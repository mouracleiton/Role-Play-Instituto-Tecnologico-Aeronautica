{
  "formatVersion": "1.0",
  "exportDate": "2025-12-03T20:17:27.202Z",
  "appVersion": "1.0",
  "curriculumData": {
    "metadata": {
      "baseOn": "Catálogo dos Cursos de Graduação 2025 - ED-17",
      "lastUpdated": "2025-12-03",
      "totalAtomicSkills": 363,
      "startDate": "2025-02-01",
      "duration": 60,
      "dailyStudyHours": 8,
      "version": "1.0",
      "institution": "Instituto Tecnológico de Aeronáutica",
      "basedOn": "Catálogo dos Cursos de Graduação 2025 - ED-17"
    },
    "areas": [
      {
        "id": "10",
        "name": "Estatística e Análise de Dados",
        "description": "Área dedicada ao estudo de métodos estatísticos, análise de dados e modelagem preditiva.",
        "disciplines": [
          {
            "id": "10.1",
            "name": "ED-17 - Análise de Séries Temporais",
            "description": "Séries temporais. Formação das bases de dados para análise: tipos de dados, importação e transformações de dados. Análise exploratória em séries temporais. Séries temporais estacionárias e seus métodos de previsão apropriados. Séries temporais não estacionárias e seus métodos de previsão apropriados. Séries temporais sazonais e seus métodos de previsão apropriados. Métodos automáticos de previsão. Aplicações em finanças, marketing e operações.",
            "mainTopics": [
              {
                "id": "10.1.1",
                "name": "Introdução às Séries Temporais",
                "description": "Conceitos fundamentais sobre séries temporais e sua importância na análise de dados sequenciais.",
                "totalSkills": 49,
                "atomicTopics": [
                  {
                    "id": "10.1.1.1",
                    "name": "Definição de Séries Temporais",
                    "description": "Conceito fundamental de séries temporais como sequências de dados observados em intervalos de tempo sucessivos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.1.1",
                        "name": "Conceito Básico de Série Temporal",
                        "description": "Entender a série temporal como uma sequência ordenada de dados coletados ao longo do tempo.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.1.1",
                            "name": "Definir série temporal",
                            "description": "Explicar que uma série temporal é uma coleção de observações feitas sequencialmente através do tempo, representando a evolução de uma variável em intervalos sucessivos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Observações Sequenciais",
                                  "subSteps": [
                                    "Leia a definição básica de observações em dados.",
                                    "Identifique exemplos de coleções de dados ordenados, como listas de compras diárias.",
                                    "Anote diferenças entre dados sequenciais e não sequenciais.",
                                    "Crie um diagrama simples mostrando ordem de observações.",
                                    "Discuta com um colega ou em voz alta o que significa 'sequencial'."
                                  ],
                                  "verification": "Listar pelo menos 3 exemplos de observações sequenciais e explicar por quê.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Caderno e caneta",
                                    "Acesso à internet para exemplos básicos"
                                  ],
                                  "tips": [
                                    "Sempre pense na ordem como uma linha do tempo natural."
                                  ],
                                  "learningObjective": "Dominar o conceito de observações coletadas em sequência.",
                                  "commonMistakes": [
                                    "Confundir sequencial com aleatório",
                                    "Ignorar a importância da ordem"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o Papel do Tempo nas Observações",
                                  "subSteps": [
                                    "Estude intervalos de tempo (diário, mensal, anual).",
                                    "Pesquise exemplos de medições ao longo do tempo, como altura de uma criança.",
                                    "Marque em um calendário pontos de observação temporal.",
                                    "Compare séries com intervalos regulares vs. irregulares.",
                                    "Registre como o tempo cria dependência entre observações."
                                  ],
                                  "verification": "Desenhar uma linha do tempo com 5 observações marcadas e intervalos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calendário ou app de linha do tempo",
                                    "Papel milimetrado"
                                  ],
                                  "tips": [
                                    "Use relógios ou calendários para visualizar o fluxo temporal."
                                  ],
                                  "learningObjective": "Entender como o tempo estrutura as observações sequenciais.",
                                  "commonMistakes": [
                                    "Tratar tempo como variável qualquer",
                                    "Esquecer dependências temporais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a Evolução de uma Variável",
                                  "subSteps": [
                                    "Defina o que é uma variável em estatística (ex: temperatura, preço).",
                                    "Observe padrões de mudança em exemplos (aumento, queda, ciclos).",
                                    "Plote um gráfico simples de uma variável ao longo do tempo.",
                                    "Descreva verbalmente a 'evolução' observada.",
                                    "Identifique fatores que influenciam a mudança da variável."
                                  ],
                                  "verification": "Plotar e descrever a evolução de uma variável em 5 pontos temporais.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets",
                                    "Dados de exemplo online"
                                  ],
                                  "tips": [
                                    "Procure tendências visuais nos gráficos para entender evolução."
                                  ],
                                  "learningObjective": "Compreender a representação da mudança de uma variável no tempo.",
                                  "commonMistakes": [
                                    "Confundir variável com tempo",
                                    "Ignorar variações aleatórias"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar a Definição Completa de Série Temporal",
                                  "subSteps": [
                                    "Reúna conceitos de steps anteriores: observações + tempo + evolução.",
                                    "Escreva a definição em suas próprias palavras.",
                                    "Compare com definições padrão de fontes confiáveis.",
                                    "Crie um fluxograma da definição.",
                                    "Teste a definição aplicando a um novo exemplo."
                                  ],
                                  "verification": "Escrever e validar a definição com um exemplo real.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Fontes online (Wikipedia, livros de estatística)",
                                    "Caderno"
                                  ],
                                  "tips": [
                                    "Use conectores como 'através do tempo' e 'intervalos sucessivos'."
                                  ],
                                  "learningObjective": "Formular a definição precisa de série temporal.",
                                  "commonMistakes": [
                                    "Omitir 'sequencialmente' ou 'evolução'",
                                    "Definir muito vagamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Coleta diária de temperaturas em São Paulo de janeiro a dezembro de 2023: cada dia representa um intervalo sucessivo, com a temperatura como variável evoluindo (ex: 25°C, 28°C, 24°C...), mostrando padrões sazonais.",
                              "finalVerifications": [
                                "Explicar a definição em palavras próprias sem erros.",
                                "Identificar corretamente uma série temporal em um conjunto de dados dado.",
                                "Diferenciar série temporal de dados cruzados.",
                                "Plotar uma série temporal simples e rotulá-la adequadamente.",
                                "Listar 3 componentes essenciais (observações, tempo, variável).",
                                "Aplicar a definição a um exemplo real sem hesitação."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude na definição (inclui sequencial, tempo, evolução).",
                                "Capacidade de exemplificar com clareza e relevância.",
                                "Uso correto de terminologia estatística.",
                                "Demonstração de compreensão conceitual via gráficos ou diagramas.",
                                "Identificação precisa de não-exemplos.",
                                "Fluência na explicação oral ou escrita."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Sequências e funções discretas.",
                                "Economia: Análise de indicadores como PIB ou inflação ao longo do tempo.",
                                "Ciências Ambientais: Dados climáticos e monitoramento ecológico.",
                                "Informática: Manipulação de dados em bancos de dados temporais (SQL TIMESTAMP)."
                              ],
                              "realWorldApplication": "Previsão de demanda em empresas (vendas diárias), monitoramento climático para alertas de enchentes, análise de ações na bolsa para investimentos, e controle de epidemias via casos reportados diariamente."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.1.2",
                            "name": "Identificar componentes essenciais",
                            "description": "Reconhecer os elementos fundamentais: ordenação temporal, observações numéricas e intervalos de tempo definidos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Séries Temporais",
                                  "subSteps": [
                                    "Defina série temporal como uma sequência de dados coletados em intervalos regulares ao longo do tempo.",
                                    "Liste os três componentes essenciais: ordenação temporal (sequência cronológica), observações numéricas (valores quantificados) e intervalos de tempo definidos (espaçamento fixo ou regular).",
                                    "Compare série temporal com dados não temporais, destacando a dependência da ordem temporal.",
                                    "Crie um diagrama simples ilustrando os três componentes interligados.",
                                    "Explique por que cada componente é indispensável para uma série temporal válida."
                                  ],
                                  "verification": "Resuma os três componentes em uma frase cada e desenhe um fluxograma conectando-os.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel, caneta, quadro branco ou ferramenta digital como Draw.io",
                                  "tips": "Use analogias cotidianas, como um diário de temperaturas diárias, para fixar os conceitos.",
                                  "learningObjective": "Explicar com precisão os três componentes essenciais de uma série temporal.",
                                  "commonMistakes": "Confundir observações numéricas com categóricas ou ignorar a regularidade dos intervalos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Ordenação Temporal em Dados",
                                  "subSteps": [
                                    "Examine um conjunto de dados e verifique se os registros estão em ordem crescente de tempo (ex: datas sequenciais).",
                                    "Detecte violações de ordenação, como dados fora de sequência cronológica.",
                                    "Ordene manualmente um conjunto de dados desordenado por timestamp.",
                                    "Analise o impacto de uma ordenação incorreta na interpretação dos dados.",
                                    "Registre exemplos de ordenação temporal em contextos reais, como logs de vendas."
                                  ],
                                  "verification": "Ordene corretamente um conjunto de 10 dados temporais misturados e justifique a sequência.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha Excel ou Google Sheets com dados de exemplo",
                                  "tips": "Sempre comece verificando a coluna de datas primeiro; use funções como SORT no Excel.",
                                  "learningObjective": "Reconhecer e corrigir ordenação temporal em conjuntos de dados.",
                                  "commonMistakes": "Ignorar fusos horários ou formatos de data inconsistentes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Reconhecer Observações Numéricas e Intervalos de Tempo",
                                  "subSteps": [
                                    "Identifique valores numéricos quantificáveis nos dados (ex: temperatura em °C, vendas em unidades).",
                                    "Meça intervalos de tempo entre observações (ex: diário, mensal) e confirme regularidade.",
                                    "Diferencie intervalos fixos (equidistantes) de irregulares e classifique o dataset.",
                                    "Calcule estatísticas básicas como média de intervalos para validar consistência.",
                                    "Crie uma tabela destacando colunas de observações numéricas e intervalos."
                                  ],
                                  "verification": "Classifique um dataset quanto a presença de observações numéricas e intervalos definidos, com cálculos de suporte.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Planilha com datasets de séries temporais (ex: temperaturas semanais)",
                                  "tips": "Use gráficos de linha para visualizar intervalos; irregularidades aparecem como gaps.",
                                  "learningObjective": "Detectar observações numéricas válidas e intervalos de tempo consistentes.",
                                  "commonMistakes": "Aceitar dados categóricos (ex: 'alto/baixo') como numéricos ou assumir intervalos sem medição."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Componentes e Validar Séries Temporais Completas",
                                  "subSteps": [
                                    "Analise um dataset completo verificando simultaneamente os três componentes.",
                                    "Documente achados em um relatório curto: presença/ausência de cada componente.",
                                    "Compare múltiplos datasets e classifique-os como séries temporais válidas ou não.",
                                    "Simule adição/remoção de componentes e observe impactos na validade.",
                                    "Discuta com um par ou autoavalie a identificação em um exemplo novo."
                                  ],
                                  "verification": "Produza um relatório de 1 página validando 3 datasets como séries temporais ou não.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "3 datasets variados (Excel), template de relatório",
                                  "tips": "Crie uma checklist: ordenação ✓, numéricas ✓, intervalos ✓ para agilizar.",
                                  "learningObjective": "Avaliar holisticamente se um conjunto de dados possui todos os componentes essenciais.",
                                  "commonMistakes": "Focar em apenas um componente e negligenciar os outros."
                                }
                              ],
                              "practicalExample": "Analise o dataset de temperaturas diárias em uma cidade: datas de 01/01/2023 a 31/01/2023 (ordenação temporal), valores em °C como 22.5, 23.1 (observações numéricas), intervalo de 1 dia (definido). Identifique se é uma série temporal válida e destaque cada componente.",
                              "finalVerifications": [
                                "Lista corretamente os três componentes essenciais sem omissões.",
                                "Identifica ordenação temporal em pelo menos 90% dos exemplos testados.",
                                "Distingue observações numéricas de não-numéricas com justificativa.",
                                "Calcula e valida intervalos de tempo em datasets irregulares.",
                                "Classifica datasets completos como séries temporais com checklist preenchida.",
                                "Explica o impacto de faltar qualquer componente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de ordenação temporal (0-3 pontos).",
                                "Correta distinção de observações numéricas (0-3 pontos).",
                                "Validação precisa de intervalos definidos (0-3 pontos).",
                                "Integração holística dos componentes (0-4 pontos).",
                                "Uso de exemplos e verificações práticas (0-3 pontos).",
                                "Clareza e completude do relatório final (0-4 pontos)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Sequências e progressões aritméticas para intervalos.",
                                "História: Linhas do tempo como ordenação temporal qualitativa.",
                                "Ciências: Registros experimentais de variáveis medidas ao longo do tempo.",
                                "Economia: Séries de preços e indicadores econômicos."
                              ],
                              "realWorldApplication": "Em previsão do tempo, analistas identificam componentes em dados de sensores para modelar tendências climáticas; em finanças, traders verificam séries de preços de ações para detectar padrões de mercado válidos antes de investir."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.1.3",
                            "name": "Diferenciar de outros tipos de dados",
                            "description": "Comparar séries temporais com dados cruzados, destacando a dependência temporal como característica única.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Dados Cruzados (Cross-Sectional Data)",
                                  "subSteps": [
                                    "Defina dados cruzados como observações coletadas em uma única ocasião para múltiplos sujeitos ou unidades.",
                                    "Identifique exemplos: renda de diferentes famílias em 2023 ou altura de alunos em uma turma.",
                                    "Note a independência: cada observação é tratada como isolada, sem ordem temporal.",
                                    "Liste características: foco em variações entre unidades, análise com regressão simples.",
                                    "Crie um diagrama simples mostrando múltiplas unidades em um snapshot temporal."
                                  ],
                                  "verification": "Crie uma tabela com 5 exemplos de dados cruzados e explique por que não há ordem temporal.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e caneta ou planilha Excel/Google Sheets para tabela.",
                                  "tips": "Use analogia de uma foto: captura um momento, não o movimento.",
                                  "learningObjective": "Distinguir dados cruzados por sua natureza estática e independente.",
                                  "commonMistakes": "Confundir com dados longitudinais que seguem as mesmas unidades ao longo do tempo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender Séries Temporais",
                                  "subSteps": [
                                    "Defina série temporal como sequência de dados coletados em intervalos regulares ao longo do tempo.",
                                    "Identifique exemplos: temperatura diária em uma cidade ou preço de ações por dia.",
                                    "Enfatize a ordem temporal: dados são indexados por tempo (t=1, t=2...).",
                                    "Descreva componentes: tendência, sazonalidade, ciclos e ruído.",
                                    "Plote um gráfico simples de uma série temporal fictícia."
                                  ],
                                  "verification": "Desenhe um gráfico de linha com 10 pontos sequenciais e rotule o eixo temporal.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Ferramenta de plotagem como Excel, Python (Matplotlib) ou papel milimetrado.",
                                  "tips": "Pense como um vídeo: mostra evolução, não snapshot.",
                                  "learningObjective": "Reconhecer a estrutura sequencial e dependência inerente das séries temporais.",
                                  "commonMistakes": "Ignorar a ordenação temporal e tratá-las como dados independentes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Dependência Temporal como Característica Única",
                                  "subSteps": [
                                    "Explique dependência temporal: valor atual depende de valores passados (autocorrelação).",
                                    "Compare com independência em dados cruzados: covariância zero entre observações.",
                                    "Calcule autocorrelação simples em um exemplo de série temporal.",
                                    "Discuta implicações: viola suposições de modelos independentes como regressão OLS.",
                                    "Crie uma matriz de correlação para ilustrar dependência serial."
                                  ],
                                  "verification": "Calcule e interprete a autocorrelação de lag 1 em uma série de 20 pontos.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Calculadora ou software como R/Python para autocorrelação.",
                                  "tips": "Teste: embaralhe a série temporal; se o padrão sumir, há dependência temporal.",
                                  "learningObjective": "Destaque a dependência temporal como o diferenciador chave.",
                                  "commonMistakes": "Assumir independência em séries temporais, levando a erros de modelagem."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar e Diferenciar com Exemplos Práticos",
                                  "subSteps": [
                                    "Monte uma tabela comparativa: colunas para tipo de dados, dependência, análise típica, exemplos.",
                                    "Analise um dataset misto: identifique partes cruzadas vs. temporais.",
                                    "Discuta quando usar cada: cruzados para comparações estáticas, temporais para previsões.",
                                    "Crie um fluxograma para classificar um dataset como cruzado ou temporal.",
                                    "Resolva 3 exercícios de classificação de datasets reais."
                                  ],
                                  "verification": "Classifique corretamente 5 datasets como cruzado ou temporal com justificativa.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Tabela comparativa em documento ou planilha; datasets de exemplo online.",
                                  "tips": "Pergunte: 'Os dados têm ordem de tempo e dependem dela?'",
                                  "learningObjective": "Aplicar comparação para diferenciar tipos de dados com confiança.",
                                  "commonMistakes": "Confundir painéis (panel data) que combinam ambos."
                                }
                              ],
                              "practicalExample": "Compare dados de vendas: (1) Vendas de 100 lojas no dia 01/01/2024 (cruzados: independentes entre lojas). (2) Vendas diárias de uma loja de Jan a Dez 2023 (temporal: vendas de hoje dependem de ontem devido a tendências). Plote ambos e calcule autocorrelação para ver a diferença.",
                              "finalVerifications": [
                                "Explique verbalmente a diferença principal entre séries temporais e dados cruzados.",
                                "Identifique dependência temporal em um gráfico fornecido.",
                                "Classifique 3 datasets reais como um dos tipos com >90% acurácia.",
                                "Crie uma tabela comparativa completa sem erros.",
                                "Discuta uma implicação errada de tratar série temporal como cruzada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de dependência temporal (peso 25%).",
                                "Uso correto de exemplos e contrastes (peso 20%).",
                                "Demonstração de autocorrelação ou visualizações (peso 20%).",
                                "Capacidade de classificação em fluxogramas/exercícios (peso 20%).",
                                "Clareza na explicação oral/escrita (peso 15%)."
                              ],
                              "crossCurricularConnections": [
                                "Economia: Análise de PIB trimestral (temporal) vs. PIB per capita por país (cruzado).",
                                "Ciências Ambientais: Temperatura mensal (temporal) vs. poluição por cidade (cruzado).",
                                "Finanças: Preços de ações diários (temporal) vs. ratings de empresas (cruzado).",
                                "História: Evolução de eventos ao longo do tempo (temporal) vs. comparações entre civilizações (cruzado)."
                              ],
                              "realWorldApplication": "Em previsão de demanda de varejo, diferenciar vendas diárias (série temporal, usar ARIMA) de perfil de clientes (cruzados, usar clustering) evita erros de estoque e otimiza supply chain."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.1.2",
                        "name": "Intervalos de Tempo Sucessivos",
                        "description": "Compreender os intervalos regulares ou irregulares nos quais as observações são registradas.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.2.1",
                            "name": "Classificar frequências temporais",
                            "description": "Identificar e classificar intervalos como diários, mensais, anuais ou irregulares em exemplos de séries temporais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender as definições de frequências temporais básicas",
                                  "subSteps": [
                                    "Revise as definições: diária (dados coletados todos os dias), mensal (a cada mês), anual (uma vez por ano) e irregular (sem padrão fixo).",
                                    "Leia exemplos: temperatura diária vs. PIB anual.",
                                    "Anote as diferenças chave em um quadro comparativo.",
                                    "Discuta com um parceiro ou anote dúvidas.",
                                    "Confirme compreensão com flashcards personalizados."
                                  ],
                                  "verification": "Criar um quadro comparativo com definições e exemplos corretos para cada frequência.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Quadro branco ou papel",
                                    "Marcadores",
                                    "Acesso a glossário de séries temporais online"
                                  ],
                                  "tips": "Use mnemônicos como 'Diário = Dia a dia' para memorizar.",
                                  "learningObjective": "Definir e diferenciar as quatro frequências temporais principais.",
                                  "commonMistakes": [
                                    "Confundir mensal com semanal",
                                    "Ignorar irregular como uma categoria válida"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar padrões de frequência em gráficos e tabelas simples",
                                  "subSteps": [
                                    "Observe 5 gráficos de séries temporais fornecidos (ex: temperatura, vendas).",
                                    "Conte os intervalos entre pontos de dados.",
                                    "Marque o eixo temporal e identifique o espaçamento.",
                                    "Classifique cada um provisoriamente como diário, mensal, anual ou irregular.",
                                    "Compare com definições do passo 1."
                                  ],
                                  "verification": "Rotular corretamente os intervalos em 5 gráficos de exemplo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráficos impressos ou digitais de séries temporais",
                                    "Lápis e régua para medir eixos"
                                  ],
                                  "tips": "Foque no eixo x (tempo) primeiro; ignore valores y inicialmente.",
                                  "learningObjective": "Reconhecer visualmente padrões de frequência em representações gráficas.",
                                  "commonMistakes": [
                                    "Assumir frequência pelo tema (ex: vendas sempre mensais)",
                                    "Não notar lacunas que indicam irregularidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Praticar classificação em conjuntos de dados tabulares",
                                  "subSteps": [
                                    "Selecione 4 tabelas de dados temporais (ex: chuva diária, lucros anuais).",
                                    "Liste as datas e calcule diferenças médias entre observações.",
                                    "Classifique cada tabela usando critérios: diária (<2 dias), mensal (~30 dias), anual (~365 dias), irregular (variável).",
                                    "Registre classificações em uma planilha.",
                                    "Valide com fórmula simples de diferença de datas."
                                  ],
                                  "verification": "Classificar corretamente 4 tabelas com justificativa escrita para cada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets",
                                    "Amostras de dados tabulares (10-20 linhas cada)"
                                  ],
                                  "tips": "Use função DATEDIF no Excel para automatizar cálculos de intervalos.",
                                  "learningObjective": "Aplicar cálculos quantitativos para confirmar classificações de frequência.",
                                  "commonMistakes": [
                                    "Arredondar incorretamente intervalos (ex: 28 dias como mensal)",
                                    "Omitir verificação de consistência em todas as linhas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e verificar classificações em cenários mistos",
                                  "subSteps": [
                                    "Analise um dataset misto com múltiplas séries (ex: economia com dados diários e anuais).",
                                    "Classifique cada sub-série independentemente.",
                                    "Identifique e explique qualquer irregularidade.",
                                    "Crie um relatório resumido com classificações.",
                                    "Teste com auto-perguntas: 'Por que não semanal?'"
                                  ],
                                  "verification": "Produzir relatório com 100% de acurácia em 3 cenários mistos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Dataset misto (ex: arquivo CSV de clima e economia)",
                                    "Ferramenta de análise como Excel"
                                  ],
                                  "tips": "Comece pelas séries mais óbvias para ganhar confiança.",
                                  "learningObjective": "Integrar conhecimento para classificar frequências em contextos complexos e mistos.",
                                  "commonMistakes": [
                                    "Classificar toda a série pelo primeiro dado",
                                    "Não detectar sub-séries irregulares"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um dataset de vendas de uma loja: datas 2023-01-01, 2023-01-02, ..., diária; vs. PIB: 2020, 2021, 2022, anual; vs. eventos promocionais esporádicos, irregular.",
                              "finalVerifications": [
                                "Classifica corretamente 10 exemplos variados sem erros.",
                                "Explica diferenças entre frequências em termos próprios.",
                                "Identifica irregularidades em 80% dos casos com evidência.",
                                "Aplica critérios quantitativos (ex: média de intervalos) consistentemente.",
                                "Cria quadro comparativo completo e preciso.",
                                "Demonstra em relatório misto sem inconsistências."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação: 90%+ acertos em classificações.",
                                "Justificativa detalhada: inclui cálculos ou observações visuais.",
                                "Cobertura completa: trata diária, mensal, anual e irregular.",
                                "Eficiência: completa tarefas dentro do tempo estimado.",
                                "Criatividade: usa exemplos reais ou visuais próprios.",
                                "Auto-correção: identifica e corrige erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de diferenças e médias em datas.",
                                "Economia: Classificação de indicadores como PIB anual ou vendas diárias.",
                                "Ciências Ambientais: Séries de temperatura diária vs. eventos climáticos irregulares.",
                                "Informática: Uso de planilhas para análise temporal.",
                                "História: Análise de eventos anuais ou irregulares em timelines."
                              ],
                              "realWorldApplication": "Em previsão de demanda (vendas diárias vs. trimestrais), monitoramento climático (temperaturas diárias para alertas), análise financeira (relatórios anuais vs. transações irregulares) ou planejamento urbano (tráfego diário vs. eventos anuais)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.2.2",
                            "name": "Explicar sucessão temporal",
                            "description": "Descrever como as observações sucessivas capturam a dinâmica temporal, permitindo análise de padrões ao longo do tempo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o conceito de sucessão temporal",
                                  "subSteps": [
                                    "Pesquise definições de séries temporais e sucessão temporal em fontes confiáveis.",
                                    "Identifique que sucessão temporal refere-se a observações ordenadas cronologicamente.",
                                    "Diferencie sucessão temporal de dados aleatórios ou não ordenados.",
                                    "Registre exemplos simples de sucessão em um caderno.",
                                    "Resuma o conceito em uma frase própria."
                                  ],
                                  "verification": "Escreva uma definição clara e compare com fontes padrão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de estatística, acesso à internet, caderno.",
                                  "tips": "Use uma linha do tempo visual para ilustrar a ordenação.",
                                  "learningObjective": "Compreender a base conceitual de ordenação temporal em observações.",
                                  "commonMistakes": "Confundir sucessão temporal com mera sequência numérica sem ordem de tempo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explicar observações sucessivas",
                                  "subSteps": [
                                    "Colete dados de exemplo com múltiplas observações no tempo, como temperaturas diárias.",
                                    "Marque cada observação com sua data/hora exata.",
                                    "Descreva como cada observação segue a anterior, formando uma cadeia.",
                                    "Crie um gráfico simples de linha mostrando a sequência.",
                                    "Anote como a proximidade temporal afeta a interpretação."
                                  ],
                                  "verification": "Construa um gráfico com pelo menos 5 observações sucessivas e explique a sequência.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Planilha Excel ou Google Sheets, dados de exemplo (ex: temperaturas).",
                                  "tips": "Escolha intervalos regulares para facilitar a visualização.",
                                  "learningObjective": "Identificar e representar observações em sucessão temporal.",
                                  "commonMistakes": "Ignorar lacunas ou irregularidades nos intervalos de tempo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Descrever a captura de dinâmica temporal",
                                  "subSteps": [
                                    "Analise como observações sucessivas revelam mudanças, tendências e variações.",
                                    "Identifique componentes como tendência, sazonalidade e ruído em um exemplo.",
                                    "Explique que a sucessão permite modelar evolução ao longo do tempo.",
                                    "Compare com instantâneas isoladas para destacar a vantagem.",
                                    "Documente a dinâmica em um diagrama de fluxo."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito como a sucessão captura mudanças em um exemplo.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Gráficos de séries temporais de exemplos reais, software de plotagem (ex: Python Matplotlib).",
                                  "tips": "Pense em 'filme' vs 'fotos': sucessão é o filme em movimento.",
                                  "learningObjective": "Explicar como a sucessão temporal modela dinâmicas evolutivas.",
                                  "commonMistakes": "Focar apenas em valores numéricos sem considerar o tempo como variável."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar padrões ao longo do tempo",
                                  "subSteps": [
                                    "Aplique técnicas básicas como cálculo de médias móveis em dados sucessivos.",
                                    "Identifique padrões como ciclos ou tendências em séries reais.",
                                    "Discuta como sucessão permite previsões baseadas em padrões passados.",
                                    "Crie um relatório curto com análise de um exemplo.",
                                    "Valide padrões com testes visuais ou estatísticos simples."
                                  ],
                                  "verification": "Produza uma análise de padrões em uma série temporal curta com conclusões claras.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Dados de séries temporais (ex: ações ou clima), calculadora ou software.",
                                  "tips": "Comece com séries curtas para evitar sobrecarga de dados.",
                                  "learningObjective": "Demonstrar análise de padrões temporais via sucessão.",
                                  "commonMistakes": "Sobre-generalizar padrões de poucas observações sem evidência."
                                }
                              ],
                              "practicalExample": "Em uma série de temperaturas diárias: 20°C (dia 1), 22°C (dia 2), 21°C (dia 3), 25°C (dia 4), 23°C (dia 5). As observações sucessivas capturam a dinâmica de aquecimento gradual, permitindo detectar um padrão de aumento com flutuações.",
                              "finalVerifications": [
                                "Pode definir sucessão temporal com precisão?",
                                "Consegue criar um gráfico de observações sucessivas?",
                                "Explica como captura dinâmica temporal em um exemplo?",
                                "Identifica padrões em uma série simples?",
                                "Diferencia sucessão de dados não temporais?",
                                "Descreve análise de padrões ao longo do tempo?"
                              ],
                              "assessmentCriteria": [
                                "Clareza e precisão na definição de sucessão temporal (1-5).",
                                "Qualidade da representação gráfica de observações sucessivas (1-5).",
                                "Profundidade na explicação da dinâmica temporal (1-5).",
                                "Identificação correta de padrões e tendências (1-5).",
                                "Uso apropriado de exemplos concretos (1-5).",
                                "Capacidade de diferenciação conceitual (1-5)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Sequências e funções discretas.",
                                "Física: Análise de movimento e aceleração temporal.",
                                "Geografia: Monitoramento de fenômenos climáticos.",
                                "Economia: Análise de tendências de mercado."
                              ],
                              "realWorldApplication": "Em meteorologia, sucessão temporal de dados de temperatura permite prever ondas de calor analisando padrões de aumento sucessivo, auxiliando em alertas públicos e planejamento agrícola."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.1.3",
                        "name": "Exemplos e Aplicações Iniciais",
                        "description": "Relacionar a definição com exemplos reais para fixar o conceito.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.3.1",
                            "name": "Reconhecer exemplos clássicos",
                            "description": "Identificar séries temporais em contextos como temperaturas diárias, preços de ações ou vendas mensais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Definição e Características de Séries Temporais",
                                  "subSteps": [
                                    "Ler a definição: uma série temporal é uma sequência de observações de uma variável coletadas em intervalos regulares de tempo.",
                                    "Identificar os componentes principais: tendência (mudança gradual), sazonalidade (padrões repetitivos), ciclos e ruído aleatório.",
                                    "Analisar a importância da ordem temporal nos dados."
                                  ],
                                  "verification": "Escrever uma definição em suas próprias palavras e listar os 4 componentes principais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Acesso a um tutorial online sobre séries temporais (ex: Khan Academy ou Wikipedia)",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Sempre enfatize o aspecto 'temporal' e a regularidade dos intervalos.",
                                  "learningObjective": "Dominar os conceitos fundamentais que distinguem séries temporais de outros dados.",
                                  "commonMistakes": [
                                    "Confundir séries temporais com dados estáticos ou cruzados.",
                                    "Ignorar a sequência cronológica dos dados."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Exemplos Clássicos de Séries Temporais",
                                  "subSteps": [
                                    "Examinar temperaturas diárias: dados coletados todo dia em uma estação meteorológica.",
                                    "Analisar preços de ações: valores de fechamento diário de uma empresa na bolsa.",
                                    "Revisar vendas mensais: registros de vendas de um produto ao longo de meses.",
                                    "Plotar graficamente um desses exemplos para visualizar a sequência temporal."
                                  ],
                                  "verification": "Desenhar um gráfico simples de um exemplo clássico e rotulá-lo corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de plotagem gratuita como Google Sheets ou Desmos",
                                    "Dados de exemplo: temperaturas diárias de uma cidade (disponíveis online)"
                                  ],
                                  "tips": "Use gráficos de linha para destacar a progressão temporal.",
                                  "learningObjective": "Reconhecer padrões visuais e contextuais em exemplos clássicos.",
                                  "commonMistakes": [
                                    "Tratar dados temporais como independentes.",
                                    "Confundir correlação temporal com causalidade."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Praticar a Identificação em Contextos Variados",
                                  "subSteps": [
                                    "Listar 5 conjuntos de dados potenciais e classificar quais são séries temporais.",
                                    "Identificar temperaturas diárias, preços de ações e vendas mensais como 'sim'.",
                                    "Comparar com não-exemplos: lista de alturas de alunos (não temporal).",
                                    "Explicar o motivo para cada classificação."
                                  ],
                                  "verification": "Criar uma tabela com 5 exemplos e classificações corretas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets",
                                    "Lista de dados de exemplo impressa ou digital"
                                  ],
                                  "tips": "Pergunte: 'Os dados são ordenados por tempo regular?'",
                                  "learningObjective": "Aplicar o reconhecimento de forma autônoma em novos contextos.",
                                  "commonMistakes": [
                                    "Classificar dados ordenados por outro critério como temporais.",
                                    "Subestimar a regularidade dos intervalos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar Séries Temporais de Outros Tipos de Dados",
                                  "subSteps": [
                                    "Comparar série temporal (ex: preços diários) com dados cruzados (ex: pesquisa de opinião).",
                                    "Destacar dependência temporal vs. independência.",
                                    "Testar com quiz: identificar 3 sim e 3 não.",
                                    "Refletir sobre aplicações exclusivas de séries temporais."
                                  ],
                                  "verification": "Completar um quiz com 80% de acerto e justificar respostas erradas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Quiz online ou impresso sobre tipos de dados",
                                    "Vídeo curto explicativo (YouTube: 'Séries Temporais vs Outros Dados')"
                                  ],
                                  "tips": "Lembre: sem ordem de tempo regular, não é série temporal.",
                                  "learningObjective": "Evitar confusões comuns ao distinguir tipos de dados.",
                                  "commonMistakes": [
                                    "Assumir que qualquer gráfico de linha é série temporal.",
                                    "Ignorar intervalos irregulares."
                                  ]
                                }
                              ],
                              "practicalExample": "Analise os dados de temperatura diária média de São Paulo de janeiro a dezembro de 2023. Identifique se é uma série temporal, liste componentes visíveis (tendência sazonal de verão/inverno) e plote o gráfico.",
                              "finalVerifications": [
                                "Listar corretamente 3 exemplos clássicos: temperaturas diárias, preços de ações, vendas mensais.",
                                "Explicar em 2-3 frases por que um dado forma uma série temporal.",
                                "Diferenciar 2 exemplos de séries temporais de dados não-temporais.",
                                "Plotar e rotular um gráfico de série temporal simples.",
                                "Identificar componentes (tendência, sazonalidade) em um exemplo dado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e componentes (90% correto).",
                                "Capacidade de identificar exemplos clássicos sem erros.",
                                "Justificativas claras e lógicas para classificações.",
                                "Qualidade visual e rotulagem de gráficos.",
                                "Diferenciação consistente de outros tipos de dados."
                              ],
                              "crossCurricularConnections": [
                                "Economia: Análise de tendências de mercado e previsão de ações.",
                                "Ciência Ambiental: Monitoramento climático e mudanças globais.",
                                "Negócios: Previsão de vendas e gestão de estoque.",
                                "Matemática: Estudo de funções e modelagem contínua.",
                                "Geografia: Padrões climáticos regionais ao longo do tempo."
                              ],
                              "realWorldApplication": "No dia a dia, meteorologistas usam séries temporais de temperaturas para previsões; analistas financeiros rastreiam preços de ações para investimentos; gerentes de vendas preveem demandas mensais para otimizar estoques e estratégias empresariais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.3.2",
                            "name": "Associar à bibliografia",
                            "description": "Referenciar definições de autores como Enders e Ehlers para embasar o conceito de séries temporais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar autores e obras chave sobre séries temporais",
                                  "subSteps": [
                                    "Realize uma busca em bases acadêmicas como Google Scholar ou SciELO por 'definição de séries temporais'",
                                    "Liste autores clássicos como Walter Enders ('Applied Econometric Time Series') e Christian Ehlers ou similares",
                                    "Compile uma lista inicial de 5-10 referências bibliográficas relevantes",
                                    "Verifique a credibilidade das fontes (editoras acadêmicas, citações altas)",
                                    "Anote resumos ou abstracts para triagem inicial"
                                  ],
                                  "verification": "Lista de pelo menos 5 referências bibliográficas com autores, títulos e anos compilada e salva em documento.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Acesso à internet (Google Scholar, JSTOR)",
                                    "Bloco de notas ou Google Docs"
                                  ],
                                  "tips": "Use palavras-chave como 'introdução séries temporais Enders' para resultados precisos.",
                                  "learningObjective": "Dominar a identificação de fontes bibliográficas fundamentais em análise de séries temporais.",
                                  "commonMistakes": [
                                    "Selecionar blogs ou fontes não peer-reviewed",
                                    "Ignorar autores contemporâneos além dos clássicos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Extrair e analisar definições de autores selecionados",
                                  "subSteps": [
                                    "Acesse capítulos introdutórios dos livros de Enders e Ehlers via PDF ou biblioteca",
                                    "Extraia definições explícitas de séries temporais (ex: Enders: sequências ordenadas no tempo com dependência serial)",
                                    "Registre contextos de aplicação mencionados pelos autores",
                                    "Compare definições entre autores para identificar consensos e diferenças",
                                    "Anote citações exatas com páginas para evitar plágio"
                                  ],
                                  "verification": "Resumo comparativo de 3 definições com citações diretas documentado.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livros digitais ou físicos de Enders e Ehlers",
                                    "Leitor PDF (Adobe Acrobat)",
                                    "Planilha Excel para comparação"
                                  ],
                                  "tips": "Foque em definições formais nos primeiros capítulos para precisão.",
                                  "learningObjective": "Compreender e extrair conceitos teóricos de fontes primárias.",
                                  "commonMistakes": [
                                    "Parafrasear sem citar página exata",
                                    "Confundir definições com exemplos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Associar definições bibliográficas ao conceito de séries temporais",
                                  "subSteps": [
                                    "Escreva uma definição própria de séries temporais baseada no contexto do currículo",
                                    "Integre referências: 'Conforme Enders (2014, p. 2), séries temporais são...'",
                                    "Explique como as definições embasam exemplos iniciais (ex: previsão de vendas)",
                                    "Crie um parágrafo coeso unindo teoria bibliográfica e aplicações",
                                    "Revise para fluidez e coerência acadêmica"
                                  ],
                                  "verification": "Parágrafo integrado com pelo menos 2 citações bibliográficas pronto e revisado.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Editor de texto (Word ou LaTeX)",
                                    "Guia de normas ABNT ou APA"
                                  ],
                                  "tips": "Use conectores como 'segundo', 'conforme' para associações naturais.",
                                  "learningObjective": "Habilitar a integração de bibliografia em explicações conceituais.",
                                  "commonMistakes": [
                                    "Citar sem contextualizar",
                                    "Exceder cotações diretas sem análise"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formatar referências e verificar a associação",
                                  "subSteps": [
                                    "Formate a lista de referências no estilo ABNT ou APA",
                                    "Inclua DOI ou links para acesso online quando disponível",
                                    "Realize autoavaliação: a bibliografia embasa adequadamente o conceito?",
                                    "Peça feedback de pares ou tutor sobre precisão",
                                    "Atualize o documento final com referências completas"
                                  ],
                                  "verification": "Lista de referências formatada e documento final com associações validadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de formatação bibliográfica (Mendeley ou Zotero)",
                                    "Normas de citação impressas"
                                  ],
                                  "tips": "Automatize com Zotero para evitar erros de digitação.",
                                  "learningObjective": "Aplicar normas de citação corretas em contextos acadêmicos.",
                                  "commonMistakes": [
                                    "Erros em formatação (ex: itálico em títulos)",
                                    "Omitir ano ou editora"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um relatório sobre análise de séries temporais para previsão de preços de ações, associe: 'Séries temporais, conforme definido por Enders (2014, p. 2), são sequências de dados ordenados temporalmente com autocorrelação, aplicável aqui aos retornos diários do IBOVESPA, alinhando-se à visão de Ehlers sobre componentes cíclicos.'",
                              "finalVerifications": [
                                "Pelo menos 2 autores referenciados corretamente com páginas",
                                "Definições extraídas embasam a definição curricular de séries temporais",
                                "Lista de referências completa e formatada",
                                "Associações mostram compreensão conceitual",
                                "Ausência de plágio (uso de aspas e parafraseio)",
                                "Integração fluida em texto explicativo"
                              ],
                              "assessmentCriteria": [
                                "Precisão e relevância das citações (30%)",
                                "Profundidade da análise comparativa (25%)",
                                "Correção na formatação bibliográfica (20%)",
                                "Coerência na associação ao conceito (15%)",
                                "Originalidade e clareza do texto integrado (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Metodologia Científica: Normas de citação e pesquisa bibliográfica",
                                "Língua Portuguesa: Redação acadêmica e parafraseio",
                                "História da Estatística: Evolução conceitual via autores clássicos",
                                "Economia: Aplicações de séries temporais em previsões econômicas"
                              ],
                              "realWorldApplication": "Em relatórios profissionais de análise de dados (ex: bancos, consultorias), teses acadêmicas ou artigos científicos, onde referenciar Enders e Ehlers embasa análises de tendências temporais em finanças, meteorologia ou epidemiologia, garantindo credibilidade e rigor metodológico."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.3.3",
                            "name": "Visualizar uma série temporal simples",
                            "description": "Desenhar ou descrever graficamente uma sequência básica de dados temporais para ilustrar a definição.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Séries Temporais",
                                  "subSteps": [
                                    "Defina o que é uma série temporal: uma sequência de dados coletados em intervalos regulares de tempo.",
                                    "Identifique componentes essenciais: tempo (eixo horizontal) e valores observados (eixo vertical).",
                                    "Reúna um conjunto de dados simples, como temperaturas diárias por 7 dias.",
                                    "Discuta exemplos reais, como vendas mensais ou níveis de rio.",
                                    "Anote os dados em uma tabela com colunas para data e valor."
                                  ],
                                  "verification": "Criar uma tabela organizada com pelo menos 5 pontos de dados temporais e definições claras anotadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Lápis e borracha",
                                    "Exemplo de dados impresso ou anotado"
                                  ],
                                  "tips": "Comece com dados reais ou simulados para maior engajamento; use intervalos uniformes como dias ou meses.",
                                  "learningObjective": "Entender a estrutura fundamental de uma série temporal e preparar dados iniciais.",
                                  "commonMistakes": [
                                    "Confundir séries temporais com dados não ordenados",
                                    "Ignorar a ordem cronológica dos dados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar os Eixos e Escala do Gráfico",
                                  "subSteps": [
                                    "Desenhe os eixos: horizontal para tempo (datas) e vertical para valores (ex: temperatura em °C).",
                                    "Escolha uma escala apropriada: marque intervalos regulares nos eixos baseados nos dados.",
                                    "Rotule os eixos claramente: 'Tempo (dias)' e 'Temperatura (°C)'.",
                                    "Adicione título ao gráfico: 'Temperatura Diária na Semana'.",
                                    "Plote pontos iniciais sem conectar para verificar alinhamento."
                                  ],
                                  "verification": "Eixos desenhados com escalas corretas, rótulos visíveis e pontos iniciais plotados com precisão.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Régua",
                                    "Marcadores coloridos"
                                  ],
                                  "tips": "Use régua para linhas retas; escale para que todos os dados caibam sem distorção.",
                                  "learningObjective": "Configurar um gráfico de linha temporal com eixos e escalas precisas.",
                                  "commonMistakes": [
                                    "Escalas irregulares que distorcem os dados",
                                    "Rótulos omitidos ou ilegíveis"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Plotar e Conectar os Dados",
                                  "subSteps": [
                                    "Plote todos os pontos de dados nos eixos correspondentes.",
                                    "Conecte os pontos com linhas retas para formar a série temporal.",
                                    "Destaque tendências visuais, como aumentos ou diminuições.",
                                    "Adicione marcadores nos pontos para maior clareza.",
                                    "Verifique a sequência temporal: pontos devem progredir da esquerda para a direita."
                                  ],
                                  "verification": "Todos os pontos plotados corretamente, conectados em ordem temporal, sem erros de posicionamento.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado com eixos prontos",
                                    "Canetas coloridas"
                                  ],
                                  "tips": "Use cores diferentes para séries múltiplas se aplicável; mantenha linhas suaves mas precisas.",
                                  "learningObjective": "Visualizar graficamente a sequência temporal de dados.",
                                  "commonMistakes": [
                                    "Plotar pontos fora de ordem temporal",
                                    "Conectar pontos incorretamente, criando loops"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e Finalizar a Visualização",
                                  "subSteps": [
                                    "Analise o gráfico: identifique padrões como tendência crescente ou picos.",
                                    "Adicione legendas ou anotações para eventos chave.",
                                    "Compare com a definição original de série temporal.",
                                    "Descreva verbalmente ou por escrito o que o gráfico ilustra.",
                                    "Revise o gráfico inteiro por completude e legibilidade."
                                  ],
                                  "verification": "Relatório curto (3-5 frases) descrevendo o gráfico e sua relação com séries temporais.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Gráfico finalizado",
                                    "Folha para anotações"
                                  ],
                                  "tips": "Peça feedback de um par para perspectivas adicionais; use setas para destacar padrões.",
                                  "learningObjective": "Interpretar visualmente uma série temporal e comunicá-la efetivamente.",
                                  "commonMistakes": [
                                    "Ignorar padrões óbvios",
                                    "Sobrecarregar o gráfico com anotações desnecessárias"
                                  ]
                                }
                              ],
                              "practicalExample": "Visualize a temperatura diária em uma cidade por 7 dias: Dia 1: 20°C, Dia 2: 22°C, Dia 3: 21°C, Dia 4: 25°C, Dia 5: 28°C, Dia 6: 26°C, Dia 7: 24°C. Plote em um gráfico de linha para mostrar a tendência de aquecimento seguida de resfriamento leve.",
                              "finalVerifications": [
                                "Gráfico possui eixos tempo-valor claramente rotulados.",
                                "Todos os dados estão plotados em ordem cronológica.",
                                "Linhas conectam pontos sequencialmente sem interrupções.",
                                "Tendências ou padrões são visualmente discerníveis.",
                                "Título e legendas (se aplicável) estão presentes.",
                                "Gráfico é legível e sem erros de escala."
                              ],
                              "assessmentCriteria": [
                                "Precisão na plotagem de dados (100% dos pontos corretos).",
                                "Clareza e legibilidade dos elementos gráficos (rótulos, escalas).",
                                "Correta representação temporal (ordem e intervalos).",
                                "Identificação de pelo menos um padrão ou tendência.",
                                "Criatividade na apresentação sem comprometer a precisão.",
                                "Descrição escrita concisa e relevante."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Construção de gráficos cartesianos e escalas.",
                                "Geografia: Visualização de dados climáticos ou demográficos ao longo do tempo.",
                                "Ciências: Séries temporais em experimentos de crescimento ou medições ambientais.",
                                "História: Linhas do tempo de eventos históricos.",
                                "Economia: Gráficos de vendas ou PIB ao longo dos anos."
                              ],
                              "realWorldApplication": "Em meteorologia, visualizar séries temporais de temperatura ajuda a prever padrões climáticos; em negócios, gráficos de vendas diárias identificam sazonalidades para otimizar estoques."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.2",
                    "name": "Importância das Séries Temporais",
                    "description": "Relevância na análise de dados sequenciais e aplicações em áreas como finanças, marketing e operações.",
                    "individualConcepts": [
                      {
                        "id": "17.1.1.2.1",
                        "name": "Relevância na Análise de Dados Sequenciais",
                        "description": "Compreender a importância das séries temporais para dados ordenados no tempo, destacando a captura de dependências temporais e autocorrelações que diferem das análises de dados independentes.",
                        "specificSkills": [
                          {
                            "id": "17.1.1.2.1.1",
                            "name": "Identificar dados sequenciais",
                            "description": "Diferenciar séries temporais de dados cruzados ou independentes, reconhecendo características como frequência temporal e ordenação cronológica em conjuntos de dados reais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Dados Sequenciais e Séries Temporais",
                                  "subSteps": [
                                    "Defina dados sequenciais como observações coletadas em ordem cronológica ou temporal.",
                                    "Explique séries temporais como um tipo específico de dados sequenciais com dependência temporal entre observações.",
                                    "Identifique exemplos iniciais, como medições diárias de temperatura ou preços de ações ao longo do tempo.",
                                    "Diferencie de dados independentes, onde a ordem não importa, como alturas de pessoas em uma amostra.",
                                    "Revise definições chave: ordenação cronológica e frequência temporal (diária, mensal, etc.)."
                                  ],
                                  "verification": "Resuma em suas palavras as diferenças entre dados sequenciais e independentes, com pelo menos dois exemplos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Vídeo introdutório sobre séries temporais (YouTube: 'Time Series Basics')",
                                    "Folha de anotações",
                                    "Glossário de termos estatísticos"
                                  ],
                                  "tips": [
                                    "Use analogias cotidianas, como um diário vs. uma lista de compras aleatória.",
                                    "Anote definições em um mapa mental para visualização."
                                  ],
                                  "learningObjective": "Dominar definições fundamentais de dados sequenciais e séries temporais.",
                                  "commonMistakes": [
                                    "Confundir ordenação cronológica com mera sequência numérica.",
                                    "Ignorar a dependência temporal em séries temporais."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Reconhecer Características Chave: Frequência Temporal e Ordenação Cronológica",
                                  "subSteps": [
                                    "Analise a ordenação cronológica: verifique se os dados estão indexados por tempo (datas, horas).",
                                    "Identifique frequência temporal: determine intervalos regulares (ex.: diário, semanal).",
                                    "Examine gráficos de linha para visualizar continuidade temporal vs. dispersão.",
                                    "Pratique rotulando eixos temporais em conjuntos de dados simulados.",
                                    "Compare com dados sem ordenação temporal para reforçar o reconhecimento."
                                  ],
                                  "verification": "Marque corretamente 5 conjuntos de dados como 'sequencial' ou 'não sequencial' com justificativa temporal.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Planilha Excel com datasets de exemplo (temperatura diária vs. salários por profissão)",
                                    "Gráficos prontos para análise",
                                    "Ferramenta online como Google Sheets"
                                  ],
                                  "tips": [
                                    "Sempre pergunte: 'A ordem importa para a análise?'",
                                    "Use cores para destacar timestamps nos dados."
                                  ],
                                  "learningObjective": "Identificar precisamente frequência e ordenação em dados reais.",
                                  "commonMistakes": [
                                    "Assumir alta frequência como critério único, ignorando irregularidades.",
                                    "Confundir correlação temporal com causalidade."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar Séries Temporais de Dados Cruzados e Independentes",
                                  "subSteps": [
                                    "Defina dados cruzados: observações em múltiplas unidades no mesmo período (ex.: PIB de países em 2023).",
                                    "Defina dados independentes: sem estrutura temporal ou espacial (ex.: resultados de testes aleatórios).",
                                    "Crie uma tabela comparativa: colunas para tipo de dados, características e exemplos.",
                                    "Analise 3 pares de datasets: um sequencial vs. um cruzado/independente.",
                                    "Discuta por que a diferenciação afeta métodos de análise (ex.: ARIMA para temporais)."
                                  ],
                                  "verification": "Classifique corretamente 10 datasets mistos em uma tabela comparativa com explicações.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Datasets reais (Kaggle: 'Daily Temperature' vs. 'Country GDP Snapshot')",
                                    "Tabela modelo em PDF",
                                    "Caneta e papel para rascunhos"
                                  ],
                                  "tips": [
                                    "Pense em 'quando' vs. 'onde/quem': temporal foca no tempo.",
                                    "Teste invertendo a ordem dos dados sequenciais para ver se perde sentido."
                                  ],
                                  "learningObjective": "Diferenciar com precisão tipos de dados baseados em estrutura temporal.",
                                  "commonMistakes": [
                                    "Classificar dados cruzados com leve ordenação como sequenciais.",
                                    "Subestimar independência em amostras grandes."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o Reconhecimento em Conjuntos de Dados Reais",
                                  "subSteps": [
                                    "Selecione um dataset real (ex.: vendas mensais de uma loja).",
                                    "Identifique se é sequencial: confirme timestamps, frequência e dependência.",
                                    "Compare com um dataset não sequencial do mesmo domínio (ex.: vendas por produto em um dia).",
                                    "Gere um relatório curto justificando a classificação.",
                                    "Debata cenários ambíguos com um parceiro ou autoavaliação."
                                  ],
                                  "verification": "Produza um relatório de 1 página classificando 3 datasets reais com evidências.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Datasets do Kaggle ou UCI ML Repository",
                                    "Template de relatório em Word/Google Docs",
                                    "Calculadora ou Python básico para visualização"
                                  ],
                                  "tips": [
                                    "Comece com metadados do dataset para pistas temporais.",
                                    "Visualize sempre com plots de tempo."
                                  ],
                                  "learningObjective": "Aplicar identificação em contextos reais e ambíguos.",
                                  "commonMistakes": [
                                    "Ignorar metadados ou headers que indicam timestamps.",
                                    "Forçar classificação sequencial em dados independentes por viés."
                                  ]
                                }
                              ],
                              "practicalExample": "Analise o dataset de temperaturas diárias em uma cidade (sequencial: ordenado por data, frequência diária) versus temperaturas em 10 cidades no mesmo dia (cruzado: sem ordenação temporal entre observações). Identifique a série temporal pela continuidade cronológica e dependência dia-a-dia.",
                              "finalVerifications": [
                                "Classifica corretamente 90% de 20 datasets mistos como sequenciais ou não.",
                                "Explica diferenças entre séries temporais, cruzados e independentes sem erros.",
                                "Identifica frequência temporal e ordenação em datasets reais.",
                                "Justifica classificações com evidências de timestamps e dependência.",
                                "Aplica conceitos em um relatório prático sem ambiguidades.",
                                "Discute limitações em dados irregulares ou missing values."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de características temporais (40%)",
                                "Capacidade de diferenciação clara entre tipos de dados (30%)",
                                "Uso de evidências e exemplos reais (15%)",
                                "Clareza na explicação e justificativa (10%)",
                                "Profundidade na análise de frequência e ordenação (5%)"
                              ],
                              "crossCurricularConnections": [
                                "História: Análise de eventos cronológicos em timelines.",
                                "Economia: Identificação de séries temporais em indicadores econômicos como inflação.",
                                "Ciência Ambiental: Séries de dados climáticos vs. snapshots espaciais.",
                                "Programação: Manipulação de dados temporais em Python (pandas).",
                                "Geografia: Dados temporais de migração vs. distribuições populacionais estáticas."
                              ],
                              "realWorldApplication": "Em previsão de demanda de varejo, identificar vendas diárias como sequenciais permite usar modelos de séries temporais para forecasting preciso, evitando erros de análise em dados cruzados como vendas por região em um mês."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "17.1.1.2.1.2",
                            "name": "Explicar dependência temporal",
                            "description": "Descrever como observações passadas influenciam futuras em séries temporais, ilustrando conceitos de autocorrelação e tendências temporais com exemplos simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito básico de dependência temporal",
                                  "subSteps": [
                                    "Defina dependência temporal como a relação em que valores passados afetam valores futuros em uma série de dados ao longo do tempo.",
                                    "Compare com dados independentes, onde cada observação não influencia a próxima.",
                                    "Discuta por que isso é comum em fenômenos reais como clima ou economia.",
                                    "Identifique exemplos cotidianos, como o trânsito influenciando o próximo dia.",
                                    "Registre em um mapa mental as diferenças entre séries temporais dependentes e independentes."
                                  ],
                                  "verification": "Crie um diagrama simples mostrando uma série com dependência e explique oralmente ou por escrito.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel, caneta ou ferramenta digital como Draw.io; vídeo introdutório sobre séries temporais (ex: Khan Academy).",
                                  "tips": "Use analogias simples como 'efeito dominó' para visualizar a influência sequencial.",
                                  "learningObjective": "Compreender a definição e importância da dependência temporal em séries temporais.",
                                  "commonMistakes": "Confundir dependência temporal com causalidade; assumir que toda variação temporal é dependência."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o conceito de autocorrelação",
                                  "subSteps": [
                                    "Explique autocorrelação como a correlação de uma série consigo mesma em diferentes lags (atrasos).",
                                    "Calcule manualmente a autocorrelação para lags 1 e 2 em um conjunto pequeno de dados (ex: 5 valores).",
                                    "Interprete valores: próximo de 1 indica forte dependência positiva; próximo de 0, independência.",
                                    "Plote um gráfico de autocorrelação (ACF) usando Excel ou Python (pandas.plotting).",
                                    "Discuta como autocorrelação alta viola suposições de modelos independentes como regressão linear simples."
                                  ],
                                  "verification": "Gere um gráfico ACF para dados de exemplo e interprete os primeiros lags.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Planilha Excel ou Jupyter Notebook com pandas; dados de exemplo (temperatura diária).",
                                  "tips": "Comece com lags pequenos (1-3) para evitar sobrecarga; visualize sempre com gráficos.",
                                  "learningObjective": "Dominar a medição e interpretação da autocorrelação em séries temporais.",
                                  "commonMistakes": "Ignorar lags negativos ou confundir autocorrelação com correlação cruzada."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar tendências temporais",
                                  "subSteps": [
                                    "Defina tendência como a direção geral de longo prazo em uma série temporal (crescente, decrescente ou estável).",
                                    "Identifique tendências em gráficos de séries reais, como PIB anual ou preço de ações.",
                                    "Use decomposição simples: subtraia a tendência para isolar ruído e sazonalidade.",
                                    "Aplique uma média móvel para suavizar e extrair tendência manualmente.",
                                    "Compare séries com e sem tendência para observar impacto na dependência."
                                  ],
                                  "verification": "Aplique média móvel em dados de exemplo e descreva a tendência identificada.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Gráficos de séries temporais prontos (ex: dados de vendas); calculadora ou Excel.",
                                  "tips": "Escolha janela de média móvel baseada no período (ex: 12 para dados mensais).",
                                  "learningObjective": "Reconhecer e quantificar tendências como componente de dependência temporal.",
                                  "commonMistakes": "Confundir tendência de curto prazo com ruído aleatório."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ilustrar com exemplos simples e integrar conceitos",
                                  "subSteps": [
                                    "Escolha um exemplo: temperaturas diárias onde dias quentes seguem quentes (autocorrelação).",
                                    "Crie um exemplo fictício: vendas de sorvete com tendência crescente no verão.",
                                    "Combine conceitos: mostre como tendência e autocorrelação interagem em um gráfico.",
                                    "Explique verbalmente ou em relatório como observações passadas influenciam futuras.",
                                    "Teste compreensão resolvendo um exercício: identifique dependência em dados fornecidos."
                                  ],
                                  "verification": "Produza um relatório curto (1 página) com gráfico, explicação e interpretação.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Dados de exemplo (CSV de temperaturas ou vendas); software de plotagem.",
                                  "tips": "Use cores diferentes no gráfico para tendência, autocorrelação e observações.",
                                  "learningObjective": "Aplicar conceitos de dependência, autocorrelação e tendências em exemplos concretos.",
                                  "commonMistakes": "Usar exemplos complexos demais; omitir interpretação qualitativa."
                                }
                              ],
                              "practicalExample": "Considere dados de temperatura diária em uma cidade: dia 1: 25°C, dia 2: 27°C, dia 3: 26°C. Observações passadas (quente) influenciam futuras (provável quentura), com autocorrelação lag 1 alta (~0.9) e tendência estável no verão.",
                              "finalVerifications": [
                                "Pode definir dependência temporal corretamente?",
                                "Calcula e interpreta autocorrelação para lag 1 em dados simples?",
                                "Identifica tendência em um gráfico de série temporal?",
                                "Explica com exemplo como passado afeta futuro?",
                                "Distingue autocorrelação de independência?",
                                "Decompõe uma série em tendência e ruído?"
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (definições corretas de dependência, autocorrelação e tendência).",
                                "Clareza na ilustração com exemplos simples e relevantes.",
                                "Qualidade de gráficos e cálculos (exatidão numérica).",
                                "Profundidade de interpretação (não só descreve, mas explica impacto).",
                                "Capacidade de integração (conecta conceitos em um todo coerente).",
                                "Criatividade em analogias e aplicações práticas."
                              ],
                              "crossCurricularConnections": [
                                "Economia: Previsão de vendas e PIB com dependências temporais.",
                                "Meteorologia: Modelos de previsão de tempo baseados em autocorrelação.",
                                "Finanças: Análise de ações e tendências de mercado.",
                                "Biologia: Populações animais com ciclos sazonais e tendências."
                              ],
                              "realWorldApplication": "Em previsão de demanda de produtos (ex: varejo usa autocorrelação para estoque), análise climática para agricultura ou detecção de fraudes em transações bancárias onde padrões temporais indicam dependências anormais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "17.1.1.2.1.3",
                            "name": "Reconhecer violações em análises não temporais",
                            "description": "Identificar erros comuns ao aplicar métodos de regressão padrão em dados temporais, como ignorar autocorrelação, e justificar a necessidade de modelos específicos para séries temporais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as Características Fundamentais dos Dados Temporais",
                                  "subSteps": [
                                    "Defina dados temporais como sequências ordenadas no tempo com dependências entre observações consecutivas.",
                                    "Diferencie de dados não temporais, que assumem independência entre observações (IID).",
                                    "Identifique propriedades chave: autocorrelação, tendência, sazonalidade e não estacionariedade.",
                                    "Revise conceitos básicos de regressão linear padrão (OLS), que assume resíduos independentes.",
                                    "Discuta por que violações ocorrem em dados temporais."
                                  ],
                                  "verification": "Resuma em 3-5 frases as diferenças entre dados temporais e não temporais, citando pelo menos duas propriedades temporais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Slides ou vídeo introdutório sobre séries temporais (ex: Khan Academy)",
                                    "Notebook com exemplos de dados temporais (ex: airpassengers dataset no R/Python)"
                                  ],
                                  "tips": "Use gráficos de linha para visualizar dependências temporais antes de qualquer modelagem.",
                                  "learningObjective": "Distinguir dados temporais de dados cross-sectionais e identificar premissas violadas pela regressão padrão.",
                                  "commonMistakes": "Confundir correlação com causalidade ou ignorar a ordenação temporal nos dados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Violações Comuns em Regressão Padrão Aplicada a Dados Temporais",
                                  "subSteps": [
                                    "Liste violações: autocorrelação serial nos resíduos, heteroscedasticidade temporal, não estacionariedade.",
                                    "Explique autocorrelação: correlação entre resíduos em diferentes lags (ex: lag-1).",
                                    "Descreva impacto: estimadores enviesados, inferências inválidas (p-values errados).",
                                    "Aprenda testes diagnósticos: Durbin-Watson para autocorrelação, teste de Dickey-Fuller para estacionariedade.",
                                    "Pratique com fórmula: ρ = Cov(ε_t, ε_{t-k}) / Var(ε_t)."
                                  ],
                                  "verification": "Liste 3 violações principais e um teste diagnóstico para cada uma, com interpretação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação de testes em Python (statsmodels) ou R (lmtest)",
                                    "Exemplos de resíduos plotados com acf()"
                                  ],
                                  "tips": "Sempre plote resíduos vs tempo e ACF/PACF após ajuste de modelo OLS.",
                                  "learningObjective": "Reconhecer e nomear violações específicas causadas por estrutura temporal em resíduos.",
                                  "commonMistakes": "Interpretar testes sem verificar premissas ou usar testes inadequados para amostras pequenas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar um Exemplo Prático de Violação em Dados Temporais",
                                  "subSteps": [
                                    "Carregue um dataset temporal (ex: série de preços de ações ou vendas mensais).",
                                    "Ajuste um modelo OLS simples (ex: y_t ~ lag(y_{t-1}) + X).",
                                    "Gere resíduos e aplique testes: Durbin-Watson <2 indica autocorrelação positiva.",
                                    "Visualize: plot de resíduos, Q-Q plot, ACF de resíduos.",
                                    "Documente evidências de violações."
                                  ],
                                  "verification": "Produza relatório com output de testes mostrando p-value <0.05 para autocorrelação.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python (pandas, statsmodels) ou R",
                                    "Dataset público: ex: AAPL stock prices de Yahoo Finance"
                                  ],
                                  "tips": "Use train-test split respeitando ordem temporal para evitar data leakage.",
                                  "learningObjective": "Diagnosticar violações empiricamente em dados reais usando ferramentas computacionais.",
                                  "commonMistakes": "Incluir variáveis futuras no modelo ou embaralhar dados temporais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Justificar a Necessidade de Modelos Específicos para Séries Temporais",
                                  "subSteps": [
                                    "Compare OLS vs ARIMA/ETS: modelos temporais capturam dependências explicitamente.",
                                    "Explique benefícios: eficiência, previsões melhores, inferências válidas.",
                                    "Discuta alternativas: VAR para multivariadas, GARCH para volatilidade.",
                                    "Resuma quando usar: presença de autocorrelação significativa ou não estacionariedade.",
                                    "Conclua com framework de decisão para análise temporal."
                                  ],
                                  "verification": "Escreva parágrafo justificando por que ARIMA é preferível a OLS aqui, citando evidências do exemplo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Artigos introdutórios (ex: Hyndman 'Forecasting: Principles')",
                                    "Comparação de forecasts OLS vs ARIMA no dataset usado"
                                  ],
                                  "tips": "Sempre valide com out-of-sample forecasting para demonstrar superioridade.",
                                  "learningObjective": "Argumentar racionalmente pela adoção de modelos temporais baseados em diagnósticos.",
                                  "commonMistakes": "Recomendar modelos complexos sem evidência de violações ou ignorar custo computacional."
                                }
                              ],
                              "practicalExample": "Ao tentar prever vendas mensais de varejo usando regressão linear simples (vendas ~ publicidade + mês), os resíduos mostram autocorrelação forte (Durbin-Watson=0.8), levando a intervalos de confiança subestimados e forecasts ruins. Aplicando ARIMA corrige isso, reduzindo MAE em 25%.",
                              "finalVerifications": [
                                "Identifica corretamente autocorrelação em resíduos de OLS via teste Durbin-Watson.",
                                "Explica impacto de violações em inferências estatísticas.",
                                "Aplica testes de estacionariedade e interpreta resultados.",
                                "Justifica transição para modelo ARIMA com evidências empíricas.",
                                "Produz gráficos diagnósticos claros mostrando violações.",
                                "Compara performance de OLS vs modelo temporal em hold-out set."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de pelo menos 3 violações comuns (80% acerto).",
                                "Uso correto de testes diagnósticos com interpretação adequada (p-values e conclusões).",
                                "Qualidade dos gráficos e visualizações (legendas, escalas corretas).",
                                "Argumentação lógica e baseada em evidências para modelos temporais.",
                                "Relatório estruturado com substeps executados e verificações passadas.",
                                "Tempo de execução dentro dos estimados (±20%)."
                              ],
                              "crossCurricularConnections": [
                                "Economia: Análise de ciclos econômicos e previsão de PIB.",
                                "Finanças: Modelagem de retornos de ações e risco (VaR).",
                                "Ciência de Dados: Pré-processamento em ML para sequências (LSTM).",
                                "Engenharia: Monitoramento de sensores IoT em tempo real."
                              ],
                              "realWorldApplication": "Em finanças, bancos usam isso para detectar falhas em modelos de risco que ignoram autocorrelação em retornos diários, evitando perdas como na crise de 2008; em marketing, otimiza previsão de demanda sazonal para estoques eficientes."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "17.1.1.2.2",
                        "name": "Aplicações em Finanças",
                        "description": "Explorar o uso de séries temporais na previsão de retornos financeiros, gerenciamento de riscos e modelagem de volatilidade em mercados de ações, câmbio e derivativos.",
                        "specificSkills": [
                          {
                            "id": "17.1.1.2.2.1",
                            "name": "Prever preços de ativos",
                            "description": "Entender como modelos de séries temporais, como ARIMA, são aplicados para forecasting de preços de ações e índices bursáteis, considerando ruído de mercado e tendências.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos de séries temporais e o modelo ARIMA",
                                  "subSteps": [
                                    "Estudar a definição de séries temporais e suas componentes: tendência, sazonalidade, ciclo e ruído.",
                                    "Aprender os componentes do modelo ARIMA: AutoRegressivo (AR), Integrado (I) e Média Móvel (MA).",
                                    "Entender a notação ARIMA(p,d,q) e como ela se aplica a dados financeiros voláteis.",
                                    "Explorar diferenças entre séries estacionárias e não estacionárias.",
                                    "Analisar exemplos de ruído de mercado em preços de ações."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito os componentes ARIMA e identificar uma série estacionária em um gráfico.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": "Livro 'Forecasting: Principles and Practice' (capítulos iniciais), vídeos tutoriais no YouTube sobre ARIMA, notebook Jupyter.",
                                  "tips": "Comece com gráficos simples de preços de ações para visualizar tendências e ruído.",
                                  "learningObjective": "Dominar os conceitos teóricos de ARIMA para aplicação em forecasting financeiro.",
                                  "commonMistakes": "Confundir sazonalidade com tendência; ignorar a necessidade de estacionariedade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Coletar e preparar dados de preços de ativos",
                                  "subSteps": [
                                    "Baixar dados históricos de preços de ações ou índices (ex: Yahoo Finance via yfinance em Python).",
                                    "Limpar os dados: remover valores ausentes, outliers e ajustar por splits/dividendos.",
                                    "Transformar dados em série temporal: definir índice de tempo diário/semanal.",
                                    "Plotar gráficos de preços, retornos logarítmicos e ACF/PACF iniciais.",
                                    "Calcular estatísticas descritivas como média, variância e autocorrelação."
                                  ],
                                  "verification": "Gerar um gráfico limpo de preços com estatísticas básicas exibidas.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": "Biblioteca yfinance ou pandas_datareader em Python, Excel para verificação manual.",
                                  "tips": "Use retornos logarítmicos para estabilizar variância em dados financeiros.",
                                  "learningObjective": "Preparar dados financeiros reais para modelagem de séries temporais.",
                                  "commonMistakes": "Não ajustar por feriados ou splits de ações; usar preços nominais sem log."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar testes de estacionariedade e diferenciação",
                                  "subSteps": [
                                    "Aplicar teste de Dickey-Fuller Aumentado (ADF) para verificar estacionariedade.",
                                    "Visualizar decomposição da série (trend, seasonal, residual) com STL.",
                                    "Aplicar diferenciação de primeira ou segunda ordem se necessário.",
                                    "Re-testar estacionariedade após diferenciação e plotar ACF/PACF.",
                                    "Identificar presença de ruído de mercado via resíduos."
                                  ],
                                  "verification": "Relatório com resultados de ADF antes/depois diferenciação (p-value < 0.05).",
                                  "estimatedTime": "1-2 horas",
                                  "materials": "Bibliotecas statsmodels e matplotlib em Python, R com forecast package.",
                                  "tips": "Sempre plote ACF/PACF após cada transformação para guiar decisões.",
                                  "learningObjective": "Garantir que a série atenda aos pressupostos de estacionariedade para ARIMA.",
                                  "commonMistakes": "Sobrediferenciação, que introduz ruído artificial; ignorar testes formais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar parâmetros e ajustar o modelo ARIMA",
                                  "subSteps": [
                                    "Usar plots ACF/PACF para estimar ordens p e q (AR e MA).",
                                    "Selecionar ordem de integração d baseada em testes anteriores.",
                                    "Ajustar modelo ARIMA(p,d,q) com função auto.arima ou manual.",
                                    "Verificar resíduos: teste Ljung-Box para autocorrelação e normalidade.",
                                    "Comparar múltiplos modelos via AIC/BIC."
                                  ],
                                  "verification": "Modelo ajustado com resíduos brancos (Ljung-Box p-value > 0.05).",
                                  "estimatedTime": "2-3 horas",
                                  "materials": "statsmodels.tsa.arima em Python, notebook com grid search para parâmetros.",
                                  "tips": "Comece com auto.arima para baseline, depois refine manualmente.",
                                  "learningObjective": "Construir um modelo ARIMA otimizado para dados financeiros.",
                                  "commonMistakes": "Escolher p/q altos sem validação; não checar resíduos."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Realizar previsões, avaliar e considerar ruído/tendências",
                                  "subSteps": [
                                    "Gerar previsões de curto/médio prazo (ex: 1-30 dias) com intervalos de confiança.",
                                    "Avaliar com métricas: MAE, RMSE, MAPE em conjunto de teste.",
                                    "Analisar impacto de ruído de mercado e tendências externas (notícias econômicas).",
                                    "Simular cenários com adição de ruído gaussiano.",
                                    "Documentar limitações do modelo em finanças voláteis."
                                  ],
                                  "verification": "Previsão plotada com dados reais e métricas de erro calculadas.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": "Mesmas bibliotecas, dados de teste out-of-sample.",
                                  "tips": "Use walk-forward validation para simular trading real.",
                                  "learningObjective": "Aplicar e validar previsões ARIMA considerando realidades de mercado.",
                                  "commonMistakes": "Superestimar precisão ignorando volatilidade; não usar validação cruzada temporal."
                                }
                              ],
                              "practicalExample": "Usando dados históricos diários da ação PETR4 (Petrobras) de 2020-2023 obtidos via yfinance, aplique ARIMA(1,1,1) após diferenciação para prever preços dos próximos 30 dias, plotando a previsão com intervalos de 95% de confiança e comparando RMSE com baseline de média móvel.",
                              "finalVerifications": [
                                "Explicar corretamente os parâmetros ARIMA(p,d,q) para um dataset financeiro dado.",
                                "Implementar e ajustar um modelo ARIMA em Python/R com dados reais de ações.",
                                "Interpretar plots ACF/PACF e testes de estacionariedade.",
                                "Gerar previsões com intervalos de confiança e avaliar com métricas padrão.",
                                "Discutir limitações devido a ruído de mercado e eventos não modelados.",
                                "Reproduzir o exemplo prático com precisão aceitável (RMSE < 5%)."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: compreensão de 90% dos componentes ARIMA e estacionariedade.",
                                "Implementação técnica: código funcional sem erros, com visualizações claras.",
                                "Qualidade de preparação de dados: dados limpos e transformados corretamente.",
                                "Avaliação do modelo: uso de pelo menos 3 métricas e análise de resíduos.",
                                "Análise crítica: identificação de ruído/tendências e sugestões de melhorias.",
                                "Eficiência: conclusão dentro do tempo estimado com passos lógicos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estatística inferencial, testes de hipóteses (ADF, Ljung-Box).",
                                "Programação: Manipulação de dados com Python/R (pandas, statsmodels).",
                                "Economia/Finanças: Análise de risco, eficiência de mercado e behavioral finance.",
                                "Machine Learning: Comparação com modelos como LSTM para séries temporais."
                              ],
                              "realWorldApplication": "Em fundos de investimento e trading algorítmico, modelos ARIMA são usados para prever preços de ações/índices como IBOVESPA, auxiliando decisões de compra/venda, gerenciamento de portfólios e detecção de anomalias de mercado, sempre combinados com análise qualitativa de notícias econômicas."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "17.1.1.2.2.2",
                            "name": "Analisar risco financeiro",
                            "description": "Descrever a aplicação de séries temporais no cálculo de Value at Risk (VaR) e modelagem de volatilidade com GARCH para avaliação de portfólios.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de VaR e GARCH",
                                  "subSteps": [
                                    "Estude a definição de Value at Risk (VaR) como uma medida de perda máxima esperada em um horizonte de tempo com um nível de confiança dado.",
                                    "Aprenda os tipos de VaR: histórico, paramétrico e baseado em simulação, focando no uso de séries temporais para dados não estacionários.",
                                    "Explore o modelo GARCH (Generalized Autoregressive Conditional Heteroskedasticity) para capturar clusters de volatilidade em retornos financeiros.",
                                    "Revise propriedades de séries temporais financeiras, como estacionariedade, autocorrelação e heterocedasticidade.",
                                    "Compare VaR simples com VaR ajustado por volatilidade GARCH."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos de VaR e GARCH e explique sua interconexão com séries temporais.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Livro 'Analysis of Financial Time Series' de Ruey S. Tsay (capítulos iniciais); vídeo tutoriais no YouTube sobre VaR e GARCH; notebook Jupyter vazio.",
                                  "tips": "Use analogias como 'VaR é o pior cenário que você espera 95% do tempo' para fixar conceitos.",
                                  "learningObjective": "Dominar definições e relações teóricas entre séries temporais, VaR e GARCH.",
                                  "commonMistakes": "Confundir VaR com volatilidade simples; ignorar que GARCH modela variância condicional, não retornos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar e Analisar Dados de Séries Temporais Financeiras",
                                  "subSteps": [
                                    "Baixe dados históricos de preços de ativos (ex: ações via Yahoo Finance).",
                                    "Calcule retornos logarítmicos: rt = log(Pt / Pt-1).",
                                    "Teste estacionariedade com teste ADF (Augmented Dickey-Fuller).",
                                    "Visualize ACF/PACF e séries de retornos quadrados para detectar volatilidade condicional.",
                                    "Divida dados em amostra de treino e teste."
                                  ],
                                  "verification": "Gere gráficos de retornos, ACF e teste ADF com p-valor < 0.05 para retornos.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Python com pandas, yfinance, statsmodels; dataset de ações como AAPL (5 anos diários).",
                                  "tips": "Sempre plote dados primeiro para identificar anomalias como feriados ou splits.",
                                  "learningObjective": "Preparar dados financeiros adequados para modelagem de risco.",
                                  "commonMistakes": "Usar preços em vez de retornos; não diferenciar não-estacionariedade de volatilidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Value at Risk (VaR) Usando Métodos de Séries Temporais",
                                  "subSteps": [
                                    "Implemente VaR histórico: ordene retornos e pegue o percentil (ex: 5% para 95% confiança).",
                                    "Calcule VaR paramétrico assumindo normalidade: VaR = μ - z * σ.",
                                    "Ajuste VaR com rolling window para capturar mudanças temporais.",
                                    "Compare VaR diário e de múltiplos dias usando séries temporais.",
                                    "Backteste VaR com Kupiec test para validar exceções."
                                  ],
                                  "verification": "Produza tabela com VaR histórico e paramétrico para 10 dias e gráfico de backtest sem >5% violações.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Python: numpy, scipy.stats; código base de VaR de repositórios GitHub como 'financial-risk-models'.",
                                  "tips": "Use janelas rolantes de 250 dias para robustez em dados diários.",
                                  "learningObjective": "Aplicar métodos de VaR em dados de séries temporais.",
                                  "commonMistakes": "Assumir normalidade em retornos com caudas gordas; janela fixa muito curta."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Modelar Volatilidade com GARCH e Integrar ao VaR",
                                  "subSteps": [
                                    "Ajuste modelo GARCH(1,1): σ_t² = ω + α ε_{t-1}² + β σ_{t-1}².",
                                    "Estime parâmetros usando máxima verossimilhança com biblioteca arch.",
                                    "Gere resíduos padronizados e teste Ljung-Box para autocorrelação.",
                                    "Calcule VaR condicional: VaR_t = μ + z * σ_t (de GARCH).",
                                    "Avalie adequação com gráficos de volatilidade fitted vs. squared returns."
                                  ],
                                  "verification": "Obtenha modelo GARCH com α+β <1 (persistência estável) e VaR GARCH com menos violações que paramétrico.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Python: arch library (pip install arch); mesmo dataset do Step 2.",
                                  "tips": "Inicie com GARCH(1,1) simples; verifique convergência ajustando initial params.",
                                  "learningObjective": "Modelar volatilidade dinâmica e aprimorar VaR.",
                                  "commonMistakes": "Ignorar não-convergência do modelo; confundir σ_t com retornos."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Avaliar Portfólio com VaR e GARCH",
                                  "subSteps": [
                                    "Construa portfólio simples (ex: 50% ações, 50% bonds).",
                                    "Calcule retornos portfólio e aplique VaR/GARCH multivariado ou escalar.",
                                    "Simule cenários de estresse usando forecasts de GARCH.",
                                    "Interprete risco: compare VaR antes/depois diversificação.",
                                    "Gere relatório com métricas como Expected Shortfall (CVaR)."
                                  ],
                                  "verification": "Relatório PDF com VaR portfólio, gráficos e recomendação de alocação.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Múltiplos datasets (ex: SPY para ações, TLT para bonds); matplotlib/seaborn para visualizações.",
                                  "tips": "Use pesos otimizados iniciais via mean-variance para realismo.",
                                  "learningObjective": "Aplicar análise de risco a portfólios reais.",
                                  "commonMistakes": "Não ponderar corretamente retornos; ignorar correlações entre ativos."
                                }
                              ],
                              "practicalExample": "Usando dados diários da ação AAPL (2018-2023), calcule VaR 95% histórico (cerca de -3.5%) e ajuste com GARCH(1,1) (σ média 2.1%), mostrando como GARCH captura picos de volatilidade durante COVID-19, reduzindo falsos positivos em backtest.",
                              "finalVerifications": [
                                "Explicar verbalmente como GARCH melhora VaR em séries com volatilidade em cluster.",
                                "Implementar e rodar código completo para VaR GARCH em novo dataset.",
                                "Identificar e corrigir um modelo GARCH não convergente.",
                                "Comparar VaR de portfólio diversificado vs. concentrado.",
                                "Produzir gráfico de volatilidade forecasted vs. realizada.",
                                "Calcular CVaR a partir de VaR GARCH."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas de VaR/GARCH (30%)",
                                "Qualidade da implementação: código roda sem erros, convergência (25%)",
                                "Análise de resultados: backtest válido, interpretação (20%)",
                                "Visualizações claras e insights acionáveis (15%)",
                                "Tratamento de erros comuns como não-estacionariedade (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Estatística: testes de hipóteses (ADF, Ljung-Box)",
                                "Programação: manipulação de dados em Python/R",
                                "Economia: teoria de portfólio e gerenciamento de risco",
                                "Matemática: processos estocásticos e otimização"
                              ],
                              "realWorldApplication": "Bancos e fundos de investimento usam VaR GARCH para definir limites de perda diária, alocar capital regulatório (Basel III) e stress tests, como no JPMorgan RiskMetrics, evitando perdas como na crise de 2008."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "17.1.1.2.2.3",
                            "name": "Modelar séries financeiras",
                            "description": "Reconhecer exemplos de não-estacionariedade em dados financeiros e a importância de diferenciação para previsões precisas em cenários de alta frequência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos de estacionariedade e não-estacionariedade em séries temporais",
                                  "subSteps": [
                                    "Defina estacionariedade: média, variância e covariância constantes ao longo do tempo.",
                                    "Identifique tipos de não-estacionariedade: tendência, sazonalidade e heteroscedasticidade.",
                                    "Estude testes estatísticos básicos como Augmented Dickey-Fuller (ADF).",
                                    "Analise gráficos de séries temporais para visualização intuitiva.",
                                    "Compare exemplos estacionários vs. não-estacionários."
                                  ],
                                  "verification": "Crie um resumo de 1 página explicando os conceitos e forneça um gráfico de exemplo rotulado corretamente.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livro 'Forecasting: Principles and Practice' (capítulo sobre séries temporais), Python com pandas e matplotlib.",
                                  "tips": "Sempre plote os dados primeiro para ganhar intuição visual antes de testes formais.",
                                  "learningObjective": "Explicar com precisão os conceitos fundamentais de estacionariedade e identificar padrões visualmente.",
                                  "commonMistakes": "Confundir variância crescente com tendência linear; ignorar a necessidade de testes formais além de gráficos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Reconhecer exemplos de não-estacionariedade em dados financeiros reais",
                                  "subSteps": [
                                    "Baixe dados financeiros de alta frequência, como ticks de preços de ações (ex: Bitcoin ou AAPL).",
                                    "Plote séries de preços, retornos e volumes para identificar tendências e volatilidade.",
                                    "Aplique teste ADF em subconjuntos de dados para confirmar não-estacionariedade.",
                                    "Documente exemplos específicos: drift em preços de ações ou clustering de volatilidade em crises.",
                                    "Compare com dados simulados estacionários para contraste."
                                  ],
                                  "verification": "Gere relatórios com gráficos e resultados de testes ADF mostrando pelo menos 3 exemplos de não-estacionariedade.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Yahoo Finance API ou Quandl para dados, Jupyter Notebook, statsmodels para ADF.",
                                  "tips": "Use log-retornos para dados financeiros, pois preços brutos são quase sempre não-estacionários.",
                                  "learningObjective": "Identificar e documentar não-estacionariedade em conjuntos de dados financeiros autênticos.",
                                  "commonMistakes": "Usar janelas de tempo muito curtas nos testes, levando a falsos positivos; não diferenciar entre tipos de não-estacionariedade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar diferenciação para induzir estacionariedade",
                                  "subSteps": [
                                    "Calcule diferenças de primeira ordem (ΔY_t = Y_t - Y_{t-1}) em dados não-estacionários.",
                                    "Plote e teste ADF nos dados diferenciados para verificar estacionariedade.",
                                    "Experimente diferenciação sazonal se houver padrões periódicos em alta frequência.",
                                    "Compare ACF/PACF antes e depois da diferenciação.",
                                    "Ajuste ordens de diferenciação com base em critérios como AIC."
                                  ],
                                  "verification": "Forneça código e gráficos mostrando transformação de não-estacionário para estacionário com testes confirmatórios.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Python (pandas, statsmodels), dados do Step 2.",
                                  "tips": "Comece com diferenciação de primeira ordem; overdifferencing aumenta ruído desnecessariamente.",
                                  "learningObjective": "Executar e validar diferenciação como técnica para estacionarizar séries financeiras.",
                                  "commonMistakes": "Diferenciar demais, causando perda de informação; não verificar estacionariedade pós-diferenciação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar a importância da diferenciação em previsões de alta frequência",
                                  "subSteps": [
                                    "Treine modelos ARIMA simples em dados originais vs. diferenciados.",
                                    "Compare métricas de previsão: MAE, RMSE em hold-out de alta frequência.",
                                    "Simule cenários de trading: prever retornos de 1-minuto com e sem diferenciação.",
                                    "Analise impacto em precisão durante períodos voláteis.",
                                    "Discuta limitações em dados de ticks ultra-alta frequência."
                                  ],
                                  "verification": "Produza um relatório comparativo com tabelas de métricas e conclusões sobre melhoria na precisão.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Python (pmdarima para ARIMA auto), dados de alta frequência.",
                                  "tips": "Use walk-forward validation para simular previsões em tempo real em finanças.",
                                  "learningObjective": "Demonstrar quantitativamente como a diferenciação melhora previsões precisas em cenários financeiros de alta frequência.",
                                  "commonMistakes": "Ignorar custos computacionais em alta frequência; superestimar melhorias sem validação out-of-sample."
                                }
                              ],
                              "practicalExample": "Baixe ticks de 1-minuto do Bitcoin durante uma semana volátil (ex: crash de 2022). Identifique não-estacionariedade nos preços (tendência ascendente), aplique diferenciação de primeira ordem nos log-retornos, teste ADF (p-valor <0.05 pós-diferenciação), e treine ARIMA(1,1,1) para prever próximos 5 minutos, comparando RMSE: 0.045 pré vs. 0.028 pós-diferenciação.",
                              "finalVerifications": [
                                "Identifica corretamente não-estacionariedade em pelo menos 3 séries financeiras reais via gráficos e ADF.",
                                "Aplica diferenciação e confirma estacionariedade com testes estatísticos.",
                                "Compara previsões ARIMA pré e pós-diferenciação com métricas quantitativas.",
                                "Explica verbalmente a importância em trading de alta frequência.",
                                "Documenta limitações como ruído em ultra-alta frequência.",
                                "Reproduz análise em novo dataset independente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de não-estacionariedade (90% acurácia em testes).",
                                "Corretude técnica na aplicação de diferenciação e validação (p-valor ADF <0.05).",
                                "Melhoria mensurável em métricas de previsão (redução >20% em RMSE).",
                                "Clareza e completude da documentação com gráficos e código.",
                                "Profundidade na discussão de aplicações financeiras reais.",
                                "Criatividade em exemplos e conexões interdisciplinares."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo diferencial e análise de processos estocásticos.",
                                "Economia: Modelos de precificação de ativos e risco-volatilidade.",
                                "Programação: Manipulação de dados com Python/R e machine learning para séries temporais.",
                                "Física: Analogia com movimento browniano em partículas financeiras."
                              ],
                              "realWorldApplication": "Em trading algorítmico de alta frequência (HFT), firmas como Citadel usam diferenciação para estacionarizar ticks de preços, permitindo ARIMA/GARCH precisos para prever micro-movimentos, gerando bilhões em lucros diários ao capturar spreads em milissegundos durante volatilidade de mercado."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "17.1.1.2.3",
                        "name": "Aplicações em Marketing e Operações",
                        "description": "Analisar o papel das séries temporais na previsão de demanda, otimização de estoques e compreensão de padrões sazonais em vendas e operações logísticas.",
                        "specificSkills": [
                          {
                            "id": "17.1.1.2.3.1",
                            "name": "Prever demanda em marketing",
                            "description": "Explicar o uso de séries temporais para forecasting de vendas sazonais, campanhas promocionais e comportamento do consumidor ao longo do tempo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Componentes de Séries Temporais em Contextos de Marketing",
                                  "subSteps": [
                                    "Estude os componentes básicos: tendência, sazonalidade, ciclicidade e ruído, focando em sazonalidade para vendas promocionais.",
                                    "Analise exemplos de dados de vendas sazonais, como picos em Black Friday ou Natal.",
                                    "Identifique padrões de comportamento do consumidor ao longo do tempo, como compras impulsivas em campanhas.",
                                    "Desenhe gráficos de séries temporais manuais para visualizar componentes.",
                                    "Compare séries temporais de diferentes produtos para notar variações sazonais."
                                  ],
                                  "verification": "Crie um diagrama anotado de uma série temporal de vendas identificando todos os componentes corretamente.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Planilha Excel ou Google Sheets, datasets de vendas sazonais (ex: Kaggle Retail Sales), vídeo introdutório sobre séries temporais.",
                                  "tips": "Sempre comece plotando os dados para visualização intuitiva antes de qualquer análise.",
                                  "learningObjective": "Compreender e identificar os componentes chave de séries temporais aplicados a dados de marketing.",
                                  "commonMistakes": "Confundir sazonalidade com tendência; ignorar ruído como parte natural dos dados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Coletar e Preparar Dados de Vendas e Campanhas",
                                  "subSteps": [
                                    "Reúna dados históricos de vendas, datas de campanhas promocionais e métricas de comportamento do consumidor.",
                                    "Limpe os dados: trate valores ausentes, outliers e formate datas corretamente.",
                                    "Crie variáveis dummy para eventos sazonais ou promocionais (ex: 1 para Natal, 0 caso contrário).",
                                    "Teste estacionariedade dos dados usando gráficos e testes como ADF.",
                                    "Divida os dados em treino e teste para forecasting futuro."
                                  ],
                                  "verification": "Produza um dataset limpo e um relatório resumindo estatísticas descritivas e testes de estacionariedade.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Python (pandas, matplotlib), R, datasets reais de e-commerce (ex: Walmart Sales dataset).",
                                  "tips": "Use funções prontas como pd.to_datetime() para agilizar o tratamento de datas.",
                                  "learningObjective": "Preparar dados de marketing de forma adequada para modelagem de séries temporais.",
                                  "commonMistakes": "Não tratar sazonalidade antes do teste de estacionariedade; ignorar feriados em dados brasileiros."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Modelos de Forecasting para Demanda em Marketing",
                                  "subSteps": [
                                    "Implemente suavização exponencial para capturar sazonalidade simples.",
                                    "Ajuste um modelo ARIMA/SARIMA incorporando termos sazonais para campanhas.",
                                    "Inclua variáveis exógenas como gastos em anúncios ou feriados.",
                                    "Gere previsões para 3-12 meses à frente e plote com intervalos de confiança.",
                                    "Compare múltiplos modelos usando métricas como MAE e RMSE."
                                  ],
                                  "verification": "Desenvolva e execute um script que gere forecasts com visualizações e métricas de erro.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Python (statsmodels, pmdarima), Jupyter Notebook, dados preparados do Step 2.",
                                  "tips": "Comece com modelos simples como Holt-Winters antes de ARIMA para ganhos rápidos.",
                                  "learningObjective": "Construir e aplicar modelos de séries temporais para prever vendas sazonais e impactos de campanhas.",
                                  "commonMistakes": "Sobreajustar o modelo (overfitting) com muitos parâmetros; esquecer intervalos de confiança."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Forecasts e Aplicar em Estratégias de Marketing",
                                  "subSteps": [
                                    "Analise previsões: identifique picos sazonais e impactos de promoções passadas.",
                                    "Simule cenários: 'e se dobrarmos o orçamento de campanha?' usando forecasts.",
                                    "Relacione forecasts com comportamento do consumidor (ex: retenção pós-promoção).",
                                    "Crie um dashboard resumindo insights acionáveis para gerentes de marketing.",
                                    "Documente limitações do modelo e sugestões de melhoria."
                                  ],
                                  "verification": "Elabore um relatório de 1 página com forecasts, insights e recomendações de marketing.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Ferramentas de visualização (Plotly, Tableau Public), relatório template em Word/Google Docs.",
                                  "tips": "Foque em storytelling: transforme números em narrativas de negócios.",
                                  "learningObjective": "Interpretar resultados de forecasting para decisões de marketing práticas.",
                                  "commonMistakes": "Ignorar incertezas nos forecasts; não contextualizar com metas de vendas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Refinar o Modelo de Previsão",
                                  "subSteps": [
                                    "Valide o modelo com dados de teste out-of-sample.",
                                    "Calcule erros de previsão e compare com benchmarks (ex: média ingênua).",
                                    "Ajuste hiperparâmetros baseados em validação cruzada temporal.",
                                    "Teste robustez adicionando ruído ou mudando condições de mercado.",
                                    "Planeje monitoramento contínuo para atualizações sazonais."
                                  ],
                                  "verification": "Atualize o relatório com resultados de validação e um plano de manutenção do modelo.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Código Python/R do Step 3, métricas de avaliação (scikit-learn).",
                                  "tips": "Use walk-forward validation para simular uso real em séries temporais.",
                                  "learningObjective": "Avaliar e melhorar a precisão de modelos de forecasting em marketing.",
                                  "commonMistakes": "Usar validação aleatória em vez de temporal; declarar sucesso prematuro sem teste real."
                                }
                              ],
                              "practicalExample": "Usando dados de vendas de uma loja online de roupas, aplique SARIMA para prever demanda no Dia das Mães: identifique sazonalidade de +30% nas vendas, simule impacto de uma campanha de email marketing dobrando o tráfego, e recomende estoque extra de 20% em vestidos florais.",
                              "finalVerifications": [
                                "Explica corretamente os componentes sazonais em dados de marketing.",
                                "Prepara um dataset de vendas com variáveis promocionais.",
                                "Constrói um modelo SARIMA que prevê vendas com RMSE < 15%.",
                                "Interpreta forecasts em termos de estratégias de campanha.",
                                "Valida o modelo com dados de teste e sugere melhorias.",
                                "Cria um dashboard visual com previsões e insights acionáveis."
                              ],
                              "assessmentCriteria": [
                                "Precisão do forecast (MAE/RMSE em dados de teste).",
                                "Correta identificação e tratamento de sazonalidade.",
                                "Qualidade da preparação de dados (limpeza e features).",
                                "Profundidade da interpretação e conexões com marketing.",
                                "Robustez do modelo (intervalos de confiança e validação).",
                                "Clareza do relatório e visualizações.",
                                "Criatividade em aplicações reais de campanhas."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Testes de estacionariedade e métricas de erro.",
                                "Negócios/Marketing: Estratégias de precificação e estoque baseadas em forecasts.",
                                "Programação: Manipulação de dados em Python/R.",
                                "Economia: Modelagem de ciclos econômicos em demanda do consumidor.",
                                "Visualização de Dados: Criação de dashboards interativos."
                              ],
                              "realWorldApplication": "Empresas como Magazine Luiza ou Amazon usam forecasting de séries temporais para otimizar estoque sazonal, planejar campanhas promocionais como Black Friday e prever churn de clientes, reduzindo custos em até 20% e aumentando vendas em períodos de pico."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "17.1.1.2.3.2",
                            "name": "Otimizar operações e estoques",
                            "description": "Descrever aplicações em gerenciamento de cadeia de suprimentos, previsão de lead times e controle de inventários usando modelos de séries temporais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender e preparar dados de séries temporais para operações e estoques",
                                  "subSteps": [
                                    "Colete dados históricos de lead times, níveis de estoque e demanda de uma cadeia de suprimentos simulada ou real.",
                                    "Limpe os dados removendo outliers e valores ausentes usando técnicas de imputação temporal.",
                                    "Transforme os dados em formato de série temporal com índice de tempo adequado (diário/semanal).",
                                    "Visualize tendências, sazonalidades e ciclos usando gráficos de linha e decomposição.",
                                    "Calcule estatísticas descritivas como autocorrelação para identificar padrões."
                                  ],
                                  "verification": "Crie um relatório ou notebook com gráficos e estatísticas que mostrem padrões claros nos dados.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Python (pandas, matplotlib, statsmodels), dataset de exemplo de estoque (ex: Kaggle Supply Chain dataset)",
                                  "tips": "Sempre padronize a frequência temporal para evitar erros de agregação.",
                                  "learningObjective": "Preparar dados de séries temporais específicos para análise operacional.",
                                  "commonMistakes": "Ignorar sazonalidades ou não tratar missing values adequadamente, levando a previsões enviesadas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Prever lead times usando modelos de séries temporais",
                                  "subSteps": [
                                    "Selecione e ajuste um modelo ARIMA para dados de lead times históricos.",
                                    "Teste estacionariedade com testes ADF e diferencie se necessário.",
                                    "Valide o modelo com métricas como MAE e RMSE em dados de teste.",
                                    "Gere previsões para os próximos 30 dias e plote com intervalos de confiança.",
                                    "Compare previsões com dados reais para refinar parâmetros."
                                  ],
                                  "verification": "Produza previsões com RMSE abaixo de 10% em conjunto de validação.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Python (statsmodels, pmdarima para auto-ARIMA), Jupyter Notebook",
                                  "tips": "Use auto-ARIMA para agilizar a seleção de parâmetros (p,d,q).",
                                  "learningObjective": "Aplicar modelos de séries temporais para prever lead times com precisão.",
                                  "commonMistakes": "Não verificar estacionariedade, resultando em modelos instáveis."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modelar e controlar inventários com previsões de séries temporais",
                                  "subSteps": [
                                    "Integre previsões de demanda de séries temporais (ex: modelo ETS ou Prophet).",
                                    "Calcule níveis de estoque de segurança usando previsões de lead time e variância.",
                                    "Simule reorder points e quantities com modelo (s,S) ou EOQ adaptado.",
                                    "Aplique controle de inventário ABC para priorizar itens.",
                                    "Avalie custos de holding e faltas com simulações baseadas em previsões."
                                  ],
                                  "verification": "Desenvolva um dashboard ou tabela mostrando redução simulada de 15% em custos de estoque.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Python (prophet, numpy, pandas), Excel para simulações simples",
                                  "tips": "Incorpore buffers de segurança baseados em desvios padrão das previsões.",
                                  "learningObjective": "Usar séries temporais para otimizar controle de inventários.",
                                  "commonMistakes": "Subestimar variabilidade de lead times, causando overstocking."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Otimizar operações na cadeia de suprimentos com integração de modelos",
                                  "subSteps": [
                                    "Combine previsões de lead times e demanda em um modelo de supply chain simulado.",
                                    "Otimize fluxos com simulação Monte Carlo para cenários de risco.",
                                    "Avalie impactos em KPIs como tempo de ciclo e taxa de serviço.",
                                    "Gere recomendações acionáveis para ajustes operacionais.",
                                    "Documente o pipeline completo em um relatório final."
                                  ],
                                  "verification": "Crie um relatório com simulações mostrando otimização de pelo menos 20% em eficiência.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Python (simpy para simulação, plotly para visualizações), relatório template",
                                  "tips": "Teste múltiplos cenários para robustez contra choques externos.",
                                  "learningObjective": "Integrar séries temporais em otimização holística de supply chain.",
                                  "commonMistakes": "Não considerar correlações entre variáveis, levando a otimizações subótimas."
                                }
                              ],
                              "practicalExample": "Em uma fábrica de eletrônicos, use dados históricos de lead times de fornecedores para prever atrasos com ARIMA, ajustando estoques de componentes críticos e reduzindo faltas em 25% durante picos de demanda natalina.",
                              "finalVerifications": [
                                "Pode descrever com precisão como séries temporais impactam lead times e estoques.",
                                "Conseguiu gerar previsões precisas (RMSE <15%) em dataset de teste.",
                                "Simulou otimização de estoque resultando em redução de custos mensurável.",
                                "Identificou e mitigou padrões sazonais em dados operacionais.",
                                "Explicou aplicações em supply chain com exemplos reais.",
                                "Criou um pipeline reprodutível de análise."
                              ],
                              "assessmentCriteria": [
                                "Precisão das previsões (métricas quantitativas como MAE/RMSE).",
                                "Qualidade da preparação e visualização de dados (clareza e completude).",
                                "Adequação dos modelos de séries temporais ao contexto operacional.",
                                "Profundidade das simulações de otimização e análise de sensibilidade.",
                                "Clareza e estrutura do relatório final com insights acionáveis.",
                                "Integração correta de conceitos de supply chain."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelos estocásticos e otimização linear.",
                                "Administração: Gestão de operações e logística.",
                                "TI: Programação em Python/R e ferramentas de BI (Tableau/Power BI).",
                                "Economia: Análise de custos e previsão econômica."
                              ],
                              "realWorldApplication": "Empresas como Amazon usam séries temporais para prever demanda e lead times, otimizando estoques em centros de distribuição e reduzindo custos operacionais em bilhões anualmente."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "17.1.1.2.3.3",
                            "name": "Identificar sazonalidade operacional",
                            "description": "Reconhecer padrões sazonais em dados de marketing e operações, como picos de vendas em feriados, e sua relevância para planejamento estratégico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Sazonalidade em Séries Temporais",
                                  "subSteps": [
                                    "Defina sazonalidade como padrões repetitivos em intervalos fixos, como mensais ou anuais.",
                                    "Estude exemplos clássicos: picos de vendas no Natal ou Black Friday em dados de varejo.",
                                    "Diferencie sazonalidade de tendências e ciclos irregulares usando diagramas explicativos.",
                                    "Revise a relevância para marketing (campanhas sazonais) e operações (gestão de estoque).",
                                    "Anote definições chave em um glossário pessoal."
                                  ],
                                  "verification": "Crie um mapa mental conectando sazonalidade a exemplos reais e explique para um colega.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Vídeos tutoriais sobre séries temporais (Khan Academy ou YouTube), papel e caneta para mapa mental.",
                                  "tips": "Use analogias cotidianas, como ondas do mar, para visualizar repetições.",
                                  "learningObjective": "Dominar a definição e distinções de sazonalidade em contextos de negócios.",
                                  "commonMistakes": "Confundir sazonalidade com variações aleatórias ou tendências de longo prazo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Coletar e Preparar Dados de Marketing e Operações",
                                  "subSteps": [
                                    "Identifique fontes de dados: planilhas de vendas históricas, Google Analytics ou ERP.",
                                    "Selecione um período de pelo menos 2-3 anos para capturar múltiplos ciclos sazonais.",
                                    "Limpe os dados: remova outliers, preencha valores ausentes e agregue por período (diário/semanal).",
                                    "Crie colunas para data, métrica principal (ex: vendas) e feriados relevantes.",
                                    "Exporte para formato analisável como CSV."
                                  ],
                                  "verification": "Verifique se o dataset tem pelo menos 24 meses de dados limpos sem erros óbvios.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Planilhas Excel/Google Sheets, datasets públicos de vendas (Kaggle), software como Python Pandas.",
                                  "tips": "Sempre marque feriados em uma coluna separada para correlação posterior.",
                                  "learningObjective": "Preparar datasets reais para análise sazonal eficaz.",
                                  "commonMistakes": "Ignorar dados incompletos ou não alinhar datas corretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Visualizar e Detectar Padrões Sazonais",
                                  "subSteps": [
                                    "Plote a série temporal como gráfico de linha com eixo temporal.",
                                    "Aplique decomposição sazonal (usando ferramentas como STL em R/Python).",
                                    "Sobreponha múltiplos anos para destacar repetições (ex: médias móveis sazonais).",
                                    "Identifique picos/vales: marque datas como Natal, verão ou fim de ano fiscal.",
                                    "Calcule índices sazonais (média dividida pela tendência)."
                                  ],
                                  "verification": "Gere gráficos mostrando padrões claros e anote 3-5 picos sazonais identificados.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Python (Matplotlib/Seaborn), R (ggplot2), Excel com gráficos avançados.",
                                  "tips": "Use zoom em períodos específicos e cores para diferenciar anos.",
                                  "learningObjective": "Detectar visual e quantitativamente padrões sazonais em dados.",
                                  "commonMistakes": "Não normalizar escalas ou ignorar efeitos de calendário (ex: leap years)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Sazonalidade e Planejar Estratégias",
                                  "subSteps": [
                                    "Relacione padrões a eventos: picos de vendas em feriados afetam estoque.",
                                    "Quantifique impacto: calcule % de aumento sazonal e variância.",
                                    "Proponha ações: aumentar produção pré-feriado ou campanhas targeted.",
                                    "Simule cenários: 'e se' sem ajuste sazonal no planejamento.",
                                    "Documente relatório com insights acionáveis."
                                  ],
                                  "verification": "Elabore um plano estratégico de 1 página baseado nos padrões detectados.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Templates de relatório, calculadora ou software de simulação.",
                                  "tips": "Priorize os 2-3 padrões mais impactantes para ações imediatas.",
                                  "learningObjective": "Aplicar insights sazonais ao planejamento de marketing e operações.",
                                  "commonMistakes": "Focar só em detecção sem ligar a decisões estratégicas."
                                }
                              ],
                              "practicalExample": "Em dados de vendas de uma loja de e-commerce (2019-2022), identifique picos de 150% em novembro (Black Friday) e dezembro (Natal), quedas de 30% em fevereiro, permitindo planejar estoque extra para Q4 e promoções em baixa temporada.",
                              "finalVerifications": [
                                "Gráficos mostram padrões repetitivos claros em múltiplos anos.",
                                "Índices sazonais calculados com precisão >90%.",
                                "Relatório liga sazonalidade a pelo menos 3 ações estratégicas.",
                                "Diferenciação correta entre sazonal, tendência e ruído.",
                                "Simulação de planejamento sem sazonalidade destaca riscos.",
                                "Documentação completa com fontes e cálculos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de padrões (80% match com dados reais).",
                                "Qualidade das visualizações (clareza, legendas, escalas).",
                                "Profundidade da análise estratégica (impacto quantificado).",
                                "Completude da preparação de dados (limpeza e cobertura temporal).",
                                "Criatividade nas conexões com planejamento.",
                                "Ausência de erros comuns em interpretação."
                              ],
                              "crossCurricularConnections": [
                                "Marketing: Otimização de campanhas sazonais.",
                                "Gestão de Operações: Previsão de demanda e estoque.",
                                "Economia: Análise de ciclos econômicos regionais.",
                                "Estatística: Modelos de regressão sazonal.",
                                "Negócios: Planejamento financeiro anual."
                              ],
                              "realWorldApplication": "Em uma rede de varejo, identificar sazonalidade permite contratar temporários pré-Natal, reduzindo custos de estoque em 20% e aumentando vendas em 15% via promoções targeted."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.3",
                    "name": "Tipos de Dados em Séries Temporais",
                    "description": "Classificação dos tipos de dados temporais, incluindo univariados, multivariados e categóricos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.3.1",
                        "name": "Séries Temporais Univariadas",
                        "description": "Séries temporais univariadas consistem em uma única variável numérica observada sequencialmente ao longo do tempo, permitindo análise focada em padrões temporais de uma dimensão.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.1.1",
                            "name": "Identificar séries univariadas",
                            "description": "Reconhecer e diferenciar séries temporais univariadas de outros tipos em conjuntos de dados, analisando a presença de uma única coluna de valores numéricos indexados por tempo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição e características de séries univariadas",
                                  "subSteps": [
                                    "Leia a definição: uma série temporal univariada consiste em uma única variável numérica observada ao longo do tempo.",
                                    "Identifique elementos chave: índice temporal (datas/horas) e uma única coluna de valores.",
                                    "Estude exemplos simples, como temperatura diária.",
                                    "Anote diferenças básicas com séries multivariadas (múltiplas variáveis).",
                                    "Revise glossário de termos: univariada vs. multivariada, indexação temporal."
                                  ],
                                  "verification": "Explique em suas palavras o que é uma série univariada e liste 3 características principais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Definição impressa ou digital da habilidade",
                                    "Notebook para anotações",
                                    "Vídeo introdutório sobre séries temporais (ex: Khan Academy)"
                                  ],
                                  "tips": "Use analogias: pense em uma série univariada como uma linha única em um gráfico de tempo vs. valor.",
                                  "learningObjective": "Definir precisamente séries univariadas e suas características fundamentais.",
                                  "commonMistakes": [
                                    "Confundir com dados tabulares sem índice temporal",
                                    "Ignorar que valores devem ser numéricos contínuos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Examinar a estrutura de um conjunto de dados",
                                  "subSteps": [
                                    "Carregue um dataset de exemplo em uma ferramenta como Excel ou Python (Pandas).",
                                    "Inspecione colunas: verifique se há exatamente uma coluna de valores numéricos além do índice temporal.",
                                    "Confirme o índice: deve ser datado (ex: YYYY-MM-DD).",
                                    "Visualize os dados: plote um gráfico de linha para observar o padrão temporal.",
                                    "Documente a estrutura: número de colunas, tipo de índice e tipo de dados."
                                  ],
                                  "verification": "Crie um resumo da estrutura do dataset, confirmando se atende aos critérios univariados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Dataset de exemplo (CSV com temperatura diária)",
                                    "Excel, Google Sheets ou Jupyter Notebook com Pandas"
                                  ],
                                  "tips": "Sempre comece pelo 'head()' ou primeira linhas para visão rápida.",
                                  "learningObjective": "Analisar a estrutura de dados para identificar componentes de séries temporais.",
                                  "commonMistakes": [
                                    "Não verificar tipos de dados (ex: tratar strings como numéricos)",
                                    "Omitir validação do índice temporal"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar critérios de identificação em datasets reais",
                                  "subSteps": [
                                    "Selecione 3 datasets mistos: um univariado, um multivariado e um não-temporal.",
                                    "Aplique checklist: 1) Índice temporal? 2) Uma única variável numérica? 3) Observações sequenciais no tempo?",
                                    "Classifique cada um como univariado ou não, justificando.",
                                    "Plote gráficos para visual confirmação.",
                                    "Registre achados em uma tabela de classificação."
                                  ],
                                  "verification": "Classifique corretamente 3 datasets e forneça justificativas escritas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "3 datasets CSV de exemplo (temperatura, vendas com múltiplas cols, dados aleatórios)",
                                    "Ferramenta de plotagem (Matplotlib ou Excel)"
                                  ],
                                  "tips": "Use df.info() no Pandas para tipos rápidos; foque em 'uma variável dependente'.",
                                  "learningObjective": "Aplicar critérios sistemáticos para identificar séries univariadas.",
                                  "commonMistakes": [
                                    "Classificar dados com índice temporal mas múltiplas cols como univariados",
                                    "Ignorar lacunas no tempo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar séries univariadas de outros tipos e praticar",
                                  "subSteps": [
                                    "Compare univariada vs. multivariada: analise um par de datasets.",
                                    "Identifique não-séries temporais: ex. dados cross-sectionais sem tempo.",
                                    "Resolva 5 exercícios de classificação rápida.",
                                    "Discuta casos ambíguos: ex. dados com metadados extras.",
                                    "Autoavalie com quiz simples."
                                  ],
                                  "verification": "Diferencie corretamente 80% dos casos em um conjunto de 5 exemplos mistos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exercícios impressos ou Google Form com 5 datasets",
                                    "Comparação tabela (univariada x multivariada)"
                                  ],
                                  "tips": "Pergunte: 'Posso plotar tudo em uma linha única contra tempo?' Se sim, univariada.",
                                  "learningObjective": "Diferenciar univariadas de outros tipos com confiança.",
                                  "commonMistakes": [
                                    "Confundir séries com múltiplas variáveis independentes",
                                    "Não considerar frequência temporal"
                                  ]
                                }
                              ],
                              "practicalExample": "Analise o dataset de 'preços diários de ações de uma empresa única' (colunas: Data, Preço). Identifique como univariada: índice 'Data' temporal, única coluna numérica 'Preço'. Plote Preço vs. Data para confirmar padrão temporal sequencial.",
                              "finalVerifications": [
                                "Explica corretamente a definição de série univariada em termos de estrutura de dados.",
                                "Identifica univariadas em 4/5 datasets de teste mistos.",
                                "Lista e aplica 4 critérios chave (índice temporal, única variável numérica, etc.).",
                                "Diferencia univariada de multivariada com exemplos.",
                                "Cria gráfico simples de uma série univariada fornecida.",
                                "Responde quiz de 10 perguntas com 90% acerto."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação: 100% em critérios estruturais.",
                                "Justificativa clara: cada classificação suportada por evidências.",
                                "Velocidade e eficiência: análise em <5 min por dataset.",
                                "Visualização adequada: gráficos revelam padrão temporal.",
                                "Diferenciação robusta: sem confusão com multivariadas ou não-temporais.",
                                "Aplicação consistente: funciona em datasets reais variados."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Uso de Pandas/Python para inspeção de dados (Data Science).",
                                "Matemática: Conceitos de funções univariadas e sequências (Álgebra).",
                                "Economia: Análise de indicadores econômicos como PIB trimestral.",
                                "Ciências Ambientais: Monitoramento de temperatura ou poluição ao longo do tempo."
                              ],
                              "realWorldApplication": "Em previsão de demanda, identificar séries univariadas de vendas diárias de um produto permite modelar tendências simples sem complexidade multivariada, auxiliando estoques em varejo ou previsão climática básica."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.1.2",
                            "name": "Exemplificar aplicações univariadas",
                            "description": "Listar e descrever exemplos reais de séries univariadas, como preços de ações diários ou temperaturas mensais, destacando sua estrutura básica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Séries Temporais Univariadas",
                                  "subSteps": [
                                    "Defina série temporal univariada como uma sequência de dados observados em intervalos regulares de tempo, envolvendo apenas uma variável.",
                                    "Diferencie de séries multivariadas, destacando que univariadas focam em uma única métrica ao longo do tempo.",
                                    "Identifique componentes básicos: tendência (direção geral), sazonalidade (padrões repetitivos) e ruído (variações aleatórias).",
                                    "Revise exemplos iniciais como temperatura diária ou preço de ação para fixar o conceito."
                                  ],
                                  "verification": "Escreva uma definição em suas próprias palavras e liste 2 diferenças chave de multivariadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notebook para anotações",
                                    "Acesso à internet para consulta de definições (ex: Wikipedia ou Khan Academy)"
                                  ],
                                  "tips": "Use analogias simples, como medir a altura de uma planta diariamente (uma variável só).",
                                  "learningObjective": "Dominar a definição e estrutura básica de séries univariadas.",
                                  "commonMistakes": "Confundir univariada com multivariada ao incluir múltiplas variáveis no mesmo exemplo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Listar Exemplos Reais de Séries Univariadas",
                                  "subSteps": [
                                    "Pesquise exemplos comuns: preços de ações diários, temperaturas mensais, vendas semanais de um produto.",
                                    "Liste pelo menos 5 exemplos de diferentes domínios (finanças, clima, saúde, economia).",
                                    "Classifique cada exemplo por frequência temporal (diária, mensal, anual) e unidade de medida.",
                                    "Documente fontes reais de dados, como Yahoo Finance para ações ou NOAA para temperaturas."
                                  ],
                                  "verification": "Crie uma tabela com 5 exemplos, incluindo domínio, variável e frequência.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Internet para pesquisa (Yahoo Finance, NOAA, World Bank data)",
                                    "Planilha ou documento para tabela"
                                  ],
                                  "tips": "Priorize exemplos acessíveis online para verificação posterior.",
                                  "learningObjective": "Reconhecer aplicações práticas de séries univariadas em contextos reais.",
                                  "commonMistakes": "Escolher exemplos que inadvertidamente envolvam múltiplas variáveis, como 'preços e volumes de ações'."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Descrever a Estrutura Básica de Exemplos Selecionados",
                                  "subSteps": [
                                    "Selecione 2-3 exemplos da lista anterior (ex: preços de ações diários e temperaturas mensais).",
                                    "Para cada um, descreva a estrutura: índice temporal (eixo x: datas), variável observada (eixo y: valor numérico), ordenação cronológica obrigatória.",
                                    "Inclua um gráfico simples ou tabela de amostra com 5-10 pontos de dados fictícios ou reais.",
                                    "Destaque como a univariabilidade simplifica a análise inicial."
                                  ],
                                  "verification": "Produza descrições escritas e esboços de gráficos para os exemplos selecionados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de planilha (Google Sheets ou Excel) para tabelas e gráficos simples",
                                    "Dados de exemplo baixados"
                                  ],
                                  "tips": "Sempre marque o eixo temporal explicitamente para visualizar a sequência.",
                                  "learningObjective": "Analisar e articular a estrutura fundamental de séries univariadas.",
                                  "commonMistakes": "Ignorar a ordenação temporal, tratando dados como não sequenciais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Compilar uma Lista Completa e Destacar Aplicações",
                                  "subSteps": [
                                    "Compile todos os exemplos em uma lista final com descrições concisas de estrutura básica.",
                                    "Adicione uma breve nota sobre por que cada exemplo é univariado e sua utilidade prática.",
                                    "Crie um resumo comparativo entre 2 exemplos (ex: ações vs. temperatura).",
                                    "Revise e refine a lista para clareza e precisão."
                                  ],
                                  "verification": "Apresente a lista final com pelo menos 4 exemplos bem descritos e comparados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documento final (Word ou Google Docs)",
                                    "Lista compilada dos passos anteriores"
                                  ],
                                  "tips": "Use bullet points para descrições curtas e impactantes.",
                                  "learningObjective": "Sintetizar conhecimento em uma exemplificação clara e acionável.",
                                  "commonMistakes": "Fazer descrições genéricas sem destacar a estrutura temporal básica."
                                }
                              ],
                              "practicalExample": "Considere os preços diários de fechamento da ação AAPL (Apple) de janeiro a março de 2023: [150.10 (01/01), 152.45 (02/01), ..., 165.20 (31/03)]. Estrutura: Índice temporal (datas diárias), variável única (preço em USD), sequência ordenada revelando tendência ascendente com flutuações.",
                              "finalVerifications": [
                                "Lista contém pelo menos 4 exemplos reais de séries univariadas.",
                                "Cada exemplo inclui descrição da estrutura básica (temporal e variável).",
                                "Exemplos cobrem domínios variados (ex: finanças, clima).",
                                "Gráficos ou tabelas simples ilustram pelo menos 2 exemplos.",
                                "Comparação entre exemplos destaca univariabilidade."
                              ],
                              "assessmentCriteria": [
                                "Relevância e realismo dos exemplos selecionados (máx. 25%).",
                                "Precisão na descrição da estrutura básica (temporal, variável única) (máx. 30%).",
                                "Clareza e detalhe nas descrições e visualizações (máx. 20%).",
                                "Cobertura de múltiplos domínios e frequência temporal (máx. 15%).",
                                "Capacidade de comparação e síntese (máx. 10%)."
                              ],
                              "crossCurricularConnections": [
                                "Economia e Finanças: Análise de tendências de mercado via preços de ações.",
                                "Ciências Ambientais: Monitoramento de temperaturas para estudos climáticos.",
                                "Saúde Pública: Registros diários de casos de doenças infecciosas.",
                                "Administração: Previsão de vendas mensais em negócios."
                              ],
                              "realWorldApplication": "Séries univariadas são usadas em finanças para prever movimentos de ações, em meteorologia para alertas de ondas de calor baseados em temperaturas históricas, e em varejo para otimizar estoques via padrões de vendas diárias, permitindo análises simples e focadas em uma métrica chave para decisões rápidas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.1.3",
                            "name": "Analisar componentes básicos",
                            "description": "Descrever os componentes essenciais de uma série univariada, incluindo tendência, sazonalidade e ruído, com base em gráficos simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os componentes essenciais de uma série univariada",
                                  "subSteps": [
                                    "Defina tendência como a direção geral de longo prazo (aumento, diminuição ou estável).",
                                    "Explique sazonalidade como padrões repetitivos em intervalos regulares (ex: mensal, anual).",
                                    "Descreva ruído como variações aleatórias imprevisíveis sem padrão discernível.",
                                    "Estude a equação decompositiva: Série = Tendência + Sazonalidade + Ruído.",
                                    "Revise exemplos visuais de cada componente isolado em gráficos."
                                  ],
                                  "verification": "Escreva definições curtas para cada componente e identifique-os em um diagrama fornecido.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Notas de aula, vídeo introdutório sobre séries temporais (ex: Khan Academy), papel e caneta.",
                                  "tips": "Use analogias: tendência é como uma rampa suave, sazonalidade é como ondas regulares, ruído é estática.",
                                  "learningObjective": "Identificar e definir com precisão os três componentes básicos de uma série univariada.",
                                  "commonMistakes": "Confundir sazonalidade com tendência de curto prazo ou ignorar que ruído não é eliminável."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Coletar e visualizar uma série temporal univariada",
                                  "subSteps": [
                                    "Obtenha um conjunto de dados univariado simples (ex: temperatura diária por 2 anos).",
                                    "Use software para plotar o gráfico de linha temporal (eixo x: tempo, y: valor).",
                                    "Ajuste escalas e adicione rótulos claros para tempo e valores.",
                                    "Observe o gráfico em diferentes escalas de zoom para padrões gerais.",
                                    "Salve o gráfico anotado para referência."
                                  ],
                                  "verification": "Produza um gráfico legível com dados plotados e anotações iniciais de padrões observados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Computador com Python (pandas, matplotlib) ou Excel/Google Sheets, conjunto de dados exemplo (ex: airpassengers.csv).",
                                  "tips": "Comece com dados conhecidos para praticar; evite gráficos muito densos inicialmente.",
                                  "learningObjective": "Gerar visualizações claras de séries temporais para análise inicial.",
                                  "commonMistakes": "Plotar dados errados ou usar escalas inadequadas que mascaram padrões."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e descrever a tendência no gráfico",
                                  "subSteps": [
                                    "Trace uma linha suave ao longo dos dados ignorando flutuações curtas.",
                                    "Descreva a direção (crescente, decrescente, constante) e magnitude aproximada.",
                                    "Quantifique se possível (ex: aumento de 2% ao mês).",
                                    "Compare com médias móveis para confirmar.",
                                    "Anotar no gráfico com seta ou linha tracejada."
                                  ],
                                  "verification": "Escreva uma descrição de 2-3 frases da tendência e destaque-a no gráfico.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Gráfico gerado no step 2, ferramenta de edição de imagem ou código para anotações.",
                                  "tips": "Pense em 'zoom out' para ver o quadro geral; use suavização para ajudar.",
                                  "learningObjective": "Detectar e descrever a tendência dominante em uma série temporal.",
                                  "commonMistakes": "Misturar tendência com sazonalidade de curto prazo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar sazonalidade, ruído e compor a descrição completa",
                                  "subSteps": [
                                    "Identifique padrões repetitivos (ex: picos todo verão) e meça seu ciclo.",
                                    "Descreva amplitude e fase da sazonalidade.",
                                    "O que resta após remover tendência e sazonalidade é ruído; confirme aleatoriedade.",
                                    "Escreva uma descrição integrada: 'Tendência X, sazonalidade Y, ruído Z'.",
                                    "Valide removendo componentes mentalmente ou com ferramentas simples."
                                  ],
                                  "verification": "Forneça uma descrição completa dos três componentes com evidências do gráfico.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Gráfico anotado, calculadora ou software para médias móveis/sazonal.",
                                  "tips": "Use sobreposição de ciclos sazonais no gráfico para visualização.",
                                  "learningObjective": "Decompor completamente uma série univariada em seus componentes básicos.",
                                  "commonMistakes": "Atribuir ruído a sazonalidade ou vice-versa; superestimar padrões no ruído."
                                }
                              ],
                              "practicalExample": "Em dados de vendas mensais de sorvetes (1950-1960): tendência crescente devido a população; sazonalidade com picos em junho-agosto; ruído de variações climáticas anômalas. Plote e descreva: 'Tendência linear ascendente ~5k unidades/ano; sazonalidade anual pico 2x base; ruído <10% variância'.",
                              "finalVerifications": [
                                "Descreve corretamente tendência, sazonalidade e ruído em um gráfico dado.",
                                "Identifica ciclo sazonal preciso (ex: 12 meses).",
                                "Distingue ruído de padrões reais.",
                                "Quantifica componentes qualitativamente ou com métricas simples.",
                                "Explica decomposição em uma frase coesa.",
                                "Aplica a um novo gráfico sem ajuda."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de cada componente (80%+ acerto).",
                                "Descrições claras e baseadas em evidências visuais.",
                                "Uso correto de termos técnicos (tendência, sazonalidade, ruído).",
                                "Quantificação aproximada onde aplicável.",
                                "Ausência de confusão entre componentes.",
                                "Capacidade de validar decomposição."
                              ],
                              "crossCurricularConnections": [
                                "Economia: Previsão de vendas e PIB.",
                                "Ciência Ambiental: Análise de temperaturas e ciclos climáticos.",
                                "Matemática: Regressão linear para tendência.",
                                "Programação: Visualização de dados com Python/R.",
                                "Negócios: Planejamento de estoque sazonal."
                              ],
                              "realWorldApplication": "Analisar vendas de varejo para otimizar estoque (tendência para crescimento, sazonalidade para promoções), prever demanda energética por padrões climáticos sazonais, ou monitorar evolução de epidemias removendo ruído para tendência real."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.3.2",
                        "name": "Séries Temporais Multivariadas",
                        "description": "Séries temporais multivariadas envolvem múltiplas variáveis observadas simultaneamente ao longo do tempo, capturando interdependências entre elas para análises mais complexas.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.2.1",
                            "name": "Diferenciar univariadas de multivariadas",
                            "description": "Comparar estruturas de dados univariados e multivariados, identificando matrizes com múltiplas colunas temporais em datasets reais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Séries Temporais Univariadas",
                                  "subSteps": [
                                    "Defina série temporal univariada como uma sequência de dados observados em intervalos regulares de tempo para uma única variável.",
                                    "Examine exemplos como medições diárias de temperatura ou preços de ações individuais.",
                                    "Visualize a estrutura: um vetor 1D ou coluna única em um DataFrame com índice temporal.",
                                    "Pratique carregando um dataset univariado simples usando pandas.",
                                    "Identifique características chave: ausência de variáveis correlacionadas adicionais."
                                  ],
                                  "verification": "Crie um gráfico de linha de uma série univariada e confirme que há apenas uma linha no plot.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python com pandas e matplotlib; dataset exemplo como 'AirPassengers.csv' (univariado).",
                                  "tips": "Sempre verifique o shape do DataFrame: deve ser (n, 1) para univariado.",
                                  "learningObjective": "Dominar a definição e representação básica de dados univariados em séries temporais.",
                                  "commonMistakes": "Confundir com dados categóricos ou não temporais; ignorar o índice de tempo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender Séries Temporais Multivariadas",
                                  "subSteps": [
                                    "Defina série temporal multivariada como dados com múltiplas variáveis medidas ao mesmo tempo, formando uma matriz (n x m).",
                                    "Examine exemplos como temperatura, umidade e pressão em estações meteorológicas.",
                                    "Visualize a estrutura: múltiplas colunas com o mesmo índice temporal em um DataFrame.",
                                    "Carregue um dataset multivariado e inspecione as colunas com df.head() e df.shape.",
                                    "Note correlações potenciais entre variáveis para análise conjunta."
                                  ],
                                  "verification": "Plote múltiplas séries no mesmo gráfico e confirme interações visíveis entre linhas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Python com pandas e matplotlib; dataset exemplo como 'multivariate_time_series.csv' com colunas 'temp', 'humidity', 'pressure'.",
                                  "tips": "Use df.corr() para visualizar correlações iniciais entre variáveis.",
                                  "learningObjective": "Reconhecer a estrutura matricial e implicações de múltiplas variáveis temporais.",
                                  "commonMistakes": "Tratar multivariadas como independentes; confundir com dados tabulares não temporais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Estruturas Univariadas e Multivariadas",
                                  "subSteps": [
                                    "Crie tabelas comparativas: dimensões (1D vs. 2D), análise (marginal vs. conjunta), complexidade computacional.",
                                    "Analise diferenças em modelagem: ARIMA univariado vs. VAR multivariado.",
                                    "Construa DataFrames lado a lado: um univariado e um multivariado para inspeção.",
                                    "Calcule estatísticas descritivas separadas e compare.",
                                    "Discuta quando usar cada tipo baseado em objetivos analíticos."
                                  ],
                                  "verification": "Gere uma tabela Markdown ou print comparando shapes, colunas e exemplos de cada tipo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python com pandas; dois datasets: um univariado e um multivariado.",
                                  "tips": "Use pd.concat([df_uni, df_multi], axis=1) para visualização paralela.",
                                  "learningObjective": "Diferenciar precisamente as estruturas e suas implicações analíticas.",
                                  "commonMistakes": "Ignorar dependências cruzadas em multivariadas; superestimar simplicidade univariada."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar Tipos em Datasets Reais",
                                  "subSteps": [
                                    "Baixe datasets reais como 'mauna_loa.csv' (univariado CO2) e 'energy_dataset.csv' (multivariado consumo).",
                                    "Inspecione df.info() e df.columns para contar variáveis temporais.",
                                    "Classifique: se 1 coluna numérica com tempo → univariada; múltiplas → multivariada.",
                                    "Aplique testes: correlograma para univariada; heatmap de correlação para multivariada.",
                                    "Documente achados em um relatório curto."
                                  ],
                                  "verification": "Classifique corretamente 3 datasets reais e justifique com shapes e plots.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Datasets reais de Kaggle/UCI: CO2 (uni), energy/meteorology (multi); Python com seaborn para heatmaps.",
                                  "tips": "Verifique se todas colunas são numéricas e indexadas por tempo antes de classificar.",
                                  "learningObjective": "Aplicar diferenciação prática em dados reais para identificação precisa.",
                                  "commonMistakes": "Classificar dados com features não-temporais como multivariados; ignorar missing values."
                                }
                              ],
                              "practicalExample": "Carregue o dataset de consumo de energia (multivariado: uso, temperatura, umidade por hora). Compare com série de preços de ações (univariado). Plote ambos: univariado mostra uma linha; multivariado mostra múltiplas linhas correlacionadas, revelando como temperatura afeta consumo.",
                              "finalVerifications": [
                                "Pode definir univariada (1 variável temporal) vs. multivariada (múltiplas variáveis no mesmo tempo).",
                                "Inspeciona df.shape e df.columns corretamente em qualquer dataset.",
                                "Gera plots comparativos sem erros de dimensionamento.",
                                "Identifica correlações em multivariadas usando heatmap.",
                                "Classifica 3 datasets reais com 100% acurácia.",
                                "Explica diferenças em modelagem (ex: ARIMA vs. VAR)."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas sem confusões (30%).",
                                "Habilidade prática: inspeção e visualização de dados (25%).",
                                "Comparação estrutural: tabelas/plots claros (20%).",
                                "Aplicação em datasets reais: classificação correta (15%).",
                                "Análise de implicações: discussão de modelagem/correlações (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Manipulação de DataFrames em Python/R.",
                                "Machine Learning: Preparação de features para modelos de forecasting.",
                                "Economia: Análise de séries multivariadas em indicadores macroeconômicos.",
                                "Ciência de Dados: Exploração inicial (EDA) de dados temporais."
                              ],
                              "realWorldApplication": "Em previsão meteorológica, diferencia univariada (apenas temperatura) de multivariada (temp + umidade + vento) para modelos mais precisos; em finanças, analisa ações isoladas vs. portfólios correlacionados para risco ajustado."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.2.2",
                            "name": "Explorar correlações multivariadas",
                            "description": "Calcular e interpretar correlações entre variáveis em séries multivariadas, utilizando matrizes de correlação para evidenciar relações temporais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os Dados das Séries Temporais Multivariadas",
                                  "subSteps": [
                                    "Coletar um dataset multivariado com timestamps alinhados (ex: colunas para tempo, variável1, variável2, etc.).",
                                    "Inspecionar os dados para identificar valores ausentes, outliers ou desalinhamentos temporais.",
                                    "Tratar valores ausentes usando interpolação linear ou forward-fill apropriado para séries temporais.",
                                    "Normalizar ou padronizar as variáveis (z-score) para permitir comparações justas de correlações.",
                                    "Verificar a estacionariedade básica das séries usando teste ADF ou plot de autocorrelação."
                                  ],
                                  "verification": "Dataset limpo, alinhado e padronizado, sem NaNs, pronto para cálculo de correlações.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Dataset CSV de séries temporais multivariadas (ex: clima e vendas)",
                                    "Python com bibliotecas pandas, numpy, matplotlib"
                                  ],
                                  "tips": "Use pd.to_datetime() para garantir índices temporais consistentes e evite reamostragem desnecessária.",
                                  "learningObjective": "Preparar dados multivariados de forma robusta para análise de correlações temporais.",
                                  "commonMistakes": [
                                    "Não alinhar timestamps levando a correlações espúrias.",
                                    "Ignorar valores ausentes resultando em matriz com NaNs.",
                                    "Padronizar sem verificar escalas iniciais."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a Matriz de Correlação",
                                  "subSteps": [
                                    "Carregar os dados em um DataFrame pandas com índice temporal.",
                                    "Selecionar as colunas numéricas das variáveis multivariadas.",
                                    "Computar a matriz de correlação de Pearson usando df.corr() ou numpy.corrcoef().",
                                    "Armazenar a matriz em um objeto pandas DataFrame para fácil manipulação.",
                                    "Calcular matriz de correlação com lags opcionais (ex: correlação cruzada para t-1) usando pd.corrwith(shifted_data)."
                                  ],
                                  "verification": "Matriz de correlação gerada corretamente, com valores entre -1 e 1, diagonal 1.0 e simétrica.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Jupyter Notebook ou script Python",
                                    "Bibliotecas pandas, numpy",
                                    "Dataset preparado do step 1"
                                  ],
                                  "tips": "Use method='pearson' explicitamente e verifique se há multicolinearidade com valores próximos a 1 ou -1.",
                                  "learningObjective": "Dominar o cálculo preciso de matrizes de correlação em dados temporais multivariados.",
                                  "commonMistakes": [
                                    "Calcular correlação em dados não estacionários levando a falsos positivos.",
                                    "Esquecer de excluir variáveis categóricas.",
                                    "Não considerar lags para relações temporais reais."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar a Matriz de Correlação",
                                  "subSteps": [
                                    "Identificar pares de variáveis com |r| > 0.7 como correlações fortes.",
                                    "Analisar sinal (positivo/negativo) e magnitude para relações temporais (ex: lead-lag).",
                                    "Testar significância estatística usando p-values via scipy.stats.pearsonr().",
                                    "Mapear correlações para contexto temporal (ex: variável A leva B por 1 período).",
                                    "Documentar insights em um relatório, destacando relações causais potenciais."
                                  ],
                                  "verification": "Relatório de interpretação escrito, com exemplos de correlações fortes e seus significados temporais.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Matriz de correlação do step 2",
                                    "Biblioteca scipy.stats",
                                    "Ferramenta de documentação (Markdown ou Notebook)"
                                  ],
                                  "tips": "Considere autocorrelações e cross-correlações para diferenciar relações simultâneas de temporais.",
                                  "learningObjective": "Interpretar correlações considerando contexto temporal e significância estatística.",
                                  "commonMistakes": [
                                    "Confundir correlação com causalidade.",
                                    "Ignorar p-values levando a interpretação de ruído.",
                                    "Não diferenciar correlações lagged de simultâneas."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Visualizar e Analisar Relações Temporais",
                                  "subSteps": [
                                    "Criar heatmap da matriz de correlação usando seaborn.heatmap().",
                                    "Plotar scatterplots ou line plots para pares de alta correlação com lags.",
                                    "Gerar correlograma cruzado (ccf) para evidenciar delays temporais.",
                                    "Analisar padrões como liderança (ex: variável X precede Y).",
                                    "Exportar visualizações e insights para apresentação."
                                  ],
                                  "verification": "Visualizações claras geradas, destacando relações temporais chave, com legenda e títulos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Bibliotecas seaborn, matplotlib",
                                    "Matriz e dados dos steps anteriores"
                                  ],
                                  "tips": "Use anotações no heatmap para valores >0.7 e cores divergentes para sinal.",
                                  "learningObjective": "Visualizar e analisar correlações para revelar dinâmicas temporais multivariadas.",
                                  "commonMistakes": [
                                    "Overplotting em heatmaps sem masks.",
                                    "Não incluir lags em plots lineares.",
                                    "Escalas inconsistentes nas visualizações."
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dados mensais de temperatura, precipitação e vendas de sorvetes em uma cidade (2018-2023): calcular a matriz de correlação revela r=0.85 entre temperatura e vendas (simultânea) e r=0.72 com lag de 1 mês para precipitação negativa, evidenciando que calor impulsiona vendas imediatamente, mas chuva passada reduz estoque.",
                              "finalVerifications": [
                                "Matriz de correlação calculada corretamente para dados multivariados.",
                                "Correlações interpretadas com atenção a lags e significância.",
                                "Visualizações claras destacam relações temporais.",
                                "Relatório resume insights acionáveis sem confundir correlação/causalidade.",
                                "Testes de significância aplicados a pelo menos 3 pares.",
                                "Dados tratados adequadamente sem artefatos."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo da matriz (valores exatos e simetria).",
                                "Profundidade na interpretação temporal (lags e sinais).",
                                "Qualidade das visualizações (legibilidade e relevância).",
                                "Correta identificação de erros comuns e limitações.",
                                "Uso apropriado de testes estatísticos.",
                                "Clareza e estrutura do relatório final."
                              ],
                              "crossCurricularConnections": [
                                "Economia: Correlações entre PIB, inflação e desemprego em séries trimestrais.",
                                "Ciência Ambiental: Relações temporais entre CO2, temperatura e níveis do mar.",
                                "Finanças: Correlações lagged entre ações, índices e commodities.",
                                "Saúde Pública: Correlações multivariadas em epidemias (casos, vacinas, mobilidade)."
                              ],
                              "realWorldApplication": "Em marketing, explorar correlações entre gastos em anúncios, tráfego web e vendas com lags revela que campanhas de TV levam conversões em 7 dias, otimizando orçamentos e estratégias de previsão de demanda."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.2.3",
                            "name": "Aplicar exemplos multivariados",
                            "description": "Descrever cenários práticos como previsão de vendas com variáveis de preço, publicidade e sazonalidade em múltiplas séries.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos de Séries Temporais Multivariadas",
                                  "subSteps": [
                                    "Estude a definição de séries temporais univariadas versus multivariadas.",
                                    "Identifique componentes como tendência, sazonalidade e variáveis exógenas.",
                                    "Revise exemplos clássicos, como previsão de vendas com múltiplos fatores.",
                                    "Analise dependências entre variáveis em séries temporais.",
                                    "Pratique identificando multivariabilidade em datasets reais."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos chave e forneça um exemplo simples.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Documentação de séries temporais (ex: livros de Hyndman), vídeos tutoriais no YouTube.",
                                  "tips": "Use diagramas de Venn para visualizar interações entre variáveis.",
                                  "learningObjective": "Dominar os fundamentos teóricos de séries multivariadas.",
                                  "commonMistakes": "Confundir variáveis endógenas com exógenas; ignorar autocorrelação."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Preparar Variáveis Relevantes",
                                  "subSteps": [
                                    "Selecione variáveis como preço, publicidade e sazonalidade para um cenário de vendas.",
                                    "Colete ou gere um dataset com múltiplas séries temporais alinhadas.",
                                    "Realize pré-processamento: tratamento de missing values e normalização.",
                                    "Crie lags e variáveis dummy para sazonalidade.",
                                    "Visualize correlações com gráficos de séries e matriz de correlação."
                                  ],
                                  "verification": "Crie um relatório com gráficos mostrando as variáveis selecionadas e preparadas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Python (pandas, matplotlib) ou R, dataset exemplo de vendas (Kaggle).",
                                  "tips": "Sempre verifique estacionariedade com teste ADF antes de prosseguir.",
                                  "learningObjective": "Selecionar e preparar dados multivariados adequadamente.",
                                  "commonMistakes": "Ignorar multicolinearidade entre variáveis; não alinhar timestamps."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir e Aplicar Modelo Multivariado",
                                  "subSteps": [
                                    "Escolha um modelo como VAR (Vector Autoregression) ou ARIMAX.",
                                    "Estime parâmetros do modelo com dados históricos.",
                                    "Gere previsões para um horizonte de 12 meses.",
                                    "Incorpore cenários: variação de preço e aumento de publicidade.",
                                    "Compare previsões com baseline univariada."
                                  ],
                                  "verification": "Execute o código e produza um gráfico de previsões multivariadas.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Bibliotecas statsmodels (Python) ou forecast (R), Jupyter Notebook.",
                                  "tips": "Comece com ordem baixa no VAR (p=1) e ajuste com AIC.",
                                  "learningObjective": "Implementar modelos multivariados para previsão prática.",
                                  "commonMistakes": "Sobreajuste por ordens altas; não validar suposições de normalidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar e Interpretar Resultados do Modelo",
                                  "subSteps": [
                                    "Calcule métricas como MAE, RMSE e MAPE para múltiplas séries.",
                                    "Analise resíduos para autocorrelação e heteroscedasticidade.",
                                    "Interprete impactos: elasticidade-preço e ROI de publicidade.",
                                    "Crie relatório com insights acionáveis para o cenário de vendas.",
                                    "Simule cenários what-if para sazonalidade."
                                  ],
                                  "verification": "Gere um dashboard ou relatório final com métricas e interpretações.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Ferramentas de visualização (seaborn, plotly), Excel para relatórios.",
                                  "tips": "Use intervalos de confiança nas previsões para robustez.",
                                  "learningObjective": "Avaliar criticamente modelos multivariados e extrair insights.",
                                  "commonMistakes": "Focar só em precisão; ignorar interpretabilidade econômica."
                                }
                              ],
                              "practicalExample": "Prever vendas mensais de smartphones considerando variáveis de preço unitário, investimento em publicidade (em R$) e sazonalidade (Natal/Black Friday), usando dados de 5 anos de uma rede varejista.",
                              "finalVerifications": [
                                "Descreve corretamente um cenário multivariado com pelo menos 3 variáveis.",
                                "Implementa um modelo VAR ou similar com código funcional.",
                                "Gera previsões precisas com métricas abaixo de 15% MAPE.",
                                "Interpreta impactos relativos das variáveis no resultado final.",
                                "Compara com modelo univariado mostrando superioridade multivariada.",
                                "Cria visualizações claras de séries e previsões."
                              ],
                              "assessmentCriteria": [
                                "Precisão do modelo (RMSE < 10% do desvio padrão).",
                                "Qualidade da preparação de dados (ausência de missing values e estacionariedade).",
                                "Profundidade da interpretação econômica dos coeficientes.",
                                "Uso adequado de múltiplas variáveis interdependentes.",
                                "Clareza e completude do relatório final.",
                                "Incorporação de sazonalidade e cenários what-if."
                              ],
                              "crossCurricularConnections": [
                                "Economia: Modelagem de demanda e elasticidades.",
                                "Marketing: Análise de eficácia de campanhas publicitárias.",
                                "Negócios: Otimização de estoque e planejamento estratégico.",
                                "Matemática: Álgebra linear em modelos vetoriais.",
                                "Computação: Programação em Python/R para análise de dados."
                              ],
                              "realWorldApplication": "Em varejo e e-commerce para otimizar preços dinâmicos, alocar orçamentos de marketing e gerenciar estoques sazonais, como na Amazon ou Magazine Luiza, reduzindo perdas por estoque excessivo em até 20%."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.3.3",
                        "name": "Séries Temporais Categóricas",
                        "description": "Séries temporais categóricas compreendem dados temporais onde os valores são categorias ou labels discretos, exigindo técnicas específicas de codificação para análise.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.3.1",
                            "name": "Classificar dados categóricos temporais",
                            "description": "Identificar séries categóricas em dados como dias da semana ou estados climáticos (sol/chuva), diferenciando de dados numéricos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Dados Categóricos Temporais",
                                  "subSteps": [
                                    "Defina dados categóricos como valores qualitativos não numéricos, como 'sol', 'chuva' ou 'segunda-feira'.",
                                    "Explique séries temporais como sequências de dados ordenados por tempo.",
                                    "Diferencie de dados numéricos (ex: temperatura 25°C) destacando que categóricos usam rótulos, não cálculos aritméticos.",
                                    "Identifique componentes temporais: o tempo (data/hora) é o índice, e o valor é categórico.",
                                    "Revise exemplos iniciais: dias da semana em um calendário de eventos."
                                  ],
                                  "verification": "Resuma em suas palavras a diferença entre dados categóricos e numéricos em um contexto temporal, com 2 exemplos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Quadro branco ou papel para anotações",
                                    "Vídeo introdutório sobre séries temporais (YouTube: 'Séries Temporais Básicas')"
                                  ],
                                  "tips": "Use analogias cotidianas, como prever o humor diário ('feliz/triste') em vez de medir peso.",
                                  "learningObjective": "Discernir dados categóricos temporais de outros tipos de dados.",
                                  "commonMistakes": [
                                    "Confundir categóricos ordenados (ex: baixa/média/alta) com numéricos",
                                    "Ignorar o aspecto temporal, tratando como dados isolados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Diferenciar Tipos de Dados em Conjuntos de Séries Temporais",
                                  "subSteps": [
                                    "Colete um conjunto de dados de exemplo: datas com valores mistos (ex: data, temperatura numérica, clima categórico).",
                                    "Classifique cada coluna: marque 'categórico temporal' se for qualitativo e indexado por tempo.",
                                    "Compare com numéricos: tente somar valores categóricos para ver impossibilidade (ex: sol + chuva?).",
                                    "Crie uma tabela simples separando colunas categóricas de numéricas.",
                                    "Discuta padrões: categóricos mostram frequências ou transições ao longo do tempo."
                                  ],
                                  "verification": "Crie uma tabela de 5 linhas de dados mistos e rotule corretamente cada tipo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets",
                                    "Dataset de exemplo: clima diário de uma semana"
                                  ],
                                  "tips": "Pergunte: 'Posso fazer média disso?' Se não, provavelmente é categórico.",
                                  "learningObjective": "Aplicar critérios de diferenciação em dados reais de séries temporais.",
                                  "commonMistakes": [
                                    "Classificar datas como numéricas sem considerar o contexto",
                                    "Omitir o índice temporal na análise"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Classificar Dados Categóricos Temporais em um Dataset Prático",
                                  "subSteps": [
                                    "Selecione um dataset temporal: ex. registros diários de tráfego (leve/moderado/pesado) por hora.",
                                    "Identifique a série categórica: confirme ordem temporal e valores qualitativos.",
                                    "Aplique rótulos: use códigos como 'CAT-TEMP' para séries categóricas temporais.",
                                    "Visualize: crie um gráfico de linha ou barras com categorias ao longo do tempo.",
                                    "Valide: verifique se mudanças categóricas fazem sentido temporalmente (ex: chuva após sol)."
                                  ],
                                  "verification": "Produza um relatório curto (3-5 frases) classificando 3 séries em um dataset fornecido.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Google Sheets ou Python (Pandas básico)",
                                    "Dataset gratuito: clima ou vendas semanais de Kaggle"
                                  ],
                                  "tips": "Comece com datasets pequenos (10-20 observações) para prática rápida.",
                                  "learningObjective": "Executar classificação precisa em conjuntos de dados temporais reais.",
                                  "commonMistakes": [
                                    "Confundir categóricos nominais com ordinais sem justificativa",
                                    "Desconsiderar lacunas temporais nos dados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Refinar Classificações com Análise de Padrões",
                                  "subSteps": [
                                    "Analise frequências: conte ocorrências de cada categoria (ex: % de dias chuvosos).",
                                    "Detecte padrões temporais: transições frequentes? Sazonalidade (ex: mais sol no verão)?",
                                    "Compare com numéricos: converta temporariamente e veja inconsistências.",
                                    "Refine classificações: ajuste se houver ambiguidades (ex: 'temperatura' como cat se em faixas).",
                                    "Documente justificativas para cada classificação."
                                  ],
                                  "verification": "Apresente uma análise de padrões em seu dataset classificado, com pelo menos 2 insights.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de visualização como Tableau Public (gratuito) ou Sheets",
                                    "Seu dataset do Step 3"
                                  ],
                                  "tips": "Use gráficos para 'ver' padrões categóricos, facilitando detecção visual.",
                                  "learningObjective": "Validar classificações através de análise exploratória.",
                                  "commonMistakes": [
                                    "Sobre-generalizar padrões sem dados suficientes",
                                    "Ignorar outliers categóricos como 'outro'"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um dataset de clima diário de uma cidade por 30 dias: colunas 'Data' (índice temporal), 'Temperatura' (numérica: 25°C), 'Condição' (categórica: sol/chuva/nublado). Classifique 'Condição' como categórica temporal, diferenciando de 'Temperatura' por impossibilidade de operações numéricas e foco em frequências/sequências.",
                              "finalVerifications": [
                                "Classifica corretamente 90% das séries em um dataset misto de 20 itens.",
                                "Explica diferenças entre categórico temporal e numérico com exemplos precisos.",
                                "Identifica padrões temporais em séries categóricas (ex: ciclos semanais).",
                                "Cria visualizações adequadas para dados categóricos temporais.",
                                "Documenta justificativas lógicas para cada classificação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na diferenciação: 40% (cat vs num correto).",
                                "Profundidade de análise: 25% (padrões e transições identificados).",
                                "Uso de ferramentas: 15% (visualizações e tabelas claras).",
                                "Justificativas: 10% (lógicas e baseadas em critérios).",
                                "Criatividade em exemplos: 10% (aplicações reais relevantes)."
                              ],
                              "crossCurricularConnections": [
                                "Geografia: Análise de padrões climáticos sazonais por região.",
                                "História: Classificação de eventos por dias da semana (ex: batalhas em segundas-feiras).",
                                "Economia: Vendas categóricas por dia da semana em varejo.",
                                "Biologia: Estados fenológicos de plantas (folhagem/flor/fruit) ao longo do tempo."
                              ],
                              "realWorldApplication": "Em meteorologia, classificar condições climáticas diárias (sol/chuva) para prever padrões de demanda por energia (ar-condicionado em dias quentes); em varejo, analisar tráfego de clientes por categoria de dia (fim de semana vs útil) para otimizar estoques."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.3.2",
                            "name": "Aplicar codificação categórica",
                            "description": "Converter séries categóricas em formatos numéricos utilizáveis, como one-hot encoding ou label encoding, para integração em modelos de séries temporais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e Explorar Dados Categóricos em Séries Temporais",
                                  "subSteps": [
                                    "Carregue o dataset de série temporal usando pandas.read_csv() ou similar.",
                                    "Identifique colunas categóricas verificando dtype 'object' ou 'category' com df.dtypes.",
                                    "Analise valores únicos e cardinalidade usando df[col].unique() e df[col].nunique().",
                                    "Visualize a distribuição temporal das categorias com plots de linha ou heatmap.",
                                    "Determine se as categorias são nominais (sem ordem) ou ordinais (com ordem natural)."
                                  ],
                                  "verification": "Relatório gerado listando colunas categóricas, cardinalidade e tipo (nominal/ordinal).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "Pandas",
                                    "Matplotlib ou Seaborn"
                                  ],
                                  "tips": "Use df.describe(include='object') para visão geral rápida das categóricas.",
                                  "learningObjective": "Reconhecer dados categóricos em séries temporais e avaliar sua natureza para escolha de encoding.",
                                  "commonMistakes": [
                                    "Ignorar a dimensão temporal na análise de distribuição.",
                                    "Confundir variáveis categóricas com numéricas discretas.",
                                    "Não checar missing values em categóricas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Label Encoding para Variáveis Ordinais",
                                  "subSteps": [
                                    "Importe LabelEncoder de sklearn.preprocessing.",
                                    "Crie uma instância: le = LabelEncoder().",
                                    "Ajuste e transforme: df['col_encoded'] = le.fit_transform(df['col_categ']).",
                                    "Substitua ou adicione a coluna codificada ao dataframe.",
                                    "Mapeie de volta com le.inverse_transform() para validar."
                                  ],
                                  "verification": "Coluna codificada contém inteiros sequenciais (0 a n-1) mapeando corretamente às categorias originais.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "scikit-learn",
                                    "Pandas"
                                  ],
                                  "tips": "Salve o encoder treinado (pickle) para uso em dados futuros e preserve ordem temporal.",
                                  "learningObjective": "Converter categorias ordinais em numéricos preservando ordem relativa.",
                                  "commonMistakes": [
                                    "Aplicar label encoding em variáveis nominais (assume ordem falsa).",
                                    "Não tratar dados de teste com o mesmo encoder.",
                                    "Perder o índice temporal durante transformação."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar One-Hot Encoding para Variáveis Nominais",
                                  "subSteps": [
                                    "Use pd.get_dummies(df['col_categ'], prefix='col') ou OneHotEncoder.",
                                    "Aplique drop_first=True para evitar multicolinearidade.",
                                    "Concatene as colunas dummy ao dataframe original com pd.concat().",
                                    "Remova a coluna categórica original.",
                                    "Verifique o novo shape e valores binários (0/1)."
                                  ],
                                  "verification": "Colunas binárias criadas (uma por categoria), coluna original removida, sem NaNs introduzidos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "Pandas",
                                    "scikit-learn (opcional)"
                                  ],
                                  "tips": "Para alta cardinalidade, considere target encoding ou embeddings em vez de one-hot puro.",
                                  "learningObjective": "Criar features independentes binárias para categorias sem ordem inerente.",
                                  "commonMistakes": [
                                    "Gerar muitas colunas com alta cardinalidade, causando curse of dimensionality.",
                                    "Não usar drop_first em regressões lineares.",
                                    "Desalinhar índices após concatenação."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Encoding em Modelos de Séries Temporais e Validar",
                                  "subSteps": [
                                    "Prepare o dataset com features codificadas e índice temporal.",
                                    "Split em train/test respeitando ordem temporal (sem shuffle).",
                                    "Treine um modelo como Prophet, ARIMAX ou LSTM com features novas.",
                                    "Compare métricas (MAE, RMSE) com baseline sem encoding.",
                                    "Visualize previsões e resíduos para checar captura de padrões categóricos."
                                  ],
                                  "verification": "Modelo executa sem erros, métricas mostram melhoria ou estabilidade com encoding aplicado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "Pandas",
                                    "Prophet ou statsmodels",
                                    "scikit-learn ou Keras"
                                  ],
                                  "tips": "Escalone features numéricas pós-encoding; evite leakage usando walk-forward validation.",
                                  "learningObjective": "Avaliar e validar o impacto do encoding na performance de modelagem temporal.",
                                  "commonMistakes": [
                                    "Shuffle de dados quebrando ordem temporal.",
                                    "Não normalizar features mistas (numéricas + codificadas).",
                                    "Sobreajuste devido a muitas dummies."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um dataset de vendas diárias de varejo (com coluna 'dia_semana': 'Seg', 'Ter', etc.), aplique one-hot encoding para capturar sazonalidade semanal, integre em um modelo Prophet para forecasting de vendas, e compare RMSE com baseline sem encoding.",
                              "finalVerifications": [
                                "Todas colunas categóricas identificadas e codificadas corretamente.",
                                "Dataset pós-encoding mantém shape esperado e ordem temporal.",
                                "Mapeamento reverso (decode) restaura categorias originais.",
                                "Modelo de série temporal treina e prevê sem erros com features codificadas.",
                                "Métricas de performance (ex: MAE) estáveis ou melhoradas.",
                                "Ausência de multicolinearidade detectada (VIF < 10)."
                              ],
                              "assessmentCriteria": [
                                "Escolha precisa de label vs. one-hot baseada em ordinalidade/nominalidade.",
                                "Implementação sem erros de índice, NaNs ou desalinhamento temporal.",
                                "Validação robusta com split temporal e métricas comparativas.",
                                "Interpretação correta do impacto das features codificadas.",
                                "Consideração de eficiência (cardinalidade, dimensionalidade).",
                                "Código reproduzível e comentado."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Manipulação avançada de dataframes e pré-processamento em Python.",
                                "Machine Learning: Feature engineering para modelos supervisionados.",
                                "Estatística: Modelos de regressão com variáveis dummy e multicolinearidade.",
                                "Ciência de Dados: Pipelines de ETL para séries temporais.",
                                "Matemática: Álgebra linear em encodings (vetores one-hot)."
                              ],
                              "realWorldApplication": "Em e-commerce, codificar categorias de produto para prever demanda sazonal; em IoT, codificar estados de sensores categóricos para detecção de anomalias em séries temporais de manutenção preditiva."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.3.3",
                            "name": "Analisar padrões categóricos",
                            "description": "Explorar transições e frequências em séries categóricas, como cadeias de Markov para prever sequências categóricas no tempo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Séries Categóricas e Calcular Frequências Básicas",
                                  "subSteps": [
                                    "Colete uma série temporal categórica, como estados diários de clima (sol, chuva, nublado).",
                                    "Identifique as categorias únicas presentes na série.",
                                    "Calcule a frequência absoluta e relativa de cada categoria.",
                                    "Visualize as frequências usando gráficos de barras ou pizza.",
                                    "Interprete as frequências para identificar padrões iniciais de ocorrência."
                                  ],
                                  "verification": "Verifique se as frequências somam 100% e se o gráfico reflete corretamente os dados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha (Excel/Google Sheets), conjunto de dados categórico de exemplo (ex: 100 dias de clima).",
                                  "tips": "Use funções como COUNTIF no Excel para agilizar cálculos.",
                                  "learningObjective": "Dominar o cálculo e interpretação de frequências em dados categóricos.",
                                  "commonMistakes": "Confundir frequência absoluta com relativa; ignorar categorias raras."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Quantificar Transições Entre Categorias",
                                  "subSteps": [
                                    "Liste as sequências consecutivas de categorias na série temporal.",
                                    "Conte o número de transições de cada categoria para outra (ex: sol para chuva).",
                                    "Construa uma matriz de transição contando ocorrências de pares consecutivos.",
                                    "Calcule probabilidades de transição normalizando as linhas da matriz.",
                                    "Visualize a matriz como mapa de calor para destacar transições comuns."
                                  ],
                                  "verification": "Confira se as probabilidades de cada linha somam 1.0.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Planilha ou Python (Pandas/Matplotlib), dados da Step 1.",
                                  "tips": "Ordene as categorias alfabeticamente para padronizar a matriz.",
                                  "learningObjective": "Construir e interpretar matrizes de transição para séries categóricas.",
                                  "commonMistakes": "Contar transições erradas (ex: incluir auto-transições incorretamente); não normalizar probabilidades."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modelar a Série como Cadeia de Markov de Ordem 1",
                                  "subSteps": [
                                    "Explique os pressupostos de uma cadeia de Markov (memória de um passo).",
                                    "Use a matriz de transição para definir o modelo probabilístico.",
                                    "Simule 10-20 passos futuros a partir de um estado inicial usando probabilidades.",
                                    "Calcule a distribuição estacionária resolvendo equações de equilíbrio.",
                                    "Compare simulações com dados reais para validar o modelo."
                                  ],
                                  "verification": "Simulações devem respeitar as probabilidades da matriz; distribuição estacionária soma 1.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python (NumPy/SciPy para simulações), ou calculadora matricial.",
                                  "tips": "Use np.random.choice() em Python para simulações eficientes.",
                                  "learningObjective": "Aplicar conceitos de cadeias de Markov para modelar dependências em séries categóricas.",
                                  "commonMistakes": "Assumir independência entre estados; erros em simulações aleatórias sem sementes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Prever Sequências Futuras e Avaliar o Modelo",
                                  "subSteps": [
                                    "Gere previsões para os próximos 5-10 passos a partir do último estado observado.",
                                    "Calcule métricas como probabilidade prevista vs. observada.",
                                    "Teste o modelo em uma série de hold-out (dados não usados no treinamento).",
                                    "Interprete resultados: identifique estados persistentes ou cíclicos.",
                                    "Documente limitações e sugestões para ordens superiores de Markov."
                                  ],
                                  "verification": "Previsões geradas coincidem com simulações probabilísticas; acurácia > 30% em hold-out.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Código Python da Step 3, conjunto de dados de validação.",
                                  "tips": "Divida dados em 80% treino / 20% teste para avaliação robusta.",
                                  "learningObjective": "Realizar previsões e validações em cadeias de Markov aplicadas a séries categóricas.",
                                  "commonMistakes": "Overfitting ao usar todos os dados para treinamento; ignorar incertezas probabilísticas."
                                }
                              ],
                              "practicalExample": "Analise uma série de 50 dias de tráfego em uma rua urbana (categorias: baixo, médio, alto). Calcule frequências (alto: 40%), construa matriz de transição (alto -> alto: 0.7), modele como Markov e preveja os próximos 5 dias a partir de 'alto', simulando: alto, alto, médio, alto, baixo.",
                              "finalVerifications": [
                                "Matriz de transição normalizada corretamente (linhas somam 1).",
                                "Simulações de 20 passos geradas e visualizadas.",
                                "Distribuição estacionária calculada e interpretada.",
                                "Previsões para 5 passos futuros consistentes com probabilidades.",
                                "Avaliação em hold-out com métrica de acurácia reportada.",
                                "Relatório resumindo padrões identificados (ex: persistência de estados)."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de frequências e transições (erro <5%).",
                                "Correta construção e interpretação da matriz de Markov.",
                                "Qualidade das simulações e previsões probabilísticas.",
                                "Validação adequada com dados de teste.",
                                "Clareza na visualização e interpretação de padrões.",
                                "Identificação de limitações do modelo de ordem 1."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: Cálculo de distribuições estacionárias.",
                                "Ciência da Computação: Simulações estocásticas e programação em Python.",
                                "Matemática Discreta: Matrizes de transição e autômatos estocásticos.",
                                "Economia: Modelagem de séries de regimes econômicos (expansão/recessão)."
                              ],
                              "realWorldApplication": "Previsão de padrões de uso de apps móveis (sessões ativas/inativas) para otimizar servidores; análise de sequências de falhas em equipamentos industriais para manutenção preditiva; modelagem de comportamento de clientes em e-commerce (compra/abandono) para estratégias de retenção."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.3.4",
                            "name": "Exemplificar usos categóricos",
                            "description": "Citar aplicações como análise de tráfego web por categorias de usuário ou previsão de eventos esportivos binários ao longo do tempo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de séries temporais categóricas",
                                  "subSteps": [
                                    "Defina série temporal categórica como sequências de dados onde cada observação é uma categoria discreta ao invés de numérica.",
                                    "Diferencie de séries numéricas, destacando que não há soma ou média direta, mas contagens ou proporções.",
                                    "Identifique características como sazonalidade em categorias (ex: dias da semana).",
                                    "Revise exemplos básicos como clima (sol/nublado/chuva) ou status de servidor (ativo/inativo).",
                                    "Anote as vantagens: modelagem de eventos qualitativos."
                                  ],
                                  "verification": "Escreva uma definição própria e liste 2 diferenças chave em um documento.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Notebook, acesso a artigos introdutórios sobre séries temporais (ex: Wikipedia ou Khan Academy).",
                                  "tips": "Use analogias cotidianas, como registrar humor diário (feliz/triste/neutro).",
                                  "learningObjective": "Dominar a definição e distinções fundamentais de séries temporais categóricas.",
                                  "commonMistakes": "Confundir com séries numéricas ou ignorar a natureza discreta das categorias."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar exemplos reais de aplicações categóricas",
                                  "subSteps": [
                                    "Pesquise tráfego web: categorias de usuário (desktop/mobile) por hora/dia.",
                                    "Explore previsão esportiva: binário win/loss ao longo de temporadas.",
                                    "Analise dados de e-commerce: tipo de produto comprado por data.",
                                    "Liste 5 exemplos de fontes públicas (Kaggle datasets de séries categóricas).",
                                    "Classifique cada exemplo por domínio (web, esportes, saúde)."
                                  ],
                                  "verification": "Compile uma tabela com 4 exemplos, incluindo fonte e categoria temporal.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Internet, Kaggle.com, Google Datasets Search.",
                                  "tips": "Busque 'categorical time series examples' para inspiração rápida.",
                                  "learningObjective": "Reconhecer e catalogar aplicações práticas de séries categóricas.",
                                  "commonMistakes": "Escolher exemplos numéricos disfarçados ou sem componente temporal clara."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar e descrever usos específicos em profundidade",
                                  "subSteps": [
                                    "Escolha um exemplo (ex: tráfego web) e descreva o processo de coleta de dados categóricos.",
                                    "Explique análises possíveis: proporções por categoria, transições (Markov chains).",
                                    "Discuta visualizações: gráficos de barras empilhadas ou heatmaps temporais.",
                                    "Avalie desafios: alta cardinalidade de categorias ou missing values.",
                                    "Compare com previsão: modelos como HMM para séries categóricas."
                                  ],
                                  "verification": "Redija um parágrafo analítico para cada um de 2 exemplos selecionados.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Ferramentas como Excel ou Python (Pandas para mock data), papel para esboços.",
                                  "tips": "Desenhe um gráfico simples à mão para visualizar o exemplo.",
                                  "learningObjective": "Analisar criticamente aplicações, identificando métodos e desafios.",
                                  "commonMistakes": "Focar só na descrição superficial sem análise ou visualização."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Criar e exemplificar usos categóricos originais",
                                  "subSteps": [
                                    "Invente um cenário novo (ex: categorias de humor em redes sociais por hora).",
                                    "Descreva coleta, análise e previsão possível para seu exemplo.",
                                    "Apresente em formato estruturado: introdução, dados simulados, insights.",
                                    "Valide com critérios: é temporal? Categórico? Útil?",
                                    "Compartilhe ou autoavalie o exemplo criado."
                                  ],
                                  "verification": "Produza um relatório curto (200 palavras) com seu exemplo original.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de texto, ferramentas de simulação como Google Sheets.",
                                  "tips": "Baseie em interesses pessoais para maior engajamento.",
                                  "learningObjective": "Aplicar o conhecimento para gerar exemplos personalizados e acionáveis.",
                                  "commonMistakes": "Criar exemplos vagos ou sem ligação temporal clara."
                                }
                              ],
                              "practicalExample": "Análise de tráfego web: Registrar diariamente o tipo de dispositivo de usuários (desktop: 40%, mobile: 50%, tablet: 10%) ao longo de uma semana, identificando picos de mobile à noite para otimizar anúncios.",
                              "finalVerifications": [
                                "Citar pelo menos 3 exemplos concretos de séries categóricas com contexto temporal.",
                                "Explicar uma análise básica (ex: proporções ou transições) para cada exemplo.",
                                "Identificar um desafio comum e solução em aplicações categóricas.",
                                "Criar um exemplo original viável e descritivo.",
                                "Visualizar um exemplo com gráfico simples (barras ou linha categórica)."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: Definição correta de séries categóricas (20%)",
                                "Diversidade de exemplos: Pelo menos 3 domínios diferentes (25%)",
                                "Profundidade analítica: Inclui métodos e desafios (25%)",
                                "Criatividade original: Exemplo novo e aplicável (20%)",
                                "Clareza de apresentação: Estruturado e visual (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Informática: Visualização de dados com Python (Matplotlib/Seaborn)",
                                "Matemática: Modelos probabilísticos (Markov para transições categóricas)",
                                "Negócios: Análise de marketing e segmentação de clientes",
                                "Esportes: Previsão de resultados e análise de desempenho"
                              ],
                              "realWorldApplication": "Em marketing digital para otimizar campanhas por comportamento de usuário temporal; em esportes para prever sequências de vitórias/derrotas e estratégias de treinamento; em saúde para monitorar categorias de sintomas ao longo de epidemias."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.4",
                    "name": "Formação de Bases de Dados",
                    "description": "Processos de importação, limpeza e transformações iniciais de dados para análise de séries temporais.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.4.1",
                        "name": "Tipos de Dados em Séries Temporais",
                        "description": "Compreensão dos diferentes tipos de dados utilizados na formação de bases para análise de séries temporais, incluindo univariados, multivariados, frequências temporais e estruturas de dados temporais.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.1.1",
                            "name": "Identificar séries univariadas e multivariadas",
                            "description": "Diferenciar séries temporais univariadas (uma variável ao longo do tempo) de multivariadas (múltiplas variáveis), com exemplos como temperatura única versus temperatura e umidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Séries Temporais Univariadas",
                                  "subSteps": [
                                    "Estude a definição: uma única variável observada sequencialmente ao longo do tempo.",
                                    "Analise características: foco em uma dimensão temporal, como valores em intervalos regulares.",
                                    "Examine exemplos: temperatura diária de uma cidade por 365 dias.",
                                    "Visualize graficamente: plote uma linha simples com o eixo x como tempo e y como a variável.",
                                    "Identifique aplicações iniciais: previsão simples de tendências."
                                  ],
                                  "verification": "Explique em suas palavras a definição e forneça um exemplo pessoal, desenhando um gráfico simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Vídeo introdutório sobre séries temporais (YouTube/Khan Academy)",
                                    "Papel e caneta ou ferramenta de plotagem como Excel/Google Sheets"
                                  ],
                                  "tips": "Sempre relacione o conceito ao tempo como eixo principal para fixar a ideia.",
                                  "learningObjective": "Definir precisamente séries univariadas e reconhecer suas características básicas.",
                                  "commonMistakes": [
                                    "Confundir com dados estáticos sem componente temporal.",
                                    "Ignorar a regularidade dos intervalos de tempo."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender Séries Temporais Multivariadas",
                                  "subSteps": [
                                    "Estude a definição: múltiplas variáveis observadas simultaneamente ao longo do tempo.",
                                    "Analise características: interdependências entre variáveis, maior complexidade dimensional.",
                                    "Examine exemplos: temperatura e umidade diárias da mesma cidade por 365 dias.",
                                    "Visualize graficamente: plote múltiplas linhas ou use gráficos de correlação.",
                                    "Identifique aplicações: modelagem de interações entre fatores."
                                  ],
                                  "verification": "Descreva uma série multivariada com pelo menos duas variáveis e explique por que ela é multivariada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Dataset de exemplo (temperatura e umidade em CSV)",
                                    "Ferramenta de visualização como Python (Matplotlib) ou Excel"
                                  ],
                                  "tips": "Pense em 'família de variáveis' evoluindo juntas no tempo.",
                                  "learningObjective": "Definir séries multivariadas e identificar suas dimensões adicionais.",
                                  "commonMistakes": [
                                    "Tratar como univariadas ao focar apenas em uma variável.",
                                    "Esquecer de verificar correlações entre variáveis."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar Univariadas de Multivariadas",
                                  "subSteps": [
                                    "Compare definições lado a lado: univariada (1 var) vs. multivariada (n vars).",
                                    "Liste diferenças chave: dimensionalidade, complexidade de modelagem, análise de correlações.",
                                    "Crie uma tabela comparativa com exemplos de cada tipo.",
                                    "Analise cenários mistos: quando adicionar uma variável transforma univariada em multivariada.",
                                    "Pratique identificação rápida: classifique 3 datasets fornecidos."
                                  ],
                                  "verification": "Preencha uma tabela comparativa corretamente e classifique corretamente 3 exemplos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela modelo em branco (Google Docs)",
                                    "3 datasets de exemplo (univariada: ações; multivariada: clima; mista: vendas e promoções)"
                                  ],
                                  "tips": "Conte o número de colunas de dados (excluindo tempo) para uma contagem rápida.",
                                  "learningObjective": "Distinguir com precisão os dois tipos baseando-se em critérios claros.",
                                  "commonMistakes": [
                                    "Classificar erroneamente por número de observações em vez de variáveis.",
                                    "Não considerar o tempo como variável implícita."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Identificação em Dados Reais",
                                  "subSteps": [
                                    "Carregue um dataset real (ex: clima ou finanças).",
                                    "Conte e liste as variáveis além do tempo.",
                                    "Classifique como univariada ou multivariada justificando.",
                                    "Gere visualizações para confirmar a classificação.",
                                    "Discuta implicações: escolha de modelo (ARIMA para uni vs. VAR para multi)."
                                  ],
                                  "verification": "Classifique corretamente 2 datasets reais e produza gráficos com legendas explicativas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Datasets públicos (Kaggle: daily temperatures; multivariate climate data)",
                                    "Python/R ou Excel para plotagem"
                                  ],
                                  "tips": "Use head() ou preview para inspecionar colunas rapidamente.",
                                  "learningObjective": "Aplicar conceitos para classificar séries reais autonomamente.",
                                  "commonMistakes": [
                                    "Interpretar metadados como variáveis principais.",
                                    "Ignorar missing values que afetam contagem."
                                  ]
                                }
                              ],
                              "practicalExample": "Baixe o dataset 'Air Quality' do UCI ML Repository. Identifique como multivariada (CO, NO2, O3, temperatura ao longo do tempo). Compare com subconjunto apenas de 'temperatura' como univariada, plotando ambos para visualizar a diferença.",
                              "finalVerifications": [
                                "Define univariada e multivariada sem erros.",
                                "Fornece exemplos precisos de cada tipo.",
                                "Classifica corretamente datasets mistos.",
                                "Explica diferenças em complexidade e modelagem.",
                                "Gera visualizações adequadas para ambos.",
                                "Discute quando usar cada tipo em cenários reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (definições e diferenças: 30%)",
                                "Qualidade de exemplos e classificações (25%)",
                                "Profundidade de visualizações e análises (20%)",
                                "Justificativas lógicas e completas (15%)",
                                "Aplicação prática em dados reais (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estatística descritiva e vetores multidimensionais",
                                "Ciência de Dados: Pré-processamento e feature engineering",
                                "Economia: Análise de séries financeiras (ex: PIB e inflação)",
                                "Ciências Ambientais: Monitoramento climático multivariado",
                                "Programação: Manipulação de DataFrames em Python/Pandas"
                              ],
                              "realWorldApplication": "Em meteorologia, séries univariadas preveem temperatura isolada, enquanto multivariadas integram temperatura, umidade e pressão para alertas de furacões precisos; em finanças, distingue ações isoladas de portfólios com múltiplos indicadores econômicos para hedging de riscos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.1.2",
                            "name": "Reconhecer frequências temporais",
                            "description": "Classificar dados por frequência (diária, semanal, mensal, anual) e entender implicações para análise, como agregação de dados de alta para baixa frequência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Frequências Temporais",
                                  "subSteps": [
                                    "Defina frequência temporal como a taxa na qual os dados são coletados ou observados ao longo do tempo.",
                                    "Liste os tipos principais: diária (ex: 24h), semanal (ex: 7 dias), mensal (ex: 30 dias), trimestral e anual.",
                                    "Explique a diferença entre alta frequência (muitos pontos de dados) e baixa frequência (poucos pontos).",
                                    "Discuta exemplos cotidianos, como medições horárias de temperatura vs. relatórios anuais de vendas.",
                                    "Crie um diagrama simples comparando as escalas de tempo."
                                  ],
                                  "verification": "Resuma em uma tabela os tipos de frequência com exemplos e diferenças entre alta/baixa frequência.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta ou software de diagramação como Draw.io",
                                    "Vídeo introdutório sobre séries temporais (ex: Khan Academy)"
                                  ],
                                  "tips": "Use analogias como 'diária é como checar o termômetro várias vezes ao dia vs. anual como balanço final do ano'.",
                                  "learningObjective": "Identificar e definir corretamente os tipos de frequências temporais e suas características.",
                                  "commonMistakes": [
                                    "Confundir frequência com período (frequência é quão often, período é o intervalo)",
                                    "Ignorar que frequências podem ser irregulares em alguns contextos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Frequências em Conjuntos de Dados de Exemplo",
                                  "subSteps": [
                                    "Obtenha um dataset de exemplo com timestamps (ex: vendas por dia ou temperatura horária).",
                                    "Examine os intervalos entre observações consecutivas.",
                                    "Calcule a frequência média contando pontos de dados por unidade de tempo.",
                                    "Classifique como diária, semanal, etc., baseado no padrão dominante.",
                                    "Registre discrepâncias, como feriados que quebram padrões."
                                  ],
                                  "verification": "Anote a frequência identificada para 3 datasets diferentes e justifique com cálculos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Datasets de amostra (ex: CSV de vendas diárias do Kaggle)",
                                    "Planilha Excel ou Google Sheets"
                                  ],
                                  "tips": "Conte os pontos de dados em um mês para confirmar se é diário (cerca de 30 pontos).",
                                  "learningObjective": "Aplicar métodos para detectar frequência em dados reais.",
                                  "commonMistakes": [
                                    "Assumir frequência sem verificar intervalos irregulares",
                                    "Confundir granularidade com frequência"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Classificar Dados por Frequência e Agregá-los",
                                  "subSteps": [
                                    "Agrupe dados de alta frequência (diária) para baixa (mensal) usando funções de agregação como média ou soma.",
                                    "Pratique resample em ferramentas como Excel (pivot) ou Python (pandas resample).",
                                    "Compare o dataset original com o agregado para visualizar perda de granularidade.",
                                    "Classifique um dataset misto (diário + semanal) em categorias puras.",
                                    "Crie um relatório resumindo as classificações."
                                  ],
                                  "verification": "Produza um dataset agregado de diário para mensal e liste as mudanças observadas.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Excel ou Python com pandas",
                                    "Dataset misto de séries temporais"
                                  ],
                                  "tips": "Sempre verifique o índice temporal antes de agregar para evitar erros de alinhamento.",
                                  "learningObjective": "Executar classificação e agregação de dados temporais com precisão.",
                                  "commonMistakes": [
                                    "Perder dados em agregações sem alinhamento correto",
                                    "Usar soma em vez de média para variáveis como temperatura"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Implicações das Frequências para Análise de Séries Temporais",
                                  "subSteps": [
                                    "Discuta como alta frequência captura sazonalidade fina, mas gera ruído.",
                                    "Explique implicações para modelagem: baixa frequência para tendências longas.",
                                    "Simule análise em frequências diferentes e compare resultados (ex: previsão).",
                                    "Identifique cenários onde mudar frequência altera insights (ex: picos diários vs. mensais).",
                                    "Reflita sobre escolhas éticas em agregação de dados sensíveis."
                                  ],
                                  "verification": "Escreva um parágrafo explicando prós/contras de usar diária vs. anual para análise de vendas.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Gráficos de séries temporais em ferramentas como Tableau ou Matplotlib",
                                    "Artigos sobre pitfalls em séries temporais"
                                  ],
                                  "tips": "Visualize sempre: gráficos revelam frequências ocultas melhor que tabelas.",
                                  "learningObjective": "Entender impactos analíticos das escolhas de frequência.",
                                  "commonMistakes": [
                                    "Ignorar perda de informação na agregação",
                                    "Aplicar modelos de baixa frequência a dados de alta sem resample"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um dataset de vendas diárias de uma loja online (ex: 365 pontos de dados para um ano), classifique como diária, agregue para mensal usando soma de vendas, e analise como picos semanais (fim de semana) desaparecem na visão mensal, impactando previsões de estoque.",
                              "finalVerifications": [
                                "Classificar corretamente 5 datasets de frequências variadas.",
                                "Agregá-los sem erros de perda de dados.",
                                "Explicar implicações para análise em pelo menos 3 cenários.",
                                "Identificar erros comuns em exemplos dados.",
                                "Produzir um gráfico comparativo de frequências.",
                                "Discutir trade-offs em um relatório curto."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de frequências (90%+ acerto).",
                                "Correção técnica na agregação e resample.",
                                "Profundidade na análise de implicações (cobertura de prós/contras).",
                                "Criatividade e relevância nos exemplos práticos.",
                                "Clareza na documentação e visualizações.",
                                "Aplicação correta de ferramentas e conceitos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estatística descritiva e funções de agregação.",
                                "Economia: Análise de indicadores macroeconômicos (PIB anual vs. trimestral).",
                                "Ciências Ambientais: Séries climáticas (temperatura diária vs. anual).",
                                "Programação: Manipulação de dados em Python/R.",
                                "Gestão: Planejamento de negócios baseado em séries temporais."
                              ],
                              "realWorldApplication": "Em finanças, bancos reconhecem frequência diária em transações para detectar fraudes em tempo real, agregando para relatórios mensais de conformidade regulatória; em meteorologia, dados horários de estações são agregados anualmente para modelos climáticos globais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.1.3",
                            "name": "Estruturar dados em formato temporal",
                            "description": "Converter dados em formato longo ou largo para formato adequado a séries temporais, preparando para indexação temporal em ferramentas como Pandas ou R.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e analisar o formato atual dos dados",
                                  "subSteps": [
                                    "Carregue o dataset usando Pandas (pd.read_csv()) ou R (read.csv()).",
                                    "Inspecione a estrutura com .info(), .head(), ou str() para identificar se está em formato largo (múltiplas colunas de tempo) ou longo (colunas separadas para data e valor).",
                                    "Verifique tipos de dados das colunas temporais (ex: strings como '2023-01' vs datetime).",
                                    "Conte o número de observações e verifique valores ausentes com .isnull().sum().",
                                    "Documente o formato atual em um relatório simples."
                                  ],
                                  "verification": "Execute .shape, .dtypes e .head(10) para confirmar identificação correta do formato largo/longo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Pandas ou tidyverse (R)",
                                    "Jupyter Notebook ou RStudio",
                                    "Dataset de exemplo (ex: vendas mensais em CSV)"
                                  ],
                                  "tips": "Sempre visualize os primeiros 10-20 registros para padrões ocultos.",
                                  "learningObjective": "Compreender diferenças entre formatos longo e largo para séries temporais.",
                                  "commonMistakes": [
                                    "Assumir formato sem inspecionar",
                                    "Ignorar valores ausentes iniciais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Converter dados de formato largo para longo",
                                  "subSteps": [
                                    "Se largo, use pd.melt() em Pandas (id_vars para variáveis fixas, value_vars para colunas temporais) ou pivot_longer() em R.",
                                    "Renomeie colunas resultantes para 'data' e 'valor'.",
                                    "Combine colunas de data se necessário (ex: ano + mês em uma única coluna datetime).",
                                    "Remova linhas duplicadas com .drop_duplicates().",
                                    "Ordene por data com .sort_values('data')."
                                  ],
                                  "verification": "Confirme com .head() que agora há apenas colunas: entidade, data, valor; sem perda de dados (.shape original vs novo).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Pandas (pd.melt) ou dplyr (pivot_longer)",
                                    "Dataset largo de exemplo"
                                  ],
                                  "tips": "Use var_name='data' em melt para nomear corretamente a coluna temporal.",
                                  "learningObjective": "Dominar transformação de formatos para tidy data adequado a séries temporais.",
                                  "commonMistakes": [
                                    "Esquecer id_vars levando a perda de contexto",
                                    "Não renomear colunas gerando confusão"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Processar e formatar a coluna temporal como datetime",
                                  "subSteps": [
                                    "Converta strings de data para datetime com pd.to_datetime() ou as.Date() em R, especificando formato (ex: '%Y-%m').",
                                    "Trate valores inválidos com errors='coerce' e preencha NaT adequadamente.",
                                    "Defina a coluna datetime como índice com .set_index('data').",
                                    "Resample se necessário para frequência regular (ex: .resample('M').mean()).",
                                    "Verifique sequência temporal com .index.is_monotonic_increasing."
                                  ],
                                  "verification": "Execute df.index.dtype == 'datetime64[ns]' e df.index.freq para confirmar indexação temporal válida.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Funções pd.to_datetime/as.POSIXct",
                                    "Documentação Pandas/R dates"
                                  ],
                                  "tips": "Teste formatos comuns como '%Y-%m-%d' primeiro para eficiência.",
                                  "learningObjective": "Preparar dados para indexação temporal em análises de séries.",
                                  "commonMistakes": [
                                    "Ignorar timezone levando a erros",
                                    "Não tratar NaT resultando em falhas downstream"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e finalizar a estrutura temporal",
                                  "subSteps": [
                                    "Visualize a série com .plot() para detectar gaps ou anomalias.",
                                    "Preencha missing values com .interpolate() ou métodos adequados.",
                                    "Salve o dataset estruturado como CSV ou RDS com índice.",
                                    "Crie um resumo estatístico (ex: .describe() por período).",
                                    "Teste compatibilidade plotando ACF ou decompondo a série."
                                  ],
                                  "verification": "O plot mostra série contínua sem gaps; .info() confirma 3 colunas essenciais: index datetime, variável, valor.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Matplotlib/ggplot2 para plots",
                                    "Dataset processado"
                                  ],
                                  "tips": "Use .asfreq() para forçar frequência e identificar misses.",
                                  "learningObjective": "Garantir dados prontos para modelagem de séries temporais.",
                                  "commonMistakes": [
                                    "Não validar monotonicidade",
                                    "Preencher misses sem justificativa estatística"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado um CSV com colunas: 'Produto', '2023-01', '2023-02', ..., '2023-12' (formato largo de vendas), converta para duas colunas: 'data' (datetime) e 'vendas' (valor), com índice temporal mensal pronto para análise em Pandas.",
                              "finalVerifications": [
                                "Dataset em formato longo com colunas: variável, data (datetime), valor.",
                                "Índice é datetime64 monotonicamente crescente.",
                                "Sem perda de dados (número de observações preservado).",
                                "Frequência temporal definida (ex: 'M' para mensal).",
                                "Visualização inicial sem gaps óbvios.",
                                "Compatível com ts.plot() ou similar sem erros."
                              ],
                              "assessmentCriteria": [
                                "Identificação precisa do formato inicial (largo/longo).",
                                "Conversão sem erros ou perda de dados (>95% preservação).",
                                "Coluna temporal corretamente parseada como datetime.",
                                "Índice setado e validado monotonicamente.",
                                "Tratamento adequado de misses/gaps.",
                                "Código reproduzível e comentado."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Manipulação de dataframes em Python/R.",
                                "Estatística: Preparação para modelos como ARIMA.",
                                "Banco de dados: Normalização e ETL processes.",
                                "Visualização: Gráficos de séries temporais.",
                                "Gestão de projetos: Pipelines de dados automatizados."
                              ],
                              "realWorldApplication": "Em finanças, estruturar histórico de preços de ações para forecasting com Prophet; em varejo, preparar dados de vendas sazonais para otimização de estoque; em saúde pública, formatar casos diários de doenças para detecção de epidemias."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.4.2",
                        "name": "Importação de Dados",
                        "description": "Processos para importar dados de fontes variadas, garantindo que a estrutura temporal seja preservada para análise de séries temporais.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.2.1",
                            "name": "Importar dados de arquivos CSV e Excel",
                            "description": "Usar bibliotecas como Pandas (Python) ou read.csv/readxl (R) para carregar dados temporais de CSV e Excel, especificando colunas de data e índice temporal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e instalar bibliotecas",
                                  "subSteps": [
                                    "Instale Pandas via pip: `pip install pandas openpyxl` (openpyxl para Excel).",
                                    "Para R: instale readr e readxl via `install.packages(c('readr', 'readxl'))`.",
                                    "Abra um Jupyter Notebook ou script Python/R.",
                                    "Importe as bibliotecas: `import pandas as pd` em Python ou `library(readr); library(readxl)` em R.",
                                    "Verifique a versão: `pd.__version__` ou `packageVersion('readr')`."
                                  ],
                                  "verification": "Execute os imports sem erros de módulo não encontrado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python 3.8+ ou R 4.0+",
                                    "pip ou RStudio",
                                    "Jupyter Notebook (opcional)"
                                  ],
                                  "tips": "Use um ambiente virtual (venv) para evitar conflitos de pacotes.",
                                  "learningObjective": "Configurar um ambiente funcional para importação de dados tabulares.",
                                  "commonMistakes": [
                                    "Esquecer de instalar openpyxl para suporte a Excel.",
                                    "Usar versões antigas do Pandas sem suporte a parse_dates."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Importar dados de arquivos CSV",
                                  "subSteps": [
                                    "Localize o arquivo CSV (ex: 'dados_temporais.csv').",
                                    "Carregue com Pandas: `df = pd.read_csv('arquivo.csv', parse_dates=['data_coluna'], index_col='data_coluna')`.",
                                    "Em R: `df <- read_csv('arquivo.csv', col_types = cols(data_coluna = col_date('YYYY-MM-DD')))` e `df$data_coluna <- as.Date(df$data_coluna)`.",
                                    "Inspecione: `df.head()` e `df.info()`.",
                                    "Defina índice temporal: `df.index = pd.to_datetime(df.index)`."
                                  ],
                                  "verification": "DataFrame carregado com shape correto e datas como datetime64 sem NaTs.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Arquivo CSV de exemplo com coluna de data (formato YYYY-MM-DD)"
                                  ],
                                  "tips": "Use `parse_dates` para inferir formatos automaticamente; especifique `date_format` se necessário.",
                                  "learningObjective": "Carregar e preparar dados CSV com índice temporal para séries temporais.",
                                  "commonMistakes": [
                                    "Ignorar separadores não padrão (use `sep=','`).",
                                    "Não especificar tipos de coluna, levando a parsing incorreto de datas."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Importar dados de arquivos Excel",
                                  "subSteps": [
                                    "Localize o arquivo Excel (ex: 'dados_temporais.xlsx', aba 'Sheet1').",
                                    "Carregue com Pandas: `df = pd.read_excel('arquivo.xlsx', sheet_name='Sheet1', parse_dates=['data_coluna'], index_col='data_coluna')`.",
                                    "Em R: `df <- read_excel('arquivo.xlsx', sheet='Sheet1')`; converta datas com `df$data_coluna <- as.Date(df$data_coluna)`.",
                                    "Selecione colunas específicas: `usecols=['data_coluna', 'valor']`.",
                                    "Verifique: `df.dtypes` para confirmar datetime no índice."
                                  ],
                                  "verification": "DataFrame de Excel com dados corretos e índice temporal sem erros de parsing.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Arquivo Excel .xlsx com dados temporais"
                                  ],
                                  "tips": "Evite arquivos .xls antigos; converta para .xlsx para melhor suporte.",
                                  "learningObjective": "Importar planilhas Excel configurando colunas de data como índice temporal.",
                                  "commonMistakes": [
                                    "Não especificar `sheet_name`, carregando aba errada.",
                                    "Datas em formato texto não convertidas automaticamente."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e finalizar preparação para séries temporais",
                                  "subSteps": [
                                    "Cheque valores ausentes: `df.isnull().sum()`.",
                                    "Confirme frequência: `df.index.freq` ou `df.asfreq('M')` para mensal.",
                                    "Plote preview: `df.plot()`.",
                                    "Salve DataFrame preparado: `df.to_csv('dados_prontos.csv')`.",
                                    "Teste slicing temporal: `df['2023-01':'2023-06']`."
                                  ],
                                  "verification": "Gráficos mostram série temporal contínua sem gaps inesperados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "DataFrames carregados dos steps anteriores"
                                  ],
                                  "tips": "Use `pd.infer_freq(df.index)` para detectar frequência automática.",
                                  "learningObjective": "Validar dados importados prontos para análise de séries temporais.",
                                  "commonMistakes": [
                                    "Índice não ordenado: use `df.sort_index()`.",
                                    "Ignorar fusos horários em dados globais."
                                  ]
                                }
                              ],
                              "practicalExample": "Carregue 'vendas_mensais.csv' (colunas: Data (YYYY-MM), Vendas) e 'vendas_mensais.xlsx' (mesmo formato). Defina 'Data' como índice, plote Vendas vs tempo para visualizar tendência de vendas de 2020-2023.",
                              "finalVerifications": [
                                "Ambos CSV e Excel carregados como DataFrames com índice datetime.",
                                "Colunas de data parseadas corretamente (sem strings ou NaT).",
                                "Sem erros de importação ou warnings de parsing.",
                                "Índice temporal ordenado e com frequência detectável.",
                                "Preview `df.head(10)` mostra dados coerentes para séries temporais.",
                                "Slicing temporal funciona: `df.loc['2023']` retorna subconjunto válido."
                              ],
                              "assessmentCriteria": [
                                "Código executa sem erros em <2 min por arquivo.",
                                "Parse de datas 100% preciso (testado com `pd.to_datetime`).",
                                "Eficiência: usa parâmetros como parse_dates/usecols.",
                                "Verificações manuais implementadas (isnull, dtypes).",
                                "Compatibilidade Python/R demonstrada.",
                                "Preparação completa para análise temporal (freq setada)."
                              ],
                              "crossCurricularConnections": [
                                "Programação em Python/R (lógica e sintaxe).",
                                "Estatística Descritiva (inspeção inicial de dados).",
                                "Gestão de Dados (limpeza e padronização).",
                                "Visualização de Dados (plotagem de séries)."
                              ],
                              "realWorldApplication": "Em análise financeira, importar históricos de transações de relatórios Excel/CSV de ERPs como SAP para modelar séries temporais de receitas e prever demandas futuras."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.2.2",
                            "name": "Importar de bancos de dados",
                            "description": "Conectar e extrair dados temporais de SQL ou APIs (ex: Quandl, Yahoo Finance), convertendo para DataFrame ou ts object com timestamp correto.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de desenvolvimento",
                                  "subSteps": [
                                    "Instale as bibliotecas necessárias via pip: pandas, sqlalchemy, yfinance, quandl.",
                                    "Importe as bibliotecas no script Python: import pandas as pd; from sqlalchemy import create_engine; import yfinance as yf; import quandl.",
                                    "Prepare credenciais para APIs (chave API para Quandl) e string de conexão SQL (ex: 'postgresql://user:pass@localhost/dbname').",
                                    "Crie um diretório de projeto e um notebook Jupyter para testes.",
                                    "Teste as importações executando um script simples de verificação."
                                  ],
                                  "verification": "Todas as bibliotecas importam sem erros e credenciais são salvas com segurança (não hardcoded).",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Python 3.8+, pip, Jupyter Notebook, chaves API (Quandl/Yahoo), acesso a banco SQL de teste"
                                  ],
                                  "tips": "Use virtualenv para isolar dependências; armazene credenciais em variáveis de ambiente ou .env file.",
                                  "learningObjective": "Configurar um ambiente Python pronto para manipulação de dados temporais de fontes externas.",
                                  "commonMistakes": [
                                    "Esquecer de instalar bibliotecas opcionais como psycopg2 para PostgreSQL",
                                    "Hardcodar senhas em scripts",
                                    "Usar versões incompatíveis de bibliotecas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Conectar e extrair dados de banco SQL",
                                  "subSteps": [
                                    "Crie o engine de conexão com create_engine('dialect://user:pass@host/db').",
                                    "Escreva uma query SQL para selecionar dados temporais: SELECT timestamp_col, value_col FROM table WHERE timestamp_col >= '2020-01-01'.",
                                    "Execute pd.read_sql(query, engine) para carregar diretamente em DataFrame.",
                                    "Feche a conexão com engine.dispose() após uso.",
                                    "Inspecione os dados iniciais com df.head() e df.info()."
                                  ],
                                  "verification": "DataFrame carregado tem colunas de timestamp e valores, sem erros de conexão.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Banco SQL de teste com tabela de séries temporais (ex: PostgreSQL com dados de vendas diárias)",
                                    "Documentação SQLAlchemy"
                                  ],
                                  "tips": "Use pd.to_datetime() imediatamente se timestamps não forem reconhecidos; otimize queries com LIMIT para testes.",
                                  "learningObjective": "Estabelecer conexão segura com SQL e extrair dados temporais para análise.",
                                  "commonMistakes": [
                                    "Query SQL malformada causando erros de sintaxe",
                                    "Ignorar fusos horários na coluna timestamp",
                                    "Não fechar conexões levando a leaks"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Conectar e extrair dados de APIs (ex: Yahoo Finance ou Quandl)",
                                  "subSteps": [
                                    "Autentique na API: quandl.ApiConfig.api_key = 'sua_chave' ou use yf diretamente.",
                                    "Para Yahoo Finance: ticker = yf.Ticker('AAPL'); df = ticker.history(start='2020-01-01', end='2023-01-01').",
                                    "Para Quandl: df = quandl.get('WIKI/AAPL', start_date='2020-01-01', end_date='2023-01-01').",
                                    "Salve os dados em variável e verifique shape e colunas.",
                                    "Trate erros de API com try-except blocks."
                                  ],
                                  "verification": "DataFrame obtido tem índice ou coluna de data com timestamps corretos e dados relevantes.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Conta gratuita em Yahoo Finance/Quandl",
                                    "Documentação yfinance e Quandl Python client"
                                  ],
                                  "tips": "Use period='1y' para dados recentes em yfinance; verifique rate limits das APIs.",
                                  "learningObjective": "Acessar dados temporais públicos via APIs financeiras de forma eficiente.",
                                  "commonMistakes": [
                                    "Chave API inválida ou expirada",
                                    "Ignorar intervalos de data causando dados vazios",
                                    "Não tratar NaNs iniciais em séries"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Converter e validar dados para DataFrame ou ts object",
                                  "subSteps": [
                                    "Converta coluna/index para datetime: df['timestamp'] = pd.to_datetime(df['timestamp']); df.set_index('timestamp', inplace=True).",
                                    "Para ts object: ts = df['value'].asfreq('D') ou use pd.Series com index datetime.",
                                    "Resample se necessário: df.resample('D').mean().fillna(method='ffill').",
                                    "Valide: print(df.index.dtype == 'datetime64[ns]'); df.plot() para visualização.",
                                    "Salve em CSV: df.to_csv('dados_temporais.csv')."
                                  ],
                                  "verification": "Índice é datetime64, sem duplicatas ou gaps inesperados, plot visualmente coerente.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "Pandas documentation on time series",
                                    "Matplotlib para plots"
                                  ],
                                  "tips": "Especifique format='%Y-%m-%d' em to_datetime se parsing falhar; use tz_localize para fusos.",
                                  "learningObjective": "Padronizar dados temporais em formatos prontos para análise de séries temporais.",
                                  "commonMistakes": [
                                    "Timestamps não parseados ficando como object",
                                    "Frequência irregular não tratada",
                                    "Perda de dados em resample sem fillna"
                                  ]
                                }
                              ],
                              "practicalExample": "Baixe dados históricos de preços de ações da AAPL da Yahoo Finance usando yfinance: df = yf.download('AAPL', start='2020-01-01', end='2023-01-01'). Converta o índice para datetime e resample para diário, criando um DataFrame pronto para análise de tendências de preços.",
                              "finalVerifications": [
                                "DataFrame ou ts object possui índice datetime64[ns] válido.",
                                "Dados extraídos cobrem o período especificado sem gaps excessivos.",
                                "Código executa end-to-end sem erros de conexão ou parsing.",
                                "Visualização plot(df['Close']) mostra série temporal coerente.",
                                "Arquivo CSV salvo mantém timestamps corretos ao recarregar.",
                                "Tratamento de NaNs e duplicatas aplicado adequadamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na extração: dados correspondem à fonte original.",
                                "Eficiência: queries/APIs otimizadas, tempos de execução < 1min.",
                                "Robustez: código lida com erros comuns (ex: API down, dados faltantes).",
                                "Conformidade temporal: timestamps corretos, ordenados e indexados.",
                                "Documentação: comentários no código explicam passos chave.",
                                "Escalabilidade: funciona para múltiplos tickers ou tabelas."
                              ],
                              "crossCurricularConnections": [
                                "Programação em Python: manipulação de bibliotecas e exceções.",
                                "Banco de Dados: SQL queries e conexões ORM.",
                                "Finanças Quantitativas: dados de mercado para modelagem.",
                                "Estatística: preparação de dados para séries temporais.",
                                "Gestão de Projetos: versionamento de código e ambientes virtuais."
                              ],
                              "realWorldApplication": "Analistas financeiros importam dados de séries temporais de APIs como Yahoo Finance para construir modelos de previsão de preços de ações, ou extraem vendas diárias de bancos SQL para detectar sazonalidades em relatórios de negócios."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.2.3",
                            "name": "Lidar com formatos de data variados",
                            "description": "Parsear strings de data em diferentes formatos (DD/MM/YYYY, ISO) usando pd.to_datetime ou as.Date, garantindo continuidade temporal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e Catalogar Formatos de Data Variados",
                                  "subSteps": [
                                    "Examine o dataset para detectar strings de data em formatos como DD/MM/YYYY, YYYY-MM-DD (ISO), MM-DD-YYYY.",
                                    "Use funções exploratórias como unique() em pandas ou table() em R para listar valores únicos na coluna de datas.",
                                    "Registre padrões comuns e inconsistências, como separadores (/, -, espaço) ou abreviações de mês.",
                                    "Crie um mapeamento manual de formatos identificados para uso posterior.",
                                    "Documente ambiguidades potenciais, como 01/02/2023 (dia/mês ou mês/dia?)."
                                  ],
                                  "verification": "Lista completa de formatos únicos gerada e documentada sem erros de identificação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Dataset de exemplo com datas mistas (CSV)",
                                    "Jupyter Notebook ou RStudio"
                                  ],
                                  "tips": "Sempre visualize as primeiras linhas com head() ou .head() para um overview rápido.",
                                  "learningObjective": "Capacitar o aluno a detectar variações de formatos de data de forma sistemática.",
                                  "commonMistakes": [
                                    "Ignorar formatos minoritários",
                                    "Confundir ambiguidades sem documentação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Parsear Datas em Python com pd.to_datetime",
                                  "subSteps": [
                                    "Importe pandas e carregue o dataset com pd.read_csv().",
                                    "Aplique pd.to_datetime() com infer_datetime_format=True para detecção automática.",
                                    "Para formatos específicos, use format='%d/%m/%Y' ou múltiplos com dict de parsers.",
                                    "Trate erros com errors='coerce' para converter inválidos em NaT.",
                                    "Converta para datetime64[ns] e verifique com .dtype."
                                  ],
                                  "verification": "Coluna de datas convertida para dtype datetime64 sem perda de dados válidos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Pandas library",
                                    "Dataset de teste com datas DD/MM/YYYY e ISO"
                                  ],
                                  "tips": "Teste com pd.to_datetime(df['data'], dayfirst=True) para priorizar DD/MM.",
                                  "learningObjective": "Dominar pd.to_datetime para lidar com múltiplos formatos de forma robusta.",
                                  "commonMistakes": [
                                    "Esquecer errors='coerce'",
                                    "Não especificar dayfirst para formatos europeus"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Parsear Datas em R com as.Date e Lubridate",
                                  "subSteps": [
                                    "Carregue dados com read.csv() ou readr::read_csv().",
                                    "Use as.Date() com format='%d/%m/%Y' para formatos específicos.",
                                    "Aplique lubridate::dmy(), ymd() ou parse_date_time() para inferência automática.",
                                    "Lide com múltiplos formatos usando uma função custom com tryCatch().",
                                    "Valide com str() ou class() para confirmar POSIXct ou Date."
                                  ],
                                  "verification": "Todas as datas convertidas para classe Date ou POSIXct sem NAs inesperados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "R base + lubridate package",
                                    "Dataset equivalente em CSV"
                                  ],
                                  "tips": "Instale lubridate para funções intuitivas como dmy('01/02/2023').",
                                  "learningObjective": "Aplicar ferramentas R para parsing flexível de datas variadas.",
                                  "commonMistakes": [
                                    "Usar as.Date sem format para dados ambíguos",
                                    "Ignorar timezone em POSIXct"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar Continuidade Temporal e Integrar à Série",
                                  "subSteps": [
                                    "Ordene a coluna de datas com sort_values() ou order() e verifique gaps com diff().",
                                    "Preencha ou interpolate NaTs/NAs usando fillna(method='ffill') ou approx().",
                                    "Defina como índice temporal com .set_index('data') ou xts::xts().",
                                    "Plote a série com plot() ou ggplot para visualizar continuidade.",
                                    "Teste frequência com pd.infer_freq() ou tsp() em R."
                                  ],
                                  "verification": "Série temporal ordenada, sem gaps significativos, e índice datetime estabelecido.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Matplotlib/ggplot2 para plots",
                                    "Código dos steps anteriores"
                                  ],
                                  "tips": "Use resample() em pandas para agregação e detecção de frequência.",
                                  "learningObjective": "Garantir que datas parseadas formem uma série temporal contínua e utilizável.",
                                  "commonMistakes": [
                                    "Não ordenar após parsing",
                                    "Ignorar NaTs que quebram a continuidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um dataset de vendas diárias (vendas.csv) com datas como '15/03/2023', '2023-03-16' e '03-16-2023', aplique pd.to_datetime(df['data'], infer_datetime_format=True, dayfirst=True) em Python ou dmy_hms em lubridate no R. Resultado: coluna 'data' como datetime, ordenada, pronta para análise de série temporal de vendas.",
                              "finalVerifications": [
                                "Todas as strings de data foram parseadas corretamente sem NaT/NA extras.",
                                "Coluna de datas possui dtype datetime/Date e está ordenada cronologicamente.",
                                "Não há gaps temporais não explicados; continuidade verificada via diff().",
                                "Índice temporal setado e infer_freq() retorna frequência válida.",
                                "Plot da série mostra progressão temporal suave.",
                                "Testes com subconjuntos de formatos variados funcionam independentemente."
                              ],
                              "assessmentCriteria": [
                                "Precisão: 100% de conversão correta de formatos identificados.",
                                "Robustez: Lida com 20% de dados inválidos sem crash.",
                                "Eficiência: Tempo de parsing < 1s para 10k linhas.",
                                "Documentação: Mapeamento de formatos e erros comuns anotados.",
                                "Integração: Série pronta para modelagem temporal (ARIMA, etc.).",
                                "Flexibilidade: Código funciona em Python e R."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Manipulação de strings e regex para parsing avançado.",
                                "Estatística: Preparação de dados para modelagem de séries temporais.",
                                "Banco de Dados: Importação ETL com SQL DATE parsing.",
                                "Visualização: Timelines em Tableau/PowerBI pós-parsing.",
                                "Ciência de Dados: Feature engineering de lags/rolling windows."
                              ],
                              "realWorldApplication": "Em análise financeira, parsear datas variadas de relatórios de ações (Yahoo Finance CSV) para criar séries temporais contínuas, detectando tendências diárias e evitando erros em backtesting de estratégias de trading."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.4.3",
                        "name": "Limpeza de Dados",
                        "description": "Técnicas para identificar e corrigir problemas nos dados, como valores ausentes, duplicatas e outliers, preparando a base para modelagem de séries temporais.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.3.1",
                            "name": "Detectar e tratar valores ausentes",
                            "description": "Identificar NaNs ou missings com isna() ou is.na(), e aplicar métodos como forward-fill, interpolation ou remoção, preservando a sequência temporal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Carregar dados e detectar valores ausentes",
                                  "subSteps": [
                                    "Importe as bibliotecas necessárias: pandas e numpy.",
                                    "Carregue o dataset de série temporal usando pd.read_csv() ou similar.",
                                    "Use df.isna().sum() ou df.isnull().sum() para contar NaNs por coluna.",
                                    "Calcule a porcentagem de missings: (df.isna().sum() / len(df)) * 100.",
                                    "Identifique linhas com missings usando df[df.isna().any(axis=1)]."
                                  ],
                                  "verification": "Execute df.isna().sum() e confirme que há valores ausentes listados com contagens e porcentagens.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": "Python com Pandas e NumPy instalados; dataset de exemplo (ex: temperaturas diárias com missings).",
                                  "tips": "Sempre verifique o tipo de dados com df.dtypes() para garantir que missings sejam NaN.",
                                  "learningObjective": "Identificar e quantificar valores ausentes em um dataset de série temporal.",
                                  "commonMistakes": "Confundir valores zero ou strings vazias com NaNs; não considerar o índice temporal."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar padrões e visualização de missings",
                                  "subSteps": [
                                    "Crie uma visualização de heatmap com sns.heatmap(df.isna()) para padrões.",
                                    "Plote a série temporal com plt.plot() e destaque missings.",
                                    "Analise se missings são MCAR, MAR ou MNAR (ex: agrupar por período).",
                                    "Verifique a sequência temporal com df.index para confirmar ordem.",
                                    "Documente insights: frequência, localização e possível causa dos missings."
                                  ],
                                  "verification": "Gere plots e anote padrões (ex: missings consecutivos indicam falha de sensor).",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": "Python com Pandas, Matplotlib e Seaborn; mesmo dataset.",
                                  "tips": "Use missingno library para visualizações avançadas como matrix ou bar.",
                                  "learningObjective": "Visualizar e interpretar padrões de valores ausentes preservando contexto temporal.",
                                  "commonMistakes": "Ignorar correlações entre colunas; tratar todos missings como aleatórios sem análise."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Selecionar e aplicar métodos de tratamento",
                                  "subSteps": [
                                    "Escolha método baseado em análise: forward-fill (df.fillna(method='ffill')) para séries temporais.",
                                    "Aplique interpolação linear: df.interpolate(method='time') se índice for datetime.",
                                    "Para remoção: df.dropna() apenas se <5% missings e não consecutivos.",
                                    "Preserve índice temporal: pd.to_datetime(df.index) se necessário.",
                                    "Crie cópia do dataset original para comparação: df_original = df.copy()."
                                  ],
                                  "verification": "Confirme df.isna().sum().sum() == 0 e len(df) == len(df_original).",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": "Mesmo ambiente Python; funções Pandas fillna() e interpolate().",
                                  "tips": "Priorize métodos que respeitam tendência temporal como ffill ou bfill em séries.",
                                  "learningObjective": "Aplicar técnicas de imputação adequadas para séries temporais sem distorcer sequência.",
                                  "commonMistakes": "Usar mean/median fill que ignora temporalidade; dropar muitos dados sem justificativa."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar tratamento e comparar resultados",
                                  "subSteps": [
                                    "Compare estatísticas descritivas antes/depois: df.describe().",
                                    "Plote séries originais vs tratadas para checar suavidade.",
                                    "Teste autocorrelação com df.autocorr() para verificar preservação.",
                                    "Simule cenários: aplique missing artificial e re-trate.",
                                    "Salve dataset tratado e relatório de mudanças."
                                  ],
                                  "verification": "Estatísticas similares e plots sem artefatos; relatório documentado.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": "Pandas, Matplotlib; datasets antes/depois.",
                                  "tips": "Use df.diff() para detectar jumps anormais pós-tratamento.",
                                  "learningObjective": "Avaliar eficácia do tratamento garantindo integridade da série temporal.",
                                  "commonMistakes": "Não comparar com original; assumir sucesso sem validação visual/estatística."
                                }
                              ],
                              "practicalExample": "Em um dataset de temperaturas diárias de uma cidade (ex: 'temperatura.csv' com datas como índice e coluna 'temp' com 10% NaNs consecutivos devido a falha de sensor), detecte missings com isna().sum(), visualize heatmap, aplique forward-fill (df['temp'].fillna(method='ffill')) e valide plotando antes/depois para confirmar preservação da tendência sazonal.",
                              "finalVerifications": [
                                "df.isna().sum().sum() retorna 0 (nenhum missing restante).",
                                "Comprimento do dataset permanece igual ao original.",
                                "Plots antes/depois mostram continuidade temporal sem jumps artificiais.",
                                "Estatísticas descritivas (mean, std) variam <5%.",
                                "Autocorrelação lag-1 similar ao original.",
                                "Índice datetime intacto e ordenado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção: 100% de missings identificados corretamente.",
                                "Escolha de método adequada ao padrão temporal (ex: ffill para consecutivos).",
                                "Preservação da sequência: nenhum dado dropado desnecessariamente.",
                                "Validação completa: uso de plots e stats comparativos.",
                                "Eficiência: código limpo sem loops desnecessários.",
                                "Documentação: comentários explicando escolhas."
                              ],
                              "crossCurricularConnections": [
                                "Estatística Descritiva: análise de distribuições e padrões MCAR/MAR.",
                                "Visualização de Dados: heatmaps e plots de séries temporais.",
                                "Programação em Python/R: manipulação de dataframes e funções vetorizadas.",
                                "Análise Exploratória de Dados (EDA): insights de missings.",
                                "Matemática Aplicada: interpolação e preenchimento preservando tendências."
                              ],
                              "realWorldApplication": "Em meteorologia, tratar missings em dados de sensores para previsões precisas; em finanças, imputar preços de ações faltantes para modelagem de séries temporais sem perda de continuidade histórica."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.3.2",
                            "name": "Remover duplicatas e outliers",
                            "description": "Eliminar registros duplicados por timestamp e detectar outliers usando boxplots ou Z-score, ajustando para séries temporais sem distorcer tendências.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Inspecionar e Identificar Duplicatas por Timestamp",
                                  "subSteps": [
                                    "Carregue o dataset de série temporal usando pandas.read_csv() ou similar.",
                                    "Defina a coluna de timestamp como índice com pd.to_datetime().",
                                    "Use df.duplicated(subset=['timestamp']) para identificar duplicatas exatas baseadas no timestamp.",
                                    "Conte o número de duplicatas com df.duplicated().sum() e visualize com df[df.duplicated()].head().",
                                    "Salve uma cópia do dataset original para backup."
                                  ],
                                  "verification": "Execute df.duplicated(subset=['timestamp']).sum() e confirme que o número de duplicatas é exibido corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python com pandas, Jupyter Notebook",
                                  "tips": "Sempre use subset=['timestamp'] para focar em duplicatas temporais, ignorando variações mínimas em outros campos.",
                                  "learningObjective": "Entender como inspecionar datasets de séries temporais para duplicatas baseadas em timestamps.",
                                  "commonMistakes": "Não converter timestamp para datetime, levando a falsos duplicados; esquecer de fazer backup."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Remover Duplicatas Mantendo a Primeira Ocorrência",
                                  "subSteps": [
                                    "Aplique df.drop_duplicates(subset=['timestamp'], keep='first') para remover duplicatas.",
                                    "Reindexe o DataFrame para garantir continuidade temporal com df.reset_index(drop=True).",
                                    "Verifique a forma do dataset antes e depois com df.shape.",
                                    "Plote uma prévia da série temporal para confirmar remoção sem gaps inesperados.",
                                    "Salve o dataset limpo de duplicatas como novo arquivo CSV."
                                  ],
                                  "verification": "Confirme df.shape mudou e df.duplicated(subset=['timestamp']).sum() == 0.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Python com pandas, matplotlib para plotagem",
                                  "tips": "Use keep='first' para séries temporais, pois mantém o registro mais antigo e evita distorções.",
                                  "learningObjective": "Dominar a remoção segura de duplicatas em séries temporais sem perder dados essenciais.",
                                  "commonMistakes": "Remover todas as duplicatas (keep=False) sem critério, perdendo informações valiosas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detectar Outliers Usando Boxplots e Z-Score Adaptado para Séries Temporais",
                                  "subSteps": [
                                    "Gere boxplots por janelas deslizantes (ex: rolling window de 30 dias) com seaborn.boxplot().",
                                    "Calcule Z-scores locais: df['z_score'] = (df['value'] - df['value'].rolling(30).mean()) / df['value'].rolling(30).std().",
                                    "Identifique outliers como |z_score| > 3 em janelas temporais.",
                                    "Visualize outliers no gráfico da série temporal com plt.scatter() para pontos anômalos.",
                                    "Crie uma máscara booleana df['is_outlier'] para marcar outliers detectados."
                                  ],
                                  "verification": "Conte os outliers identificados e confirme visualmente no boxplot sem distorções de tendência global.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python com pandas, numpy, matplotlib, seaborn",
                                  "tips": "Use janelas rolling para séries temporais, evitando detecção de sazonalidades como outliers.",
                                  "learningObjective": "Aplicar métodos de detecção de outliers sensíveis a estruturas temporais.",
                                  "commonMistakes": "Usar Z-score global, que flagra variações sazonais como outliers."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Tratar e Verificar Outliers sem Distorcer Tendências",
                                  "subSteps": [
                                    "Substitua outliers por interpolação linear: df['value'] = df['value'].interpolate(method='linear').",
                                    "Alternativamente, remova com df = df[~df['is_outlier']] e reinterpole gaps.",
                                    "Compare estatísticas descritivas antes/depois (mean, std, trend via lmplot).",
                                    "Plote a série limpa vs original para validar preservação de tendências.",
                                    "Salve o dataset final e gere relatório de mudanças (número de duplicatas/outliers tratados)."
                                  ],
                                  "verification": "Tendência linear (df['value'].rolling(90).mean()) permanece estável; sem gaps visíveis no plot.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Python com pandas, scipy para interpolação, matplotlib",
                                  "tips": "Prefira interpolação a remoção para manter comprimento da série temporal.",
                                  "learningObjective": "Tratar outliers preservando integridade das séries temporais.",
                                  "commonMistakes": "Remover outliers sem interpolação, criando gaps que distorcem análises futuras."
                                }
                              ],
                              "practicalExample": "Em um dataset de temperaturas diárias de uma cidade (timestamp e temp_C), remova 5 duplicatas de datas idênticas e trate 3 picos invernal anômalos (ex: 50°C) usando Z-score em janela de 7 dias, interpolando para manter a tendência sazonal de aquecimento global.",
                              "finalVerifications": [
                                "Nenhuma duplicata por timestamp: df.duplicated(subset=['timestamp']).sum() == 0",
                                "Outliers detectados e tratados: len(df[df['is_outlier']]) == 0 pós-tratamento",
                                "Forma do dataset lógico: sem gaps inesperados em timestamps sequenciais",
                                "Estatísticas preservadas: média e desvio padrão variam <5% pós-limpeza",
                                "Visual: Plot da série limpa sobrepõe tendência original",
                                "Relatório gerado com contagens de ações realizadas"
                              ],
                              "assessmentCriteria": [
                                "Precisão na remoção de duplicatas sem perda de dados únicos (100% corretos)",
                                "Detecção de outliers adaptada a temporalidade (taxa de falsos positivos <10%)",
                                "Preservação de tendências: correlação >0.95 entre original e limpo",
                                "Eficiência: tempo total <90 minutos para dataset de 10k registros",
                                "Documentação: código comentado e relatório claro",
                                "Robustez: funciona em datasets com missing values iniciais"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Manipulação de DataFrames em Python/pandas",
                                "Matemática: Estatística descritiva, Z-scores e distribuições",
                                "Visualização de Dados: Boxplots e gráficos temporais com matplotlib/seaborn",
                                "Ciência de Dados: Pré-processamento em machine learning pipelines"
                              ],
                              "realWorldApplication": "Em finanças, limpar dados de preços de ações para modelos de previsão sem distorções por erros de feed; em meteorologia, tratar sensores falhos em séries de precipitação para análises climáticas precisas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.3.3",
                            "name": "Verificar consistência temporal",
                            "description": "Garantir ausência de gaps ou sobreposições nos timestamps, usando resample ou seq para preencher intervalos regulares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Inspecionar os Timestamps Existentes",
                                  "subSteps": [
                                    "Carregue o dataset de série temporal usando pandas (pd.read_csv ou similar).",
                                    "Converta a coluna de timestamp para datetime com pd.to_datetime().",
                                    "Ordene o DataFrame pelo timestamp com sort_values().",
                                    "Calcule diferenças entre timestamps consecutivos usando diff().",
                                    "Visualize o índice temporal com plot() para identificar irregularidades iniciais."
                                  ],
                                  "verification": "Confirme que os timestamps estão em formato datetime e ordenados cronologicamente sem erros iniciais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Biblioteca pandas",
                                    "Dataset de exemplo com timestamps (ex: dados de vendas diárias)"
                                  ],
                                  "tips": "Use freq='D' ou 'H' no to_datetime() para inferir frequência; sempre verifique timezone.",
                                  "learningObjective": "Entender a estrutura temporal dos dados e preparar para detecção de inconsistências.",
                                  "commonMistakes": [
                                    "Ignorar timezones diferentes",
                                    "Não ordenar antes de diff()",
                                    "Assumir formato sem conversão explícita"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Detectar Gaps e Sobreposições",
                                  "subSteps": [
                                    "Crie uma série de diferenças: ts_diff = df.index.to_series().diff().",
                                    "Identifique gaps: gaps = ts_diff > pd.Timedelta('1D') (ajuste o intervalo esperado).",
                                    "Detecte sobreposições: overlaps = ts_diff <= pd.Timedelta('0s').",
                                    "Gere relatórios: len(gaps.sum()) gaps encontrados e liste timestamps afetados.",
                                    "Plote as diferenças para visualização com histograma ou scatter plot."
                                  ],
                                  "verification": "Lista de gaps e overlaps gerada e exibida, com contagem precisa.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Pandas",
                                    "Matplotlib para plots"
                                  ],
                                  "tips": "Defina o intervalo esperado baseado no contexto (diário, horário); use isna() para missing values.",
                                  "learningObjective": "Identificar precisamente inconsistências temporais como gaps e overlaps.",
                                  "commonMistakes": [
                                    "Usar diff() sem Timedelta",
                                    "Não considerar frequência irregular inicial",
                                    "Ignorar duplicates no index"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Corrigir Inconsistências com Resample ou Seq",
                                  "subSteps": [
                                    "Defina o índice como DatetimeIndex com set_index().",
                                    "Use resample('D').mean() ou ffills() para preencher gaps (escolha método adequado).",
                                    "Para overlaps, agregue com resample('D').first() ou drop_duplicates().",
                                    "Alternativa em R-like: pd.date_range(start, end, freq='D') para criar seq regular e reindex().",
                                    "Preencha valores missing com interpolate() ou forward fill."
                                  ],
                                  "verification": "Novo DataFrame tem índice regular sem gaps/overlaps, confirmado por diff() constante.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Pandas resample e interpolate funções"
                                  ],
                                  "tips": "Escolha método de preenchimento baseado no domínio (ex: mean para numérico, ffill para cumulativo).",
                                  "learningObjective": "Aplicar técnicas de resampling para uniformizar séries temporais.",
                                  "commonMistakes": [
                                    "Resample sem definir freq correta",
                                    "Perder dados originais sem backup",
                                    "Usar fillna(0) em vez de interpolate"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Documentar a Consistência Final",
                                  "subSteps": [
                                    "Reexecute diff() no DataFrame corrigido e confirme todos diffs iguais ao intervalo esperado.",
                                    "Compare estatísticas antes/depois: shape, min/max timestamps, missing count.",
                                    "Gere um relatório: 'Gaps corrigidos: X, Overlaps removidos: Y'.",
                                    "Salve o dataset limpo com to_csv() e anote mudanças em log.",
                                    "Teste com plot() para visual confirmação de regularidade."
                                  ],
                                  "verification": "Relatório confirma ausência total de gaps/overlaps e regularidade.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Pandas describe()",
                                    "Notebook Jupyter para logging"
                                  ],
                                  "tips": "Sempre crie cópia df_clean = df.copy() antes de alterações.",
                                  "learningObjective": "Garantir e documentar a qualidade temporal dos dados processados.",
                                  "commonMistakes": [
                                    "Não validar após correção",
                                    "Sobrescrever dados originais",
                                    "Ignorar edge cases como feriados"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um dataset de temperaturas horárias de uma estação meteorológica (ex: dados de 2023 com missing horas nos dias 5-7 e duplicatas no dia 10), use resample('H').mean() para preencher gaps e drop_duplicates() para overlaps, resultando em 8760 observações regulares anuais.",
                              "finalVerifications": [
                                "Todos diffs entre timestamps consecutivos são iguais ao intervalo esperado (ex: 1 dia).",
                                "Número de observações corresponde ao período total sem gaps.",
                                "Ausência de valores duplicados ou NaN nos timestamps.",
                                "Estatísticas descritivas (min, max, count) confirmam cobertura completa.",
                                "Visualização temporal mostra linha contínua sem interrupções.",
                                "Relatório de mudanças documentado e salvo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção: 100% dos gaps/overlaps identificados corretamente.",
                                "Adequação da correção: Método de resample apropriado ao contexto (90%+ eficácia).",
                                "Validação completa: Todas verificações finais passadas sem erros.",
                                "Eficiência temporal: Conclusão dentro do tempo estimado com código limpo.",
                                "Documentação: Relatório claro com antes/depois.",
                                "Criatividade: Adaptação a cenários reais como timezones ou freqs irregulares."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Manipulação de dataframes em Python/R.",
                                "Matemática: Sequências aritméticas e interpolação linear.",
                                "Ciência de Dados: Pré-processamento para modelagem preditiva.",
                                "Gestão de Projetos: Documentação de ETL pipelines."
                              ],
                              "realWorldApplication": "Em finanças, verificar consistência em séries de preços de ações diários para evitar erros em backtesting de algoritmos de trading; em IoT, uniformizar dados de sensores para monitoramento preditivo de falhas em manufatura."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.4.4",
                        "name": "Transformações Iniciais de Dados",
                        "description": "Aplicar transformações básicas para estabilizar e preparar a série temporal, como indexação, agregação e logaritmização.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.4.1",
                            "name": "Definir índice temporal",
                            "description": "Configurar coluna de data como índice DatetimeIndex (Python) ou ts/zoo (R), habilitando operações temporais como shift e diff.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Importar Bibliotecas e Carregar Dados",
                                  "subSteps": [
                                    "Instale e importe pandas (Python) ou zoo/ts (R) via pip/install.packages.",
                                    "Carregue o dataset com pd.read_csv() (Python) ou read.csv() seguido de as.data.frame() (R).",
                                    "Inspecione a estrutura dos dados com df.info() ou str(df) para identificar a coluna de data (ex: 'date').",
                                    "Visualize as primeiras linhas com df.head() para confirmar formato da coluna de data (ex: '2023-01-01').",
                                    "Garanta que a coluna de data não tenha valores ausentes com df['date'].isnull().sum() ou sum(is.na(df$date))."
                                  ],
                                  "verification": "Execute df.head() e df.info()/str(df); confirme que dados carregaram corretamente e coluna de data existe.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Bibliotecas: pandas (Python), zoo/exts (R); dataset CSV de exemplo com coluna 'date' (ex: temperaturas diárias).",
                                  "tips": "Use encoding='utf-8' no read_csv se houver problemas de caracteres especiais.",
                                  "learningObjective": "Preparar ambiente e dados para manipulação temporal.",
                                  "commonMistakes": "Esquecer de importar bibliotecas; ignorar formato inconsistente de datas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar e Converter Coluna de Data para Formato Temporal",
                                  "subSteps": [
                                    "Converta coluna para datetime: pd.to_datetime(df['date']) (Python) ou as.Date(df$date) ou as.POSIXct() (R).",
                                    "Atribua de volta: df['date'] = pd.to_datetime(df['date']) ou df$date <- as.Date(df$date).",
                                    "Trate valores inválidos: use errors='coerce' (Python) ou na.rm=TRUE onde aplicável (R).",
                                    "Ordene o DataFrame por data: df.sort_values('date') ou df[order(df$date),].",
                                    "Verifique conversão: df['date'].dtype == 'datetime64[ns]' (Python) ou class(df$date) == 'Date' (R)."
                                  ],
                                  "verification": "Confirme dtype/class da coluna como datetime/Date; não há NaT/NA em datas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Dataset do Step 1; funções pd.to_datetime/as.Date.",
                                  "tips": "Especifique format='%Y-%m-%d' se o formato for irregular para acelerar conversão.",
                                  "learningObjective": "Transformar strings de data em objetos temporais manipuláveis.",
                                  "commonMistakes": "Não ordenar dados, levando a séries temporais desordenadas; ignorar fusos horários."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Coluna de Data como Índice Temporal",
                                  "subSteps": [
                                    "Defina índice em Python: df.set_index('date', inplace=True) resultando em DatetimeIndex.",
                                    "Em R: use zoo::zoots(df$value, order.by=df$date) ou tsibble::as_tsibble(df, index=date).",
                                    "Remova coluna original se necessário: del df['date'] (Python) ou df$date <- NULL (R).",
                                    "Renomeie índice se desejado: df.index.name = 'timestamp' (Python).",
                                    "Confirme: print(df.index) mostra DatetimeIndex ou classe temporal (R)."
                                  ],
                                  "verification": "df.index é DatetimeIndex (Python) ou tem classe 'zoo'/'tsibble' (R); shape preservado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "DataFrame preparado do Step 2.",
                                  "tips": "Use inplace=True para modificar original; freq='D' se diário para inferir frequência.",
                                  "learningObjective": "Habilitar indexação temporal para operações como shift/diff.",
                                  "commonMistakes": "Índice duplicado causando erros; não definir inplace corretamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Testar Operações Temporais Básicas",
                                  "subSteps": [
                                    "Teste shift: df.shift(1) (Python) ou lag(df$value,1) (R).",
                                    "Teste diff: df.diff() (Python) ou diff(df$value) (R).",
                                    "Visualize: df.plot() ou plot(df) para ver continuidade temporal.",
                                    "Resample se aplicável: df.resample('M').mean() (Python) ou aggregate por mês (R).",
                                    "Salve DataFrame indexado: df.to_csv('temporal_data.csv') ou write.csv(df,'temporal_data.csv')."
                                  ],
                                  "verification": "shift(1) e diff() executam sem erros; resultados fazem sentido (ex: diff mostra mudanças).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "DataFrame indexado do Step 3; matplotlib/ggplot para plots opcionais.",
                                  "tips": "Use freq='infer' no resample para detectar automaticamente; plot para validar visualmente.",
                                  "learningObjective": "Validar que índice temporal habilita análises sequenciais.",
                                  "commonMistakes": "Aplicar shift/diff sem índice temporal, resultando em erros ou NaNs iniciais não entendidos."
                                }
                              ],
                              "practicalExample": "Dataset de vendas diárias (coluna 'date': '2023-01-01' a '2023-01-31', 'sales': [100,105,...]). Converta 'date' para índice DatetimeIndex/zoo, compute df['sales'].diff() para ver variações diárias, e df.shift(1) para comparar com dia anterior.",
                              "finalVerifications": [
                                "Índice é DatetimeIndex (Python) ou zoo/ts (R) com datas corretas.",
                                "shift(1) retorna série deslocada sem erros, com NaN no primeiro valor.",
                                "diff() computa diferenças corretas entre períodos consecutivos.",
                                "Dados ordenados cronologicamente: df.index.is_monotonic_increasing == True.",
                                "Não há duplicatas no índice: df.index.duplicated().sum() == 0.",
                                "Operações como resample('W').sum() funcionam.",
                                "Plot temporal mostra sequência lógica."
                              ],
                              "assessmentCriteria": [
                                "Código executa sem erros de tipo ou índice.",
                                "Índice reconhecido como temporal (dtype correto).",
                                "shift e diff produzem outputs esperados e interpretáveis.",
                                "Tratamento adequado de dados ausentes/inválidos.",
                                "Eficiência: tempo de execução razoável (<1s para 1000 linhas).",
                                "Documentação/comentários no código explicam passos.",
                                "Testes de verificação incluídos no script."
                              ],
                              "crossCurricularConnections": [
                                "Programação Computacional: Manipulação de DataFrames em Python/R.",
                                "Estatística Descritiva: Cálculo de diferenças e lags temporais.",
                                "Visualização de Dados: Plots de séries temporais com matplotlib/ggplot.",
                                "Banco de Dados: Importação e limpeza de dados tabulares.",
                                "Matemática: Conceitos de sequências e diferenças finitas."
                              ],
                              "realWorldApplication": "Em análise financeira, definir preço de ações por data como índice permite calcular retornos diários via diff() para modelos de risco; em meteorologia, indexar temperaturas por tempo habilita forecasts com shift para validação de modelos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.4.2",
                            "name": "Realizar agregações temporais",
                            "description": "Agregue dados de alta frequência para baixa usando resample.mean() ou aggregate(), calculando médias, somas ou contagens por período.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e carregar os dados de alta frequência",
                                  "subSteps": [
                                    "Carregue um dataset de exemplo com dados de alta frequência (ex: por minuto) usando pd.read_csv()",
                                    "Inspecione a estrutura com .info() e .head() para identificar a coluna de timestamp",
                                    "Converta a coluna de timestamp para datetime usando pd.to_datetime()",
                                    "Verifique duplicatas ou valores ausentes com .duplicated() e .isnull().sum()",
                                    "Defina a coluna de timestamp como índice com .set_index()"
                                  ],
                                  "verification": "Execute df.index.dtype para confirmar que é datetime64[ns] e df.head() mostra dados corretos",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Biblioteca Pandas instalada",
                                    "Jupyter Notebook ou IDE Python",
                                    "Dataset CSV de exemplo com timestamps (ex: vendas_minuto.csv)"
                                  ],
                                  "tips": "Sempre salve uma cópia do DataFrame original com df_original = df.copy() para evitar perda de dados",
                                  "learningObjective": "Entender a importância de preparar dados temporais corretamente antes de agregações",
                                  "commonMistakes": [
                                    "Não converter timestamp para datetime",
                                    "Ignorar valores ausentes que distorcem agregações",
                                    "Definir índice incorreto"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a frequência desejada e escolher funções de agregação",
                                  "subSteps": [
                                    "Decida a nova frequência (ex: 'H' para hora, 'D' para dia) com base no contexto",
                                    "Selecione funções: 'mean()' para médias, 'sum()' para somas, 'count()' para contagens",
                                    "Planeje múltiplas agregações se necessário, usando dict como {'valor': 'mean', 'contagem': 'count'}",
                                    "Teste em um subconjunto pequeno com df_small = df.head(100) para validar",
                                    "Documente a escolha em um comentário no código"
                                  ],
                                  "verification": "Crie um dicionário de agregações e imprima para confirmar: print(agg_dict)",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Documentação Pandas resample",
                                    "Notebook com dados carregados"
                                  ],
                                  "tips": "Use 'sum()' para quantidades acumuláveis como vendas, 'mean()' para médias como temperatura",
                                  "learningObjective": "Selecionar apropriadamente funções de agregação para preservar o significado dos dados",
                                  "commonMistakes": [
                                    "Usar 'mean()' em dados não aditivos como contagens",
                                    "Escolher frequência muito ampla perdendo granularidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar o resample e aplicar agregações",
                                  "subSteps": [
                                    "Aplique resample() com a frequência: df_resampled = df.resample('H')",
                                    "Use .agg() ou métodos diretos: df_resampled.mean() ou df_resampled.agg({'coluna': 'sum'})",
                                    "Preencha valores ausentes com .fillna(method='ffill') ou .fillna(0) se apropriado",
                                    "Renomeie colunas resultantes com .rename() para clareza",
                                    "Salve o resultado em um novo DataFrame"
                                  ],
                                  "verification": "Compare tamanhos: print(f'Original: {len(df)}, Agregado: {len(df_resampled)}') e verifique valores esperados",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Pandas",
                                    "Dataset preparado"
                                  ],
                                  "tips": "Para múltiplas colunas, use .agg() com dicionário para flexibilidade",
                                  "learningObjective": "Dominar a sintaxe de resample() e agg() para transformações temporais eficientes",
                                  "commonMistakes": [
                                    "Resample sem índice datetime",
                                    "Não tratar NaNs pós-agregação",
                                    "Agg em colunas erradas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e visualizar os resultados agregados",
                                  "subSteps": [
                                    "Plote os dados originais e agregados com .plot() para comparação visual",
                                    "Calcule estatísticas descritivas com .describe() nos dois DataFrames",
                                    "Verifique consistência: soma de agregados deve aproximar total original",
                                    "Exporte para CSV com .to_csv() para inspeção externa",
                                    "Registre insights em markdown no notebook"
                                  ],
                                  "verification": "Gráficos mostram agregação suave sem artefatos e estatísticas coerentes",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Matplotlib ou Seaborn para plots",
                                    "Notebook"
                                  ],
                                  "tips": "Use plt.figure(figsize=(12,6)) para visualizações claras lado a lado",
                                  "learningObjective": "Garantir qualidade dos dados agregados através de validação quantitativa e visual",
                                  "commonMistakes": [
                                    "Ignorar discrepâncias numéricas",
                                    "Plots sem legendas ou labels",
                                    "Não validar preenchimento de NaNs"
                                  ]
                                }
                              ],
                              "practicalExample": "Carregue dados de temperatura medida a cada 5 minutos em um dia. Use df.resample('H').agg({'temperatura': 'mean'}) para obter média horária, resultando em 24 valores diários em vez de 288 originais.",
                              "finalVerifications": [
                                "Índice do DataFrame resultante é DatetimeIndex com frequência correta",
                                "Número de linhas reduzido conforme esperado (ex: minutos para horas divide por 60)",
                                "Valores agregados batem com cálculos manuais em amostras",
                                "Ausência de NaNs não tratados ou inconsistências",
                                "Visualização confirma tendência suave sem picos artificiais",
                                "Código é reproduzível e comentado"
                              ],
                              "assessmentCriteria": [
                                "Precisão das agregações (erro <1% em validações manuais)",
                                "Eficiência do código (tempo de execução <5s para 10k linhas)",
                                "Tratamento adequado de edge cases (NaNs, fins de semana)",
                                "Clareza e documentação do código",
                                "Escolha contextualizada de funções de agregação",
                                "Validação visual e estatística completa"
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Cálculo de medidas resumo (média, soma)",
                                "Programação: Manipulação de DataFrames em Python/Pandas",
                                "Matemática: Operações em séries numéricas e indexação",
                                "Ciência de Dados: Pré-processamento para modelagem",
                                "Finanças: Agregação de ticks para candles diários"
                              ],
                              "realWorldApplication": "Em meteorologia, agregar leituras de sensores por segundo para relatórios diários; em e-commerce, somar transações por minuto para dashboards horários de vendas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.4.3",
                            "name": "Aplicar transformações estabilizadoras",
                            "description": "Executar log, sqrt ou Box-Cox para estabilizar variância, e diferenciação simples para remover tendência inicial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Diagnosticar não-estacionariedade na variância e tendência",
                                  "subSteps": [
                                    "Carregue a série temporal usando pandas.read_csv ou similar.",
                                    "Plote a série temporal original e observe padrões visuais de variância crescente ou tendência.",
                                    "Calcule estatísticas descritivas por janelas deslizantes para quantificar variância.",
                                    "Realize teste de Dickey-Fuller Aumentado (ADF) na série original.",
                                    "Examine o gráfico de resíduos ou ACF para confirmar heteroscedasticidade."
                                  ],
                                  "verification": "Gráficos mostram variância crescente ou falha no teste ADF (p-valor > 0.05).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python (pandas, matplotlib, statsmodels), dataset de série temporal (ex: vendas mensais).",
                                  "tips": "Use log escala no plot para visualizar variância melhor.",
                                  "learningObjective": "Identificar visual e estatisticamente problemas de variância e tendência.",
                                  "commonMistakes": "Ignorar janelas deslizantes e julgar só pelo plot cru."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar transformação estabilizadora de variância (log, sqrt ou Box-Cox)",
                                  "subSteps": [
                                    "Escolha a transformação: log para variância proporcional, sqrt para variância quadrática, Box-Cox para otimização automática.",
                                    "Implemente np.log(), np.sqrt() ou scipy.stats.boxcox() no pandas Series.",
                                    "Plote a série transformada e compare com a original.",
                                    "Calcule variância em janelas deslizantes na transformada.",
                                    "Ajuste parâmetro lambda no Box-Cox se necessário (use boxcox com lmbda=None para otimizar)."
                                  ],
                                  "verification": "Variância em janelas deslizantes é aproximadamente constante.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Python (numpy, scipy.stats, pandas, matplotlib).",
                                  "tips": "Para Box-Cox, verifique se dados são positivos; adicione constante pequena se zero.",
                                  "learningObjective": "Selecionar e executar a transformação apropriada para homogeneizar variância.",
                                  "commonMistakes": "Aplicar log em dados com zeros ou negativos sem ajuste."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar diferenciação simples para remover tendência",
                                  "subSteps": [
                                    "Use diff(1) no pandas Series para primeira diferenciação.",
                                    "Plote a série diferenciada e verifique remoção de tendência.",
                                    "Aplique segunda diferenciação se autocorrelação persistir em lag 1.",
                                    "Realize teste ADF na série diferenciada.",
                                    "Calcule ACF/PACF para confirmar ausência de tendência."
                                  ],
                                  "verification": "Plot mostra ausência de tendência linear e ADF p-valor < 0.05.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python (pandas, statsmodels.tsa.stattools.adfuller).",
                                  "tips": "Não diferencie excessivamente para evitar sobrediferenciação (verifique com ACF).",
                                  "learningObjective": "Executar diferenciação e validar remoção de tendência não-sazonal.",
                                  "commonMistakes": "Diferenciar sem verificar necessidade, causando ruído excessivo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar transformações finais e documentar processo",
                                  "subSteps": [
                                    "Compare métricas pré e pós-transformação (ADF, variância, Q-Q plot).",
                                    "Plote todos os estágios: original, variância estabilizada, diferenciada.",
                                    "Documente escolhas (ex: 'Box-Cox lambda=0.5 usado pois variância quadrática').",
                                    "Teste estacionariedade final com KPSS ou Ljung-Box.",
                                    "Salve a série transformada para modelagem futura."
                                  ],
                                  "verification": "Todos testes indicam estacionariedade (ADF rejeita unidade raiz).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Python (statsmodels, scipy.stats.probplot).",
                                  "tips": "Use subplots para comparações visuais eficientes.",
                                  "learningObjective": "Avaliar eficácia das transformações e preparar para modelagem.",
                                  "commonMistakes": "Pular validação estatística e confiar só em plots."
                                }
                              ],
                              "practicalExample": "Em um dataset de vendas mensais de smartphones (aumentando com variância crescente), aplique log para estabilizar variância (vendas_log = np.log(vendas)), então diff(1) para remover tendência ascendente. Resultado: série estacionária pronta para ARIMA.",
                              "finalVerifications": [
                                "Teste ADF na série final rejeita hipótese nula (p < 0.05).",
                                "Gráfico de ACF decai rapidamente sem picos persistentes.",
                                "Variância em janelas rolantes é estável (±10% variação).",
                                "Q-Q plot mostra resíduos próximos a normal.",
                                "KPSS test não rejeita estacionariedade em nível."
                              ],
                              "assessmentCriteria": [
                                "Correção na escolha e implementação das transformações.",
                                "Validação estatística e visual adequada em todos passos.",
                                "Interpretação precisa dos resultados (ex: por que log vs Box-Cox).",
                                "Código limpo, reproduzível e comentado.",
                                "Documentação de decisões e métricas pré/pós.",
                                "Eficiência: série final estacionária sem sobre-transformação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Propriedades de funções logarítmica e Box-Cox.",
                                "Programação: Manipulação de dados com pandas e testes estatísticos.",
                                "Economia: Preparação de séries para previsão de demanda.",
                                "Física: Transformações em sinais temporais ruidosos."
                              ],
                              "realWorldApplication": "Em finanças, estabilizar retornos de ações voláteis com log e diff para modelar GARCH/ARIMA; em meteorologia, transformar precipitação com variância sazonal para previsão de secas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.4.4",
                            "name": "Normalizar séries para comparação",
                            "description": "Aplicar min-max scaling ou z-score em séries temporais, mantendo a estrutura temporal intacta para análises comparativas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos de Normalização em Séries Temporais",
                                  "subSteps": [
                                    "Estude a fórmula do Min-Max Scaling: (x - min) / (max - min)",
                                    "Estude a fórmula do Z-Score: (x - μ) / σ, onde μ é a média e σ o desvio padrão",
                                    "Aprenda por que manter a estrutura temporal intacta é crucial para análises comparativas",
                                    "Compare os efeitos de cada método em dados com diferentes escalas",
                                    "Identifique cenários onde cada método é preferível (ex: Min-Max para limites conhecidos)"
                                  ],
                                  "verification": "Explique verbalmente ou por escrito as diferenças entre Min-Max e Z-Score, com exemplos numéricos simples.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Documentação Pandas/NumPy",
                                    "Notebook Jupyter",
                                    "Artigos sobre normalização de séries temporais"
                                  ],
                                  "tips": "Use gráficos de histogramas antes e depois para visualizar o impacto da normalização.",
                                  "learningObjective": "Dominar as fórmulas e implicações de Min-Max Scaling e Z-Score em contextos temporais.",
                                  "commonMistakes": [
                                    "Confundir normalização com padronização (Z-Score)",
                                    "Aplicar estatísticas globais em janelas deslizantes sem justificativa",
                                    "Ignorar a preservação da ordem temporal"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar Dados de Séries Temporais de Exemplo",
                                  "subSteps": [
                                    "Carregue ou crie duas séries temporais sintéticas ou reais (ex: vendas de produtos A e B ao longo de 12 meses)",
                                    "Verifique o índice temporal com pd.date_range() ou similar",
                                    "Calcule estatísticas descritivas (média, min, max, std) para cada série",
                                    "Visualize as séries originais com plot() para observar diferenças de escala",
                                    "Garanta que as séries tenham o mesmo comprimento e frequência temporal"
                                  ],
                                  "verification": "Execute df.describe() e plt.plot() para confirmar preparação correta dos dados.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "Python com Pandas, NumPy, Matplotlib",
                                    "Dataset CSV de séries temporais (ex: Kaggle)"
                                  ],
                                  "tips": "Use pd.read_csv(parse_dates=True) para índices temporais automáticos.",
                                  "learningObjective": "Preparar dados temporais limpos e alinhados para normalização comparativa.",
                                  "commonMistakes": [
                                    "Desalinhar índices temporais entre séries",
                                    "Incluir valores ausentes sem tratamento",
                                    "Usar dados não temporais por engano"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Min-Max Scaling Mantendo Estrutura Temporal",
                                  "subSteps": [
                                    "Implemente Min-Max manualmente: df['minmax'] = (df - df.min()) / (df.max() - df.min())",
                                    "Use sklearn.preprocessing.MinMaxScaler() para validação",
                                    "Aplique separadamente em cada série sem embaralhar",
                                    "Visualize séries normalizadas lado a lado",
                                    "Confirme que valores estão entre 0 e 1"
                                  ],
                                  "verification": "Verifique df['minmax'].min() == 0 e df['minmax'].max() == 1 para cada série.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Scikit-learn",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Ajuste feature_range=(0,1) no scaler para consistência.",
                                  "learningObjective": "Implementar Min-Max Scaling preservando a sequência temporal.",
                                  "commonMistakes": [
                                    "Normalizar globalmente misturando séries (perde comparabilidade)",
                                    "Aplicar scaler em dados de treino/teste incorretamente",
                                    "Arredondar valores prematuramente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Z-Score Normalization Mantendo Estrutura Temporal",
                                  "subSteps": [
                                    "Implemente Z-Score manualmente: df['zscore'] = (df - df.mean()) / df.std()",
                                    "Use sklearn.preprocessing.StandardScaler() para validação",
                                    "Aplique separadamente em cada série",
                                    "Visualize e compare com Min-Max",
                                    "Confirme média ≈ 0 e std ≈ 1"
                                  ],
                                  "verification": "Verifique abs(df['zscore'].mean()) < 0.01 e abs(df['zscore'].std() - 1) < 0.01.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Scikit-learn",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Use ddof=0 em std() para consistência com scaler.",
                                  "learningObjective": "Implementar Z-Score Normalization para séries comparáveis.",
                                  "commonMistakes": [
                                    "Usar std populacional vs amostral incorretamente",
                                    "Normalizar com base em estatísticas mistas",
                                    "Interpretar Z-Scores absolutos sem contexto temporal"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e Comparar Séries Normalizadas",
                                  "subSteps": [
                                    "Crie subplots comparando originais, Min-Max e Z-Score",
                                    "Calcule correlações entre séries normalizadas",
                                    "Analise padrões temporais preservados (ex: picos sazonais)",
                                    "Documente qual método é melhor para o exemplo",
                                    "Salve resultados em CSV para reutilização"
                                  ],
                                  "verification": "Correlação > 0.8 entre séries normalizadas e preservação visual de tendências.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "Matplotlib/Seaborn",
                                    "Pandas"
                                  ],
                                  "tips": "Use twinx() para sobrepor séries em escalas diferentes.",
                                  "learningObjective": "Avaliar efetividade da normalização em análises comparativas.",
                                  "commonMistakes": [
                                    "Ignorar outliers que afetam escalas",
                                    "Concluir sem visualizações",
                                    "Comparar métodos sem métricas quantitativas"
                                  ]
                                }
                              ],
                              "practicalExample": "Carregue dados de vendas mensais de dois produtos (Produto A: [100, 200, 150,...]; Produto B: [1000, 1500, 1200,...]). Aplique Min-Max e Z-Score separadamente. Plote para ver como picos sazonais se alinham após normalização, facilitando comparação de padrões de demanda.",
                              "finalVerifications": [
                                "Séries normalizadas mantêm índice temporal e comprimento idênticos",
                                "Min-Max: todos valores em [0,1]",
                                "Z-Score: média ≈0 e desvio padrão ≈1 por série",
                                "Visualizações mostram tendências comparáveis sem distorções de escala",
                                "Correlação entre séries normalizadas é significativa (>0.7)",
                                "Nenhum NaN ou valor inválido introduzido"
                              ],
                              "assessmentCriteria": [
                                "Fórmulas implementadas corretamente sem bibliotecas de alto nível inicialmente",
                                "Estrutura temporal preservada em todas as transformações",
                                "Estatísticas pós-normalização validadas numericamente",
                                "Interpretação clara das diferenças entre métodos",
                                "Código reproduzível e comentado",
                                "Análise comparativa com visualizações e métricas"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estatística descritiva e transformações lineares",
                                "Programação: Manipulação de DataFrames Pandas e visualização Matplotlib",
                                "Economia/Negócios: Análise de tendências de vendas e previsão de demanda",
                                "Ciências Ambientais: Normalização de dados climáticos para modelagem"
                              ],
                              "realWorldApplication": "Em finanças, normalizar retornos diários de ações de empresas de tamanhos diferentes permite comparar volatilidade e padrões de mercado sem viés de escala absoluta, auxiliando portfólios de investimento."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.5",
                    "name": "Análise Exploratória Inicial",
                    "description": "Técnicas básicas para visualização e identificação de padrões em séries temporais.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.5.1",
                        "name": "Formação e Preparação de Dados para Séries Temporais",
                        "description": "Entender os tipos de dados específicos de séries temporais, importar conjuntos de dados e realizar transformações iniciais para preparar a base para análise exploratória.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.1.1",
                            "name": "Identificar tipos de dados em séries temporais",
                            "description": "Diferenciar entre dados univariados e multivariados, séries com frequência regular ou irregular, e formatos comuns como CSV, Excel ou bancos de dados temporais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Básicos de Tipos de Séries Temporais",
                                  "subSteps": [
                                    "Defina série temporal univariada como dados com uma única variável ao longo do tempo.",
                                    "Defina série temporal multivariada como dados com múltiplas variáveis inter-relacionadas no tempo.",
                                    "Explique frequência regular (ex: dados diários fixos) versus irregular (ex: eventos esporádicos).",
                                    "Identifique exemplos reais: temperatura diária (univariada, regular) vs. ações e índices econômicos (multivariada, regular).",
                                    "Crie um fluxograma mental para classificar univariado/multivariado e regular/irregular."
                                  ],
                                  "verification": "Crie um resumo escrito ou diagrama distinguindo os quatro tipos principais (univariado regular, univariado irregular, multivariado regular, multivariado irregular).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Notebook para anotações, acesso a internet para definições (ex: Wikipedia ou Khan Academy sobre séries temporais).",
                                  "tips": "Use mnemônicos: 'Uni = Um', 'Multi = Muitos'; 'Regular = Ritmo fixo como relógio'.",
                                  "learningObjective": "Dominar definições precisas de univariado/multivariado e frequência regular/irregular.",
                                  "commonMistakes": "Confundir multivariado com correlação (foco em número de variáveis, não relações); ignorar gaps em dados irregulares."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Formatos Comuns de Dados de Séries Temporais",
                                  "subSteps": [
                                    "Descreva CSV: texto simples com colunas de data e valores, delimitado por vírgulas.",
                                    "Descreva Excel: planilhas com timestamps em colunas, suporte a fórmulas e gráficos.",
                                    "Descreva bancos de dados temporais (ex: InfluxDB, TimescaleDB): consultas SQL com índices temporais.",
                                    "Compare prós/contras: CSV (fácil portabilidade), Excel (visual), DB (escalável para grandes volumes).",
                                    "Baixe amostras de cada formato de repositórios públicos como Kaggle."
                                  ],
                                  "verification": "Liste características únicas de cada formato e identifique qual usar para um dataset de 1GB.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Amostras de arquivos CSV/Excel de séries temporais (ex: dados de ações do Yahoo Finance), visualizador de texto como Notepad++.",
                                  "tips": "Sempre verifique o cabeçalho das colunas para timestamps no primeiro passo.",
                                  "learningObjective": "Reconhecer e diferenciar formatos CSV, Excel e bancos de dados temporais.",
                                  "commonMistakes": "Assumir que todos CSVs têm datas na primeira coluna; ignorar encoding UTF-8 em CSVs internacionais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Praticar Identificação em Datasets Reais",
                                  "subSteps": [
                                    "Carregue um dataset CSV univariado regular (ex: temperaturas mensais).",
                                    "Analise colunas: conte variáveis, verifique intervalos de tempo uniformes.",
                                    "Repita com multivariado irregular (ex: logs de sensores IoT com eventos).",
                                    "Use ferramentas para inspecionar: pandas em Python (head(), info()) ou Excel filtros.",
                                    "Classifique cada dataset em uma tabela: tipo univariado/multivariado, frequência, formato."
                                  ],
                                  "verification": "Classifique corretamente 3 datasets fornecidos ou baixados, com justificativa por dataset.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com pandas (ou R com tidyverse), Jupyter Notebook, datasets de Kaggle (ex: 'AirPassengers' univariado, 'M4 Competition' multivariado).",
                                  "tips": "Plote os dados rapidamente (ex: pandas plot()) para visualizar regularidade.",
                                  "learningObjective": "Aplicar conceitos para inspecionar e classificar datasets reais.",
                                  "commonMistakes": "Não detectar missing values que criam irregularidade; confundir features não-temporais como multivariadas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e Testar Classificação Completa",
                                  "subSteps": [
                                    "Crie um checklist de identificação: colunas de tempo? Número de vars? Intervalos uniformes? Formato?",
                                    "Teste em dataset desconhecido: extraia metadados e classifique.",
                                    "Documente em relatório: tipo, frequência, formato e razões.",
                                    "Compare com documentação oficial do dataset se disponível.",
                                    "Reflita sobre desafios em dados reais (ex: fusos horários afetando regularidade)."
                                  ],
                                  "verification": "Produza relatório classificado para 2 datasets novos, com acurácia auto-avaliada >90%.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Datasets mistos (ex: COVID-19 cases CSV univariado, stock market Excel multivariado), template de relatório em Google Docs.",
                                  "tips": "Automatize com script simples: len(df.columns) para multivariado, diff em datas para regularidade.",
                                  "learningObjective": "Integrar todos conceitos em processo de classificação fluido.",
                                  "commonMistakes": "Overlook fusos horários ou formatos de data inconsistentes que mascaram irregularidade."
                                }
                              ],
                              "practicalExample": "Carregue o dataset 'AirPassengers' (CSV univariado mensal regular): verifique 1 coluna numérica + data implícita mensal uniforme. Compare com 'Rossmann Store Sales' (multivariado diário com promoções irregulares em Excel). Classifique ambos usando checklist.",
                              "finalVerifications": [
                                "Classifica corretamente univariado vs multivariado em 5 exemplos aleatórios.",
                                "Identifica frequência regular/irregular checando gaps em timestamps.",
                                "Distingue formatos CSV/Excel/DB por extensão e estrutura de amostra.",
                                "Explica diferenças com exemplos reais sem hesitação.",
                                "Cria checklist pessoal para identificação rápida.",
                                "Detecta irregularidades sutis como feriados em dados diários."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de conceitos (90%+ correto).",
                                "Capacidade de inspecionar datasets reais (classificação sem erros em 4/5 casos).",
                                "Profundidade em justificativas (inclui evidências de dados).",
                                "Eficiência no tempo: completa steps em <3 horas totais.",
                                "Criatividade em exemplos e conexões reais.",
                                "Checklist robusto cobrindo todos aspectos."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Uso de pandas/SQL para inspeção de dados.",
                                "Estatística: Medidas de frequência e autocorrelação básica.",
                                "Banco de Dados: Queries temporais em SQL/NoSQL.",
                                "Visualização: Gráficos de linha para detectar regularidade."
                              ],
                              "realWorldApplication": "Em finanças, identificar séries multivariadas regulares (ações + volume) em CSV para modelagem preditiva; em IoT, detectar dados irregulares de sensores em DB para manutenção preditiva de equipamentos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.1.2",
                            "name": "Importar dados de séries temporais",
                            "description": "Utilizar bibliotecas como pandas em Python ou readr em R para carregar dados temporais de arquivos e convertê-los em objetos de série temporal indexados por data.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de desenvolvimento",
                                  "subSteps": [
                                    "Instale o Python (versão 3.8 ou superior) se não estiver instalado.",
                                    "Instale a biblioteca pandas via pip: `pip install pandas`.",
                                    "Instale pandas-datareader ou outras libs auxiliares se necessário: `pip install openpyxl` para Excel.",
                                    "Crie um novo script Python ou notebook Jupyter.",
                                    "Importe pandas: `import pandas as pd` e teste com `pd.__version__`."
                                  ],
                                  "verification": "Execute `import pandas as pd; print(pd.__version__)` sem erros e veja a versão impressa.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Python 3.8+",
                                    "pip",
                                    "Editor de código (VS Code ou Jupyter Notebook)",
                                    "Internet para instalação"
                                  ],
                                  "tips": "Use um ambiente virtual (venv) para isolar dependências: `python -m venv ts_env` e ative-o.",
                                  "learningObjective": "Preparar um ambiente funcional para manipulação de dados temporais com pandas.",
                                  "commonMistakes": [
                                    "Esquecer de ativar ambiente virtual",
                                    "Instalar pandas sem pip atualizado (`pip install --upgrade pip`)",
                                    "Usar Python 2.x"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Carregar dados de arquivo CSV ou Excel",
                                  "subSteps": [
                                    "Baixe ou crie um arquivo CSV com colunas de data e valores (ex: 'date', 'value').",
                                    "Use `pd.read_csv('dados.csv')` para carregar os dados em um DataFrame.",
                                    "Inspecione com `df.head()`, `df.info()` e `df.describe()`.",
                                    "Trate valores ausentes iniciais com `df.dropna(subset=['date'])`.",
                                    "Renomeie colunas se necessário: `df.columns = ['data', 'valor']`."
                                  ],
                                  "verification": "O DataFrame carregado tem shape correto e primeiras linhas visíveis sem erros de parsing.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Arquivo CSV de exemplo com dados temporais (ex: temperaturas diárias)",
                                    "pandas instalado"
                                  ],
                                  "tips": "Especifique `parse_dates=['date']` no read_csv para pré-processar datas.",
                                  "learningObjective": "Carregar dados brutos de fontes comuns em um DataFrame pandas.",
                                  "commonMistakes": [
                                    "Caminho de arquivo incorreto (use path absoluto)",
                                    "Separador errado (use `sep=';'` para Europa)",
                                    "Ignorar encoding: `encoding='utf-8'`"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Preparar e converter coluna de data para datetime",
                                  "subSteps": [
                                    "Identifique a coluna de data com `df['date'].dtype`.",
                                    "Converta para datetime: `df['date'] = pd.to_datetime(df['date'])`.",
                                    "Defina como índice: `ts = df.set_index('date')`.",
                                    "Ordene por data: `ts = ts.sort_index()`.",
                                    "Resample se necessário para frequência diária: `ts = ts.asfreq('D')`."
                                  ],
                                  "verification": "Execute `ts.index.dtype` deve retornar 'datetime64[ns]' e `ts.index.is_monotonic_increasing` deve ser True.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "DataFrame carregado do step anterior"
                                  ],
                                  "tips": "Use `format='%Y-%m-%d'` em to_datetime para formatos não padrão.",
                                  "learningObjective": "Transformar dados em objetos de série temporal indexados corretamente por data.",
                                  "commonMistakes": [
                                    "Datas em formato string não convertidas",
                                    "Índice não único/duplicado",
                                    "Fuso horário ignorado (`utc=True`)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e realizar verificações iniciais na série temporal",
                                  "subSteps": [
                                    "Plote a série: `ts.plot()` para visualização.",
                                    "Verifique missing values: `ts.isnull().sum()`.",
                                    "Confira frequência: `ts.index.freq`.",
                                    "Teste slicing temporal: `ts['2023-01':'2023-03']`.",
                                    "Salve a série: `ts.to_csv('serie_temporal.csv')`."
                                  ],
                                  "verification": "Gráfico plotado corretamente, sem erros em slicing e missing values identificados.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Série temporal do step 3",
                                    "Matplotlib (instale se necessário: pip install matplotlib)"
                                  ],
                                  "tips": "Use `ts.resample('M').mean()` para agregações mensais iniciais.",
                                  "learningObjective": "Garantir integridade da série temporal para análises futuras.",
                                  "commonMistakes": [
                                    "Não ordenar índice",
                                    "Ignorar gaps em datas",
                                    "Plot sem figsize para melhor visualização"
                                  ]
                                }
                              ],
                              "practicalExample": "Carregue o dataset de temperaturas diárias de uma cidade de 'temperaturas.csv' (colunas: 'data' como '2023-01-01', 'temp'). Converta para ts = pd.read_csv('temperaturas.csv', parse_dates=['data']).set_index('data')['temp'].sort_index(). Plote para ver tendência sazonal.",
                              "finalVerifications": [
                                "Índice é datetime64 e monotonicamente crescente.",
                                "Sem duplicatas no índice: ts.index.duplicated().sum() == 0.",
                                "Dados plotados mostram estrutura temporal clara.",
                                "Slicing por data funciona: ts.loc['2023'].head().",
                                "Frequência inferida ou setada corretamente.",
                                "Nenhum erro em to_csv() para exportação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na conversão de datas (100% sucesso em to_datetime).",
                                "DataFrame convertido corretamente em TimeSeries (índice datetime).",
                                "Tratamento inicial de missings e ordenação aplicada.",
                                "Código reproduzível e comentado.",
                                "Visualização básica realizada e interpretada.",
                                "Tempo total dentro de 1 hora."
                              ],
                              "crossCurricularConnections": [
                                "Programação em Python (fundamentos de bibliotecas).",
                                "Estatística Descritiva (inspeção inicial de dados).",
                                "Matemática (conceitos de sequências indexadas).",
                                "Ciência de Dados (pipelines de ETL).",
                                "Visualização de Dados (matplotlib integration)."
                              ],
                              "realWorldApplication": "Em empresas de varejo, importar séries de vendas diárias para prever demanda; em meteorologia, carregar dados de precipitação para modelos climáticos; em finanças, converter históricos de ações em time series para análise de risco."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.1.5.1.3",
                            "name": "Realizar transformações básicas de dados",
                            "description": "Aplicar operações como resampling, interpolação de valores ausentes, logaritmização e diferenciação simples para limpar e padronizar a série temporal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar problemas na série temporal e preparar dados",
                                  "subSteps": [
                                    "Carregue a série temporal usando pandas.read_csv() ou similar.",
                                    "Converta a coluna de data para datetime index com pd.to_datetime().",
                                    "Visualize a série com plot() para identificar valores ausentes, outliers e padrões irregulares.",
                                    "Calcule estatísticas descritivas (mean, std, missing values) com describe() e isnull().sum().",
                                    "Defina o índice temporal como DatetimeIndex com set_index()."
                                  ],
                                  "verification": "Confirme que o DataFrame tem índice datetime, sem erros de parsing, e gere um plot inicial sem crashes.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python com pandas, numpy, matplotlib",
                                    "Dataset de série temporal exemplo (ex: dados de vendas diárias)"
                                  ],
                                  "tips": "Sempre comece visualizando os dados para guiar as transformações necessárias.",
                                  "learningObjective": "Entender a estrutura de séries temporais e diagnosticar issues comuns.",
                                  "commonMistakes": [
                                    "Ignorar formato de data incorreto levando a parsing falho",
                                    "Não setar índice temporal cedo",
                                    "Pular visualização inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar interpolação para valores ausentes",
                                  "subSteps": [
                                    "Identifique gaps com diff() no índice ou resample().count().",
                                    "Escolha método de interpolação (linear, time, spline) baseado no contexto.",
                                    "Aplique df.interpolate(method='linear') ou df.resample('D').interpolate().",
                                    "Compare valores originais e interpolados com plot side-by-side.",
                                    "Salve versão interpolada em nova coluna para backup."
                                  ],
                                  "verification": "Número de valores ausentes == 0 após interpolação, e plot mostra preenchimento suave sem saltos abruptos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Pandas Series/DataFrame com missing values",
                                    "Documentação pandas.interpolate"
                                  ],
                                  "tips": "Use 'time' para séries irregulares; evite para gaps grandes (>10% dos dados).",
                                  "learningObjective": "Dominar técnicas para lidar com missing data preservando tendências.",
                                  "commonMistakes": [
                                    "Usar método inadequado causando distorções",
                                    "Interpolação em dados não estacionários",
                                    "Não validar visualmente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar logaritmização para estabilizar variância",
                                  "subSteps": [
                                    "Verifique se variância aumenta com magnitude (teste visual com plot log-scale).",
                                    "Crie nova coluna com np.log(df['value']) ou df['log_value'] = np.log1p(df['value']).",
                                    "Trate valores <=0 com adição de constante pequena ou filtro.",
                                    "Compare ACF/PACF ou std antes/depois para confirmar estabilização.",
                                    "Plote original vs log-transformada."
                                  ],
                                  "verification": "Variância da log-série é mais constante (teste com rolling std), sem NaNs introduzidos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Numpy para np.log/np.log1p",
                                    "Matplotlib para comparações"
                                  ],
                                  "tips": "Use log1p para valores próximos de zero; inverta com np.exp para interpretação.",
                                  "learningObjective": "Aplicar transformações Box-Cox básicas para normalizar dados.",
                                  "commonMistakes": [
                                    "Log de zeros/negativos sem tratamento",
                                    "Não comparar antes/depois",
                                    "Ignorar heterocedasticidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar resampling para padronizar frequência",
                                  "subSteps": [
                                    "Defina frequência alvo (ex: 'D' para diário, 'M' para mensal) com freq='D'.",
                                    "Aplique resample('D').mean() ou .sum() baseado no agregado necessário.",
                                    "Lide com bordas usando closed='right' ou label='right'.",
                                    "Preencha novos NaNs com interpolate() se necessário.",
                                    "Valide comprimento e frequência com df.index.freq."
                                  ],
                                  "verification": "Índice tem frequência uniforme (df.index.freq não None), sem gaps excessivos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Pandas resample docs",
                                    "Série irregular exemplo"
                                  ],
                                  "tips": "Escolha método de agregação que preserve o significado (mean para médias, sum para totais).",
                                  "learningObjective": "Padronizar séries para análises consistentes em múltiplas frequências.",
                                  "commonMistakes": [
                                    "Agregação errada alterando escala",
                                    "Não especificar freq levando a erros",
                                    "Ignorar aliasing em altas frequências"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar diferenciação simples para remover tendência",
                                  "subSteps": [
                                    "Escolha ordem (1 para primeira diferença) baseado em plot de tendência.",
                                    "Compute df['diff'] = df['value'].diff(1) ou .diff(periods=1).",
                                    "Drop NaN inicial com dropna().",
                                    "Plote original, cumulativa e diferenciada para verificar estacionariedade.",
                                    "Teste ADF qualitativamente ou com statsmodels.adfuller()."
                                  ],
                                  "verification": "Plot da série diferenciada oscila em torno de zero sem tendência clara; p-value ADF <0.05 opcional.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Statsmodels para ADF test",
                                    "Matplotlib/Seaborn"
                                  ],
                                  "tips": "Diferencie apenas se tendência forte; múltiplas diffs para sazonalidade.",
                                  "learningObjective": "Tornar séries estacionárias para modelagem posterior.",
                                  "commonMistakes": [
                                    "Sobrediferenciação causando ruído",
                                    "Não dropar NaNs",
                                    "Ignorar interpretação das diferenças"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um dataset de preços de ações diários (ex: AAPL.csv), identifique 5% de missing trades, interpole linearmente, log-transforme para estabilizar volatilidade, resample para semanal com mean(), e diferencie para analisar retornos estacionários. Plote antes/depois para relatório.",
                              "finalVerifications": [
                                "Série final sem valores ausentes ou NaNs.",
                                "Índice temporal uniforme e freq definida.",
                                "Variância estabilizada pós-log (rolling std constante).",
                                "Tendência removida pós-diferenciação (plot centrado em zero).",
                                "Todos plots gerados e salvos comparando etapas.",
                                "Estatísticas descritivas melhoradas (menor std relativa)."
                              ],
                              "assessmentCriteria": [
                                "Precisão das transformações: sem erros de sintaxe ou lógicos.",
                                "Escolha adequada de métodos baseada em diagnóstico inicial.",
                                "Visualizações claras e interpretativas em todas etapas.",
                                "Código limpo, comentado e reproduzível.",
                                "Validações quantitativas (ex: missing count==0, freq correta).",
                                "Interpretação correta dos impactos (ex: por que log?)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções logarítmicas e derivadas (diferenciação).",
                                "Programação: Manipulação de dados em Python/pandas.",
                                "Estatística: Testes de estacionariedade e heterocedasticidade.",
                                "Visualização de Dados: Gráficos temporais com matplotlib.",
                                "Finanças/Economia: Aplicações em séries financeiras."
                              ],
                              "realWorldApplication": "Em previsão de demanda de varejo, transforme vendas diárias irregulares (com feriados missing) via interpolação, log para variância, resample mensal e diferenciação para modelar crescimento sazonal, melhorando precisão de forecasts em 20-30%."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.5.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.5.2",
                        "name": "Visualização Básica de Séries Temporais",
                        "description": "Aplicar técnicas gráficas fundamentais para observar a estrutura temporal dos dados e detectar anomalias iniciais.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.2.1",
                            "name": "Plotar gráficos de linha de séries temporais",
                            "description": "Criar gráficos de linha simples e múltiplos painéis usando matplotlib/seaborn em Python ou ggplot2 em R para visualizar evolução temporal e zoom em períodos específicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente e preparar dados de série temporal",
                                  "subSteps": [
                                    "Instalar e importar bibliotecas necessárias: pandas, matplotlib/seaborn para Python ou ggplot2/tidyr para R.",
                                    "Carregar um dataset de exemplo com dados temporais (ex: CSV com colunas de data e valor).",
                                    "Converter a coluna de data em índice datetime usando pd.to_datetime() ou as.Date().",
                                    "Verificar a estrutura dos dados com info() ou head() e tratar valores ausentes.",
                                    "Resample os dados se necessário para frequência regular (diária, mensal)."
                                  ],
                                  "verification": "Dados carregados com índice datetime válido e sem erros de parsing.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python ou R instalado",
                                    "Bibliotecas: pandas, matplotlib, seaborn ou ggplot2",
                                    "Dataset exemplo (ex: air_passengers.csv)"
                                  ],
                                  "tips": "Sempre use parse_dates=True no read_csv para agilizar a conversão.",
                                  "learningObjective": "Preparar dados temporais limpos e indexados para plotagem.",
                                  "commonMistakes": [
                                    "Ignorar formato de data inconsistente",
                                    "Não converter para datetime",
                                    "Deixar NaNs sem tratamento"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Plotar gráfico de linha simples para uma série temporal",
                                  "subSteps": [
                                    "Selecionar a coluna de valores da série.",
                                    "Usar plt.plot(df.index, df['valor']) em Python ou ggplot(df, aes(data, valor)) + geom_line() em R.",
                                    "Adicionar rótulos aos eixos: plt.xlabel('Data'), plt.ylabel('Valor'), plt.title('Série Temporal').",
                                    "Rotacionar rótulos do eixo x para melhor legibilidade com plt.xticks(rotation=45).",
                                    "Exibir o gráfico com plt.show() ou print em R."
                                  ],
                                  "verification": "Gráfico de linha exibido com eixo temporal horizontal e evolução visível.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ambiente Python/R configurado",
                                    "Dados preparados do step 1"
                                  ],
                                  "tips": "Use figsize=(12,6) para gráficos mais amplos em séries longas.",
                                  "learningObjective": "Criar visualização básica de evolução temporal em uma única série.",
                                  "commonMistakes": [
                                    "Eixo x numérico em vez de data",
                                    "Título e labels ausentes",
                                    "Gráfico muito apertado sem ajustes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Criar gráficos com múltiplas linhas ou painéis",
                                  "subSteps": [
                                    "Preparar dados com múltiplas colunas ou usar melt para formato longo.",
                                    "Plotar múltiplas linhas: plt.plot para cada ou sns.lineplot com hue em seaborn.",
                                    "Para painéis: usar FacetGrid em seaborn ou facet_wrap em ggplot2.",
                                    "Adicionar legenda com plt.legend() ou automaticamente via hue.",
                                    "Ajustar cores e estilos para diferenciar séries."
                                  ],
                                  "verification": "Gráfico mostra 2+ séries ou painéis com legendas claras.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Dados com múltiplas séries",
                                    "Bibliotecas seaborn ou ggplot2"
                                  ],
                                  "tips": "Use palette='Set1' em seaborn para cores distintas.",
                                  "learningObjective": "Visualizar comparações entre múltiplas séries temporais.",
                                  "commonMistakes": [
                                    "Linhas sobrepostas sem legenda",
                                    "Formato de dados errado para facet",
                                    "Cores idênticas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar zoom, personalizações e salvar o gráfico",
                                  "subSteps": [
                                    "Filtrar dados para período específico: df.loc['2020-01':'2020-06'].",
                                    "Aplicar zoom com xlim() em matplotlib ou scale_x_date em ggplot2.",
                                    "Adicionar grid, média móvel ou anotações com plt.axvline().",
                                    "Personalizar tema: sns.set_style('whitegrid') ou theme_minimal().",
                                    "Salvar como PNG/PDF: plt.savefig('grafico.png', dpi=300)."
                                  ],
                                  "verification": "Gráfico salvo com zoom aplicado e elementos personalizados visíveis.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Gráficos dos steps anteriores",
                                    "Editor de código"
                                  ],
                                  "tips": "Teste zoom iterativamente para evitar distorções de escala.",
                                  "learningObjective": "Refinar visualizações para foco em períodos chave e exportação profissional.",
                                  "commonMistakes": [
                                    "Zoom cortando dados importantes",
                                    "Resolução baixa no savefig",
                                    "Esquecer grid para legibilidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Carregue dados de temperatura diária de uma cidade (ex: dataset de Seattle de 2010-2020). Plote a linha completa, adicione linha de temperatura média em painéis mensais e zoom no verão de 2015, salvando como 'temperatura_seattle.png'.",
                              "finalVerifications": [
                                "Eixo temporal formatado corretamente com datas legíveis.",
                                "Linhas contínuas sem quebras abruptas (exceto por dados reais).",
                                "Zoom aplicado sem perda de contexto geral.",
                                "Legendas e títulos presentes e descritivos.",
                                "Gráfico salvo em alta qualidade.",
                                "Múltiplas séries comparáveis visualmente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na indexação temporal e escalas dos eixos.",
                                "Clareza visual: legibilidade de labels e ausência de clutter.",
                                "Correta representação de múltiplas séries/painéis.",
                                "Uso efetivo de zoom para destacar padrões.",
                                "Profissionalismo: temas, grids e resolução.",
                                "Código reproduzível sem erros."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Interpretação de funções contínuas e tendências.",
                                "Programação: Manipulação de dados e automação de plots.",
                                "Economia/Finanças: Análise de tendências de mercado.",
                                "Ciências Ambientais: Visualização de dados climáticos.",
                                "Estatística: Identificação de sazonalidade e ciclos."
                              ],
                              "realWorldApplication": "Em finanças para rastrear preços de ações e detectar tendências; em meteorologia para monitorar variações climáticas; em epidemiologia para plotar casos de doenças ao longo do tempo e focar em surtos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.5.1.3"
                            ]
                          },
                          {
                            "id": "10.1.1.5.2.2",
                            "name": "Gerar gráficos de autocorrelação (ACF)",
                            "description": "Construir e interpretar gráficos de função de autocorrelação (ACF) e autocorrelação parcial (PACF) para avaliar dependências temporais nos lags.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambiente e carregar dados da série temporal",
                                  "subSteps": [
                                    "Instale as bibliotecas necessárias: pandas, matplotlib e statsmodels via pip.",
                                    "Importe as bibliotecas: import pandas as pd; import matplotlib.pyplot as plt; from statsmodels.graphics.tsaplots import plot_acf, plot_pacf; from statsmodels.tsa.stattools import acf, pacf.",
                                    "Carregue um dataset de série temporal, como dados de vendas mensais de um CSV.",
                                    "Converta a coluna de datas em índice datetime e defina a frequência (ex: monthly).",
                                    "Visualize os primeiros valores e plote a série para inspeção inicial."
                                  ],
                                  "verification": "Confirme que os dados carregaram sem erros e o plot inicial da série aparece corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python 3.8+",
                                    "Bibliotecas: pandas, matplotlib, statsmodels",
                                    "Dataset de série temporal (ex: AirPassengers.csv)"
                                  ],
                                  "tips": "Use pd.read_csv com parse_dates=True para facilitar o parsing de datas.",
                                  "learningObjective": "Preparar um ambiente Python funcional para análise de séries temporais.",
                                  "commonMistakes": [
                                    "Esquecer de definir o índice datetime",
                                    "Não instalar statsmodels",
                                    "Ignorar NaNs nos dados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar e visualizar o gráfico de Autocorrelação (ACF)",
                                  "subSteps": [
                                    "Defina o número de lags a analisar (ex: lags=40).",
                                    "Use plot_acf(série, lags=40, ax=plt.gca()) para plotar o ACF.",
                                    "Adicione título, labels e grid ao gráfico com plt.title(), plt.xlabel(), etc.",
                                    "Calcule os valores ACF manualmente com acf(série, nlags=40) para verificação.",
                                    "Salve o gráfico como PNG com plt.savefig('acf_plot.png')."
                                  ],
                                  "verification": "O gráfico ACF mostra barras de autocorrelação decaindo gradualmente com bandas de confiança azuis.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código Python do Step 1",
                                    "Jupyter Notebook ou script .py"
                                  ],
                                  "tips": "Ajuste lags baseado no tamanho da série (geralmente 1/4 do comprimento).",
                                  "learningObjective": "Construir visualizações ACF precisas para detectar dependências em lags.",
                                  "commonMistakes": [
                                    "Não plotar bandas de confiança",
                                    "Usar lags excessivos causando ruído",
                                    "Esquecer plt.show()"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar e visualizar o gráfico de Autocorrelação Parcial (PACF)",
                                  "subSteps": [
                                    "Use plot_pacf(série, lags=40, ax=plt.gca()) para plotar o PACF.",
                                    "Personalize o gráfico similar ao ACF: título 'PACF Plot', labels e grid.",
                                    "Calcule valores PACF com pacf(série, nlags=40).",
                                    "Compare visualmente ACF e PACF em subplots usando plt.subplot.",
                                    "Salve o gráfico combinado."
                                  ],
                                  "verification": "Gráfico PACF exibe corte abrupto após poucos lags para séries AR.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código dos steps anteriores"
                                  ],
                                  "tips": "PACF é útil para ordem AR em ARIMA; procure spikes significativos iniciais.",
                                  "learningObjective": "Diferenciar e gerar ACF vs PACF para modelagem de séries temporais.",
                                  "commonMistakes": [
                                    "Confundir ACF com PACF",
                                    "Ignorar normalização dos dados",
                                    "Lags inconsistentes entre plots"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar os gráficos ACF e PACF",
                                  "subSteps": [
                                    "Identifique lags significativos fora das bandas de confiança (95%).",
                                    "Para ACF: decay lento sugere MA; corte abrupto sugere AR.",
                                    "Para PACF: spikes iniciais definem ordem p em AR(p).",
                                    "Anote padrões: sazonalidade (picos repetitivos), tendência.",
                                    "Documente insights em um relatório Markdown ou notebook cell."
                                  ],
                                  "verification": "Relatório lista pelo menos 3 lags significativos e hipótese de modelo (ex: ARIMA(1,1,1)).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Gráficos gerados",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Use alpha=0.05 para bandas; teste estacionariedade com ADF se ACF não decay.",
                                  "learningObjective": "Interpretar padrões ACF/PACF para informar modelagem de séries temporais.",
                                  "commonMistakes": [
                                    "Interpretar todas barras como significativas",
                                    "Ignorar contexto da série (ex: não estacionária)",
                                    "Não considerar sazonalidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Carregue o dataset clássico AirPassengers (passageiros aéreos mensais 1949-1960). Gere ACF e PACF com lags=24. Interprete: ACF decay lento indica MA, picos sazonais em 12 lags sugerem componente sazonal SARIMA.",
                              "finalVerifications": [
                                "Gráficos ACF e PACF gerados e salvos sem erros.",
                                "Lags significativos identificados corretamente (ex: fora de ±1.96/sqrt(n)).",
                                "Interpretação alinhada com teoria ARIMA (p,d,q).",
                                "Código reproduzível em novo ambiente.",
                                "Relatório de insights escrito.",
                                "Teste com dataset diferente confirma resultados."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica no código (sem erros de sintaxe ou import).",
                                "Qualidade visual dos gráficos (labels, títulos, escalas).",
                                "Correção na identificação de lags significativos.",
                                "Profundidade da interpretação (ligação com modelos ARIMA).",
                                "Eficiência: tempo dentro do estimado e código limpo.",
                                "Criatividade: uso de subplots ou customizações extras."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Inferência sobre correlações e estacionariedade.",
                                "Programação: Manipulação de dados com pandas e plotting.",
                                "Matemática: Funções de autocorrelação e processos estocásticos.",
                                "Ciência de Dados: Pré-processamento para machine learning em time series."
                              ],
                              "realWorldApplication": "Em finanças, gerar ACF/PACF de retornos diários de ações para detectar autocorrelações, auxiliando na modelagem ARIMA para previsão de preços e gerenciamento de risco em trading algorítmico."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.5.2.1"
                            ]
                          },
                          {
                            "id": "10.1.1.5.2.3",
                            "name": "Visualizar decomposição de séries temporais",
                            "description": "Usar decomposição aditiva ou multiplicativa para separar tendência, sazonalidade e resíduo em gráficos separados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos de Decomposição Aditiva e Multiplicativa",
                                  "subSteps": [
                                    "Estude a fórmula da decomposição aditiva: Y(t) = Tendência + Sazonalidade + Resíduo",
                                    "Estude a fórmula da decomposição multiplicativa: Y(t) = Tendência * Sazonalidade * Resíduo",
                                    "Identifique quando usar aditiva (variações constantes) vs. multiplicativa (variações proporcionais)",
                                    "Revise exemplos gráficos de cada componente: tendência (longo prazo), sazonalidade (padrões repetitivos), resíduo (ruído aleatório)",
                                    "Compare os dois modelos com séries temporais reais simples"
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre aditiva e multiplicativa com um exemplo",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de statsmodels ou tutoriais online sobre decomposição STL",
                                    "Notebook Jupyter ou papel e caneta para esboços"
                                  ],
                                  "tips": "Comece com séries sem sazonalidade forte para entender tendência e resíduo primeiro",
                                  "learningObjective": "Diferenciar e explicar os componentes de uma série temporal e os modelos de decomposição",
                                  "commonMistakes": [
                                    "Confundir sazonalidade com tendência",
                                    "Ignorar a não-estacionariedade dos dados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar e Carregar Dados da Série Temporal",
                                  "subSteps": [
                                    "Colete ou baixe um dataset de série temporal (ex: AirPassengers ou vendas mensais)",
                                    "Carregue os dados em Python usando pandas: pd.read_csv()",
                                    "Converta a coluna de data para datetime e defina como índice: pd.to_datetime() e set_index()",
                                    "Plote a série original para inspeção visual inicial",
                                    "Verifique stationariedade básica e trate missing values se necessário"
                                  ],
                                  "verification": "Execute o código e confirme que o gráfico da série original é exibido corretamente sem erros",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python com pandas e matplotlib instalados",
                                    "Dataset exemplo: AirPassengers do R ou CSV equivalente"
                                  ],
                                  "tips": "Use freq='M' para dados mensais ao converter índice para melhor indexação temporal",
                                  "learningObjective": "Preparar dados de série temporal para análise de decomposição",
                                  "commonMistakes": [
                                    "Índice não convertido para datetime",
                                    "Ignorar frequência dos dados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Decomposição Aditiva ou Multiplicativa",
                                  "subSteps": [
                                    "Instale/importe statsmodels: from statsmodels.tsa.seasonal import seasonal_decompose",
                                    "Escolha o modelo (additive ou multiplicative) baseado na variação dos dados",
                                    "Execute seasonal_decompose(série, model='additive', period=12) para dados mensais",
                                    "Armazene o resultado: decomposição = seasonal_decompose(...)",
                                    "Inspecione os componentes acessando .trend, .seasonal, .resid"
                                  ],
                                  "verification": "Acesse e plote um componente (ex: decomposição.trend) para confirmar extração sem NaNs excessivos",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Biblioteca statsmodels",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Use period igual ao ciclo sazonal (12 para mensal anual); teste ambos os modelos se incerto",
                                  "learningObjective": "Executar decomposição de séries temporais usando ferramentas padrão",
                                  "commonMistakes": [
                                    "Period incorreto levando a sazonalidade errada",
                                    "Não tratar NaNs nos extremos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Visualizar Componentes em Gráficos Separados",
                                  "subSteps": [
                                    "Crie figura com subplots: fig, axes = plt.subplots(4,1, figsize=(10,8))",
                                    "Plote original: série.plot(ax=axes[0])",
                                    "Plote tendência: decomposição.trend.plot(ax=axes[1])",
                                    "Plote sazonalidade: decomposição.seasonal.plot(ax=axes[2])",
                                    "Plote resíduo: decomposição.resid.plot(ax=axes[3]); plt.tight_layout(); plt.show()"
                                  ],
                                  "verification": "Os quatro gráficos (original, tendência, sazonal, resíduo) são exibidos claramente e alinhados",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Matplotlib ou seaborn para plotting"
                                  ],
                                  "tips": "Ajuste figsize para melhor visualização; adicione títulos e labels aos eixos",
                                  "learningObjective": "Gerar visualizações claras e separadas dos componentes de decomposição",
                                  "commonMistakes": [
                                    "Subplots desalinhados",
                                    "Escala inadequada nos eixos"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar e Validar a Decomposição",
                                  "subSteps": [
                                    "Analise a tendência: crescente/decrescente? Suavidade?",
                                    "Examine sazonalidade: amplitude e padrão repetitivo?",
                                    "Verifique resíduo: aleatório? Próximo de ruído branco?",
                                    "Compare soma dos componentes com original (para aditiva)",
                                    "Teste modelo alternativo se resíduo não for estacionário"
                                  ],
                                  "verification": "Escreva um parágrafo resumindo insights de cada componente",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Gráficos gerados",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use ACF plot no resíduo para validar aleatoriedade",
                                  "learningObjective": "Interpretar visualmente os componentes e validar a decomposição",
                                  "commonMistakes": [
                                    "Interpretar resíduo como sinal útil",
                                    "Ignorar discrepâncias nos extremos"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando o dataset AirPassengers (passageiros aéreos mensais de 1949-1960), aplique decomposição multiplicativa (period=12). Os gráficos revelarão tendência crescente, sazonalidade anual de verão e resíduo aleatório, ajudando a entender picos de viagem.",
                              "finalVerifications": [
                                "Gráficos mostram separação clara de tendência, sazonalidade e resíduo",
                                "Soma (aditiva) ou produto (multiplicativa) reconstrói a série original",
                                "Resíduo aparece aleatório sem padrões óbvios",
                                "Escolha de modelo justificada pela variação dos dados",
                                "Código executa sem erros e é reproduzível",
                                "Insights escritos sobre cada componente"
                              ],
                              "assessmentCriteria": [
                                "Precisão na aplicação da decomposição (modelo correto e period)",
                                "Qualidade visual dos gráficos (legíveis, rotulados, escalas adequadas)",
                                "Correta interpretação dos componentes",
                                "Tratamento adequado de dados (índice temporal, missing values)",
                                "Validação do resíduo como ruído",
                                "Código limpo e comentado"
                              ],
                              "crossCurricularConnections": [
                                "Economia: Análise de vendas e previsão de demanda",
                                "Finanças: Decomposição de retornos de ações para identificar ciclos",
                                "Ciência do Clima: Separação de tendências globais de variações sazonais em temperaturas",
                                "Epidemiologia: Análise de casos de doenças com sazonalidade"
                              ],
                              "realWorldApplication": "Em empresas de varejo, decompor vendas mensais identifica tendência de crescimento, picos sazonais de Natal e anomalias residuais para ajustar estoques e previsões de demanda."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.5.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.5.3",
                        "name": "Identificação Inicial de Padrões em Séries Temporais",
                        "description": "Reconhecer padrões como tendência, sazonalidade, ciclicidade e estacionariedade por meio de inspeção visual e testes preliminares.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.3.1",
                            "name": "Detectar tendência e sazonalidade visualmente",
                            "description": "Analisar gráficos para identificar componentes de tendência linear ou não linear, padrões sazonais repetitivos e variações irregulares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e Visualizar a Série Temporal",
                                  "subSteps": [
                                    "Colete dados de série temporal relevantes (ex: vendas mensais ao longo de 5 anos).",
                                    "Carregue os dados em uma ferramenta de visualização como Excel, Python (Matplotlib/Seaborn) ou R.",
                                    "Plote o gráfico de linha simples com tempo no eixo x e valores no eixo y.",
                                    "Ajuste escalas e rótulos para clareza visual.",
                                    "Observe o gráfico geral por 1-2 minutos sem análise prévia."
                                  ],
                                  "verification": "Gráfico plotado corretamente com eixos rotulados e dados visíveis sem distorções.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Dados de série temporal (CSV ou Excel)",
                                    "Software: Excel, Python (Jupyter Notebook com pandas e matplotlib), ou RStudio"
                                  ],
                                  "tips": "Use cores contrastantes para linhas e adicione grade para facilitar leitura.",
                                  "learningObjective": "Dominar a visualização inicial de séries temporais para inspeção qualitativa.",
                                  "commonMistakes": [
                                    "Escalas inadequadas que distorcem o padrão",
                                    "Ignorar outliers óbvios no plot inicial",
                                    "Plotar sem rótulos claros"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Componentes de Tendência",
                                  "subSteps": [
                                    "Procure por direção geral de longo prazo: crescente, decrescente ou estável.",
                                    "Avalie se a tendência é linear (reta suave) ou não linear (curva, exponencial).",
                                    "Desenhe uma linha suave à mão ou use suavização móvel para delinear a tendência.",
                                    "Compare com médias móveis de 12 períodos para confirmar.",
                                    "Anote a força da tendência (forte, fraca, ausente)."
                                  ],
                                  "verification": "Descrição escrita da tendência com justificativa baseada no gráfico e linha desenhada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráfico da série temporal do Step 1",
                                    "Ferramentas de suavização: Excel (média móvel), Python (rolling mean)"
                                  ],
                                  "tips": "Foque em movimentos de longo prazo ignorando flutuações curtas.",
                                  "learningObjective": "Reconhecer e classificar tendências lineares e não lineares visualmente.",
                                  "commonMistakes": [
                                    "Confundir sazonalidade com tendência",
                                    "Ignorar quebras abruptas na tendência",
                                    "Sobrepor ruído à tendência real"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detectar Padrões Sazonais Repetitivos",
                                  "subSteps": [
                                    "Identifique ciclos repetitivos em intervalos fixos (ex: mensal, anual).",
                                    "Sobreponha anos ou use subplots para comparar padrões ao longo do tempo.",
                                    "Marque picos e vales recorrentes no gráfico.",
                                    "Calcule amplitude sazonal aproximada (máx - mín em ciclo).",
                                    "Confirme repetição em pelo menos 3-4 ciclos."
                                  ],
                                  "verification": "Ciclos sazonais marcados no gráfico com anotações de repetição.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Gráfico do Step 1",
                                    "Ferramentas: Python (seasonal_decompose) ou Excel (gráficos sobrepostos)"
                                  ],
                                  "tips": "Zoom em 2-3 anos para isolar sazonalidade sem tendência dominando.",
                                  "learningObjective": "Identificar e quantificar visualmente padrões sazonais cíclicos.",
                                  "commonMistakes": [
                                    "Confundir tendência gradual com sazonalidade",
                                    "Ignorar variações de amplitude ao longo do tempo",
                                    "Assumir sazonalidade sem múltiplos ciclos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Variações Irregulares e Ruído",
                                  "subSteps": [
                                    "Remova mentalmente ou graficamente tendência e sazonalidade para isolar resíduos.",
                                    "Identifique outliers, choques ou variações aleatórias nos resíduos.",
                                    "Classifique irregularidades: transitórias (pontuais) vs. persistentes.",
                                    "Avalie volatilidade geral (alta/baixa dispersão).",
                                    "Documente decomposição completa: Tendência + Sazonal + Irregular."
                                  ],
                                  "verification": "Gráfico de resíduos sem tendência/sazonalidade clara e lista de irregularidades identificadas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráficos anteriores",
                                    "Ferramentas para decomposição: Python (statsmodels.tsa.seasonal_decompose)"
                                  ],
                                  "tips": "Use boxplots de resíduos para detectar outliers quantitativamente.",
                                  "learningObjective": "Diferenciar componentes regulares de variações irregulares em séries temporais.",
                                  "commonMistakes": [
                                    "Atribuir ruído a sazonalidade",
                                    "Subestimar impacto de outliers",
                                    "Não validar decomposição visual"
                                  ]
                                }
                              ],
                              "practicalExample": "Analise o gráfico de vendas mensais de sorvetes de uma loja de 2018-2023: identifique tendência crescente linear devido a expansão, sazonalidade anual com picos no verão, e irregularidades como queda em 2020 por pandemia.",
                              "finalVerifications": [
                                "Pode decompor corretamente um gráfico de série temporal em tendência, sazonalidade e irregularidade.",
                                "Identifica tendências lineares vs. não lineares em exemplos novos.",
                                "Detecta ciclos sazonais em pelo menos 80% dos casos com repetição visual.",
                                "Reconhece outliers e ruído sem confundir com padrões regulares.",
                                "Documenta análise com anotações claras em gráficos.",
                                "Aplica suavização visual para confirmar componentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de tendência (linear/não linear): 0-100%.",
                                "Correta detecção de padrões sazonais repetitivos em múltiplos ciclos.",
                                "Diferenciação clara entre componentes regulares e irregulares.",
                                "Uso efetivo de ferramentas visuais (suavização, subplots).",
                                "Qualidade das anotações e justificativas escritas.",
                                "Tempo de análise eficiente sem perda de precisão."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Regressão linear e funções não lineares.",
                                "Economia: Análise de ciclos econômicos e previsão de demanda.",
                                "Ciência Ambiental: Séries de temperatura e padrões climáticos.",
                                "Programação: Visualização de dados com Python/R.",
                                "Negócios: Planejamento de estoque baseado em sazonalidade."
                              ],
                              "realWorldApplication": "Em marketing, detectar sazonalidade em vendas para otimizar campanhas; em finanças, identificar tendências em ações para investimentos; em meteorologia, analisar séries de precipitação para previsões agrícolas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.5.2.3"
                            ]
                          },
                          {
                            "id": "10.1.1.5.3.2",
                            "name": "Avaliar estacionariedade inicial",
                            "description": "Verificar visualmente constantes de média e variância ao longo do tempo e interpretar ACF para sinais de não-estacionariedade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e Plotar a Série Temporal",
                                  "subSteps": [
                                    "Carregue o dataset de série temporal usando pandas (ex: pd.read_csv()).",
                                    "Converta a coluna de tempo para datetime e defina como índice.",
                                    "Gere um gráfico de linha da série temporal com matplotlib ou seaborn.",
                                    "Adicione rótulos aos eixos (tempo no x, valor no y) e título.",
                                    "Salve ou exiba o plot para inspeção inicial."
                                  ],
                                  "verification": "Confirme que o gráfico da série temporal é exibido corretamente sem erros de indexação ou formatação.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Python com pandas, matplotlib; dataset de exemplo (ex: AirPassengers.csv)",
                                  "tips": "Use plt.figure(figsize=(12,6)) para visualização clara em séries longas.",
                                  "learningObjective": "Dominar o carregamento e visualização básica de séries temporais.",
                                  "commonMistakes": "Ignorar a conversão para datetime, levando a eixos de tempo incorretos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Visualmente Constância de Média e Variância",
                                  "subSteps": [
                                    "Inspecione o plot para detectar tendências crescentes/decrescentes na média.",
                                    "Verifique variações na dispersão (variância) ao longo do tempo (ex: funil ou explosão).",
                                    "Calcule médias móveis (rolling mean) com janela de 12 períodos e plote sobre a série.",
                                    "Calcule desvios móveis (rolling std) e plote para variância.",
                                    "Anotar observações qualitativas em um notebook ou log."
                                  ],
                                  "verification": "Identifique e documente pelo menos uma evidência visual de constância ou violação em média/variância.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Python com pandas (rolling()), matplotlib",
                                  "tips": "Use diferentes janelas de rolling (ex: 12 para dados mensais) para sensibilidade.",
                                  "learningObjective": "Desenvolver intuição visual para estacionariedade via plots de média e variância móveis.",
                                  "commonMistakes": "Confundir sazonalidade com tendência; foque em mudanças lineares suaves."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular e Plotar a Função de Autocorrelação (ACF)",
                                  "subSteps": [
                                    "Importe statsmodels.tsa.stattools.acf e statsmodels.graphics.tsaplots.plot_acf.",
                                    "Compute ACF com lags=40 (ajuste ao tamanho da série).",
                                    "Gere o plot ACF com confiança de 95%.",
                                    "Marque lags significativos (fora das bandas de confiança).",
                                    "Salve o plot ACF para referência."
                                  ],
                                  "verification": "O plot ACF é gerado mostrando correlações decaindo lentamente ou oscilando.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Python com statsmodels",
                                  "tips": "Aumente lags para séries longas; normalize=False para ACF bruta.",
                                  "learningObjective": "Computar ACF corretamente e gerar visualizações padrão.",
                                  "commonMistakes": "Usar lags insuficientes, mascarando decaimento lento."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar ACF e Concluir sobre Estacionariedade",
                                  "subSteps": [
                                    "Observe decaimento lento na ACF (sinal de não-estacionariedade por tendência).",
                                    "Detecte picos persistentes em lags altos (não-estacionariedade).",
                                    "Compare com plots de média/variância para confirmação.",
                                    "Classifique: estacionária (decaimento rápido dentro de bandas) ou não.",
                                    "Registre conclusão com evidências em relatório curto."
                                  ],
                                  "verification": "Produza um resumo escrito justificando estacionariedade ou não com referências aos plots.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Plots gerados nos steps anteriores; notebook Jupyter",
                                  "tips": "ACF decaindo sinusoidal sugere sazonalidade; lento e suave indica tendência.",
                                  "learningObjective": "Interpretar padrões ACF para diagnóstico de estacionariedade.",
                                  "commonMistakes": "Interpretar picos iniciais como não-estacionariedade (normal em autocorrelação)."
                                }
                              ],
                              "practicalExample": "Usando dados de passageiros aéreos (AirPassengers.csv): Plote a série mostrando tendência crescente e variância expansiva; ACF decai lentamente, confirmando não-estacionariedade inicial.",
                              "finalVerifications": [
                                "Gráficos de série, rolling mean/std e ACF foram gerados sem erros.",
                                "Evidências visuais de média/variância constantes ou não foram documentadas.",
                                "Interpretação ACF identifica decaimento lento ou picos persistentes corretamente.",
                                "Conclusão sobre estacionariedade é justificada com múltiplas evidências.",
                                "Relatório resume achados de forma clara e concisa."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção visual de tendências e heteroscedasticidade (80%+ acurácia).",
                                "Correta computação e plotagem de ACF com lags apropriados.",
                                "Interpretação ACF alinhada com teoria (decaimento lento = não-estacionária).",
                                "Integração coerente de múltiplas visualizações na conclusão.",
                                "Documentação completa com anotações e justificativas.",
                                "Eficiência temporal dentro dos estimates."
                              ],
                              "crossCurricularConnections": [
                                "Economia: Análise de séries de PIB ou inflação para modelagem econométrica.",
                                "Física: Séries de sinais em processamento de sinais (ex: detecção de drifts).",
                                "Engenharia: Monitoramento de sensores IoT para detecção de falhas em processos.",
                                "Biologia: Séries genéticas ou populacionais para modelagem ecológica."
                              ],
                              "realWorldApplication": "Em finanças, avaliar estacionariedade inicial de retornos de ações antes de ARIMA para previsões precisas; em meteorologia, detectar drifts em temperaturas para alertas climáticos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.5.3.1"
                            ]
                          },
                          {
                            "id": "10.1.1.5.3.3",
                            "name": "Classificar tipos de séries temporais",
                            "description": "Categorizar séries como estacionárias, não estacionárias ou sazonais com base em visualizações e discutir implicações para métodos de previsão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Tipos de Séries Temporais",
                                  "subSteps": [
                                    "Defina série temporal estacionária: média e variância constantes ao longo do tempo.",
                                    "Defina série temporal não estacionária: presença de tendência ou variância mudando.",
                                    "Defina série temporal sazonal: padrões repetitivos em intervalos regulares.",
                                    "Estude exemplos gráficos de cada tipo para reconhecimento visual.",
                                    "Compare e contraste as características de cada categoria."
                                  ],
                                  "verification": "Resuma as definições em suas próprias palavras e identifique diferenças chave em um diagrama comparativo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação sobre séries temporais (ex: livros de Hyndman ou tutoriais online)",
                                    "Gráficos de exemplo de séries estacionárias, não estacionárias e sazonais"
                                  ],
                                  "tips": "Use analogias como 'estacionária é como um rio calmo sem corrente forte' para fixar conceitos.",
                                  "learningObjective": "Dominar definições e características visuais dos três tipos principais de séries temporais.",
                                  "commonMistakes": [
                                    "Confundir sazonalidade com tendência de longo prazo",
                                    "Ignorar variância na definição de estacionariedade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar e Visualizar Dados de Séries Temporais",
                                  "subSteps": [
                                    "Carregue um conjunto de dados de série temporal em Python (usando pandas).",
                                    "Plote a série temporal básica com matplotlib ou seaborn.",
                                    "Adicione linhas de tendência e médias móveis para destacar padrões.",
                                    "Examine visualmente picos, vales e repetições.",
                                    "Calcule estatísticas descritivas básicas (média, variância) em janelas deslizantes."
                                  ],
                                  "verification": "Gere e salve um gráfico anotado mostrando padrões evidentes na série.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com pandas, matplotlib",
                                    "Datasets de exemplo: AirPassengers ou vendas mensais"
                                  ],
                                  "tips": "Aumente o tamanho da figura para melhor visualização e use cores contrastantes para tendências.",
                                  "learningObjective": "Adquirir habilidades para plotar e inspecionar visualmente séries temporais.",
                                  "commonMistakes": [
                                    "Escala inadequada no eixo y ocultando padrões",
                                    "Não tratar dados ausentes antes da plotagem"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Classificar a Série Temporal com Base em Visualizações",
                                  "subSteps": [
                                    "Analise o gráfico: verifique constância de média e variância para estacionariedade.",
                                    "Identifique tendências crescentes/decrescentes ou mudanças abruptas para não estacionariedade.",
                                    "Procure ciclos repetitivos anuais/mensais para sazonalidade.",
                                    "Aplique testes qualitativos iniciais (ex: rolamento de estatísticas).",
                                    "Registre a classificação com justificativa baseada em evidências visuais."
                                  ],
                                  "verification": "Crie um relatório curto justificando a classificação com capturas de tela dos gráficos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Gráficos gerados no passo anterior",
                                    "Ferramentas de plotagem interativa como Plotly (opcional)"
                                  ],
                                  "tips": "Zoom em sub-períodos para confirmar padrões; anote o gráfico diretamente.",
                                  "learningObjective": "Desenvolver capacidade de categorizar séries temporais usando análise visual.",
                                  "commonMistakes": [
                                    "Classificar erroneamente tendência como sazonalidade",
                                    "Ignorar ruído aleatório como não estacionariedade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir Implicações para Métodos de Previsão",
                                  "subSteps": [
                                    "Para estacionárias: liste métodos como ARIMA sem diferenciação.",
                                    "Para não estacionárias: explique necessidade de diferenciação ou decomposição.",
                                    "Para sazonais: destaque modelos como SARIMA ou Prophet.",
                                    "Compare precisão de previsões inadequadas vs. adequadas.",
                                    "Simule uma previsão simples para ilustrar impactos."
                                  ],
                                  "verification": "Escreva um parágrafo por tipo explicando implicações e métodos recomendados.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Resumos de modelos de previsão (ARIMA, SARIMA)",
                                    "Tutoriais de bibliotecas como statsmodels"
                                  ],
                                  "tips": "Ligue implicações a cenários reais para melhor retenção.",
                                  "learningObjective": "Entender como a classificação afeta a escolha e performance de modelos de previsão.",
                                  "commonMistakes": [
                                    "Recomendar modelos sazonais para séries puramente estacionárias",
                                    "Subestimar necessidade de transformações em não estacionárias"
                                  ]
                                }
                              ],
                              "practicalExample": "Analise o dataset clássico AirPassengers (passageiros aéreos mensais de 1949-1960): plote a série, identifique sazonalidade anual e tendência crescente (não estacionária sazonal), e discuta por que SARIMA é apropriado em vez de ARIMA simples.",
                              "finalVerifications": [
                                "Classifica corretamente pelo menos 3 séries de teste como estacionária, não estacionária ou sazonal.",
                                "Justifica classificações com evidências visuais específicas.",
                                "Explica implicações corretas para métodos de previsão em cada categoria.",
                                "Gera gráficos claros com anotações de padrões.",
                                "Identifica erros comuns em classificações de pares.",
                                "Simula impacto de modelagem errada em uma previsão de exemplo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de características (média, variância, ciclos): 30%",
                                "Qualidade das visualizações e anotações: 20%",
                                "Justificativas lógicas baseadas em evidências: 25%",
                                "Compreensão de implicações para previsão: 15%",
                                "Clareza e completude do relatório: 10%"
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Testes formais de estacionariedade (ADF test).",
                                "Programação: Manipulação de dados em Python/R.",
                                "Economia: Previsão de vendas ou PIB.",
                                "Ciência de Dados: Pré-processamento para ML.",
                                "Matemática: Modelos estocásticos e diferenciação."
                              ],
                              "realWorldApplication": "Em empresas de varejo, classificar séries de vendas como sazonais permite usar SARIMA para prever demandas de Natal, otimizando estoque e reduzindo custos; em meteorologia, identificar não estacionariedade em temperaturas ajuda a modelar mudanças climáticas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.5.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.2",
                "name": "Formação de Bases de Dados",
                "description": "Tipos de dados temporais, importação e transformações necessárias para análise de séries temporais.",
                "totalSkills": 50,
                "atomicTopics": [
                  {
                    "id": "10.1.2.1",
                    "name": "Tipos de Dados Temporais",
                    "description": "Classificação e características dos tipos de dados específicos para séries temporais, como univariados, multivariados e de diferentes frequências.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.1.1",
                        "name": "Séries Temporais Univariadas",
                        "description": "Séries temporais compostas por uma única variável observada sequencialmente ao longo do tempo, permitindo análise focada em padrões como tendência e sazonalidade de uma dimensão.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.1.1",
                            "name": "Definir e identificar séries univariadas",
                            "description": "Explicar o conceito de série temporal univariada e distinguir exemplos reais, como preço de uma ação ou temperatura diária, de dados não temporais ou multivariados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito Básico de Série Temporal",
                                  "subSteps": [
                                    "Estude a definição: Uma série temporal é uma sequência de observações de uma variável coletadas em intervalos regulares de tempo.",
                                    "Identifique características chave: ordenação temporal, dependência entre observações consecutivas, presença de tendências, sazonalidade ou ciclos.",
                                    "Analise a importância: Permite modelar e prever fenômenos que evoluem no tempo.",
                                    "Compare com dados não temporais: Dados cruzados não têm ordem temporal explícita."
                                  ],
                                  "verification": "Escreva uma definição em suas palavras e dê um exemplo simples de série temporal.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Vídeo introdutório sobre séries temporais (ex: Khan Academy)",
                                    "Artigo da Wikipedia: 'Time series'"
                                  ],
                                  "tips": "Visualize séries temporais como uma linha no gráfico onde o eixo X é sempre o tempo.",
                                  "learningObjective": "Dominar a definição e características fundamentais de séries temporais.",
                                  "commonMistakes": [
                                    "Confundir com dados estáticos ou cruzados sem sequência temporal.",
                                    "Ignorar a dependência entre pontos consecutivos."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e Diferenciar Séries Univariadas de Multivariadas",
                                  "subSteps": [
                                    "Defina univariada: Série temporal com apenas uma variável observada ao longo do tempo (ex: temperatura diária).",
                                    "Defina multivariada: Múltiplas variáveis medidas simultaneamente no tempo (ex: temperatura e umidade diárias).",
                                    "Crie uma tabela comparativa: Colunas para univariada vs. multivariada, com exemplos e diferenças.",
                                    "Explique o foco: Univariada analisa o comportamento de uma única métrica temporal.",
                                    "Pratique verbalizando: Descreva por que uma série é univariada."
                                  ],
                                  "verification": "Classifique 3 exemplos como univariados ou multivariados com justificativa.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets para tabela comparativa",
                                    "Infográfico sobre tipos de séries temporais"
                                  ],
                                  "tips": "Conte o número de colunas de dados: 1 = univariada; mais de 1 = multivariada.",
                                  "learningObjective": "Distinguir precisamente séries univariadas de multivariadas.",
                                  "commonMistakes": [
                                    "Considerar metadados (como data) como segunda variável.",
                                    "Confundir com múltiplas séries separadas."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Exemplos Reais de Séries Univariadas",
                                  "subSteps": [
                                    "Liste exemplos comuns: Preço de fechamento diário de uma ação, temperatura média mensal, vendas diárias de um produto.",
                                    "Colete dados reais: Baixe um dataset simples de temperatura diária ou preço de ação de fontes como Yahoo Finance.",
                                    "Plote o gráfico: Use ferramentas para visualizar a série e confirmar ordenação temporal.",
                                    "Valide: Verifique se há apenas uma variável principal indexada pelo tempo.",
                                    "Documente 5 exemplos com fontes."
                                  ],
                                  "verification": "Apresente 3 gráficos de exemplos univariados com legendas explicativas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de plotagem: Excel, Python (Matplotlib) ou Google Sheets",
                                    "Datasets gratuitos: Yahoo Finance para ações, NOAA para temperatura"
                                  ],
                                  "tips": "Sempre pergunte: 'Há apenas uma medida quantitativa por ponto temporal?'",
                                  "learningObjective": "Reconhecer séries univariadas em contextos reais.",
                                  "commonMistakes": [
                                    "Incluir variáveis auxiliares como volume de negociação como parte da série.",
                                    "Usar dados irregulares (não em intervalos fixos)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Distinção de Dados Não Temporais e Multivariados",
                                  "subSteps": [
                                    "Colete contra-exemplos: Dados não temporais (ex: salários de funcionários em 2023), multivariados (ex: PIB e inflação trimestrais).",
                                    "Crie exercícios de classificação: Misture 10 datasets e categorize cada um.",
                                    "Explique erros: Para cada contra-exemplo, justifique por que não é univariada temporal.",
                                    "Teste com quiz: Responda perguntas sobre novos exemplos.",
                                    "Revise e corrija: Analise acertos/erros para reforçar aprendizado."
                                  ],
                                  "verification": "Complete um quiz de 10 itens com 90% de acerto e explique 2 erros comuns.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Quiz online ou planilha com exemplos mistos",
                                    "Lista de datasets: Kaggle para variedade"
                                  ],
                                  "tips": "Foco na dimensionalidade: Tempo + 1 variável = univariada.",
                                  "learningObjective": "Aplicar identificação em cenários mistos e ambíguos.",
                                  "commonMistakes": [
                                    "Classificar dados ordenados por data mas sem dependência temporal como série.",
                                    "Ignorar múltiplas variáveis em painéis de dados."
                                  ]
                                }
                              ],
                              "practicalExample": "Baixe os preços diários de fechamento da ação AAPL (Apple) de 2023. Plote como linha temporal: eixo X = datas, eixo Y = preço. Confirme univariada (apenas preço), temporal (diário) e distinga de dados multivariados como preço + volume.",
                              "finalVerifications": [
                                "Define série temporal univariada com precisão em 1 parágrafo.",
                                "Classifica corretamente 5 exemplos reais como univariados/não.",
                                "Explica diferenças univariada vs. multivariada sem erros.",
                                "Plota e interpreta 2 gráficos de séries univariadas.",
                                "Identifica 3 contra-exemplos comuns (não temporal/multivariado).",
                                "Responde quiz de distinção com 95% acerto."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: Definição completa e correta (20%)",
                                "Capacidade de identificação: Acertos em exemplos reais (25%)",
                                "Distinção clara: Explicações lógicas para classificações (20%)",
                                "Uso de visualizações: Gráficos adequados e interpretados (15%)",
                                "Profundidade prática: Aplicação em datasets reais (10%)",
                                "Correção de erros: Reconhecimento e evitação de pitfalls (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Economia/Finanças: Análise de preços de ações e forecasting de mercado.",
                                "Ciência Ambiental: Monitoramento de temperatura e padrões climáticos.",
                                "Saúde Pública: Taxas diárias de casos de doenças infecciosas.",
                                "Negócios: Vendas sazonais e previsão de demanda.",
                                "Engenharia: Medições de sensores em intervalos fixos."
                              ],
                              "realWorldApplication": "Em finanças, identificar séries univariadas como preços de ações permite modelos de previsão simples para trading; em meteorologia, temperaturas diárias univariadas alimentam alertas de clima; em negócios, vendas diárias ajudam a otimizar estoque e marketing."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.2",
                            "name": "Listar características principais",
                            "description": "Descrever atributos chave como dependência serial, autocorrelação e ausência de covariáveis, ilustrando com gráficos de séries univariadas simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de séries temporais univariadas",
                                  "subSteps": [
                                    "Defina série temporal univariada como uma sequência de observações de uma única variável ao longo do tempo.",
                                    "Diferencie de dados cruzados, destacando a ordenação temporal.",
                                    "Explique que não há covariáveis externas, focando apenas na variável principal.",
                                    "Identifique exemplos simples como temperatura diária ou preço de ações.",
                                    "Discuta a importância da estrutura temporal para análise."
                                  ],
                                  "verification": "Escreva uma definição clara e cite um exemplo pessoal.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notebook para anotações",
                                    "Acesso a internet para exemplos básicos"
                                  ],
                                  "tips": "Use analogias cotidianas, como medir sua altura ao longo dos anos.",
                                  "learningObjective": "Dominar a definição e distinção de séries univariadas.",
                                  "commonMistakes": "Confundir com séries multivariadas que incluem múltiplas variáveis."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar dependência serial",
                                  "subSteps": [
                                    "Explique dependência serial como a relação entre observações consecutivas.",
                                    "Descreva que valores passados influenciam valores futuros, violando independência.",
                                    "Compare com dados independentes, como amostras aleatórias.",
                                    "Analise um exemplo: em temperaturas, dias quentes tendem a seguir dias quentes.",
                                    "Registre a fórmula conceitual: Cov(Y_t, Y_{t-k}) ≠ 0 para k>0."
                                  ],
                                  "verification": "Desenhe um gráfico simples mostrando dependência serial.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis para esboços",
                                    "Software como Excel ou Python (opcional)"
                                  ],
                                  "tips": "Pense em 'memória' da série: o passado 'lembra' o presente.",
                                  "learningObjective": "Reconhecer e descrever dependência serial em séries temporais.",
                                  "commonMistakes": "Assumir independência como em regressão linear padrão."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar autocorrelação",
                                  "subSteps": [
                                    "Defina autocorrelação como correlação de uma série consigo mesma em lags diferentes.",
                                    "Calcule conceitualmente o coeficiente de autocorrelação: ρ_k = Cov(Y_t, Y_{t-k}) / Var(Y).",
                                    "Interprete valores: próximo de 1 indica forte autocorrelação positiva.",
                                    "Discuta lags: lag-1 (consecutivos), lag-2, etc.",
                                    "Examine um gráfico de autocorrelação parcial (PACF) para visualização."
                                  ],
                                  "verification": "Liste 3 lags e interprete coeficientes hipotéticos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Ferramentas online como ACF plotter"
                                  ],
                                  "tips": "Visualize com gráficos: barras acima de bandas de confiança indicam significância.",
                                  "learningObjective": "Compreender e calcular autocorrelação em séries univariadas.",
                                  "commonMistakes": "Confundir autocorrelação com correlação cruzada."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ilustrar ausência de covariáveis e criar gráficos simples",
                                  "subSteps": [
                                    "Explique ausência de covariáveis: foco exclusivo na variável univariada, sem regressores externos.",
                                    "Compare com multivariadas que incluem covariáveis como PIB em previsão de inflação.",
                                    "Crie gráfico de linha de uma série univariada fictícia (ex: 20 pontos de temperatura).",
                                    "Adicione gráfico de autocorrelação para ilustrar características.",
                                    "Liste verbalmente as 3 principais: dependência serial, autocorrelação, univariada."
                                  ],
                                  "verification": "Produza e descreva 2 gráficos rotulados corretamente.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Software de plotagem: Python (matplotlib), R ou Excel"
                                  ],
                                  "tips": "Use dados reais baixados de sites como Yahoo Finance para autenticidade.",
                                  "learningObjective": "Visualizar e sintetizar características principais via gráficos.",
                                  "commonMistakes": "Incluir variáveis externas inadvertidamente nos gráficos."
                                }
                              ],
                              "practicalExample": "Analise a série temporal univariada de temperaturas diárias em São Paulo nos últimos 30 dias. Plote o gráfico de linha, observe a dependência serial (ondas de calor/frio), calcule autocorrelações em lags 1-5 e confirme ausência de covariáveis como umidade.",
                              "finalVerifications": [
                                "Lista corretamente dependência serial, autocorrelação e ausência de covariáveis.",
                                "Desenha gráfico de série univariada com tendência ou sazonalidade visível.",
                                "Interpreta coeficiente de autocorrelação em lag-1 acima de 0.5.",
                                "Diferencia univariada de multivariada com exemplo.",
                                "Explica impacto da dependência serial em modelagem estatística.",
                                "Produz gráfico de ACF simples e rotulado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição das 3 características principais (90%+ correção).",
                                "Qualidade dos gráficos: eixos claros, legenda e interpretação.",
                                "Profundidade na explicação de autocorrelação com fórmula conceitual.",
                                "Uso correto de terminologia estatística sem erros conceituais.",
                                "Criatividade em exemplos reais e conexões práticas.",
                                "Completude: todos os atributos chave abordados em lista estruturada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estatística descritiva e correlação.",
                                "Informática: Programação em Python/R para visualização de dados.",
                                "Economia: Análise de séries de preços e vendas.",
                                "Geografia: Séries climáticas e ambientais.",
                                "Física: Medições temporais como velocidade em experimentos."
                              ],
                              "realWorldApplication": "Em meteorologia, listar essas características permite modelar temperaturas futuras sem dados externos, auxiliando previsões de curto prazo para agricultura e energia."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.3",
                            "name": "Aplicar em exemplos práticos",
                            "description": "Analisar um dataset univariado fornecido, identificando componentes temporais básicos como nível, tendência e ruído.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e carregar o dataset univariado",
                                  "subSteps": [
                                    "Obtenha um dataset univariado de série temporal (ex: temperaturas diárias por 1 ano).",
                                    "Verifique a estrutura: índice temporal sequencial e coluna de valores.",
                                    "Carregue os dados em uma ferramenta como Python (pandas) ou R.",
                                    "Trate valores ausentes ou inconsistências iniciais.",
                                    "Confirme o formato temporal (data/hora) usando funções como pd.to_datetime()."
                                  ],
                                  "verification": "Dataset carregado corretamente com shape, tipos de dados e primeiras/last linhas exibidas sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Dataset CSV/Excel de série temporal univariada; Python com pandas/matplotlib ou R com tidyverse.",
                                  "tips": "Sempre defina o índice como datetime para facilitar plots temporais.",
                                  "learningObjective": "Dominar o carregamento e inspeção inicial de dados temporais univariados.",
                                  "commonMistakes": "Ignorar valores ausentes, que distorcem análises; não converter índice para datetime."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Visualizar a série temporal completa",
                                  "subSteps": [
                                    "Gere um gráfico de linha com tempo no eixo x e valores no eixo y.",
                                    "Adicione rótulos, título e grade para clareza.",
                                    "Observe padrões visuais iniciais: estabilidade, crescimento ou flutuações.",
                                    "Calcule estatísticas descritivas básicas (média, mediana, desvio padrão).",
                                    "Plote subperíodos para zoom em comportamentos locais."
                                  ],
                                  "verification": "Gráfico gerado mostrando a série ao longo do tempo com estatísticas resumidas impressas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Bibliotecas de plotagem (matplotlib/seaborn em Python; ggplot2 em R).",
                                  "tips": "Use escalas logarítmicas se houver variações extremas para melhor visualização.",
                                  "learningObjective": "Desenvolver habilidade em visualização para intuição inicial dos componentes temporais.",
                                  "commonMistakes": "Plots sem rótulos ou eixos claros; ignorar escalas que mascaram tendências."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e estimar o nível (componente constante)",
                                  "subSteps": [
                                    "Calcule a média móvel de longo período (ex: janela de 30 períodos).",
                                    "Plote a média móvel sobre a série original.",
                                    "Descreva o nível: alto/baixo, estável ou com shifts abruptos.",
                                    "Compare com mediana para detectar assimetrias.",
                                    "Ajuste janela da média móvel para suavizar ruído excessivo."
                                  ],
                                  "verification": "Gráfico com média móvel sobreposta e descrição escrita do nível identificado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Funções de rolling mean em pandas ou zoo em R.",
                                  "tips": "Escolha janela baseada no ciclo sazonal conhecido (ex: 365 para diário anual).",
                                  "learningObjective": "Isolar o componente de nível como base estável da série.",
                                  "commonMistakes": "Usar janela muito curta, confundindo nível com ruído; ignorar mudanças estruturais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar e estimar a tendência",
                                  "subSteps": [
                                    "Aplique suavização dupla (ex: média móvel em média móvel) ou regressão linear por tempo.",
                                    "Plote a tendência estimada sobre a série e nível.",
                                    "Classifique: crescente, decrescente, estacionária ou não linear.",
                                    "Teste remoção da tendência (subtraia e visualize resíduos).",
                                    "Use decomposição STL se disponível para separar formalmente."
                                  ],
                                  "verification": "Gráfico com tendência plotada e resíduos sem tendência visível.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "statsmodels.tsa.seasonal.STL ou lm() em R para regressão.",
                                  "tips": "Para não lineares, teste polinomiais de grau 2; valide com ACF de resíduos.",
                                  "learningObjective": "Extrair a direção e magnitude da mudança ao longo do tempo.",
                                  "commonMistakes": "Ajustar tendência muito flexível, capturando ruído; assumir linearidade sempre."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Identificar o ruído e validar decomposição",
                                  "subSteps": [
                                    "Subtraia nível + tendência dos dados originais para obter resíduos (ruído).",
                                    "Plote resíduos: devem parecer aleatórios, sem padrões.",
                                    "Calcule variância dos resíduos e teste estacionariedade (ADF test).",
                                    "Reconstrua série: nível + tendência + ruído e compare com original.",
                                    "Documente insights: força de cada componente."
                                  ],
                                  "verification": "Resíduos plotados sem autocorrelação visível; soma de componentes ≈ original (erro <5%).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Testes de estacionariedade (statsmodels.adfuller ou ur.df em R).",
                                  "tips": "Ruído ideal é branco; correlações residuais indicam sazonalidade não capturada.",
                                  "learningObjective": "Confirmar que ruído é o remanescente aleatório após remoção de componentes sistemáticos.",
                                  "commonMistakes": "Resíduos com padrões restantes (falha na decomposição); não validar reconstrução."
                                }
                              ],
                              "practicalExample": "Analise o dataset de temperaturas diárias em uma cidade (ex: dados do Kaggle 'Daily Temperature of Major Cities'). Carregue, plote, identifique nível (~20°C médio), tendência (leve aquecimento anual), e ruído (flutuações diárias). Use Python: df['temp'].rolling(30).mean() para nível, regressão para tendência.",
                              "finalVerifications": [
                                "Gráficos de decomposição mostram nível, tendência e ruído claramente separados.",
                                "Resíduos são estacionários (p-value ADF <0.05).",
                                "Reconstrução da série original tem erro RMSE <10% dos dados.",
                                "Relatório escrito descreve cada componente com evidências visuais.",
                                "Pode aplicar o processo a um novo dataset em <1 hora.",
                                "Identifica corretamente se há sazonalidade não modelada nos resíduos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na estimação de componentes (visualmente alinhados aos dados).",
                                "Uso correto de métodos de suavização e testes estatísticos.",
                                "Qualidade dos gráficos: legíveis, anotados e informativos.",
                                "Análise qualitativa robusta com descrições justificadas.",
                                "Eficiência: tempo dentro do estimado com zero erros de código.",
                                "Capacidade de generalizar para datasets semelhantes."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Regressão linear e médias móveis.",
                                "Programação: Manipulação de dados com pandas/R e visualização.",
                                "Economia: Análise de séries de vendas ou PIB.",
                                "Ciências Ambientais: Monitoramento climático com dados temporais."
                              ],
                              "realWorldApplication": "Em empresas de varejo, decompor vendas mensais para prever demanda removendo sazonalidade; em meteorologia, separar tendências climáticas de variações aleatórias para alertas de longo prazo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.1.2",
                        "name": "Séries Temporais Multivariadas",
                        "description": "Séries temporais que envolvem múltiplas variáveis interdependentes ao longo do tempo, permitindo modelagem de relações cruzadas e interações entre séries.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.2.1",
                            "name": "Definir e diferenciar multivariadas",
                            "description": "Explicar o conceito de série temporal multivariada e contrastá-la com univariadas, usando exemplos como PIB, inflação e desemprego em um vetor temporal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Séries Temporais Univariadas",
                                  "subSteps": [
                                    "Revise a definição básica de uma série temporal: sequência de observações coletadas ao longo do tempo.",
                                    "Identifique características de univariadas: uma única variável medida repetidamente, como temperatura diária.",
                                    "Analise exemplos simples: plotar uma série univariada de vendas mensais para visualizar tendências e sazonalidade.",
                                    "Discuta limitações: ignora interações com outras variáveis, limitando análises causais.",
                                    "Pratique identificando univariadas em datasets reais."
                                  ],
                                  "verification": "Crie um gráfico de uma série univariada e descreva suas componentes (tendência, sazonalidade, ruído).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python com pandas e matplotlib; dataset de temperatura ou vendas (ex: airpassengers.csv)",
                                  "tips": "Sempre comece plotando os dados para visualização intuitiva antes de análises formais.",
                                  "learningObjective": "Definir e exemplificar séries temporais univariadas com precisão.",
                                  "commonMistakes": "Confundir com dados cross-sectionais; univariadas são sequenciais no tempo, não independentes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Séries Temporais Multivariadas",
                                  "subSteps": [
                                    "Defina multivariada: conjunto de múltiplas séries temporais observadas simultaneamente, formando um vetor temporal.",
                                    "Explique a estrutura: em tempo t, Y_t = [Y1_t, Y2_t, ..., Yk_t], onde cada Yi é uma univariada.",
                                    "Discuta dependências: variáveis podem ser correlacionadas, como PIB e inflação.",
                                    "Compare dimensionalidade: univariada (1D) vs. multivariada (kD).",
                                    "Estude notação matemática básica: Y_t ∈ ℝ^k."
                                  ],
                                  "verification": "Escreva a definição formal e um exemplo de vetor multivariado para t=1.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Notebook Jupyter; referências teóricas como 'Forecasting: Principles and Practice' (Hyndman).",
                                  "tips": "Use vetores para representar multivariadas; pense em matrizes de tempo x variáveis.",
                                  "learningObjective": "Articular a definição matemática de séries temporais multivariadas.",
                                  "commonMistakes": "Confundir com painéis de dados; multivariadas têm múltiplas variáveis no mesmo tempo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar Univariadas de Multivariadas",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: dimensões, modelagem (ARIMA vs. VAR), análise de dependências.",
                                    "Analise vantagens multivariadas: captura spillovers e causalidade (ex: Granger).",
                                    "Descreva desvantagens: maior complexidade computacional e risco de multicolinearidade.",
                                    "Pratique conversão: transforme univariada em multivariada adicionando lags ou covariáveis.",
                                    "Avalie cenários: quando usar cada uma (univariada para forecasting simples; multivariada para interações)."
                                  ],
                                  "verification": "Preencha uma tabela de diferenças e justifique com um exemplo hipotético.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Planilha Excel ou Google Sheets para tabela; datasets econômicos do FRED (Federal Reserve).",
                                  "tips": "Foque em interações: multivariadas modelam como uma variável afeta outra ao longo do tempo.",
                                  "learningObjective": "Contrastar características chave e aplicações de cada tipo.",
                                  "commonMistakes": "Ignorar estacionariedade conjunta em multivariadas; teste sempre."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar com Exemplos Econômicos",
                                  "subSteps": [
                                    "Colete dados: PIB, inflação e desemprego trimestrais (ex: 2000-2023).",
                                    "Forme vetor temporal: Y_t = [PIB_t, Inflação_t, Desemprego_t].",
                                    "Plote séries individuais e correlações para visualizar diferenças.",
                                    "Simule análise: compute matriz de correlação e interprete relacionamentos.",
                                    "Conclua: explique por que multivariada é superior aqui (ex: choques inflacionários afetam PIB)."
                                  ],
                                  "verification": "Gere plots e relatório de 200 palavras diferenciando univariada (só PIB) vs. multivariada.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python/R com bibliotecas (pandas, ggplot2); dados FRED API ou CSV.",
                                  "tips": "Use correlogramas para dependências; comece com dados reais para motivação.",
                                  "learningObjective": "Demonstrar diferenciação prática usando vetores temporais econômicos.",
                                  "commonMistakes": "Usar escalas diferentes sem normalizar; padronize variáveis para comparações."
                                }
                              ],
                              "practicalExample": "Baixe dados trimestrais de PIB, inflação (CPI) e taxa de desemprego dos EUA (FRED). Forme Y_t = [PIB_t / 1000, Inflação_t, Desemprego_t]. Plote univariada (PIB) vs. multivariada (todas três), destacando como recessões (alta desemprego) impactam PIB, ausente na univariada.",
                              "finalVerifications": [
                                "Definição precisa de multivariada como vetor temporal.",
                                "Correta diferenciação de dimensões e modelagem (ARIMA vs. VAR).",
                                "Exemplo concreto com dados econômicos inter-relacionados.",
                                "Tabela comparativa completa sem erros.",
                                "Interpretação de correlações em contexto multivariado.",
                                "Identificação de limitações de univariadas em cenários reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (30%): Definições e diferenças exatas.",
                                "Exemplificação prática (25%): Uso correto de dados reais.",
                                "Profundidade analítica (20%): Análise de dependências e limitações.",
                                "Clareza de comunicação (15%): Tabelas/plots legíveis.",
                                "Aplicação contextual (10%): Ligação com economia real."
                              ],
                              "crossCurricularConnections": [
                                "Economia: Modelagem macroeconômica com VAR.",
                                "Machine Learning: Séries multivariadas em LSTM ou Prophet.",
                                "Finanças: Previsão de portfólios com retornos múltiplos.",
                                "Ciências Sociais: Análise de indicadores sociais interdependentes."
                              ],
                              "realWorldApplication": "Em bancos centrais, modelar séries multivariadas como PIB, inflação e desemprego para prever recessões e ajustar políticas monetárias, capturando spillovers que univariadas ignoram."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.2.2",
                            "name": "Identificar características específicas",
                            "description": "Descrever propriedades como correlação cruzada, cointegration e matriz de covariância, com visualizações em gráficos múltiplos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Teóricos Fundamentais",
                                  "subSteps": [
                                    "Estude a definição de correlação cruzada (cross-correlation) para séries temporais multivariadas e sua função de autocorrelação cruzada (CCF).",
                                    "Aprenda sobre cointegration: conceito de relações de longo prazo entre séries não estacionárias, usando testes como Engle-Granger ou Johansen.",
                                    "Revise matriz de covariância: como ela captura dependências lineares entre múltiplas séries temporais em diferentes lags.",
                                    "Explore diferenças entre correlação simples, covariância e cross-correlation em contextos temporais.",
                                    "Analise exemplos matemáticos simples de fórmulas para CCF e matriz de covariância."
                                  ],
                                  "verification": "Resuma cada conceito em suas próprias palavras e forneça uma fórmula matemática básica para cada um.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro ou notas sobre séries temporais (ex: 'Time Series Analysis' de Hamilton)",
                                    "Vídeos tutoriais no Khan Academy ou YouTube sobre cointegration",
                                    "Notebook Jupyter para anotações"
                                  ],
                                  "tips": "Use analogias: pense em cross-correlation como 'eco' entre duas séries ao longo do tempo.",
                                  "learningObjective": "Dominar as definições e fórmulas teóricas de correlação cruzada, cointegration e matriz de covariância.",
                                  "commonMistakes": [
                                    "Confundir cross-correlation com correlação simples (ignorar lags)",
                                    "Achar que cointegration implica causalidade",
                                    "Ignorar estacionariedade nas séries"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar e Explorar Dados de Séries Temporais Multivariadas",
                                  "subSteps": [
                                    "Carregue um dataset multivariado (ex: preços de ações ou dados climáticos) usando pandas em Python.",
                                    "Verifique estacionariedade com testes ADF para cada série e aplique diferenciação se necessário.",
                                    "Calcule estatísticas descritivas básicas: média, variância e gráficos de séries individuais.",
                                    "Crie um dataframe alinhado temporalmente para múltiplas variáveis.",
                                    "Gere gráficos preliminares de séries temporais sobrepostas para visual inspeção."
                                  ],
                                  "verification": "Produza um relatório com testes ADF e gráficos iniciais mostrando alinhamento temporal.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com pandas, numpy, matplotlib",
                                    "Dataset exemplo: yfinance para ações (AAPL, MSFT)",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Sempre padronize datas com pd.to_datetime() para evitar erros de indexação.",
                                  "learningObjective": "Preparar dados limpos e prontos para análise de dependências multivariadas.",
                                  "commonMistakes": [
                                    "Não tratar missing values",
                                    "Ignorar lags na preparação",
                                    "Usar séries não alinhadas temporalmente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Métricas de Dependência: Covariância, Cross-Correlation e Cointegration",
                                  "subSteps": [
                                    "Construa a matriz de covariância usando pd.DataFrame.cov() para lags zero.",
                                    "Calcule funções de cross-correlation (CCF) com statsmodels.tsa.stattools.ccf() para pares de séries.",
                                    "Aplique teste de cointegration Johansen com statsmodels.tsa.vector_ar.vecm.JohansenTest.",
                                    "Interprete picos na CCF (lags significativos) e autovalores no teste Johansen.",
                                    "Gere uma matriz de covariância rolling para análise dinâmica."
                                  ],
                                  "verification": "Gere outputs numéricos: matriz cov, CCF plot e resultados do teste Johansen com interpretação.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Bibliotecas Python: statsmodels, pandas",
                                    "Dataset do Step 2",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Defina lags_max razoável (ex: 20) na CCF para evitar ruído excessivo.",
                                  "learningObjective": "Executar cálculos precisos das métricas chave para séries multivariadas.",
                                  "commonMistakes": [
                                    "Não normalizar séries antes da CCF",
                                    "Interpretar falsos positivos em testes sem ajuste de significância",
                                    "Confundir covariância com correlação padronizada"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Visualizar e Interpretar Características em Gráficos Múltiplos",
                                  "subSteps": [
                                    "Crie heatmap da matriz de covariância com seaborn.heatmap().",
                                    "Plote CCF para múltiplos pares em subplots com matplotlib.subplots().",
                                    "Gere gráficos de séries com bandas de confiança para cointegration residuals.",
                                    "Combine em um dashboard: séries raw, heatmaps e CCFs em uma figura única.",
                                    "Interprete visualmente: identifique padrões como leads/lags e relações de longo prazo."
                                  ],
                                  "verification": "Produza uma figura final com múltiplos gráficos anotados e uma narrativa de 200 palavras interpretando características.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python: matplotlib, seaborn",
                                    "Resultados dos cálculos anteriores",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Use cores consistentes e legendas claras; salve como PNG para relatórios.",
                                  "learningObjective": "Criar visualizações informativas que revelem características específicas das séries.",
                                  "commonMistakes": [
                                    "Sobrecarregar gráficos com muitos lags",
                                    "Ignorar escalas nos eixos",
                                    "Não anotar significância estatística (ex: barras de erro)"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e Identificar Características Específicas",
                                  "subSteps": [
                                    "Compile métricas em um relatório: forças de dependências, lags dominantes e evidência de cointegration.",
                                    "Identifique características únicas: ex. 'Série A lidera B em 3 lags' ou 'Cointegradas com vetor (1, -0.8)'.",
                                    "Compare com benchmarks teóricos ou dados conhecidos.",
                                    "Discuta implicações para modelagem futura (ex: VAR ou VECM).",
                                    "Revise o workflow completo para reprodutibilidade."
                                  ],
                                  "verification": "Escreva um resumo executivo de 1 página listando 5+ características identificadas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Todos os outputs anteriores",
                                    "Template de relatório Markdown"
                                  ],
                                  "tips": "Priorize as 3 características mais impactantes para síntese clara.",
                                  "learningObjective": "Integrar análises para identificar e descrever propriedades chave das séries multivariadas.",
                                  "commonMistakes": [
                                    "Focar só em números sem interpretação",
                                    "Generalizar achados sem evidência estatística",
                                    "Omitir limitações como tamanho da amostra"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dados de preços diários das ações AAPL e MSFT (via yfinance), calcule a matriz de covariância, plote CCF revelando que AAPL lidera MSFT em 2 dias, e confirme cointegration via teste Johansen, visualizando residuals estacionários em gráficos múltiplos.",
                              "finalVerifications": [
                                "Matriz de covariância corretamente calculada e interpretada.",
                                "CCF plots mostram lags significativos com barras de confiança.",
                                "Teste de cointegration aplicado e resultados explicados.",
                                "Dashboard de visualizações múltiplas gerado e anotado.",
                                "Relatório sintetiza pelo menos 4 características específicas.",
                                "Workflow reproduzível em notebook compartilhável."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos matemáticos (90%+ acurácia).",
                                "Qualidade e clareza das visualizações (rótulos, escalas, legibilidade).",
                                "Profundidade da interpretação (ligação teoria-prática).",
                                "Completude do relatório (todos conceitos cobertos).",
                                "Criatividade na identificação de características únicas.",
                                "Eficiência temporal e uso otimizado de recursos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes) e estatística inferencial.",
                                "Economia/Finanças: Modelagem de mercados e pares trading.",
                                "Ciência de Dados: Machine Learning para previsão multivariada.",
                                "Física: Análise de sinais em sistemas dinâmicos.",
                                "Engenharia: Controle de sistemas com dependências temporais."
                              ],
                              "realWorldApplication": "Em finanças, identificar cointegration entre ações permite estratégias de trading sem risco (pairs trading); em meteorologia, cross-correlation entre temperatura e precipitação melhora previsões climáticas; em epidemiologia, analisa dependências entre surtos em regiões vizinhas para políticas de saúde pública."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.2.3",
                            "name": "Reconhecer aplicações iniciais",
                            "description": "Exemplificar usos em finanças (retornos de múltiplos ativos) e marketing (vendas e promoções correlacionadas), preparando para modelagem VAR.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de Séries Temporais Multivariadas",
                                  "subSteps": [
                                    "Defina série temporal univariada versus multivariada, destacando a presença de múltiplas variáveis interdependentes ao longo do tempo.",
                                    "Identifique características chave: autocorrelação cruzada, lags entre variáveis e dependências temporais simultâneas.",
                                    "Revise exemplos simples de dados multivariados, como temperatura e umidade em estações meteorológicas.",
                                    "Discuta por que multivariadas são essenciais para capturar interações reais, preparando o terreno para aplicações práticas.",
                                    "Anote diferenças com regressão linear tradicional, enfatizando a estrutura temporal."
                                  ],
                                  "verification": "Crie um diagrama conceitual resumindo univariada vs. multivariada e liste 3 características chave.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Notebook para anotações",
                                    "Artigo introdutório sobre séries temporais (ex: PDF de referência estatística)"
                                  ],
                                  "tips": "Use analogias cotidianas, como prever vendas considerando preço e publicidade simultaneamente.",
                                  "learningObjective": "Diferenciar séries temporais multivariadas de univariadas e reconhecer suas interdependências temporais.",
                                  "commonMistakes": [
                                    "Confundir com análise de painel (foco em entidades vs. tempo)",
                                    "Ignorar a ordem temporal dos dados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Aplicações em Finanças: Retornos de Múltiplos Ativos",
                                  "subSteps": [
                                    "Colete dados sample de retornos diários de ações (ex: AAPL, GOOG, índice S&P500) por 1 ano.",
                                    "Plote séries temporais paralelas e matriz de correlação para visualizar dependências.",
                                    "Exemplifique como choques em um ativo propagam para outros via correlações temporais.",
                                    "Discuta cenários: prever retornos de portfólio considerando volatilidade cruzada.",
                                    "Calcule correlações lagged simples para demonstrar leads/lags entre ativos."
                                  ],
                                  "verification": "Gere gráficos de séries e correlações, explicando uma dependência observada em 2-3 frases.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com pandas/matplotlib",
                                    "Dados sample de Yahoo Finance (CSV gratuito)"
                                  ],
                                  "tips": "Comece com 3 ativos para simplicidade; foque em visualizações antes de cálculos avançados.",
                                  "learningObjective": "Exemplificar como séries multivariadas modelam interações em retornos financeiros.",
                                  "commonMistakes": [
                                    "Usar correlação simples sem lags",
                                    "Ignorar normalização de retornos (log-retornos)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Aplicações em Marketing: Vendas e Promoções Correlacionadas",
                                  "subSteps": [
                                    "Obtenha dados sample de vendas semanais, gastos em promoções e tráfego de site por 6 meses.",
                                    "Visualize séries temporais sobrepostas e correlograma cruzado para identificar picos sincronizados.",
                                    "Exemplifique: como promoções em TV afetam vendas online com delay de 1 semana.",
                                    "Quantifique correlações: calcule coeficientes entre variáveis em diferentes lags.",
                                    "Debata impactos: otimizar timing de promoções baseado em respostas temporais cruzadas."
                                  ],
                                  "verification": "Produza relatório curto com gráficos e 2 insights sobre correlações observadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Excel ou Python (pandas/seaborn)",
                                    "Dataset sample de Kaggle sobre vendas e marketing"
                                  ],
                                  "tips": "Escolha dados reais para relevância; use lags de 0-4 períodos para marketing típico.",
                                  "learningObjective": "Demonstrar uso de multivariadas para correlacionar vendas e promoções com delays.",
                                  "commonMistakes": [
                                    "Assumir causalidade de correlação",
                                    "Não alinhar datas corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar Exemplos e Preparar para Modelagem VAR",
                                  "subSteps": [
                                    "Compare exemplos de finanças e marketing: identifique similaridades em dependências cruzadas.",
                                    "Explique necessidade de VAR: modelar dinâmicas vetoriais com lags endógenos.",
                                    "Esboce estrutura básica de VAR: equações para cada variável dependendo de lags de todas.",
                                    "Discuta pré-requisitos: estacionariedade, ordem de lags via AIC/BIC.",
                                    "Planeje próximo passo: teste de cointegração e Impulse Response Functions."
                                  ],
                                  "verification": "Crie mapa conceitual ligando exemplos a componentes de VAR, com 3 pré-requisitos listados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel/diagrama digital (ex: Draw.io)",
                                    "Resumo de VAR de textbook (ex: PDF capítulo séries temporais)"
                                  ],
                                  "tips": "Pense em VAR como 'regressão temporal multi-equação'; revise estacionariedade primeiro.",
                                  "learningObjective": "Conectar aplicações iniciais à modelagem VAR, reconhecendo transição lógica.",
                                  "commonMistakes": [
                                    "Pular testes de estacionariedade",
                                    "Confundir VAR com ARIMA univariada"
                                  ]
                                }
                              ],
                              "practicalExample": "Em finanças, use retornos diários de Bitcoin e S&P500 (2020-2023): plote séries e correlações lagged para mostrar como crashes no mercado propagam ao crypto. Em marketing, dados de vendas de refrigerantes vs. gastos em TV ads: identifique lag de 7 dias onde promoções impulsionam vendas subsequentes.",
                              "finalVerifications": [
                                "Explicar 2 diferenças chave entre séries univariadas e multivariadas.",
                                "Descrever um exemplo financeiro com dependência cruzada específica.",
                                "Identificar lag típico em exemplo de marketing e justificá-lo.",
                                "Listar 3 pré-requisitos para prosseguir a VAR.",
                                "Criar diagrama conectando exemplos a aplicações reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas sem confusões básicas (30%)",
                                "Exemplos relevantes: aplicações concretas em finanças/marketing (25%)",
                                "Análise visual/quantitativa: gráficos e correlações adequados (20%)",
                                "Conexão a VAR: preparação lógica e pré-requisitos (15%)",
                                "Clareza e estrutura: comunicação acionável (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Economia: Modelagem de spillovers entre mercados.",
                                "Negócios: Otimização de campanhas de marketing temporal.",
                                "Matemática: Álgebra linear em matrizes de covariância.",
                                "Computação: Programação em Python/R para análise temporal."
                              ],
                              "realWorldApplication": "Bancos usam séries multivariadas para gerenciamento de risco em portfólios; empresas de varejo preveem vendas otimizando promoções baseadas em interações históricas, reduzindo custos e aumentando receitas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.2.4",
                            "name": "Classificar datasets multivariados",
                            "description": "Classificar um conjunto de dados como univariado ou multivariado, avaliando dimensões e dependências temporais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Séries Temporais Univariadas e Multivariadas",
                                  "subSteps": [
                                    "Defina série temporal univariada como uma única variável observada ao longo do tempo (ex: temperatura diária).",
                                    "Defina série temporal multivariada como múltiplas variáveis interdependentes ao longo do tempo (ex: temperatura, umidade e pressão).",
                                    "Identifique dimensões chave: número de variáveis (features) e observações temporais.",
                                    "Explique dependências temporais: autocorrelação dentro de variáveis e correlações cruzadas entre variáveis.",
                                    "Diferencie de datasets não-temporais, focando no índice temporal ordenado."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras com definições e um exemplo de cada tipo, sem erros conceituais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de séries temporais (ex: Statsmodels docs)",
                                    "Notebook Jupyter ou Google Colab"
                                  ],
                                  "tips": "Use diagramas visuais para representar uni vs multi; memorize: uni = 1D temporal, multi = >1D temporal.",
                                  "learningObjective": "Dominar definições e distinções para basear classificações precisas.",
                                  "commonMistakes": [
                                    "Confundir univariado com poucos dados totais.",
                                    "Ignorar interdependências entre variáveis.",
                                    "Não considerar o aspecto sequencial temporal."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inspecionar Estrutura e Dimensões do Dataset",
                                  "subSteps": [
                                    "Carregue o dataset usando Pandas (pd.read_csv ou similar).",
                                    "Examine o shape (linhas x colunas) com df.shape e df.info().",
                                    "Identifique colunas: conte variáveis numéricas potenciais (excluindo índice de tempo).",
                                    "Verifique presença de índice temporal com df.index ou colunas de data.",
                                    "Visualize as primeiras linhas com df.head() e descreva com df.describe()."
                                  ],
                                  "verification": "Gere um relatório com shape, número de variáveis e confirmação de índice temporal.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Biblioteca Pandas instalada",
                                    "Dataset de exemplo (ex: air_passengers_multi.csv)",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Sempre verifique tipos de dados (datetime para tempo); foque em colunas além do timestamp.",
                                  "learningObjective": "Habilitar inspeção inicial para contar dimensões e confirmar natureza temporal.",
                                  "commonMistakes": [
                                    "Contar timestamp como variável.",
                                    "Ignorar colunas categóricas irrelevantes.",
                                    "Confundir linhas (observações) com dimensões (variáveis)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar Dependências Temporais e Inter-relações",
                                  "subSteps": [
                                    "Gere matriz de correlação com df.corr() para identificar cross-correlações.",
                                    "Crie autocorrelogramas (ACF) para cada variável usando statsmodels.tsa.stattools.acf.",
                                    "Plote correlogramas cruzados (CCF) entre pares de variáveis.",
                                    "Verifique estacionariedade básica com teste ADF (adfuller) em múltiplas séries.",
                                    "Documente evidências de dependências: lags significativos ou correlações >0.5."
                                  ],
                                  "verification": "Produza gráficos de correlação e ACF/CCF com interpretações escritas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Bibliotecas: Pandas, Statsmodels, Matplotlib/Seaborn",
                                    "Dataset temporal multivariado de exemplo"
                                  ],
                                  "tips": "Filtre correlações acima de 0.3; use lags até 20 para séries curtas.",
                                  "learningObjective": "Detectar interdependências temporais que confirmam caráter multivariado.",
                                  "commonMistakes": [
                                    "Não diferenciar auto vs cross-correlação.",
                                    "Ignorar não-estacionariedade.",
                                    "Sobrepor análises sem normalização de dados."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Classificar o Dataset e Justificar a Decisão",
                                  "subSteps": [
                                    "Aplique critérios: >1 variável numérica temporal = multivariado.",
                                    "Confirme dependências: evidência de correlações cruzadas ou lags inter-variáveis.",
                                    "Compare com univariado: apenas 1 variável relevante.",
                                    "Escreva justificativa detalhada incluindo shape, correlações e gráficos.",
                                    "Teste com subconjunto: remova variáveis e reclassifique."
                                  ],
                                  "verification": "Emita uma classificação final (uni/multi) com relatório de 200 palavras e evidências.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Relatório template em Markdown",
                                    "Gráficos gerados anteriormente"
                                  ],
                                  "tips": "Use checklist: dimensões >1 E temporal E dependências = multivariado.",
                                  "learningObjective": "Sintetizar análises em classificação acionável e defensável.",
                                  "commonMistakes": [
                                    "Classificar baseado só em shape, ignorando tempo.",
                                    "Faltar justificativa quantitativa.",
                                    "Classificar como uni se houver variáveis derivadas."
                                  ]
                                }
                              ],
                              "practicalExample": "Carregue dataset 'clima.csv' com colunas: data, temp_max, umidade, pressao. Shape: (365,4). Correlação temp-umidade=0.7. ACF mostra lags em ambas. Classificação: Multivariado devido a 3 variáveis interdependentes temporais.",
                              "finalVerifications": [
                                "Número de variáveis temporais >1 identificado corretamente.",
                                "Matriz de correlação gerada e interpretada.",
                                "Gráficos ACF/CCF mostram dependências temporais.",
                                "Classificação final justificada com critérios claros.",
                                "Teste de robustez com subconjuntos realizado.",
                                "Relatório livre de erros conceituais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na contagem de dimensões (100% corretude).",
                                "Qualidade da análise de dependências (correlações > threshold detectadas).",
                                "Profundidade da justificativa (evidências visuais + quantitativas).",
                                "Correção conceitual (uni vs multi distinguido).",
                                "Eficiência temporal (dentro de 90 min total).",
                                "Clareza do relatório (estruturado e legível)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Manipulação de dados com Python/Pandas e visualização com Matplotlib.",
                                "Matemática: Estatística descritiva, correlação e testes de estacionariedade.",
                                "Ciência de Dados: Pré-processamento para modelagem de séries temporais (VAR, ARIMAX).",
                                "Economia/Finanças: Análise de múltiplos indicadores econômicos (PIB, inflação, juros).",
                                "Meio Ambiente: Monitoramento multivariado de sensores climáticos."
                              ],
                              "realWorldApplication": "Em previsão meteorológica, classificar dados de múltiplos sensores (temp, vento, precipitação) para modelos VAR; em finanças, datasets de ações múltiplas para análise de risco e portfólios otimizados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.1.3",
                        "name": "Frequências de Dados Temporais",
                        "description": "Classificação das séries temporais com base na periodicidade de observação, como diária, semanal, mensal ou anual, impactando escolha de métodos analíticos.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.3.1",
                            "name": "Classificar tipos de frequência",
                            "description": "Listar e definir frequências comuns (diária, quinzenal, mensal, trimestral, anual) e suas implicações em granularidade temporal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Frequência Temporal",
                                  "subSteps": [
                                    "Defina série temporal como uma sequência de dados ordenados no tempo.",
                                    "Explique frequência como o intervalo regular entre observações consecutivas.",
                                    "Diferencie frequência de resolução temporal e granularidade.",
                                    "Identifique exemplos cotidianos, como relógios (segundos) vs. relatórios anuais.",
                                    "Discuta por que a frequência afeta a análise de dados."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo o conceito e dê um exemplo pessoal.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notebook e caneta",
                                    "Vídeo introdutório sobre séries temporais (ex: Khan Academy)"
                                  ],
                                  "tips": "Visualize um calendário para entender intervalos regulares.",
                                  "learningObjective": "Dominar a definição e importância da frequência temporal em séries de dados.",
                                  "commonMistakes": [
                                    "Confundir frequência com o número total de observações",
                                    "Ignorar que frequências irregulares não são séries temporais padrão"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Listar e Definir Frequências Comuns",
                                  "subSteps": [
                                    "Liste diária: observações a cada 24 horas.",
                                    "Defina quinzenal: a cada 15 dias ou duas vezes por mês.",
                                    "Explique mensal: no final ou início de cada mês.",
                                    "Descreva trimestral: a cada 3 meses (ex: jan-mar, abr-jun).",
                                    "Detalhe anual: uma vez por ano, tipicamente dezembro.",
                                    "Crie uma tabela comparativa com exemplos numéricos."
                                  ],
                                  "verification": "Crie uma tabela com as 5 frequências, definições e um exemplo de data.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets",
                                    "Calendário impresso"
                                  ],
                                  "tips": "Use abreviações padrão como 'D' para diária, 'M' para mensal em ferramentas como Pandas.",
                                  "learningObjective": "Memorizar e articular definições precisas das frequências comuns.",
                                  "commonMistakes": [
                                    "Confundir quinzenal com semestral",
                                    "Não considerar convenções de início de período (ex: mês civil)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Implicações na Granularidade Temporal",
                                  "subSteps": [
                                    "Explique granularidade fina (diária) vs. grossa (anual): mais detalhes vs. menos ruído.",
                                    "Discuta agregação: somar diárias para obter mensais.",
                                    "Avalie impactos na análise: sazonalidade detectável em diárias, tendências em anuais.",
                                    "Identifique perdas de informação ao mudar frequência (ex: de diária para mensal).",
                                    "Exemplo: volatilidade alta em dados diários de ações vs. estável em anuais."
                                  ],
                                  "verification": "Descreva prós e contras de usar frequência diária vs. anual para previsão de vendas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Gráficos de exemplo de séries temporais (ex: dados de temperatura do NOAA)",
                                    "Software como Python com Pandas"
                                  ],
                                  "tips": "Pense em trade-offs: mais dados = mais processamento, mas melhor precisão.",
                                  "learningObjective": "Compreender como a frequência influencia a qualidade e viabilidade da análise.",
                                  "commonMistakes": [
                                    "Subestimar custos computacionais de alta frequência",
                                    "Ignorar vieses de agregação (ex: média mensal esconde picos diários)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Classificação de Tipos de Frequência",
                                  "subSteps": [
                                    "Colete datasets de exemplo com diferentes frequências (ex: vendas diárias, PIB trimestral).",
                                    "Classifique cada um: identifique o intervalo e justifique.",
                                    "Converta um dataset de frequência alta para baixa e note mudanças.",
                                    "Crie um fluxograma para classificar qualquer série temporal.",
                                    "Teste com dados reais irregulares e proponha padronização."
                                  ],
                                  "verification": "Classifique 3 datasets fornecidos e explique implicações para cada.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Datasets sample (ex: Kaggle séries temporais)",
                                    "Ferramenta de visualização como Tableau Public ou Matplotlib"
                                  ],
                                  "tips": "Verifique intervalos exatos contando diferenças de datas.",
                                  "learningObjective": "Aplicar classificação em cenários reais e raciocinar sobre escolhas de frequência.",
                                  "commonMistakes": [
                                    "Classificar erroneamente dados com feriados como diários",
                                    "Não validar com múltiplas observações"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado um dataset de vendas de uma loja com registros em 01/01, 02/01, ..., 31/01 (diária), classifique como 'diária', note alta granularidade para detectar picos de fim de semana, e agregue para mensal somando valores para análise de tendências sazonais.",
                              "finalVerifications": [
                                "Listar corretamente as 5 frequências comuns com definições precisas.",
                                "Explicar granularidade temporal para cada frequência com exemplo.",
                                "Classificar um dataset desconhecido em menos de 2 minutos.",
                                "Identificar implicações de mudança de frequência (ex: diária para trimestral).",
                                "Criar tabela comparativa de prós/contras.",
                                "Discutir um caso real onde frequência errada levou a erro de análise."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições (100% das frequências corretas).",
                                "Profundidade nas implicações de granularidade (cobertura de pelo menos 3 impactos).",
                                "Qualidade da classificação prática (acertos em 90% dos exemplos).",
                                "Criatividade em exemplos e conexões reais.",
                                "Clareza na comunicação (tabelas/fluxogramas bem estruturados).",
                                "Demonstração de trade-offs computacionais e analíticos."
                              ],
                              "crossCurricularConnections": [
                                "Economia: Análise de PIB trimestral para políticas fiscais.",
                                "Finanças: Relatórios de ações diárias vs. balanços anuais.",
                                "Meio Ambiente: Monitoramento mensal de níveis de CO2.",
                                "Saúde Pública: Casos diários de doenças para epidemias.",
                                "Gestão de Projetos: Relatórios quinzenais de progresso."
                              ],
                              "realWorldApplication": "Em previsão de demanda para varejo, classificar vendas como mensais permite modelar sazonalidades (Natal), otimizando estoque e reduzindo custos em 20-30%, enquanto dados diários revelam padrões semanais para ajustes operacionais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.3.2",
                            "name": "Analisar impactos da frequência",
                            "description": "Explicar como frequências altas revelam ruído e baixas suavizam tendências, com exemplos de agregação de dados diários para mensais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Básicos de Frequência em Séries Temporais",
                                  "subSteps": [
                                    "Defina frequência temporal como o intervalo entre observações (ex: diária, mensal).",
                                    "Diferencie frequência alta (ex: diária) de baixa (ex: anual).",
                                    "Identifique componentes de séries temporais: tendência, sazonalidade, ruído.",
                                    "Explique que frequência afeta a visibilidade desses componentes.",
                                    "Revise exemplos iniciais de dados com diferentes frequências."
                                  ],
                                  "verification": "Resuma em 3 frases os conceitos chave e forneça 2 exemplos corretos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Notebook com Python (Pandas), conjunto de dados de séries temporais exemplo (ex: airpassengers.csv).",
                                  "tips": "Use diagramas visuais para ilustrar frequências diferentes no mesmo conjunto de dados.",
                                  "learningObjective": "Dominar definições e impactos iniciais da frequência em séries temporais.",
                                  "commonMistakes": "Confundir frequência com período sazonal; ignorar que frequência zero não existe em dados reais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Impactos de Frequências Altas e Revelação de Ruído",
                                  "subSteps": [
                                    "Carregue dados diários e plote o gráfico de linha.",
                                    "Identifique flutuações irregulares como ruído em frequências altas.",
                                    "Compare com média móvel para destacar ruído vs. sinal.",
                                    "Calcule variância em janelas curtas para quantificar ruído.",
                                    "Discuta por que ruído dificulta detecção de tendências reais."
                                  ],
                                  "verification": "Gere gráfico mostrando ruído em dados diários e explique 2 impactos observados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python (Pandas, Matplotlib), dados diários de temperatura ou vendas.",
                                  "tips": "Aumente o zoom em picos para visualizar ruído claramente.",
                                  "learningObjective": "Reconhecer e quantificar ruído em séries de alta frequência.",
                                  "commonMistakes": "Atribuir todo ruído a erros de medição em vez de variabilidade natural."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Efeitos de Frequências Baixas na Suavização de Tendências",
                                  "subSteps": [
                                    "Agregue dados diários para mensais usando resample (média, soma).",
                                    "Plote dados originais vs. agregados para observar suavização.",
                                    "Meça redução na variância pós-agregação.",
                                    "Identifique como tendências e sazonalidade ficam mais evidentes.",
                                    "Compare múltiplos níveis de agregação (semanal, mensal, trimestral)."
                                  ],
                                  "verification": "Produza gráficos comparativos e calcule redução percentual de variância.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python (Pandas resample), mesmo conjunto de dados do step 2.",
                                  "tips": "Escolha funções de agregação adequadas: média para tendências, soma para totais.",
                                  "learningObjective": "Demonstrar como agregação baixa frequência suaviza ruído e realça padrões.",
                                  "commonMistakes": "Perder informação sazonal fina ao agregar excessivamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Análise de Impactos com Exemplos de Agregação Prática",
                                  "subSteps": [
                                    "Selecione dataset real (ex: vendas diárias).",
                                    "Agregue diário para mensal e analise mudanças em ruído/tendência.",
                                    "Crie relatório comparativo com métricas (autocorrelação, variância).",
                                    "Teste hipóteses: 'Agregação reduz ruído em X%'.",
                                    "Documente escolhas de frequência baseadas em objetivos analíticos."
                                  ],
                                  "verification": "Entregue relatório com gráficos, métricas e conclusões sobre impactos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Jupyter Notebook, datasets públicos (Kaggle: daily sales time series).",
                                  "tips": "Sempre valide agregações com domínio do problema (ex: soma para contagens).",
                                  "learningObjective": "Integrar análise de frequência em fluxos de análise de séries temporais.",
                                  "commonMistakes": "Agregar sem considerar perdas de granularidade útil para previsões."
                                }
                              ],
                              "practicalExample": "Em dados de vendas diárias de uma loja online, frequência alta (diária) mostra ruído de fins de semana e promoções isoladas; agregando para mensal suaviza ruído, revelando tendência de crescimento sazonal de verão, facilitando previsões.",
                              "finalVerifications": [
                                "Explicar corretamente ruído em alta frequência vs. suavização em baixa.",
                                "Gerar gráficos comparativos de dados antes/depois agregação.",
                                "Calcular e interpretar métricas como variância reduzida (>20%).",
                                "Identificar tendência/sazonalidade em dados agregados.",
                                "Propor frequência ideal para um cenário dado.",
                                "Relatório escrito sem erros conceituais."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (ruído/suavização): 30%",
                                "Qualidade de visualizações e cálculos: 25%",
                                "Profundidade de análise de impactos: 20%",
                                "Relevância de exemplos práticos: 15%",
                                "Clareza e estrutura do relatório: 10%"
                              ],
                              "crossCurricularConnections": [
                                "Economia: Agregação em PIB trimestral para análise macroeconômica.",
                                "Física: Amostragem em sinais (Nyquist) para evitar aliasing.",
                                "Biologia: Dados de monitoramento ambiental (diário vs. anual).",
                                "Finanças: Volatilidade em retornos diários vs. mensais."
                              ],
                              "realWorldApplication": "Em previsão de demanda para supply chain, usar frequência mensal em vez de diária reduz ruído de variações climáticas isoladas, melhorando modelos de forecasting em 15-30% de precisão."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.3.3",
                            "name": "Converter frequências básicas",
                            "description": "Realizar resampling simples de uma série de alta para baixa frequência (ex: diária para mensal via média ou soma), usando ferramentas como R ou Python.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o Ambiente e Carregar os Dados",
                                  "subSteps": [
                                    "Instale as bibliotecas necessárias: pandas e, opcionalmente, matplotlib para visualização.",
                                    "Carregue um dataset de série temporal de alta frequência (ex: dados diários de vendas em CSV).",
                                    "Converta a coluna de data em índice datetime usando pd.to_datetime().",
                                    "Inspecione os dados com info(), head() e plot() para verificar frequência inicial.",
                                    "Trate valores ausentes com fillna() ou dropna() se necessário."
                                  ],
                                  "verification": "Execute df.info() e confirme que o índice é DatetimeIndex com frequência diária e sem erros de parsing.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "Bibliotecas: pandas, matplotlib",
                                    "Dataset exemplo: vendas_diarias.csv"
                                  ],
                                  "tips": "Sempre defina infer_datetime_format=True para acelerar o parsing em datasets grandes.",
                                  "learningObjective": "Configurar corretamente um ambiente Python para manipulação de séries temporais.",
                                  "commonMistakes": [
                                    "Não converter índice para datetime",
                                    "Ignorar valores NaN iniciais",
                                    "Usar colunas erradas como índice"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Frequência Alvo e Método de Agregação",
                                  "subSteps": [
                                    "Escolha a nova frequência: 'M' para mensal, 'W' para semanal, etc.",
                                    "Decida o método: 'sum()' para totais (ex: vendas), 'mean()' para médias (ex: temperaturas).",
                                    "Considere downsampling: alta para baixa frequência apenas.",
                                    "Teste em um subset pequeno: df_subset.resample('M').sum().head().",
                                    "Documente a escolha em um comentário no código."
                                  ],
                                  "verification": "Crie um resample teste e confirme que o output tem o número correto de períodos (ex: 365 dias -> 12 meses).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Documentação pandas: https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.resample.html"
                                  ],
                                  "tips": "Use 'sum()' para contagens acumulativas e 'mean()' para médias; evite 'first()'/'last()' sem motivo.",
                                  "learningObjective": "Selecionar apropriadamente métodos de agregação baseados no contexto dos dados.",
                                  "commonMistakes": [
                                    "Escolher frequência errada (ex: 'M' em dados semanais)",
                                    "Usar upsampling acidentalmente",
                                    "Ignorar o tipo de dado (contínuo vs discreto)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar o Resampling",
                                  "subSteps": [
                                    "Aplique resample(): df_resampled = df.resample('M').agg({'valor': 'sum'}).",
                                    "Para múltiplas colunas: use dict de agregações, ex: {'vendas': 'sum', 'preco': 'mean'}.",
                                    "Reset_index() se necessário para manipulações futuras.",
                                    "Salve o resultado em novo CSV: df_resampled.to_csv('vendas_mensais.csv').",
                                    "Compare estatísticas descritivas antes/depois com describe()."
                                  ],
                                  "verification": "Verifique se soma dos valores mensais equals soma original por período manualmente em 2-3 meses.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notebook Jupyter para testes interativos"
                                  ],
                                  "tips": "Use .agg() para flexibilidade em múltiplas colunas; chain métodos como .resample('M').sum().dropna().",
                                  "learningObjective": "Implementar resampling preciso em Python com pandas.",
                                  "commonMistakes": [
                                    "Resample sem índice datetime",
                                    "Agregação errada (sum em médias)",
                                    "Perder dados no reset_index"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Visualizar Resultados",
                                  "subSteps": [
                                    "Plote original vs resampled: df.plot() e df_resampled.plot().",
                                    "Calcule métricas: diff em somas totais deve ser zero.",
                                    "Teste edge cases: fim de mês com dias incompletos.",
                                    "Gere relatório: print(f'Redução de {len(df)} para {len(df_resampled)} observações').",
                                    "Compare com função equivalente em R (zoo::aggregate) se aplicável."
                                  ],
                                  "verification": "Gráficos mostram agregação suave sem discrepâncias; soma total preservada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Matplotlib ou seaborn para plots"
                                  ],
                                  "tips": "Use subplots para comparar side-by-side: fig, ax = plt.subplots(2,1).",
                                  "learningObjective": "Garantir integridade dos dados pós-resampling via visualização e métricas.",
                                  "commonMistakes": [
                                    "Não validar soma total",
                                    "Ignorar fins de período irregulares",
                                    "Plots sem labels"
                                  ]
                                }
                              ],
                              "practicalExample": "Carregue dados diários de vendas de uma loja (vendas_diarias.csv com colunas 'data' e 'vendas'). Converta para mensal somando 'vendas' com df.resample('M').sum(), resultando em 12 observações mensais onde Janeiro soma os 31 dias de vendas diárias.",
                              "finalVerifications": [
                                "Dataset resampled tem frequência mensal confirmada via df.index.freq.",
                                "Soma total dos valores originais equals soma dos resampled.",
                                "Sem NaNs em períodos completos; shape reduzido corretamente (ex: 365 -> 12).",
                                "Visualizações mostram tendência preservada sem artefatos.",
                                "Código roda sem erros em dataset de teste independente.",
                                "Exportação CSV mantém tipos de dados corretos."
                              ],
                              "assessmentCriteria": [
                                "Precisão da agregação: erros < 0.1% em validações manuais.",
                                "Eficiência do código: usa resample() nativo sem loops.",
                                "Tratamento robusto de edge cases (feriados, meses curtos).",
                                "Documentação clara com comentários e prints informativos.",
                                "Visualizações profissionais com títulos, labels e escalas.",
                                "Adaptabilidade: funciona para mean() e múltiplas colunas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estatística descritiva e funções de agregação (média, soma).",
                                "Programação: Manipulação de dados em Python/pandas e indexação avançada.",
                                "Economia/Finanças: Análise de indicadores temporais como PIB mensal ou balanços.",
                                "Ciências Ambientais: Agregação de dados climáticos diários para relatórios anuais.",
                                "Engenharia de Software: Boas práticas de validação e testes unitários em dados."
                              ],
                              "realWorldApplication": "Em análise financeira, converter transações diárias de ações para retornos mensais para relatórios de portfólio; em meteorologia, agregar precipitação diária para médias sazonais em previsões climáticas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.2",
                    "name": "Importação de Dados Temporais",
                    "description": "Métodos e ferramentas para importar dados temporais de fontes variadas, incluindo arquivos CSV, Excel e bancos de dados.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.2.1",
                        "name": "Importação de Dados Temporais de Arquivos CSV",
                        "description": "Técnicas para carregar dados temporais de arquivos CSV utilizando ferramentas como R, garantindo a correta interpretação de componentes temporais como datas e horários.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.1.1",
                            "name": "Utilizar read.csv() para importar CSV",
                            "description": "Aplicar a função read.csv() no R para ler arquivos CSV em um data.frame, especificando parâmetros como sep, dec e stringsAsFactors para lidar com formatos comuns de séries temporais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente R e o arquivo CSV de teste",
                                  "subSteps": [
                                    "Instale e abra o R ou RStudio.",
                                    "Crie um diretório de trabalho com setwd() ou via interface gráfica.",
                                    "Baixe ou crie um arquivo CSV de séries temporais simples (ex: datas e valores numéricos).",
                                    "Verifique o caminho do arquivo com file.exists().",
                                    "Explore o arquivo no editor de texto para notar separadores (vírgula, ponto-vírgula) e decimais (ponto ou vírgula)."
                                  ],
                                  "verification": "Confirme que o R está rodando, diretório setado e arquivo acessível sem erros.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "R ou RStudio instalado",
                                    "Arquivo CSV de exemplo (ex: temperaturas_diarias.csv)"
                                  ],
                                  "tips": "Use getwd() para verificar o diretório atual e normalizePath() para caminhos absolutos.",
                                  "learningObjective": "Configurar ambiente para importação confiável de dados.",
                                  "commonMistakes": [
                                    "Esquecer de setar o diretório de trabalho",
                                    "Caminho de arquivo incorreto com barras invertidas no Windows",
                                    "Arquivo CSV corrompido ou com encoding errado"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar importação básica com read.csv()",
                                  "subSteps": [
                                    "Digite o comando básico: meu_df <- read.csv('arquivo.csv').",
                                    "Atribua o resultado a um objeto data.frame.",
                                    "Use View(meu_df) ou head(meu_df) para inspecionar.",
                                    "Verifique a estrutura com str(meu_df) e dim(meu_df).",
                                    "Salve o workspace com save.image() para preservar o data.frame."
                                  ],
                                  "verification": "Data.frame criado sem erros, com head() mostrando dados corretos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Arquivo CSV preparado",
                                    "Console R ativo"
                                  ],
                                  "tips": "Sempre use aspas no nome do arquivo e atribuição <- para o data.frame.",
                                  "learningObjective": "Dominar a sintaxe essencial de read.csv() para CSVs padrão.",
                                  "commonMistakes": [
                                    "Omitir aspas no filepath",
                                    "Não atribuir a um objeto",
                                    "Confundir read.csv() com read.table()"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar parâmetros chave: sep, dec e stringsAsFactors",
                                  "subSteps": [
                                    "Identifique o separador no CSV (sep = ';') se não for vírgula.",
                                    "Ajuste decimal (dec = ',') para CSVs europeus.",
                                    "Defina stringsAsFactors = FALSE para evitar fatores automáticos em séries temporais.",
                                    "Teste: meu_df <- read.csv('arquivo.csv', sep=';', dec=',', stringsAsFactors=FALSE).",
                                    "Compare str() antes e depois para validar mudanças."
                                  ],
                                  "verification": "str(meu_df) mostra colunas numéricas corretas e strings como character.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "CSV com formatos não padrão",
                                    "Documentação read.csv() via ?read.csv"
                                  ],
                                  "tips": "Use count.fields() para detectar separadores reais no arquivo.",
                                  "learningObjective": "Personalizar read.csv() para formatos variados de dados temporais.",
                                  "commonMistakes": [
                                    "Ignorar sep levando a uma coluna única",
                                    "dec errado causando NAs em números",
                                    "stringsAsFactors=TRUE poluindo análises temporais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar integridade e preparar para análise de séries temporais",
                                  "subSteps": [
                                    "Cheque NAs com summary(meu_df) e complete.cases().",
                                    "Converta coluna de data para POSIXct ou Date com as.Date().",
                                    "Verifique ordem temporal com order() ou is.unsorted().",
                                    "Salve o data.frame limpo como RDS com saveRDS().",
                                    "Teste subsetting básico: meu_df[1:10, ] para validação."
                                  ],
                                  "verification": "Sem NAs inesperados, datas formatadas corretamente e dados ordenados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Data.frame importado",
                                    "Pacote lubridate opcional para datas"
                                  ],
                                  "tips": "Carregue readr::read_csv() como alternativa mais robusta após dominar read.csv().",
                                  "learningObjective": "Garantir dados importados prontos para modelagem de séries temporais.",
                                  "commonMistakes": [
                                    "Datas como character não convertidas",
                                    "NAs não detectados em colunas numéricas",
                                    "Dados fora de ordem temporal"
                                  ]
                                }
                              ],
                              "practicalExample": "Baixe 'temperaturas_diarias.csv' com colunas Data (dd/mm/yyyy), Temp (com vírgula decimal) separadas por ';'. Use: temps <- read.csv('temperaturas_diarias.csv', sep=';', dec=',', stringsAsFactors=FALSE). Converta Data com as.Date(temps$Data, '%d/%m/%Y') para análise de tendências climáticas.",
                              "finalVerifications": [
                                "Data.frame importado com dim() mostrando linhas/colunas corretas.",
                                "str() confirma tipos: Date para tempo, numeric para valores.",
                                "summary() sem NAs excessivos (>5%).",
                                "head() e tail() exibem dados coerentes.",
                                "Arquivo salvo como RDS e recarregado com readRDS() sem perda.",
                                "Subsetting temporal funciona: temps[temps$Data > '2023-01-01', ]."
                              ],
                              "assessmentCriteria": [
                                "Execução sem erros de sintaxe ou filepath (100% sucesso).",
                                "Parâmetros sep/dec ajustados corretamente para o CSV dado (tipos numéricos preservados).",
                                "stringsAsFactors=FALSE aplicado, evitando fatores desnecessários.",
                                "Verificações pós-importação (str, summary) identificam e resolvem issues.",
                                "Data.frame pronto para ts() ou xts() em séries temporais.",
                                "Tempo total <60 minutos com explicação clara do processo."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Entender funções e argumentos em linguagens como Python (pandas.read_csv).",
                                "Estatística: Preparação de dados para modelagem (ARIMA, forecasting).",
                                "Ciência de Dados: ETL (Extract, Transform, Load) pipelines.",
                                "Matemática: Manipulação de sequências temporais e vetores.",
                                "Informática: Gerenciamento de arquivos e encoding UTF-8."
                              ],
                              "realWorldApplication": "Em empresas de energia, importar CSVs de consumo horário para prever picos; em meteorologia, ler estações automáticas para alertas climáticos; ou em finanças, carregar cotações diárias para análise de risco, garantindo precisão em formatos regionais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.2",
                            "name": "Converter colunas de data em formatos temporais",
                            "description": "Identificar colunas de data/hora em dados importados e usar funções como as.Date(), as.POSIXct() ou parse_date_time() do pacote lubridate para converter strings em objetos temporais válidos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Inspecionar o Dataset para Identificar Colunas de Data/Hora",
                                  "subSteps": [
                                    "Carregue o arquivo CSV usando read.csv() ou readr::read_csv().",
                                    "Execute str(df) ou glimpse(df) para visualizar a estrutura e classes das colunas.",
                                    "Use head(df) e tail(df) para inspecionar visualmente as primeiras e últimas linhas.",
                                    "Identifique padrões como sequências de números com separadores (/ , - , espaços) ou abreviações de meses.",
                                    "Liste as colunas suspeitas em um vetor para referência futura."
                                  ],
                                  "verification": "Lista de colunas candidatas a data/hora criada e confirmada visualmente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "RStudio ou R console",
                                    "Arquivo CSV de exemplo com dados temporais",
                                    "Pacotes base R ou tidyverse"
                                  ],
                                  "tips": "Filtre colunas com unique(df$coluna) para padrões rápidos; ignore colunas puramente numéricas sem contexto temporal.",
                                  "learningObjective": "Desenvolver habilidade para detectar dados temporais não formatados em datasets importados.",
                                  "commonMistakes": [
                                    "Confundir códigos numéricos com datas",
                                    "Ignorar colunas com timestamps parciais",
                                    "Não verificar linhas finais por inconsistências"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar e Documentar Formatos de Data nas Colunas Identificadas",
                                  "subSteps": [
                                    "Extraia amostras únicas com unique(df$coluna_data[1:20]) ou table(df$coluna_data).",
                                    "Identifique separadores (%d/%m/%Y, %Y-%m-%d, etc.) e ordem (dia-mês-ano, ano-mês-dia).",
                                    "Teste formatos preliminares com as.Date(df$coluna_data[1], format=\"%d/%m/%Y\").",
                                    "Registre o formato exato para cada coluna em um comentário ou vetor de formatos.",
                                    "Verifique por variações (ex: alguns com hora) usando grepl() para padrões regex."
                                  ],
                                  "verification": "Formato padronizado documentado para cada coluna de data.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Dataset carregado",
                                    "Documentação em script R"
                                  ],
                                  "tips": "Use strptime() para testes interativos; memorize formatos comuns como %Y-%m-%d para ISO.",
                                  "learningObjective": "Aprender a decifrar e padronizar strings de data ambíguas.",
                                  "commonMistakes": [
                                    "Assumir formato único sem amostragem",
                                    "Confundir mdy com dmy",
                                    "Ignorar fusos horários em timestamps"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Funções de Conversão para Objetos Temporais",
                                  "subSteps": [
                                    "Instale e carregue lubridate se necessário: install.packages('lubridate'); library(lubridate).",
                                    "Para base R: df$coluna_data <- as.Date(df$coluna_data, format=\"%d/%m/%Y\").",
                                    "Para lubridate: df$coluna_data <- parse_date_time(df$coluna_data, orders=c('dmy', 'ymd')).",
                                    "Para timestamps: use as.POSIXct() ou ymd_hms() do lubridate.",
                                    "Aplique a múltiplas colunas com lapply() ou across() no dplyr."
                                  ],
                                  "verification": "class(df$coluna_data) retorna 'Date' ou 'POSIXct'; primeiras linhas mostram objetos data válidos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Pacote lubridate",
                                    "Script R com dataset modificado"
                                  ],
                                  "tips": "Sempre especifique tz='UTC' para POSIXct; use guess_format() do lubridate para auto-detecção.",
                                  "learningObjective": "Dominar funções chave para conversão precisa de strings em objetos temporais.",
                                  "commonMistakes": [
                                    "Esquecer format= levando a NAs",
                                    "Não carregar lubridate antes do uso",
                                    "Misturar Date e POSIXct sem necessidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Conversão e Lidar com Erros ou Inconsistências",
                                  "subSteps": [
                                    "Execute summary(df$coluna_data) e class(df$coluna_data) para métricas básicas.",
                                    "Identifique NAs com sum(is.na(df$coluna_data)) e isole linhas problemáticas.",
                                    "Crie plots como plot(df$coluna_data) ou hist(df$coluna_data) para visualização cronológica.",
                                    "Corrija formatos mistos subdividindo com ifelse() ou funções customizadas.",
                                    "Salve o dataset convertido e teste operações como difftime()."
                                  ],
                                  "verification": "Zero ou mínimo NAs explicados; plotagem mostra sequência temporal coerente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "ggplot2 para plots avançados",
                                    "Dataset convertido"
                                  ],
                                  "tips": "Use na.omit() temporariamente para análise; documente correções em um log.",
                                  "learningObjective": "Garantir integridade dos dados temporais pós-conversão.",
                                  "commonMistakes": [
                                    "Ignorar NAs silenciosamente",
                                    "Não testar aritmética temporal",
                                    "Plotar sem ordenar por data"
                                  ]
                                }
                              ],
                              "practicalExample": "Carregue um CSV de vendas com coluna 'data_venda' como '01/12/2023'. Aplique: library(lubridate); df$data_venda <- dmy(df$data_venda). Verifique: class(df$data_venda) == 'Date'; plot(df$data_venda, df$vendas, type='l') mostra tendência temporal sem gaps.",
                              "finalVerifications": [
                                "Todas colunas de data têm classe Date ou POSIXct.",
                                "sum(is.na(df$coluna_data)) < 5% dos dados originais.",
                                "Datas mínima e máxima fazem sentido no contexto do dataset.",
                                "Operações como mean(diff(df$coluna_data)) executam sem erros.",
                                "Plot temporal revela padrões lógicos sem anomalias.",
                                "Dataset salvo em RDS preserva classes temporais."
                              ],
                              "assessmentCriteria": [
                                "Identificação precisa de 100% das colunas temporais.",
                                "Conversão sem introduzir mais de 2% NAs.",
                                "Uso correto de pelo menos duas funções (base R + lubridate).",
                                "Verificações finais documentadas no script.",
                                "Código reproduzível e comentado.",
                                "Aplicação bem-sucedida a múltiplas colunas."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Preparação para modelagem de séries temporais (ARIMA, forecasting).",
                                "Programação: Manipulação de dados com tidyverse e funções vetoriais.",
                                "Matemática: Cálculos de intervalos e diferenças temporais.",
                                "Ciência de Dados: Integração com visualizações (ggplot2 timelines).",
                                "Gestão de Projetos: Limpeza de dados para relatórios analíticos."
                              ],
                              "realWorldApplication": "Em finanças, converter datas de transações para calcular retornos diários; em saúde pública, transformar registros de casos para mapear surtos temporais; em logística, analisar prazos de entrega de CSVs de envios para otimizar rotas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.3",
                            "name": "Lidar com formatos de data irregulares em CSV",
                            "description": "Diagnosticar e corrigir problemas em formatos de data variados (ex.: DD/MM/YYYY vs MM/DD/YYYY) usando strptime() ou lubridate::dmy(), garantindo consistência para análise de séries temporais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Inspeção e Diagnóstico dos Formatos Irregulares",
                                  "subSteps": [
                                    "Carregue o arquivo CSV usando pandas.read_csv() em Python ou read_csv() em R.",
                                    "Examine a coluna de datas com funções como head(), tail() e sample().",
                                    "Identifique padrões irregulares (ex.: DD/MM/YYYY, MM/DD/YYYY, YYYY-MM-DD) usando str() ou unique().",
                                    "Conte a frequência de cada formato com value_counts() ou table().",
                                    "Registre formatos únicos e potenciais ambiguidades (ex.: 01/02/2020 pode ser 1º fev ou 2º jan)."
                                  ],
                                  "verification": "Lista de formatos únicos gerada e frequências documentadas sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python com pandas",
                                    "R com readr e dplyr",
                                    "Arquivo CSV de exemplo com datas irregulares"
                                  ],
                                  "tips": "Use print(df['data_coluna'].dtype) para verificar tipo inicial e evitar suposições.",
                                  "learningObjective": "Diagnosticar precisamente irregularidades em colunas de data de CSVs.",
                                  "commonMistakes": [
                                    "Não inspecionar amostras representativas",
                                    "Ignorar valores NA ou inválidos",
                                    "Confundir formatos sem contar frequências"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Seleção e Teste de Funções de Parsing",
                                  "subSteps": [
                                    "Escolha strptime() em Python ou dmy()/mdy() no lubridate para R baseado nos formatos detectados.",
                                    "Teste parsing em subconjuntos com pd.to_datetime(format='%d/%m/%Y') ou dmy(data_coluna).",
                                    "Compare resultados entre múltiplos formatos para resolver ambiguidades.",
                                    "Crie uma função personalizada que tenta múltiplos formatos sequencialmente.",
                                    "Registre taxas de sucesso (sem NA) para cada tentativa."
                                  ],
                                  "verification": "Função de parsing testada com >95% de sucesso em subconjunto de teste.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação de strptime() e lubridate",
                                    "Jupyter Notebook ou RStudio"
                                  ],
                                  "tips": "Use coerce = FALSE no lubridate para diagnosticar falhas sem forçar conversões.",
                                  "learningObjective": "Selecionar e testar estratégias de parsing adequadas para formatos variados.",
                                  "commonMistakes": [
                                    "Usar formato único sem testes",
                                    "Ignorar zonas horárias implícitas",
                                    "Não tratar ambiguidades como 05/04"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicação do Parsing e Padronização",
                                  "subSteps": [
                                    "Aplique a função escolhida a toda a coluna com pd.to_datetime() ou parse_date_time().",
                                    "Padronize para formato consistente (ex.: YYYY-MM-DD) usando format() ou as.Date().",
                                    "Substitua a coluna original pela parseada no DataFrame.",
                                    "Trate resíduos (NAs restantes) com imputação ou remoção flagged.",
                                    "Salve o CSV corrigido com write_csv()."
                                  ],
                                  "verification": "Coluna de datas convertida para datetime sem perda significativa de dados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "DataFrame corrigido",
                                    "Função de parsing validada"
                                  ],
                                  "tips": "Use errors='coerce' para converter falhas em NA e rastreá-las depois.",
                                  "learningObjective": "Corrigir e padronizar datas irregulares garantindo consistência.",
                                  "commonMistakes": [
                                    "Sobrescrever dados originais sem backup",
                                    "Não padronizar para UTC",
                                    "Perder dados sem logging"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validação Final e Preparação para Análise",
                                  "subSteps": [
                                    "Verifique tipos com dtype ou class() e range de datas com min/max.",
                                    "Plote a série temporal corrigida para detectar gaps ou anomalias.",
                                    "Teste ordenação e agregações temporais (ex.: resample por mês).",
                                    "Compare estatísticas antes/depois (ex.: número de NAs).",
                                    "Documente o processo em um relatório ou comentário no script."
                                  ],
                                  "verification": "Séries temporais plotadas corretamente sem erros de parsing.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Bibliotecas de plotagem como matplotlib/ggplot2",
                                    "Script de análise inicial"
                                  ],
                                  "tips": "Use summary() ou describe() para stats rápidas de validação.",
                                  "learningObjective": "Validar correções garantindo readiness para análise de séries temporais.",
                                  "commonMistakes": [
                                    "Não plotar para visual check",
                                    "Ignorar outliers temporais",
                                    "Pular comparação pré/pós"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um CSV de vendas diárias de uma rede varejista, datas misturam '25/12/2023' (DD/MM/YYYY europeu) e '12/25/2023' (MM/DD/YYYY americano). Use pd.to_datetime(df['data'], format='%d/%m/%Y', errors='coerce') para europeias e alternar com '%m/%d/%Y' via função condicional, padronizando para '2023-12-25', permitindo plot de vendas por mês sem gaps.",
                              "finalVerifications": [
                                "100% das datas válidas parseadas sem NA introduzidos pelo parsing.",
                                "Todas as datas em formato consistente (ex.: datetime64 ou POSIXct).",
                                "Range temporal cobre o período esperado sem anomalias.",
                                "Agregações temporais (soma por mês) executam sem erros.",
                                "Plot da série temporal mostra continuidade lógica.",
                                "Número de linhas preservado ou perda mínima justificada."
                              ],
                              "assessmentCriteria": [
                                "Diagnóstico preciso identifica >90% dos formatos irregulares.",
                                "Função de parsing escolhida resolve ambiguidades corretamente.",
                                "Padronização mantém integridade dos dados originais.",
                                "Validação inclui testes visuais e estatísticos.",
                                "Documentação clara do processo e decisões tomadas.",
                                "Eficiência: tempo total <1h para dataset médio (10k linhas)."
                              ],
                              "crossCurricularConnections": [
                                "Programação em Python/R (manipulação de strings e datas).",
                                "Estatística Descritiva (diagnóstico de dados e validação).",
                                "Gestão de Dados (limpeza e ETL).",
                                "Matemática (tratamento de séries temporais).",
                                "Informática (importação e exportação de arquivos)."
                              ],
                              "realWorldApplication": "Em análises financeiras de transações bancárias com datas de fontes internacionais variadas, corrige formatos para calcular retornos acumulados precisos e detectar fraudes temporais; ou em saúde pública, uniformiza datas de vacinação de CSVs regionais para rastrear coberturas vacinais ao longo do tempo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.2",
                        "name": "Importação de Dados Temporais de Arquivos Excel",
                        "description": "Métodos para extrair dados temporais de planilhas Excel com preservação de índices temporais, utilizando pacotes especializados em R.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.2.1",
                            "name": "Instalar e usar readxl para ler Excel",
                            "description": "Instalar o pacote readxl e aplicar read_excel() ou read_xlsx() para importar planilhas Excel específicas, selecionando sheets e ranges relevantes para dados temporais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Instalar e carregar o pacote readxl",
                                  "subSteps": [
                                    "Abra o R ou RStudio em seu ambiente de trabalho.",
                                    "Execute o comando `install.packages(\"readxl\")` no console.",
                                    "Após a instalação, execute `library(readxl)` para carregar o pacote.",
                                    "Verifique a instalação com `packageVersion(\"readxl\")` para confirmar a versão ativa.",
                                    "Teste um comando básico como `readxl_example()` para validar o carregamento."
                                  ],
                                  "verification": "O pacote carrega sem erros e `packageVersion(\"readxl\")` retorna uma versão válida (ex: 1.4.0).",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "R ou RStudio instalado",
                                    "Conexão à internet"
                                  ],
                                  "tips": "Sempre use aspas duplas ou simples no nome do pacote; reinicie a sessão R se houver conflitos.",
                                  "learningObjective": "Dominar a instalação e carregamento de pacotes R essenciais para manipulação de dados.",
                                  "commonMistakes": [
                                    "Esquecer aspas no nome do pacote",
                                    "Executar install.packages sem internet",
                                    "Não recarregar library após instalação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar e explorar a estrutura do arquivo Excel",
                                  "subSteps": [
                                    "Crie ou baixe um arquivo Excel de exemplo com dados temporais (ex: colunas 'Data' e 'Valor', em sheet 'SerieTemporal').",
                                    "Defina o caminho completo do arquivo: `arquivo <- \"caminho/para/exemplo.xlsx\"`.",
                                    "Liste as sheets disponíveis com `excel_sheets(arquivo)`.",
                                    "Inspecione dimensões sem ler dados: `read_excel(arquivo, n_max = 0)`.",
                                    "Visualize nomes de colunas: `colnames(read_excel(arquivo, n_max = 1))`."
                                  ],
                                  "verification": "Sheets e colunas são listados corretamente, sem erros de caminho de arquivo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Arquivo Excel de exemplo com dados temporais (ex: exemplo.xlsx)"
                                  ],
                                  "tips": "Use caminhos absolutos para evitar erros; teste com `file.exists(arquivo)` antes.",
                                  "learningObjective": "Explorar metadados de arquivos Excel para planejar importações eficientes.",
                                  "commonMistakes": [
                                    "Caminho de arquivo incorreto ou com barras invertidas",
                                    "Arquivo aberto no Excel simultaneamente",
                                    "Ignorar sheets múltiplas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Ler planilha Excel básica completa",
                                  "subSteps": [
                                    "Execute `dados <- read_excel(arquivo)` para importar toda a sheet padrão.",
                                    "Inspecione os dados com `head(dados)` e `str(dados)` para verificar tipos.",
                                    "Converta coluna de data se necessário: `dados$Data <- as.Date(dados$Data)`.",
                                    "Verifique dimensões com `dim(dados)` e resumo com `summary(dados)`.",
                                    "Salve uma cópia: `write.csv(dados, \"dados_importados.csv\", row.names = FALSE)`."
                                  ],
                                  "verification": "Data.frame `dados` é criado com dimensões corretas e datas reconhecidas como classe Date.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Arquivo Excel preparado do Step 2"
                                  ],
                                  "tips": "Use `na = \"NA\"` no read_excel para tratar valores missing explicitamente.",
                                  "learningObjective": "Importar e validar dados temporais de Excel de forma completa e confiável.",
                                  "commonMistakes": [
                                    "Datas importadas como character em vez de Date",
                                    "Ignorar NAs ou linhas vazias",
                                    "Não inspecionar str() após importação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ler sheet específica e range selecionado",
                                  "subSteps": [
                                    "Importe sheet específica: `dados_sheet <- read_excel(arquivo, sheet = \"SerieTemporal\")`.",
                                    "Selecione range: `dados_range <- read_excel(arquivo, range = \"A1:F100\")`.",
                                    "Combine: `dados_final <- read_excel(arquivo, sheet = 2, range = \"B2:E200\", col_types = c(\"date\", \"numeric\"))`.",
                                    "Valide seleção com `nrow(dados_final)` e `head(dados_final)`.",
                                    "Ajuste para séries temporais: `ts_data <- ts(dados_final$Valor, start = c(2020,1), frequency = 12)`."
                                  ],
                                  "verification": "Dados importados correspondem exatamente ao range/sheet especificado, com tipos corretos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Arquivo Excel com múltiplas sheets do Step 2"
                                  ],
                                  "tips": "Use índices numéricos para sheets (ex: sheet=2) ou nomes; especifique col_types para consistência.",
                                  "learningObjective": "Aplicar seleções avançadas para importar subconjuntos otimizados de dados temporais.",
                                  "commonMistakes": [
                                    "Range inválido causando erro",
                                    "Sheet por nome com case-sensitive",
                                    "Colunas erradas sem col_types"
                                  ]
                                }
                              ],
                              "practicalExample": "Baixe 'vendas_mensais.xlsx' com sheets '2023' e '2024'. Use `read_excel(\"vendas_mensais.xlsx\", sheet = \"2023\", range = \"A1:C13\")` para importar 12 meses de vendas (coluna A: datas, B: vendas, C: região), convertendo datas para análise de sazonalidade.",
                              "finalVerifications": [
                                "Pacote readxl está instalado e carrega sem warnings.",
                                "Todas as sheets e ranges são acessíveis e importados corretamente.",
                                "Colunas de data são classe Date e numéricas são numeric.",
                                "Data.frame final tem dimensões esperadas (ex: 100 linhas, 4 colunas).",
                                "Não há NAs inesperados ou erros de parsing.",
                                "Dados podem ser convertidos em ts() ou xts() para séries temporais."
                              ],
                              "assessmentCriteria": [
                                "Código executa sem erros ou warnings em ambiente limpo.",
                                "Seleções de sheet/range importam subconjuntos precisos.",
                                "Tipos de dados são corretos (Date para temporais, numeric para valores).",
                                "Inspeções (head, str, dim) confirmam integridade dos dados.",
                                "Aplicação em ts() gera objeto válido para análise.",
                                "Tempo de execução é eficiente (<5s para arquivos médios)."
                              ],
                              "crossCurricularConnections": [
                                "Programação em R (TI e Computação Científica)",
                                "Estatística Descritiva (validação de dados importados)",
                                "Gerenciamento de Dados (bases relacionais e ETL)",
                                "Análise Financeira (importação de históricos para forecasting)"
                              ],
                              "realWorldApplication": "Em empresas de varejo, importar dados de vendas sazonais de relatórios Excel gerados pelo ERP para modelagem de séries temporais em previsões de estoque e demanda."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.2.2",
                            "name": "Tratar datas serializadas do Excel",
                            "description": "Converter números seriais do Excel (ex.: 44562 para data) em objetos Date usando as.Date() com origin='1899-12-30', corrigindo problemas comuns em séries temporais financeiras.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o formato de datas seriais do Excel",
                                  "subSteps": [
                                    "Estude a documentação oficial do Excel sobre armazenamento de datas como números inteiros (dias desde 1900-01-01 com ajuste para bug de ano bissexto em 1900).",
                                    "Identifique que o R requer origin='1899-12-30' para alinhar corretamente devido ao offset de 2 dias.",
                                    "Teste manualmente: calcule que 1 = 1900-01-01 no Excel, mas confirme em R com as.Date(1, origin='1899-12-30').",
                                    "Examine exemplos: 44562 deve converter para 2021-12-31."
                                  ],
                                  "verification": "Explique por escrito ou verbalmente por que origin='1899-12-30' é usado e converta manualmente 44562 para data.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Excel (support.microsoft.com)",
                                    "Console R ou RStudio",
                                    "Exemplo de número serial: 44562"
                                  ],
                                  "tips": [
                                    "Anote o bug do Excel: 1900 foi tratado como bissexto erroneamente.",
                                    "Use ?as.Date no R para referência rápida."
                                  ],
                                  "learningObjective": "Entender a mecânica de serialização de datas no Excel e sua compatibilidade com R.",
                                  "commonMistakes": [
                                    "Usar origin='1900-01-01' causando erro de 2 dias.",
                                    "Ignorar diferenças entre Windows e Mac Excel."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Importar dados do Excel para R",
                                  "subSteps": [
                                    "Instale e carregue pacotes necessários: install.packages('readxl'); library(readxl).",
                                    "Carregue o arquivo Excel: dados <- read_excel('seu_arquivo.xlsx').",
                                    "Inspecione a estrutura: str(dados); View(dados) para identificar colunas numéricas que representam datas.",
                                    "Identifique colunas afetadas: sapply(dados, class) para detectar numeric onde esperava Date."
                                  ],
                                  "verification": "Confirme que os dados foram importados corretamente e liste as colunas com valores numéricos grandes (ex.: >40000).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Pacote readxl",
                                    "Arquivo Excel de teste com datas seriais (crie um com datas de 2020-2022)",
                                    "RStudio"
                                  ],
                                  "tips": [
                                    "Use sheet=1 se múltiplas abas.",
                                    "Evite read.csv para Excel; prefira readxl para precisão."
                                  ],
                                  "learningObjective": "Importar corretamente dados temporais de Excel preservando números seriais.",
                                  "commonMistakes": [
                                    "Importar como character em vez de numeric.",
                                    "Esquecer de especificar na= para valores NA."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Converter números seriais em objetos Date",
                                  "subSteps": [
                                    "Selecione a coluna: datas_seriais <- dados$DataColuna.",
                                    "Aplique a conversão: datas_convertidas <- as.Date(datas_seriais, origin='1899-12-30').",
                                    "Atribua de volta ao dataframe: dados$DataColuna <- datas_convertidas.",
                                    "Verifique classes: class(dados$DataColuna) deve ser 'Date'.",
                                    "Trate múltiplas colunas com mutate do dplyr se necessário."
                                  ],
                                  "verification": "Execute head(dados$DataColuna) e confirme que 44562 virou '2021-12-31' ou similar.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Dataframe importado do step 2",
                                    "Pacote dplyr (opcional): library(dplyr)"
                                  ],
                                  "tips": [
                                    "Use format() para visualizar: format(datas_convertidas, '%Y-%m-%d').",
                                    "Teste com tz='' se issues de timezone."
                                  ],
                                  "learningObjective": "Executar conversão precisa de serial dates para Date objects em R.",
                                  "commonMistakes": [
                                    "Omitir origin causando datas erradas (ex.: 1900 em vez de 2022).",
                                    "Não tratar NAs: use na.rm=TRUE se aplicável."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e corrigir problemas em séries temporais financeiras",
                                  "subSteps": [
                                    "Verifique continuidade: diff(as.numeric(dados$DataColuna)) para detectar gaps.",
                                    "Identifique outliers: summary(dados$DataColuna); boxplot para datas fora do range esperado.",
                                    "Corrija gaps comuns em finanças (feriados): use seq.Date() para preencher ou padronizar.",
                                    "Plote a série: plot(dados$DataColuna, dados$Preco, type='l') para visual inspeção.",
                                    "Salve o dataframe corrigido: write.csv(dados, 'dados_corrigidos.csv')."
                                  ],
                                  "verification": "Gere um plot sem gaps e confirme que as datas alinham com eventos conhecidos (ex.: crash de mercado).",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Dataframe convertido",
                                    "Pacotes ggplot2 ou base plot"
                                  ],
                                  "tips": [
                                    "Em finanças, use business days: library(bizdays).",
                                    "Sempre valide com dados conhecidos."
                                  ],
                                  "learningObjective": "Garantir integridade de séries temporais financeiras pós-conversão.",
                                  "commonMistakes": [
                                    "Ignorar gaps de fins de semana/feriados.",
                                    "Plotar sem conversão levando a eixo X errado."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um dataset de preços diários de ações (ex.: PETR4 do Excel), coluna 'Date' mostra 44562, 44563,... Converta para Date, preencha gap de feriado e plote ts <- ts(dados$Preco, start=min(dados$DataColuna)) para análise de volatilidade.",
                              "finalVerifications": [
                                "Converter 44562 corretamente para 2021-12-31.",
                                "Identificar e explicar gap de 3 dias em série semanal.",
                                "Gerar plot de linha com eixo Date correto sem distorções.",
                                "Salvar dataframe com classe Date confirmada via str().",
                                "Tratar NA em 10% dos dados sem crash.",
                                "Validar soma de dias entre datas específicas (ex.: 365 dias = 1 ano)."
                              ],
                              "assessmentCriteria": [
                                "Precisão da conversão: 100% das datas seriais mapeadas corretamente.",
                                "Detecção de issues: Identificar pelo menos 2 problemas comuns (gaps, NAs).",
                                "Eficiência: Código roda em <1min para 10k linhas.",
                                "Documentação: Comentários no código explicando origin.",
                                "Aplicação financeira: Plot mostra padrões reais como tendência de alta."
                              ],
                              "crossCurricularConnections": [
                                "Finanças: Preparação de dados para modelos ARIMA ou GARCH em séries temporais.",
                                "Matemática: Cálculos de elapsed time e diferenças de datas.",
                                "Programação: Manipulação de dataframes e funções vetoriais em R.",
                                "Estatística: Validação de hipóteses em dados temporais.",
                                "Economia: Análise de impactos de eventos em ativos financeiros."
                              ],
                              "realWorldApplication": "Analistas financeiros em bancos ou corretoras importam históricos de Excel para R, convertem datas seriais e constroem forecasts de risco, backtests de estratégias de trading ou relatórios regulatórios como CVM, evitando erros de US$ milhões por misdating."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.2.3",
                            "name": "Importar múltiplas abas com dados temporais",
                            "description": "Usar read_excel() com sheet para combinar dados de várias abas, aplicando transformações temporais unificadas para formar uma base integrada de séries temporais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e inspecionar o arquivo Excel",
                                  "subSteps": [
                                    "Instale e importe as bibliotecas necessárias: pandas e openpyxl.",
                                    "Carregue o arquivo Excel usando pd.ExcelFile() para listar as abas disponíveis.",
                                    "Inspecione as primeiras linhas de cada aba com head() e info() para entender a estrutura temporal (colunas de data, formato inconsistente).",
                                    "Identifique padrões temporais comuns, como colunas de data em formatos diferentes (ex: DD/MM/YYYY vs YYYY-MM-DD).",
                                    "Crie um dicionário mapeando nomes de abas para suas estruturas de dados."
                                  ],
                                  "verification": "Confirme que o ExcelFile lista todas as abas corretamente e que head() de cada aba mostra dados temporais esperados sem erros de parsing.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Biblioteca pandas instalada",
                                    "Arquivo Excel de exemplo com múltiplas abas de séries temporais (ex: vendas_mensais.xlsx)"
                                  ],
                                  "tips": "Use pd.ExcelFile em vez de read_excel direto para eficiência em múltiplas abas; salve o arquivo em um diretório acessível.",
                                  "learningObjective": "Entender a estrutura do arquivo Excel e preparar para importações seletivas.",
                                  "commonMistakes": [
                                    "Esquecer de instalar openpyxl para arquivos .xlsx",
                                    "Não inspecionar formatos de data, levando a NaT (Not a Time)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Importar dados de múltiplas abas usando read_excel com sheet",
                                  "subSteps": [
                                    "Use um loop para ler cada aba especificada com pd.read_excel(excel_file, sheet_name=aba).",
                                    "Adicione um identificador de aba ou fonte como nova coluna (ex: df['fonte'] = 'Aba1').",
                                    "Armazene cada DataFrame em uma lista ou dicionário para processamento posterior.",
                                    "Verifique dimensões iniciais com shape e tipos de dados com dtypes.",
                                    "Salve DataFrames intermediários em variáveis nomeadas para depuração."
                                  ],
                                  "verification": "Cada aba é importada como DataFrame válido sem erros, com shape correto e coluna 'fonte' adicionada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "pandas",
                                    "Arquivo Excel preparado do step 1"
                                  ],
                                  "tips": "Use sheet_name=None para ler todas as abas de uma vez se o arquivo for pequeno; especifique index_col se houver índices temporais.",
                                  "learningObjective": "Dominar a importação parametrizada de abas múltiplas com metadados de origem.",
                                  "commonMistakes": [
                                    "Usar read_excel sem ExcelFile, causando recarga ineficiente",
                                    "Índices duplicados ao concatenar sem reset_index"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar transformações temporais unificadas",
                                  "subSteps": [
                                    "Padronize a coluna de data em todas as abas usando pd.to_datetime() com infer_datetime_format=True ou format específico.",
                                    "Defina a coluna de data como índice com set_index('data') e ordene com sort_index().",
                                    "Preencha lacunas temporais com resample() ou interpolate() se necessário para unificação.",
                                    "Renomeie colunas inconsistentes para um schema comum (ex: 'vendas' em todas as abas).",
                                    "Trate valores ausentes em séries temporais com ffill() ou dropna()."
                                  ],
                                  "verification": "Todas as colunas de data são datetime64[ns], índices ordenados cronologicamente e sem NaT.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "DataFrames das abas importadas",
                                    "Documentação pandas.to_datetime"
                                  ],
                                  "tips": "Use errors='coerce' em to_datetime para converter inválidos em NaT e tratá-los depois; freq='D' no resample para diário.",
                                  "learningObjective": "Unificar formatos temporais heterogêneos em uma estrutura consistente.",
                                  "commonMistakes": [
                                    "Ignorar fusos horários, causando offsets errados",
                                    "Não ordenar índice, levando a séries temporais bagunçadas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Combinar dados e validar a base integrada",
                                  "subSteps": [
                                    "Concatene todos os DataFrames tratados com pd.concat(dfs_list, axis=0, ignore_index=False).",
                                    "Reindexe para uma grade temporal completa com reindex(pd.date_range(start, end, freq='D')).",
                                    "Verifique integridade com isna().sum() e plot() para visualização rápida.",
                                    "Salve a base final como CSV ou novo Excel com to_csv() ou to_excel().",
                                    "Gere um resumo estatístico com describe() focado em métricas temporais."
                                  ],
                                  "verification": "DataFrame final tem shape esperado, índice temporal contínuo sem duplicatas (duplicated().sum() == 0) e salva corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "DataFrames transformados",
                                    "Jupyter Notebook para plots"
                                  ],
                                  "tips": "Use join='outer' em concat para preservar todos os dados; visualize com df.plot() para detectar anomalias.",
                                  "learningObjective": "Integrar e validar bases de séries temporais multi-fonte.",
                                  "commonMistakes": [
                                    "Concatenação sem sort_index, resultando em ordem errada",
                                    "Perda de dados por inner join acidental"
                                  ]
                                }
                              ],
                              "practicalExample": "Baixe um arquivo 'vendas_2023.xlsx' com abas 'Jan', 'Fev', 'Mar' contendo colunas 'Data' (formatos mistos) e 'Vendas'. Importe todas, unifique datas para datetime, concatene em um DF com índice diário e salve como 'vendas_integradas.csv'. Verifique com plot de vendas ao longo do tempo.",
                              "finalVerifications": [
                                "Índice temporal é datetime contínuo sem gaps ou duplicatas.",
                                "Todas as colunas numéricas são float/int sem NaN excessivos.",
                                "Shape final combina dimensões das abas originais.",
                                "pd.to_datetime funciona sem erros na base integrada.",
                                "Plot temporal mostra série suave sem quebras abruptas.",
                                "Arquivo salvo carrega corretamente com read_csv."
                              ],
                              "assessmentCriteria": [
                                "Eficiência: Loop de importação sem recargas desnecessárias.",
                                "Precisão temporal: 100% das datas parseadas corretamente.",
                                "Integridade: Sem perda de dados durante concatenação.",
                                "Validação: Uso de verificações como dtypes, isna(), duplicated().",
                                "Código limpo: Funções reutilizáveis e comentários explicativos.",
                                "Escalabilidade: Funciona para 5+ abas sem timeout."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Preparação de dados para modelagem ARIMA ou Prophet.",
                                "Programação: Manipulação avançada de loops e dicionários em Python.",
                                "Gestão de Dados: ETL (Extract, Transform, Load) em pipelines de BI.",
                                "Visualização: Integração com matplotlib/seaborn para séries temporais."
                              ],
                              "realWorldApplication": "Em análise financeira, importe abas mensais de extratos bancários de múltiplos anos em Excel, unifique datas e crie uma série temporal integrada para forecasting de caixa ou detecção de anomalias em transações."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.3",
                        "name": "Importação de Dados Temporais de Bancos de Dados",
                        "description": "Conexão e extração de dados temporais de bancos relacionais como SQL Server, PostgreSQL ou SQLite, com queries otimizadas para séries temporais.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.3.1",
                            "name": "Estabelecer conexão com banco via DBI",
                            "description": "Usar pacotes DBI e RSQLite/odbc para criar conexões com bancos de dados, testando autenticação e listando tabelas com dados temporais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Instalar e carregar pacotes necessários",
                                  "subSteps": [
                                    "Abra o R ou RStudio.",
                                    "Execute install.packages(c('DBI', 'RSQLite')) se não instalados.",
                                    "Carregue os pacotes com library(DBI) e library(RSQLite).",
                                    "Verifique a versão dos pacotes com packageVersion('DBI').",
                                    "Confirme que não há conflitos de pacotes."
                                  ],
                                  "verification": "Pacotes carregados sem erros e versões exibidas corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "R ou RStudio instalado",
                                    "Conexão à internet para instalação"
                                  ],
                                  "tips": "Use remotes::install_version() para versões específicas se necessário.",
                                  "learningObjective": "Configurar o ambiente R com pacotes DBI e RSQLite para conexões de banco.",
                                  "commonMistakes": [
                                    "Esquecer de recarregar pacotes após instalação",
                                    "Instalar pacotes errados como RMySQL em vez de RSQLite"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar parâmetros e credenciais de conexão",
                                  "subSteps": [
                                    "Crie um arquivo SQLite de exemplo: db <- dbConnect(RSQLite::SQLite(), dbname = 'dados_temporais.db').",
                                    "Defina variáveis: driver <- 'SQLite', dbname <- 'dados_temporais.db', user <- NA, password <- NA.",
                                    "Para bancos remotos, configure host, port, user e password.",
                                    "Crie uma tabela de teste com dados temporais: dbExecute(db, 'CREATE TABLE vendas (data DATE, valor NUMERIC)').",
                                    "Insira dados de exemplo: dbExecute(db, \"INSERT INTO vendas VALUES ('2023-01-01', 100)\") e desconecte."
                                  ],
                                  "verification": "Arquivo de banco criado e tabela com dados temporais inseridos visível via dbListTables().",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Script R para criação do banco de teste"
                                  ],
                                  "tips": "Use Sys.getenv() para credenciais sensíveis em ambientes reais.",
                                  "learningObjective": "Definir corretamente parâmetros de conexão para bancos SQLite com foco em dados temporais.",
                                  "commonMistakes": [
                                    "Caminho absoluto incorreto para dbname",
                                    "Esquecer de fechar conexão após setup"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estabelecer a conexão usando dbConnect",
                                  "subSteps": [
                                    "Use a função dbConnect: con <- dbConnect(RSQLite::SQLite(), dbname = 'dados_temporais.db').",
                                    "Para ODBC: con <- dbConnect(odbc::odbc(), Driver = 'SQLite', Database = 'dados_temporais.db').",
                                    "Atribua a conexão a uma variável para reutilização.",
                                    "Verifique o objeto con com class(con) == 'SQLiteConnection'.",
                                    "Registre logs de conexão com dbGetInfo(con)."
                                  ],
                                  "verification": "Objeto de conexão criado e class(con) confirma tipo correto sem erros.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Banco de dados de teste preparado no step 2"
                                  ],
                                  "tips": "Sempre use dbDisconnect() ao final para liberar recursos.",
                                  "learningObjective": "Criar uma conexão ativa com banco de dados via DBI e drivers apropriados.",
                                  "commonMistakes": [
                                    "Usar aspas simples/duplas inconsistentes em strings",
                                    "Não especificar driver corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar autenticação e listar tabelas com dados temporais",
                                  "subSteps": [
                                    "Execute dbListTables(con) para listar tabelas.",
                                    "Teste autenticação com dbGetInfo(con) ou query simples: dbGetQuery(con, 'SELECT COUNT(*) FROM vendas').",
                                    "Execute query temporal: dbGetQuery(con, 'SELECT * FROM vendas WHERE data > \"2023-01-01\"').",
                                    "Confirme resultados com str() ou head().",
                                    "Desconecte: dbDisconnect(con) e verifique dbIsValid(con) == FALSE."
                                  ],
                                  "verification": "Tabelas listadas, query retorna dados temporais corretos e desconexão confirmada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Conexão ativa do step 3",
                                    "Tabela de teste com dados temporais"
                                  ],
                                  "tips": "Use dbSendQuery() para queries grandes e dbClearResult() após.",
                                  "learningObjective": "Validar conexão autenticada e acessar metadados/tabelas com dados temporais.",
                                  "commonMistakes": [
                                    "Query SQL inválida para dados DATE",
                                    "Esquecer dbDisconnect() causando locks"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um banco SQLite 'dados_temporais.db' com tabela 'temperaturas' contendo colunas 'timestamp' (POSIXct) e 'temp' (numeric). Conecte via DBI/RSQLite, liste tabelas, execute 'SELECT * FROM temperaturas WHERE timestamp > \"2023-01-01\"' e visualize os 5 primeiros registros para análise de série temporal.",
                              "finalVerifications": [
                                "Pacotes DBI e RSQLite carregados sem erros.",
                                "Conexão estabelecida com dbConnect() e validada via dbIsValid(con).",
                                "dbListTables(con) retorna lista incluindo tabelas com dados temporais.",
                                "Query simples em tabela temporal executa sem erro e retorna dados esperados.",
                                "Desconexão limpa com dbDisconnect() e recursos liberados.",
                                "Nenhum erro de autenticação ou permissão."
                              ],
                              "assessmentCriteria": [
                                "Código utiliza sintaxe correta de dbConnect() com parâmetros apropriados.",
                                "Testes de conexão incluem listagem de tabelas e query temporal válida.",
                                "Tratamento básico de erros (tryCatch) implementado.",
                                "Tempo de execução eficiente e sem vazamentos de memória.",
                                "Comentários no código explicam passos de conexão e testes.",
                                "Compatível com dados temporais (formatos DATE/DATETIME)."
                              ],
                              "crossCurricularConnections": [
                                "Programação em R: Manipulação de pacotes e funções.",
                                "Análise de Dados: Preparação para importação de séries temporais.",
                                "Banco de Dados: Conceitos de SQL e drivers ODBC/JDBC.",
                                "Estatística: Integração com pacotes como tsibble para séries temporais."
                              ],
                              "realWorldApplication": "Analistas de dados em empresas financeiras conectam via DBI a bancos PostgreSQL corporativos para extrair séries temporais de transações diárias, autenticando com credenciais seguras, listando tabelas de mercado e iniciando modelagem preditiva em R."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.3.2",
                            "name": "Executar queries SQL para extrair séries temporais",
                            "description": "Escrever e executar consultas SQL com dbGetQuery() filtrando por intervalos temporais (ex.: WHERE data BETWEEN '2020-01-01' AND '2023-12-31'), importando resultados como data.frame.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Estabelecer conexão com o banco de dados",
                                  "subSteps": [
                                    "Instale e carregue os pacotes necessários: DBI e RSQLite (ou driver apropriado).",
                                    "Crie uma conexão usando dbConnect() com credenciais do banco (ex.: SQLite para teste).",
                                    "Teste a conexão executando uma query simples como 'SELECT 1'.",
                                    "Liste as tabelas disponíveis com dbListTables() para identificar a tabela de séries temporais.",
                                    "Registre o tipo de dados temporais na tabela usando dbDataType()."
                                  ],
                                  "verification": "Conexão bem-sucedida sem erros e lista de tabelas exibida corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Pacotes R: DBI, RSQLite",
                                    "Arquivo SQLite de exemplo com dados temporais",
                                    "Editor R como RStudio"
                                  ],
                                  "tips": "Use opções de timeout na conexão para bancos remotos; sempre feche conexões com dbDisconnect().",
                                  "learningObjective": "Compreender e implementar conexões seguras a bancos de dados relacionais em R.",
                                  "commonMistakes": [
                                    "Esquecer de carregar pacotes",
                                    "Credenciais incorretas",
                                    "Não testar conexão básica"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar estrutura da tabela e intervalos temporais",
                                  "subSteps": [
                                    "Execute dbGetQuery('DESCRIBE tabela') ou PRAGMA table_info(tabela) para SQLite para ver colunas.",
                                    "Identifique a coluna de data (ex.: 'data' como DATE ou TIMESTAMP).",
                                    "Defina variáveis R para datas inicial e final: start_date <- '2020-01-01'; end_date <- '2023-12-31'.",
                                    "Formate datas no padrão SQL: YYYY-MM-DD usando as.Date().",
                                    "Verifique o range de datas na tabela com MIN(data) e MAX(data)."
                                  ],
                                  "verification": "Estrutura da tabela listada e range de datas confirmado dentro do intervalo desejado.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Conexão ativa ao banco",
                                    "Query de inspeção SQL"
                                  ],
                                  "tips": "Use strftime() em SQLite para formatar datas; valide tipos com dbColumnInfo().",
                                  "learningObjective": "Analisar metadados de tabelas para preparar extrações temporais precisas.",
                                  "commonMistakes": [
                                    "Assumir formato de data sem verificar",
                                    "Ignorar fusos horários",
                                    "Usar datas inválidas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a query SQL com filtro temporal",
                                  "subSteps": [
                                    "Escreva a query base: SELECT data, valor FROM tabela.",
                                    "Adicione filtro: WHERE data BETWEEN '2020-01-01' AND '2023-12-31'.",
                                    "Inclua ORDER BY data ASC para sequência temporal.",
                                    "Adicione cláusulas opcionais: GROUP BY ou HAVING para agregações.",
                                    "Teste sintaxe da query em um cliente SQL antes de R."
                                  ],
                                  "verification": "Query executada manualmente retorna resultados esperados sem erros de sintaxe.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto para query",
                                    "Cliente SQL como DBeaver para teste"
                                  ],
                                  "tips": "Use parâmetros preparados com dbBind() para segurança; prefira BETWEEN para intervalos.",
                                  "learningObjective": "Escrever queries SQL otimizadas para extração de subconjuntos temporais.",
                                  "commonMistakes": [
                                    "Filtros exclusivos em vez de inclusivos",
                                    "Falta de ORDER BY",
                                    "Aspas simples em datas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar query e importar como data.frame",
                                  "subSteps": [
                                    "Execute: result <- dbGetQuery(con, \"sua_query\").",
                                    "Converta coluna data para POSIXct ou Date: result$data <- as.Date(result$data).",
                                    "Verifique dimensões com dim(result) e summary(result).",
                                    "Feche a conexão: dbDisconnect(con).",
                                    "Salve o data.frame: saveRDS(result, 'serie_temporal.rds')."
                                  ],
                                  "verification": "Data.frame importado com dados no intervalo correto e tipos apropriados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Conexão ativa",
                                    "Query pronta"
                                  ],
                                  "tips": "Use dbSendQuery() para queries grandes; capture warnings com tryCatch().",
                                  "learningObjective": "Integrar SQL com R para manipulação fluida de séries temporais em data.frames.",
                                  "commonMistakes": [
                                    "Não converter tipos de data",
                                    "Esquecer de desconectar",
                                    "Ignorar erros de memória"
                                  ]
                                }
                              ],
                              "practicalExample": "Conecte a um banco SQLite com dados de vendas diárias (tabela 'vendas' com colunas 'data' e 'valor'). Extraia vendas entre '2020-01-01' e '2023-12-31' ordenadas por data, resultando em um data.frame de 1461 observações para análise de tendências sazonais.",
                              "finalVerifications": [
                                "Data.frame possui colunas 'data' (Date) e valores numéricos corretos.",
                                "Todas as datas estão estritamente entre o intervalo especificado.",
                                "Número de linhas corresponde ao período esperado (ex.: ~3 anos diários).",
                                "Query executa sem erros ou warnings em <5 segundos.",
                                "Dados ordenados cronologicamente e sem duplicatas.",
                                "Conversão de tipos bem-sucedida (sem NAs introduzidos)."
                              ],
                              "assessmentCriteria": [
                                "Query SQL sintaticamente correta e otimizada com BETWEEN e ORDER BY.",
                                "Filtro temporal preciso, sem vazamentos de dados fora do intervalo.",
                                "Uso correto de dbGetQuery() retornando data.frame tibble-like.",
                                "Manipulação pós-importação de datas para análise em R.",
                                "Conexão gerenciada adequadamente (abrir/fechar).",
                                "Tratamento de edge cases como datas nulas ou feriados."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Preparação de dados para modelos ARIMA ou decomposição sazonal.",
                                "Programação: Integração SQL-R para ETL (Extract-Transform-Load).",
                                "Ciência de Dados: Feature engineering temporal em machine learning.",
                                "Banco de Dados: Otimização de queries com índices em colunas de data."
                              ],
                              "realWorldApplication": "Em análise de mercado, extrair histórico de preços de ações de bancos como Yahoo Finance via SQL para modelar volatilidade; em IoT, puxar leituras de sensores ambientais por período para detecção de anomalias climáticas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.3.3",
                            "name": "Mapear tipos temporais do banco para R",
                            "description": "Converter campos TIMESTAMP ou DATE do banco em POSIXct no R durante a importação, usando colClasses em dbGetQuery() para preservar granularidade temporal em análises de séries.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e documentar tipos de dados temporais na tabela do banco",
                                  "subSteps": [
                                    "Acesse o schema da tabela no banco de dados usando ferramentas como SQL client ou INFORMATION_SCHEMA.",
                                    "Liste colunas com tipos DATE, TIMESTAMP, DATETIME ou equivalentes (ex: MySQL TIMESTAMP, PostgreSQL TIMESTAMPTZ).",
                                    "Anote a granularidade esperada (dia, hora, milissegundo) para cada coluna.",
                                    "Verifique amostras de dados para confirmar formato e fuso horário.",
                                    "Crie um mapeamento preliminar: DATE -> as.Date, TIMESTAMP -> POSIXct."
                                  ],
                                  "verification": "Crie uma tabela ou lista com colunas temporais, tipos originais e mapeamentos propostos; confirme com query SELECT.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Cliente SQL (DBeaver, pgAdmin)",
                                    "Documentação do banco (MySQL/PostgreSQL manual)"
                                  ],
                                  "tips": "Priorize colunas com alta granularidade como TIMESTAMP para séries temporais.",
                                  "learningObjective": "Reconhecer tipos temporais do banco e planejar mapeamento para R.",
                                  "commonMistakes": [
                                    "Ignorar fusos horários em TIMESTAMPTZ",
                                    "Confundir DATE com TIMESTAMP",
                                    "Não verificar amostras reais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estabelecer conexão segura com o banco de dados no R",
                                  "subSteps": [
                                    "Instale pacotes necessários: DBI, RPostgres (ou RMySQL), pool.",
                                    "Configure credenciais usando keyring ou .Renviron para segurança.",
                                    "Crie objeto de conexão com dbConnect().",
                                    "Teste conexão com dbListTables() ou query simples.",
                                    "Defina opções de timezone na conexão se aplicável."
                                  ],
                                  "verification": "Execute dbGetInfo(con) e uma query básica; conexão deve retornar dados sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "RStudio",
                                    "Pacotes: DBI, RPostgres/RMySQL",
                                    "Arquivo .Renviron"
                                  ],
                                  "tips": "Use pool::dbPool() para conexões persistentes em scripts longos.",
                                  "learningObjective": "Configurar conexão robusta para importação eficiente de dados.",
                                  "commonMistakes": [
                                    "Expor credenciais em código hardcoded",
                                    "Não fechar conexões (dbDisconnect())",
                                    "Ignorar drivers ausentes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir colClasses para mapeamento de tipos temporais",
                                  "subSteps": [
                                    "Liste todas as colunas da tabela com dbGetQuery('DESCRIBE table') ou PRAGMA.",
                                    "Crie vetor colClasses nomeado: nomes das colunas -> c('POSIXct', 'Date', etc.).",
                                    "Use as.POSIXct ou as.Date para colunas específicas; especifique tz='UTC' se necessário.",
                                    "Inclua NA para colunas não-temporais ou especifique 'character'/'numeric'.",
                                    "Valide o vetor colClasses com str() após importação teste."
                                  ],
                                  "verification": "Crie e imprima o vetor colClasses; garanta que colunas temporais apontem para POSIXct/Date.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Script R",
                                    "Documentação DBI::dbGetQuery"
                                  ],
                                  "tips": "Para múltiplas colunas POSIXct, use list('POSIXct') em colClasses.",
                                  "learningObjective": "Construir colClasses preciso para preservar granularidade temporal.",
                                  "commonMistakes": [
                                    "Esquecer nomes exatos das colunas",
                                    "Usar 'Date' para TIMESTAMP sem POSIXct",
                                    "Não especificar tz levando a NA"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar importação com dbGetQuery e validar dados temporais",
                                  "subSteps": [
                                    "Escreva query SQL otimizada (SELECT * FROM table WHERE date > '2020-01-01').",
                                    "Execute df <- dbGetQuery(con, query, colClasses = colClasses).",
                                    "Inspecione com str(df), summary(df$timestamp_col), head(df).",
                                    "Converta se necessário: df$ts <- as.POSIXct(df$ts, tz='UTC').",
                                    "Teste plot(df$ts) ou diff(range(df$ts)) para granularidade."
                                  ],
                                  "verification": "str(df) mostra POSIXct/Date; sem NAs inesperados em colunas temporais; plot confirma continuidade.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Conexão ativa",
                                    "Query SQL testada"
                                  ],
                                  "tips": "Use nrows=100 em testes para velocidade; monitore warnings sobre parsing.",
                                  "learningObjective": "Importar e validar dados temporais preservando granularidade para séries.",
                                  "commonMistakes": [
                                    "Query sem LIMIT causando memory overflow",
                                    "Ignorar warnings de coercion",
                                    "Não testar range temporal"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma tabela 'vendas' no PostgreSQL com colunas order_date (DATE) e timestamp_order (TIMESTAMPTZ), use colClasses = c('order_date'='Date', 'timestamp_order'='POSIXct') em dbGetQuery para importar 10k registros. Plote vendas por hora para ver picos diários sem perda de granularidade.",
                              "finalVerifications": [
                                "Colunas temporais importadas como POSIXct/Date via str(df).",
                                "Sem NAs em timestamps originais válidos.",
                                "Granularidade preservada: min/max diff em segundos/milis.",
                                "Fuso horário consistente (attr(df$ts, 'tzone')).",
                                "Query reprodutível retorna mesmo resultado.",
                                "Integração com xts/zoo sem erros de coerce."
                              ],
                              "assessmentCriteria": [
                                "Uso correto de colClasses nomeado para tipos exatos.",
                                "Preservação de granularidade temporal em análises subsequentes.",
                                "Conexão segura sem exposição de credenciais.",
                                "Validação completa com str(), summary() e plots.",
                                "Tratamento de edge cases como NULLs ou fusos.",
                                "Eficiência: query otimizada e fechamento de conexão."
                              ],
                              "crossCurricularConnections": [
                                "Programação em R: Manipulação de dataframes e pacotes DBI.",
                                "Estatística: Preparação de dados para modelagem de séries temporais (ARIMA, Prophet).",
                                "Banco de Dados: SQL avançado e schema design.",
                                "Computação Científica: Integração com tidyverse para wrangling temporal.",
                                "Gestão de Dados: ETL pipelines para big data."
                              ],
                              "realWorldApplication": "Em análises financeiras, mapear timestamps de trades de um banco Oracle para POSIXct permite detectar padrões intradiários em high-frequency trading; em IoT, importa sensores TIMESTAMP para forecasting de falhas em manufatura."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.3.4",
                            "name": "Fechar conexões e otimizar grandes datasets",
                            "description": "Implementar dbDisconnect() para liberar recursos e usar dbSendQuery() com fetch() para datasets grandes, evitando sobrecarga de memória em séries temporais longas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender e preparar a conexão ao banco de dados",
                                  "subSteps": [
                                    "Carregue as bibliotecas necessárias: library(DBI) e o driver específico (ex: library(RPostgres))",
                                    "Estabeleça uma conexão com o banco usando dbConnect()",
                                    "Identifique um dataset grande de séries temporais (ex: tabela com milhões de registros de dados horários)",
                                    "Monitore o uso inicial de memória com gc() e memory.size()",
                                    "Registre o tempo de início da sessão"
                                  ],
                                  "verification": "Verifique se a conexão foi estabelecida com sucesso usando dbIsValid(conexao) retornando TRUE",
                                  "estimatedTime": "10 minutos",
                                  "materials": "R/RStudio, pacotes DBI e driver do banco (ex: RPostgres, RSQLite), banco de dados com tabela de séries temporais",
                                  "tips": "Sempre use credenciais seguras e teste a conexão em um ambiente de desenvolvimento primeiro",
                                  "learningObjective": "Compreender o ciclo de vida de conexões de banco para evitar vazamentos de recursos",
                                  "commonMistakes": "Esquecer de carregar o driver do banco, causando erro de conexão; usar senhas hardcoded"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o fechamento de conexões com dbDisconnect()",
                                  "subSteps": [
                                    "Execute uma query simples para testar a conexão ativa",
                                    "Chame dbDisconnect(conexao) explicitamente após o uso",
                                    "Confirme o fechamento com dbIsValid(conexao) retornando FALSE",
                                    "Use on.exit(dbDisconnect(conexao)) em funções para automação",
                                    "Registre logs de confirmação do fechamento"
                                  ],
                                  "verification": "A conexão retorna FALSE em dbIsValid() e não há warnings de conexões pendentes",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Mesmos do step 1, script R com funções wrapper",
                                  "tips": "Sempre feche conexões em blocos tryCatch() para lidar com erros inesperados",
                                  "learningObjective": "Liberar recursos de forma segura e evitar acúmulo de conexões ociosas",
                                  "commonMistakes": "Chamar dbDisconnect() múltiplas vezes (use if(dbIsValid()) antes); ignorar em loops"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Otimizar importação de grandes datasets com dbSendQuery() e dbFetch()",
                                  "subSteps": [
                                    "Prepare a query SQL otimizada para séries temporais (ex: SELECT * FROM serie WHERE data BETWEEN '2020-01-01' AND '2023-12-31')",
                                    "Use dbSendQuery(conexao, query) para enviar a query sem carregar tudo de uma vez",
                                    "Implemente dbFetch(res, n = 10000) em chunks para processar incrementalmente",
                                    "Processe dados em memória (ex: agregue com dplyr) e libere chunks com dbClearResult(res)",
                                    "Compare uso de memória com dbGetQuery() (método não otimizado)"
                                  ],
                                  "verification": "Uso de memória estabiliza abaixo de 1GB para datasets >10M rows e tempo de execução <5min",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Banco com dataset grande (>1M rows), pacotes dplyr para processamento",
                                  "tips": "Ajuste o tamanho do chunk (n) baseado no RAM disponível; use índices no banco para queries rápidas",
                                  "learningObjective": "Processar datasets massivos sem sobrecarga de memória em análises de séries temporais",
                                  "commonMistakes": "Usar dbGetQuery() para tudo, causando out-of-memory; não chamar dbClearResult()"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, monitorar e integrar no workflow de séries temporais",
                                  "subSteps": [
                                    "Execute o workflow completo: conectar > query otimizada > processar > desconectar",
                                    "Meça métricas: tempo total, pico de memória com pryr::mem_used()",
                                    "Aplique em análise real (ex: plot de série temporal com ggplot2)",
                                    "Crie uma função reutilizável encapsulando o processo",
                                    "Teste com dataset ainda maior para validar escalabilidade"
                                  ],
                                  "verification": "Workflow roda sem erros, memória retorna ao baseline e análise gera output correto",
                                  "estimatedTime": "15 minutos",
                                  "materials": "ggplot2 para visualização, datasets de teste escaláveis",
                                  "tips": "Use profvis() para profiling de performance; automatize com targets ou drake",
                                  "learningObjective": "Integrar otimizações em pipelines de dados reais para eficiência",
                                  "commonMistakes": "Não limpar resultados de query, causando leaks; ignorar profiling"
                                }
                              ],
                              "practicalExample": "Exemplo em R:\ncon <- dbConnect(RPostgres::Postgres(), dbname='timeseries', host='localhost')\nquery <- \"SELECT * FROM hourly_data WHERE timestamp >= '2020-01-01'\"\nres <- dbSendQuery(con, query)\ndata <- data.frame()\nrepeat {\n  chunk <- dbFetch(res, n=50000)\n  if(nrow(chunk)==0) break\ndata <- rbind(data, chunk)\n}\ndbClearResult(res)\n# Análise: ts_data <- ts(data$value, frequency=24)\ndbDisconnect(con)\n# Resultado: Série temporal processada sem crash de memória",
                              "finalVerifications": [
                                "Conexões são fechadas automaticamente com dbIsValid() == FALSE",
                                "Importação de 1M+ rows usa <500MB RAM",
                                "Tempo de processamento < tempo com dbGetQuery()",
                                "Nenhum warning de recursos pendentes no console",
                                "Análise de série temporal (ex: ACF plot) executa corretamente",
                                "Função wrapper roda em loop sem vazamentos"
                              ],
                              "assessmentCriteria": [
                                "Código usa dbSendQuery() + dbFetch() corretamente (100%)",
                                "Gerenciamento de memória <2x baseline (90-100%)",
                                "Fechamento de conexões em todos os cenários (100%)",
                                "Exemplo prático com séries temporais reais (85%)",
                                "Métricas de performance documentadas (90%)",
                                "Função reutilizável e comentada (95%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação em R: Estruturas de controle e funções",
                                "Gestão de Recursos Computacionais: Otimização de memória e CPU",
                                "Análise Estatística: Manipulação de dados para modelagem de séries temporais",
                                "Banco de Dados: SQL avançado e índices",
                                "Engenharia de Software: Boas práticas em pipelines de dados"
                              ],
                              "realWorldApplication": "Em finanças, otimizar importação de dados tick-by-tick de bolsas de valores para backtesting de estratégias sem crashes; em meteorologia, processar séries horárias globais de temperatura para previsões sem sobrecarga em servidores compartilhados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.3",
                    "name": "Indexação Temporal",
                    "description": "Estabelecimento de índices de tempo corretos para estruturar bases de dados de séries temporais.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.3.1",
                        "name": "Definição e Importância da Indexação Temporal",
                        "description": "Compreensão do conceito de indexação temporal como a atribuição de um eixo temporal ordenado às observações de uma série temporal, fundamental para garantir a estrutura correta em bases de dados para análises subsequentes como previsão e decomposição.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.1.1",
                            "name": "Identificar a necessidade de indexação temporal",
                            "description": "Reconhecer quando dados brutos requerem indexação temporal, diferenciando séries temporais de dados tabulares comuns, e explicar sua relevância para ordenação cronológica e alinhamento de observações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos básicos de dados tabulares e séries temporais",
                                  "subSteps": [
                                    "Defina dados tabulares como estruturas bidimensionais sem ordem temporal inerente.",
                                    "Defina séries temporais como sequências de dados ordenados por tempo.",
                                    "Compare as estruturas: tabelas vs. vetores indexados por tempo.",
                                    "Identifique exemplos cotidianos de cada tipo.",
                                    "Registre as diferenças principais em um quadro comparativo."
                                  ],
                                  "verification": "Quadro comparativo completo com pelo menos 5 diferenças listadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Exemplos de datasets online (CSV tabular e série temporal)"
                                  ],
                                  "tips": "Use analogias como 'lista de compras' para tabulares e 'diário' para séries temporais.",
                                  "learningObjective": "Diferenciar conceitualmente dados tabulares de séries temporais.",
                                  "commonMistakes": [
                                    "Confundir dependência temporal com correlação simples.",
                                    "Ignorar a ordenação como elemento chave."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar características que indicam necessidade de indexação temporal",
                                  "subSteps": [
                                    "Liste sinais em dados brutos: presença de timestamps, medições sequenciais, dependência temporal.",
                                    "Analise se os dados representam observações ao longo do tempo (ex: diárias, horárias).",
                                    "Verifique ausência de índice temporal explícito nos dados brutos.",
                                    "Classifique dados como 'requer indexação' ou 'não requer' com justificativa.",
                                    "Documente critérios em uma checklist."
                                  ],
                                  "verification": "Checklist preenchida com 5+ critérios e aplicada a 2 exemplos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets",
                                    "Datasets de exemplo (ex: vendas sem data)"
                                  ],
                                  "tips": "Procure por palavras como 'data', 'hora', 'dia' nos rótulos das colunas.",
                                  "learningObjective": "Reconhecer indicadores de dados que demandam indexação temporal.",
                                  "commonMistakes": [
                                    "Assumir indexação só para grandes volumes de dados.",
                                    "Não considerar granularidade temporal (ex: segundos vs. anos)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar exemplos práticos de dados brutos",
                                  "subSteps": [
                                    "Carregue um dataset tabular comum (ex: lista de produtos).",
                                    "Carregue um dataset de série temporal sem índice (ex: temperaturas diárias sem datas).",
                                    "Tente ordenar e alinhar observações sem índice temporal.",
                                    "Simule adição de índice e observe melhorias na análise.",
                                    "Registre observações em um relatório curto."
                                  ],
                                  "verification": "Relatório com antes/depois da indexação em pelo menos 2 exemplos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com Pandas ou R",
                                    "Datasets de Kaggle (tabular e temporal)"
                                  ],
                                  "tips": "Use funções como pd.to_datetime() para testar indexação.",
                                  "learningObjective": "Aplicar identificação em dados reais para diferenciar tipos.",
                                  "commonMistakes": [
                                    "Ordenar por valor numérico em vez de tempo.",
                                    "Ignorar fusos horários em dados globais."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar a relevância da indexação temporal",
                                  "subSteps": [
                                    "Descreva como a indexação permite ordenação cronológica precisa.",
                                    "Explique alinhamento de observações para análises como médias móveis.",
                                    "Discuta impactos em modelagem (ex: ARIMA requer índice temporal).",
                                    "Elabore um parágrafo explicativo com exemplos.",
                                    "Apresente para um par ou grave áudio resumindo."
                                  ],
                                  "verification": "Parágrafo explicativo de 150+ palavras aprovado por autoavaliação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de texto",
                                    "Gravação de áudio opcional"
                                  ],
                                  "tips": "Ligue à previsão: sem índice, previsões perdem contexto temporal.",
                                  "learningObjective": "Articular benefícios da indexação para análises temporais.",
                                  "commonMistakes": [
                                    "Subestimar problemas em junções de datasets sem índice comum.",
                                    "Confundir indexação com formatação de data."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um dataset de vendas diárias brutas: [dia1:100, dia2:120, dia3:90]. Sem indexação temporal (ex: 2023-01-01), não é possível ordenar cronologicamente ou alinhar com feriados. Adicionando índice ['2023-01-01', '2023-01-02', '2023-01-03'], permite análise de tendências sazonais e previsões precisas.",
                              "finalVerifications": [
                                "Diferencia corretamente 3+ exemplos de séries temporais vs. tabulares.",
                                "Lista 4+ indicadores de necessidade de indexação em dados brutos.",
                                "Explica ordenação cronológica com exemplo prático.",
                                "Descreve alinhamento de observações sem erros.",
                                "Aplica checklist a novo dataset com 90% de acerto.",
                                "Articula relevância em contexto de análise de séries temporais."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: 90% de acertos em definições e diferenças.",
                                "Completude da análise: Todos substeps executados em exemplos.",
                                "Clareza na explicação: Linguagem acessível e sem jargões desnecessários.",
                                "Aplicação prática: Demonstração funcional com código ou planilha.",
                                "Profundidade: Integra relevância para modelagem avançada.",
                                "Autoavaliação: Reflexão sobre erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Sequências e funções discretas ao longo do tempo.",
                                "Informática: Manipulação de índices em Pandas ou DataFrames no R.",
                                "Economia: Análise de séries financeiras como PIB ou ações.",
                                "Ciências Ambientais: Monitoramento climático com dados temporais.",
                                "Física: Registros de experimentos com timestamps."
                              ],
                              "realWorldApplication": "Na previsão de demanda em e-commerce, identificar necessidade de indexação em logs de vendas permite alinhar picos sazonais (ex: Black Friday), otimizando estoque e reduzindo perdas em até 20%."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.1.2",
                            "name": "Diferenciar tipos de índices temporais",
                            "description": "Comparar índices numéricos sequenciais com índices datetime ou period, destacando vantagens dos temporais para operações como lag, lead e alinhamento sazonal em séries temporais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Índices Numéricos Sequenciais",
                                  "subSteps": [
                                    "Defina um índice numérico sequencial como um RangeIndex padrão no pandas (0, 1, 2...).",
                                    "Crie um DataFrame simples com índice numérico e visualize suas propriedades usando df.index.",
                                    "Observe limitações iniciais, como falta de suporte nativo para operações temporais.",
                                    "Compare com um array NumPy para reforçar a natureza posicional.",
                                    "Registre as propriedades principais: tipo (int64), frequência (None)."
                                  ],
                                  "verification": "Execute df.index e confirme que é RangeIndex com valores sequenciais inteiros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Jupyter Notebook, biblioteca pandas instalada, dataset simples de números (ex: np.arange(10))",
                                  "tips": "Sempre use pd.DataFrame(range(10)) para criar rapidamente um exemplo.",
                                  "learningObjective": "Identificar e criar índices numéricos sequenciais, reconhecendo seu foco posicional.",
                                  "commonMistakes": "Confundir índice numérico com colunas numéricas; sempre inspecione df.index separadamente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Índices Temporais (Datetime e Period)",
                                  "subSteps": [
                                    "Instale e importe pd.to_datetime() para converter strings ou números em DatetimeIndex.",
                                    "Crie um PeriodIndex usando pd.period_range() para períodos fixos (ex: mensais).",
                                    "Visualize diferenças: DatetimeIndex para timestamps exatos, PeriodIndex para intervalos.",
                                    "Aplique freq='M' ou 'D' para definir frequência temporal.",
                                    "Compare propriedades: df.index.freq deve retornar uma frequência válida."
                                  ],
                                  "verification": "Crie um DataFrame com DatetimeIndex e confirme df.index.freq == 'M' via print.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Jupyter Notebook, pandas, strings de datas de exemplo (ex: ['2023-01', '2023-02'])",
                                  "tips": "Use pd.date_range(start='2023-01-01', periods=12, freq='M') para séries mensais rápidas.",
                                  "learningObjective": "Criar e diferenciar DatetimeIndex de PeriodIndex, entendendo sua representação temporal.",
                                  "commonMistakes": "Ignorar fusos horários; especifique tz='UTC' se necessário para evitar erros."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Características dos Dois Tipos de Índices",
                                  "subSteps": [
                                    "Crie DataFrames idênticos, um com índice numérico e outro temporal.",
                                    "Compare operações básicas: slicing (ex: df[0:5] vs df['2023-01':'2023-03']).",
                                    "Teste resample() apenas no índice temporal para agregação sazonal.",
                                    "Analise inferência de frequência automática no pandas.",
                                    "Documente tabela de prós/contras: numérico (simples, rápido) vs temporal (semântico, operações avançadas)."
                                  ],
                                  "verification": "Tabela comparativa criada e slicing temporal funciona sem erros no índice datetime.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Jupyter Notebook, pandas, mesmo dataset convertido para ambos índices",
                                  "tips": "Use df.set_index(pd.to_datetime(df['date'])) para conversão rápida.",
                                  "learningObjective": "Comparar sintaxe, performance e usabilidade entre índices numéricos e temporais.",
                                  "commonMistakes": "Assumir que slicing numérico é equivalente a temporal; teste com datas não sequenciais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Destacar Vantagens com Operações Específicas (Lag, Lead, Alinhamento Sazonal)",
                                  "subSteps": [
                                    "Aplique shift(1) para lag/lead em ambos índices e note alinhamento automático no temporal.",
                                    "Use df.asfreq('MS') para alinhamento sazonal apenas em índice temporal.",
                                    "Execute rolling(window=3) com centro em datas específicas no temporal.",
                                    "Compare resultados: numérico requer alinhamento manual, temporal é intuitivo.",
                                    "Visualize com plot() para séries temporais alinhadas."
                                  ],
                                  "verification": "Lag/lead produz valores corretamente alinhados no índice temporal, plot mostra sazonalidade.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Jupyter Notebook, pandas, matplotlib, dataset de vendas mensais fictício",
                                  "tips": "Combine com groupby(df.index.month) para análise sazonal instantânea.",
                                  "learningObjective": "Demonstrar superioridade dos índices temporais em operações de séries temporais.",
                                  "commonMistakes": "Usar shift() sem índice temporal, resultando em desalinhamento de períodos."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar Diferenciação em um Cenário Completo",
                                  "subSteps": [
                                    "Carregue um dataset real (ex: air passengers) com índice numérico.",
                                    "Converta para DatetimeIndex e reaplique operações do Step 4.",
                                    "Identifique quando usar cada tipo baseado em requisitos do problema.",
                                    "Resuma vantagens em um relatório curto.",
                                    "Teste cenários de falha: tente resample() em índice numérico."
                                  ],
                                  "verification": "Relatório resume 3 vantagens temporais comprovadas com código executado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Jupyter Notebook, pandas, dataset CSV de séries temporais (ex: de seaborn.load_dataset('flights'))",
                                  "tips": "Salve comparações em df_num vs df_temp para side-by-side.",
                                  "learningObjective": "Aplicar diferenciação prática e decidir uso baseado em contexto.",
                                  "commonMistakes": "Não converter índice adequadamente, levando a erros em freq operations."
                                }
                              ],
                              "practicalExample": "Em um dataset de vendas mensais de 2020-2023 (pd.read_csv('sales.csv', parse_dates=['date'], index_col='date')), use índice numérico para df.shift(1) desalinhado vs DatetimeIndex para lag perfeito: sales_temp.shift(1).plot() alinha picos sazonais de Natal automaticamente.",
                              "finalVerifications": [
                                "Explicar verbalmente 3 diferenças chave entre RangeIndex e DatetimeIndex.",
                                "Converter um DataFrame numérico para temporal sem erros de parsing.",
                                "Executar lag/lead e resample() exclusivamente em índice temporal.",
                                "Identificar erro ao tentar asfreq() em índice numérico.",
                                "Plotar série temporal com alinhamento sazonal visível.",
                                "Listar 2 cenários onde índice numérico é preferível (ex: ML sem tempo)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e criação de ambos índices (30%)",
                                "Correta comparação de operações (lag/lead/resample) com evidências (25%)",
                                "Uso correto de freq e slicing temporal (20%)",
                                "Identificação de vantagens/disvantagens com exemplos (15%)",
                                "Clareza no relatório/prática final (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Sequências e progressões aritméticas vs funções de tempo contínuo.",
                                "Programação: Manipulação de estruturas de dados indexadas (arrays vs dicionários temporais).",
                                "Economia/Finanças: Análise de tendências sazonais em dados de mercado.",
                                "Ciência de Dados: Pré-processamento para modelagem preditiva em ML."
                              ],
                              "realWorldApplication": "Em finanças, índices temporais permitem análise precisa de retornos diários com lead/lag para estratégias de trading algorítmico; em meteorologia, alinhamento sazonal via resample() revela padrões climáticos para previsões."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.1.3",
                            "name": "Analisar impactos de indexação incorreta",
                            "description": "Avaliar erros comuns como desalinhamento de datas ou duplicatas temporais e seus efeitos em análises exploratórias e modelos de previsão, com exemplos de bases de dados financeiras ou de marketing.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos de Indexação Temporal e Erros Comuns",
                                  "subSteps": [
                                    "Defina indexação temporal como a configuração de um índice datetime em séries temporais para ordenação e slicing eficiente.",
                                    "Liste erros comuns: desalinhamento de datas (ex: fusos horários incorretos ou formatos mistos) e duplicatas temporais (múltiplas entradas para o mesmo timestamp).",
                                    "Explique por que indexação é crucial para operações como resample, rolling windows e agregações temporais.",
                                    "Revise exemplos iniciais de datasets financeiros (preços de ações) e de marketing (vendas diárias).",
                                    "Compare indexação correta vs. incorreta usando diagramas simples."
                                  ],
                                  "verification": "Resuma em 3 frases os erros comuns e forneça um exemplo de cada um; valide com um colega ou auto-revisão.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação Pandas pd.to_datetime()",
                                    "Notebook Jupyter com datasets de exemplo (Yahoo Finance API para ações, Kaggle para marketing)"
                                  ],
                                  "tips": "Sempre use pd.to_datetime() com infer_datetime_format=True para eficiência; visualize com df.index para inspeção rápida.",
                                  "learningObjective": "Identificar e definir indexação temporal correta e os principais erros associados.",
                                  "commonMistakes": [
                                    "Ignorar fusos horários levando a offsets de 1 dia",
                                    "Não tratar duplicatas com drop_duplicates(), causando inflamento de dados",
                                    "Misturar formatos de data sem padronização"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Detectar e Diagnosticar Erros de Indexação em Datasets",
                                  "subSteps": [
                                    "Carregue um dataset de exemplo (ex: preços de ações com datas desalinhadas ou vendas de marketing com duplicatas).",
                                    "Inspecione o índice com df.info(), df.index.dtype e df.index.duplicated().",
                                    "Aplique diagnósticos: df.resample('D').count() para gaps/duplicatas, e df.sort_index() para ordenação.",
                                    "Corrija temporariamente erros: df.set_index(pd.to_datetime(df['date'], errors='coerce')) e df[~df.index.duplicated(keep='first')].",
                                    "Documente os erros encontrados em um relatório curto."
                                  ],
                                  "verification": "Execute código em Jupyter e capture output mostrando detecção de pelo menos 2 erros; salve como imagem ou markdown.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Datasets: yfinance para ações (ex: AAPL), Kaggle 'Daily Sales' para marketing",
                                    "Bibliotecas: pandas, matplotlib"
                                  ],
                                  "tips": "Use df.index.is_monotonic_increasing para checar ordenação; plot(df.index) revela anomalias visuais.",
                                  "learningObjective": "Diagnosticar erros de indexação incorreta em datasets reais de forma sistemática.",
                                  "commonMistakes": [
                                    "Não checar NaT após conversão de datas",
                                    "Remover duplicatas sem investigar causas",
                                    "Assumir ordenação sem sort_index()"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Impactos em Análises Exploratórias (EDA)",
                                  "subSteps": [
                                    "Realize EDA básica com indexação correta: plot de séries, rolling mean, seasonal_decompose.",
                                    "Repita EDA com indexação incorreta (introduza erros manualmente) e compare métricas (média móvel, autocorrelação).",
                                    "Quantifique impactos: calcule % de distorção em tendências (ex: pico artificial por duplicatas).",
                                    "Visualize diferenças com subplots: correto vs. incorreto em dataset financeiro/marketing.",
                                    "Registre observações sobre viés em estatísticas descritivas."
                                  ],
                                  "verification": "Gere gráficos comparativos e tabela de métricas distorcidas; explique discrepâncias em parágrafo.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Pandas, matplotlib, statsmodels.tsa.seasonal para decompose",
                                    "Notebooks com datasets pré-carregados"
                                  ],
                                  "tips": "Use df.asfreq('D', method='ffill') para simular gaps; compare ACF plots para autocorrelação.",
                                  "learningObjective": "Quantificar efeitos de indexação incorreta em EDA de séries temporais.",
                                  "commonMistakes": [
                                    "Não normalizar escalas nos plots comparativos",
                                    "Ignorar missing values introduzidos por desalinhamento",
                                    "Focar só em visuais sem métricas numéricas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Impactos em Modelos de Previsão e Sintetizar Lições",
                                  "subSteps": [
                                    "Treine um modelo simples (ARIMA ou Prophet) em dados com indexação correta e incorreta.",
                                    "Compare métricas: MAE, RMSE em previsões out-of-sample.",
                                    "Analise resíduos e diagnósticos (Ljung-Box) para violar suposições temporais.",
                                    "Simule cenários: duplicatas inflando variância, desalinhamento shiftando forecasts.",
                                    "Escreva relatório final com recomendações para evitar impactos."
                                  ],
                                  "verification": "Execute modelos e compare tabelas de métricas; forecast plots mostram diferenças claras.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "statsmodels.tsa.arima, prophet",
                                    "Datasets do passo anterior"
                                  ],
                                  "tips": "Use cross_validation em Prophet para robustez; sempre valide com train_test_split temporal.",
                                  "learningObjective": "Demonstrar e mitigar impactos de indexação em modelagem preditiva.",
                                  "commonMistakes": [
                                    "Treinar em dados não-estacionários sem diff()",
                                    "Comparar métricas sem holdout temporal",
                                    "Overfitting em datasets pequenos com erros"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um dataset de preços diários de ações AAPL (via yfinance), introduza duplicatas em 10/01/2023 e shift de timezone em uma semana. Na EDA, rolling mean(7) mostra pico artificial de 20%; ARIMA forecast erra RMSE em 15% devido a autocorrelação violada. Em marketing, vendas duplicadas superestimam conversões semanais em 30%.",
                              "finalVerifications": [
                                "Identifica e corrige 3 erros comuns em um dataset novo sem prompts.",
                                "Explica impactos quantitativos em EDA e previsão com exemplos numéricos.",
                                "Gera relatório comparativo de métricas antes/depois correção.",
                                "Aplica resample/rolling em índice corrigido sem erros.",
                                "Discute trade-offs de métodos de correção (drop vs. aggregate).",
                                "Valida monotonicidade e ausência de duplicatas em código."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção de erros (100% em exemplos padrão).",
                                "Quantificação de impactos com métricas (MAE/RMSE <10% variação explicada).",
                                "Qualidade de visualizações comparativas (claras, legíveis).",
                                "Relatório lógico com causas, efeitos e soluções.",
                                "Código reproduzível e eficiente (sem warnings Pandas).",
                                "Conexão com contextos reais (finanças/marketing)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Manipulação avançada de dataframes em Python/R.",
                                "Finanças: Análise de séries temporais em trading algorítmico.",
                                "Marketing: Previsão de demanda e ROI de campanhas.",
                                "Matemática: Estatística descritiva e testes de estacionariedade.",
                                "Ética em Dados: Viés introduzido por preprocessing inadequado."
                              ],
                              "realWorldApplication": "Em bancos, indexação incorreta em dados de transações causa forecasts de risco ruins, levando a perdas milionárias; em e-commerce, duplicatas de cliques distorcem modelos de churn, afetando retenção de clientes em 5-10%."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.3.2",
                        "name": "Métodos de Criação e Definição de Índices Temporais",
                        "description": "Técnicas práticas para estabelecer índices temporais corretos durante a importação e transformação inicial de dados, utilizando ferramentas em R como ts, zoo e xts.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.2.1",
                            "name": "Importar dados com parsing de datas",
                            "description": "Aplicar funções como read.csv com colClasses ou as.Date/strptime para converter strings de datas em índices temporais durante a importação de arquivos CSV ou Excel em R.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar ambiente R e inspecionar arquivo de dados",
                                  "subSteps": [
                                    "Instalar e carregar pacotes essenciais: install.packages(c('readr', 'readxl', 'lubridate')); library(readr); library(readxl); library(lubridate)",
                                    "Usar readLines() ou head() para visualizar as primeiras linhas do arquivo CSV/Excel sem carregá-lo completamente",
                                    "Identificar coluna(s) de datas, formatos (ex: '2023-01-15', '15/01/2023') e possíveis inconsistências como NA ou valores inválidos",
                                    "Executar str(readLines(file, n=10)) para analisar tipos iniciais das strings de data",
                                    "Documentar o formato exato usando ?strptime para mapear %Y-%m-%d etc."
                                  ],
                                  "verification": "Visualize head(readLines(file, 20)) e confirme identificação correta de formatos de data via print()",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "RStudio ou R console",
                                    "Arquivo CSV/Excel de exemplo com coluna de datas (ex: dados_vendas.csv)"
                                  ],
                                  "tips": "Para arquivos grandes, limite readLines a 100 linhas para evitar lentidão; use encoding='UTF-8' se houver acentos",
                                  "learningObjective": "Configurar ambiente e diagnosticar formatos de data brutos para planejamento de parsing",
                                  "commonMistakes": [
                                    "Não instalar pacotes antes",
                                    "Ignorar variações regionais de data (DD/MM vs MM/DD)",
                                    "Carregar todo o arquivo prematuramente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Testar parsing de datas em amostras isoladas",
                                  "subSteps": [
                                    "Extrair amostra de strings de data: sample_dates <- readLines(file)[1:10]",
                                    "Testar conversão com as.Date(sample_dates, format='%Y-%m-%d') ou strptime(sample_dates, format='%d/%m/%Y')",
                                    "Usar lubridate::dmy(), mdy() ou ymd() para parsing inteligente e tolerante a erros",
                                    "Verificar resultados com class() e summary() para detectar NAs ou erros",
                                    "Definir formato final e função de parsing personalizada se necessário: parse_date <- function(x) as.Date(x, '%Y-%m-%d')"
                                  ],
                                  "verification": "Todas as datas da amostra convertidas corretamente sem NAs: sum(is.na(parse_date(sample_dates))) == 0",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "R console",
                                    "Função strptime reference: ?strptime",
                                    "Lubridate cheat sheet"
                                  ],
                                  "tips": "Comece com lubridate para simplicidade; fallback para strptime só se formatos forem muito customizados",
                                  "learningObjective": "Dominar funções de parsing e validar conversões antes da importação em escala",
                                  "commonMistakes": [
                                    "Assumir formato único sem testar amostras",
                                    "Confundir %d/%m com %m/%d",
                                    "Não tratar valores ausentes como 'NA' ou vazios"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar e executar importação com parsing de datas",
                                  "subSteps": [
                                    "Para CSV: read.csv(file, colClasses=c('data_col'='Date'), na.strings=c('', 'NA')) ou read_csv(file, col_types=cols(data_col=col_date(format='%Y-%m-%d')))",
                                    "Para Excel: read_excel(file, col_types=c(data_col='date'))",
                                    "Aplicar parsing seletivo apenas na coluna de data para eficiência: df <- read_csv(..., col_types=cols(.default='c', data_col=col_date()))",
                                    "Manter outras colunas como character inicialmente para limpeza posterior",
                                    "Salvar dataset importado: saveRDS(df, 'dados_parseados.rds')"
                                  ],
                                  "verification": "str(df) mostra classe(data_col) == 'Date' e sem warnings de parsing durante importação",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Arquivos CSV/Excel de teste",
                                    "Documentação read.csv e readr::read_csv"
                                  ],
                                  "tips": "Use col_types para forçar tipos e evitar coerção automática; teste em subconjunto com nrows=100",
                                  "learningObjective": "Importar dados com parsing integrado, garantindo eficiência e correção de tipos temporais",
                                  "commonMistakes": [
                                    "Especificar colClasses incorreto (use nomes exatos de colunas)",
                                    "Ignorar warnings de parsing",
                                    "Não definir na.strings para valores inválidos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir índice temporal e realizar validações finais",
                                  "subSteps": [
                                    "Converter coluna de data em índice: df$index <- df$data_col; rownames(df) <- df$index; df$data_col <- NULL",
                                    "Para séries temporais: ts_data <- ts(df$valor, start=min(df$index), frequency=12) ou xts(df, order.by=df$index)",
                                    "Verificar ordenação: is.unsorted(df$index) e duplicatas: any(duplicated(df$index))",
                                    "Tratar outliers/NAs em datas: df <- df[!is.na(df$index), ]",
                                    "Visualizar: plot(df$index, df$valor, type='l') para confirmar série temporal coerente"
                                  ],
                                  "verification": "rownames(df) ou index(df) é classe Date, ordenado e único: all(order(df$index) == seq_len(nrow(df)))",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Pacote xts ou zoo para séries temporais",
                                    "Gráficos base R ou ggplot2"
                                  ],
                                  "tips": "Use zoo::index() para flexibilidade; sempre plote para inspeção visual rápida",
                                  "learningObjective": "Transformar dados parseados em índices temporais válidos para análise de séries",
                                  "commonMistakes": [
                                    "Não remover coluna original após indexação",
                                    "Índices não ordenados levando a análises erradas",
                                    "Esquecer de lidar com fusos horários em strptime"
                                  ]
                                }
                              ],
                              "practicalExample": "Baixe 'vendas_mensais.csv' com colunas 'data' ('2023-01-01') e 'vendas'. Use read_csv('vendas_mensais.csv', col_types=cols(data=col_date('%Y-%m-%d'), vendas=col_double())) para importar, defina rownames como data e plote vendas vs tempo para ver tendência mensal.",
                              "finalVerifications": [
                                "Todas as datas importadas são classe 'Date' sem NAs inesperados",
                                "Índice temporal está ordenado cronologicamente",
                                "Gráfico de linha mostra série temporal contínua sem gaps visuais",
                                "Funções como diff(index) confirmam intervalos regulares",
                                "Exportar e reimportar preserva classes temporais",
                                "Tratamento de 10% de datas inválidas resulta em <5% NAs"
                              ],
                              "assessmentCriteria": [
                                "Precisão do parsing: 100% de conversões corretas em dataset de teste",
                                "Eficiência: Tempo de importação <1s para 10k linhas",
                                "Robustez: Código lida com formatos mistos e NAs sem crashes",
                                "Clareza: Código comentado com explicações de formatos usados",
                                "Validação: Inclui testes unitários para parsing (ex: testthat)",
                                "Escalabilidade: Funciona para CSV e Excel sem reescrita"
                              ],
                              "crossCurricularConnections": [
                                "Programação em R: Manipulação de dados com tidyverse",
                                "Estatística: Preparação para modelagem de séries temporais (ARIMA, Prophet)",
                                "Gestão de Dados: Processos ETL em pipelines de dados",
                                "Análise Financeira: Indexação de cotações históricas",
                                "Ciência de Dados: Integração com bases NoSQL ou APIs temporais"
                              ],
                              "realWorldApplication": "Em empresas de e-commerce, importar logs de transações diárias de CSVs para análise de sazonalidade de vendas, prevendo picos como Black Friday via modelos de séries temporais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.2.2",
                            "name": "Definir índice em objetos de séries temporais",
                            "description": "Criar objetos ts() ou xts() com especificação de start, frequency e end, garantindo alinhamento correto para séries mensais, diárias ou irregulares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Índices Temporais",
                                  "subSteps": [
                                    "Estude a documentação de ts() e xts() no R usando ?ts e library(xts).",
                                    "Identifique parâmetros chave: start (data inicial), frequency (mensal=12, diária=365, etc.), end (opcional).",
                                    "Diferencie séries regulares (ts()) de irregulares (xts()).",
                                    "Revise tipos de dados de tempo: Date, POSIXct.",
                                    "Pratique conversão de vetores/data.frames para formato temporal com as.Date()."
                                  ],
                                  "verification": "Liste corretamente os parâmetros de ts() e xts() e dê exemplos de frequency para dados mensais e diários.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "R/RStudio, pacotes base, xts, zoo; documentação online de R.",
                                  "tips": "Use help() para funções específicas; memorize frequencies comuns (12=mensal, 365.25=diário).",
                                  "learningObjective": "Dominar terminologia e parâmetros para criação precisa de objetos de séries temporais.",
                                  "commonMistakes": "Confundir frequency com período (ex: usar 7 para semanal em vez de 52); ignorar formato de start como c(ano, mês)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar Dados e Criar Objeto ts() para Séries Regulares",
                                  "subSteps": [
                                    "Carregue dados de exemplo (ex: vetor de valores numéricos).",
                                    "Defina start como vetor c(ano, período), ex: c(2020,1) para janeiro 2020.",
                                    "Especifique frequency baseado na granularidade (12 para mensal).",
                                    "Crie o objeto: ts(dados, start=start, frequency=freq).",
                                    "Inspecione com str() e head() para confirmar índice."
                                  ],
                                  "verification": "Execute print(ts_obj) e confirme que o índice inicia corretamente e frequency está listada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "R script, dados de exemplo (ex: AirPassengers dataset).",
                                  "tips": "Use end= para limitar; teste com dados mensais primeiro.",
                                  "learningObjective": "Criar objetos ts() alinhados para séries regulares como mensais ou trimestrais.",
                                  "commonMistakes": "Start incorreto (ex: c(2020,13) para mensal); dados não numéricos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Criar Objeto xts() para Séries Irregulares ou com Datas Específicas",
                                  "subSteps": [
                                    "Instale/carregue library(xts) e zoo.",
                                    "Crie índice temporal: index <- as.Date(c('2020-01-01', '2020-01-02', ...)).",
                                    "Crie xts: xts(dados, order.by=index).",
                                    "Ajuste zona horária se necessário com Sys.setenv(TZ='UTC').",
                                    "Alinhe frequência implícita verificando unique(frequency(index_xts))."
                                  ],
                                  "verification": "Use xtsAttributes() e index() para ver o índice; plot() deve mostrar eixo temporal correto.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Pacotes xts, zoo; dados irregulares de exemplo (ex: CSV com datas faltantes).",
                                  "tips": "Para diários irregulares, xts() é mais flexível que ts(); use na.locf() para preencher gaps.",
                                  "learningObjective": "Construir xts() para dados com timestamps precisos e irregulares.",
                                  "commonMistakes": "Índice não ordenado (use order.by=sort(index)); misturar Date e POSIXct."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar Alinhamento e Realizar Testes de Consistência",
                                  "subSteps": [
                                    "Compare start/end/frequency com dados originais usando start(), end(), frequency().",
                                    "Plote o objeto: plot(ts_obj) ou plot(xts_obj) para visualização.",
                                    "Teste subsetting: window(ts_obj, start=c(2020,2), end=c(2020,6)).",
                                    "Verifique alinhamento com merge() ou na.locf() para gaps.",
                                    "Salve e recarregue para confirmar persistência."
                                  ],
                                  "verification": "Subset e plot funcionam sem erros; valores batem com dados originais em pelo menos 3 pontos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Funções plot(), window(); datasets de teste variados.",
                                  "tips": "Sempre rode summary() para estatísticas; use autoplot() do ggplot2 para plots melhores.",
                                  "learningObjective": "Garantir integridade e usabilidade do objeto de série temporal criado.",
                                  "commonMistakes": "Ignorar gaps de dados levando a frequency incorreta; não ordenar índice em xts()."
                                }
                              ],
                              "practicalExample": "Crie um objeto ts() para vendas mensais: vendas <- c(100,120,110,130); ts_vendas <- ts(vendas, start=c(2023,1), frequency=12). Para xts diário irregular: datas <- as.Date(c('2023-01-01','2023-01-03')); xts_vendas <- xts(c(100,150), order.by=datas). Plote e subset para verificar.",
                              "finalVerifications": [
                                "O objeto é da classe correta (ts ou xts).",
                                "start(), end() e frequency() retornam valores esperados.",
                                "Plot exibe eixo temporal alinhado sem distorções.",
                                "Subsetting por data funciona precisamente.",
                                "Não há NAs introduzidos inadvertidamente no índice.",
                                "Conversão para data.frame preserva temporalidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na especificação de start, frequency e end (100% match).",
                                "Correto manuseio de regular vs irregular (ts vs xts).",
                                "Ausência de erros em verificações e plots.",
                                "Eficiência: tempo de criação <1s para 1000 obs.",
                                "Flexibilidade: adaptação a mensais/diárias/irregulares.",
                                "Documentação clara no código (comentários)."
                              ],
                              "crossCurricularConnections": [
                                "Programação em R: manipulação de vetores e data.frames.",
                                "Estatística: preparação para modelagem ARIMA ou decomposição.",
                                "Finanças: análise de retornos de ações com xts().",
                                "Ciência de Dados: integração com tidyverse para wrangling temporal.",
                                "Visualização: uso de ggplot2 ou dygraphs para séries."
                              ],
                              "realWorldApplication": "Em análise financeira, definir índice xts() em dados de preços de ações diários permite calcular retornos alinhados, detectar anomalias e prever tendências; em meteorologia, ts() mensal para temperaturas facilita modelagem sazonal e forecasting."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.2.3",
                            "name": "Especificar frequências temporais",
                            "description": "Configurar parâmetros de frequência (ex: 12 para mensal, 365 para diária) e lidar com dados irregulares usando zoo ou xts para suportar análises sazonais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos de Frequência Temporal em Séries Temporais",
                                  "subSteps": [
                                    "Revise definições de frequência: diária (365), semanal (52), mensal (12), trimestral (4), anual (1).",
                                    "Estude exemplos de dados regulares vs. irregulares (ex: feriados afetando dados diários).",
                                    "Explore documentação de zoo e xts para funções como as.Date(), frequency().",
                                    "Identifique quando usar zoo (irregulares) vs. ts (regulares).",
                                    "Pratique identificando frequência em datasets de exemplo como AirPassengers."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito as diferenças entre frequências com exemplos corretos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação R de zoo/xts, dataset AirPassengers do pacote datasets.",
                                  "tips": "Use ?zoo e ?xts no R para referências rápidas.",
                                  "learningObjective": "Compreender os parâmetros de frequência e suas implicações em análises sazonais.",
                                  "commonMistakes": "Confundir frequência com período (ex: usar 365 para diária ignorando leap years)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Frequências Básicas para Dados Regulares",
                                  "subSteps": [
                                    "Carregue pacotes: library(zoo); library(xts).",
                                    "Crie um vetor de datas regulares com seq.Date().",
                                    "Construa objeto zoo/xts especificando frequency=12 para mensal.",
                                    "Converta ts para zoo/xts usando as.zoo() com deltat=1/12.",
                                    "Visualize com plot() para confirmar alinhamento temporal."
                                  ],
                                  "verification": "O objeto resultante mostra frequency() == 12 e plot sem gaps irregulares.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "R/RStudio, pacotes zoo e xts, dados de exemplo como EuStockMarkets.",
                                  "tips": "Sempre especifique order.by=dates no xts para evitar erros de indexação.",
                                  "learningObjective": "Criar objetos de séries temporais com frequências padrão configuradas corretamente.",
                                  "commonMistakes": "Esquecer de alinhar índices de tempo, causando NA values."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Lidar com Dados Irregulares Usando zoo ou xts",
                                  "subSteps": [
                                    "Identifique irregularidades em dados (ex: missing dates ou múltiplos por dia).",
                                    "Use zoo(data, order.by=dates) para dados irregulares sem frequência fixa.",
                                    "Aplique na.omit() ou na.approx() para preencher gaps.",
                                    "Converta para xts com as.xts() e teste agregação com apply.daily/monthly().",
                                    "Ajuste frequência efetiva com aggregate() para análise sazonal."
                                  ],
                                  "verification": "Dados irregulares convertidos sem perda de informação chave e plot() mostra continuidade.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Dataset irregular personalizado (ex: vendas com feriados), pacotes zoo/xts.",
                                  "tips": "Para sazonalidade, use frequency=12 mesmo em zoo para compatibilidade com forecast.",
                                  "learningObjective": "Manipular dados irregulares para suportar análises sazonais robustas.",
                                  "commonMistakes": "Ignorar time zones em xts, levando a desalinhamentos globais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar Configuração para Análises Sazonais",
                                  "subSteps": [
                                    "Aplique decompose() ou stl() no objeto para decompor sazonalidade.",
                                    "Verifique ciclo com cycle() e nscycle() retornando valores esperados.",
                                    "Teste agregação sazonal com apply.monthly() ou period.apply().",
                                    "Compare resultados com dados originais para precisão.",
                                    "Documente frequência usada em um relatório simples."
                                  ],
                                  "verification": "Decomposição sazonal revela padrões claros sem erros de frequência.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Pacotes forecast e stats, objetos criados nos steps anteriores.",
                                  "tips": "Salve objetos com saveRDS() para reutilização em análises futuras.",
                                  "learningObjective": "Garantir que a frequência suporte detecção e modelagem sazonal.",
                                  "commonMistakes": "Usar frequência errada (ex: 365 em dados mensais), distorcendo ciclos."
                                }
                              ],
                              "practicalExample": "Dado um dataset de vendas diárias irregulares (com missing em feriados), configure zoo com order.by=dates, agregue para mensal (frequency=12), aplique STL para decompor sazonalidade e visualize picos de fim de ano.",
                              "finalVerifications": [
                                "frequency() retorna valor correto (ex: 12 para mensal).",
                                "Nenhum NA introduzido por desalinhamento temporal.",
                                "Plot da série mostra alinhamento sazonal lógico.",
                                "Decomposição STL revela componentes sazonais coerentes.",
                                "Agregações mensais/diárias batem com somas manuais.",
                                "Objeto compatível com forecast::auto.arima() sem warnings."
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração de frequency para dados regulares/irregulares (80% acerto).",
                                "Manipulação correta de irregularidades sem perda de dados chave.",
                                "Visualizações e decomposições demonstram compreensão sazonal.",
                                "Código reproduzível e comentado adequadamente.",
                                "Tratamento de erros comuns como time zones ou leap years.",
                                "Eficiência temporal: conclusão em <2 horas com resultados válidos."
                              ],
                              "crossCurricularConnections": [
                                "Programação em R: manipulação de data frames e funções vetoriais.",
                                "Estatística: modelagem sazonal e decomposição de séries.",
                                "Ciência de Dados: preparação de dados para ML em time series.",
                                "Matemática: conceitos de periodicidade e ciclos."
                              ],
                              "realWorldApplication": "Em finanças, configurar frequency=252 (dias úteis) em xts para dados de ações irregulares, permitindo análise sazonal de retornos e previsão de volatilidade; em meteorologia, usar zoo para dados de precipitação diária com gaps, suportando modelos sazonais de clima."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.3.3",
                        "name": "Validação e Correção de Índices Temporais",
                        "description": "Processos para verificar a integridade do índice temporal e realizar ajustes necessários, assegurando bases de dados robustas para análise exploratória e modelagem.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.3.1",
                            "name": "Validar propriedades do índice temporal",
                            "description": "Verificar monotonicidade crescente, ausência de duplicatas e completude das datas usando funções como is.unsorted() ou summary() em objetos temporais no R.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e carregar o objeto temporal",
                                  "subSteps": [
                                    "Instale e carregue bibliotecas necessárias como zoo ou xts: install.packages('zoo'); library(zoo)",
                                    "Crie ou carregue um objeto de série temporal, ex: ts_data <- zoo(rnorm(100), seq(as.Date('2020-01-01'), by='day', length.out=100))",
                                    "Extraia o índice temporal: index <- index(ts_data)",
                                    "Visualize o índice inicial com summary(index) e plot(index)",
                                    "Confirme o tipo do índice com class(index)"
                                  ],
                                  "verification": "O objeto temporal está carregado e o índice é acessível via index(ts_data); summary(index) mostra min, max e quartis",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "R e RStudio",
                                    "Pacote zoo ou xts",
                                    "Dataset de exemplo com datas"
                                  ],
                                  "tips": "Use as.Date() para garantir formato correto de datas; sempre verifique class() antes de prosseguir",
                                  "learningObjective": "Configurar corretamente um objeto temporal no R para validação subsequente",
                                  "commonMistakes": [
                                    "Esquecer de carregar bibliotecas",
                                    "Confundir index() com time()",
                                    "Usar formatos de data inválidos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar monotonicidade crescente do índice",
                                  "subSteps": [
                                    "Use is.unsorted(index, strictly = TRUE) para checar se não está ordenado crescentemente",
                                    "Calcule diferenças: diffs <- diff(as.numeric(index)); verifique if(all(diffs > 0))",
                                    "Para índices irregulares, use order(index) == seq_along(index)",
                                    "Registre o resultado: monotonic <- !is.unsorted(index, strictly = TRUE)",
                                    "Plote o índice para inspeção visual: plot(index)"
                                  ],
                                  "verification": "is.unsorted(index, strictly = TRUE) retorna FALSE; todas as diferenças são positivas",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Funções base R: is.unsorted(), diff()",
                                    "Gráficos: plot()"
                                  ],
                                  "tips": "strictly = TRUE garante crescimento estrito; use as.numeric() para índices POSIXct",
                                  "learningObjective": "Aplicar testes estatísticos para confirmar ordenação temporal estrita",
                                  "commonMistakes": [
                                    "Usar strictly = FALSE",
                                    "Ignorar NaNs em diff()",
                                    "Não converter POSIXct para numérico"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detectar ausência de duplicatas no índice",
                                  "subSteps": [
                                    "Identifique duplicatas: dups <- duplicated(index) | duplicated(index, fromLast = TRUE)",
                                    "Conte duplicatas: sum(dups)",
                                    "Liste posições: which(dups)",
                                    "Visualize duplicatas: index[which(dups)]",
                                    "Confirme ausência: if(any(dups)) warning('Duplicatas encontradas') else message('Sem duplicatas')"
                                  ],
                                  "verification": "duplicated(index) retorna todos FALSE; sum(duplicated(index)) == 0",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Função duplicated() do base R"
                                  ],
                                  "tips": "Use fromLast = TRUE para capturar todas; combine com unique() para relatório",
                                  "learningObjective": "Detectar e quantificar repetições em sequências temporais",
                                  "commonMistakes": [
                                    "Verificar só duplicated() sem fromLast",
                                    "Confundir com NA values",
                                    "Não checar tolerance em floats"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar completude das datas no índice",
                                  "subSteps": [
                                    "Defina sequência esperada: expected <- seq(min(index), max(index), by = 'day')",
                                    "Identifique gaps: missing <- setdiff(expected, index)",
                                    "Conte gaps: length(missing)",
                                    "Use summary(index) para estatísticas e detectar irregularidades",
                                    "Gere relatório: paste('Gaps:', length(missing), 'datas esperadas:', length(expected))"
                                  ],
                                  "verification": "setdiff(seq(min(index), max(index), by='day'), index) é vazio; length(index) == length(expected)",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Funções: seq(), setdiff()",
                                    "summary()"
                                  ],
                                  "tips": "Ajuste 'by' para frequência (day, month); ignore fins de semana se aplicável",
                                  "learningObjective": "Verificar ausência de lacunas em séries temporais regulares",
                                  "commonMistakes": [
                                    "by incorreto (ex: 'day' em dados mensais)",
                                    "Não considerar frequência real",
                                    "Ignorar feriados em dados diários"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um dataset de vendas diárias de uma loja de 2023 (zoo(sales, seq(as.Date('2023-01-01'), by='day', length.out=365))), valide: monotonicidade (datas crescentes), sem duplicatas (nenhum dia repetido) e completude (365 dias sem gaps). Use is.unsorted(index) == FALSE, sum(duplicated(index)) == 0 e setdiff(seq(min,max,'day'), index) vazio.",
                              "finalVerifications": [
                                "Índice é monotonicamente crescente: !is.unsorted(index, strictly=TRUE)",
                                "Nenhuma duplicata: sum(duplicated(index)) == 0",
                                "Completude total: length(index) == length(seq(min(index), max(index), by=frequencia))",
                                "Sem NA no índice: !any(is.na(index))",
                                "Tipo correto: inherits(index, 'Date') ou 'POSIXct'",
                                "Visualização confirma: plot(index) mostra linha reta crescente"
                              ],
                              "assessmentCriteria": [
                                "Explica monotonicidade e usa is.unsorted corretamente",
                                "Detecta duplicatas com duplicated e fromLast=TRUE",
                                "Constrói sequência esperada com seq() e compara com setdiff",
                                "Gera relatório automatizado com mensagens/warnings",
                                "Identifica e discute erros comuns como gaps em fins de semana",
                                "Aplica em dataset real com output reproduzível"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Sequências ordenadas e monotonicidade",
                                "Programação: Manipulação de vetores e funções lógicas em R",
                                "Estatística: Pré-processamento de dados para modelagem temporal",
                                "Ciência de Dados: Qualidade de dados em pipelines ETL"
                              ],
                              "realWorldApplication": "Em finanças, validar índices de preços de ações para evitar erros em modelos ARIMA; em meteorologia, garantir séries diárias de temperatura sem gaps para previsões; em e-commerce, checar logs de vendas para análises precisas de tendências sazonais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.3.2",
                            "name": "Corrigir erros de indexação",
                            "description": "Aplicar técnicas como na.locf() para preencher valores ausentes ou reindexar com seq.Date() para alinhar lacunas em séries temporais não estacionárias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Diagnosticar erros de indexação na série temporal",
                                  "subSteps": [
                                    "Carregue o pacote zoo com library(zoo).",
                                    "Inspecione o índice da série usando index(ts_object) ou names(data).",
                                    "Identifique gaps ou duplicatas com diff(as.numeric(index(ts_object))) e verifique NAs com any(is.na(ts_object)).",
                                    "Plote a série com plot(ts_object) para visualização gráfica de irregularidades."
                                  ],
                                  "verification": "O relatório lista todos os gaps, duplicatas e NAs identificados, com plot confirmando visualmente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "R instalado",
                                    "Pacote zoo",
                                    "Dataset de exemplo com séries temporais irregulares"
                                  ],
                                  "tips": "Sempre compare o índice com uma sequência esperada de datas usando seq.Date(as.Date('2020-01-01'), as.Date('2020-12-31'), 'day').",
                                  "learningObjective": "Identificar precisamente tipos e localizações de erros de indexação em séries temporais.",
                                  "commonMistakes": [
                                    "Ignorar gaps sutis em séries diárias",
                                    "Confundir NAs nos valores com gaps no índice"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preencher valores ausentes com na.locf()",
                                  "subSteps": [
                                    "Aplique na.locf(ts_object, na.rm=FALSE) para propagar a última observação conhecida para frente.",
                                    "Se necessário, use na.locf(ts_object, fromLast=TRUE) para preenchimento reverso.",
                                    "Combine com merge.zoo() se houver múltiplas séries para alinhar.",
                                    "Verifique o resultado com summary(na.locf(ts_object))."
                                  ],
                                  "verification": "Nenhum NA restante nos valores após summary() e length(na.locf(ts_object)) == length(original).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Pacote zoo carregado",
                                    "Série temporal com NAs identificados"
                                  ],
                                  "tips": "Use na.locf com fromLast=TRUE apenas se a série for estacionária e o preenchimento reverso fizer sentido contextual.",
                                  "learningObjective": "Aplicar preenchimento de LOCF de forma precisa para manter a continuidade da série.",
                                  "commonMistakes": [
                                    "Aplicar na.rm=TRUE prematuramente, removendo dados úteis",
                                    "Não considerar direção do preenchimento para séries com tendências"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Reindexar a série com seq.Date()",
                                  "subSteps": [
                                    "Defina o intervalo completo: full_index <- seq.Date(start_date, end_date, by='day').",
                                    "Crie um novo zoo object: corrected_ts <- zoo(ts_object, full_index).",
                                    "Preencha gaps restantes com na.locf(corrected_ts).",
                                    "Ajuste frequência se necessário com as.ts() para conversão em ts object."
                                  ],
                                  "verification": "index(corrected_ts) é idêntico a full_index sem gaps, confirmado por all(diff(as.numeric(index(corrected_ts))) == 1).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Função seq.Date()",
                                    "Pacote zoo",
                                    "Datas de início e fim conhecidas"
                                  ],
                                  "tips": "Use by='day' ou 'business' com pacote timeDate para alinhar com calendários reais de trading.",
                                  "learningObjective": "Reindexar séries não estacionárias para criar um índice temporal contínuo e alinhado.",
                                  "commonMistakes": [
                                    "Definir seq.Date com frequência errada (ex: 'day' em dados mensais)",
                                    "Perder ordem temporal ao reindexar sem ordenação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e finalizar a correção da indexação",
                                  "subSteps": [
                                    "Compare estatísticas pré e pós: summary(original) vs summary(corrected_ts).",
                                    "Teste estacionariedade com adf.test(corrected_ts) do pacote tseries.",
                                    "Plote antes/depois com par(mfrow=c(2,1)); plot(original); plot(corrected_ts).",
                                    "Salve o objeto corrigido com saveRDS(corrected_ts, 'corrected_ts.rds')."
                                  ],
                                  "verification": "Testes estatísticos mostram melhoria (sem gaps, estacionariedade preservada) e plots visuais confirmam alinhamento.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Pacotes tseries e zoo",
                                    "Funções de plot e teste"
                                  ],
                                  "tips": "Registre mudanças em um log para reproducibilidade em análises futuras.",
                                  "learningObjective": "Validar integralmente a correção para garantir integridade da série temporal.",
                                  "commonMistakes": [
                                    "Pular testes de estacionariedade, assumindo correção automática",
                                    "Sobrescrita do original sem backup"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um dataset de temperaturas diárias de 2023 com 10 dias de feriados faltando (NAs no índice), aplique na.locf para propagar temperaturas e reindexe com seq.Date('2023-01-01', '2023-12-31', 'day'), resultando em uma série contínua de 365 observações prontas para modelagem ARIMA.",
                              "finalVerifications": [
                                "Índice temporal é contínuo sem gaps ou duplicatas.",
                                "Nenhum NA nos valores da série.",
                                "Estatísticas descritivas (média, variância) preservadas ou melhoradas.",
                                "Visualização gráfica mostra alinhamento suave.",
                                "Teste ADF confirma não rejeição de estacionariedade (p>0.05).",
                                "Frequência da série matches o domínio (ex: daily)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de 100% dos erros iniciais.",
                                "Correta aplicação de na.locf sem perda de dados essenciais.",
                                "Reindexação exata com seq.Date, sem offsets temporais.",
                                "Validação estatística e visual completa.",
                                "Eficiência temporal dentro dos estimates (total <2h)."
                              ],
                              "crossCurricularConnections": [
                                "Programação em R para manipulação de dados.",
                                "Estatística inferencial (testes de estacionariedade).",
                                "Gestão de bancos de dados (alinhamento temporal).",
                                "Análise financeira (séries de preços com gaps de trading).",
                                "Visualização de dados (ggplot2 para plots avançados)."
                              ],
                              "realWorldApplication": "Em meteorologia, corrige séries de precipitação com sensores offline para previsões precisas; em finanças, alinha dados de ações com feriados para backtesting de estratégias de trading sem vieses de indexação."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.3.3",
                            "name": "Realizar transformações básicas de índice",
                            "description": "Executar resampling com aggregate() ou apply.daily() para converter frequências e preparar dados para métodos de previsão automáticos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e Inspecionar Dados de Série Temporal",
                                  "subSteps": [
                                    "Carregue a biblioteca necessária (ex: zoo ou xts) com library(zoo).",
                                    "Importe os dados de série temporal usando read.zoo() ou similar.",
                                    "Use frequency() ou start/end() para identificar a frequência atual (diária, horária, etc.).",
                                    "Visualize com plot() para confirmar estrutura temporal.",
                                    "Verifique missing values com anyNA() ou summary()."
                                  ],
                                  "verification": "Confirme que frequency() retorna o valor esperado e plot() mostra série contínua sem gaps óbvios.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "R instalado, biblioteca zoo/xts, arquivo de dados de exemplo (CSV com timestamp e valores).",
                                  "tips": "Sempre defina o índice temporal com as.Date() ou Sys.time() para precisão.",
                                  "learningObjective": "Entender a estrutura atual da série temporal para decidir transformações necessárias.",
                                  "commonMistakes": "Ignorar timezone mismatches ou confundir data com POSIXct sem conversão."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Frequência Alvo e Escolher Função de Agregação",
                                  "subSteps": [
                                    "Decida a nova frequência (ex: de diária para mensal com 'month').",
                                    "Escolha aggregate() para resample simples (média, soma) ou apply.daily() para funções diárias.",
                                    "Defina a função de agregação: mean, sum, first, last, etc.",
                                    "Teste sintaxe: aggregate(serie, FUN=mean, by=month).",
                                    "Considere alinhamento: end='month' para fim do período."
                                  ],
                                  "verification": "Escreva um snippet de código comentado e execute dry-run com head() para preview.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Documentação de zoo::aggregate(), dados preparados do Step 1.",
                                  "tips": "Use FUN=list(mean=mean, sd=sd) para múltiplas estatísticas em um passo.",
                                  "learningObjective": "Selecionar apropriadamente métodos de resampling baseados na necessidade de previsão.",
                                  "commonMistakes": "Escolher soma em vez de média para séries normalizadas, levando a distorções."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar Resampling com aggregate() ou apply.daily()",
                                  "subSteps": [
                                    "Aplique aggregate(serie_original, FUN=mean, by=month) para conversão.",
                                    "Para apply.daily(): use apply.daily(serie, FUN=mean) em dados intradiários.",
                                    "Atribua a nova série: serie_resampled <- aggregate(...).",
                                    "Confirme nova frequência com frequency(serie_resampled).",
                                    "Salve ou exporte se necessário."
                                  ],
                                  "verification": "Execute e verifique dim(serie_resampled) e tail(head(serie_resampled)) para comprimento e valores corretos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Código R interativo (RStudio), dados do Step 1.",
                                  "tips": "Combine com na.fill() para lidar com NAs pós-resample.",
                                  "learningObjective": "Executar transformações de frequência de forma precisa e eficiente.",
                                  "commonMistakes": "Não especificar 'by' corretamente, resultando em NA total."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar Transformação e Preparar para Previsão Automática",
                                  "subSteps": [
                                    "Compare estatísticas: summary(serie_original) vs summary(serie_resampled).",
                                    "Plote ambas séries com lines() para sobreposição visual.",
                                    "Teste estacionariedade com adf.test() da biblioteca tseries.",
                                    "Remova outliers ou ajuste se necessário para auto.arima() ou forecast().",
                                    "Documente mudanças em um relatório ou comentário."
                                  ],
                                  "verification": "Gráficos mostram continuidade lógica e testes estatísticos passam thresholds básicos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Bibliotecas tseries/forecast, plots em RStudio.",
                                  "tips": "Use autoplot() do ggplot2 para visualizações profissionais.",
                                  "learningObjective": "Garantir que dados transformados sejam adequados para modelagem preditiva.",
                                  "commonMistakes": "Pular validação, levando a forecasts enviesados por resampling incorreto."
                                }
                              ],
                              "practicalExample": "Dado um conjunto de preços de ações diários de 2023 (ex: AAPL.csv com colunas Date e Close), use aggregate(Close ~ month(Date), data=precos_diarios, mean) para obter médias mensais, preparando para forecast::auto.arima() em previsões trimestrais.",
                              "finalVerifications": [
                                "Nova frequência confirmada com frequency() ou indexfreq().",
                                "Ausência de NAs introduzidos (sum(is.na()) == 0).",
                                "Estatísticas descritivas preservam tendências originais (média ±10%).",
                                "Plot comparativo mostra alinhamento lógico.",
                                "Código roda sem erros e é reproduzível."
                              ],
                              "assessmentCriteria": [
                                "Precisão na execução do resampling (100% match com output esperado).",
                                "Escolha correta de aggregate() vs apply.daily() baseada no contexto.",
                                "Validação completa com pelo menos 3 métricas/visuais.",
                                "Código limpo, comentado e eficiente (sem loops desnecessários).",
                                "Preparação explícita para métodos de previsão (ex: teste de estacionariedade)."
                              ],
                              "crossCurricularConnections": [
                                "Programação em R: Manipulação de dados com dplyr/tidyr.",
                                "Estatística: Conceitos de agregação e perda de informação em resample.",
                                "Finanças: Análise de séries temporais em mercados voláteis.",
                                "Machine Learning: Pré-processamento para modelos de forecasting como Prophet."
                              ],
                              "realWorldApplication": "Em empresas de varejo, transformar vendas horárias em diárias/semanal para previsão de estoque com auto.arima(), otimizando logística e reduzindo desperdícios."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.4",
                    "name": "Transformações de Dados Temporais",
                    "description": "Operações essenciais como limpeza, tratamento de valores ausentes, agregação e diferenciação para preparar dados para análise.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.4.1",
                        "name": "Limpeza de Dados Temporais",
                        "description": "Processos iniciais para identificar, corrigir ou remover inconsistências, outliers e erros nos dados de séries temporais, garantindo a integridade da sequência temporal.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.1.1",
                            "name": "Identificar outliers em séries temporais",
                            "description": "Aplicar métodos estatísticos como Z-score, IQR ou boxplots adaptados para dados sequenciais, considerando autocorrelação para detectar anomalias temporais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e Explorar a Série Temporal",
                                  "subSteps": [
                                    "Carregue os dados da série temporal em um ambiente como Python (pandas) ou R.",
                                    "Converta os dados para formato de série temporal (ex: pd.to_datetime e set_index).",
                                    "Realize uma análise exploratória: plote a série, verifique estacionariedade com testes como ADF.",
                                    "Calcule estatísticas descritivas básicas (média, mediana, desvio padrão) em janelas deslizantes.",
                                    "Identifique tendências e sazonalidades iniciais com decomposição STL."
                                  ],
                                  "verification": "Gráficos de linha e decomposição mostram estrutura temporal clara sem erros de carregamento.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python/R com bibliotecas pandas, statsmodels, matplotlib",
                                    "Dataset de série temporal (ex: AirPassengers.csv)"
                                  ],
                                  "tips": [
                                    "Use rolling windows para estatísticas locais; sempre padronize datas."
                                  ],
                                  "learningObjective": "Compreender a estrutura temporal dos dados para contextualizar outliers.",
                                  "commonMistakes": [
                                    "Ignorar formato de data",
                                    "Não tratar missing values",
                                    "Assumir independência imediata"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar Métodos Estatísticos Básicos para Detecção",
                                  "subSteps": [
                                    "Calcule Z-scores em janelas deslizantes (ex: z = (x - mean)/std com window=30).",
                                    "Implemente IQR adaptado: Q1 e Q3 em janelas, outliers como < Q1-1.5*IQR ou > Q3+1.5*IQR.",
                                    "Crie boxplots sequenciais agrupados por períodos (ex: mensal).",
                                    "Defina threshold (ex: |Z| > 3) e marque potenciais outliers.",
                                    "Compare resultados entre Z-score e IQR para consenso inicial."
                                  ],
                                  "verification": "Lista de índices de outliers gerada com Z-scores e IQR coincidentes em pelo menos 80%.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Código Python: scipy.stats.zscore, pandas rolling",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": [
                                    "Use window size adaptada ao período sazonal; teste sensibilidades."
                                  ],
                                  "learningObjective": "Dominar detecção univariada adaptada a sequências temporais.",
                                  "commonMistakes": [
                                    "Window fixa muito pequena/grande",
                                    "Aplicar global sem local",
                                    "Confundir sazonalidade com outlier"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Ajustar para Autocorrelação e Refinar Detecção",
                                  "subSteps": [
                                    "Estime autocorrelação com ACF/PACF plots.",
                                    "Ajuste modelo simples (ex: ARIMA) e extraia resíduos.",
                                    "Aplique Z-score ou IQR nos resíduos para detecção robusta.",
                                    "Use método ESD (Extreme Studentized Deviate) para séries temporais.",
                                    "Filtre falsos positivos comparando com modelo baseline."
                                  ],
                                  "verification": "Resíduos mostram autocorrelação reduzida (<0.1 em lags iniciais) e outliers consistentes.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Bibliotecas statsmodels.tsa, ruptures para changepoints",
                                    "Dataset com autocorrelação conhecida"
                                  ],
                                  "tips": [
                                    "Comece com ARIMA(1,1,1); valide com Ljung-Box test."
                                  ],
                                  "learningObjective": "Incorporar dependências temporais para detecção precisa de anomalias.",
                                  "commonMistakes": [
                                    "Ignorar ACF",
                                    "Sobreajustar modelo ARIMA",
                                    "Não validar resíduos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar, Visualizar e Interpretar Outliers",
                                  "subSteps": [
                                    "Plote série original com outliers destacados (scatter ou annotate).",
                                    "Crie dashboard com boxplots, Z-scores e resíduos lado a lado.",
                                    "Avalie impacto: remova outliers e compare métricas (MSE pré/pós).",
                                    "Contextualize: verifique se coincidem com eventos conhecidos (ex: feriados).",
                                    "Documente lista final com razões e confiança (ex: high/medium/low)."
                                  ],
                                  "verification": "Relatório com visualizações e lista final de 5-10% de outliers plausíveis.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Matplotlib/Seaborn/Plotly para plots interativos",
                                    "Relatório template em Markdown"
                                  ],
                                  "tips": [
                                    "Use cores para tipos de outlier; sempre busque explicações externas."
                                  ],
                                  "learningObjective": "Interpretar outliers no contexto temporal para decisões acionáveis.",
                                  "commonMistakes": [
                                    "Não visualizar",
                                    "Marcar todos como anomalias",
                                    "Ignorar contexto domínio"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um dataset de temperaturas diárias de uma cidade (ex: dados NOAA), identifique outliers como um pico de 45°C em inverno detectado via Z-score em janela de 30 dias ajustado por ARIMA, confirmando falha de sensor.",
                              "finalVerifications": [
                                "Lista de outliers com índices, valores e scores Z/IQR gerada corretamente.",
                                "Gráficos mostram detecção visual clara sem falsos negativos óbvios.",
                                "Resíduos pós-ajuste têm autocorrelação baixa (ACF <0.05).",
                                "Relatório interpreta pelo menos 3 outliers com contexto plausível.",
                                "Precisão simulada >85% em dataset de teste com anomalias injetadas.",
                                "Código reproduzível roda sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção: >80% recall/precision em validação.",
                                "Adequação de métodos: uso correto de janelas e ajuste autocorrelação.",
                                "Qualidade visual: plots claros e informativos.",
                                "Interpretação contextual: ligação com domínio real.",
                                "Eficiência computacional: tempo <5min para 10k pontos.",
                                "Robustez: funciona em dados com missing/sazonalidade."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python/R (Ciência da Computação).",
                                "Machine Learning: Pré-processamento para forecasting/anomaly detection.",
                                "Negócios: Detecção de fraudes em finanças ou vendas.",
                                "Engenharia: Monitoramento de sensores IoT.",
                                "Matemática: Estatística inferencial e modelagem estocástica."
                              ],
                              "realWorldApplication": "Em monitoramento de sistemas financeiros, detectar transações outliers em séries de volumes diários para prevenir fraudes; ou em saúde, identificar picos anormais em leituras de ECG para alertas médicos precoces."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.1.2",
                            "name": "Remover duplicatas em índices temporais",
                            "description": "Detectar e eliminar entradas duplicadas baseadas em timestamps, preservando a unicidade da série temporal sem perda de informação relevante.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e carregar dados de série temporal",
                                  "subSteps": [
                                    "Instale bibliotecas necessárias: pandas e numpy via pip.",
                                    "Carregue o dataset de série temporal definindo o índice como timestamp (pd.read_csv com parse_dates e index_col).",
                                    "Inspecione o índice com df.index.is_unique e df.index.duplicated().sum() para overview inicial.",
                                    "Visualize duplicatas com df.index[df.index.duplicated()].",
                                    "Converta índice para DatetimeIndex se necessário com pd.to_datetime()."
                                  ],
                                  "verification": "Confirme que df.index.dtype é datetime64[ns] e execute df.info() sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "pandas",
                                    "numpy",
                                    "dataset CSV de exemplo com timestamps"
                                  ],
                                  "tips": "Sempre defina o índice temporal cedo para evitar reindexação posterior.",
                                  "learningObjective": "Configurar corretamente um DataFrame de série temporal pronto para análise.",
                                  "commonMistakes": [
                                    "Esquecer de parse_dates levando a strings como índices",
                                    "Não converter para DatetimeIndex",
                                    "Ignorar timezone awareness"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Detectar e analisar duplicatas no índice temporal",
                                  "subSteps": [
                                    "Identifique duplicatas exatas com mask = df.index.duplicated(keep=False).",
                                    "Agrupe duplicatas com df.groupby(df.index).size() > 1 para contar ocorrências.",
                                    "Examine valores duplicados com df.loc[mask] para entender padrões (ex: valores idênticos ou ligeiramente diferentes).",
                                    "Registre estatísticas: total de duplicatas únicas e totais afetadas.",
                                    "Decida estratégia baseada na análise (manter first, last, mean para agregação)."
                                  ],
                                  "verification": "Gere relatório mostrando número de duplicatas detectadas e amostra de dados afetados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Jupyter Notebook ou script Python",
                                    "Dataset carregado do Step 1"
                                  ],
                                  "tips": "Use duplicated(keep=False) para ver todas as instâncias, não só as subsequentes.",
                                  "learningObjective": "Diagnosticar precisamente duplicatas em séries temporais para informar tratamento.",
                                  "commonMistakes": [
                                    "Confundir duplicated() com drop_duplicates()",
                                    "Não inspecionar valores além dos índices",
                                    "Assumir duplicatas sem verificação visual"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar remoção ou consolidação de duplicatas",
                                  "subSteps": [
                                    "Para remoção simples: df_clean = df[~df.index.duplicated(keep='first')].",
                                    "Para agregação (ex: soma): df_clean = df.groupby(df.index).agg({'valor': 'sum'}).",
                                    "Mantenha índice único com df_clean.index = pd.DatetimeIndex(df_clean.index).",
                                    "Reindexe se necessário para frequência regular com df_clean.asfreq('D', method='ffill').",
                                    "Salve versão limpa com df_clean.to_csv('cleaned_data.csv')."
                                  ],
                                  "verification": "Verifique df_clean.index.is_unique == True e compare shapes antes/depois.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "DataFrame com duplicatas do Step 2",
                                    "pandas"
                                  ],
                                  "tips": "Escolha 'first' ou 'last' baseado no contexto temporal; agregue para métricas cumulativas.",
                                  "learningObjective": "Implementar estratégias de limpeza que preservam informação relevante.",
                                  "commonMistakes": [
                                    "Perder dados úteis com drop_duplicates() sem agregação",
                                    "Não resetar índice após groupby",
                                    "Ignorar NaNs introduzidos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e documentar a limpeza realizada",
                                  "subSteps": [
                                    "Confirme unicidade com assert df_clean.index.is_unique.",
                                    "Compare estatísticas descritivas antes/depois: df.describe() vs df_clean.describe().",
                                    "Plote séries antes/depois com df['valor'].plot() e df_clean['valor'].plot().",
                                    "Documente mudanças em log: duplicatas removidas, método usado.",
                                    "Teste robustez com novo dataset simulando duplicatas."
                                  ],
                                  "verification": "Todos asserts passam e plots mostram continuidade sem gaps inesperados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "df e df_clean",
                                    "matplotlib para plots"
                                  ],
                                  "tips": "Use asserts para automação de validação em pipelines.",
                                  "learningObjective": "Garantir qualidade e reprodutibilidade da limpeza de dados.",
                                  "commonMistakes": [
                                    "Não validar visualmente",
                                    "Esquecer documentação",
                                    "Assumir sucesso sem asserts"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um dataset de temperaturas horárias de uma estação meteorológica (ex: 'temp_data.csv' com colunas timestamp e temp), timestamps como '2023-01-01 12:00' aparecem duplicados devido a falha de sensor. Detecte 5 duplicados, agregue tomando a média das temps, resultando em índice único de 8760 entradas anuais limpas.",
                              "finalVerifications": [
                                "df.index.is_unique retorna True.",
                                "Número de entradas reduzido corretamente pelo número de duplicatas.",
                                "Estatísticas descritivas (mean, std) variam <5% da original.",
                                "Plot da série mostra continuidade sem saltos artificiais.",
                                "Grupo por índice tem size() == 1 em todos.",
                                "Sem NaNs introduzidos na coluna principal."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção: 100% das duplicatas identificadas.",
                                "Escolha adequada de estratégia (remoção vs agregação) justificada.",
                                "Código limpo, comentado e reproduzível.",
                                "Validações implementadas com asserts ou testes.",
                                "Documentação cobre antes/depois e decisões.",
                                "Tempo de execução eficiente (<1s para 10k rows)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Manipulação avançada de DataFrames em Python/pandas.",
                                "Estatística: Tratamento de dados para modelagem inferencial.",
                                "Banco de Dados: Conceitos de chaves primárias e integridade referencial.",
                                "Ciência de Computação: Algoritmos de hash para detecção de duplicatas.",
                                "Gestão de Projetos: Pipelines ETL para dados reais."
                              ],
                              "realWorldApplication": "Em trading algorítmico, preços de ações com ticks duplicados por latência de exchange são limpos para backtesting preciso de estratégias, evitando overfitting em séries temporais financeiras."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.1.3",
                            "name": "Padronizar formatos de data e hora",
                            "description": "Converter strings de datas em objetos datetime consistentes (ex: usando pandas.to_datetime), lidando com fusos horários e formatos variados para uniformizar a base.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Inspeção Inicial dos Dados de Data e Hora",
                                  "subSteps": [
                                    "Carregue o dataset usando pandas.read_csv() ou equivalente.",
                                    "Use df['data_coluna'].dtype para verificar o tipo atual (object, string?).",
                                    "Aplique df['data_coluna'].head(20) e df['data_coluna'].tail(20) para visualizar amostras.",
                                    "Use df['data_coluna'].value_counts().head(10) para identificar formatos comuns.",
                                    "Registre problemas iniciais como strings malformadas ou valores ausentes."
                                  ],
                                  "verification": "Lista de formatos identificados e contagem de valores únicos impressa no console.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Pandas instalado",
                                    "Jupyter Notebook ou IDE Python",
                                    "Dataset de exemplo com datas variadas (CSV)"
                                  ],
                                  "tips": "Use pd.options.display.max_rows = 50 para visualizar mais linhas.",
                                  "learningObjective": "Identificar variações de formatos de data para planejar a conversão.",
                                  "commonMistakes": "Ignorar valores NaN ou outliers que parecem datas inválidas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Limpeza Básica e Preparação",
                                  "subSteps": [
                                    "Remova ou substitua valores nulos com pd.NA usando df['data_coluna'].fillna(pd.NA).",
                                    "Padronize strings removendo espaços extras com .str.strip().",
                                    "Corrija formatos óbvios manualmente, ex: substitua 'DD/MM/YY' por 'DD/MM/YYYY' usando regex.",
                                    "Crie uma coluna auxiliar para backup: df['data_backup'] = df['data_coluna'].copy().",
                                    "Defina uma lista de formatos esperados comuns (ex: '%d/%m/%Y', '%Y-%m-%d')."
                                  ],
                                  "verification": "Coluna limpa sem espaços extras e backup criado; df.info() mostra contagens corretas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Pandas",
                                    "Regular expressions (re module opcional)"
                                  ],
                                  "tips": "Teste regex em uma amostra pequena antes de aplicar no dataset inteiro.",
                                  "learningObjective": "Preparar dados inconsistentes para conversão segura sem perda de informação.",
                                  "commonMistakes": "Sobrescrever a coluna original sem backup, perdendo dados originais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Conversão para Objetos Datetime",
                                  "subSteps": [
                                    "Aplique pd.to_datetime(df['data_coluna'], infer_datetime_format=True, errors='coerce').",
                                    "Se inferência falhar, especifique format: pd.to_datetime(df['data_coluna'], format='%d/%m/%Y').",
                                    "Para múltiplos formatos, use uma função custom com try-except para cada formato.",
                                    "Atribua de volta: df['data_padronizada'] = resultado da conversão.",
                                    "Verifique NaT (Not a Time): df['data_padronizada'].isna().sum()."
                                  ],
                                  "verification": "df['data_padronizada'].dtype == 'datetime64[ns]' e NaT < 5% dos dados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Pandas",
                                    "Função custom de conversão (opcional)"
                                  ],
                                  "tips": "Use errors='coerce' para converter inválidos em NaT em vez de falhar.",
                                  "learningObjective": "Transformar strings variadas em objetos datetime consistentes.",
                                  "commonMistakes": "Especificar formato errado, causando 100% NaT; sempre teste em subset."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Padronização de Fusos Horários",
                                  "subSteps": [
                                    "Localize datas: df['data_padronizada'] = df['data_padronizada'].dt.tz_localize('UTC') ou timezone específico.",
                                    "Para fusos variados, use tz_convert: df['data_padronizada'].dt.tz_convert('UTC').",
                                    "Se sem timezone, assuma local e converta: pd.to_datetime(..., utc=True).",
                                    "Crie coluna final: df['data_utc'] = df['data_padronizada'].dt.tz_convert('UTC').",
                                    "Arredonde para granularidade desejada, ex: .dt.floor('D') para diário."
                                  ],
                                  "verification": "df['data_utc'].dt.tz == 'UTC' para todas as entradas não-NaT.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Pandas com pytz ou zoneinfo",
                                    "Lista de timezones comuns"
                                  ],
                                  "tips": "Use pytz.all_timezones para listar opções; prefira UTC como padrão.",
                                  "learningObjective": "Uniformizar timezones para análises globais de séries temporais.",
                                  "commonMistakes": "Dupla localização causando erros; verifique tzinfo antes."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validação e Testes Finais",
                                  "subSteps": [
                                    "Compare original vs padronizado: df[['data_coluna', 'data_utc']].sample(50).",
                                    "Teste ordenação: assert df['data_utc'].is_monotonic_increasing.",
                                    "Calcule métricas: % de conversões bem-sucedidas = 1 - df['data_utc'].isna().mean().",
                                    "Salve dataset processado: df.to_csv('dataset_padronizado.csv', index=False).",
                                    "Documente o processo em um README ou notebook markdown."
                                  ],
                                  "verification": "Taxa de sucesso >95%, ordenação monotonic e dataset salvo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Pandas",
                                    "Notebook para documentação"
                                  ],
                                  "tips": "Use df.plot() para visualizar timeline e detectar anomalias.",
                                  "learningObjective": "Garantir integridade e usabilidade dos dados padronizados.",
                                  "commonMistakes": "Não testar ordenação, levando a erros em análises temporais."
                                }
                              ],
                              "practicalExample": "Em um dataset de vendas de e-commerce (vendas.csv) com datas como '2023-01-15', '15/01/2023', 'Jan 15 2023 14:30 EST', aplique pd.to_datetime com inferência, localize para 'America/Sao_Paulo' onde necessário, converta tudo para UTC, resultando em df['timestamp_utc'] pronto para análise de séries temporais de vendas diárias.",
                              "finalVerifications": [
                                "Todas as entradas válidas são datetime64[ns, UTC].",
                                "Taxa de NaT < 2% do total.",
                                "Coluna é monotonic increasing após sort.",
                                "Comparação amostral: 100% das datas convertidas corretamente.",
                                "Sem perda de dados (linhas originais preservadas).",
                                "Timezone uniforme em UTC para todas."
                              ],
                              "assessmentCriteria": [
                                "Precisão da conversão: >98% de strings válidas convertidas corretamente.",
                                "Eficiência: Tempo total < 2h para dataset de 10k linhas.",
                                "Robustez: Função custom lida com 5+ formatos variados.",
                                "Documentação: Notebook com código reproduzível e explicações.",
                                "Validação: Testes unitários para funções de conversão.",
                                "Escalabilidade: Funciona em datasets >100k linhas sem crash."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Manipulação de strings e regex em Python.",
                                "Estatística: Preparação para modelagem de séries temporais (ARIMA, Prophet).",
                                "Banco de Dados: Normalização de timestamps em SQL (CAST, AT TIME ZONE).",
                                "Ciência de Dados: Integração com visualizações (Matplotlib Seaborn timelines)."
                              ],
                              "realWorldApplication": "Em análises financeiras, padronizar timestamps de transações globais permite calcular retornos ajustados por timezone em plataformas como Bloomberg; em IoT, uniformiza logs de sensores para detecção de anomalias em tempo real."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.4.2",
                        "name": "Tratamento de Valores Ausentes",
                        "description": "Técnicas específicas para imputar ou gerenciar missing values em séries temporais, mantendo a continuidade e evitando introduzir vieses na estrutura temporal.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.2.1",
                            "name": "Aplicar forward fill (bfill)",
                            "description": "Preencher valores ausentes com o último valor observado anterior (forward fill) ou próximo (backward fill), ideal para séries com pouca variabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos de Forward Fill (ffill) e Backward Fill (bfill)",
                                  "subSteps": [
                                    "Defina forward fill como a propagação do último valor não-nulo para frente até o próximo valor válido.",
                                    "Defina backward fill como a propagação do próximo valor não-nulo para trás até o último valor válido.",
                                    "Identifique cenários ideais: séries com pouca variabilidade, como níveis de estoque ou temperaturas estáveis.",
                                    "Compare com outros métodos (média, interpolação) e note quando ffill/bfill é superior para dados temporais sequenciais.",
                                    "Estude documentação oficial do Pandas para métodos .ffill() e .bfill()."
                                  ],
                                  "verification": "Explique em suas palavras a diferença entre ffill e bfill com um exemplo simples de 5 valores.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Pandas: https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.ffill.html",
                                    "Notebook Jupyter vazio"
                                  ],
                                  "tips": "Visualize com um diagrama simples: NaN -> valor anterior (ffill) vs. próximo (bfill).",
                                  "learningObjective": "Diferenciar conceitualmente ffill e bfill e identificar aplicações adequadas em séries temporais.",
                                  "commonMistakes": [
                                    "Confundir ffill com bfill",
                                    "Ignorar que ambos requerem dados ordenados por tempo",
                                    "Aplicar em dados não sequenciais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar Dataset de Série Temporal com Valores Ausentes",
                                  "subSteps": [
                                    "Carregue uma biblioteca Pandas: import pandas as pd.",
                                    "Crie ou carregue um DataFrame com índice datetime e coluna numérica contendo NaNs intencionais.",
                                    "Garanta que o índice esteja ordenado cronologicamente usando sort_index().",
                                    "Inspecione missing values com .isnull().sum() e .info().",
                                    "Visualize os dados com .plot() para identificar padrões de missing data."
                                  ],
                                  "verification": "Execute df.isnull().sum() e confirme presença de NaNs; plote o gráfico sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Pandas instalado",
                                    "Exemplo de dataset: pd.date_range('2023-01-01', periods=10, freq='D') com valores aleatórios e NaNs"
                                  ],
                                  "tips": "Use pd.Series([1, None, 3, None, 5], index=pd.date_range('2023-01-01', periods=5)) para teste rápido.",
                                  "learningObjective": "Preparar dados temporais limpos e ordenados prontos para imputação.",
                                  "commonMistakes": [
                                    "Índice não datetime",
                                    "Dados não ordenados",
                                    "Não verificar missing values antes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Forward Fill e Backward Fill nos Dados",
                                  "subSteps": [
                                    "Aplique forward fill: df['coluna'].ffill(inplace=True) ou df_filled = df.fillna(method='ffill').",
                                    "Aplique backward fill separadamente: df_bfill = df.fillna(method='bfill').",
                                    "Combine ambos se necessário: df.ffill().bfill() para preencher todos os NaNs.",
                                    "Salve cópias originais para comparação: df_original.copy().",
                                    "Atualize inplace apenas após testes para evitar perda de dados."
                                  ],
                                  "verification": "Compare df_original e df_filled; confirme que NaNs foram substituídos corretamente com print(df_filled).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notebook Jupyter com dados do Step 2",
                                    "Pandas DataFrame"
                                  ],
                                  "tips": "Use method='ffill' em fillna() para compatibilidade; evite inplace=True em produção.",
                                  "learningObjective": "Executar ffill e bfill com sintaxe correta e opções de combinação.",
                                  "commonMistakes": [
                                    "Usar inplace=True sem backup",
                                    "Esquecer de especificar axis=0 para séries",
                                    "Aplicar em colunas categóricas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar, Comparar e Documentar Resultados",
                                  "subSteps": [
                                    "Compare visualmente: plote df_original, df_ffill e df_bfill lado a lado.",
                                    "Calcule estatísticas: df.describe() antes/depois para validar preservação de tendências.",
                                    "Teste edge cases: NaNs no início (ffill falha, use bfill) ou fim (bfill falha, use ffill).",
                                    "Documente escolhas em comentários ou relatório: 'ffill usado por estabilidade de série'.",
                                    "Exporte resultados: df_filled.to_csv('dados_imputados.csv')."
                                  ],
                                  "verification": "Gráficos mostram preenchimento lógico sem distorções; estatísticas comparáveis.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Matplotlib/Seaborn para plots",
                                    "Dados preenchidos do Step 3"
                                  ],
                                  "tips": "Use subplots: fig, axs = plt.subplots(1,3); para comparações rápidas.",
                                  "learningObjective": "Validar eficácia da imputação e documentar processo para reprodutibilidade.",
                                  "commonMistakes": [
                                    "Não testar edge cases",
                                    "Ignorar mudanças em estatísticas",
                                    "Não documentar rationale"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um dataset de temperaturas diárias de uma cidade (ex: [20, NaN, NaN, 22, NaN, 21]), aplique ffill para obter [20, 20, 20, 22, 22, 21], propagando 20 para frente e 22 para o NaN final após combinação com bfill.",
                              "finalVerifications": [
                                "Todos os NaNs foram preenchidos sem introduzir valores artificiais extremos.",
                                "Ordem temporal preservada: df.index.is_monotonic_increasing == True.",
                                "Estatísticas descritivas (média, mediana) alteradas minimamente (<5%).",
                                "Visualização gráfica mostra série contínua e realista.",
                                "Código reproduzível gera os mesmos resultados em nova execução.",
                                "Edge cases (NaNs iniciais/finais) tratados corretamente com combinação ffill+bfill."
                              ],
                              "assessmentCriteria": [
                                "Exatidão na aplicação: 100% dos NaNs preenchidos logicamente.",
                                "Compreensão conceitual: Explicação correta de ffill vs bfill.",
                                "Eficiência de código: Uso de métodos vetoriais Pandas sem loops.",
                                "Validação robusta: Comparações visuais e estatísticas incluídas.",
                                "Documentação: Rationale e edge cases abordados.",
                                "Tempo de execução: <1s para datasets médios (10k linhas)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Imputação em análise descritiva e modelagem preditiva.",
                                "Programação: Manipulação de dados em Python/Pandas para automação.",
                                "Matemática: Preservação de tendências em funções discretas.",
                                "Ciência de Dados: Pré-processamento para ML em séries temporais.",
                                "Negócios: Tratamento de dados operacionais em relatórios financeiros."
                              ],
                              "realWorldApplication": "Em finanças, preencha preços de ações ausentes em fins de semana com o último preço de fechamento (ffill) para análises contínuas; em IoT, complete leituras de sensores falhas em monitoramento ambiental com valores estáveis anteriores."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.2.2",
                            "name": "Realizar interpolação linear",
                            "description": "Calcular valores intermediários ausentes usando interpolação linear entre pontos observados adjacentes, preservando tendências locais na série.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos da interpolação linear",
                                  "subSteps": [
                                    "Estude a definição: interpolação linear estima valores intermediários entre dois pontos conhecidos usando uma reta.",
                                    "Analise a fórmula básica: y = y1 + (y2 - y1) * (x - x1) / (x2 - x1).",
                                    "Visualize graficamente: desenhe pontos (x1,y1) e (x2,y2) e trace a linha entre eles.",
                                    "Diferencie de extrapolação: interpolação fica dentro do intervalo [x1,x2].",
                                    "Identifique aplicações em séries temporais: preenche gaps preservando tendências locais."
                                  ],
                                  "verification": "Explique em suas palavras a fórmula e desenhe um gráfico simples com um valor interpolado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis para gráficos",
                                    "Vídeo tutorial sobre interpolação linear (ex: Khan Academy)"
                                  ],
                                  "tips": "Sempre pense graficamente primeiro para intuitar o resultado antes de calcular.",
                                  "learningObjective": "Dominar o conceito teórico e a fórmula da interpolação linear em contextos de séries temporais.",
                                  "commonMistakes": [
                                    "Confundir interpolação com extrapolação",
                                    "Usar pontos não adjacentes",
                                    "Ignorar o denominador (x2 - x1)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar valores ausentes e pontos adjacentes em uma série temporal",
                                  "subSteps": [
                                    "Examine a série temporal: liste os timestamps e valores observados.",
                                    "Marque os valores ausentes (NaN ou missing).",
                                    "Selecione pontos adjacentes: o par mais próximo antes e depois do gap.",
                                    "Verifique se o gap é simples (um ou poucos pontos) para linear ser adequada.",
                                    "Registre os pares (x1,y1) e (x2,y2) para cada missing value."
                                  ],
                                  "verification": "Crie uma tabela com a série original destacando gaps e pares adjacentes selecionados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets com dados de exemplo",
                                    "Série temporal de amostra (ex: temperaturas diárias)"
                                  ],
                                  "tips": "Confirme que os pontos são temporalmente adjacentes para preservar tendências locais.",
                                  "learningObjective": "Habilitar a detecção precisa de gaps e seleção correta de pontos para interpolação.",
                                  "commonMistakes": [
                                    "Escolher pontos não consecutivos",
                                    "Ignorar múltiplos gaps consecutivos",
                                    "Usar valores médios em vez de adjacentes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular valores interpolados usando a fórmula",
                                  "subSteps": [
                                    "Aplique a fórmula para cada gap: substitua x1, y1, x2, y2 e x (posição do missing).",
                                    "Calcule passo a passo: primeiro (x - x1)/(x2 - x1), depois multiplique pela diferença y.",
                                    "Arredonde adequadamente (ex: 2 casas decimais para dados contínuos).",
                                    "Repita para múltiplos gaps, usando resultados interpolados como novos adjacentes se necessário.",
                                    "Registre os novos valores em uma cópia da série."
                                  ],
                                  "verification": "Compare cálculo manual com resultado de calculadora ou Excel (função TREND ou LINEST).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Planilha com fórmulas prontas para verificação"
                                  ],
                                  "tips": "Teste com frações simples primeiro para validar a fórmula mentalmente.",
                                  "learningObjective": "Executar cálculos precisos de interpolação linear de forma manual e eficiente.",
                                  "commonMistakes": [
                                    "Erro de sinal na diferença (y2 - y1)",
                                    "Dividir por zero se x1=x2",
                                    "Arredondamento prematuro"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e interpretar os resultados na série temporal",
                                  "subSteps": [
                                    "Plote a série original e interpolada para visual inspeção.",
                                    "Verifique se os valores interpolados estão entre y1 e y2.",
                                    "Analise preservação de tendência: compare inclinações locais antes/depois.",
                                    "Calcule métricas simples: diferença média entre original e interpolado (se dados reais disponíveis).",
                                    "Documente o processo: anote fórmulas usadas e suposições."
                                  ],
                                  "verification": "Gráfico mostra linha suave sem quebras abruptas nos gaps interpolados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software de plotagem (Excel, Python Matplotlib ou Google Sheets)"
                                  ],
                                  "tips": "Sempre valide visualmente: um bom interpola deve 'parecer natural' na tendência.",
                                  "learningObjective": "Avaliar a qualidade da interpolação e sua adequação à série temporal.",
                                  "commonMistakes": [
                                    "Não plotar para verificação",
                                    "Aceitar valores fora do range [y1,y2]",
                                    "Ignorar mudanças na variância local"
                                  ]
                                }
                              ],
                              "practicalExample": "Série de temperaturas diárias: Dia 1 (x=1): 20°C, Dia 2 (x=2): missing, Dia 3 (x=3): 25°C. Cálculo: y = 20 + (25-20)*(2-1)/(3-1) = 20 + 5*0.5 = 22.5°C. A tendência crescente é preservada.",
                              "finalVerifications": [
                                "Todos os gaps foram preenchidos com valores entre os adjacentes.",
                                "Gráfico da série interpolada mostra continuidade suave nas tendências locais.",
                                "Cálculos manuais coincidem com ferramentas computacionais (erro < 0.01).",
                                "Nenhum valor extrapolado foi usado indevidamente.",
                                "Documentação inclui pares selecionados e fórmulas aplicadas.",
                                "Tendência geral da série (inclinação média) não alterou significativamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática: cálculos corretos em 100% dos gaps.",
                                "Seleção adequada de pontos: sempre adjacentes e temporais.",
                                "Validação visual: gráfico confirma preservação de tendências.",
                                "Eficiência: tempo de processamento alinhado com estimativas.",
                                "Interpretação: explicação clara do impacto na análise da série.",
                                "Documentação completa: passos reproduzíveis por terceiros."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Equações lineares e funções afins.",
                                "Programação: Implementação em Python (numpy.interp) ou R.",
                                "Física: Modelagem de movimentos uniformes em experimentos.",
                                "Economia: Preenchimento de dados em séries financeiras (ex: PIB trimestral).",
                                "Geociências: Interpolação em dados climáticos ou sensoriamento remoto."
                              ],
                              "realWorldApplication": "Em meteorologia, preenche medições faltantes de temperatura em estações automáticas para modelagem climática precisa; em finanças, estima preços de ações em dias feriados para análises de risco contínuas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.2.3",
                            "name": "Usar médias móveis para imputação",
                            "description": "Imputar missing values com médias rolantes (rolling mean) de janelas temporais vizinhas, suavizando flutuações e respeitando padrões locais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o Conjunto de Dados de Série Temporal",
                                  "subSteps": [
                                    "Carregue o dataset de série temporal usando pandas.read_csv() ou similar, garantindo que a coluna de tempo seja indexada com pd.to_datetime().",
                                    "Identifique valores ausentes (NaN) na coluna alvo usando df.isnull().sum() e visualize com df.plot() para entender padrões de missing values.",
                                    "Defina o tamanho da janela de média móvel (window) baseado na frequência dos dados, como 7 para dados diários semanais.",
                                    "Crie uma cópia do dataset original para evitar alterações irreversíveis: df_imputed = df.copy().",
                                    "Explore estatísticas descritivas com df.describe() para baseline de comparação pré-imputação."
                                  ],
                                  "verification": "Confirme que o índice é datetime, NaNs estão identificados e uma cópia do data foi criada sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "Biblioteca Pandas",
                                    "Jupyter Notebook ou IDE como VS Code",
                                    "Dataset de exemplo com missing values (ex: dados de temperatura diária)"
                                  ],
                                  "tips": "Escolha window size baseado no domínio: pequeno para suavização fina, maior para tendências amplas. Sempre plot antes!",
                                  "learningObjective": "Preparar dados temporais adequadamente para aplicação de rolling mean, entendendo impacto de missing values.",
                                  "commonMistakes": [
                                    "Não converter índice para datetime, causando erros em rolling()",
                                    "Escolher window muito grande/pequeno sem justificativa",
                                    "Modificar dataset original acidentalmente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a Média Móvel (Rolling Mean)",
                                  "subSteps": [
                                    "Aplique rolling() no DataFrame: rolling_mean = df[target_col].rolling(window=7, min_periods=3).mean().",
                                    "Trate bordas iniciais definindo min_periods para evitar NaNs excessivos no início da série.",
                                    "Visualize a rolling mean com plot() sobreposta aos dados originais para validar suavização.",
                                    "Salve a rolling mean em uma nova coluna: df['rolling_mean'] = rolling_mean.",
                                    "Ajuste parâmetros como center=True se necessário para séries centradas."
                                  ],
                                  "verification": "Verifique se a nova coluna 'rolling_mean' foi criada sem erros e plote para confirmar suavização de flutuações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Pandas (import pandas as pd)",
                                    "Matplotlib (import matplotlib.pyplot as plt)"
                                  ],
                                  "tips": "Use min_periods=window//2 para equilíbrio entre precisão e cobertura de dados iniciais.",
                                  "learningObjective": "Implementar rolling mean corretamente, respeitando estrutura temporal e parâmetros chave.",
                                  "commonMistakes": [
                                    "Esquecer min_periods, gerando NaNs no início",
                                    "Aplicar rolling em dados não ordenados temporalmente",
                                    "Não visualizar para checar suavização"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Imputação com Médias Móveis",
                                  "subSteps": [
                                    "Preencha NaNs na coluna original usando a rolling mean: df[target_col] = df[target_col].fillna(df['rolling_mean']).",
                                    "Remova a coluna auxiliar 'rolling_mean' se não necessária: del df['rolling_mean'].",
                                    "Reverta qualquer NaN restante com forward fill ou método híbrido se aplicável.",
                                    "Salve o dataset imputado em CSV: df.to_csv('imputed_data.csv').",
                                    "Compare estatísticas pré e pós-imputação com describe() para validar."
                                  ],
                                  "verification": "Confirme zero NaNs com df.isnull().sum() e compare plots antes/depois.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Pandas DataFrame já preparado"
                                  ],
                                  "tips": "Combine com interpolate() para casos híbridos se rolling mean deixar gaps persistentes.",
                                  "learningObjective": "Executar imputação preservando padrões locais temporais via rolling mean.",
                                  "commonMistakes": [
                                    "Fillna sem alinhamento temporal",
                                    "Não remover colunas auxiliares",
                                    "Ignorar NaNs residuais pós-imputação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Analisar a Imputação",
                                  "subSteps": [
                                    "Calcule métricas de qualidade: correlação entre original e imputado onde não faltava.",
                                    "Plote resíduos (original - imputado) para detectar vieses.",
                                    "Teste estacionariedade com ADF test (from statsmodels.tsa.stattools import adfuller).",
                                    "Documente escolhas de parâmetros em um relatório ou comentário.",
                                    "Compare com baseline (ex: mean global) via MSE em subset validado."
                                  ],
                                  "verification": "Métricas mostram baixa distorção e plotes confirmam respeito a padrões locais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Statsmodels (pip install statsmodels)",
                                    "Scikit-learn para métricas opcionais"
                                  ],
                                  "tips": "Use cross-validation temporal para robustez em datasets grandes.",
                                  "learningObjective": "Avaliar efetividade da imputação em suavizar flutuações mantendo tendências.",
                                  "commonMistakes": [
                                    "Não testar estacionariedade",
                                    "Comparar só visualmente sem métricas",
                                    "Overfit window size sem validação"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um dataset de temperaturas diárias de uma cidade (com 10% NaNs aleatórios), aplique rolling mean com window=5: temperaturas ausentes em dias 15-17 são imputadas com média dos dias 13-19, suavizando picos isolados enquanto preserva sazonalidade semanal.",
                              "finalVerifications": [
                                "Dataset final sem NaNs na coluna alvo.",
                                "Rolling mean suaviza flutuações sem distorcer tendências principais (ver plot).",
                                "Correlação >0.95 entre valores observados e imputados.",
                                "MSE da imputação < variância original dos dados.",
                                "Índice temporal intacto e ordenado.",
                                "Documentação de window size e min_periods justificada."
                              ],
                              "assessmentCriteria": [
                                "Correta preparação e indexação temporal (20%)",
                                "Implementação precisa de rolling() com parâmetros adequados (30%)",
                                "Imputação efetiva sem NaNs residuais (20%)",
                                "Validação quantitativa e visual completa (20%)",
                                "Respeito a padrões locais vs. suavização global (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Manipulação avançada de DataFrames em Python/Pandas.",
                                "Estatística: Conceitos de suavização e médias rolantes em inferência.",
                                "Finanças: Imputação em séries de preços de ações para modelagem.",
                                "Engenharia: Tratamento de sensores IoT com dados missing.",
                                "Machine Learning: Pré-processamento para forecasting em séries temporais."
                              ],
                              "realWorldApplication": "Em previsão de demanda de varejo, imputar vendas missing em feriados usando rolling mean de 7 dias para manter picos sazonais, melhorando precisão de modelos ARIMA em 15-20%."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.2.4",
                            "name": "Avaliar impacto de métodos de imputação",
                            "description": "Comparar séries originais e imputadas via gráficos ACF/PACF ou testes de estacionariedade para validar a escolha do método.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar as séries temporais original e imputada",
                                  "subSteps": [
                                    "Carregue o dataset original com valores ausentes usando pandas.read_csv ou similar.",
                                    "Identifique e isole a série temporal principal (ex: coluna de valores ao longo do tempo).",
                                    "Aplique o método de imputação escolhido (ex: interpolação linear, média móvel) para criar a série imputada.",
                                    "Crie cópias limpas das duas séries: original (com NAs marcados) e imputada (sem NAs).",
                                    "Verifique estatísticas descritivas básicas (média, variância) para ambas."
                                  ],
                                  "verification": "Confirme que as séries têm o mesmo comprimento e índice temporal alinhado via df.shape e df.index.equals().",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python com pandas, numpy; dataset de série temporal com missing values (ex: air_passengers.csv).",
                                  "tips": "Use pd.Series.interpolate(method='linear') para imputação rápida; sempre backup o original.",
                                  "learningObjective": "Dominar preparação de dados para comparação imparcial de séries temporais.",
                                  "commonMistakes": "Ignorar desalinhamento de índices temporais; imputar sem preservar a estrutura temporal."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar e analisar gráficos ACF e PACF",
                                  "subSteps": [
                                    "Plote ACF (Autocorrelation Function) para a série original usando statsmodels.tsa.stattools.acf.",
                                    "Plote PACF (Partial Autocorrelation Function) para a série original.",
                                    "Repita os plots para a série imputada no mesmo eixo para sobreposição visual.",
                                    "Identifique padrões como decaimento lento (não-estacionariedade) ou cortes abruptos em ambas.",
                                    "Anote diferenças qualitativas nos lags significativos (ex: 95% intervalo de confiança)."
                                  ],
                                  "verification": "Gráficos mostram sobreposição visual e lags semelhantes; salve figs com plt.savefig().",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python com statsmodels, matplotlib ou seaborn; Jupyter Notebook para visualização interativa.",
                                  "tips": "Use plot_acf e plot_pacf do statsmodels para automação; normalize lags até 20-30 para séries longas.",
                                  "learningObjective": "Interpretar ACF/PACF para detectar impactos da imputação na autocorrelação.",
                                  "commonMistakes": "Não padronizar lags ou escalas nos gráficos; ignorar barras fora do intervalo de confiança."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar testes de estacionariedade",
                                  "subSteps": [
                                    "Execute teste ADF (Augmented Dickey-Fuller) na série original com statsmodels.tsa.stattools.adfuller.",
                                    "Execute teste KPSS na série original para confirmar não-estacionariedade complementar.",
                                    "Repita ADF e KPSS na série imputada.",
                                    "Registre p-values, estatísticas e conclusões (ex: p<0.05 rejeita não-estacionariedade no ADF).",
                                    "Compare resultados lado a lado em uma tabela pandas."
                                  ],
                                  "verification": "Tabela com p-values mostra consistência ou mudança significativa pós-imputação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "statsmodels.tsa.stattools; dataset preparado do Step 1.",
                                  "tips": "Use maxlag='auto' no ADF para lags ótimos; interprete ADF e KPSS juntos para robustez.",
                                  "learningObjective": "Aplicar e interpretar testes estatísticos para validar preservação de propriedades temporais.",
                                  "commonMistakes": "Usar apenas um teste; não diferenciar hipóteses nula (ADF: unidade raiz vs KPSS: estacionariedade)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar resultados e validar escolha do método",
                                  "subSteps": [
                                    "Sobreponha métricas: similaridade em ACF/PACF decays e p-values de testes.",
                                    "Calcule métricas quantitativas como MSE entre ACFs originais e imputadas.",
                                    "Avalie se a imputação preservou estacionariedade ou autocorrelação (ex: sem introduzir artefatos).",
                                    "Conclua se o método é adequado ou sugira alternativas (ex: se interpolação distorce lags, use LOESS).",
                                    "Documente relatório com gráficos e tabela de comparação."
                                  ],
                                  "verification": "Relatório escrito justifica validação ou rejeição do método com evidências.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Resultados dos steps anteriores; pandas para tabelas, matplotlib para resumo.",
                                  "tips": "Use scipy.stats para correlações adicionais; priorize preservação de estrutura temporal sobre completude.",
                                  "learningObjective": "Sintetizar análises para decisões baseadas em evidências em séries temporais.",
                                  "commonMistakes": "Concluir sem quantificar diferenças; ignorar contexto domain-specific da série."
                                }
                              ],
                              "practicalExample": "Em um dataset de vendas mensais de varejo com 10% de valores ausentes (ex: dados de 2010-2023), compare imputação por média móvel (janela=3) vs interpolação linear: plote ACF/PACF mostrando que linear preserva melhor o ciclo sazonal (lags 12 significativos), confirmado por ADF p-value de 0.03 pós-linear vs 0.45 pós-média.",
                              "finalVerifications": [
                                "ACF/PACF das séries mostram sobreposição >80% nos lags principais.",
                                "Testes de estacionariedade (ADF/KPSS) têm p-values consistentes pré/pós-imputação.",
                                "MSE entre ACFs originais e imputadas < 0.05.",
                                "Nenhuma introdução de autocorrelações espúrias nos primeiros 20 lags.",
                                "Relatório documenta escolha do método com evidências gráficas e numéricas.",
                                "Série imputada mantém variância e média dentro de 5% da original."
                              ],
                              "assessmentCriteria": [
                                "Precisão na preparação e alinhamento das séries (20%)",
                                "Qualidade e interpretação correta de ACF/PACF (25%)",
                                "Aplicação e análise robusta de testes de estacionariedade (25%)",
                                "Comparação quantitativa e qualitativa clara (20%)",
                                "Conclusão validada com evidências e sugestões práticas (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Estatística Inferencial: Hipóteses nula/alternativa em testes ADF/KPSS.",
                                "Programação em Python: Manipulação de dados com pandas/statsmodels.",
                                "Machine Learning: Pré-processamento para modelos de forecasting como ARIMA.",
                                "Visualização de Dados: Interpretação de gráficos temporais com matplotlib."
                              ],
                              "realWorldApplication": "Em finanças, avaliar imputação em séries de preços de ações para evitar distorções em modelos de previsão de volatilidade; em meteorologia, validar métodos em dados de temperatura com sensores falhos para relatórios climáticos precisos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.4.3",
                        "name": "Agregação de Dados Temporais",
                        "description": "Redução ou expansão da granularidade temporal por meio de resampling e funções de agregação, adaptando os dados à frequência desejada para análise.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.3.1",
                            "name": "Executar downsampling com agregações",
                            "description": "Converter séries de alta frequência (ex: horária para diária) usando funções como mean, sum ou median via resample no pandas, agregando por períodos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e carregar dados de série temporal",
                                  "subSteps": [
                                    "Instale e importe as bibliotecas necessárias: pandas e numpy.",
                                    "Carregue um dataset de exemplo com dados de alta frequência, como medições horárias de temperatura em um DataFrame.",
                                    "Converta a coluna de data para datetime e defina-a como índice do DataFrame.",
                                    "Inspecione os dados com info(), head() e plot() para confirmar a frequência horária.",
                                    "Trate valores ausentes com fillna() ou dropna() se necessário."
                                  ],
                                  "verification": "Execute df.index.freq e df.head() para confirmar índice datetime horário sem erros.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Python com pandas e numpy instalados; dataset CSV de série temporal horária (ex: temperaturas).",
                                  "tips": "Use pd.to_datetime() com infer_datetime_format=True para eficiência em grandes datasets.",
                                  "learningObjective": "Configurar corretamente uma série temporal pandas para downsampling.",
                                  "commonMistakes": "Esquecer de setar o índice temporal, levando a erros no resample; ignorar NaNs que distorcem agregações."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar e executar downsampling básico com resample",
                                  "subSteps": [
                                    "Use df.resample('D') para agregar de horária para diária.",
                                    "Aplique uma agregação simples como .mean() para calcular médias diárias.",
                                    "Armazene o resultado em uma nova variável, como daily_data = df.resample('D').mean().",
                                    "Visualize o resultado com daily_data.plot() e compare com o original.",
                                    "Teste diferentes regras de frequência, como 'H' para horária ou 'M' para mensal."
                                  ],
                                  "verification": "Confira se o novo DataFrame tem frequência diária com daily_data.index.freq e len(daily_data) é cerca de 1/24 do original.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Jupyter Notebook ou script Python; dados preparados do Step 1.",
                                  "tips": "Especifique on='coluna_data' no resample se índice não for datetime.",
                                  "learningObjective": "Dominar a sintaxe básica de resample para downsampling com agregações padrão.",
                                  "commonMistakes": "Usar frequência errada (ex: 'D' em dados mensais); aplicar mean() em colunas não numéricas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar agregações avançadas (sum, median, etc.) e personalizar",
                                  "subSteps": [
                                    "Crie um dicionário de agregações: agg_dict = {'temperatura': 'mean', 'vendas': 'sum'}.",
                                    "Execute resample com .agg(agg_dict) para múltiplas colunas.",
                                    "Teste median() para dados com outliers e compare com mean().",
                                    "Use .ohlc() para Open-High-Low-Close em dados financeiros.",
                                    "Salve o resultado em CSV com to_csv() para persistência."
                                  ],
                                  "verification": "Calcule estatísticas descritivas antes/depois e confirme que sum() preserva totais diários.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Dados com múltiplas colunas numéricas; matplotlib para plots comparativos.",
                                  "tips": "Para grandes datasets, use kind='period' no resample para eficiência.",
                                  "learningObjective": "Selecionar e aplicar agregações apropriadas por tipo de dado e contexto.",
                                  "commonMistakes": "Aplicar sum() em proporções normalizadas (deve usar mean()); não lidar com grupos vazios."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar resultados e integrar em pipeline de análise",
                                  "subSteps": [
                                    "Compare estatísticas originais vs. agregadas com describe().",
                                    "Crie plots lado a lado para visualizar perda de granularidade.",
                                    "Integre em uma função reutilizável: def downsample_data(df, freq, agg_func).",
                                    "Teste com dataset real (ex: ações horárias para diárias).",
                                    "Documente escolhas de agregação no notebook."
                                  ],
                                  "verification": "Execute testes unitários simples, como assert np.allclose(original.sum(), downsampled.sum().resample('D').sum()).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Bibliotecas de teste como pytest; datasets variados.",
                                  "tips": "Sempre plote resíduos ou diferenças para detectar anomalias.",
                                  "learningObjective": "Garantir qualidade e reprodutibilidade de transformações temporais.",
                                  "commonMistakes": "Ignorar fusos horários (use tz_localize()); superestimar precisão sem validação."
                                }
                              ],
                              "practicalExample": "Carregue dados horários de vendas de uma loja (colunas: data_hora, vendas, clientes). Use df.resample('D').agg({'vendas': 'sum', 'clientes': 'mean'}) para obter vendas totais diárias e média de clientes, simulando relatório gerencial.",
                              "finalVerifications": [
                                "Índice do DataFrame resultante tem frequência diária confirmada.",
                                "Agregações preservam totais esperados (ex: soma diária == soma horária por dia).",
                                "Não há NaNs introduzidos indevidamente nos resultados.",
                                "Plots comparativos mostram coerência visual entre original e downsampled.",
                                "Função customizada processa novos dados sem erros.",
                                "Estatísticas descritivas (mean, std) são consistentes com expectativas."
                              ],
                              "assessmentCriteria": [
                                "Correta configuração de resample com frequência e agregações adequadas (peso: 30%).",
                                "Escolha contextual de funções (mean/sum/median) baseada no tipo de dado (peso: 25%).",
                                "Validação completa com comparações numéricas e visuais (peso: 20%).",
                                "Código limpo, comentado e reutilizável em função (peso: 15%).",
                                "Tratamento de edge cases como NaNs e períodos vazios (peso: 10%)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística Descritiva: Compreensão de medidas de tendência central (mean, median).",
                                "Programação Python: Manipulação avançada de DataFrames e funções lambda.",
                                "Visualização de Dados: Uso de matplotlib/seaborn para validação gráfica.",
                                "Análise Financeira: Aplicação em dados OHLC de mercado.",
                                "Gestão de Projetos: Integração em pipelines ETL de dados."
                              ],
                              "realWorldApplication": "Em meteorologia, agregar precipitação horária para totais diários em previsões; em finanças, converter ticks de alta frequência para candles diários para backtesting de estratégias de trading."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.3.2",
                            "name": "Realizar upsampling com interpolação",
                            "description": "Aumentar frequência (ex: diária para horária) preenchendo gaps com métodos como linear ou spline interpolation para manter continuidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a Série Temporal Original",
                                  "subSteps": [
                                    "Carregue o dataset usando pandas.read_csv() com parse_dates para índice temporal.",
                                    "Inspecione a frequência atual com df.index.freq e identifique gaps ou irregularidades.",
                                    "Converta o índice para DatetimeIndex se necessário com pd.to_datetime().",
                                    "Visualize a série com df.plot() para entender tendências e valores ausentes."
                                  ],
                                  "verification": "A série está carregada com índice DatetimeIndex válido, frequência identificada e plotada corretamente sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python com bibliotecas pandas e matplotlib instaladas",
                                    "Dataset de exemplo em CSV (ex: vendas_diarias.csv com colunas data e valor)"
                                  ],
                                  "tips": [
                                    "Use infer_datetime_format=True para aceleração no parse_dates.",
                                    "Salve uma cópia do DataFrame original para comparação posterior."
                                  ],
                                  "learningObjective": "Compreender a estrutura e características da série temporal original antes do upsampling.",
                                  "commonMistakes": [
                                    "Esquecer de converter strings para datetime, causando erros de indexação.",
                                    "Ignorar valores ausentes iniciais que propagam erros."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o Novo Índice Temporal para Upsampling",
                                  "subSteps": [
                                    "Determine a nova frequência desejada (ex: 'H' para horária a partir de diária).",
                                    "Crie o novo índice com pd.date_range(start=df.index.min(), end=df.index.max(), freq='H').",
                                    "Reindexe a série original: df_upsampled = df.reindex(new_index) para introduzir NaNs nos novos pontos."
                                  ],
                                  "verification": "O DataFrame reindexado tem o comprimento correto e contém NaNs nos intervalos interpolados.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Biblioteca pandas",
                                    "Código do Step 1 (série original preparada)"
                                  ],
                                  "tips": [
                                    "Garanta que start e end cubram exatamente o período original para evitar extrapolação.",
                                    "Use freq='H' para horária, 'T' para minutely, etc."
                                  ],
                                  "learningObjective": "Criar um índice temporal de maior resolução alinhado à série original.",
                                  "commonMistakes": [
                                    "Definir freq incorreta, resultando em desalinhamento temporal.",
                                    "Não alinhar start/end, criando índices vazios ou excessivos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Métodos de Interpolação",
                                  "subSteps": [
                                    "Escolha o método: 'linear' para simples, 'spline' (order=3) para curvas suaves via method='spline'.",
                                    "Aplique interpolação: df_upsampled.interpolate(method='linear', limit_direction='both').",
                                    "Para spline avançado: use scipy.interpolate.interp1d com kind='cubic' e aplique aos valores.",
                                    "Preencha eventuais NaNs restantes com ffill/bfill se apropriado."
                                  ],
                                  "verification": "O DataFrame interpolado não possui NaNs e os valores preenchem logicamente os gaps.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Pandas e scipy instalados",
                                    "DataFrame reindexado do Step 2"
                                  ],
                                  "tips": [
                                    "Teste múltiplos métodos e compare plots para escolher o melhor.",
                                    "Use limit_direction='both' para interpolação bidirecional em bordas."
                                  ],
                                  "learningObjective": "Implementar interpolação para preencher gaps mantendo continuidade e realismo.",
                                  "commonMistakes": [
                                    "Aplicar interpolação sem reindexar primeiro, perdendo pontos novos.",
                                    "Escolher spline de alta ordem sem dados suficientes, causando oscilações (Runge phenomenon)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Visualizar o Resultado Upsampled",
                                  "subSteps": [
                                    "Plote séries original e upsampled sobrepostas com df_original.plot() e df_upsampled.plot().",
                                    "Verifique estatísticas: compare mean, std e trends com df.describe().",
                                    "Calcule erro de reconstrução em pontos originais: RMSE entre original e upsampled nos pontos conhecidos.",
                                    "Salve o resultado como novo CSV para uso futuro."
                                  ],
                                  "verification": "Plots mostram continuidade suave, estatísticas preservadas e RMSE baixo (<5% da std original).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Matplotlib e pandas",
                                    "DataFrames do Step 3"
                                  ],
                                  "tips": [
                                    "Use subplots para comparação lado a lado.",
                                    "Exporte plots como PNG para relatórios."
                                  ],
                                  "learningObjective": "Avaliar a qualidade do upsampling e sua fidelidade aos dados originais.",
                                  "commonMistakes": [
                                    "Não verificar bordas, onde extrapolação pode distorcer.",
                                    "Ignorar visualização, perdendo detecção de artefatos."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um dataset de vendas diárias de uma loja (ex: 2023-01-01 a 2023-01-31), realize upsampling para horária usando interpolação linear. Isso simula demanda intradiária para otimizar escalas de funcionários, preenchendo 24 valores por dia original com valores proporcionais.",
                              "finalVerifications": [
                                "A nova série possui exatamente a frequência horária desejada (ex: 744 pontos para 31 dias).",
                                "Ausência total de valores NaN após interpolação.",
                                "Tendências e sazonalidades originais preservadas visualmente.",
                                "Valores interpolados respeitam monotonicidade onde aplicável (ex: sem picos artificiais).",
                                "Estatísticas descritivas (média, desvio padrão) variam <10% da original.",
                                "RMSE nos pontos originais <5% do range dos dados.",
                                "Plot comparativo confirma continuidade suave."
                              ],
                              "assessmentCriteria": [
                                "Preparação correta da série original e detecção de frequência (20%).",
                                "Definição precisa do novo índice sem desalinhamentos (20%).",
                                "Seleção e aplicação adequada do método de interpolação (30%).",
                                "Validação robusta com métricas e visualizações (20%).",
                                "Justificativa da escolha do método baseada no contexto dos dados (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação em Python: Manipulação avançada de DataFrames com pandas.",
                                "Estatística Descritiva: Análise de métricas como RMSE e preservação de distribuições.",
                                "Visualização de Dados: Uso de matplotlib para validação gráfica.",
                                "Machine Learning: Pré-processamento de features temporais para modelos de previsão.",
                                "Ciências Computacionais: Algoritmos de interpolação numérica (linear, spline)."
                              ],
                              "realWorldApplication": "Na previsão de demanda em e-commerce, upsampling dados diários de tráfego para horários permite modelar picos de pico de almoço/janta, otimizando alocação de servidores. Em meteorologia, preenche gaps de estações com baixa frequência para simulações de alta resolução em apps de tempo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.3.3",
                            "name": "Aplicar janelas rolantes para agregação",
                            "description": "Calcular estatísticas rolantes (rolling mean, std) em janelas fixas ou expandidas para suavizar séries e destacar tendências.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e os dados para análise de séries temporais",
                                  "subSteps": [
                                    "Instale e importe as bibliotecas necessárias: pandas, numpy e matplotlib.",
                                    "Carregue um dataset de série temporal (ex: preços de ações via yfinance ou CSV).",
                                    "Converta o índice para datetime e defina como índice do DataFrame.",
                                    "Inspecione os dados com head(), info() e plot() para verificar integridade.",
                                    "Trate valores ausentes com fillna() ou dropna() se necessário."
                                  ],
                                  "verification": "Execute df.head() e df.plot() para confirmar que o índice é datetime e os dados estão ordenados cronologicamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Jupyter Notebook, Python 3+, bibliotecas pandas, numpy, matplotlib, yfinance (opcional para dados reais)",
                                  "tips": "Sempre use pd.to_datetime() para garantir formato correto do índice temporal.",
                                  "learningObjective": "Configurar um ambiente pronto para manipulações temporais em pandas.",
                                  "commonMistakes": "Esquecer de definir o índice como datetime, causando erros em funções rolling."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar janelas rolantes fixas para calcular média móvel",
                                  "subSteps": [
                                    "Selecione a coluna alvo (ex: 'Close' para preços de ações).",
                                    "Crie uma janela rolante fixa: df['rolling_mean'] = df['Close'].rolling(window=7).mean().",
                                    "Preencha valores NaN iniciais com ffill() ou um valor padrão.",
                                    "Compare original e rolling com df[['Close', 'rolling_mean']].plot().",
                                    "Teste diferentes tamanhos de janela (ex: 5, 14, 30 dias)."
                                  ],
                                  "verification": "Verifique se os primeiros 6 valores (para window=7) são NaN ou preenchidos, e o gráfico mostra suavização das flutuações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Mesmo do step 1; dataset de séries temporais com pelo menos 100 observações",
                                  "tips": "Escolha window baseado no ciclo esperado (ex: 7 para semanal).",
                                  "learningObjective": "Implementar e interpretar médias rolantes fixas para suavizar ruído em séries.",
                                  "commonMistakes": "Usar window muito pequeno, que não suaviza o suficiente, ou muito grande, que atrasa a resposta."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular estatísticas rolantes adicionais e janelas expandidas",
                                  "subSteps": [
                                    "Adicione desvio padrão: df['rolling_std'] = df['Close'].rolling(window=7).std().",
                                    "Inclua min/max: df['rolling_min'] = df['Close'].rolling(window=7).min(); df['rolling_max'] = df['Close'].rolling(window=7).max().",
                                    "Aplique janela expandindo: df['expanding_mean'] = df['Close'].expanding().mean().",
                                    "Combine em um DataFrame e plote múltiplas estatísticas.",
                                    "Salve o resultado em um novo CSV para persistência."
                                  ],
                                  "verification": "Confira df.describe() nas colunas rolling para valores coerentes (std > 0 após janela cheia).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Mesmo do step 1; funções agg() para múltiplas stats se avançado",
                                  "tips": "Use rolling().agg(['mean', 'std']) para eficiência em múltiplas estatísticas.",
                                  "learningObjective": "Expandir agregações rolantes para múltiplas métricas e janelas cumulativas.",
                                  "commonMistakes": "Confundir expanding() com rolling(), gerando estatísticas globais em vez de locais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Visualizar, interpretar e validar os resultados",
                                  "subSteps": [
                                    "Crie subplots com original, rolling_mean, rolling_std e expanding_mean.",
                                    "Identifique tendências: onde mean cruza o preço ou std aumenta (volatilidade).",
                                    "Calcule correlação entre original e rolling para validar suavização.",
                                    "Teste com outro dataset para generalizar.",
                                    "Documente insights em markdown no notebook."
                                  ],
                                  "verification": "Gráficos mostram tendências claras; correlação > 0.9 entre smoothed e original.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Matplotlib/Seaborn para plots avançados",
                                  "tips": "Use twinx() para plotar preço e std no mesmo eixo com escalas diferentes.",
                                  "learningObjective": "Analisar visual e quantitativamente o impacto das janelas rolantes.",
                                  "commonMistakes": "Ignorar NaNs nos gráficos, distorcendo interpretação inicial."
                                }
                              ],
                              "practicalExample": "Usando dados diários de preços de ações da PETR4 (Petrobras) de 2023, aplique rolling(7).mean() no 'Close' para suavizar variações semanais, revelando uma tendência de alta apesar de ruídos diários, e rolling_std para detectar períodos de alta volatilidade durante notícias econômicas.",
                              "finalVerifications": [
                                "Código executa sem erros e produz DataFrame com colunas rolling corretas.",
                                "Gráficos exibem suavização visível e padrões de volatilidade.",
                                "Valores iniciais de rolling são NaN ou adequadamente tratados.",
                                "Janela expandindo acumula corretamente desde o início.",
                                "Correlação entre série original e suavizada é alta (>0.85).",
                                "Resultados salvos e reproduzíveis com seed ou dados fixos."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos rolantes (valores coincidem com verificação manual).",
                                "Escolha adequada de window baseada no contexto temporal.",
                                "Interpretação correta de tendências e volatilidade.",
                                "Código limpo, comentado e modular.",
                                "Visualizações claras e informativas.",
                                "Generalização para novos datasets."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estatística descritiva e funções de agregação.",
                                "Economia/Finanças: Análise técnica de mercado e indicadores.",
                                "Física: Suavização de sinais em medições experimentais.",
                                "Negócios: Previsão de vendas e detecção de sazonalidade."
                              ],
                              "realWorldApplication": "Em finanças, suaviza preços de ativos para trading; em meteorologia, médias rolantes de temperatura destacam mudanças climáticas; em e-commerce, agregações em vendas diárias preveem demandas e otimizam estoque."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.4.4",
                        "name": "Diferenciação de Séries Temporais",
                        "description": "Transformações diferenciais para remover tendências e induzir estacionariedade, preparando a série para modelagem como ARIMA ou outros métodos.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.4.1",
                            "name": "Calcular diferenças de primeira ordem",
                            "description": "Subtrair valores consecutivos (diff(1)) para eliminar tendências lineares, verificando estacionariedade via teste ADF.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a Série Temporal para Diferenciação",
                                  "subSteps": [
                                    "Carregue o conjunto de dados de série temporal em um DataFrame do pandas.",
                                    "Defina o índice temporal adequado usando pd.to_datetime() se necessário.",
                                    "Visualize a série original com plot() para identificar tendências lineares.",
                                    "Verifique valores ausentes com isna().sum() e trate-os com fillna() ou dropna().",
                                    "Confirme que a série está ordenada cronologicamente com sort_index()."
                                  ],
                                  "verification": "Série carregada, indexada corretamente e plotada sem erros, sem valores ausentes.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Python com pandas, matplotlib; dataset de série temporal (ex: dados de PIB mensal).",
                                  "tips": "Sempre plotar primeiro para visual inspeção de tendências.",
                                  "learningObjective": "Preparar dados limpos e indexados para transformações temporais.",
                                  "commonMistakes": "Ignorar índice temporal, levando a cálculos incorretos; não tratar NaNs."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Diferenças de Primeira Ordem (diff(1))",
                                  "subSteps": [
                                    "Aplique a função diff(1) no DataFrame ou Series: serie_diferenciada = serie_original.diff(1).",
                                    "Remova o primeiro valor NaN gerado pela diferenciação com dropna().",
                                    "Reindexe se necessário para manter alinhamento temporal.",
                                    "Visualize a série diferenciada com plot() para observar remoção de tendência linear.",
                                    "Salve a série diferenciada em uma nova coluna ou variável."
                                  ],
                                  "verification": "Série diferenciada calculada, sem NaNs iniciais, e plot mostra eliminação de tendência linear.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Python com pandas; série temporal preparada do Step 1.",
                                  "tips": "Use diff(periods=1) explicitamente para clareza.",
                                  "learningObjective": "Executar diferenciação de primeira ordem para remover tendências lineares.",
                                  "commonMistakes": "Esquecer dropna(), resultando em NaNs propagados; confundir com diff() sem parâmetro."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar Estacionariedade com Teste ADF",
                                  "subSteps": [
                                    "Instale/importe statsmodels: from statsmodels.tsa.stattools import adfuller.",
                                    "Execute o teste: resultado = adfuller(serie_diferenciada).",
                                    "Extraia estatísticas chave: p-value, estatística do teste e valores críticos.",
                                    "Compare p-value com 0.05: se <0.05, rejeitar hipótese nula (não estacionária).",
                                    "Registre os resultados em um dicionário ou print para análise."
                                  ],
                                  "verification": "Teste ADF executado com p-value reportado e interpretação inicial de estacionariedade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python com statsmodels.tsa; série diferenciada do Step 2.",
                                  "tips": "Use o p-value como critério principal; visualize ACF/PACF para confirmação.",
                                  "learningObjective": "Aplicar e interpretar teste ADF para validar estacionariedade pós-diferenciação.",
                                  "commonMistakes": "Não incluir constantes ou tendências no teste ADF; misinterpretar hipótese nula."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Resultados e Validar Transformação",
                                  "subSteps": [
                                    "Analise se p-value <0.05 confirma estacionariedade na série diferenciada.",
                                    "Compare estatísticas ACF da original vs. diferenciada para decay rápido.",
                                    "Se não estacionária, considere diferenciação adicional ou outras transformações.",
                                    "Documente conclusões em um relatório ou notebook markdown.",
                                    "Teste robustez com subamostras da série."
                                  ],
                                  "verification": "Relatório com interpretação clara: estacionariedade confirmada ou não, com evidências.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Python com pandas, statsmodels; resultados dos steps anteriores.",
                                  "tips": "Combine ADF com gráficos QQ ou histogramas para resíduos.",
                                  "learningObjective": "Interpretar transformações e decidir próximos passos em análise de séries.",
                                  "commonMistakes": "Aceitar ADF sem visualizações complementares; ignorar autocorrelação residual."
                                }
                              ],
                              "practicalExample": "Usando dados mensais de vendas de uma loja (ex: dataset 'AirPassengers' do R convertido para pandas), aplique diff(1) para remover tendência crescente de passageiros aéreos, execute ADF na série diferenciada (p-value ~0.02, confirmando estacionariedade), permitindo modelagem ARIMA posterior.",
                              "finalVerifications": [
                                "Série diferenciada sem NaNs e com tendência linear removida visualmente.",
                                "Teste ADF retorna p-value <0.05 na série diferenciada.",
                                "Gráficos ACF mostram decay rápido pós-diferenciação.",
                                "Documentação inclui código, plots e interpretação.",
                                "Transformação reproduzível em novo dataset similar.",
                                "Nenhuma autocorrelação significativa nos resíduos."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo diff(1): valores corretos em pelo menos 95% dos pontos.",
                                "Interpretação correta de ADF: hipótese nula rejeitada adequadamente.",
                                "Qualidade dos visualizações: claros, rotulados e informativos.",
                                "Tratamento completo de dados: sem erros de NaN ou indexação.",
                                "Documentação: passos lógicos e conclusões justificadas.",
                                "Eficiência: tempo dentro do estimado e código limpo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo diferencial discreto e testes de hipóteses estatísticos.",
                                "Programação: Manipulação de dados com pandas e statsmodels em Python.",
                                "Economia: Análise de séries temporais em previsão de PIB ou inflação.",
                                "Finanças: Detrending em modelagem de retornos de ações."
                              ],
                              "realWorldApplication": "Em finanças, diferenciação de primeira ordem em preços de ações remove tendências lineares para modelar retornos estacionários, essencial para previsões de risco em portfólios de investimento ou detecção de anomalias em séries de transações bancárias."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.4.2",
                            "name": "Aplicar diferenças sazonais",
                            "description": "Realizar diferenças em lags sazonais (ex: diff(12) para mensal) para remover padrões periódicos e estabilizar variância.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de diferenças sazonais",
                                  "subSteps": [
                                    "Estudar o que é sazonalidade em séries temporais: padrões repetitivos em intervalos fixos (ex: mensal com ciclo anual).",
                                    "Explicar a diferença entre diferenciação regular (diff(1)) e sazonal (diff(lag)), onde lag é o período sazonal.",
                                    "Analisar por que diferenças sazonais removem padrões periódicos e estabilizam variância para estacionariedade.",
                                    "Visualizar exemplos gráficos de séries com e sem sazonalidade."
                                  ],
                                  "verification": "Resumir em 3 frases o propósito das diferenças sazonais e dar um exemplo de lag para dados mensais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Gráficos de séries temporais sazonais (ex: AirPassengers dataset)",
                                    "Documentação de séries temporais (R ou Python)"
                                  ],
                                  "tips": [
                                    "Sempre comece visualizando a série para identificar ciclos óbvios.",
                                    "Lembre-se: lag = frequência de dados (12 para mensal, 4 para trimestral)."
                                  ],
                                  "learningObjective": "Dominar os fundamentos teóricos das diferenças sazonais e sua importância para análise de séries temporais.",
                                  "commonMistakes": [
                                    "Confundir lag sazonal com diferenciação de primeira ordem.",
                                    "Ignorar que sazonalidade pode se sobrepor a tendências."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar o período sazonal da série",
                                  "subSteps": [
                                    "Plotar a série temporal original e decompor em tendência, sazonalidade e resíduo (usar STL ou seasonal_decompose).",
                                    "Calcular a autocorrelação (ACF) para detectar picos em lags múltiplos do período sazonal.",
                                    "Usar testes como periodograma ou inspeção visual para confirmar o lag (ex: 12 para mensal).",
                                    "Documentar o período identificado com evidências gráficas.",
                                    "Testar lags alternativos se houver ambiguidade."
                                  ],
                                  "verification": "Produzir plot ACF mostrando picos claros no lag correto e justificar a escolha.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Biblioteca Python: pandas, statsmodels; ou R: forecast",
                                    "Dataset de exemplo com sazonalidade conhecida (ex: vendas mensais)"
                                  ],
                                  "tips": [
                                    "Procure picos significativos na ACF em lags como 12, 24 para mensais.",
                                    "Combine plot da série com ACF para confirmação dupla."
                                  ],
                                  "learningObjective": "Desenvolver habilidade para diagnosticar sazonalidade e determinar o lag apropriado.",
                                  "commonMistakes": [
                                    "Escolher lag errado baseado só em suposição (ex: 7 para diário em vez de 365).",
                                    "Não inspecionar múltiplos lags."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a diferenciação sazonal",
                                  "subSteps": [
                                    "Carregar a série em formato temporal (pandas Series com index datetime ou ts em R).",
                                    "Executar a transformação: em Python, df.diff(12); em R, diff(ts_data, lag=12).",
                                    "Tratar valores NA iniciais gerados pela diferenciação (preencher ou remover).",
                                    "Plotar a série diferenciada para inspeção inicial.",
                                    "Salvar a nova série para análises subsequentes."
                                  ],
                                  "verification": "Executar código e mostrar plot da série diferenciada sem os padrões sazonais originais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ambiente Python/R com pandas/statsmodels ou tsibble",
                                    "Dataset real (ex: série de temperaturas mensais)"
                                  ],
                                  "tips": [
                                    "Use dropna() após diff() para limpar NAs.",
                                    "Teste em subset pequeno antes do dataset completo."
                                  ],
                                  "learningObjective": "Executar com precisão a transformação sazonal em ferramentas computacionais.",
                                  "commonMistakes": [
                                    "Aplicar diff(1) em vez de diff(lag).",
                                    "Esquecer de converter para objeto temporal."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e interpretar os resultados",
                                  "subSteps": [
                                    "Comparar plots: original vs sazonalmente diferenciada (tendência e variância estabilizadas?).",
                                    "Reanalisar ACF/PACF da série diferenciada: ausência de picos sazonais.",
                                    "Aplicar teste de estacionariedade (KPSS ou ADF) para confirmar melhorias.",
                                    "Interpretar impactos: como isso afeta modelagem futura (ARIMA).",
                                    "Documentar conclusões e sugestões para iterações (ex: diferenças duplas)."
                                  ],
                                  "verification": "Gerar relatório com plots, testes e conclusão sobre remoção da sazonalidade.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Funções de teste: adfuller() em Python ou ur.df() em R",
                                    "Notebooks Jupyter ou RMarkdown"
                                  ],
                                  "tips": [
                                    "Se sazonalidade persistir, considere diferenciação sazonal dupla.",
                                    "Sempre teste estacionariedade pós-transformação."
                                  ],
                                  "learningObjective": "Avaliar efetividade da transformação e interpretar implicações para análise avançada.",
                                  "commonMistakes": [
                                    "Não verificar ACF pós-diferença.",
                                    "Ignorar NAs que distorcem testes."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um dataset de vendas mensais de varejo (ex: Walmart sales), identifique ciclo anual (lag=12), aplique vendas.diff(12), plote ACF antes/depois mostrando remoção de picos em lag 12, e confirme estacionariedade com ADF test (p-value < 0.05).",
                              "finalVerifications": [
                                "Série diferenciada não exibe padrões sazonais visíveis no plot.",
                                "ACF da série diferenciada sem picos significativos nos lags sazonais.",
                                "Teste ADF ou KPSS indica estacionariedade (p-value apropriado).",
                                "Variância estabilizada comparada à original.",
                                "Código reproduzível sem erros em dataset de teste.",
                                "Relatório interpreta corretamente os efeitos da transformação."
                              ],
                              "assessmentCriteria": [
                                "Identificação precisa do lag sazonal com evidências (ACF/plot).",
                                "Código correto e eficiente para diff(lag).",
                                "Verificações pós-transformação completas (plots, testes).",
                                "Interpretação teórica e prática adequada.",
                                "Tratamento correto de NAs e artefatos.",
                                "Documentação clara e reproduzível."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações em sequências e álgebra linear para decomposição.",
                                "Programação: Manipulação de dados temporais em Python/R.",
                                "Economia: Previsão de demanda sazonal em negócios.",
                                "Física: Modelagem de ciclos periódicos em fenômenos naturais."
                              ],
                              "realWorldApplication": "Em finanças, estabilizar séries de retornos de ações com sazonalidade para modelos ARIMA precisos; em meteorologia, remover ciclos anuais de temperaturas para previsões de longo prazo; em supply chain, forecast de vendas sazonais para otimização de estoque."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.4.3",
                            "name": "Usar log-diferenças para séries exponenciais",
                            "description": "Aplicar logaritmo natural seguido de diferenças para séries com crescimento multiplicativo, como em finanças, analisando retornos logarítmicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar séries temporais com crescimento exponencial",
                                  "subSteps": [
                                    "Examine o gráfico da série temporal para detectar padrões de crescimento multiplicativo (curva exponencial).",
                                    "Calcule as razões sucessivas (y_{t}/y_{t-1}) para confirmar se são aproximadamente constantes.",
                                    "Verifique estatísticas descritivas como média geométrica das razões e teste de estacionariedade inicial (ex: ADF test).",
                                    "Documente evidências de não-estacionariedade multiplicativa.",
                                    "Decida que log-diferenças são apropriadas se razões forem estáveis."
                                  ],
                                  "verification": "Gráfico e razões sucessivas mostram crescimento exponencial consistente; teste ADF rejeita estacionariedade na série original.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Série temporal de dados (ex: Excel ou Python pandas DataFrame)",
                                    "Software de plotagem (Matplotlib ou Excel)"
                                  ],
                                  "tips": [
                                    "Comece sempre com visualização; números mentais enganam em séries longas.",
                                    "Use log-escala no gráfico para confirmar linearidade pós-log."
                                  ],
                                  "learningObjective": "Reconhecer quando log-diferenças estabilizam variância em séries multiplicativas.",
                                  "commonMistakes": [
                                    "Confundir com crescimento linear (use razões, não diferenças simples).",
                                    "Ignorar outliers que distorcem razões."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar logaritmo natural à série temporal",
                                  "subSteps": [
                                    "Carregue a série y_t em um ambiente computacional.",
                                    "Compute log(y_t) para cada observação, usando np.log() em Python ou LOG() no Excel.",
                                    "Trate valores zero ou negativos substituindo por NA ou adicionando pequena constante (ex: 1e-10).",
                                    "Plote a série logarítmica e compare com a original.",
                                    "Salve a nova série como log_y."
                                  ],
                                  "verification": "Série log_y é computada sem erros; gráfico mostra linearidade crescente se exponencial.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python (pandas, numpy) ou Excel",
                                    "Dados de exemplo: preços de ações diários"
                                  ],
                                  "tips": [
                                    "Use log natural (ln) para consistência com finanças; evite log10 a menos que especificado.",
                                    "Verifique domínio: y_t > 0 para todos t."
                                  ],
                                  "learningObjective": "Transformar multiplicatividade em aditividade via logaritmo.",
                                  "commonMistakes": [
                                    "Aplicar log em zeros (causa -inf).",
                                    "Esquecer de plotar para validação visual."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular diferenças finitas na série logarítmica",
                                  "subSteps": [
                                    "Compute Δlog_y_t = log_y_t - log_y_{t-1} para t=2 até n.",
                                    "Interprete como retornos logarítmicos: ≈ (y_t - y_{t-1})/y_{t-1}.",
                                    "Plote a série de diferenças e compute estatísticas (média, variância).",
                                    "Aplique teste de estacionariedade (ADF) na série diferenciada.",
                                    "Ajuste lag se necessário (primeira diferença geralmente basta)."
                                  ],
                                  "verification": "Série Δlog_y é estacionária (p-value ADF < 0.05); média ≈ log(1 + retorno médio).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python (statsmodels para ADF) ou R",
                                    "Série log_y salva"
                                  ],
                                  "tips": [
                                    "Diferenças primeiro-order bastam para exponenciais puras; monitore autocorrelação.",
                                    "Média de Δlog_y é o crescimento contínuo anualizado."
                                  ],
                                  "learningObjective": "Obter retornos logarítmicos estacionários para modelagem.",
                                  "commonMistakes": [
                                    "Usar diferenças simples na original (não estabiliza variância).",
                                    "Incluir t=1 sem diferença (série encurta)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e validar a transformação log-diferenças",
                                  "subSteps": [
                                    "Analise ACF/PACF da série Δlog_y para resíduos de autocorrelação.",
                                    "Compare variância antes/depois: deve reduzir em séries exponenciais.",
                                    "Simule cenários: reverta transformação para validar (exp(cumsum(Δlog_y))).",
                                    "Documente insights: ex: volatilidade dos retornos.",
                                    "Planeje próximos passos: ARIMA na série transformada."
                                  ],
                                  "verification": "ACF mostra decaimento rápido; reversão aproxima original; relatório escrito.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python (statsmodels.tsa.stattools para ACF)",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": [
                                    "Sempre reverta para checar: cumsum(Δlog_y) + log(y0) ≈ log(y).",
                                    "Use para previsões: forecast Δlog, exp para níveis."
                                  ],
                                  "learningObjective": "Avaliar eficácia da transformação e extrair insights acionáveis.",
                                  "commonMistakes": [
                                    "Ignorar não-estacionariedade residual (teste sempre).",
                                    "Interpretar Δlog como % simples (é aproximado só para pequenos)."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere preços diários de ações da AAPL: [100, 105, 110.25, 115.7625]. Aplique ln: [4.605, 4.654, 4.700, 4.751]. Diferenças: [0.049, 0.046, 0.051]. Média ≈ 4.9% diário log-retorno. Plote: original exponencial, transformada estacionária ~N(0.049, 0.02).",
                              "finalVerifications": [
                                "Série original mostra crescimento exponencial (razões ~constantes >1).",
                                "Série log-diferenças passa em teste ADF de estacionariedade.",
                                "Variância reduzida pós-transformação em pelo menos 50%.",
                                "Reversão (exp(cumsum(diffs) + ln(y0))) reconstrói original com erro <5%.",
                                "Retornos logarítmicos interpretados corretamente como crescimento contínuo.",
                                "Gráficos de antes/depois documentados e comparados."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos: erros numéricos <1e-6.",
                                "Correta identificação de aplicabilidade (exponencial vs linear).",
                                "Interpretação financeira/econômica válida dos retornos log.",
                                "Uso adequado de testes estatísticos (ADF, ACF).",
                                "Relatório claro com plots e insights acionáveis.",
                                "Tratamento de edge cases (zeros, missing values).",
                                "Eficiência: transformação torna série modelável (ARIMA-ready)."
                              ],
                              "crossCurricularConnections": [
                                "Finanças: Cálculo de retornos compostos em portfólios.",
                                "Economia: Modelagem de PIB ou inflação hiperbólica.",
                                "Biologia: Crescimento populacional bacteriano ou epidemias (Rt em COVID).",
                                "Física: Decaimento radioativo (log para meia-vida).",
                                "Machine Learning: Feature engineering para LSTM em time series."
                              ],
                              "realWorldApplication": "Em finanças, log-diferenças computam retornos diários de ações para Value-at-Risk (VaR) e hedging; em epidemiologia, estabilizam curvas de casos COVID para previsão; em e-commerce, analisam crescimento exponencial de usuários para churn prediction."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.5",
                    "name": "Criação de Objetos de Séries Temporais",
                    "description": "Conversão de dados importados em estruturas específicas para análise de séries temporais em softwares como R.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.5.1",
                        "name": "Objetos ts no R",
                        "description": "A classe 'ts' é a estrutura fundamental no R para representar séries temporais univariadas, permitindo definir o tempo inicial, a frequência (diária, mensal, anual) e o intervalo de tempo, essencial para análises subsequentes como modelagem ARIMA.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.1.1",
                            "name": "Criar objeto ts a partir de vetor",
                            "description": "Utilizar a função ts() para converter um vetor numérico em objeto ts, especificando parâmetros start (início, ex: c(2020,1)) e frequency (ex: 12 para mensal), garantindo alinhamento temporal correto.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o vetor numérico de dados",
                                  "subSteps": [
                                    "Colete ou crie um vetor numérico representando a série temporal (ex: vendas mensais).",
                                    "Garanta que o vetor tenha comprimento adequado ao período (ex: 24 para 2 anos mensais).",
                                    "Nomeie o vetor de forma descritiva (ex: vendas <- c(100, 120, 110, ...)).",
                                    "Verifique o tipo e comprimento com typeof() e length().",
                                    "Remova valores NA ou inf se existirem usando na.omit()."
                                  ],
                                  "verification": "Execute length(vetor) e typeof(vetor) para confirmar que é numérico e tem o tamanho esperado.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Console R ou RStudio, dados de exemplo em vetor.",
                                  "tips": "Use c() para criar vetores pequenos; importe de CSV para reais.",
                                  "learningObjective": "Dominar criação e validação inicial de vetores numéricos para séries temporais.",
                                  "commonMistakes": "Confundir com matriz ou data.frame; incluir não-numéricos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir parâmetros start e frequency",
                                  "subSteps": [
                                    "Identifique a data de início (ex: c(2020, 1) para janeiro de 2020).",
                                    "Escolha frequency: 12 para mensal, 4 para trimestral, 1 para anual.",
                                    "Calcule end implicitamente: end = start + (length(vetor)-1)/frequency.",
                                    "Documente os parâmetros em comentários no código.",
                                    "Teste cálculos manuais para alinhamento (ex: 24 meses de jan/2020 termina dez/2021)."
                                  ],
                                  "verification": "Anote start e frequency; calcule manualmente as datas de início e fim esperadas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Folha de papel ou bloco de notas para cálculos; console R.",
                                  "tips": "Frequency deve dividir o período uniformemente para evitar desalinhamentos.",
                                  "learningObjective": "Compreender e calcular corretamente start e frequency para alinhamento temporal.",
                                  "commonMistakes": "Usar frequency errada (ex: 365 para diário em vez de 12 mensal); start como string."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Criar o objeto ts com a função ts()",
                                  "subSteps": [
                                    "Escreva o comando: ts_obj <- ts(vetor, start = c(2020,1), frequency = 12).",
                                    "Execute o comando no console R.",
                                    "Atribua a um objeto nomeado (ex: vendas_ts).",
                                    "Inspecione com str(ts_obj) ou summary(ts_obj).",
                                    "Salve o código em um script .R para reutilização."
                                  ],
                                  "verification": "Execute class(ts_obj) deve retornar 'ts'; start(ts_obj) e frequency(ts_obj) devem coincidir.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "R ou RStudio aberto.",
                                  "tips": "Use ?ts para ver documentação; teste com dados pequenos primeiro.",
                                  "learningObjective": "Aplicar sintaxe correta da função ts() para conversão de vetor.",
                                  "commonMistakes": "Esquecer parênteses em start; frequency como inteiro não numérico."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e visualizar o objeto ts",
                                  "subSteps": [
                                    "Execute plot(ts_obj) para gráfico da série.",
                                    "Confira eixos: tempo deve iniciar em start e frequency correta.",
                                    "Use window(ts_obj, start=c(2020,1), end=c(2020,6)) para subperíodos.",
                                    "Compare com vetor original via as.numeric(ts_obj).",
                                    "Exporte com write.zoo ou save() se necessário."
                                  ],
                                  "verification": "Gráfico mostra alinhamento temporal correto; length(time(ts_obj)) == length(vetor).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Pacote base R (sem extras).",
                                  "tips": "plot() é automático para ts; adicione main='Título' para clareza.",
                                  "learningObjective": "Verificar integridade e usabilidade do objeto ts criado.",
                                  "commonMistakes": "Ignorar verificação de frequency no plot; não notar desalinhamento sazonal."
                                }
                              ],
                              "practicalExample": "Crie vendas <- c(100,120,110,130,140,150,160,170,180,190,200,210,220,230,240,250,260,270,280,290,300,310,320,330); vendas_ts <- ts(vendas, start=c(2020,1), frequency=12). Plote para ver vendas mensais de 2020-2021.",
                              "finalVerifications": [
                                "class(objeto) retorna 'ts'.",
                                "start(objeto) == c(2020,1).",
                                "frequency(objeto) == 12.",
                                "length(as.numeric(objeto)) == length(vetor original).",
                                "plot(objeto) exibe eixos temporais corretos.",
                                "window(objeto, end=c(2020,12)) tem 12 observações."
                              ],
                              "assessmentCriteria": [
                                "Vetor numérico preparado corretamente sem NAs.",
                                "Parâmetros start e frequency alinhados ao contexto temporal.",
                                "Função ts() invocada com sintaxe exata.",
                                "Objeto validado com class(), start(), frequency().",
                                "Visualização confirma estrutura temporal.",
                                "Código reproduzível e comentado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Sequências e progressões temporais.",
                                "Programação: Manipulação de objetos em R.",
                                "Economia: Análise de indicadores mensais como PIB ou inflação.",
                                "Geociências: Séries climáticas mensais de temperatura.",
                                "Finanças: Retornos de ações ou câmbio."
                              ],
                              "realWorldApplication": "Em análise financeira, converter vetor de preços mensais de ações em ts() permite forecasting com arima() ou decomposição sazonal para prever tendências de mercado."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.1.2",
                            "name": "Definir frequência e início adequados",
                            "description": "Escolher e aplicar frequency (1 anual, 4 trimestral, 12 mensal, 365 diário) e start baseado no contexto dos dados, evitando erros em plots e modelos que dependem da estrutura temporal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar o conjunto de dados para identificar padrões temporais",
                                  "subSteps": [
                                    "Examine os dados brutos (vetor ou data.frame) para identificar o intervalo de tempo coberto.",
                                    "Conte o número de observações e determine se são diárias, mensais, trimestrais ou anuais.",
                                    "Identifique a data de início real dos dados (primeira observação).",
                                    "Verifique se há lacunas ou irregularidades nos dados.",
                                    "Registre notas sobre o contexto (ex: dados mensais de vendas de 2020 a 2023)."
                                  ],
                                  "verification": "Crie um resumo com contagem de observações, data inicial/final e intervalo sugerido; confirme que matches com metadados dos dados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "RStudio, conjunto de dados de exemplo (ex: AirPassengers), documentação do R sobre ts().",
                                  "tips": "Use head() e tail() para inspecionar rapidamente as extremidades dos dados.",
                                  "learningObjective": "Compreender a estrutura temporal subjacente dos dados para informar escolhas de frequency e start.",
                                  "commonMistakes": "Assumir frequência sem contar observações; ignorar fusos horários ou dados irregulares."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar a frequency apropriada com base no contexto",
                                  "subSteps": [
                                    "Escolha frequency: 365 para diário, 12 para mensal, 4 para trimestral, 1 para anual.",
                                    "Valide com o número de observações (ex: 36 observações = 3 anos mensais → frequency=12).",
                                    "Considere o domínio: economia usa mensal/trimestral; clima pode ser diário.",
                                    "Teste frequency=1 se dados anuais agregados.",
                                    "Documente a justificativa para a escolha."
                                  ],
                                  "verification": "Calcule observações esperadas (anos * frequency) e compare com length(dados); deve coincidir.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Documentação R: ?ts; exemplos de séries temporais como EuStockMarkets.",
                                  "tips": "Lembre-se: frequency é ciclos por ano; use freq=7 para semanal.",
                                  "learningObjective": "Mapear corretamente o ritmo dos dados para a opção de frequency padrão do R.",
                                  "commonMistakes": "Confundir mensal (12) com semanal (52); escolher frequency muito alta para poucos dados."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir o parâmetro start corretamente",
                                  "subSteps": [
                                    "Identifique a data/posição da primeira observação (ex: janeiro 2020 → c(2020,1)).",
                                    "Formate como vetor c(ano, período): para mensal c(2020,1), diário c(2020,1).",
                                    "Ajuste se dados começam no meio do período (ex: março → c(2020,3)).",
                                    "Verifique fim implícito: start + (n-1)/frequency.",
                                    "Anote start em comentários do código."
                                  ],
                                  "verification": "Use str(ts_obj) para confirmar start exibido corretamente.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "R console, dados de teste com datas conhecidas.",
                                  "tips": "start é cíclico: para frequency=12, 13=1 do próximo ano.",
                                  "learningObjective": "Especificar o ponto de ancoragem temporal preciso para alinhamento correto.",
                                  "commonMistakes": "Usar data completa em vez de c(ano,periodo); off-by-one em posição inicial."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Criar o objeto ts e validar a estrutura temporal",
                                  "subSteps": [
                                    "Execute ts(dados, start=c(ano,periodo), frequency=valor).",
                                    "Plote com plot(ts_obj) para inspecionar eixos temporais.",
                                    "Use window() ou cycle() para extrair ciclos e confirmar periodicidade.",
                                    "Compare com dados originais via all.equal(as.numeric(ts_obj), dados).",
                                    "Salve o objeto e teste em modelo simples como plot(forecast(ts_obj))."
                                  ],
                                  "verification": "Plot mostra labels de tempo corretos (ex: anos/meses); cycle(ts_obj) repete 1-12 para mensal.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Pacotes: forecast, tseries; dados exemplo: ts(AirPassengers).",
                                  "tips": "Sempre plote imediatamente após criação para detecção visual de erros.",
                                  "learningObjective": "Construir e validar objeto ts funcional para análises subsequentes.",
                                  "commonMistakes": "Esquecer vírgula em start=c(2020,1); não validar levando a erros em ARIMA/stlf."
                                }
                              ],
                              "practicalExample": "Para dados mensais de passageiros aéreos de 1949-1960 (144 obs): ts(AirPassengers, start=c(1949,1), frequency=12). Plot mostra picos anuais corretos de jan/1949 a dez/1960.",
                              "finalVerifications": [
                                "plot(ts_obj) exibe eixo temporal alinhado com dados reais.",
                                "length(ts_obj) == length(dados originais).",
                                "start(ts_obj) retorna valores corretos.",
                                "cycle(ts_obj) varia de 1 a frequency repetidamente.",
                                "Não há warnings ao criar ou plotar.",
                                "Modelo simples como mean(ts_obj) por ciclo faz sentido."
                              ],
                              "assessmentCriteria": [
                                "Frequência escolhida matches exatamente com contagem de observações e contexto.",
                                "Start posiciona primeira observação corretamente no tempo.",
                                "Objeto ts plota sem distorções temporais.",
                                "Validações (cycle, window) confirmam estrutura.",
                                "Justificativa documentada para escolhas.",
                                "Evita erros comuns como frequency errada impactando forecasts."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Compreensão de periodicidade e ciclos em funções trigonométricas.",
                                "Programação: Manipulação de estruturas de dados indexadas em R/Python.",
                                "Economia/Negócios: Análise de tendências sazonais em séries financeiras.",
                                "Ciência de Dados: Pré-processamento para ML em time-series forecasting."
                              ],
                              "realWorldApplication": "Em previsão de vendas varejistas, definir frequency=12 e start=c(2015,1) garante modelos ARIMA capturem sazonalidade natalina, evitando forecasts enviesados por misalignment temporal."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.5.1.3",
                            "name": "Inspecionar estrutura de objeto ts",
                            "description": "Usar funções como class(), start(), end(), frequency(), plot() e summary() para verificar e visualizar o objeto ts, identificando possíveis problemas como missing values ou frequência incorreta.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Verificar atributos básicos do objeto ts",
                                  "subSteps": [
                                    "Carregue o objeto ts no ambiente R.",
                                    "Execute class(objeto) para confirmar a classe 'ts'.",
                                    "Execute start(objeto) para obter data de início.",
                                    "Execute end(objeto) para obter data de fim.",
                                    "Execute frequency(objeto) para verificar a frequência (ex: 12 para mensal)."
                                  ],
                                  "verification": "Todos os comandos retornam valores esperados sem erros e confirmam estrutura ts válida.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "RStudio, objeto ts criado previamente (ex: pacote 'stats').",
                                  "tips": "Salve os resultados em variáveis para facilitar comparação posterior.",
                                  "learningObjective": "Identificar e confirmar os atributos fundamentais de um objeto ts.",
                                  "commonMistakes": "Confundir frequency com período total; não verificar se o objeto é realmente 'ts'."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Visualizar a série temporal com plot()",
                                  "subSteps": [
                                    "Execute plot(objeto) para gerar o gráfico básico.",
                                    "Observe os eixos: tempo no x, valores no y.",
                                    "Identifique padrões visuais como tendência ou sazonalidade.",
                                    "Adicione título e labels com plot(objeto, main='Título', xlab='Tempo', ylab='Valores').",
                                    "Verifique se há quebras ou irregularidades visíveis."
                                  ],
                                  "verification": "Gráfico renderizado corretamente sem erros, com eixos interpretáveis.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "RStudio, objeto ts.",
                                  "tips": "Use par(mfrow=c(1,1)) para limpar múltiplos plots anteriores.",
                                  "learningObjective": "Visualizar e interpretar graficamente a estrutura da série temporal.",
                                  "commonMistakes": "Ignorar avisos de plot sobre frequência; não rotacionar labels em séries longas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar resumo estatístico com summary()",
                                  "subSteps": [
                                    "Execute summary(objeto) para obter estatísticas descritivas.",
                                    "Analise mínimo, máximo, média, mediana e quartis.",
                                    "Compare com frequency para validar consistência temporal.",
                                    "Registre observações sobre dispersão ou outliers.",
                                    "Salve o summary em um objeto para referência."
                                  ],
                                  "verification": "Summary exibe estatísticas coerentes com o tamanho e frequência do ts.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "RStudio, objeto ts.",
                                  "tips": "Combine com quantile() para mais detalhes sobre distribuição.",
                                  "learningObjective": "Extrair e interpretar métricas resumidas da série temporal.",
                                  "commonMistakes": "Interpretar summary como de dados não temporais; ignorar NA counts."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar problemas comuns como missing values e frequência incorreta",
                                  "subSteps": [
                                    "Execute sum(is.na(objeto)) para contar missing values.",
                                    "Verifique frequency(objeto) contra dados originais (ex: 12 para mensal).",
                                    "Use window(objeto, start=, end=) para subset e rechecagem.",
                                    "Se houver NAs, identifique posições com which(is.na(objeto)).",
                                    "Documente problemas e sugira correções (ex: na.approx())."
                                  ],
                                  "verification": "Relatório de problemas gerado, com contagem zero de NAs ou plano de correção.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "RStudio, funções base R (is.na, which).",
                                  "tips": "Crie um dataframe com atributos para relatório consolidado.",
                                  "learningObjective": "Detectar e diagnosticar inconsistências na estrutura ts.",
                                  "commonMistakes": "Não checar NAs após subset; assumir frequência sem validação externa."
                                }
                              ],
                              "practicalExample": "Crie um objeto ts de vendas mensais: vendas <- ts(rnorm(48, mean=100, sd=20), start=c(2020,1), frequency=12). Inspecione: class(vendas) retorna 'ts', start='2020 Jan', frequency=12, plot() mostra oscilações aleatórias sem NAs, summary() exibe média ~100.",
                              "finalVerifications": [
                                "Classe confirmada como 'ts' via class().",
                                "Start, end e frequency reportados corretamente.",
                                "Plot gerado sem erros, com interpretação visual.",
                                "Summary interpretado com estatísticas chave.",
                                "Ausência ou detecção precisa de missing values.",
                                "Frequência validada contra contexto dos dados."
                              ],
                              "assessmentCriteria": [
                                "Uso correto e sequencial das funções especificadas.",
                                "Interpretação precisa de saídas (atributos, gráfico, summary).",
                                "Detecção e relatório de problemas (NAs, frequência).",
                                "Documentação clara de achados.",
                                "Eficiência no tempo estimado.",
                                "Aplicação de tips para evitar erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Programação em R (Linguagens de Programação Computacional).",
                                "Estatística Descritiva (resumos e visualizações).",
                                "Análise Exploratória de Dados (diagnóstico inicial).",
                                "Visualização de Dados (gráficos temporais)."
                              ],
                              "realWorldApplication": "Em empresas de varejo para inspecionar dados de vendas sazonais antes de modelar previsões; em meteorologia para validar séries de temperatura e detectar gaps antes de análises climáticas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.5.2",
                        "name": "Conversão de dados importados para ts",
                        "description": "Transformar data frames ou matrizes provenientes de importações (CSV, Excel) em objetos ts, alinhando colunas de valores com índices temporais implícitos ou explícitos.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.2.1",
                            "name": "Usar as.ts() em data frames",
                            "description": "Aplicar a função as.ts() diretamente em um data frame ou vetor de uma coluna, especificando start e frequency para conversão automática, útil para dados tabulares sem coluna de data explícita.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o Data Frame com Dados Temporais",
                                  "subSteps": [
                                    "Carregue o ambiente R e instale/carregue pacotes necessários se aplicável (base R é suficiente).",
                                    "Importe ou crie um data frame com pelo menos uma coluna numérica representando a série temporal (ex: vendas mensais).",
                                    "Inspecione o data frame usando str(), head() e summary() para confirmar estrutura e tipos de dados.",
                                    "Identifique e extraia a coluna relevante (ex: df$vendas) garantindo que seja numérica com as.numeric().",
                                    "Defina o comprimento da série para alinhar com start e frequency."
                                  ],
                                  "verification": "Execute str(df) e confirme que a coluna alvo é numérica sem NAs; visualize head(df).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "R ou RStudio",
                                    "Dataset exemplo: AirPassengers (convertido para df) ou CSV customizado"
                                  ],
                                  "tips": "Use na.rm=TRUE ao converter para numérico se houver NAs iniciais.",
                                  "learningObjective": "Preparar dados tabulares limpos e prontos para conversão em objeto ts.",
                                  "commonMistakes": [
                                    "Tratar dados categóricos como numéricos",
                                    "Ignorar NAs que causam erros na conversão"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Determinar Parâmetros start e frequency",
                                  "subSteps": [
                                    "Analise o contexto dos dados: identifique a data inicial (ano e período, ex: c(1949, 1) para janeiro de 1949).",
                                    "Defina frequency baseada na periodicidade: 12 para mensal, 4 para trimestral, 1 para anual, 52 para semanal.",
                                    "Calcule o número de observações: length(coluna) deve matching com período total (ex: 12*12=144 para 12 anos mensais).",
                                    "Teste parâmetros em um subset pequeno: crie ts curto para validar.",
                                    "Documente os parâmetros escolhidos com comentários no código."
                                  ],
                                  "verification": "Crie variáveis start <- c(ano, periodo); frequency <- valor; e imprima para confirmação.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Documentação R: ?ts",
                                    "Dados de exemplo com periodicidade conhecida"
                                  ],
                                  "tips": "Frequency deve dividir exatamente o número de observações para end() ser preciso.",
                                  "learningObjective": "Selecionar corretamente start e frequency para representar a temporalidade dos dados.",
                                  "commonMistakes": [
                                    "Confundir start com end",
                                    "Escolher frequency errada levando a plot distorcido"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a Função as.ts() no Data Frame ou Coluna",
                                  "subSteps": [
                                    "Escreva a sintaxe: minha_serie <- as.ts(df$coluna, start = start, frequency = frequency).",
                                    "Para data frame inteiro (uma coluna): as.ts(df, start = start, frequency = frequency).",
                                    "Execute o comando e capture warnings ou erros com tryCatch() se necessário.",
                                    "Atribua o resultado a uma variável nomeada (ex: vendas_ts).",
                                    "Salve o código em um script para reutilização."
                                  ],
                                  "verification": "Execute class(minha_serie) e confirme 'ts'; sem erros na console.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Console R",
                                    "Script R para salvar"
                                  ],
                                  "tips": "Use as.ts() em vetor unidimensional; para múltiplas séries, aplique coluna por coluna.",
                                  "learningObjective": "Executar conversão precisa de dados tabulares para objeto ts usando as.ts().",
                                  "commonMistakes": [
                                    "Omitir start/frequency causando ts irregular",
                                    "Passar data frame com múltiplas colunas sem especificar"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Validar o Objeto ts Criado",
                                  "subSteps": [
                                    "Inspecione propriedades: start(minha_serie), end(minha_serie), frequency(minha_serie), length(minha_serie).",
                                    "Visualize a série: plot(minha_serie, main='Série Temporal Convertida').",
                                    "Compare com dados originais: sum(minha_serie) == sum(df$coluna).",
                                    "Teste operações básicas: window(minha_serie, start=c(1950,1), end=c(1955,12)).",
                                    "Exporte ou salve: saveRDS(minha_serie, 'serie_ts.rds')."
                                  ],
                                  "verification": "Propriedades start, end e frequency matching com parâmetros; plot exibe eixo temporal correto.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Funções base R: plot(), start(), frequency()",
                                    "RStudio para visualização"
                                  ],
                                  "tips": "Use tsp(minha_serie) para tupla completa de tempo.",
                                  "learningObjective": "Validar integridade e usabilidade do objeto ts para análises subsequentes.",
                                  "commonMistakes": [
                                    "Não verificar frequency levando a ciclos errados",
                                    "Ignorar warnings sobre irregularidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando o dataset AirPassengers (converta para df com as.data.frame(AirPassengers)): air_df <- data.frame(time=1949:1960 + seq(0,11)/12, passengers=AirPassengers); serie_ts <- as.ts(air_df$passengers, start=c(1949,1), frequency=12); plot(serie_ts). Isso converte passageiros aéreos mensais em ts plotável.",
                              "finalVerifications": [
                                "class(serie) retorna 'ts'.",
                                "start(serie) e end(serie) coincidem com dados originais.",
                                "frequency(serie) é o valor especificado (ex: 12).",
                                "plot(serie) mostra eixos de tempo corretos sem gaps.",
                                "length(serie) == nrow(df) ou length(coluna).",
                                "Nenhuma perda de dados: sum(serie) == sum(df$coluna)."
                              ],
                              "assessmentCriteria": [
                                "Parâmetros start e frequency especificados corretamente e justificados.",
                                "Conversão executada sem erros ou warnings.",
                                "Objeto ts validado com inspeções e plot adequados.",
                                "Código reproduzível e comentado.",
                                "Interpretação correta das propriedades do ts.",
                                "Aplicação em dataset real com resultados coerentes."
                              ],
                              "crossCurricularConnections": [
                                "Estatística Descritiva: Análise de tendências e sazonalidade.",
                                "Programação em R: Manipulação de data frames e vetores.",
                                "Análise Financeira: Séries de preços de ações ou vendas.",
                                "Ciência de Dados: Pré-processamento para modelagem ARIMA."
                              ],
                              "realWorldApplication": "Em empresas de varejo, converta planilhas Excel de vendas mensais em ts para forecasting com auto.arima(), permitindo previsões de demanda e otimização de estoque."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.5.2.2",
                            "name": "Extrair série univariada de múltiplas colunas",
                            "description": "Selecionar uma coluna específica de um data frame importado (ex: df$valor) e convertê-la em ts(), lidando com headers e tipos de dados para evitar erros de coerção.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Importar e Inspecionar o Data Frame",
                                  "subSteps": [
                                    "Carregue o dataset usando read.csv() ou read.table(), especificando header=TRUE se aplicável.",
                                    "Use str(df) para examinar a estrutura, tipos de dados e nomes das colunas.",
                                    "Execute head(df) e tail(df) para visualizar as primeiras e últimas linhas.",
                                    "Verifique valores ausentes com summary(df) ou is.na().",
                                    "Identifique a coluna alvo (ex: 'valor') que será extraída como série univariada."
                                  ],
                                  "verification": "Confirme que str(df) mostra a coluna correta com tipo numérico ou coercível, e não há erros de importação.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "R/RStudio, arquivo CSV de exemplo (ex: vendas.csv com colunas data, valor, categoria)",
                                  "tips": "Sempre especifique stringsAsFactors=FALSE para evitar problemas com fatores.",
                                  "learningObjective": "Entender a estrutura do data frame para seleção precisa de colunas.",
                                  "commonMistakes": "Esquecer header=TRUE levando a headers como primeira linha de dados; ignorar tipos não numéricos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e Extrair a Coluna Específica",
                                  "subSteps": [
                                    "Use df$nome_coluna ou df[[\"nome_coluna\"]] para extrair a coluna como vetor.",
                                    "Atribua a um novo objeto: serie <- df$valor.",
                                    "Verifique class(serie) e length(serie) para confirmar extração.",
                                    "Remova NAs se necessário: serie <- na.omit(serie).",
                                    "Converta para numérico se string: serie <- as.numeric(serie)."
                                  ],
                                  "verification": "Execute class(serie) e summary(serie); deve ser 'numeric' sem erros de coerção.",
                                  "estimatedTime": "8 minutos",
                                  "materials": "Data frame 'df' do step anterior",
                                  "tips": "Prefira df[[\"coluna\"]] para nomes com espaços ou caracteres especiais.",
                                  "learningObjective": "Dominar extração segura de colunas evitando perda de dados.",
                                  "commonMistakes": "Usar df[,\"coluna\"] resultando em matrix em vez de vetor; coerção falha em fatores."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Preparar Parâmetros para ts()",
                                  "subSteps": [
                                    "Defina frequência (ex: frequency=12 para mensal).",
                                    "Especifique start (ex: start=c(2020,1) para janeiro 2020).",
                                    "Confirme comprimento da série compatível com frequência.",
                                    "Crie um vetor de datas se necessário para validação futura.",
                                    "Teste coerção final: as.numeric(serie) sem warnings."
                                  ],
                                  "verification": "Valores de frequency e start fazem sentido para o domínio da série (ex: summary(serie) mostra range temporal implícito).",
                                  "estimatedTime": "7 minutos",
                                  "materials": "Vetor 'serie' do step anterior",
                                  "tips": "Use frequency=1 para anual, 4 para trimestral; consulte documentação ts() para opções.",
                                  "learningObjective": "Preparar dados com metadados temporais corretos para ts().",
                                  "commonMistakes": "Frequency errada causando ciclos incorretos; start com valores inválidos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Converter para Objeto ts() e Validar",
                                  "subSteps": [
                                    "Crie ts_serie <- ts(serie, start=c(2020,1), frequency=12).",
                                    "Execute plot(ts_serie) para visualização gráfica.",
                                    "Use start(ts_serie), end(ts_serie), frequency(ts_serie) para metadados.",
                                    "Verifique class(ts_serie) == 'ts'.",
                                    "Salve com saveRDS() para reutilização."
                                  ],
                                  "verification": "plot(ts_serie) mostra série temporal coerente sem erros; class e atributos corretos.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Vetor preparado e parâmetros do step anterior",
                                  "tips": "Sempre plote imediatamente para detectar anomalias visuais.",
                                  "learningObjective": "Criar e validar objeto ts() pronto para análise.",
                                  "commonMistakes": "ts() sem frequency levando a série não sazonal; dados não numéricos causando NA."
                                }
                              ],
                              "practicalExample": "Em um dataset vendas.csv com colunas 'data' (YYYY-MM), 'valor' (numérico) e 'regiao', extraia df$valor, converta para ts(valor, start=c(2020,1), frequency=12), e plote para ver vendas mensais de 2020-2023.",
                              "finalVerifications": [
                                "class(ts_serie) retorna 'ts'.",
                                "frequency(ts_serie) e start(ts_serie) correspondem aos dados.",
                                "plot(ts_serie) exibe eixo temporal correto sem gaps.",
                                "summary(ts_serie) mostra estatísticas numéricas válidas.",
                                "Não há NAs introduzidos na conversão.",
                                "Comprimento da série bate com dados originais."
                              ],
                              "assessmentCriteria": [
                                "Extração da coluna sem perda de dados ou coerção desnecessária.",
                                "Objeto ts() com frequência e start precisos.",
                                "Visualização gráfica coerente e sem erros.",
                                "Tratamento correto de tipos de dados e NAs.",
                                "Código reproduzível e comentado.",
                                "Validações manuais executadas com outputs corretos."
                              ],
                              "crossCurricularConnections": [
                                "Programação em R (manipulação de data frames).",
                                "Estatística descritiva (summary e plot).",
                                "Gestão de dados (limpeza e preparação).",
                                "Matemática (conceitos de periodicidade e tempo)."
                              ],
                              "realWorldApplication": "Em análise de vendas de uma empresa, extrair coluna de faturamento mensal de um CSV exportado do ERP, convertê-la em ts() para modelagem ARIMA e previsão de demanda futura."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.1.3",
                              "10.1.2.5.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.5.2.3",
                            "name": "Criar objetos mts para séries multivariadas",
                            "description": "Usar ts() em matrizes com múltiplas colunas para formar objetos mts (multivariate ts), especificando dimensões e garantindo alinhamento temporal entre variáveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a matriz de dados multivariados",
                                  "subSteps": [
                                    "Importe os dados brutos usando read.csv() ou similar para uma matriz com múltiplas colunas representando variáveis temporais.",
                                    "Verifique a estrutura dos dados com str() e head() para confirmar que há pelo menos duas colunas numéricas alinhadas temporalmente.",
                                    "Converta as colunas relevantes em uma matriz usando as.matrix() ou cbind(), garantindo que as linhas correspondam a observações temporais sequenciais.",
                                    "Defina o vetor de frequências temporais (ex: frequência mensal = 12) e o início da série (ex: c(2020,1)).",
                                    "Nomeie as colunas da matriz para facilitar identificação das variáveis."
                                  ],
                                  "verification": "Execute dim(matriz) e colnames(matriz) para confirmar dimensões e nomes; todas as colunas devem ser numéricas sem NAs iniciais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "R instalado",
                                    "pacote 'datasets' ou arquivo CSV de exemplo com dados multivariados (ex: AirPassengers com variável extra)",
                                    "Editor R como RStudio"
                                  ],
                                  "tips": "Use na.rm=TRUE ao criar a matriz se houver poucos NAs no final; sempre padronize datas para alinhamento.",
                                  "learningObjective": "Preparar dados multivariados limpos e alinhados para conversão em objeto mts.",
                                  "commonMistakes": [
                                    "Ignorar desalinhamento temporal entre colunas",
                                    "Esquecer de converter fatores para numéricos",
                                    "Não definir frequência corretamente desde o início"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar parâmetros da função ts() para objetos mts",
                                  "subSteps": [
                                    "Consulte ?ts() para entender argumentos: start, frequency, end, deltat e dimensões implícitas para multivariadas.",
                                    "Note que para mts, ts() infere múltiplas séries de colunas da matriz de entrada.",
                                    "Prepare argumentos: start = c(ano, período), frequency = número de observações por unidade temporal.",
                                    "Teste com uma série univariada simples usando ts(univariavel) para validar setup.",
                                    "Identifique dimensões esperadas: nrow(matriz) observações, ncol(matriz) variáveis."
                                  ],
                                  "verification": "Crie um ts univariado teste e verifique com frequency(ts_obj) e start(ts_obj) para confirmar parâmetros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Documentação R: ?ts",
                                    "Console R interativo"
                                  ],
                                  "tips": "Frequência comum: 12 (mensal), 4 (trimestral), 52 (semanal); use deltat=1/frequency para precisão.",
                                  "learningObjective": "Dominar os parâmetros essenciais de ts() para séries multivariadas.",
                                  "commonMistakes": [
                                    "Confundir start com end",
                                    "Usar frequency incorreta levando a ciclos errados",
                                    "Passar data.frame em vez de matriz"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Criar o objeto mts usando ts() na matriz",
                                  "subSteps": [
                                    "Execute mts_obj <- ts(matriz, start = c(2020,1), frequency = 12).",
                                    "Confirme criação com class(mts_obj) que deve retornar 'mts'.",
                                    "Acesse componentes com mts_obj[,1] para primeira variável e plot(mts_obj) para visualização múltipla.",
                                    "Ajuste se necessário com window() para subset temporal.",
                                    "Salve o objeto com saveRDS() para reutilização."
                                  ],
                                  "verification": "plot(mts_obj) mostra múltiplas séries alinhadas; dim(mts_obj) retorna dimensões corretas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Matriz preparada do step 1",
                                    "RStudio para plotting"
                                  ],
                                  "tips": "Use frequency que divida o período uniformemente; plot() é ótimo para inspeção visual inicial.",
                                  "learningObjective": "Aplicar ts() corretamente para gerar objetos mts funcionais.",
                                  "commonMistakes": [
                                    "Não especificar start levando a alinhamento errado",
                                    "Matriz com NAs causando falha",
                                    "Esquecer de carregar pacotes como 'forecast' se necessário"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e diagnosticar o objeto mts criado",
                                  "subSteps": [
                                    "Use summary(mts_obj) para estatísticas descritivas por variável.",
                                    "Verifique alinhamento com cycle(mts_obj) e time(mts_obj).",
                                    "Teste operações básicas: VAR(mts_obj) para variância cruzada.",
                                    "Identifique problemas como não-estacionariedade com ndiffs() do pacote forecast.",
                                    "Documente o objeto com atributos(mts_obj) e corrija se frequência ou start estiverem errados."
                                  ],
                                  "verification": "class(mts_obj) == 'mts' e todas verificações acima sem erros; plot sem desalinhamentos visuais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Pacote 'forecast' instalado: install.packages('forecast')",
                                    "Dados de exemplo"
                                  ],
                                  "tips": "Sempre plote múltiplas séries sobrepostas para detectar desalinhamentos sutis.",
                                  "learningObjective": "Garantir integridade e usabilidade do objeto mts para análises avançadas.",
                                  "commonMistakes": [
                                    "Assumir sucesso sem plotar",
                                    "Ignorar warnings sobre conversão de classes",
                                    "Não testar acessos como mts_obj[,'var2']"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere dados de vendas de produtos A e B mensais de jan/2020 a dez/2023 em matriz vendas_mat = matrix(c(vendasA, vendasB), ncol=2); mts_vendas <- ts(vendas_mat, start=c(2020,1), frequency=12). Plot mostra ambas séries alinhadas, permitindo análise VAR para previsão conjunta.",
                              "finalVerifications": [
                                "class(objeto) retorna 'mts'",
                                "dim(objeto) reflete nrow=observações e ncol=variáveis corretas",
                                "start(objeto) e frequency(objeto) coincidem com dados originais",
                                "plot(objeto) exibe séries alinhadas sem gaps ou shifts",
                                "Acesso seletivo como objeto[,'var2'] funciona sem erro",
                                "summary(objeto) mostra estatísticas coerentes por variável"
                              ],
                              "assessmentCriteria": [
                                "Correção na preparação da matriz multivariada (tipos numéricos, alinhamento)",
                                "Uso preciso de parâmetros ts() (start, frequency adequados)",
                                "Validação completa do objeto mts criado (classe, dims, plot)",
                                "Detecção e correção de erros comuns (NAs, desalinhamento)",
                                "Capacidade de aplicar em exemplo prático com documentação",
                                "Eficiência temporal dentro dos estimates"
                              ],
                              "crossCurricularConnections": [
                                "Programação em R (manipulação de dados com matrizes e funções ts)",
                                "Estatística (conceitos de séries temporais multivariadas e covariância)",
                                "Análise de Dados (preparação para modelos VAR/ARIMA multivariados)",
                                "Matemática (vetores, matrizes e alinhamento temporal)",
                                "Economia/Finanças (aplicações em dados macroeconômicos multivariados)"
                              ],
                              "realWorldApplication": "Em análise econômica, criar mts de PIB, inflação e desemprego permite modelagem VAR para prever recessões, auxiliando bancos centrais em decisões de política monetária com dados alinhados temporalmente."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.1.2",
                              "10.1.2.5.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.5.3",
                        "name": "Manipulação inicial de objetos ts",
                        "description": "Realizar ajustes básicos em objetos ts já criados, como seleção de subperíodos e verificação de propriedades temporais, preparando para análises exploratórias.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.3.1",
                            "name": "Selecionar subperíodos com window()",
                            "description": "Aplicar window(ts_obj, start=c(ano,mes), end=c(ano,mes)) para extrair janelas específicas de uma série temporal, útil para focar em períodos de interesse sem recriar o objeto.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e criar um objeto ts de exemplo",
                                  "subSteps": [
                                    "Abra o R ou RStudio.",
                                    "Carregue dados de exemplo com dados(AirPassengers) ou crie um vetor de série temporal simulado, como: ts_data <- ts(rnorm(144), start=c(2000,1), frequency=12).",
                                    "Atribua o objeto ts a uma variável: ts_obj <- AirPassengers.",
                                    "Examine o objeto com str(ts_obj), start(ts_obj), end(ts_obj) e frequency(ts_obj).",
                                    "Plote o objeto original com plot(ts_obj) para visualizar a série completa."
                                  ],
                                  "verification": "Confirme que ts_obj é um objeto de classe 'ts' com start, end e frequency corretos via str() e plot().",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "R ou RStudio instalado",
                                    "Pacote base R (sem necessidade de instalação adicional)"
                                  ],
                                  "tips": [
                                    "Use dados reais como AirPassengers para prática autêntica.",
                                    "Sempre verifique a frequência (12 para mensal, 4 para trimestral)."
                                  ],
                                  "learningObjective": "Configurar e inspecionar um objeto ts básico para manipulação.",
                                  "commonMistakes": [
                                    "Esquecer de definir frequency ao criar ts personalizado.",
                                    "Confundir start/end com formato incorreto (deve ser c(ano, período))."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender e definir os parâmetros start e end para window()",
                                  "subSteps": [
                                    "Consulte a documentação com ?window para revisar a sintaxe: window(x, start, end).",
                                    "Identifique o período de interesse: por exemplo, para AirPassengers (1949-1960 mensal), escolha start=c(1955,1) e end=c(1960,12).",
                                    "Calcule o número de observações esperadas: (end_ano - start_ano)*frequency + (end_periodo - start_periodo).",
                                    "Teste parâmetros isoladamente com start() e end() no objeto original para validar.",
                                    "Anote os parâmetros em um script para reutilização."
                                  ],
                                  "verification": "Escreva os parâmetros start e end em um vetor e confirme que correspondem ao período visualizado no plot original.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Ajuda do R (?window)",
                                    "Plot do objeto ts original"
                                  ],
                                  "tips": [
                                    "start e end usam o formato c(ano, posição_no_ciclo), onde posição é 1 a frequency.",
                                    "Evite ultrapassar os limites do objeto original."
                                  ],
                                  "learningObjective": "Dominar a sintaxe exata de start e end compatível com a frequência do ts.",
                                  "commonMistakes": [
                                    "Usar data completa como '2020-01' em vez de c(2020,1).",
                                    "Ignorar a frequency, causando desalinhamento."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a função window() para extrair o subperíodo",
                                  "subSteps": [
                                    "Execute: sub_ts <- window(ts_obj, start=c(1955,1), end=c(1960,12)).",
                                    "Inspecione o novo objeto com str(sub_ts), start(sub_ts), end(sub_ts), length(sub_ts).",
                                    "Plote o sub_ts com plot(sub_ts) e compare visualmente com o original.",
                                    "Salve o resultado em um novo objeto para preservar o original.",
                                    "Teste com outro período para reforçar, como start=c(1950,6), end=c(1955,6)."
                                  ],
                                  "verification": "O novo objeto sub_ts tem start e end exatos aos especificados e length correto.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Objeto ts_obj pronto",
                                    "Editor de script R"
                                  ],
                                  "tips": [
                                    "Use window() em vez de subsetting manual para preservar atributos ts.",
                                    "Sempre atribua a um novo objeto para evitar sobrescrever."
                                  ],
                                  "learningObjective": "Executar window() corretamente e validar o output.",
                                  "commonMistakes": [
                                    "Passar start/end como lista em vez de vetor c().",
                                    "Selecionar período além dos limites, resultando em NA ou erro."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e integrar o subperíodo em análises subsequentes",
                                  "subSteps": [
                                    "Compare estatísticas: summary(ts_obj) vs summary(sub_ts).",
                                    "Aplique uma análise simples, como média móvel: mean(sub_ts).",
                                    "Exporte ou salve o sub_ts com write.zoo(sub_ts, 'subperiodo.csv') (após library(zoo)).",
                                    "Documente o código em um relatório com comentários explicando o período selecionado.",
                                    "Teste robustez alterando frequency ou dados e reaplicando window()."
                                  ],
                                  "verification": "O sub_ts integra-se sem erros em funções ts como forecast::auto.arima(sub_ts).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Pacote zoo opcional para export",
                                    "Funções summary() e plot()"
                                  ],
                                  "tips": [
                                    "Mantenha o sub_ts como 'ts' para compatibilidade com funções de séries temporais.",
                                    "Comente o motivo da seleção do período (ex: foco em tendência crescente)."
                                  ],
                                  "learningObjective": "Usar o subperíodo de forma prática e validar sua integridade.",
                                  "commonMistakes": [
                                    "Perder atributos ts ao usar [ ] indexing em vez de window().",
                                    "Não verificar NA introduzidos por limites inválidos."
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dados AirPassengers (passageiros aéreos mensais de 1949-1960): sub_passengers <- window(AirPassengers, start=c(1955,1), end=c(1960,12)). Isso extrai 72 observações de 1955 a 1960, focando no período de crescimento acelerado, preservando frequency=12.",
                              "finalVerifications": [
                                "start(sub_ts) retorna exatamente os valores de start especificados.",
                                "end(sub_ts) corresponde aos valores de end.",
                                "length(sub_ts) equals o número calculado de observações.",
                                "class(sub_ts) permanece 'ts' com frequency idêntica ao original.",
                                "plot(sub_ts) alinha perfeitamente com a porção correspondente do plot original.",
                                "Não há NA ou valores inesperados em sub_ts."
                              ],
                              "assessmentCriteria": [
                                "Precisão na especificação de start=c(ano,mes) e end=c(ano,mes).",
                                "Validação completa com start(), end(), length() e plot().",
                                "Preservação dos atributos ts (classe, frequency).",
                                "Uso correto de window() em vez de métodos alternativos inadequados.",
                                "Capacidade de aplicar em múltiplos exemplos e períodos.",
                                "Documentação clara do código e justificativa do período."
                              ],
                              "crossCurricularConnections": [
                                "Programação em Python: Similar a df.loc['1955-01':'1960-12'] em pandas DataFrame.",
                                "Economia: Seleção de trimestres durante recessões para análise de PIB (frequency=4).",
                                "Ciência de Dados: Pré-processamento para modelagem em machine learning focada em janelas.",
                                "Estatística: Integração com decomposição sazonal em subperíodos específicos."
                              ],
                              "realWorldApplication": "Em análise financeira, use window() para extrair dados de ações durante a crise de 2008 (start=c(2008,1), end=c(2009,12)) de um ts diário, permitindo modelar volatilidade específica sem recriar o dataset inteiro, otimizando forecasts para portfólios."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.1.3"
                            ]
                          },
                          {
                            "id": "10.1.2.5.3.2",
                            "name": "Acessar e modificar atributos temporais",
                            "description": "Usar funções como start(), end(), frequency() para consultar e tsp() para modificar atributos temporais de um objeto ts, corrigindo erros de configuração inicial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e criar um objeto ts básico",
                                  "subSteps": [
                                    "Instale e carregue o pacote 'ts' no R com install.packages('ts') se necessário e library(ts).",
                                    "Crie um vetor de dados de exemplo, como dados mensais de vendas: vendas <- c(100, 110, 120, 130, 140, 150).",
                                    "Construa o objeto ts com tsp(c(2023,1), frequency=12): ts_vendas <- ts(vendas, start=c(2023,1), frequency=12).",
                                    "Execute str(ts_vendas) para inspecionar a estrutura inicial do objeto."
                                  ],
                                  "verification": "Confirme que ts_vendas é um objeto de classe 'ts' sem erros de criação usando class(ts_vendas) e str(ts_vendas).",
                                  "estimatedTime": "10 minutos",
                                  "materials": "R ou RStudio instalado, pacote 'ts', dados de exemplo em vetor.",
                                  "tips": "Sempre especifique start e frequency explicitamente para evitar configurações padrão incorretas.",
                                  "learningObjective": "Configurar corretamente um objeto ts com atributos temporais iniciais.",
                                  "commonMistakes": "Esquecer de carregar library(ts); usar frequency incorreta (ex: 12 para mensais em vez de 4 para trimestrais)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Acessar atributos temporais com funções de consulta",
                                  "subSteps": [
                                    "Use start(ts_vendas) para obter o início da série (esperado: [1] 2023 1).",
                                    "Execute end(ts_vendas) para o fim da série (esperado: [1] 2023 6).",
                                    "Aplique frequency(ts_vendas) para a frequência (esperado: [1] 12).",
                                    "Combine em um summary: cat('Start:', start(ts_vendas), 'End:', end(ts_vendas), 'Freq:', frequency(ts_vendas))."
                                  ],
                                  "verification": "Todos os comandos retornam valores esperados sem erros; compare com a configuração inicial.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Objeto ts_vendas criado no step anterior, console R.",
                                  "tips": "Salve os resultados em variáveis para reutilização, ex: inicio <- start(ts_vendas).",
                                  "learningObjective": "Consultar precisamente os atributos temporais de um objeto ts.",
                                  "commonMistakes": "Confundir start() com início calendário vs. índice; não notar que retorna vetor de 2 elementos para start/end."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modificar atributos temporais usando tsp()",
                                  "subSteps": [
                                    "Crie um novo tsp: novo_tsp <- tsp(ts_vendas); novo_tsp[2] <- 4  # Muda frequency para trimestral simulada.",
                                    "Aplique tsp(ts_vendas) <- novo_tsp para modificar.",
                                    "Verifique as mudanças com start(), end(), frequency() após modificação.",
                                    "Teste com correção de erro: se frequency errada, recrie com tsp correto."
                                  ],
                                  "verification": "Atributos alterados refletem o novo tsp; sem perda de dados ou warnings.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Objeto ts_vendas modificável, funções tsp(), start(), etc.",
                                  "tips": "tsp() retorna/atribui um vetor c(start, end, frequency); modifique componentes específicos com indexação.",
                                  "learningObjective": "Alterar atributos temporais de forma segura e verificar impactos.",
                                  "commonMistakes": "Modificar start sem ajustar dados; ignorar que tsp() não realinha dados automaticamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Corrigir erros de configuração inicial e validar",
                                  "subSteps": [
                                    "Simule erro: crie ts_errado <- ts(vendas, frequency=4)  # frequency errada para dados mensais.",
                                    "Identifique com start(ts_errado), end(), frequency().",
                                    "Corrija: tsp(ts_errado) <- c(2023,1,12); verifique novamente.",
                                    "Compare plot(ts_vendas) vs plot(ts_errado corrigido) para visualização."
                                  ],
                                  "verification": "Objeto corrigido tem atributos idênticos ao original; plot sem distorções temporais.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Objetos ts originais e errados, função plot().",
                                  "tips": "Use window() para subsetar após correções se necessário.",
                                  "learningObjective": "Diagnosticar e remediar configurações temporais incorretas em objetos ts.",
                                  "commonMistakes": "Não testar após correção; assumir que dados se auto-ajustam."
                                }
                              ],
                              "practicalExample": "Crie ts_vendas <- ts(c(100,110,120,130,140,150), start=c(2023,1), frequency=12). Acesse: start(ts_vendas) → [1] 2023 1. Modifique para trimestral: tsp(ts_vendas) <- c(2023,1,4). Verifique: frequency(ts_vendas) → [1] 4. Corrija erro comum de frequency=52 em dados mensais.",
                              "finalVerifications": [
                                "start(), end() e frequency() retornam valores esperados pré e pós-modificação.",
                                "str(objeto_ts) mostra classe 'ts' com tsp correto.",
                                "plot(ts_objeto) exibe eixo temporal alinhado corretamente.",
                                "window(ts_objeto, start=c(2023,3)) subseta sem erros.",
                                "Nenhum warning ou erro em acessos/modificações."
                              ],
                              "assessmentCriteria": [
                                "Precisão na consulta de start(), end(), frequency() (100% correto).",
                                "Modificação via tsp() sem perda de integridade dos dados.",
                                "Identificação e correção de 2+ erros comuns de configuração.",
                                "Uso correto de verificações em todos os steps.",
                                "Explicação clara de mudanças em comentários no código.",
                                "Tempo total dentro de 60 minutos com resultados reproduzíveis."
                              ],
                              "crossCurricularConnections": [
                                "Programação em R: Manipulação de objetos e funções mutáveis.",
                                "Estatística: Preparação de dados para modelagem de séries temporais (ARIMA).",
                                "Análise de Dados: Limpeza e validação de dados temporais em big data.",
                                "Matemática: Compreensão de periodicidade e indexação sequencial."
                              ],
                              "realWorldApplication": "Em análise de vendas de varejo, corrija frequency de um ts de transações diárias mal configurado para modelagem precisa de sazonalidade mensal, permitindo forecasts precisos com auto.arima() e evitando erros em relatórios gerenciais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.1.2",
                              "10.1.2.5.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.3",
                "name": "Análise Exploratória de Séries Temporais",
                "description": "Técnicas para explorar e visualizar características de séries temporais.",
                "totalSkills": 39,
                "atomicTopics": [
                  {
                    "id": "10.1.3.1",
                    "name": "Visualização Gráfica de Séries Temporais",
                    "description": "Técnicas para plotar séries temporais, incluindo gráficos de linha e decomposição em tendência, sazonalidade e resíduo.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.1.1.1",
                        "name": "Gráficos de Linha para Séries Temporais",
                        "description": "Técnicas fundamentais para plotar séries temporais utilizando gráficos de linha, permitindo a visualização da evolução temporal dos dados e identificação inicial de padrões.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.1.1.1",
                            "name": "Criar gráfico de linha básico",
                            "description": "Implementar um gráfico de linha simples para uma série temporal, configurando o eixo x como índice temporal (datas ou períodos) e o eixo y como valores observados, utilizando bibliotecas como matplotlib em Python ou ggplot2 em R.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os Dados da Série Temporal",
                                  "subSteps": [
                                    "Instale e importe as bibliotecas necessárias: pandas e numpy usando pip se preciso.",
                                    "Crie ou carregue uma lista de datas sequenciais (ex: pd.date_range('2023-01-01', periods=12, freq='M') para meses).",
                                    "Gere valores observados correspondentes (ex: array numpy com vendas fictícias como [100, 120, 110, ...]).",
                                    "Estruture os dados em um pandas DataFrame com colunas 'data' e 'valor'.",
                                    "Ordene o DataFrame por data e verifique ausência de valores ausentes com df.isnull().sum()."
                                  ],
                                  "verification": "DataFrame criado com datas no eixo temporal ordenadas cronologicamente e valores numéricos válidos, sem NaNs.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "Bibliotecas: pandas, numpy"
                                  ],
                                  "tips": "Use pd.to_datetime() para converter strings em datas se carregando de CSV.",
                                  "learningObjective": "Compreender e preparar dados estruturados para visualização de séries temporais.",
                                  "commonMistakes": [
                                    "Não ordenar dados cronologicamente",
                                    "Misturar tipos de dados nos eixos",
                                    "Ignorar valores ausentes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Importar Bibliotecas de Visualização e Inicializar a Figura",
                                  "subSteps": [
                                    "Importe matplotlib.pyplot as plt.",
                                    "Crie uma nova figura com plt.figure(figsize=(10, 6)) para dimensões adequadas.",
                                    "Converta a coluna de datas para formato reconhecível pelo matplotlib usando pd.to_datetime(df['data']).dt.to_pydatetime() se necessário.",
                                    "Defina o estilo do plot com plt.style.use('default') ou outro para clareza.",
                                    "Ative o grid com plt.grid(True, alpha=0.3) para melhor legibilidade."
                                  ],
                                  "verification": "Figura inicializada sem erros e grid visível ao testar plt.show().",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Biblioteca: matplotlib"
                                  ],
                                  "tips": "Ajuste figsize para evitar gráficos cortados em relatórios.",
                                  "learningObjective": "Configurar ambiente de plotting básico com matplotlib.",
                                  "commonMistakes": [
                                    "Esquecer de importar plt",
                                    "Usar tamanho de figura muito pequeno",
                                    "Não ativar grid para séries temporais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Plotar o Gráfico de Linha Básico",
                                  "subSteps": [
                                    "Extraia as séries: datas = df['data'] e valores = df['valor'].",
                                    "Execute plt.plot(datas, valores, marker='o', linewidth=2, color='blue') para linha com marcadores.",
                                    "Adicione rótulo à linha com label='Valores Observados'.",
                                    "Use fmt='o-' em plot para linha e pontos automaticamente.",
                                    "Verifique rotação de labels no eixo x com plt.xticks(rotation=45) para datas longas."
                                  ],
                                  "verification": "Linha contínua plotada conectando pontos sequencialmente sem interrupções.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Código Python preparado no step 1"
                                  ],
                                  "tips": "Adicione marker='o' para destacar pontos de dados em séries temporais.",
                                  "learningObjective": "Implementar plot de linha para representar tendências temporais.",
                                  "commonMistakes": [
                                    "Plotar valores em x e datas em y",
                                    "Não usar marker em dados discretos",
                                    "Linha muito fina e ilegível"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Configurar Eixos, Títulos e Formatação",
                                  "subSteps": [
                                    "Defina rótulos: plt.xlabel('Data'), plt.ylabel('Valores Observados'), plt.title('Gráfico de Linha Básico - Série Temporal').",
                                    "Formate eixo x temporal com matplotlib.dates.DateFormatter('%Y-%m') se aplicável.",
                                    "Ajuste limites dos eixos com plt.xlim e plt.ylim para foco nos dados.",
                                    "Adicione legenda com plt.legend().",
                                    "Melhore layout com plt.tight_layout() para evitar sobreposições."
                                  ],
                                  "verification": "Eixos rotulados corretamente, título presente e legenda visível sem overlaps.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Gráfico plotado do step 3"
                                  ],
                                  "tips": "Use rotation=45 nos xticks para datas em ângulo.",
                                  "learningObjective": "Customizar visualizações para clareza e profissionalismo.",
                                  "commonMistakes": [
                                    "Labels genéricos ou ausentes",
                                    "Eixo x não formatado para datas",
                                    "Título muito longo sem quebra"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Exibir, Salvar e Validar o Gráfico",
                                  "subSteps": [
                                    "Exiba o gráfico com plt.show() para inspeção visual.",
                                    "Salve em alta resolução: plt.savefig('grafico_linha_basico.png', dpi=300, bbox_inches='tight').",
                                    "Valide: verifique se eixo x é temporal crescente e y escala valores corretamente.",
                                    "Teste com dados reais de um CSV pequeno para robustez.",
                                    "Feche a figura com plt.close() para liberar memória."
                                  ],
                                  "verification": "Gráfico salvo como PNG legível e exibido sem erros de formatação.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Gráfico completo dos steps anteriores"
                                  ],
                                  "tips": "Sempre use bbox_inches='tight' ao salvar para incluir labels.",
                                  "learningObjective": "Finalizar e exportar visualizações para uso prático.",
                                  "commonMistakes": [
                                    "Não salvar em alta DPI",
                                    "Esquecer plt.close() em loops",
                                    "Ignorar validação visual"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dados de vendas mensais de uma loja em 2023 (janeiro: 100 unidades, fevereiro: 120, ..., dezembro: 150), crie um DataFrame com pd.date_range e valores numpy. Plote com plt.plot(datas, vendas, marker='o'), adicione xlabel('Mês'), ylabel('Vendas'), title('Vendas Mensais 2023') e salve como 'vendas_2023.png'.",
                              "finalVerifications": [
                                "Gráfico exibe linha contínua conectando pontos temporais sequenciais.",
                                "Eixo x representa datas ou períodos em ordem cronológica crescente.",
                                "Eixo y escala valores observados corretamente sem distorções.",
                                "Labels, título e legenda estão presentes e legíveis.",
                                "Gráfico salvo em formato imagem de alta qualidade sem cortes.",
                                "Nenhum erro de plotting ou dados ausentes no output final."
                              ],
                              "assessmentCriteria": [
                                "Precisão na preparação e ordenação dos dados temporais (20%).",
                                "Correta implementação do plt.plot com parâmetros adequados (25%).",
                                "Qualidade da customização de eixos, labels e título (20%).",
                                "Funcionalidade de exibição e salvamento sem erros (15%).",
                                "Clareza visual geral e ausência de erros comuns (10%).",
                                "Uso eficiente de recursos e boas práticas de código (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Representação gráfica de funções e tendências lineares.",
                                "Programação: Manipulação de arrays e bibliotecas de visualização.",
                                "Ciências Ambientais: Visualização de dados climáticos ou sensoriais ao longo do tempo.",
                                "Economia: Análise de séries temporais em indicadores econômicos.",
                                "Design: Princípios de visualização de dados claros e informativos."
                              ],
                              "realWorldApplication": "Em análise financeira, criar gráficos de linha para visualizar a evolução de preços de ações diárias ao longo de um ano, identificando tendências de alta/queda para decisões de investimento; ou em meteorologia, plotar temperaturas médias mensais para detectar padrões sazonais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.1.2",
                            "name": "Personalizar gráficos de linha",
                            "description": "Adicionar elementos como títulos descritivos, rótulos de eixos com formatação temporal, grades, legendas e escalas adequadas para destacar variações em séries temporais longas ou curtas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Criar gráfico de linha básico e adicionar título e rótulos de eixos",
                                  "subSteps": [
                                    "Carregue os dados de série temporal usando pandas (ex: pd.read_csv()).",
                                    "Crie o gráfico de linha básico com plt.plot(data.index, data.values).",
                                    "Adicione título descritivo com plt.title('Título Descritivo da Série Temporal').",
                                    "Defina rótulos de eixos com plt.xlabel('Tempo') e plt.ylabel('Valor').",
                                    "Ajuste o layout com plt.tight_layout()."
                                  ],
                                  "verification": "Execute o código e confirme que o gráfico exibe título e rótulos visíveis e legíveis.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python com bibliotecas pandas e matplotlib instaladas",
                                    "Dataset de série temporal exemplo (ex: CSV com datas e valores)"
                                  ],
                                  "tips": "Use títulos que resumam o período e variável para clareza imediata.",
                                  "learningObjective": "Dominar a criação inicial de gráficos com elementos textuais essenciais.",
                                  "commonMistakes": [
                                    "Esquecer de converter índice para datetime",
                                    "Títulos genéricos sem contexto",
                                    "Rótulos de eixos trocados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formatar eixos com formatação temporal adequada",
                                  "subSteps": [
                                    "Converta o índice para datetime com pd.to_datetime(data.index).",
                                    "Use matplotlib.dates para formatar o eixo x: plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%b %Y')).",
                                    "Rotacione rótulos para legibilidade: plt.xticks(rotation=45).",
                                    "Ajuste o locator para intervalos adequados: mdates.MonthLocator() para séries mensais.",
                                    "Atualize o gráfico com plt.gcf().autofmt_xdate()."
                                  ],
                                  "verification": "Verifique se as datas nos eixos aparecem formatadas (ex: 'Jan 2023') sem sobreposição.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Bibliotecas: matplotlib.dates",
                                    "Dataset com coluna de datas"
                                  ],
                                  "tips": "Para séries longas, use formatação anual; para curtas, diária/mensal.",
                                  "learningObjective": "Aplicar formatação temporal para melhorar a interpretação de séries temporais.",
                                  "commonMistakes": [
                                    "Não rotacionar rótulos causando sobreposição",
                                    "Formato de data incompatível com o índice",
                                    "Ignorar fusos horários em dados globais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adicionar grades e legendas para melhor legibilidade",
                                  "subSteps": [
                                    "Ative grades principais e secundárias: plt.grid(True, alpha=0.3).",
                                    "Crie múltiplas linhas se necessário e adicione legenda: plt.plot(..., label='Série1'); plt.legend().",
                                    "Posicione a legenda: plt.legend(loc='upper right').",
                                    "Ajuste transparência e estilo das grades: plt.grid(axis='both', linestyle='--').",
                                    "Garanta que a legenda não sobreponha dados."
                                  ],
                                  "verification": "Confirme visualmente que grades auxiliam na leitura de valores e legenda identifica séries claramente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código do gráfico anterior",
                                    "Múltiplos datasets para legendas"
                                  ],
                                  "tips": "Use alpha baixo em grades para não distrair dos dados.",
                                  "learningObjective": "Incorporar elementos visuais auxiliares para facilitar a análise exploratória.",
                                  "commonMistakes": [
                                    "Legenda cobrindo picos de dados",
                                    "Grades muito opacas obscurecendo linhas",
                                    "Falta de labels em plots múltiplos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ajustar escalas e destacar variações em séries longas ou curtas",
                                  "subSteps": [
                                    "Defina limites de eixos: plt.xlim(data.index[0], data.index[-1]); plt.ylim(min_val, max_val).",
                                    "Use escalas logarítmicas para variações amplas: plt.yscale('log').",
                                    "Adicione sombreamento para períodos chave: plt.axvspan(start_date, end_date, alpha=0.2, color='yellow').",
                                    "Aplique zoom ou twin axes para séries com escalas díspares.",
                                    "Salve e revise o gráfico final: plt.savefig('grafico_personalizado.png')."
                                  ],
                                  "verification": "Teste com séries longa/curta: variações devem ser destacadas sem distorção.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Datasets de séries longa (5+ anos) e curta (1 ano)",
                                    "Código completo anterior"
                                  ],
                                  "tips": "Escala log para dados com ordens de magnitude diferentes; linear para variações relativas pequenas.",
                                  "learningObjective": "Otimizar escalas para revelar padrões em diferentes comprimentos de séries temporais.",
                                  "commonMistakes": [
                                    "Escala inadequada distorcendo tendências",
                                    "Limites cortando dados importantes",
                                    "Sombreamento excessivo confundindo o gráfico"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dados de temperaturas diárias de uma cidade de 2020-2023 (CSV com colunas 'data' e 'temp'), crie um gráfico de linha personalizado: título 'Temperatura Média Diária - Cidade X (2020-2023)', eixo x formatado como 'MMM YYYY', grades cinza claras, legenda se múltiplas estações, escala linear com ylim ajustado para min/max +5%, e sombreamento no verão 2022 para destacar pico de calor.",
                              "finalVerifications": [
                                "Título e rótulos de eixos são descritivos e formatados corretamente.",
                                "Eixo temporal exibe datas legíveis sem sobreposição.",
                                "Grades e legendas melhoram a legibilidade sem distrair.",
                                "Escalas adequadas destacam variações em séries longas/curtas.",
                                "Gráfico salvo é profissional e interpretável por terceiros.",
                                "Nenhum erro comum presente (ex: distorções ou sobreposições)."
                              ],
                              "assessmentCriteria": [
                                "Clareza visual: elementos personalizados facilitam interpretação imediata (30%).",
                                "Precisão técnica: formatação temporal e escalas corretas (25%).",
                                "Adequação ao contexto: destaca variações relevantes da série (20%).",
                                "Criatividade em destaques: uso eficaz de sombreamento/zoom (15%).",
                                "Código limpo e comentado (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Compreensão de escalas logarítmicas e proporções.",
                                "Programação: Manipulação de dados com pandas e visualização com matplotlib.",
                                "Ciências Ambientais: Análise de séries climáticas ou populacionais.",
                                "Economia: Visualização de tendências econômicas temporais.",
                                "Design Gráfico: Princípios de legibilidade e estética visual."
                              ],
                              "realWorldApplication": "Em análise financeira, personalizar gráficos de preços de ações para identificar tendências e volatilidade; em saúde pública, visualizar casos de doenças ao longo do tempo para prever surtos; ou em marketing, analisar vendas sazonais para otimizar estoques."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.1.3",
                            "name": "Plotar múltiplas séries temporais",
                            "description": "Superpor ou posicionar lado a lado gráficos de linha de múltiplas séries para comparação, ajustando cores, estilos de linha e normalizações quando necessário.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e Importar Dados para Múltiplas Séries Temporais",
                                  "subSteps": [
                                    "Carregue bibliotecas necessárias: pandas, matplotlib.pyplot e numpy.",
                                    "Importe ou gere dados de séries temporais múltiplas (ex: DataFrame com colunas de data e valores para 3-5 séries).",
                                    "Converta a coluna de datas para datetime e defina como índice.",
                                    "Verifique e limpe dados ausentes ou inconsistentes usando dropna() ou interpolate().",
                                    "Crie um dicionário ou lista com nomes das séries para referência."
                                  ],
                                  "verification": "Execute df.head() e df.info() para confirmar que os dados estão indexados por data e múltiplas colunas numéricas estão prontas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python com pandas, matplotlib, numpy instalados",
                                    "Dataset de exemplo (ex: vendas mensais de produtos)"
                                  ],
                                  "tips": "Use pd.read_csv(parse_dates=['date']) para importar datas automaticamente.",
                                  "learningObjective": "Entender como estruturar dados temporais para plotting múltiplo.",
                                  "commonMistakes": [
                                    "Não converter datas para datetime",
                                    "Ignorar valores NaN que distorcem linhas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar Plot Básico com Múltiplas Séries Superpostas ou Lado a Lado",
                                  "subSteps": [
                                    "Inicie figura com plt.figure(figsize=(12,6)) ou plt.subplots().",
                                    "Para superposição: use plt.plot(df.index, df['serie1'], label='Serie1'); repita para outras séries.",
                                    "Para lado a lado: use fig, axs = plt.subplots(1,3); axs[0].plot(df.index, df['serie1']); etc.",
                                    "Adicione labels: plt.xlabel('Data'), plt.ylabel('Valor'), plt.title('Comparação de Séries').",
                                    "Inclua legenda com plt.legend()."
                                  ],
                                  "verification": "Exiba o plot com plt.show() e confirme que todas as séries são visíveis e legendadas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Jupyter Notebook ou script Python",
                                    "Dados preparados do Step 1"
                                  ],
                                  "tips": "Use ax.plot() em subplots para consistência.",
                                  "learningObjective": "Dominar plotting básico de múltiplas séries em configurações superposta ou facetada.",
                                  "commonMistakes": [
                                    "Esquecer labels ou legendas",
                                    "Figuras muito pequenas para múltiplas linhas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Personalizar Cores, Estilos de Linha e Normalizações",
                                  "subSteps": [
                                    "Defina paleta de cores com plt.cm.Set1 ou cores manuais: colors=['red','blue','green'].",
                                    "Ajuste estilos: linewidth=2, linestyle='--' para séries secundárias.",
                                    "Para normalização: crie df_normalized = (df - df.min()) / (df.max() - df.min()); plote normalized.",
                                    "Aplique twinx() para escalas diferentes se séries tiverem unidades variadas.",
                                    "Teste visibilidade rotacionando xticks com plt.xticks(rotation=45)."
                                  ],
                                  "verification": "Compare plots antes/depois: linhas distinguíveis, escalas apropriadas sem sobreposição caótica.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação matplotlib para styles e colormaps"
                                  ],
                                  "tips": "Use cycle de cores com itertools para automação.",
                                  "learningObjective": "Aplicar customizações para melhorar legibilidade em comparações.",
                                  "commonMistakes": [
                                    "Cores similares causando confusão",
                                    "Normalizar sem informar no título/legenda"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar, Salvar e Interpretar o Gráfico",
                                  "subSteps": [
                                    "Adicione grid: plt.grid(True, alpha=0.3).",
                                    "Ajuste layout: plt.tight_layout().",
                                    "Salve com plt.savefig('multi_series.png', dpi=300, bbox_inches='tight').",
                                    "Anote insights iniciais: ex: 'Serie A cresce mais rápido após 2020'.",
                                    "Teste responsividade redimensionando figura."
                                  ],
                                  "verification": "Arquivo salvo abre corretamente; gráfico é legível em PDF/PNG.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Diretório para salvar imagens"
                                  ],
                                  "tips": "Use %matplotlib inline em Jupyter para previews rápidos.",
                                  "learningObjective": "Produzir gráficos profissionais prontos para relatórios.",
                                  "commonMistakes": [
                                    "Grid ausente dificultando leitura",
                                    "Salvar sem alta resolução"
                                  ]
                                }
                              ],
                              "practicalExample": "Compare vendas mensais de smartphones, tablets e wearables de 2019-2023: superponha séries normalizadas para identificar picos sazonais e tendências de crescimento relativo.",
                              "finalVerifications": [
                                "Todas as séries são plotadas corretamente sem erros de indexação.",
                                "Cores e estilos distinguem claramente cada série.",
                                "Legenda, títulos e labels estão presentes e informativos.",
                                "Normalização aplicada quando escalas diferem, com indicação no gráfico.",
                                "Gráfico salvo em alta qualidade e legível.",
                                "Comparação visual permite insights rápidos (ex: qual série lidera)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na preparação de dados (sem NaNs ou erros de tipo).",
                                "Escolha apropriada de layout (superposto vs. lado a lado baseado em dados).",
                                "Customizações eficazes melhoram clareza (cores/estilos/notas).",
                                "Uso correto de normalização ou escalas duplas quando necessário.",
                                "Profissionalismo: grid, layout, salvamento e interpretação.",
                                "Eficiência: código limpo, reutilizável com funções."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Normalização e escalonamento de funções.",
                                "Economia: Análise de tendências de mercado e forecasting.",
                                "Ciência Ambiental: Comparação de séries climáticas (ex: temperaturas vs. CO2).",
                                "Programação: Manipulação de DataFrames e visualização avançada."
                              ],
                              "realWorldApplication": "Em finanças, comparar retornos de ações (ex: AAPL vs. GOOG) para portfólios; em saúde pública, sobrepor curvas de infecções por variantes de vírus para políticas de controle."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.1.1.2",
                        "name": "Decomposição Gráfica de Séries Temporais",
                        "description": "Técnicas para decompor uma série temporal em componentes aditivos ou multiplicativos (tendência, sazonalidade e resíduo) e visualizá-los em painéis gráficos separados.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.1.2.1",
                            "name": "Realizar decomposição aditiva",
                            "description": "Aplicar decomposição aditiva em uma série temporal sazonal usando funções como seasonal_decompose() em Python (statsmodels) ou decompose() em R, gerando os componentes tendência, sazonal e resíduo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente de programação e os dados da série temporal",
                                  "subSteps": [
                                    "Instalar e importar bibliotecas necessárias: statsmodels, pandas, matplotlib para Python; forecast para R.",
                                    "Carregar um dataset de série temporal sazonal, como AirPassengers (built-in em ambos).",
                                    "Verificar e preparar o índice temporal: converter para datetime em Python e ts com frequency em R.",
                                    "Visualizar a série original com plot() para confirmar sazonalidade.",
                                    "Definir o período sazonal (ex: period=12 para dados mensais)."
                                  ],
                                  "verification": "Dados carregados corretamente, plot da série original exibido sem erros e frequência confirmada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python 3.x com pandas, statsmodels, matplotlib instalados",
                                    "R/RStudio com forecast",
                                    "Dataset AirPassengers ou similar CSV"
                                  ],
                                  "tips": "Use datasets built-in para evitar problemas de download; sempre cheque freqtime() em R ou .index em Python.",
                                  "learningObjective": "Configurar ambiente e dados para decomposição de séries temporais sazonais.",
                                  "commonMistakes": [
                                    "Índice não convertido para datetime/ts",
                                    "Frequência sazonal não definida (ex: period=1)",
                                    "Dados com valores NA não tratados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar decomposição aditiva em Python com seasonal_decompose()",
                                  "subSteps": [
                                    "Importar from statsmodels.tsa.seasonal import seasonal_decompose.",
                                    "Aplicar: result = seasonal_decompose(serie, model='additive', period=12).",
                                    "Extrair componentes: trend = result.trend, seasonal = result.seasonal, resid = result.resid.",
                                    "Gerar visualização: result.plot() ou plots separados com matplotlib.",
                                    "Salvar componentes em DataFrame para análise adicional."
                                  ],
                                  "verification": "Gráficos de 4 painéis (observed, trend, seasonal, residual) gerados e componentes extraídos sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Jupyter Notebook ou script Python",
                                    "Dataset preparado do Step 1"
                                  ],
                                  "tips": "Teste com model='additive' primeiro; use extrapolate_trend='freq' se trend tiver NA iniciais.",
                                  "learningObjective": "Aplicar corretamente a função seasonal_decompose para extrair componentes aditivos.",
                                  "commonMistakes": [
                                    "model='multiplicative' usado em dados aditivos",
                                    "period incorreto causando falha",
                                    "Não lidar com NA em trend"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar decomposição aditiva em R com decompose()",
                                  "subSteps": [
                                    "Carregar library(forecast) ou usar base R.",
                                    "Converter dados para ts: serie_ts <- ts(serie, frequency=12).",
                                    "Aplicar: decomp <- decompose(serie_ts, type='additive').",
                                    "Extrair componentes: decomp$trend, decomp$seasonal, decomp$random.",
                                    "Visualizar: plot(decomp)."
                                  ],
                                  "verification": "Plot da decomposição em R exibido com 4 painéis e componentes acessíveis.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "RScript ou RStudio",
                                    "Dataset ts do Step 1"
                                  ],
                                  "tips": "frequency deve matching o dados (12 mensal); use na.rm=TRUE se necessário.",
                                  "learningObjective": "Implementar decomposição aditiva em R usando decompose().",
                                  "commonMistakes": [
                                    "Objeto não classe ts",
                                    "type='multiplicative' em vez de additive",
                                    "frequency errada"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar componentes, validar e comparar resultados",
                                  "subSteps": [
                                    "Analisar tendência: identificar se crescente, decrescente ou estável.",
                                    "Examinar sazonal: descrever padrões repetitivos (picos/vales).",
                                    "Verificar resíduos: checar se aleatórios (sem tendências/sazonalidade via plot/acf).",
                                    "Reconstruir série: somar componentes e comparar com original (diferença <1%).",
                                    "Comparar saídas Python vs R para consistência."
                                  ],
                                  "verification": "Relatório com interpretações, plots de resíduos e validação de soma escrito.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Gráficos e componentes dos Steps 2-3",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Resíduos ideais são ruído branco; use acf() para detectar padrões restantes.",
                                  "learningObjective": "Interpretar e validar decomposição aditiva para insights acionáveis.",
                                  "commonMistakes": [
                                    "Ignorar autocorrelação em resíduos",
                                    "Não verificar soma dos componentes",
                                    "Interpretação errada de sazonalidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando o dataset AirPassengers (passageiros aéreos mensais 1949-1960), aplique decomposição aditiva (period=12) em Python e R para extrair tendência crescente, sazonalidade de verão e resíduos aleatórios, visualizando e validando a reconstrução.",
                              "finalVerifications": [
                                "Gráficos de decomposição gerados corretamente em Python e R.",
                                "Componentes (tendência, sazonal, resíduo) extraídos e plotados.",
                                "Soma dos componentes reconstrói a série original com erro mínimo.",
                                "Resíduos visualmente aleatórios sem padrões evidentes.",
                                "Interpretação escrita identifica tendência crescente e sazonalidade anual.",
                                "Resultados consistentes entre Python e R."
                              ],
                              "assessmentCriteria": [
                                "Configuração precisa de period/frequency e model='additive'.",
                                "Execução sem erros e plots completos em ambas linguagens.",
                                "Extração correta e manipulação dos componentes.",
                                "Interpretação precisa dos padrões em cada componente.",
                                "Validação robusta via resíduos e reconstrução.",
                                "Comparação entre ferramentas demonstrando compreensão."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelagem de funções lineares e periódicas.",
                                "Programação: Manipulação de objetos temporais em Python/R.",
                                "Economia: Análise de tendências sazonais em vendas/finanças.",
                                "Ciência de Dados: Exploração univariada e diagnóstico de modelos.",
                                "Estatística: Testes de estacionariedade em resíduos."
                              ],
                              "realWorldApplication": "Previsão de demanda sazonal em varejo (ex: estoque para Black Friday), análise de tráfego web para marketing, modelagem climática para agricultura e previsão de vendas em e-commerce."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.2.2",
                            "name": "Visualizar componente de tendência",
                            "description": "Plotar isoladamente o componente de tendência extraído da decomposição, interpretando sua direção (crescente, decrescente ou estável) e suavidade ao longo do tempo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e isolar o componente de tendência",
                                  "subSteps": [
                                    "Instalar e importar bibliotecas necessárias: pandas, matplotlib e statsmodels.",
                                    "Carregar o dataset da série temporal já decomposta.",
                                    "Extrair o componente de tendência do objeto de decomposição (ex: result.trend).",
                                    "Verificar integridade dos dados: ausência de NaN e comprimento adequado.",
                                    "Definir índices de tempo corretos para o eixo x."
                                  ],
                                  "verification": "Executar df_trend.head() e df_trend.info() sem erros e com dados válidos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python/Jupyter Notebook",
                                    "Bibliotecas: pandas, matplotlib, statsmodels",
                                    "Dataset de série temporal decomposta"
                                  ],
                                  "tips": [
                                    "Salve o componente em um DataFrame separado para facilitar manipulações.",
                                    "Use pd.to_datetime() para índices temporais precisos."
                                  ],
                                  "learningObjective": "Configurar um ambiente pronto e dados isolados para visualização precisa.",
                                  "commonMistakes": [
                                    "Importar bibliotecas incorretas.",
                                    "Ignorar valores NaN no componente.",
                                    "Usar índices errados, confundindo o eixo temporal."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Plotar o gráfico isolado do componente de tendência",
                                  "subSteps": [
                                    "Criar figura e eixo com plt.figure() e plt.subplot().",
                                    "Plotar a linha do componente de tendência usando plt.plot(data.index, data.values).",
                                    "Adicionar rótulos: título 'Componente de Tendência', eixos x ('Tempo') e y ('Valor').",
                                    "Configurar grade e limites de eixos para melhor visualização.",
                                    "Exibir o gráfico com plt.show() ou plt.savefig()."
                                  ],
                                  "verification": "Gráfico gerado isoladamente, sem outros componentes, legível e com labels corretos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Biblioteca matplotlib",
                                    "DataFrame do componente de tendência"
                                  ],
                                  "tips": [
                                    "Use cores contrastantes e linewidth=2 para destaque.",
                                    "Ajuste figsize para visualização em tela cheia."
                                  ],
                                  "learningObjective": "Gerar uma visualização gráfica clara e profissional do componente de tendência.",
                                  "commonMistakes": [
                                    "Plotar múltiplos componentes por engano.",
                                    "Esquecer labels, tornando o gráfico ambíguo.",
                                    "Escala inadequada nos eixos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar a direção da tendência",
                                  "subSteps": [
                                    "Observar inclinação geral da linha: crescente (positiva), decrescente (negativa) ou estável (próxima de zero).",
                                    "Calcular coeficiente angular simples via regressão linear (scipy.stats.linregress).",
                                    "Identificar pontos de mudança na direção ao longo do tempo.",
                                    "Anotar no gráfico linhas de tendência ou setas indicativas.",
                                    "Documentar interpretação em texto: 'Tendência crescente de X% ao ano'."
                                  ],
                                  "verification": "Relatório escrito confirmando direção com evidência numérica ou visual.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Biblioteca scipy.stats",
                                    "Gráfico plotado"
                                  ],
                                  "tips": [
                                    "Compare com linha horizontal para estabilidade.",
                                    "Use zoom em períodos suspeitos."
                                  ],
                                  "learningObjective": "Identificar e quantificar a direção da tendência de forma objetiva.",
                                  "commonMistakes": [
                                    "Confundir flutuações sazonais com tendência.",
                                    "Ignorar escala temporal longa.",
                                    "Interpretar subjetivamente sem cálculo."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar a suavidade da tendência e finalizar análise",
                                  "subSteps": [
                                    "Analisar variações locais: suavidade indicada por curvas lisas vs. oscilações.",
                                    "Aplicar suavização adicional (ex: rolling mean) se necessário para confirmação.",
                                    "Comparar suavidade com componente residual para validação.",
                                    "Concluir sobre estabilidade e implicações (ex: aceleração da tendência).",
                                    "Salvar gráfico anotado e relatório de interpretação."
                                  ],
                                  "verification": "Análise documentada com descrição qualitativa e quantitativa da suavidade.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Biblioteca pandas para rolling",
                                    "Gráfico anterior"
                                  ],
                                  "tips": [
                                    "Suavidade alta sugere tendência dominante; baixa indica ruído.",
                                    "Use múltiplas janelas de rolling para testes."
                                  ],
                                  "learningObjective": "Avaliar qualidade e confiabilidade da tendência visualizada.",
                                  "commonMistakes": [
                                    "Confundir suavidade com sazonalidade.",
                                    "Não validar com métricas quantitativas.",
                                    "Omitir contexto temporal na análise."
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dados mensais de vendas de uma loja (disponíveis em datasets como 'airpassengers' adaptado), extraia o componente de tendência via decomposição STL, plote isoladamente, interprete como crescente suave devido ao crescimento econômico, com inclinação positiva de 5% ao ano.",
                              "finalVerifications": [
                                "Gráfico isolado do componente de tendência exibido corretamente.",
                                "Direção (crescente/decrescente/estável) identificada com justificativa.",
                                "Suavidade descrita qualitativamente e visualmente.",
                                "Anotações no gráfico facilitam interpretação.",
                                "Relatório final resume achados sem ambiguidades.",
                                "Código reproduzível gera o mesmo resultado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na extração e plotagem do componente (sem erros de dados).",
                                "Clareza visual do gráfico (labels, escalas adequadas).",
                                "Correção na interpretação da direção (suportada por evidências).",
                                "Análise detalhada de suavidade com métodos apropriados.",
                                "Documentação completa e acionável.",
                                "Eficiência temporal e uso otimizado de recursos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Regressão linear e funções contínuas.",
                                "Economia: Análise de tendências macroeconômicas.",
                                "Geociências: Tendências climáticas em séries temporais ambientais.",
                                "Programação: Manipulação de dados e visualização com Python."
                              ],
                              "realWorldApplication": "Em empresas de varejo para prever crescimento de vendas e planejar estoques; em meteorologia para monitorar aquecimento global via tendências de temperatura; em finanças para detectar ciclos econômicos em índices bursáteis."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.2.3",
                            "name": "Visualizar componente sazonal",
                            "description": "Gerar e plotar o gráfico do componente sazonal, analisando padrões cíclicos repetitivos e sua amplitude em diferentes períodos da série.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a série temporal e extrair o componente sazonal",
                                  "subSteps": [
                                    "Carregar o conjunto de dados da série temporal usando pandas.",
                                    "Verificar e limpar dados ausentes ou inconsistentes.",
                                    "Aplicar decomposição da série temporal (ex: seasonal_decompose do statsmodels).",
                                    "Extrair o componente sazonal do objeto de decomposição.",
                                    "Salvar o componente sazonal em um DataFrame separado."
                                  ],
                                  "verification": "Componente sazonal extraído corretamente e salvo em DataFrame, sem erros de NaN.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python com pandas, statsmodels e numpy",
                                    "Notebook Jupyter",
                                    "Dataset de série temporal (ex: AirPassengers.csv)"
                                  ],
                                  "tips": "Use freq='M' para dados mensais ao criar a série; teste com period=12 para sazonalidade anual.",
                                  "learningObjective": "Compreender e aplicar decomposição aditiva/multiplicativa para isolar o componente sazonal.",
                                  "commonMistakes": [
                                    "Não definir a frequência correta da série",
                                    "Ignorar dados ausentes antes da decomposição",
                                    "Confundir modelo aditivo com multiplicativo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar e plotar o gráfico do componente sazonal",
                                  "subSteps": [
                                    "Importar matplotlib ou seaborn para visualização.",
                                    "Configurar o plot com eixos apropriados (tempo no x, valor sazonal no y).",
                                    "Plotar a linha do componente sazonal, destacando múltiplos ciclos.",
                                    "Adicionar títulos, labels e grid para clareza.",
                                    "Exibir ou salvar o gráfico."
                                  ],
                                  "verification": "Gráfico gerado com eixos rotulados, múltiplos ciclos visíveis e sem erros de plotagem.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python com matplotlib ou seaborn",
                                    "DataFrame do componente sazonal do Step 1"
                                  ],
                                  "tips": "Use figsize=(12,6) para melhor visualização; plote vários anos para ver repetição.",
                                  "learningObjective": "Criar visualizações claras e profissionais do componente sazonal.",
                                  "commonMistakes": [
                                    "Escala inadequada nos eixos",
                                    "Não mostrar múltiplos períodos",
                                    "Falta de legendas ou títulos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar padrões cíclicos repetitivos no gráfico",
                                  "subSteps": [
                                    "Observar a repetição do padrão ao longo dos períodos.",
                                    "Medir o comprimento do ciclo (ex: 12 meses para anual).",
                                    "Anotar picos e vales consistentes em cada ciclo.",
                                    "Comparar ciclos adjacentes para confirmar repetitividade.",
                                    "Documentar observações em comentários ou relatório."
                                  ],
                                  "verification": "Relatório com descrição de pelo menos 3 ciclos repetitivos e seus picos/vales.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Gráfico gerado no Step 2",
                                    "Ferramenta de anotação (ex: Jupyter cells)"
                                  ],
                                  "tips": "Amplie seções do gráfico para detalhes finos; use zoom em notebooks.",
                                  "learningObjective": "Reconhecer e descrever padrões cíclicos característicos da sazonalidade.",
                                  "commonMistakes": [
                                    "Confundir ruído com padrão sazonal",
                                    "Ignorar variações pequenas",
                                    "Não quantificar o ciclo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar amplitude da sazonalidade em diferentes períodos",
                                  "subSteps": [
                                    "Calcular amplitude (máx - mín) por ciclo sazonal.",
                                    "Plotar gráfico de amplitude ao longo do tempo.",
                                    "Comparar amplitudes entre períodos iniciais e finais.",
                                    "Interpretar variações (ex: tendência ou anomalias).",
                                    "Concluir sobre estabilidade da sazonalidade."
                                  ],
                                  "verification": "Gráfico de amplitudes gerado e análise escrita com comparações quantitativas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "DataFrame sazonal",
                                    "matplotlib para plot adicional"
                                  ],
                                  "tips": "Use groupby por período para calcular amplitudes; normalize se necessário.",
                                  "learningObjective": "Quantificar e interpretar variações de amplitude sazonal ao longo da série.",
                                  "commonMistakes": [
                                    "Calcular amplitude em toda série sem segmentar",
                                    "Ignorar outliers",
                                    "Não contextualizar variações"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dados mensais de passageiros aéreos (AirPassengers dataset), extraia o componente sazonal com decomposição multiplicativa (period=12), plote 3-5 anos de ciclos, identifique picos em julho/dezembro e compare amplitudes entre 1949-1952 vs. 1955-1958, notando aumento gradual.",
                              "finalVerifications": [
                                "Componente sazonal extraído e plotado corretamente com múltiplos ciclos visíveis.",
                                "Padrões cíclicos descritos com picos, vales e período exato.",
                                "Amplitudes calculadas e comparadas entre pelo menos 3 períodos.",
                                "Gráficos claros com labels, títulos e escalas adequadas.",
                                "Análise escrita interpretando repetitividade e variações.",
                                "Código reproduzível sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na extração e plotagem do componente sazonal (30%)",
                                "Qualidade visual e clareza dos gráficos (20%)",
                                "Profundidade na identificação de padrões cíclicos (20%)",
                                "Análise quantitativa de amplitudes e interpretações (20%)",
                                "Documentação completa e código limpo (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelos de funções periódicas e trigonométricas.",
                                "Programação: Manipulação de dados com pandas e visualização com matplotlib.",
                                "Economia: Análise de sazonalidade em vendas e demandas.",
                                "Ciência de Dados: Pré-processamento e decomposição de séries.",
                                "Estatística: Detecção de componentes em processos estocásticos."
                              ],
                              "realWorldApplication": "Em meteorologia para visualizar ciclos sazonais de temperatura/pluviosidade e prever eventos climáticos; no varejo para ajustar estoques em picos de vendas natalinos/verão; em finanças para modelar sazonalidade em ações de commodities agrícolas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.2.4",
                            "name": "Visualizar resíduos e análise gráfica",
                            "description": "Plotar os resíduos da decomposição em gráfico de linha ou nuvem de pontos, verificando aleatoriedade, heterocedasticidade e presença de outliers graficamente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os dados dos resíduos da decomposição",
                                  "subSteps": [
                                    "Carregue o dataset da série temporal já decomposta (trend, seasonal, residual).",
                                    "Extraia a coluna de resíduos (residuals) em um DataFrame ou vetor.",
                                    "Verifique valores ausentes (NaN) e trate-os removendo ou interpolando.",
                                    "Crie um índice temporal alinhado com os resíduos.",
                                    "Salve os resíduos em uma variável dedicada para plotting."
                                  ],
                                  "verification": "Confirme que os resíduos estão em um array ou Series sem NaNs e com índice temporal correto via print ou shape.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Python (pandas, numpy); dataset de série temporal decomposta (ex: AirPassengers ou vendas mensais).",
                                  "tips": "Use df['residuals'] = decomposition.resid para extrair diretamente do modelo.",
                                  "learningObjective": "Entender como isolar resíduos limpos para análise gráfica.",
                                  "commonMistakes": "Esquecer de tratar NaNs, levando a erros no plot; usar resíduos não alinhados com tempo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Plotar os resíduos em gráfico de linha e nuvem de pontos",
                                  "subSteps": [
                                    "Importe bibliotecas: matplotlib.pyplot e seaborn.",
                                    "Crie gráfico de linha: plt.plot(time_index, residuals).",
                                    "Crie scatter plot: plt.scatter(fitted_values, residuals) ou vs tempo.",
                                    "Adicione títulos, labels (eixo x: Tempo, y: Resíduos) e grid.",
                                    "Exiba ou salve os gráficos com plt.show() ou plt.savefig()."
                                  ],
                                  "verification": "Visualize os dois gráficos gerados, confirmando legibilidade e escalas adequadas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Python (matplotlib, seaborn, pandas); resíduos preparados.",
                                  "tips": "Use seaborn.residplot() para scatter automatizado com linha de tendência.",
                                  "learningObjective": "Dominar visualização gráfica de resíduos para inspeção inicial.",
                                  "commonMistakes": "Escalas inadequadas nos eixos, ocultando padrões; esquecer labels."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar aleatoriedade nos resíduos graficamente",
                                  "subSteps": [
                                    "No gráfico de linha vs tempo, procure por padrões lineares ou cíclicos.",
                                    "Verifique ausência de autocorrelação visual (sem runs longos positivos/negativos).",
                                    "Gere correlograma (ACF plot) com statsmodels.tsa.stattools.plot_acf(residuals).",
                                    "Confirme que barras do ACF estão dentro de bandas de confiança.",
                                    "Anote observações sobre random walk ou white noise aparente."
                                  ],
                                  "verification": "ACF mostra barras insignificantes após lag 0; linha sem tendências óbvias.",
                                  "estimatedTime": "12 minutos",
                                  "materials": "Python (statsmodels); gráficos anteriores.",
                                  "tips": "Zoom no gráfico para detectar padrões sutis em lags iniciais.",
                                  "learningObjective": "Identificar visualmente se resíduos se comportam como ruído branco.",
                                  "commonMistakes": "Ignorar lags iniciais no ACF; confundir sazonalidade residual com aleatoriedade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar heterocedasticidade e detectar outliers",
                                  "subSteps": [
                                    "No scatter residuals vs fitted, busque padrões de funil (variância crescente/diminuindo).",
                                    "Use gráfico de resíduos vs tempo para dispersão variável.",
                                    "Identifique outliers: pontos distantes >2-3 desvios padrão.",
                                    "Calcule desvios padronizados e marque pontos |z| > 2.5.",
                                    "Documente posições e magnitudes dos outliers detectados."
                                  ],
                                  "verification": "Ausência de funil no scatter; lista de 2-5 outliers potenciais anotados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Python (matplotlib, scipy.stats para z-score); gráficos de resíduos.",
                                  "tips": "Adicione linha horizontal y=0 e bandas de confiança (±2σ) no plot.",
                                  "learningObjective": "Diagnosticar variância não constante e anomalias graficamente.",
                                  "commonMistakes": "Confundir heterocedasticidade com outliers isolados; não padronizar resíduos."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar e interpretar a análise gráfica",
                                  "subSteps": [
                                    "Compile screenshots ou exports dos gráficos em relatório.",
                                    "Escreva conclusões: 'Resíduos aleatórios? Heterocedásticos? Outliers?'",
                                    "Sugira próximos passos (ex: transformação log se heterocedástico).",
                                    "Compare com critérios teóricos de resíduos ideais.",
                                    "Salve análise em notebook Jupyter ou PDF."
                                  ],
                                  "verification": "Relatório com gráficos e conclusões claras gerado.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Jupyter Notebook; gráficos gerados.",
                                  "tips": "Use markdown cells para anotações interpretativas ao lado dos plots.",
                                  "learningObjective": "Sintetizar diagnósticos gráficos em insights acionáveis.",
                                  "commonMistakes": "Conclusões vagas sem referência aos gráficos; ignorar contexto da série."
                                }
                              ],
                              "practicalExample": "Usando dados de passageiros aéreos (AirPassengers), após decomposição STL, plote resíduos vs tempo: observe aleatoriedade (sem padrões), ausência de funil (homocedástico) e 2 outliers em picos de feriados (mar/1961, jul/1961).",
                              "finalVerifications": [
                                "Gráficos de linha e scatter plotados corretamente com labels.",
                                "Aleatoriedade confirmada via ausência de padrões e ACF insignificante.",
                                "Heterocedasticidade ausente (sem funil nos plots).",
                                "Outliers identificados e quantificados (posição e magnitude).",
                                "Relatório com interpretações e sugestões gerado.",
                                "Código reproduzível sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos plots (eixos, labels, escalas): 20%",
                                "Detecção correta de aleatoriedade (ACF + visual): 25%",
                                "Análise de heterocedasticidade e outliers: 25%",
                                "Qualidade da interpretação e relatório: 20%",
                                "Eficiência do código e tratamento de dados: 10%"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estatística descritiva e testes gráficos (ACF).",
                                "Programação: Manipulação de dados com pandas e visualização (matplotlib).",
                                "Ciência de Dados: Diagnóstico de modelos em machine learning.",
                                "Economia: Análise de séries temporais em forecasting econômico."
                              ],
                              "realWorldApplication": "Em previsão de demanda de varejo, análise de resíduos detecta feriados não modelados como outliers, permitindo ajustes no modelo para maior precisão em vendas futuras; ou em monitoramento IoT, identifica falhas em sensores via padrões não aleatórios."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.2",
                    "name": "Análise de Tendência e Sazonalidade",
                    "description": "Identificação e extração de componentes de tendência e padrões sazonais por meio de métodos exploratórios.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.2.1",
                        "name": "Tendência em Séries Temporais",
                        "description": "A tendência representa a componente de longo prazo em uma série temporal, indicando a direção geral dos dados ao longo do tempo, como aumento, diminuição ou estabilidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.1.1",
                            "name": "Identificar tendência visualmente",
                            "description": "Reconhecer padrões de tendência em gráficos de séries temporais, diferenciando crescimento linear, exponencial ou cíclico por meio de plotagens básicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Tipos Básicos de Tendências",
                                  "subSteps": [
                                    "Defina tendência linear: mudança constante e reta no gráfico ao longo do tempo.",
                                    "Defina tendência exponencial: aceleração no crescimento ou declínio, formando curva.",
                                    "Defina tendência cíclica: padrões repetitivos de altos e baixos em ciclos regulares.",
                                    "Compare exemplos visuais de cada tipo em gráficos prontos.",
                                    "Note diferenças chave: linear (reta), exponencial (curva acentuada), cíclico (ondas)."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo as diferenças entre os três tipos com esboços simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Gráficos de exemplo de tendências linear, exponencial e cíclica (impressos ou online)",
                                    "Caneta e papel para esboços"
                                  ],
                                  "tips": "Use setas para indicar direção e velocidade da mudança em cada esboço.",
                                  "learningObjective": "Diferenciar conceitualmente tendências linear, exponencial e cíclica por características visuais.",
                                  "commonMistakes": [
                                    "Confundir cíclico com ruído aleatório",
                                    "Ignorar a escala dos eixos ao julgar linearidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar e Plotar a Série Temporal",
                                  "subSteps": [
                                    "Obtenha um dataset de série temporal (ex: valores mensais de vendas ou temperaturas).",
                                    "Selecione uma ferramenta acessível como Excel, Google Sheets ou Python com Matplotlib.",
                                    "Crie um gráfico de linha: tempo (meses/anos) no eixo X, valores no eixo Y.",
                                    "Adicione títulos, labels e grid para melhor visualização.",
                                    "Ajuste escalas para evitar distorções visuais."
                                  ],
                                  "verification": "O gráfico é legível, com eixos rotulados e sem erros de plotagem; salve ou tire print.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Dataset exemplo (CSV com 24-60 pontos de dados)",
                                    "Excel/Google Sheets ou Jupyter Notebook com Matplotlib"
                                  ],
                                  "tips": "Comece com dados reais ou simulados; zoom no gráfico para detalhes finos.",
                                  "learningObjective": "Produzir um gráfico de linha claro e corretamente escalado para análise visual.",
                                  "commonMistakes": [
                                    "Escala inadequada que mascara tendências",
                                    "Plotar valores errados ou eixos trocados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Visualmente Padrões de Tendência",
                                  "subSteps": [
                                    "Examine a direção geral: subindo, descendo ou oscilando.",
                                    "Para linear: verifique se uma linha reta aproxima bem os pontos médios.",
                                    "Para exponencial: observe se a curva acelera (teste log(Y) vs X para linearizar).",
                                    "Para cíclico: identifique repetições de picos e vales com período similar.",
                                    "Anote características: inclinação constante, aceleração ou periodicidade."
                                  ],
                                  "verification": "Marque no gráfico a tendência identificada e justifique com 3 observações visuais.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Gráfico plotado do Step 2",
                                    "Transparência ou ferramenta de desenho digital para sobrepor linhas"
                                  ],
                                  "tips": "Desenhe manualmente linhas de tendência para 'sentir' o padrão.",
                                  "learningObjective": "Reconhecer e classificar padrões visuais como linear, exponencial ou cíclico.",
                                  "commonMistakes": [
                                    "Focar só em pontos iniciais/finais",
                                    "Confundir sazonalidade curta com cíclico longo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Confirmar e Documentar a Identificação",
                                  "subSteps": [
                                    "Compare com múltiplos gráficos de referência para validar.",
                                    "Descreva por que não é outro tipo (ex: 'não exponencial pois sem aceleração').",
                                    "Teste suavização simples (média móvel) para destacar tendência.",
                                    "Registre conclusão com evidências visuais (anotações ou setas).",
                                    "Discuta limitações visuais e necessidade de métodos quantitativos."
                                  ],
                                  "verification": "Produza um relatório curto (1 página) com gráfico anotado e explicação da tendência.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráficos de referência",
                                    "Ferramenta de edição de imagem ou Word para anotações"
                                  ],
                                  "tips": "Use cores: azul para linear, vermelho para exponencial, verde para cíclico.",
                                  "learningObjective": "Validar identificação de tendência com justificativa robusta e autocrítica.",
                                  "commonMistakes": [
                                    "Sobreconfiança sem comparação",
                                    "Ignorar outliers que alteram percepção"
                                  ]
                                }
                              ],
                              "practicalExample": "Baixe dados mensais de preços de ações (ex: AAPL de 2020-2023). Plote em Excel, observe aceleração inicial (exponencial durante pandemia), transição para linear; anote picos cíclicos semanais suavizados.",
                              "finalVerifications": [
                                "Plotou corretamente pelo menos 3 séries temporais diferentes.",
                                "Identificou com precisão tendências em exemplos mistos (linear, exponencial, cíclico).",
                                "Justificou escolhas com pelo menos 3 características visuais por gráfico.",
                                "Diferenciou corretamente entre tipos em relatório anotado.",
                                "Aplicou suavização básica para confirmar tendência dominante.",
                                "Reconheceu limitações da análise visual."
                              ],
                              "assessmentCriteria": [
                                "Precisão na classificação de tendências (acertos em 90% dos casos).",
                                "Qualidade visual dos gráficos (labels, escalas corretas).",
                                "Profundidade das justificativas visuais (detalhes específicos).",
                                "Capacidade de diferenciação entre tipos semelhantes.",
                                "Clareza no relatório final com anotações.",
                                "Uso adequado de ferramentas e materiais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Reconhecimento de funções lineares e exponenciais em gráficos.",
                                "Economia: Análise de tendências de mercado e previsão de vendas.",
                                "Ciências Ambientais: Identificação de tendências climáticas em dados de temperatura.",
                                "Programação: Visualização de dados com bibliotecas como Matplotlib ou ggplot.",
                                "História/Geografia: Tendências demográficas ou econômicas em séries históricas."
                              ],
                              "realWorldApplication": "Em finanças, identificar tendências exponenciais em crescimento de criptomoedas para timing de investimentos; em saúde pública, detectar tendências lineares em casos de doenças para alocação de recursos; em marketing, reconhecer ciclos sazonais em vendas para campanhas direcionadas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.1.2",
                            "name": "Aplicar suavização por médias móveis",
                            "description": "Calcular e aplicar médias móveis simples ou ponderadas para extrair a componente de tendência, removendo flutuações de curto prazo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Médias Móveis",
                                  "subSteps": [
                                    "Defina média móvel simples (SMA) como a média aritmética de um número fixo de observações consecutivas.",
                                    "Explique média móvel ponderada (WMA) atribuindo pesos decrescentes aos dados mais antigos.",
                                    "Identifique o propósito: suavizar ruído de curto prazo para revelar tendência.",
                                    "Discuta escolha da janela (k): pequena para capturar mudanças rápidas, grande para tendência suave.",
                                    "Compare SMA e WMA com exemplos numéricos simples."
                                  ],
                                  "verification": "Resuma em suas palavras as diferenças entre SMA e WMA, com um exemplo de 3 pontos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel ou editor de texto",
                                    "Calculadora ou planilha (Excel/Google Sheets)"
                                  ],
                                  "tips": "Use analogias como 'média de temperatura diária para clima semanal' para fixar o conceito.",
                                  "learningObjective": "Explicar os princípios de médias móveis e quando usá-las em séries temporais.",
                                  "commonMistakes": [
                                    "Confundir janela móvel com média estática",
                                    "Ignorar perda de dados nas bordas da série"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar e Calcular Média Móvel Simples (SMA)",
                                  "subSteps": [
                                    "Colete uma série temporal de pelo menos 20 observações (ex: vendas mensais).",
                                    "Escolha o tamanho da janela k (ex: 3 ou 5) baseado na frequência de flutuações.",
                                    "Calcule SMA para cada ponto t: SMA_t = (x_{t-k+1} + ... + x_t) / k.",
                                    "Registre os valores em uma tabela, notando os k-1 valores iniciais perdidos.",
                                    "Plote a série original vs. SMA para visualizar suavização."
                                  ],
                                  "verification": "Gere uma tabela com SMA correta para uma série de 10 pontos com k=3.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha (Excel/Google Sheets)",
                                    "Gráfico de linhas para plotagem"
                                  ],
                                  "tips": "Comece com k ímpar para centralizar melhor; use funções como AVERAGE em Excel.",
                                  "learningObjective": "Implementar cálculo manual e automatizado de SMA em dados reais.",
                                  "commonMistakes": [
                                    "Erro aritmético em somas",
                                    "Não ajustar índices corretamente nas bordas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular e Comparar Média Móvel Ponderada (WMA)",
                                  "subSteps": [
                                    "Defina pesos lineares decrescentes: w_i = i / sum(1 a k) para i=1 (mais antigo) a k (recente).",
                                    "Calcule WMA_t = (w1*x_{t-k+1} + ... + wk*x_t) / sum(w).",
                                    "Aplique à mesma série usada na SMA.",
                                    "Compare plots de SMA, WMA e original, notando sensibilidade a dados recentes na WMA.",
                                    "Ajuste pesos se necessário para enfatizar tendência."
                                  ],
                                  "verification": "Calcule WMA para os mesmos 10 pontos com k=3 e compare com SMA.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Planilha avançada com fórmulas ponderadas",
                                    "Software de plotagem (opcional: Python/Matplotlib)"
                                  ],
                                  "tips": "Normalize pesos para soma=1; teste pesos exponenciais como variação.",
                                  "learningObjective": "Dominar WMA e discernir quando preferi-la sobre SMA.",
                                  "commonMistakes": [
                                    "Pesos não normalizados levando a escalas erradas",
                                    "Inverter ordem de pesos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar, Aplicar e Validar a Suavização",
                                  "subSteps": [
                                    "Subtraia a média móvel da original para obter resíduos (ruído).",
                                    "Analise se a tendência capturada é linear, quadrática ou outra.",
                                    "Valide: verifique se resíduos têm média zero e variância reduzida.",
                                    "Ajuste k iterativamente para melhor ajuste visual/estatístico.",
                                    "Documente insights: ex. 'tendência crescente de 5% ao mês após suavização'."
                                  ],
                                  "verification": "Produza relatório com plots, resíduos e conclusão sobre tendência.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramentas de plotagem",
                                    "Dados de série temporal real"
                                  ],
                                  "tips": "Use ACF (função de autocorrelação) nos resíduos para validar remoção de curto prazo.",
                                  "learningObjective": "Extrair e interpretar tendência de forma acionável.",
                                  "commonMistakes": [
                                    "Sobre-suavização apagando tendência real",
                                    "k muito pequeno mantendo ruído"
                                  ]
                                }
                              ],
                              "practicalExample": "Em dados de vendas mensais de uma loja (ex: [100, 120, 90, 130, 110, 140]), aplique SMA com k=3: SMA = [-, -, 103.3, 113.3, 110, -]. A tendência revela crescimento estável apesar de flutuações semanais.",
                              "finalVerifications": [
                                "Série suavizada remove >70% das flutuações de curto prazo (visualmente).",
                                "Resíduos têm média próxima de zero e sem autocorrelação significativa.",
                                "Tendência extraída é consistente com domínio do problema.",
                                "Cálculos manuais coincidem com ferramentas automatizadas.",
                                "Plot comparativo mostra clareza na tendência.",
                                "Ajustes de k foram testados e justificados."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de SMA e WMA (erro <1%).",
                                "Escolha apropriada de k com justificativa.",
                                "Interpretação correta da tendência e resíduos.",
                                "Uso eficaz de visualizações para comunicação.",
                                "Identificação e correção de erros comuns.",
                                "Relatório completo com insights acionáveis."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em Python (Pandas rolling()) ou R.",
                                "Economia: Análise de PIB ou inflação para políticas públicas.",
                                "Física: Suavização de sinais em sensores experimentais.",
                                "Machine Learning: Pré-processamento para forecasting."
                              ],
                              "realWorldApplication": "Em finanças, suavizar preços de ações para detectar tendências de investimento; em meteorologia, extrair ciclos climáticos de dados diários para previsões sazonais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.1.3",
                            "name": "Ajustar modelos lineares para tendência",
                            "description": "Realizar regressão linear simples contra o tempo para modelar e quantificar a tendência, interpretando coeficientes e resíduos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a série temporal para modelagem linear",
                                  "subSteps": [
                                    "Carregue o conjunto de dados da série temporal usando pandas.read_csv() ou similar.",
                                    "Converta o índice para um formato temporal sequencial (ex: datas mensais para 0,1,2,...).",
                                    "Plote a série original para visualizar a tendência preliminar com matplotlib.",
                                    "Verifique e trate valores ausentes ou outliers iniciais.",
                                    "Crie uma variável independente 'tempo' como um vetor numérico crescente."
                                  ],
                                  "verification": "Gráfico da série temporal plotado corretamente com eixo tempo visível e sem erros de carregamento.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python",
                                    "pandas",
                                    "matplotlib"
                                  ],
                                  "tips": "Use pd.date_range() para índices temporais precisos; sempre visualize antes de modelar.",
                                  "learningObjective": "Preparar dados temporais limpos e indexados para regressão linear.",
                                  "commonMistakes": [
                                    "Ignorar valores ausentes levando a NaNs no modelo",
                                    "Usar datas como numéricas sem conversão",
                                    "Não plotar a série inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Ajustar o modelo de regressão linear simples",
                                  "subSteps": [
                                    "Importe statsmodels.api como sm.",
                                    "Defina o modelo: y = série temporal, X = sm.add_constant(tempo).",
                                    "Ajuste o modelo com model.fit().",
                                    "Obtenha o summary() para visualizar coeficientes iniciais.",
                                    "Gere predições com model.predict()."
                                  ],
                                  "verification": "Modelo ajustado sem erros, com summary() mostrando p-value do slope < 0.05.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python",
                                    "statsmodels",
                                    "pandas"
                                  ],
                                  "tips": "Sempre adicione constante para intercepto; verifique multicolinearidade se aplicável.",
                                  "learningObjective": "Implementar regressão linear onde tempo é o preditor único para capturar tendência.",
                                  "commonMistakes": [
                                    "Esquecer add_constant() resultando em viés",
                                    "Não checar p-values iniciais",
                                    "Confundir y e X"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar os coeficientes do modelo",
                                  "subSteps": [
                                    "Identifique o coeficiente de inclinação (slope) e seu significado (mudança por unidade de tempo).",
                                    "Interprete o intercepto como valor inicial da tendência.",
                                    "Analise o R² e adjusted R² para força da tendência linear.",
                                    "Verifique significância estatística (p-value < 0.05).",
                                    "Calcule intervalo de confiança para o slope usando conf_int()."
                                  ],
                                  "verification": "Relatório escrito explicando slope, R² e significância com valores numéricos exatos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "statsmodels summary output"
                                  ],
                                  "tips": "Slope positivo indica tendência crescente; multiplique por escala temporal (ex: por ano).",
                                  "learningObjective": "Quantificar e interpretar a tendência linear em termos práticos.",
                                  "commonMistakes": [
                                    "Interpretar slope sem unidade de tempo",
                                    "Ignorar adjusted R² em séries longas",
                                    "Confundir p-value com R²"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar resíduos para validar pressupostos",
                                  "subSteps": [
                                    "Extraia resíduos com model.resid.",
                                    "Plote resíduos vs tempo e vs fitted values para homocedasticidade.",
                                    "Teste autocorrelação com Durbin-Watson (dw = model.dw).",
                                    "Verifique normalidade com QQ-plot ou teste Shapiro-Wilk.",
                                    "Identifique padrões nos resíduos indicando não-linearidade."
                                  ],
                                  "verification": "Gráficos de resíduos gerados mostrando ausência de padrões óbvios e dw próximo de 2.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "matplotlib",
                                    "scipy.stats"
                                  ],
                                  "tips": "Resíduos aleatórios e sem tendência confirmam adequação linear; dw ~2 indica sem autocorrelação.",
                                  "learningObjective": "Diagnosticar violações de pressupostos da regressão linear em séries temporais.",
                                  "commonMistakes": [
                                    "Não plotar resíduos vs tempo",
                                    "Ignorar autocorrelação comum em séries",
                                    "Assumir normalidade sem teste"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Visualizar e validar o modelo final",
                                  "subSteps": [
                                    "Plote a série original, linha de tendência ajustada e faixa de confiança.",
                                    "Compare RMSE ou MAE das predições.",
                                    "Teste previsões fora da amostra se dados disponíveis.",
                                    "Documente limitações (ex: não captura sazonalidade).",
                                    "Salve modelo e relatório com pickle ou export."
                                  ],
                                  "verification": "Gráfico final com tendência sobreposta à série, legenda clara e métricas reportadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "matplotlib",
                                    "statsmodels"
                                  ],
                                  "tips": "Use fill_between para intervalos de confiança; sempre valide visualmente.",
                                  "learningObjective": "Comunicar resultados do modelo de tendência de forma visual e interpretável.",
                                  "commonMistakes": [
                                    "Não incluir CI no gráfico",
                                    "Sobreestimar R² sem resíduos",
                                    "Ignorar extrapolação além dos dados"
                                  ]
                                }
                              ],
                              "practicalExample": "Carregue dados de vendas mensais de uma loja de eletrônicos de 2015-2023 (CSV com coluna 'data' e 'vendas'). Crie variável tempo (0 a 96), ajuste regressão linear, interprete slope como crescimento médio mensal em R$, analise resíduos para confirmar ausência de tendência residual, e plote a linha de tendência prevendo aumento de 1500 R$/mês.",
                              "finalVerifications": [
                                "Modelo linear ajustado com p-value do slope < 0.05.",
                                "R² > 0.6 indicando boa captura de tendência.",
                                "Resíduos sem autocorrelação (Durbin-Watson ~2).",
                                "Interpretação correta do slope em unidades de tempo.",
                                "Gráfico final com série, tendência e resíduos.",
                                "Relatório documentando coeficientes e limitações."
                              ],
                              "assessmentCriteria": [
                                "Precisão no ajuste do modelo (código executável sem erros).",
                                "Correta interpretação quantitativa de coeficientes.",
                                "Análise completa de resíduos com diagnósticos visuais.",
                                "Visualizações claras e profissionais.",
                                "Identificação de pelo menos 2 limitações do modelo linear.",
                                "Aplicação coerente ao exemplo prático."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear e equações de retas.",
                                "Programação: Manipulação de dados com pandas e modelagem estatística.",
                                "Economia: Análise de tendências de mercado e forecasting.",
                                "Ciência Ambiental: Detecção de tendências climáticas em séries temporais.",
                                "Física: Modelagem de crescimento exponencial aproximado por linear."
                              ],
                              "realWorldApplication": "Em finanças para detectar tendências de preços de ações; em meteorologia para quantificar aquecimento global via temperaturas anuais; em marketing para analisar crescimento de vendas e planejar estoques; em saúde pública para tendências de casos de doenças ao longo do tempo."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.2.2",
                        "name": "Sazonalidade em Séries Temporais",
                        "description": "A sazonalidade refere-se a padrões repetitivos e previsíveis em intervalos fixos, como mensais ou anuais, influenciados por ciclos naturais ou econômicos.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.2.1",
                            "name": "Detectar padrões sazonais em gráficos",
                            "description": "Analisar gráficos de séries temporais e sub-séries para identificar períodos sazonais, como picos anuais ou semanais, usando plotagens de múltiplos anos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e Visualizar a Série Temporal Inicial",
                                  "subSteps": [
                                    "Carregar o dataset de série temporal com timestamps e valores",
                                    "Verificar integridade dos dados (ausências, outliers iniciais)",
                                    "Plotar o gráfico completo da série temporal ao longo do tempo",
                                    "Ajustar eixos e rótulos para clareza visual",
                                    "Observar variações gerais e ciclos aparentes"
                                  ],
                                  "verification": "Gráfico da série temporal plotado corretamente, com dados visíveis e sem erros de carregamento",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de análise de dados (Python com pandas e matplotlib, R, ou Excel)",
                                    "Dataset de série temporal com pelo menos 2-3 anos de dados"
                                  ],
                                  "tips": "Use datas como índice para alinhamento temporal preciso e adicione gridlines para facilitar a leitura",
                                  "learningObjective": "Adquirir familiaridade visual com a estrutura temporal dos dados",
                                  "commonMistakes": [
                                    "Ignorar valores ausentes que distorcem o gráfico",
                                    "Escolher escalas inadequadas que mascaram padrões",
                                    "Plotar sem rótulos claros"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Hipotetizar e Investigar Períodos Sazonais Possíveis",
                                  "subSteps": [
                                    "Analisar o gráfico inicial para suspeitas de ciclos (ex: picos a cada 12 meses ou 7 dias)",
                                    "Listar hipóteses de períodos sazonais baseadas em domínio (anual, mensal, semanal)",
                                    "Calcular comprimentos aproximados de ciclos medindo distâncias entre picos",
                                    "Destacar regiões suspeitas no gráfico com anotações",
                                    "Documentar hipóteses iniciais em uma tabela"
                                  ],
                                  "verification": "Lista de 2-4 hipóteses sazonais documentadas com medidas aproximadas de período",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Gráfico gerado no step 1",
                                    "Ferramentas de anotação no software (ex: plt.annotate no matplotlib)"
                                  ],
                                  "tips": "Considere o contexto do domínio dos dados (ex: vendas de Natal para anual)",
                                  "learningObjective": "Desenvolver raciocínio para gerar hipóteses baseadas em evidências visuais",
                                  "commonMistakes": [
                                    "Confundir ruído aleatório com sazonalidade",
                                    "Ignorar múltiplos ciclos sobrepostos",
                                    "Não medir distâncias precisamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Plotar Sub-séries e Múltiplos Anos para Confirmação",
                                  "subSteps": [
                                    "Extrair sub-séries por período hipotético (ex: médias semanais ou por mês)",
                                    "Plotar sobreposição de múltiplos anos/ciclos no mesmo gráfico",
                                    "Alinhar séries por fase sazonal (ex: todos os verões juntos)",
                                    "Identificar consistência nos picos e vales entre ciclos",
                                    "Ajustar visualizações para zoom em padrões confirmados"
                                  ],
                                  "verification": "Gráficos de sub-séries mostram alinhamento consistente de padrões sazonais",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código ou funções para sub-séries (ex: resample no pandas)",
                                    "Gráficos do step 1"
                                  ],
                                  "tips": "Use cores diferentes para cada ciclo para facilitar comparação",
                                  "learningObjective": "Confirmar sazonalidade através de visualizações comparativas",
                                  "commonMistakes": [
                                    "Não alinhar corretamente as fases sazonais",
                                    "Plotar sub-séries sem normalização",
                                    "Sobrepor muitos ciclos causando confusão"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar, Documentar e Validar Padrões Sazonais",
                                  "subSteps": [
                                    "Descrever padrões detectados (período, amplitude, fase)",
                                    "Quantificar sazonalidade (ex: % de variação sazonal)",
                                    "Testar robustez removendo outliers ou subconjuntos de dados",
                                    "Gerar relatório com gráficos e conclusões",
                                    "Comparar com conhecimentos de domínio para validação"
                                  ],
                                  "verification": "Relatório completo com descrições, gráficos e métricas de padrões sazonais",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráficos dos steps anteriores",
                                    "Ferramentas de relatório (Jupyter notebook, Word)"
                                  ],
                                  "tips": "Inclua estatísticas simples como média e desvio para suporte quantitativo",
                                  "learningObjective": "Sintetizar análise visual em insights acionáveis e verificáveis",
                                  "commonMistakes": [
                                    "Generalizar padrões de poucos ciclos",
                                    "Não quantificar achados",
                                    "Ignorar contexto de domínio"
                                  ]
                                }
                              ],
                              "practicalExample": "Ao analisar dados de vendas diárias de sorvetes de uma rede de lojas (2019-2023), plote a série completa revelando picos no verão; sub-séries mensais confirmam ciclo anual de 12 meses com pico em julho, e zoom semanal mostra sub-pico aos fins de semana.",
                              "finalVerifications": [
                                "Pelo menos dois padrões sazonais (ex: anual e semanal) identificados com evidências gráficas",
                                "Gráficos de sub-séries mostram alinhamento consistente entre múltiplos ciclos",
                                "Hipóteses iniciais validadas ou refutadas com justificativa",
                                "Relatório documenta períodos, amplitudes e fases dos padrões",
                                "Análise robusta a remoção de subconjuntos de dados",
                                "Conclusões alinhadas com contexto de domínio dos dados"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de padrões sazonais (acertos >90%)",
                                "Qualidade e clareza das visualizações (rótulos, escalas adequadas)",
                                "Profundidade da análise (uso de sub-séries e múltiplos ciclos)",
                                "Documentação completa com hipóteses, evidências e métricas",
                                "Raciocínio lógico na distinção de sazonalidade vs. tendência/ruído",
                                "Criatividade em conexões com aplicações reais"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções periódicas e análise de Fourier básica",
                                "Economia: Previsão de demanda sazonal em negócios",
                                "Ciência Ambiental: Padrões climáticos e ciclos sazonais",
                                "Geografia: Variações regionais de sazonalidade",
                                "Programação: Manipulação de dados temporais em Python/R"
                              ],
                              "realWorldApplication": "Em meteorologia para modelar temperaturas sazonais e prever eventos climáticos; no varejo para otimizar estoque antes de picos sazonais como Black Friday; em finanças para detectar ciclos semanais em negociações de ações e ajustar estratégias de trading."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.2.2",
                            "name": "Calcular índices sazonais",
                            "description": "Computar fatores sazonais médios por período (ex.: média por mês) e ajustá-los para decompor a sazonalidade da série original.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a série temporal e calcular médias sazonais brutas",
                                  "subSteps": [
                                    "Coletar dados da série temporal com pelo menos 3 ciclos sazonais completos (ex: 36 meses).",
                                    "Identificar o período sazonal (ex: 12 para dados mensais).",
                                    "Agrupar dados por período sazonal e calcular a média para cada um (ex: média de todos os janeiros).",
                                    "Criar tabela com: Período | Média Sazonal Bruta | Número de Observações.",
                                    "Tratar valores ausentes ou outliers."
                                  ],
                                  "verification": "Tabela de médias sazonais brutas gerada corretamente, com médias calculadas sem erros aritméticos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Planilha Excel, Google Sheets ou software como R/Python (pandas)",
                                    "Dados de série temporal de exemplo (ex: CSV de vendas mensais)"
                                  ],
                                  "tips": "Use funções como AVERAGEIF no Excel ou groupby no pandas para agilizar.",
                                  "learningObjective": "Dominar a preparação de dados e cálculo inicial de componentes sazonais.",
                                  "commonMistakes": [
                                    "Ignorar outliers que distorcem médias",
                                    "Confundir ordem dos períodos sazonais",
                                    "Usar poucos ciclos, levando a instabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estimar a componente de tendência com médias móveis",
                                  "subSteps": [
                                    "Calcular a média móvel simples para capturar a tendência (janela = período sazonal, ex: 12 meses).",
                                    "Para decomposição centrada, usar média móvel de 2xperíodo-1 (ex: 23 para mensal) e centralizar.",
                                    "Alinhar as médias móveis com os períodos originais da série.",
                                    "Criar nova tabela: Tempo | Valor Original | Média Móvel (Tendência).",
                                    "Visualizar gráfico da tendência suavizada."
                                  ],
                                  "verification": "Gráfico mostra tendência suave sem oscilações sazonais, e valores alinhados corretamente.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software de análise (Excel, R com forecast, Python com pandas e matplotlib)",
                                    "Série temporal preparada do step 1"
                                  ],
                                  "tips": "No Excel, use REPT(AVERAGE(OFFSET(...))) para médias móveis centradas.",
                                  "learningObjective": "Aprender a isolar a tendência para ajuste sazonal preciso.",
                                  "commonMistakes": [
                                    "Janela de média móvel errada (não múltipla do período)",
                                    "Não centralizar, desalinhando com dados originais",
                                    "Aplicar em séries com tendência forte sem log"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular índices sazonais preliminares",
                                  "subSteps": [
                                    "Para cada período sazonal, dividir a média sazonal bruta pela média móvel de tendência correspondente.",
                                    "Ex: Índice Janeiro = Média Janeiro / Média Móvel de Janeiro médio.",
                                    "Preencher tabela: Período | Média Sazonal | Tendência | Índice Preliminar.",
                                    "Verificar se índices refletem padrão esperado (ex: >1 no verão para sorvetes).",
                                    "Calcular média dos índices preliminares."
                                  ],
                                  "verification": "Índices preliminares calculados com divisões exatas e média próxima de 1.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Mesmas ferramentas do step anterior",
                                    "Tabelas dos steps 1 e 2"
                                  ],
                                  "tips": "Use fórmulas relativas para automatizar divisões em planilhas.",
                                  "learningObjective": "Entender o ajuste da sazonalidade pela tendência.",
                                  "commonMistakes": [
                                    "Dividir errado (tendência pela sazonal)",
                                    "Não alinhar períodos corretamente",
                                    "Ignorar zeros ou negativos em séries multiplicativas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Normalizar índices e decompor a série",
                                  "subSteps": [
                                    "Calcular fator de ajuste: Número de períodos / Soma dos índices preliminares.",
                                    "Multiplicar cada índice preliminar pelo fator de ajuste para obter índices finais (média=1).",
                                    "Verificar soma dos índices finais = período sazonal (ex: 12).",
                                    "Multiplicar série original pela tendência e dividir pelos índices para obter resíduos (opcional).",
                                    "Aplicar índices à tendência para reconstruir componente sazonal."
                                  ],
                                  "verification": "Índices finais somam exatamente o número de períodos e média=1; decomposição reconstrói série original razoavelmente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Ferramentas anteriores",
                                    "Índices preliminares do step 3"
                                  ],
                                  "tips": "Automatize normalização com uma célula para o fator e cópia de fórmulas.",
                                  "learningObjective": "Finalizar e validar a decomposição sazonal completa.",
                                  "commonMistakes": [
                                    "Erro no fator de ajuste (soma ao invés de média)",
                                    "Não verificar soma final",
                                    "Aplicar multiplicativo em séries aditivas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma série de vendas mensais de sorvetes (jan/2018 a dez/2022), calcule médias por mês (ex: jan=500u), estime tendência com média móvel de 12 meses (ex: jan médio=600u), índice preliminar=500/600=0.833, ajuste para soma=12, obtendo índices como verão>1, inverno<1. Use para prever vendas futuras.",
                              "finalVerifications": [
                                "Soma dos índices sazonais finais equals ao número de períodos (ex: 12 para mensal).",
                                "Média aritmética dos índices = 1.",
                                "Índices refletem padrão sazonal lógico (ex: picos em meses esperados).",
                                "Multiplicação da tendência pelos índices reconstrói a série original sem grandes resíduos.",
                                "Ausência de erros aritméticos em todas as médias e divisões.",
                                "Gráficos mostram separação clara de tendência e sazonalidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de médias e divisões (erro <0.01%).",
                                "Correta estimação e alinhamento da tendência via médias móveis.",
                                "Normalização adequada dos índices (média=1, soma=período).",
                                "Interpretação coerente dos índices no contexto da série.",
                                "Uso eficiente de ferramentas e visualizações para validação.",
                                "Tratamento apropriado de edge cases como dados incompletos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculos de médias, divisões e normalização estatística.",
                                "Programação: Manipulação de dados com pandas/R e visualização com ggplot/matplotlib.",
                                "Economia/Gestão: Previsão de demanda sazonal em varejo e supply chain.",
                                "Geografia/Meio Ambiente: Análise de padrões climáticos em séries como precipitação.",
                                "Finanças: Ajuste sazonal em retornos de ações ou vendas setoriais."
                              ],
                              "realWorldApplication": "Empresas como redes de varejo (ex: Amazon) usam índices sazonais para otimizar estoques de produtos como roupas de inverno/verão, turismo prevê ocupação hoteleira por mês, e bancos ajustam empréstimos agrícolas por ciclos de safra, melhorando previsões e reduzindo desperdícios."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.2.3",
                            "name": "Visualizar sazonalidade com gráficos de caixa",
                            "description": "Criar boxplots agrupados por período sazonal para visualizar variações e confirmar a presença de padrões sazonais repetitivos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e extrair dados sazonais da série temporal",
                                  "subSteps": [
                                    "Carregue o dataset de série temporal usando pandas (ex: pd.read_csv()).",
                                    "Converta a coluna de data para datetime com pd.to_datetime().",
                                    "Crie uma coluna de período sazonal (ex: mês, estação ou trimestre) usando dt.month ou funções personalizadas.",
                                    "Agrupe os dados por período sazonal com groupby() para inspeção inicial.",
                                    "Verifique valores ausentes e outliers com describe() ou boxplot simples."
                                  ],
                                  "verification": "Confirme que a nova coluna sazonal tem valores corretos e o dataset agrupado retorna estatísticas por grupo sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Biblioteca pandas instalada",
                                    "Dataset de série temporal (ex: CSV com colunas data e valor)"
                                  ],
                                  "tips": [
                                    "Use .astype('category') na coluna sazonal para otimizar plots.",
                                    "Salve uma cópia do dataset original com df.copy()."
                                  ],
                                  "learningObjective": "Dominar a extração e preparação de componentes sazonais de séries temporais para análise visual.",
                                  "commonMistakes": [
                                    "Ignorar fusos horários em datas",
                                    "Não converter para datetime antes de extrair mês/estação",
                                    "Agrupar incorretamente levando a NaNs"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar ambiente de visualização e importar bibliotecas necessárias",
                                  "subSteps": [
                                    "Importe matplotlib.pyplot, seaborn e pandas.",
                                    "Defina um estilo de plot com sns.set_style('whitegrid') para clareza.",
                                    "Crie uma figura com plt.figure(figsize=(12,8)) adequada para múltiplos boxplots.",
                                    "Prepare os dados em formato long (melt) se necessário para seaborn.",
                                    "Teste um boxplot simples em uma variável para validar setup."
                                  ],
                                  "verification": "Execute um boxplot de teste e confirme que a figura renderiza sem erros com eixos rotulados corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Bibliotecas: matplotlib, seaborn, pandas (pip install se necessário)",
                                    "Jupyter Notebook ou script Python"
                                  ],
                                  "tips": [
                                    "Use %matplotlib inline em notebooks para visualização imediata.",
                                    "Ajuste figsize baseado no número de períodos sazonais."
                                  ],
                                  "learningObjective": "Configurar um ambiente de plotting otimizado para visualizações comparativas em séries temporais.",
                                  "commonMistakes": [
                                    "Esquecer importações levando a NameError",
                                    "Não definir estilo resultando em plots bagunçados",
                                    "Figsize muito pequeno para muitos grupos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Criar boxplots agrupados por período sazonal",
                                  "subSteps": [
                                    "Use sns.boxplot(data=df, x='periodo_sazonal', y='valor') para plot agrupado.",
                                    "Adicione títulos e labels com plt.title(), plt.xlabel(), plt.ylabel().",
                                    "Rotacione labels do eixo x com plt.xticks(rotation=45).",
                                    "Adicione uma linha de média ou mediana com sns.pointplot() sobreposto.",
                                    "Salve o gráfico com plt.savefig('boxplot_sazonal.png', dpi=300)."
                                  ],
                                  "verification": "O boxplot exibe caixas por período sazonal com mediana, quartis e outliers visíveis, sem sobreposições ilegíveis.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código preparado dos steps anteriores",
                                    "Editor de código ou Jupyter"
                                  ],
                                  "tips": [
                                    "Use hue='outra_variavel' para subgrupos se aplicável.",
                                    "Log scale com plt.yscale('log') para dados skewed."
                                  ],
                                  "learningObjective": "Construir visualizações de boxplot agrupadas que destacam variações sazonais de forma clara e profissional.",
                                  "commonMistakes": [
                                    "Ordem errada de x/y causando plot invertido",
                                    "Não rotacionar labels levando a texto sobreposto",
                                    "Esquecer de salvar ou mostrar o plot com plt.show()"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar o boxplot e confirmar padrões sazonais repetitivos",
                                  "subSteps": [
                                    "Analise as medianas por período: identifique picos e vales consistentes.",
                                    "Compare dispersões (IQR) entre períodos para variações sazonais.",
                                    "Verifique outliers e sua recorrência em períodos específicos.",
                                    "Documente observações em um relatório Markdown ou comentários no código.",
                                    "Compare com gráfico de linha original para validação cruzada."
                                  ],
                                  "verification": "Escreva 3-5 observações específicas sobre padrões sazonais detectados, com referências ao boxplot.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Gráfico gerado",
                                    "Notebook para anotações"
                                  ],
                                  "tips": [
                                    "Foque em repetitividade ano a ano para confirmar sazonalidade.",
                                    "Use estatísticas resumidas com groupby().agg() para suporte quantitativo."
                                  ],
                                  "learningObjective": "Interpretar boxplots sazonais para extrair insights acionáveis sobre padrões repetitivos em séries temporais.",
                                  "commonMistakes": [
                                    "Confundir outliers com padrões sazonais",
                                    "Ignorar diferenças de escala entre períodos",
                                    "Não validar com outras visualizações"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dados de vendas mensais de sorvetes (colunas: data, vendas), crie boxplots agrupados por mês. Observe mediana alta em julho/agosto e baixa em janeiro, com IQR amplo no verão confirmando padrão sazonal repetitivo ao longo de 5 anos.",
                              "finalVerifications": [
                                "Boxplot agrupa corretamente por períodos sazonais com caixas visíveis para cada grupo.",
                                "Variações de mediana e dispersão indicam padrões repetitivos claros.",
                                "Outliers são plotados e não distorcem a interpretação geral.",
                                "Gráfico inclui labels, título e é salvo em alta resolução.",
                                "Interpretação escrita confirma presença de sazonalidade com evidências visuais.",
                                "Código é reproduzível sem erros em dataset similar."
                              ],
                              "assessmentCriteria": [
                                "Precisão na preparação de dados sazonais (sem erros de indexing ou NaNs).",
                                "Qualidade visual do boxplot (clareza, labels, escalas adequadas).",
                                "Profundidade da interpretação (identifica repetitividade e variações).",
                                "Eficiência do código (usa funções otimizadas como seaborn).",
                                "Documentação completa com comentários e salvamento de artefatos.",
                                "Validação cruzada com estatísticas descritivas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estatística descritiva e medidas de dispersão (quartis, IQR).",
                                "Biologia: Ciclos sazonais em populações animais ou fenômenos climáticos.",
                                "Economia: Análise de vendas sazonais para previsão de estoque.",
                                "Geografia: Padrões climáticos regionais e impactos sazonais."
                              ],
                              "realWorldApplication": "Em meteorologia, boxplots sazonais de temperaturas ajudam a prever ondas de calor; em varejo, identificam picos de vendas para otimizar logística e estoque."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.2.3",
                        "name": "Decomposição Exploratória de Séries Temporais",
                        "description": "Métodos para separar uma série temporal em componentes aditivos ou multiplicativos: tendência, sazonalidade e resíduo, facilitando a análise exploratória.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.3.1",
                            "name": "Executar decomposição clássica",
                            "description": "Aplicar decomposição aditiva ou multiplicativa usando médias móveis para tendência e índices sazonais, interpretando os gráficos resultantes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar dados e escolher modelo de decomposição",
                                  "subSteps": [
                                    "Colete a série temporal com pelo menos 3-4 ciclos sazonais completos.",
                                    "Visualize o gráfico da série original para identificar padrão de tendência e sazonalidade.",
                                    "Decida entre modelo aditivo (se variações constantes) ou multiplicativo (se variações proporcionais) com base na variância.",
                                    "Defina o período sazonal (ex: 12 para mensal).",
                                    "Prepare o dataframe com datas e valores."
                                  ],
                                  "verification": "Gráfico inicial plotado corretamente e modelo escolhido justificado em relatório.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software como R (forecast package), Python (statsmodels), Excel; dados de série temporal (ex: AirPassengers dataset).",
                                  "tips": "Use log-transformação para estabilizar variância em séries multiplicativas.",
                                  "learningObjective": "Identificar características da série para seleção adequada do modelo.",
                                  "commonMistakes": "Escolher modelo errado sem visualizar dados; usar período sazonal incorreto."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular componente de tendência com médias móveis",
                                  "subSteps": [
                                    "Aplique média móvel simples (SMA) com janela = 2 * período sazonal (ex: 24 para mensal).",
                                    "Calcule SMA centrada se necessário para alinhar com observações.",
                                    "Plote a tendência suavizada sobre a série original.",
                                    "Ajuste janela se tendência não capturar padrão adequadamente.",
                                    "Salve a série de tendência para próximos passos."
                                  ],
                                  "verification": "Gráfico de tendência sobreposto à original sem lags evidentes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Funções como ma() em R ou pd.to_numeric() em Python; planilha para cálculos manuais.",
                                  "tips": "Use janela ímpar para centralização exata.",
                                  "learningObjective": "Dominar suavização por médias móveis para isolar tendência.",
                                  "commonMistakes": "Janela errada causando distorção; não centralizar SMA."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular componentes sazonais e detrend",
                                  "subSteps": [
                                    "Subtraia (aditivo) ou divida (multiplicativo) tendência da série original para obter série detrended.",
                                    "Calcule médias sazonais por período ao longo dos ciclos.",
                                    "Média dos desvios sazonais para cada posição sazonal.",
                                    "Normalize índices sazonais para somar 1 (multiplicativo) ou média zero (aditivo).",
                                    "Plote série detrended e índices sazonais."
                                  ],
                                  "verification": "Índices sazonais somam corretamente e gráfico detrended mostra apenas sazonalidade.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Scripts R decompose() ou Python seasonal_decompose(); dados detrended salvos.",
                                  "tips": "Agrupe por fator sazonal (month()) para eficiência.",
                                  "learningObjective": "Extrair e normalizar padrões sazonais da série detrended.",
                                  "commonMistakes": "Não normalizar índices; confundir aditivo/multiplicativo no detrending."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular resíduos e recompor série",
                                  "subSteps": [
                                    "Remova sazonalidade da detrended: resíduos = detrended - sazonal (aditivo) ou / sazonal (multiplicativo).",
                                    "Recomponha: original ≈ tendência + sazonal + resíduo (aditivo).",
                                    "Verifique se soma/reconstrução aproxima original.",
                                    "Plote todos componentes alinhados.",
                                    "Analise resíduos para estacionariedade (sem padrão)."
                                  ],
                                  "verification": "Série recomposta tem erro mínimo (MSE baixo) vs original.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Funções de decomposição integrada; métricas como RMSE.",
                                  "tips": "Use loop para recomposição em código.",
                                  "learningObjective": "Isolar ruído e validar decomposição via recomposição.",
                                  "commonMistakes": "Erros de sinal em subtrações; resíduos com padrão restante."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar gráficos e validar decomposição",
                                  "subSteps": [
                                    "Analise gráfico de tendência: direção, aceleração.",
                                    "Examine sazonalidade: picos/vales, amplitude.",
                                    "Verifique resíduos: aleatoriedade, ausência de autocorrelação.",
                                    "Compare modelos aditivo/multiplicativo via resíduos.",
                                    "Documente insights em relatório com gráficos anotados."
                                  ],
                                  "verification": "Relatório com interpretações claras e gráficos legendados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Ferramentas de plotagem (ggplot2, matplotlib); ACF plot para resíduos.",
                                  "tips": "Teste Ljung-Box em resíduos para não-estacionariedade.",
                                  "learningObjective": "Extrair insights acionáveis dos componentes decomposados.",
                                  "commonMistakes": "Ignorar resíduos não-brancos; interpretação subjetiva sem dados."
                                }
                              ],
                              "practicalExample": "Usando dataset AirPassengers (passageiros aéreos mensais 1949-1960): aplique decomposição multiplicativa (devido variância crescente). Calcule tendência com SMA(24), índices sazonais (pico verão), resíduos aleatórios. Gráficos mostram crescimento exponencial e sazonalidade anual.",
                              "finalVerifications": [
                                "Gráficos de todos componentes (original, tendência, sazonal, resíduos) plotados corretamente.",
                                "Índices sazonais normalizados (soma=12 para mensal aditivo; média=1 multiplicativo).",
                                "Resíduos sem padrão visual ou autocorrelação significativa (ACF próximo zero).",
                                "Reconstrução da série original com erro <5% MSE.",
                                "Relatório justifica escolha aditivo/multiplicativo.",
                                "Tendência captura direção geral sem oscilações sazonais."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de médias móveis e índices sazonais (erro <1%).",
                                "Correta identificação e aplicação do modelo (aditivo/multiplicativo).",
                                "Qualidade dos gráficos: legíveis, anotados, componentes alinhados.",
                                "Interpretação profunda: insights sobre tendência/sazonalidade.",
                                "Validação rigorosa: testes em resíduos e MSE de reconstrução.",
                                "Eficiência: tempo dentro estimado, código limpo/reprodutível."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estatística descritiva, suavização de sinais.",
                                "Programação: Manipulação de dados em R/Python (pandas, dplyr).",
                                "Economia/Negócios: Previsão de demanda sazonal (vendas, turismo).",
                                "Ciências Ambientais: Análise de séries climáticas (temperatura, precipitação)."
                              ],
                              "realWorldApplication": "Em varejo, decompor vendas mensais para prever estoque sazonal (ex: Natal); em finanças, analisar retornos de ações para detectar ciclos econômicos; em meteorologia, separar tendência climática de variações sazonais para modelos de mudança climática."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.3.2",
                            "name": "Usar método STL para decomposição",
                            "description": "Implementar o método Season-Trend decomposition using Loess (STL) em software como R para extrair componentes robustas, lidando com não-linearidades.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e os dados no R",
                                  "subSteps": [
                                    "Instale o R e RStudio se necessário.",
                                    "Carregue um conjunto de dados de série temporal exemplo, como AirPassengers.",
                                    "Verifique a estrutura dos dados com str() e plot() para identificar sazonalidade e tendência.",
                                    "Converta os dados para objeto ts() com frequência apropriada (ex: frequency=12 para mensal).",
                                    "Trate valores ausentes com na.approx() do pacote zoo."
                                  ],
                                  "verification": "Os dados estão carregados como objeto ts() e plotados corretamente sem erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "R e RStudio instalados",
                                    "Pacote datasets (base do R)",
                                    "Dataset AirPassengers"
                                  ],
                                  "tips": "Sempre defina a frequência correta para evitar erros na decomposição.",
                                  "learningObjective": "Preparar dados de série temporal adequadamente para decomposição STL.",
                                  "commonMistakes": [
                                    "Esquecer de definir frequency no ts()",
                                    "Ignorar valores missing",
                                    "Usar dados não estacionários sem pré-processamento"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Instalar e carregar pacotes necessários",
                                  "subSteps": [
                                    "Execute install.packages('forecast') ou 'stlplus' se necessário.",
                                    "Carregue com library(forecast) e library(ggplot2) para visualizações avançadas.",
                                    "Verifique a versão do R com R.version para compatibilidade.",
                                    "Importe dados externos se aplicável com read.csv() e ts().",
                                    "Teste uma plot básica para confirmar carregamento."
                                  ],
                                  "verification": "Todas as libraries carregam sem warnings e funções stl() estão disponíveis.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Conexão à internet para instalação",
                                    "RStudio"
                                  ],
                                  "tips": "Use pacotes como forecast para funções auxiliares de STL.",
                                  "learningObjective": "Configurar ambiente R pronto para análise de séries temporais com STL.",
                                  "commonMistakes": [
                                    "Instalar pacotes desnecessários",
                                    "Conflitos de versão entre pacotes",
                                    "Esquecer library() após install"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar e executar a decomposição STL",
                                  "subSteps": [
                                    "Defina parâmetros: s.window='periodic', t.window=13, l.window=13 para Loess.",
                                    "Execute decomp <- stl(ts_data, s.window='periodic', robust=TRUE).",
                                    "Ajuste parâmetros para séries longas: t.window maior para tendências suaves.",
                                    "Use robust=TRUE para lidar com outliers e não-linearidades.",
                                    "Salve o objeto decomp para inspeção."
                                  ],
                                  "verification": "O objeto stl é criado sem erros e class(decomp) retorna 'stl'.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Objeto ts() preparado",
                                    "Documentação stl() via ?stl"
                                  ],
                                  "tips": "Comece com parâmetros padrão e ajuste iterativamente baseado no plot.",
                                  "learningObjective": "Implementar STL com parâmetros adequados para decompor série temporal.",
                                  "commonMistakes": [
                                    "Parâmetros window muito pequenos causando ruído",
                                    "Ignorar robust=FALSE para dados com outliers",
                                    "Não especificar frequency correta"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Visualizar e analisar os componentes",
                                  "subSteps": [
                                    "Execute plot(decomp) para gráfico padrão de tendência, sazonal e resíduo.",
                                    "Extraia componentes: trend(decomp), seasonal(decomp), remainder(decomp).",
                                    "Plote individualmente com ggplot2 para zoom e customização.",
                                    "Verifique resíduos com plot(remainder(decomp)) e teste de autocorrelação.",
                                    "Compare decomposição com modelo aditivo/multiplicativo."
                                  ],
                                  "verification": "Gráficos mostram separação clara de tendência, sazonalidade e resíduo sem sobreposição excessiva.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Pacote ggplot2",
                                    "Objeto stl gerado"
                                  ],
                                  "tips": "Use autoplot(decomp) do forecast para visualizações modernas.",
                                  "learningObjective": "Interpretar visualmente os componentes extraídos pelo STL.",
                                  "commonMistakes": [
                                    "Interpretar resíduo como ruído sem checar autocorrelação",
                                    "Confundir sazonal com tendência",
                                    "Escalas inadequadas nos plots"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar, interpretar e refinar a decomposição",
                                  "subSteps": [
                                    "Calcule métricas: sum((remainder(decomp))^2) para variância residual.",
                                    "Teste estacionariedade nos resíduos com adf.test() do pacote tseries.",
                                    "Ajuste parâmetros e reexecute se resíduos mostrarem padrões.",
                                    "Reconstrua série: ts(trend(decomp) + seasonal(decomp) + remainder(decomp)).",
                                    "Documente insights em relatório R Markdown."
                                  ],
                                  "verification": "Resíduos são estacionários (p-value < 0.05 no ADF test) e reconstrução matches original.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Pacotes tseries e forecast",
                                    "R Markdown para relatório"
                                  ],
                                  "tips": "STL é robusto, mas valide com múltiplos conjuntos de dados.",
                                  "learningObjective": "Validar robustez da decomposição STL e extrair insights acionáveis.",
                                  "commonMistakes": [
                                    "Aceitar decomposição sem checar resíduos",
                                    "Overfitting de parâmetros",
                                    "Ignorar reconstrução para validação"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando o dataset AirPassengers (passageiros aéreos mensais 1949-1960), aplique STL com s.window='periodic' para extrair a forte sazonalidade anual e tendência crescente, visualizando como o pico de verão é isolado nos resíduos mínimos.",
                              "finalVerifications": [
                                "Decomposição executada sem erros em dataset real.",
                                "Componentes plotados e interpretados corretamente.",
                                "Resíduos validados como ruído branco.",
                                "Parâmetros ajustados para não-linearidades.",
                                "Reconstrução da série original com erro mínimo.",
                                "Relatório com insights gerado."
                              ],
                              "assessmentCriteria": [
                                "Escolha precisa de parâmetros STL (window sizes adequados).",
                                "Tratamento correto de dados (ts(), missing values).",
                                "Interpretação precisa dos componentes (tendência, sazonal, resíduo).",
                                "Validação estatística dos resíduos (ADF test).",
                                "Visualizações claras e profissionais.",
                                "Aplicação robusta a não-linearidades."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelos Loess e suavização não-paramétrica.",
                                "Programação: Manipulação de dados em R e ggplot2.",
                                "Economia: Previsão de demanda e análise de vendas sazonais.",
                                "Ciência de Dados: Exploração de séries temporais e validação.",
                                "Estatística: Testes de estacionariedade e decomposição aditiva."
                              ],
                              "realWorldApplication": "Em meteorologia para decompor temperaturas e prever padrões climáticos; em varejo para separar sazonalidade de vendas de tendências econômicas; em finanças para analisar retornos de ações e remover ruído sazonal antes de modelagem preditiva."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.3.3",
                            "name": "Avaliar resíduos após decomposição",
                            "description": "Analisar os resíduos da decomposição para verificar estacionariedade, autocorrelação e adequação do modelo exploratório.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e visualizar os resíduos da decomposição",
                                  "subSteps": [
                                    "Extrair os resíduos do modelo de decomposição (aditiva ou multiplicativa) usando a função apropriada da biblioteca (ex: decompose() no R ou seasonal_decompose() no Python).",
                                    "Gerar plots básicos: série temporal dos resíduos, histograma e Q-Q plot para inspeção inicial.",
                                    "Identificar padrões visuais óbvios como tendências remanescentes, sazonalidade ou outliers.",
                                    "Salvar os plots em alta resolução para análise posterior.",
                                    "Documentar observações iniciais em um relatório ou notebook."
                                  ],
                                  "verification": "Plots gerados mostram resíduos centralizados em zero sem padrões evidentes; histograma aproximadamente simétrico.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python (statsmodels, matplotlib, seaborn) ou R (forecast, ggplot2); conjunto de dados de série temporal decomposta.",
                                  "tips": "Use escala logarítmica para resíduos de decomposição multiplicativa para melhor visualização.",
                                  "learningObjective": "Compreender a importância da visualização inicial para detectar anomalias nos resíduos.",
                                  "commonMistakes": "Ignorar outliers ou não ajustar a escala dos gráficos, levando a interpretações erradas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Testar estacionariedade dos resíduos",
                                  "subSteps": [
                                    "Aplicar teste Augmented Dickey-Fuller (ADF) nos resíduos para hipotesar não-estacionariedade.",
                                    "Realizar teste KPSS para confirmar estacionariedade em torno da média.",
                                    "Interpretar p-valores: ADF p < 0.05 indica estacionariedade; KPSS p > 0.05 confirma.",
                                    "Gerar plot de resíduos com linha de tendência para suporte visual.",
                                    "Registrar estatísticas dos testes em uma tabela."
                                  ],
                                  "verification": "P-valores dos testes ADF e KPSS indicam resíduos estacionários (ADF rejeita unidade raiz, KPSS não rejeita estacionariedade).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Python (statsmodels.tsa.stattools adfuller, kpss) ou R (tseries::adf.test, urca::ur.kpss); notebook Jupyter ou RMarkdown.",
                                  "tips": "Inclua lags automáticos no ADF para robustez; compare com resíduos originais da série.",
                                  "learningObjective": "Aplicar e interpretar testes formais de estacionariedade em resíduos.",
                                  "commonMistakes": "Confundir p-valores dos testes (ADF e KPSS testam hipóteses opostas)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar autocorrelação e correlação parcial nos resíduos",
                                  "subSteps": [
                                    "Calcular e plotar Função de Autocorrelação (ACF) e Função de Autocorrelação Parcial (PACF) dos resíduos.",
                                    "Verificar se barras de ACF/PACF caem dentro das bandas de confiança (95%) após lag 1.",
                                    "Identificar qualquer autocorrelação significativa que indique modelo inadequado.",
                                    "Realizar teste Ljung-Box para autocorrelação residual coletiva.",
                                    "Anotar lags significativos e implicações para o modelo."
                                  ],
                                  "verification": "ACF/PACF mostram ausência de autocorrelação significativa (todas barras dentro das bandas); Ljung-Box p > 0.05.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python (statsmodels.tsa.stattools acf, pacf, qqplot) ou R (acf(), pacf(), Box.test); dados de resíduos.",
                                  "tips": "Use lags até 20-30 para séries longas; foque em spikes iniciais que indicam dependência.",
                                  "learningObjective": "Diagnosticar dependências seriais remanescentes via gráficos ACF/PACF.",
                                  "commonMistakes": "Interpretar barras próximas às bandas como significativas sem considerar o teste formal."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar adequação geral do modelo e concluir",
                                  "subSteps": [
                                    "Testar normalidade dos resíduos com teste Shapiro-Wilk ou Kolmogorov-Smirnov.",
                                    "Verificar homocedasticidade via plot de resíduos vs. fitted values ou teste Breusch-Pagan.",
                                    "Sintetizar todos os resultados em um relatório: adequação do modelo (sim/não e por quê).",
                                    "Sugerir ajustes no modelo de decomposição se necessário (ex: mudar para multiplicativo).",
                                    "Comparar com critérios como AIC/BIC para validação."
                                  ],
                                  "verification": "Resíduos passam em testes de normalidade e homocedasticidade; conclusão justificada com evidências.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Python (scipy.stats shapiro, statsmodels.stats.diagnostic) ou R (shapiro.test, lmtest::bptest); relatório template.",
                                  "tips": "Para séries não-Gaussianas, priorize estacionariedade sobre normalidade.",
                                  "learningObjective": "Integrar múltiplos diagnósticos para validar a decomposição exploratória.",
                                  "commonMistakes": "Aceitar resíduos sem verificar múltiplos aspectos, focando apenas em um teste."
                                }
                              ],
                              "practicalExample": "Usando dados mensais de passageiros aéreos (AirPassengers dataset), decomponha a série, extraia resíduos e verifique: ADF p=0.01 (estacionário), ACF sem spikes significativos, confirmando boa decomposição aditiva.",
                              "finalVerifications": [
                                "Resíduos centralizados em zero com variância constante.",
                                "Testes de estacionariedade (ADF/KPSS) aprovados.",
                                "ACF/PACF sem autocorrelações significativas.",
                                "Normalidade e homocedasticidade confirmadas.",
                                "Ljung-Box p > 0.05 para independência.",
                                "Ausência de padrões visuais nos plots."
                              ],
                              "assessmentCriteria": [
                                "Precisão na extração e visualização de resíduos (plots corretos).",
                                "Interpretação correta de p-valores em testes estatísticos.",
                                "Identificação precisa de autocorrelações via ACF/PACF.",
                                "Síntese coerente de resultados com conclusão sobre modelo.",
                                "Uso adequado de software e documentação de passos.",
                                "Sugestões lógicas para melhorias no modelo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estatística inferencial e testes de hipóteses.",
                                "Programação: Manipulação de dados em Python/R e visualização.",
                                "Economia: Análise de séries temporais em previsão econômica.",
                                "Ciência de Dados: Diagnóstico de modelos em machine learning."
                              ],
                              "realWorldApplication": "Em finanças, avaliar resíduos de decomposição de séries de retornos de ações para validar modelos de previsão, garantindo previsões confiáveis para investimentos; em meteorologia, verificar resíduos de temperaturas para melhorar modelos sazonais de clima."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.3",
                    "name": "Funções de Autocorrelação (ACF e PACF)",
                    "description": "Cálculo e interpretação das funções de autocorrelação e autocorrelação parcial para detectar dependências temporais.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.3.1",
                        "name": "Função de Autocorrelação (ACF)",
                        "description": "A Função de Autocorrelação (ACF) mede a correlação linear entre os valores de uma série temporal e seus valores defasados por k períodos, permitindo identificar padrões de dependência temporal e auxiliar na verificação de estacionariedade.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.1.1",
                            "name": "Definir e formular a ACF",
                            "description": "Explicar o conceito de autocorrelação e derivar a fórmula matemática da ACF, ρ_k = γ_k / γ_0, onde γ_k é a covariância autocovariância de ordem k e γ_0 é a variância, com exemplos em séries temporais estacionárias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Conceito Intuitivo de Autocorrelação",
                                  "subSteps": [
                                    "Revise o conceito de correlação linear entre duas variáveis aleatórias independentes.",
                                    "Visualize autocorrelação como a correlação de uma série temporal consigo mesma em lags diferentes (k=0,1,2,...).",
                                    "Analise gráficos de séries temporais estacionárias para identificar padrões de dependência temporal.",
                                    "Diferencie autocorrelação de correlação cruzada entre séries diferentes.",
                                    "Discuta por que autocorrelação é crucial em processos estacionários, onde a média e variância são constantes."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que é autocorrelação com um diagrama simples de lag k.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Gráficos de séries temporais de exemplo (ex: AR(1))",
                                    "Papel e caneta para esboços"
                                  ],
                                  "tips": "Use analogias como 'eco' em uma conversa para visualizar dependência em lags.",
                                  "learningObjective": "Compreender intuitivamente autocorrelação como dependência serial em séries temporais estacionárias.",
                                  "commonMistakes": [
                                    "Confundir com tendência não estacionária",
                                    "Ignorar que k=0 sempre dá ρ_0=1"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e Calcular a Autocovariância γ_k",
                                  "subSteps": [
                                    "Defina formalmente γ_k = Cov(Y_t, Y_{t+k}) = E[(Y_t - μ)(Y_{t+k} - μ)] para processos estacionários.",
                                    "Mostre que para estacionariedade, γ_k depende apenas de k, não de t.",
                                    "Calcule γ_0 = Var(Y_t) = E[(Y_t - μ)^2].",
                                    "Derive propriedades: γ_k = γ_{-k}, |γ_k| ≤ γ_0.",
                                    "Implemente cálculo amostral de γ_k em software: γ_k̂ = (1/n) Σ (Y_t - Ȳ)(Y_{t+k} - Ȳ)."
                                  ],
                                  "verification": "Calcule γ_1 para uma série simulada de 100 observações e verifique se |γ_1| ≤ γ_0.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Python/R com bibliotecas statsmodels ou tseries",
                                    "Série temporal simulada AR(1) com φ=0.5"
                                  ],
                                  "tips": "Sempre centre a série subtraindo a média para evitar bias.",
                                  "learningObjective": "Dominar a definição e propriedades da autocovariância em processos estacionários.",
                                  "commonMistakes": [
                                    "Esquecer de subtrair a média μ",
                                    "Assumir não-estacionariedade ao calcular γ_k"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a Fórmula da Função de Autocorrelação (ACF) ρ_k",
                                  "subSteps": [
                                    "Parta da definição de correlação padronizada: ρ_k = Cov(Y_t, Y_{t+k}) / √[Var(Y_t) Var(Y_{t+k})].",
                                    "Para estacionariedade, Var(Y_t) = Var(Y_{t+k}) = γ_0, simplificando para ρ_k = γ_k / γ_0.",
                                    "Verifique propriedades: ρ_0 = 1, |ρ_k| ≤ 1, ρ_k = ρ_{-k}.",
                                    "Plote a função ACF teórica para modelos como MA(1) ou AR(1).",
                                    "Compare ACF amostral ρ_k̂ = γ_k̂ / γ_0̂ com a teórica."
                                  ],
                                  "verification": "Derive algebricamente ρ_k a partir de γ_k e γ_0, e aplique a um exemplo numérico.",
                                  "estimatedTime": "25-40 minutos",
                                  "materials": [
                                    "Folha de papel para derivação",
                                    "Software para plotar ACF (ex: acf() no R)"
                                  ],
                                  "tips": "Lembre-se: ACF normaliza a autocovariância para torná-la adimensional e comparável.",
                                  "learningObjective": "Derivar e interpretar a fórmula ρ_k = γ_k / γ_0 corretamente.",
                                  "commonMistakes": [
                                    "Dividir por γ_k em vez de γ_0",
                                    "Confundir ρ_k com γ_k sem normalização"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Interpretar ACF em Séries Temporais Estacionárias",
                                  "subSteps": [
                                    "Simule séries AR(1), MA(1) e ruído branco; calcule e plote ACF para cada.",
                                    "Identifique decaimento exponencial em AR(1) vs. corte abrupto em MA(q).",
                                    "Teste significância de ρ_k̂ usando intervalos de confiança (ex: ±1.96/√n).",
                                    "Discuta implicações: ACF lenta indica dependência de longo alcance.",
                                    "Compare com PACF para diferenciação de modelos ARMA."
                                  ],
                                  "verification": "Gere plots de ACF para 3 séries diferentes e interprete padrões corretamente.",
                                  "estimatedTime": "30-50 minutos",
                                  "materials": [
                                    "Python (statsmodels.tsa.stattools.acf)",
                                    "R (forecast ou tseries)"
                                  ],
                                  "tips": "Use n_sim=1000 para médias de ACF em simulações para clareza visual.",
                                  "learningObjective": "Aplicar ACF na identificação de estruturas em séries estacionárias.",
                                  "commonMistakes": [
                                    "Interpretar spikes insignificantes como estrutura",
                                    "Não testar estacionariedade primeiro (ADF test)"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule uma série AR(1): Y_t = 0.7 Y_{t-1} + ε_t, ε_t ~ N(0,1). Calcule γ_1 = φ γ_0 = 0.7, ρ_1 = 0.7. Plote ACF amostral de 200 observações e observe decaimento exponencial aproximando a teórica.",
                              "finalVerifications": [
                                "Deriva corretamente ρ_k = γ_k / γ_0 a partir de definições.",
                                "Calcula ACF amostral para uma série dada com software.",
                                "Interpreta plots ACF identificando padrões AR/MA.",
                                "Explica propriedades ρ_0=1 e |ρ_k|≤1.",
                                "Diferencia ACF de autocovariância em exemplos.",
                                "Aplica teste de significância em barras de confiança."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação matemática (100% correto).",
                                "Correção nos cálculos numéricos/simulações (erro <5%).",
                                "Interpretação qualitativa de plots ACF (identifica modelo correto).",
                                "Uso adequado de propriedades estacionárias.",
                                "Clareza na explicação verbal/escrita do conceito.",
                                "Integração de exemplos práticos relevantes."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade: Uso de momentos (covariância, expectativa).",
                                "Álgebra Linear: Vetores de autocovariância em estimação.",
                                "Programação: Implementação em Python/R para análise computacional.",
                                "Econometria: Aplicação em modelos de previsão econômica.",
                                "Física: Análise de sinais em séries temporais vibracionais."
                              ],
                              "realWorldApplication": "Em finanças, ACF de retornos diários de ações detecta dependência serial para modelagem GARCH; em meteorologia, analisa padrões de temperatura para previsões sazonais estacionárias."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.2",
                            "name": "Calcular coeficientes de autocorrelação",
                            "description": "Realizar o cálculo manual e computacional dos coeficientes ACF para uma série temporal dada, utilizando fórmulas e ferramentas como R (função acf()), considerando limites de confiança de 95% para significância.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Fórmula e Conceitos Básicos da ACF",
                                  "subSteps": [
                                    "Revise a fórmula da ACF para lag k: ρ_k = γ_k / γ_0, onde γ_k é a covariância autocorrelacionada e γ_0 é a variância.",
                                    "Calcule a média da série temporal (μ).",
                                    "Entenda que ACF mede a dependência linear em diferentes lags.",
                                    "Discuta a estacionariedade como pré-requisito para ACF confiável.",
                                    "Identifique os limites de confiança aproximados: ±1.96/√n para 95%."
                                  ],
                                  "verification": "Explique a fórmula ACF verbalmente e calcule manualmente γ_0 para uma série de exemplo.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Fórmula ACF impressa",
                                    "Exemplo de série temporal (e.g., [1,2,3,2,1])",
                                    "Calculadora"
                                  ],
                                  "tips": [
                                    "Comece com séries estacionárias para evitar viés.",
                                    "Visualize lags como deslocamentos temporais."
                                  ],
                                  "learningObjective": "Dominar a definição matemática e interpretação inicial da ACF.",
                                  "commonMistakes": [
                                    "Esquecer de centralizar a série (subtrair μ)",
                                    "Confundir ACF com PACF",
                                    "Ignorar normalização pela variância"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar Cálculo Manual dos Coeficientes ACF",
                                  "subSteps": [
                                    "Centralize a série: x_t' = x_t - μ.",
                                    "Calcule γ_1 = (1/n) Σ (x_t' * x_{t+1}') para lag 1.",
                                    "Calcule ρ_1 = γ_1 / γ_0.",
                                    "Repita para lag 2: γ_2 e ρ_2.",
                                    "Verifique se |ρ_k| ≤ 1."
                                  ],
                                  "verification": "Calcule ACF(1) e ACF(2) para série [10,12,11,13,12,11] e confira resultados.",
                                  "estimatedTime": "30-40 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Planilha Excel para cálculos",
                                    "Série temporal de exemplo"
                                  ],
                                  "tips": [
                                    "Use somas parciais para evitar erros aritméticos.",
                                    "Arredonde para 4 casas decimais."
                                  ],
                                  "learningObjective": "Executar cálculo manual preciso de ACF para lags iniciais.",
                                  "commonMistakes": [
                                    "Não centralizar dados",
                                    "Dividir por (n-k) em vez de n",
                                    "Erros em multiplicações cruzadas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Cálculo Computacional em R",
                                  "subSteps": [
                                    "Instale/carregue pacotes: library(forecast) ou base R.",
                                    "Crie vetor da série: ts_data <- c(10,12,11,13,12,11).",
                                    "Execute acf(ts_data, lag.max=5, plot=FALSE) para obter coeficientes.",
                                    "Plote: acf(ts_data, lag.max=5).",
                                    "Extraia valores: acf_values <- acf(ts_data)$acf."
                                  ],
                                  "verification": "Gere output de acf() e compare com cálculo manual (tolerância 0.01).",
                                  "estimatedTime": "25-30 minutos",
                                  "materials": [
                                    "R e RStudio instalados",
                                    "Script R preparado"
                                  ],
                                  "tips": [
                                    "Use plot=FALSE para inspecionar valores numéricos primeiro.",
                                    "Defina lag.max adequadamente (e.g., 10 para n>50)."
                                  ],
                                  "learningObjective": "Usar função acf() do R para automação de cálculos ACF.",
                                  "commonMistakes": [
                                    "Não converter para ts object se necessário",
                                    "Confundir acf$acf com lags",
                                    "Ignorar parâmetro type='correlation'"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Incorporar e Interpretar Limites de Confiança de 95%",
                                  "subSteps": [
                                    "Calcule limite teórico: ci <- qnorm(0.975)/sqrt(length(ts_data)).",
                                    "Adicione bandas ao plot: acf(ts_data, plot=TRUE, ylim=c(-1,1)).",
                                    "Identifique lags significativos: |ACF(k)| > ci.",
                                    "Compare manual vs. R: adicione ci manualmente.",
                                    "Interprete: lags dentro de ci são insignificantes (ruído branco)."
                                  ],
                                  "verification": "Produza plot ACF com bandas de 95% e liste lags significativos.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "R script com dados",
                                    "Documentação acf()"
                                  ],
                                  "tips": [
                                    "Para séries longas, use ±2/sqrt(n) como aproximação rápida.",
                                    "Sempre plote para visualização intuitiva."
                                  ],
                                  "learningObjective": "Avaliar significância estatística dos coeficientes ACF.",
                                  "commonMistakes": [
                                    "Usar t-distribution em vez de normal",
                                    "Aplicar ci a lags altos sem ajuste",
                                    "Interpretar todos lags como significativos"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Comparar Resultados Manual vs. Computacional",
                                  "subSteps": [
                                    "Compare ρ_1 manual e R para múltiplas séries.",
                                    "Teste com série não estacionária e observe viés.",
                                    "Gere relatório: tabela com lags, ACF, ci, significância.",
                                    "Simule ruído branco: verifique se todos ACF dentro de ci.",
                                    "Documente discrepâncias e razões (e.g., arredondamento)."
                                  ],
                                  "verification": "Crie tabela comparativa com erro <0.05 e interpretação coerente.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "R script completo",
                                    "Tabela Excel para comparação"
                                  ],
                                  "tips": [
                                    "Use all=FALSE em acf() para foco em correlação.",
                                    "Valide com pacotes como tseries."
                                  ],
                                  "learningObjective": "Garantir consistência entre métodos e interpretação robusta.",
                                  "commonMistakes": [
                                    "Ignorar diferenças devido a amostragem finita",
                                    "Não testar com ruído branco",
                                    "Sobreinterpretar pequenos desvios"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a série temporal de temperaturas diárias [22, 24, 23, 25, 24, 22, 21, 23]: Calcule manualmente ACF(1) ≈ 0.75 (significativo), use R acf() para confirmar e plote com ci ≈ ±0.8, identificando dependência de lag 1 (padrão diário).",
                              "finalVerifications": [
                                "Cálculo manual de ACF(1) e ACF(2) coincide com R (erro <0.01).",
                                "Plot ACF gerado com bandas de 95% corretas.",
                                "Identificação precisa de 2-3 lags significativos.",
                                "Tabela de resultados com lags, valores, ci e significância.",
                                "Explicação verbal de pelo menos um padrão detectado.",
                                "Teste com ruído branco: nenhum lag significativo."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos manuais (90%+ acurácia).",
                                "Correto uso de acf() com parâmetros apropriados.",
                                "Interpretação estatística válida dos limites de confiança.",
                                "Comparação consistente entre métodos manuais e R.",
                                "Clareza na documentação e visualizações.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Programação em R (Ciência da Computação).",
                                "Estatística Inferencial (Testes de Hipótese).",
                                "Análise Financeira (Modelagem ARIMA).",
                                "Machine Learning (Feature Engineering em Séries Temporais).",
                                "Econometria (Detecção de Autocorrelação em Resíduos)."
                              ],
                              "realWorldApplication": "Em previsão de demanda de varejo, calcular ACF em vendas semanais detecta sazonalidade (e.g., lag 7 para semanal), permitindo modelos ARIMA precisos e otimização de estoque, reduzindo custos em 10-20%."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.3",
                            "name": "Construir e interpretar gráfico de ACF",
                            "description": "Gerar o gráfico de barras da ACF, identificar decaimento lento (indicando não-estacionariedade), cortes abruptos (modelos MA) ou decaimento exponencial (modelos AR), e detectar dependências temporais sazonais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e os dados para análise de ACF",
                                  "subSteps": [
                                    "Carregue a biblioteca necessária (ex: statsmodels.tsa.stattools no Python).",
                                    "Importe o conjunto de dados de série temporal (ex: AirPassengers ou dados personalizados).",
                                    "Verifique e limpe os dados: remova valores ausentes e confirme estacionariedade inicial com teste ADF se necessário.",
                                    "Transforme os dados em um objeto de série temporal (pd.Series com índice datetime).",
                                    "Defina parâmetros iniciais como lags máximos (ex: 20 ou 10% do tamanho da série)."
                                  ],
                                  "verification": "Dados carregados sem erros, shape e índice datetime confirmados via print(df.head()) e df.info().",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Python com pandas, statsmodels, matplotlib; dataset de série temporal (ex: CSV de vendas mensais).",
                                  "tips": "Use seed para reprodutibilidade em simulações; sempre plote a série original primeiro para visualização.",
                                  "learningObjective": "Configurar corretamente o ambiente computacional para computação de ACF.",
                                  "commonMistakes": "Esquecer de converter índice para datetime, levando a erros em lags; ignorar missing values que distorcem autocorrelações."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar o gráfico de barras da ACF",
                                  "subSteps": [
                                    "Calcule a ACF usando acf() do statsmodels com lags especificados.",
                                    "Plote o gráfico com plot_acf() ou manualmente com stem plot via matplotlib.",
                                    "Adicione linha de significância (confidence interval de 95%).",
                                    "Personalize o gráfico: título 'Gráfico de ACF', rótulos de eixo, grid.",
                                    "Salve ou exiba o gráfico para inspeção."
                                  ],
                                  "verification": "Gráfico exibido com barras de autocorrelação, bandas de confiança azuis e lags no eixo x.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Código Python pronto; Jupyter Notebook para visualização interativa.",
                                  "tips": "Defina lags = min(40, len(data)//5) para séries curtas; use alpha=0.05 para bandas.",
                                  "learningObjective": "Produzir visualização precisa da função de autocorrelação.",
                                  "commonMistakes": "Usar lags excessivos causando ruído; não incluir bandas de confiança, levando a falsos positivos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar padrões de decaimento e cortes no gráfico de ACF",
                                  "subSteps": [
                                    "Observe decaimento lento: barras acima da banda de confiança por muitos lags (não-estacionariedade).",
                                    "Identifique cortes abruptos: barras significativas até lag q, depois insignificantes (modelo MA(q)).",
                                    "Detecte decaimento exponencial ou sinusoidal: barras decrescendo gradualmente (modelo AR(p)).",
                                    "Anote lags significativos e compare com bandas de confiança.",
                                    "Registre observações em um dicionário ou tabela para relatório."
                                  ],
                                  "verification": "Lista de padrões identificados com lags específicos e justificativa baseada em bandas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Gráfico de ACF gerado; régua ou zoom no plot para precisão.",
                                  "tips": "Foque nos primeiros 10-15 lags; ignore lags muito altos por baixa confiabilidade.",
                                  "learningObjective": "Reconhecer assinaturas visuais de processos AR, MA e não-estacionários.",
                                  "commonMistakes": "Confundir flutuações aleatórias com padrões reais; interpretar barras dentro da banda como significativas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Detectar e interpretar dependências sazonais na ACF",
                                  "subSteps": [
                                    "Procure picos repetitivos em lags múltiplos de sazonalidade (ex: lag 12 para mensal).",
                                    "Compare amplitude dos picos sazonais com decaimento geral.",
                                    "Diferencie sazonalidade de não-estacionariedade: picos persistentes vs. decaimento lento uniforme.",
                                    "Sugira transformações (diferenciação sazonal) se detectado.",
                                    "Documente interpretação completa: tipo de modelo sugerido (SARIMA) e próximos passos."
                                  ],
                                  "verification": "Relatório escrito com detecção de sazonalidade (sim/não), período e implicações para modelagem.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Gráfico de ACF; conhecimento de períodos sazonais comuns (12 mensal, 4 trimestral).",
                                  "tips": "Sobreponha gráfico da série original para validar sazonalidade visual.",
                                  "learningObjective": "Diagnosticar componentes sazonais via padrões cíclicos na ACF.",
                                  "commonMistakes": "Atribuir sazonalidade a ruído; ignorar múltiplos picos fracos como ausência de sazonalidade."
                                }
                              ],
                              "practicalExample": "Usando dados de passageiros aéreos (AirPassengers.csv): gere ACF, observe decaimento lento e picos em lags 12, 24 (não-estacionariedade + sazonalidade anual), sugerindo modelo SARIMA(1,1,1)(1,1,1)12.",
                              "finalVerifications": [
                                "Gráfico de ACF gerado com lags corretos e bandas de confiança.",
                                "Identificação precisa de decaimento lento indicando não-estacionariedade.",
                                "Detecção de cortes abruptos ou decaimento exponencial para AR/MA.",
                                "Picos sazonais anotados com lags e períodos.",
                                "Interpretação alinhada com teoria de Box-Jenkins.",
                                "Relatório com sugestões de modelagem."
                              ],
                              "assessmentCriteria": [
                                "Precisão na geração do gráfico (visual e técnica).",
                                "Correta identificação de pelo menos 3 padrões principais (decaimento, cortes, sazonal).",
                                "Justificativas baseadas em bandas de confiança e lags.",
                                "Profundidade da interpretação com ligações a modelos ARIMA.",
                                "Clareza e completude do relatório final.",
                                "Eficiência temporal e ausência de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Correlação e funções estatísticas.",
                                "Programação: Manipulação de dados com Python/pandas.",
                                "Economia: Previsão de séries temporais em finanças.",
                                "Ciência de Dados: Diagnóstico em machine learning para forecasting."
                              ],
                              "realWorldApplication": "Em finanças, analisar ACF de retornos de ações para detectar dependências temporais e escolher modelos ARIMA para previsão de preços; em meteorologia, identificar sazonalidade em temperaturas para alertas climáticos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.3.2",
                        "name": "Função de Autocorrelação Parcial (PACF)",
                        "description": "A Função de Autocorrelação Parcial (PACF) mede a correlação entre valores da série defasados por k períodos, removendo os efeitos de defasagens intermediárias, essencial para identificação de ordens em modelos AR.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.2.1",
                            "name": "Definir e formular a PACF",
                            "description": "Descrever a PACF como coeficientes de regressão em um modelo AR(k), com fórmula φ_{k,k} obtida por equações de Yule-Walker ou método de Levinson-Durbin, diferenciando de ACF.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de ACF e Modelos AR",
                                  "subSteps": [
                                    "Relembre a definição de Função de Autocorrelação (ACF) como correlação entre a série e seus lags.",
                                    "Entenda modelos AR(k): Y_t = φ1 Y_{t-1} + ... + φk Y_{t-k} + ε_t.",
                                    "Calcule ACF manualmente para uma série simples de lag 1 e 2.",
                                    "Identifique limitações da ACF para identificação de ordem de modelo AR.",
                                    "Pratique plotando ACF de uma série AR(1) simulada."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre correlação simples e parcial; forneça fórmula básica de ACF.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Séries Temporais (cap. ACF)",
                                    "Python/R com pacotes statsmodels ou forecast",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": [
                                    "Comece com séries estacionárias para evitar confusões.",
                                    "Use plots para visualização intuitiva.",
                                    "Simule dados AR(1) com φ=0.5."
                                  ],
                                  "learningObjective": "Compreender a base conceitual necessária para PACF, diferenciando de ACF.",
                                  "commonMistakes": [
                                    "Confundir ACF com PACF prematuramente.",
                                    "Ignorar estacionariedade da série.",
                                    "Não normalizar correlações."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir PACF Conceitualmente como Coeficientes de Regressão",
                                  "subSteps": [
                                    "Defina PACF φ_{k,k} como o coeficiente de Y_{t-k} em regressão de Y_t sobre Y_{t-1} até Y_{t-k}.",
                                    "Interprete como correlação parcial, controlando lags intermediários.",
                                    "Derive intuitivamente para k=1 (φ_{1,1} = ρ_1 = ACF(1)).",
                                    "Para k=2, mostre regressão Y_t = φ_{2,1} Y_{t-1} + φ_{2,2} Y_{t-2} + ε.",
                                    "Compare com correlação simples (ACF)."
                                  ],
                                  "verification": "Escreva a equação de regressão para AR(2) e identifique φ_{2,2} como PACF(2).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula sobre regressão múltipla",
                                    "Software estatístico para regressão stepwise"
                                  ],
                                  "tips": [
                                    "Pense em termos de 'efeito direto' vs. indireto.",
                                    "Use analogia com regressão linear múltipla.",
                                    "Desenhe diagramas de dependência."
                                  ],
                                  "learningObjective": "Formular PACF como φ_{k,k} em modelo AR(k).",
                                  "commonMistakes": [
                                    "Confundir φ_{k,j} para j<k com PACF.",
                                    "Não controlar lags intermediários.",
                                    "Assumir PACF = ACF para todos os lags."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Equações de Yule-Walker para PACF",
                                  "subSteps": [
                                    "Estude as equações de Yule-Walker: ρ_k = φ_{k,1} ρ_1 + ... + φ_{k,k} ρ_{k-k+1} para k=1 a p.",
                                    "Resolva sistema para k=1: φ_{1,1} = ρ_1.",
                                    "Para k=2, resolva matriz 2x2: [ρ1 ρ0; ρ2 ρ1] [φ21; φ22] = [ρ1; ρ2].",
                                    "Calcule numericamente para uma ACF hipotética (ρ1=0.6, ρ2=0.3).",
                                    "Verifique que φ_{k,k} é a PACF(k)."
                                  ],
                                  "verification": "Resolva Yule-Walker para AR(2) e isole φ_{2,2}; confira com software.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Matriz de correlação",
                                    "Calculadora ou Python numpy.linalg.solve",
                                    "Exemplos resolvidos"
                                  ],
                                  "tips": [
                                    "Use forma matricial para eficiência.",
                                    "Verifique simetria da matriz Toeplitz.",
                                    "Comece com k pequeno."
                                  ],
                                  "learningObjective": "Aplicar Yule-Walker para obter φ_{k,k}.",
                                  "commonMistakes": [
                                    "Erro na indexação de lags.",
                                    "Não dividir por variância (ρ0=1).",
                                    "Sistema não resolvido corretamente."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Introduzir Método de Levinson-Durbin para Cálculo Eficiente",
                                  "subSteps": [
                                    "Entenda recursão de Levinson-Durbin: φ_{k,k} = (ρ_k - ∑_{j=1}^{k-1} φ_{k-1,j} ρ_{k-j}) / (1 - ∑_{j=1}^{k-1} φ_{k-1,j} ρ_j).",
                                    "Implemente recursivamente para k=1 a 3 com ACF exemplo.",
                                    "Compare resultados com Yule-Walker direto.",
                                    "Discuta vantagens: O(n^2) vs O(n^3), numérica estável.",
                                    "Gere PACF plot usando função pronta em software."
                                  ],
                                  "verification": "Implemente algoritmo em código e reproduza φ_{k,k} para série conhecida.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Pseudocódigo Levinson-Durbin",
                                    "Python/R implementação",
                                    "Série temporal simulada AR(2)"
                                  ],
                                  "tips": [
                                    "Teste com ρ_k decaindo exponencialmente.",
                                    "Debug passo a passo.",
                                    "Use loops for eficiência."
                                  ],
                                  "learningObjective": "Formular e computar PACF via Levinson-Durbin.",
                                  "commonMistakes": [
                                    "Erro no denominador recursivo.",
                                    "Índices off-by-one.",
                                    "Não inicializar φ_{1,1} corretamente."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Diferenciar PACF de ACF e Interpretar",
                                  "subSteps": [
                                    "Liste diferenças: PACF corta após ordem p em AR(p), ACF decai gradualmente.",
                                    "Interprete spikes em PACF para identificação de modelo.",
                                    "Calcule ambos para série MA(1) vs AR(2).",
                                    "Pratique identificação: PACF significativo em lag 2 → AR(2).",
                                    "Resuma fórmula geral: φ_{k,k} via YW ou LD."
                                  ],
                                  "verification": "Compare plots ACF/PACF de simulações AR/MA e identifique corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Funções acf/pacf em statsmodels",
                                    "Dados simulados variados"
                                  ],
                                  "tips": [
                                    "Sempre plote juntos.",
                                    "Confie em intervalos de confiança.",
                                    "Memorize padrões clássicos."
                                  ],
                                  "learningObjective": "Diferenciar PACF de ACF na formulação e uso prático.",
                                  "commonMistakes": [
                                    "Interpretar decaimento ACF como corte PACF.",
                                    "Ignorar significância estatística.",
                                    "Confundir em não-estacionárias."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma série temporal de vendas mensais de varejo (e.g., dados simulados AR(2) com φ1=0.5, φ2=0.3). Calcule ACF até lag 10, resolva Yule-Walker para φ_{2,2} ≈0.3, use Levinson-Durbin para confirmar, plote PACF mostrando corte após lag 2, diferenciando do decaimento ACF.",
                              "finalVerifications": [
                                "Defina corretamente PACF como φ_{k,k} em AR(k).",
                                "Escreva equações Yule-Walker para k=2.",
                                "Implemente recursão Levinson-Durbin para 3 lags.",
                                "Diferencie PACF (corte em AR(p)) de ACF (decaimento).",
                                "Identifique ordem AR de um plot PACF simulado.",
                                "Calcule manualmente para ACF simples (ρ1=0.8, ρ2=0.5)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação φ_{k,k} (100%).",
                                "Correta derivação Yule-Walker (matriz resolvida).",
                                "Implementação numérica Levinson-Durbin sem erros.",
                                "Interpretação qualitativa ACF vs PACF.",
                                "Uso prático em identificação de modelo.",
                                "Clareza em explicações e exemplos."
                              ],
                              "crossCurricularConnections": [
                                "Econometria: Identificação ARIMA em previsão econômica.",
                                "Machine Learning: Features em modelos de séries temporais (LSTM/ARIMA).",
                                "Física: Análise de sinais oscilatórios (e.g., sismologia).",
                                "Engenharia: Controle de processos com dependência temporal.",
                                "Finanças: Modelagem de retornos de ações."
                              ],
                              "realWorldApplication": "Em previsão de demanda de energia elétrica, use PACF para identificar ordem AR(2) em série horária, ajustando modelo para forecasts precisos e otimizando alocação de recursos em redes elétricas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.2.2",
                            "name": "Calcular coeficientes de autocorrelação parcial",
                            "description": "Computar os coeficientes PACF manualmente para pequenas ordens e via software R (função pacf()), interpretando zeros fora dos limites de confiança como não significativos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar dados da série temporal e revisar teoria da PACF",
                                  "subSteps": [
                                    "Selecione ou gere uma série temporal estacionária com pelo menos 50 observações (ex: simule AR(2) process).",
                                    "Calcule a média da série e centre os dados subtraindo-a (demean).",
                                    "Revise equações Yule-Walker para PACF: para lag k, resolva sistema de autocorrelações.",
                                    "Defina limites de confiança aproximados: ±1.96 / sqrt(n) para significância ao nível 5%.",
                                    "Documente propriedades esperadas da série (ex: spikes em lags específicos)."
                                  ],
                                  "verification": "Dados centrados salvos em vetor ou CSV; resumo teórico escrito com limites de confiança calculados.",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "Software R ou Python instalado",
                                    "Série temporal de exemplo (CSV)",
                                    "Papel/caneta para anotações",
                                    "Documentação pacf() do R"
                                  ],
                                  "tips": "Use séries simuladas conhecidas para validar resultados iniciais.",
                                  "learningObjective": "Compreender preparação de dados e fundamentos teóricos da PACF.",
                                  "commonMistakes": [
                                    "Esquecer de centrar os dados",
                                    "Não verificar estacionariedade básica",
                                    "Confundir PACF com ACF simples"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular coeficientes PACF manualmente para lag 1",
                                  "subSteps": [
                                    "Calcule autocorrelação lag 1 (ρ1) como covariância lag 1 dividida pela variância.",
                                    "Note que para lag 1, PACF(1) = ρ1 (sem lags intermediários).",
                                    "Calcule limite de confiança: 1.96 / sqrt(n).",
                                    "Compare φ11 com limite e anote se significativo.",
                                    "Repita com fórmula explícita: φ11 = γ1 / γ0."
                                  ],
                                  "verification": "Valor de PACF(1) calculado e comparado ao limite, registrado em tabela.",
                                  "estimatedTime": "20 minutes",
                                  "materials": [
                                    "Calculadora ou Excel",
                                    "Dados centrados da Step 1",
                                    "Fórmulas Yule-Walker impressas"
                                  ],
                                  "tips": "Para AR(1), PACF(1) deve ser próximo de ρ1; valide com isso.",
                                  "learningObjective": "Executar cálculo manual preciso para PACF de baixa ordem.",
                                  "commonMistakes": [
                                    "Dividir por n em vez de n-k para covariâncias",
                                    "Ignorar sinal do coeficiente",
                                    "Usar dados não centrados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular PACF manualmente para lag 2 e via função pacf() no R",
                                  "subSteps": [
                                    "Calcule ρ2 e resolva sistema Yule-Walker: [γ0 γ1; γ1 γ0] [φ21; φ22] = [γ2; γ1].",
                                    "Inverta matriz 2x2 e multiplique para obter φ21 e φ22.",
                                    "No R: instale/load tsibble ou base R, crie ts object, execute pacf(serie, lag.max=10, plot=FALSE).",
                                    "Extraia coeficientes com $acf e compare com manual.",
                                    "Gere plot com ci=TRUE para visualização."
                                  ],
                                  "verification": "Tabela comparando manual vs R; gráfico PACF salvo.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "RStudio",
                                    "Script R preparado",
                                    "Matriz invertida manualmente verificada"
                                  ],
                                  "tips": "Use solve() no R para validar inversão manual da matriz.",
                                  "learningObjective": "Dominar cálculo matricial para lag 2 e integração com R.",
                                  "commonMistakes": [
                                    "Erro na inversão de matriz (determinante)",
                                    "pacf() com lag.max baixo",
                                    "Não plotar confidence intervals"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar coeficientes PACF e verificar significância",
                                  "subSteps": [
                                    "Identifique coeficientes fora dos limites de confiança como não significativos (≈0).",
                                    "Para AR(p), espere spikes significativos até lag p, depois zeros.",
                                    "Anote lags significativos e sugira ordem AR possível.",
                                    "Compare interpretação manual vs R plot.",
                                    "Teste com outra série para generalizar."
                                  ],
                                  "verification": "Relatório de interpretação escrito, destacando lags não significativos.",
                                  "estimatedTime": "25 minutes",
                                  "materials": [
                                    "Gráficos PACF do R",
                                    "Tabela de coeficientes",
                                    "Notas de Steps anteriores"
                                  ],
                                  "tips": "Lags cortados após primeiros zeros indicam ordem do modelo AR.",
                                  "learningObjective": "Interpretar PACF corretamente para modelagem de séries.",
                                  "commonMistakes": [
                                    "Considerar todos lags como significativos",
                                    "Ignorar assimetria em limites",
                                    "Confundir com ACF spikes"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando série temporal de vendas mensais de 60 meses (ex: vendas = arima.sim(model=list(ar=c(0.6, -0.3)), n=60)): calcule manualmente PACF(1)=0.6, PACF(2)=-0.3; no R, pacf(vendas) mostra spikes em lag1 e lag2 dentro de limites, zeros após, confirmando AR(2).",
                              "finalVerifications": [
                                "Cálculos manuais coincidem com pacf() R em pelo menos 3 casas decimais.",
                                "Gráfico PACF gerado com confidence intervals corretos.",
                                "Identificados corretamente lags significativos/não significativos.",
                                "Limites de confiança calculados precisamente (±1.96/sqrt(n)).",
                                "Sugestão de ordem AR baseada em corte de PACF justificada.",
                                "Validação com segunda série temporal realizada."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos manuais (erro <0.01).",
                                "Correto uso e interpretação de pacf() no R.",
                                "Identificação precisa de zeros não significativos.",
                                "Clareza na comparação manual vs software.",
                                "Relatório de interpretação lógico e completo.",
                                "Validação cruzada com exemplos múltiplos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Sistemas lineares e álgebra matricial (Yule-Walker).",
                                "Programação: Scripting em R para análise estatística.",
                                "Economia/Finanças: Modelagem de séries temporais para previsões econômicas.",
                                "Engenharia: Análise de sinais em controle de processos.",
                                "Ciência de Dados: Preparação e visualização de dados temporais."
                              ],
                              "realWorldApplication": "Em finanças, calcular PACF de retornos de ações para determinar ordem de modelos ARIMA em previsões de risco; em meteorologia, identificar lags significativos em temperaturas para modelos de previsão climática curta; em supply chain, analisar padrões de demanda para otimizar estoques."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.2.3",
                            "name": "Construir e interpretar gráfico de PACF",
                            "description": "Produzir o gráfico PACF, reconhecer corte abrupto após ordem p (modelo AR(p)), persistência (não-estacionariedade) ou decaimento em sinuosidade (modelos MA), para detecção de dependências temporais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a Série Temporal para Análise PACF",
                                  "subSteps": [
                                    "Carregue um dataset de série temporal univariada (ex: dados mensais de vendas ou temperatura).",
                                    "Plote a série temporal original para visualizar padrões, sazonalidade ou tendências.",
                                    "Teste estacionariedade inicial usando teste de Dickey-Fuller (ADF) ou inspeção visual.",
                                    "Aplique diferenciação se necessário para tornar a série aproximadamente estacionária.",
                                    "Defina o número de lags a considerar (ex: 20-30 lags para inspeção inicial)."
                                  ],
                                  "verification": "A série está plotada, estacionariedade testada e dados prontos para PACF sem erros de carregamento.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python com bibliotecas: pandas, matplotlib, statsmodels",
                                    "Dataset exemplo: AirPassengers ou série sintética"
                                  ],
                                  "tips": "Sempre padronize a frequência temporal (diária, mensal) e remova valores ausentes antes.",
                                  "learningObjective": "Preparar adequadamente uma série temporal para cálculo confiável de PACF.",
                                  "commonMistakes": [
                                    "Ignorar não-estacionariedade, levando a PACF enviesado",
                                    "Usar lags insuficientes, mascarando padrões"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular e Gerar o Gráfico PACF",
                                  "subSteps": [
                                    "Importe a função plot_pacf de statsmodels.graphics.tsaplots.",
                                    "Execute plot_pacf(série, lags=20) para calcular e plotar o PACF.",
                                    "Adicione bandas de confiança (95% por padrão) e personalize lags se necessário.",
                                    "Salve ou exiba o gráfico com títulos claros: 'Gráfico PACF da Série'.",
                                    "Compare visualmente com o gráfico ACF gerado previamente."
                                  ],
                                  "verification": "Gráfico PACF é gerado corretamente com barras decaindo dentro das bandas azuis para lags altos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Jupyter Notebook ou script Python",
                                    "Biblioteca statsmodels instalada"
                                  ],
                                  "tips": "Use lags=2*int(np.log(len(série))) como heurística para número de lags.",
                                  "learningObjective": "Dominar o cálculo e visualização prática do PACF em software estatístico.",
                                  "commonMistakes": [
                                    "Confundir PACF com ACF",
                                    "Não incluir bandas de confiança, levando a interpretações erradas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Padrões Visuais no Gráfico PACF",
                                  "subSteps": [
                                    "Observe barras significativas (fora das bandas) nos primeiros lags.",
                                    "Identifique 'corte abrupto': pico significativo até lag p, depois insignificantes (AR(p)).",
                                    "Detecte 'persistência': todas barras significativas sem corte (não-estacionariedade).",
                                    "Note 'decaimento sinuoso': barras alternando sinal e decaimento lento (MA(q)).",
                                    "Anote lags significativos e compare com teoria ARIMA."
                                  ],
                                  "verification": "Lista de padrões observados (corte, persistência ou sinuosidade) anotada corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráfico PACF gerado no step anterior",
                                    "Papel ou notebook para anotações"
                                  ],
                                  "tips": "Foque nos primeiros 10-15 lags; lags altos >0.05 indicam problema.",
                                  "learningObjective": "Reconhecer visualmente os três padrões principais do PACF para identificação de modelos.",
                                  "commonMistakes": [
                                    "Interpretar ruído como sinal significativo",
                                    "Ignorar sinal alternado em MA"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar PACF para Detecção de Dependências Temporais",
                                  "subSteps": [
                                    "Baseado no padrão, sugira ordem p para AR(p) ou q para MA(q).",
                                    "Valide com modelo ARIMA provisório e compare AIC.",
                                    "Discuta implicações: AR para dependência curta, MA para choques passados.",
                                    "Documente interpretação em relatório: 'PACF sugere AR(2) devido a corte após lag 2'.",
                                    "Teste em outra série para prática comparativa."
                                  ],
                                  "verification": "Interpretação escrita matches padrões teóricos e sugere modelo coerente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "statsmodels para fit ARIMA",
                                    "Relatório template Markdown"
                                  ],
                                  "tips": "Combine sempre com ACF para confirmação cruzada de modelo.",
                                  "learningObjective": "Aplicar interpretação PACF para seleção de parâmetros em modelos de séries temporais.",
                                  "commonMistakes": [
                                    "Selecionar p alto sem corte claro",
                                    "Desconsiderar contexto da série (ex: sazonal)"
                                  ]
                                },
                                {
                                  "practicalExample": "Usando dataset AirPassengers (passageiros aéreos 1949-1960): Gere PACF da série diferenciada 1x. Observe persistência em lags baixos sem corte abrupto, indicando necessidade de mais diferenciação (não-estacionariedade); após 2x diff, corte após lag 1 sugere AR(1). Código: from statsmodels.graphics.tsaplots import plot_pacf; plot_pacf(np.diff(airpassengers,2), lags=20).",
                                  "finalVerifications": [
                                    "Gera PACF corretamente para série dada.",
                                    "Identifica corte abrupto após lag p em exemplo AR(p).",
                                    "Reconhece persistência em série não-estacionária.",
                                    "Detecta decaimento sinuoso em MA(q).",
                                    "Sugere ordens de modelo baseadas em PACF com justificativa."
                                  ],
                                  "assessmentCriteria": [
                                    "Precisão na geração do gráfico (100% match com esperado).",
                                    "Correta identificação de pelo menos 3 padrões clássicos.",
                                    "Interpretação coerente com teoria ARIMA (sem contradições).",
                                    "Uso adequado de lags e bandas de confiança.",
                                    "Relatório claro com evidências visuais."
                                  ],
                                  "crossCurricularConnections": [
                                    "Matemática: Álgebra linear em estimação de coeficientes parciais.",
                                    "Programação: Manipulação de dados em Python/R para séries temporais.",
                                    "Economia: Previsão de vendas ou PIB via ARIMA.",
                                    "Física: Modelagem de sinais temporais em oscilações.",
                                    "Machine Learning: Feature engineering com lags para forecasting."
                                  ],
                                  "realWorldApplication": "Em finanças, analistas usam PACF de retornos de ações para detectar ordem AR(p) e modelar dependências temporais, melhorando previsões de risco e portfólios; ex: PACF de Bitcoin mostra MA(1) para choques de mercado.",
                                  "stepNumber": "5",
                                  "title": "Identificação de Ordens ARIMA usando PACF e Differencing",
                                  "subSteps": [
                                    "Carregar o dataset AirPassengers e visualizar série original",
                                    "Aplicar diferenciação 1x e plotar PACF para detectar não-estacionariedade",
                                    "Aplicar diferenciação 2x e plotar PACF para identificar ordem AR(p)",
                                    "Interpretar padrões de corte abrupto e decaimento nos gráficos",
                                    "Sugerir ordens ARIMA (p,d,q) com base na análise dos gráficos"
                                  ],
                                  "verification": "O aluno deve gerar gráficos PACF corretos para série diferenciada 1x e 2x, identificar persistência em lags baixos como indício de não-estacionariedade, detectar corte abrupto após lag 1 na série 2x diferenciada como evidência de AR(1), e justificar a escolha de ordens ARIMA com base nos padrões observados.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python/R ambiente de programação",
                                    "Bibliotecas: statsmodels, matplotlib/seaborn",
                                    "Dataset AirPassengers (disponível em statsmodels ou CSV)",
                                    "Jupyter Notebook ou script de código",
                                    "Guia de referência de funções plot_pacf e diff"
                                  ],
                                  "tips": [
                                    "Use bandas de confiança (alpha=0.05) para interpretar significância dos lags",
                                    "Compare sempre PACF com ACF para confirmar padrões (ex: decaimento sinuoso em MA)",
                                    "Teste múltiplas diferenciações até alcançar estacionariedade visual",
                                    "Documente cada etapa com anotações claras no código",
                                    "Valide resultados com testes de estacionariedade (ADF) após diferenciação"
                                  ],
                                  "learningObjective": "Interpretar gráficos PACF para determinar ordens p e d em modelos ARIMA, aplicando diferenciação adequada para alcançar estacionariedade e justificando escolhas teóricas com evidências visuais.",
                                  "commonMistakes": [
                                    "Confundir padrões de PACF com ACF (ex: interpretar decaimento como AR ao invés de MA)",
                                    "Ignorar bandas de confiança e sobreinterpretar lags não significativos",
                                    "Aplicar diferenciação excessiva sem verificar estacionariedade",
                                    "Não considerar tendência sazonal no dataset AirPassengers",
                                    "Relatar ordens sem justificar com evidências gráficas"
                                  ]
                                }
                              ],
                              "practicalExample": "Utilize o dataset de temperatura média mensal de São Paulo (1970-2023). Após verificação de estacionariedade e diferenciação 1x, gere o PACF. Observação: decaimento sinuoso nos lags 1-3 indica componente MA(3); após ajuste por tendência sazonal (diferenciação 12x), corte abrupto após lag 2 sugere AR(2). Código Python: `diff_temp = np.diff(temp_series, 12); plot_pacf(diff_temp, lags=20)` com bandas de confiança ajustadas para alpha=0.05.",
                              "finalVerifications": [
                                "Gráfico PACF gerado com bandas de confiança corretas e rótulos claros para série diferenciada.",
                                "Identificação precisa de pelo menos três padrões clássicos (corte abrupto, decaimento sinuoso, persistência) com evidências visuais.",
                                "Correlação entre padrão observado e sugestão de ordem AR/MA validada por modelo ARIMA inicial (AIC/BIC).",
                                "Análise de lags significativos acima de 0.05 rejeitada como ruído, com justificativa estatística.",
                                "Relatório escrito conectando padrões PACF ao contexto da série (ex: 'Decaimento sinuoso em lags 1-3 indica choques persistentes em temperatura')."
                              ],
                              "assessmentCriteria": [
                                "Precisão gráfica: alinhamento 100% entre PACF gerado e expectativas teóricas para série teste.",
                                "Identificação de pelo menos 4 padrões distintos com descrição detalhada de lags críticos.",
                                "Seleção de ordens AR/MA coerente com teoria e validada por métricas AIC/BIC (<5% de erro relativo).",
                                "Uso correto de parâmetros (lags=2*int(np.log(n)), alpha=0.05) e interpretação das bandas de confiança.",
                                "Relatório final com visualizações anotadas, conclusões estatísticas e aplicação prática ao contexto da série."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Produção: Otimização de inventário via modelagem ARIMA de demanda com base em PACF.",
                                "Ciência de Dados: Feature engineering para modelos de machine learning usando lags significativos do PACF.",
                                "Economia e Negócios: Análise de ciclos econômicos (PIB, inflação) para políticas fiscais usando dependências temporais.",
                                "Meteorologia: Previsão de padrões climáticos através de séries de precipitação com identificação de AR/MA.",
                                "Ciência da Computação: Implementação de algoritmos de PACF em linguagens de programação para Otimização de Algoritmos."
                              ],
                              "realWorldApplication": "Em saúde pública, epidemiologistas aplicam PACF a séries de casos de doenças infecciosas (ex: COVID-19) para detectar dependências temporais. Um PACF com corte abrupto após lag 2 em dados diários de internações sugere modelo AR(2), permitindo prever picos futuros e alocar recursos hospitalares com precisão, como feito pelo Ministério da Saúde em 2021 durante a segunda onda da pandemia."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.4",
                    "name": "Testes Exploratórios de Estacionariedade",
                    "description": "Análise visual e estatística inicial para verificar propriedades de estacionariedade em séries temporais.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.4.1",
                        "name": "Análise Visual de Estacionariedade",
                        "description": "Utilização de gráficos para inspeção inicial das propriedades de estacionariedade, identificando tendências, sazonalidade e variações na média e variância ao longo do tempo.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.1.1",
                            "name": "Construir e interpretar gráfico da série temporal original",
                            "description": "Gerar plot da série temporal e analisar visualmente a presença de tendência linear ou não linear, mudanças abruptas na média e heteroscedasticidade na variância.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e carregar os dados da série temporal",
                                  "subSteps": [
                                    "Instalar bibliotecas necessárias: pandas, matplotlib e numpy via pip.",
                                    "Carregar o dataset da série temporal (ex: CSV ou dataset built-in como AirPassengers).",
                                    "Verificar a estrutura dos dados com info() e head().",
                                    "Converter o índice para formato datetime usando pd.to_datetime().",
                                    "Tratar valores ausentes com fillna() ou interpolação se necessário."
                                  ],
                                  "verification": "Executar df.info() e df.plot() básico sem erros, confirmando índice datetime e ausência de NaNs.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "Bibliotecas: pandas, matplotlib, numpy",
                                    "Dataset de exemplo (ex: AirPassengers do R ou CSV equivalente)"
                                  ],
                                  "tips": "Sempre defina o índice como datetime no início para evitar problemas em plots.",
                                  "learningObjective": "Configurar ambiente de análise e preparar dados limpos para plotagem de séries temporais.",
                                  "commonMistakes": [
                                    "Esquecer de converter índice para datetime",
                                    "Ignorar valores ausentes",
                                    "Não verificar tipos de dados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir o gráfico da série temporal original",
                                  "subSteps": [
                                    "Importar matplotlib.pyplot as plt.",
                                    "Criar figura com plt.figure(figsize=(12,6)) para boa visualização.",
                                    "Plotar a série com plt.plot(df.index, df['valor'], linewidth=1.5).",
                                    "Adicionar labels: plt.xlabel('Tempo'), plt.ylabel('Valor'), plt.title('Série Temporal Original').",
                                    "Melhorar visualização com grid: plt.grid(True, alpha=0.3) e plt.tight_layout().",
                                    "Salvar ou exibir o gráfico com plt.savefig() ou plt.show()."
                                  ],
                                  "verification": "Gráfico gerado com eixos rotulados corretamente, grid visível e sem erros de plotagem.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Código Python preparado do Step 1",
                                    "Jupyter Notebook ou IDE como VS Code"
                                  ],
                                  "tips": "Use figsize maior para séries longas e linewidth para linhas mais visíveis.",
                                  "learningObjective": "Gerar um plot claro e profissional da série temporal original.",
                                  "commonMistakes": [
                                    "Eixos sem labels",
                                    "Índice não formatado causando plot bagunçado",
                                    "Figura muito pequena para análise"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar visualmente a presença de tendência linear ou não linear",
                                  "subSteps": [
                                    "Observar inclinação geral: crescente/decrescente e se é constante (linear) ou curva (não linear).",
                                    "Adicionar linha de tendência com plt.plot para regressão simples (usar np.polyfit grau 1 ou 2).",
                                    "Comparar série original com linha de tendência sobreposta.",
                                    "Identificar acelerações/desacelerações na tendência.",
                                    "Anotar no gráfico com plt.annotate() pontos chave de mudança."
                                  ],
                                  "verification": "Relatório escrito descrevendo se tendência é linear/não linear com evidência visual do plot.",
                                  "estimatedTime": "25-30 minutos",
                                  "materials": [
                                    "Gráfico do Step 2",
                                    "numpy para polyfit"
                                  ],
                                  "tips": "Teste polyfit com graus 1 (linear) e 2 (quadrática) e compare resíduos visualmente.",
                                  "learningObjective": "Identificar e visualizar padrões de tendência na série temporal.",
                                  "commonMistakes": [
                                    "Confundir tendência com sazonalidade",
                                    "Não sobrepor linha de tendência",
                                    "Ignorar escala do eixo y"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Detectar mudanças abruptas na média e heteroscedasticidade na variância",
                                  "subSteps": [
                                    "Inspecionar visualmente saltos abruptos na série (mudanças na média).",
                                    "Analisar dispersão: variância constante (homocedástica) ou crescente/diminuindo (heterocedástica).",
                                    "Calcular janela móvel de média e variância com df.rolling(window=12).var().plot().",
                                    "Sobrepor plot de variância no gráfico principal ou subplot.",
                                    "Marcar pontos de mudança abrupta com plt.scatter() ou setas."
                                  ],
                                  "verification": "Gráfico atualizado com sobreposições e descrição escrita de heteroscedasticidade e saltos detectados.",
                                  "estimatedTime": "25-30 minutos",
                                  "materials": [
                                    "Gráficos anteriores",
                                    "pandas rolling functions"
                                  ],
                                  "tips": "Use window=12 para dados mensais; plote variância em subplot separado para clareza.",
                                  "learningObjective": "Reconhecer visualmente não-estacionaridade devido a mudanças na média e variância.",
                                  "commonMistakes": [
                                    "Não diferenciar mudança abrupta de ruído",
                                    "Variância analisada sem janela móvel",
                                    "Escala y inadequada ocultando heteroscedasticidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando o dataset AirPassengers (passageiros aéreos mensais 1949-1960): carregue, plote a série mostrando tendência não linear crescente, sazonalidade, mudança abrupta em 1955 e heteroscedasticidade com variância aumentando ao longo do tempo.",
                              "finalVerifications": [
                                "Gera plot completo da série temporal com labels e grid.",
                                "Identifica corretamente tendência (ex: linear ou não linear).",
                                "Detecta pelo menos uma mudança abrupta na média.",
                                "Avalia heteroscedasticidade via plot de variância móvel.",
                                "Produz relatório escrito com interpretações visuais.",
                                "Reproduz análise em novo dataset similar sem erros."
                              ],
                              "assessmentCriteria": [
                                "Preparação de dados e plot básico corretos (25%)",
                                "Visualização clara de tendência com sobreposição (25%)",
                                "Detecção precisa de mudanças abruptas (20%)",
                                "Análise de heteroscedasticidade com evidências (20%)",
                                "Relatório interpretativo coerente e completo (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Regressão linear/polimonial para modelar tendências.",
                                "Programação: Manipulação de dados com pandas e visualização com matplotlib.",
                                "Economia: Análise de séries temporais para previsão de vendas ou PIB.",
                                "Ciência de Dados: Exploração inicial antes de modelagem avançada.",
                                "Física: Séries temporais em medições experimentais (ex: temperatura)."
                              ],
                              "realWorldApplication": "Em finanças, para visualizar e interpretar evolução de preços de ações detectando tendências e volatilidade crescente (heteroscedasticidade); em meteorologia, analisando séries de temperatura para identificar mudanças climáticas abruptas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.1.2",
                            "name": "Aplicar diferenciação e plotar série diferenciada",
                            "description": "Realizar diferenciação de primeira ordem na série e plotar o resultado para verificar se a tendência foi removida e a série aparenta estacionária.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a série temporal para diferenciação",
                                  "subSteps": [
                                    "Carregue a série temporal em um DataFrame do pandas usando pd.read_csv() ou similar.",
                                    "Defina o índice temporal com pd.to_datetime() para garantir alinhamento temporal.",
                                    "Verifique valores ausentes com df.isnull().sum() e preencha ou remova se necessário.",
                                    "Plote a série original com plt.plot() para visualizar a tendência inicial.",
                                    "Confirme que a série possui tendência não estacionária visualmente."
                                  ],
                                  "verification": "Série carregada corretamente, índice temporal definido e gráfico original plotado sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python com pandas e matplotlib instalados",
                                    "Arquivo CSV com dados de série temporal (ex: vendas mensais)"
                                  ],
                                  "tips": "Sempre use freq='M' ou similar no índice para séries mensais para facilitar análises futuras.",
                                  "learningObjective": "Entender a preparação adequada de dados temporais antes de transformações.",
                                  "commonMistakes": [
                                    "Ignorar valores ausentes levando a erros na diferenciação",
                                    "Não definir índice temporal causando desalinhamento"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar diferenciação de primeira ordem",
                                  "subSteps": [
                                    "Crie uma nova coluna para a série diferenciada: df['differenced'] = df['original'].diff().dropna().",
                                    "Use o método diff(1) para diferenciação de primeira ordem, removendo o primeiro NaN.",
                                    "Verifique estatísticas descritivas da série diferenciada com df['differenced'].describe().",
                                    "Confirme que não há NaNs restantes com df['differenced'].isnull().sum() == 0.",
                                    "Salve a série diferenciada em uma variável separada para plotting."
                                  ],
                                  "verification": "Série diferenciada criada sem NaNs e estatísticas mostram média próxima de zero.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Biblioteca pandas importada como pd"
                                  ],
                                  "tips": "Para diferenciação sazonal, use diff(period=12) para dados mensais; aqui focamos em primeira ordem.",
                                  "learningObjective": "Dominar a aplicação da diferenciação para remover tendência linear.",
                                  "commonMistakes": [
                                    "Esquecer de dropar NaNs causando erros no plot",
                                    "Aplicar diff() múltiplas vezes sem necessidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Plotar a série diferenciada e compará-la com a original",
                                  "subSteps": [
                                    "Crie uma figura com duas subplots usando plt.subplots(2,1, figsize=(10,8)).",
                                    "No subplot superior, plote a série original: ax[0].plot(df.index, df['original']).",
                                    "No subplot inferior, plote a diferenciada: ax[1].plot(df['differenced'].index, df['differenced']).",
                                    "Adicione títulos, labels e grid: ax[0].set_title('Série Original'), ax[1].set_title('Série Diferenciada').",
                                    "Exiba o gráfico com plt.tight_layout() e plt.show()."
                                  ],
                                  "verification": "Gráficos lado a lado mostram remoção clara de tendência na série diferenciada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Biblioteca matplotlib.pyplot importada como plt"
                                  ],
                                  "tips": "Use cores diferentes para original (azul) e diferenciada (vermelho) para fácil comparação.",
                                  "learningObjective": "Visualizar o impacto da diferenciação na remoção de tendência.",
                                  "commonMistakes": [
                                    "Índices desalinhados causando gráficos distorcidos",
                                    "Não ajustar figsize levando a plots ilegíveis"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar visualmente a estacionariedade da série diferenciada",
                                  "subSteps": [
                                    "Observe se a série diferenciada oscila ao redor de zero sem tendência ascendente/descendente.",
                                    "Verifique ausência de autocorrelação visual (sem padrões repetitivos fortes).",
                                    "Compare variância: a diferenciada deve ter variância estável ao longo do tempo.",
                                    "Anote observações qualitativas: 'Tendência removida, aparenta estacionária'.",
                                    "Se não estacionária, planeje diferenciação adicional ou testes formais (ex: ADF)."
                                  ],
                                  "verification": "Relatório escrito confirmando remoção de tendência e aparência estacionária.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Gráfico gerado no step anterior"
                                  ],
                                  "tips": "Procure por 'mean reversion' – retornos à média – como sinal de estacionariedade.",
                                  "learningObjective": "Interpretar gráficos para inferir estacionariedade visualmente.",
                                  "commonMistakes": [
                                    "Concluir estacionariedade prematuramente sem verificar variância",
                                    "Ignorar sazonalidade residual"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dados de vendas mensais de uma loja de varejo de 2015-2023 (disponíveis em datasets como 'airline_passengers.csv' adaptado), aplique diff(1) na coluna de passageiros/vendas. O plot original mostra tendência crescente; o diferenciado oscila em torno de zero, confirmando remoção de tendência.",
                              "finalVerifications": [
                                "Série diferenciada plotada corretamente sem erros de indexação.",
                                "Gráfico comparativo mostra clara remoção de tendência linear.",
                                "Média da série diferenciada próxima de zero (abs(mean) < 0.05 * std).",
                                "Ausência visual de drift ou explosão de variância.",
                                "Relatório de análise escrito descrevendo a aparência estacionária.",
                                "Código reproduzível salva como script .py."
                              ],
                              "assessmentCriteria": [
                                "Correta aplicação de df.diff(1).dropna() sem NaNs residuais (100% precisão).",
                                "Plots comparativos com labels, títulos e layout profissional (clareza visual 10/10).",
                                "Interpretação precisa: identificação correta de remoção de tendência (lógica sound).",
                                "Uso eficiente de tempo e recursos sem código desnecessário.",
                                "Análise qualitativa alinhada com evidências gráficas.",
                                "Preparação de dados robusta (handling de missing values)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conceitos de derivadas discretas e cálculo diferencial.",
                                "Programação: Manipulação de dados com pandas e visualização com matplotlib.",
                                "Economia/Finanças: Aplicação em modelagem de séries financeiras estacionárias.",
                                "Estatística: Preparação para testes formais como Augmented Dickey-Fuller.",
                                "Ciência de Dados: Pipeline completo de pré-processamento de séries temporais."
                              ],
                              "realWorldApplication": "Em finanças, diferenciação é usada para tornar retornos de ações estacionários antes de modelagem ARIMA, permitindo previsões precisas de preços de criptomoedas ou ações; em meteorologia, remove tendências climáticas para analisar variações sazonais de temperatura."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.1.3",
                            "name": "Identificar padrões sazonais visualmente",
                            "description": "Examinar picos e vales periódicos no gráfico da série para detectar componentes sazonais que violam a estacionariedade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e Plotar o Gráfico da Série Temporal",
                                  "subSteps": [
                                    "Carregue os dados da série temporal em uma ferramenta de visualização (ex: Python com pandas e matplotlib).",
                                    "Defina o eixo x como tempo (datas) e eixo y como valores da série.",
                                    "Gere o gráfico de linha simples da série temporal completa.",
                                    "Ajuste escalas e rótulos para clareza visual.",
                                    "Salve ou exiba o gráfico inicial."
                                  ],
                                  "verification": "Gráfico plotado corretamente com eixos rotulados e dados visíveis sem erros de escala.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Dados da série temporal (CSV ou similar), Python (pandas, matplotlib) ou Excel/R.",
                                  "tips": "Use zoom inicial em subperíodos para melhor visualização inicial.",
                                  "learningObjective": "Dominar a preparação visual básica de séries temporais para análise.",
                                  "commonMistakes": "Ignorar lacunas nos dados ou plotar sem ordenação temporal."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Picos e Vales Repetitivos",
                                  "subSteps": [
                                    "Examine o gráfico visualmente de esquerda para direita, marcando picos (máximos locais) e vales (mínimos locais).",
                                    "Meça aproximadamente a distância temporal entre picos consecutivos.",
                                    "Verifique se os padrões se repetem em intervalos consistentes (ex: mensal, anual).",
                                    "Destaque 3-5 ciclos completos de picos/vales no gráfico.",
                                    "Anote as posições temporais dos picos principais."
                                  ],
                                  "verification": "Lista de pelo menos 3 picos/vales identificados com intervalos temporais anotados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Gráfico plotado, ferramenta de anotação (ex: matplotlib annotate ou papel e caneta sobre print).",
                                  "tips": "Use uma régua ou grid no gráfico para medir distâncias com precisão.",
                                  "learningObjective": "Desenvolver habilidade em detectar repetições visuais em dados temporais.",
                                  "commonMistakes": "Confundir ruído aleatório com padrões sazonais reais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Periodicidade e Amplitude dos Padrões",
                                  "subSteps": [
                                    "Calcule a periodicidade média (ex: número de pontos de dados por ciclo).",
                                    "Compare amplitudes dos picos/vales entre ciclos para consistência.",
                                    "Verifique se os padrões ocorrem em todos os subperíodos da série.",
                                    "Plote uma linha de tendência sazonal aproximada sobre os picos.",
                                    "Registre variações que possam indicar não-sazonalidade."
                                  ],
                                  "verification": "Relatório com periodicidade calculada e gráfico com sobreposição de tendência.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Gráfico anotado, calculadora ou código para médias.",
                                  "tips": "Foquem em ciclos longos (ex: 12 meses) antes de julgar sazonalidade.",
                                  "learningObjective": "Quantificar visualmente componentes sazonais para análise qualitativa.",
                                  "commonMistakes": "Sobreestimar periodicidade em séries curtas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Impacto na Estacionariedade e Documentar",
                                  "subSteps": [
                                    "Avalie se os padrões sazonais causam variância não constante (viola estacionariedade).",
                                    "Compare com critérios de estacionariedade: média e variância constantes.",
                                    "Crie um resumo escrito dos padrões identificados.",
                                    "Sugira próximos passos (ex: decomposição sazonal).",
                                    "Salve o gráfico final com anotações."
                                  ],
                                  "verification": "Resumo documentado confirmando presença/ausência de sazonalidade e impacto.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Gráficos anteriores, documento de texto.",
                                  "tips": "Lembre-se: sazonalidade forte implica não-estacionariedade.",
                                  "learningObjective": "Conectar identificação visual à teoria de estacionariedade.",
                                  "commonMistakes": "Ignorar que sazonalidade é uma violação específica de estacionariedade."
                                }
                              ],
                              "practicalExample": "Em dados de vendas mensais de sorvetes (2010-2020), identifique picos repetitivos todo verão (junho-agosto) e vales no inverno, com ciclo de 12 meses, violando estacionariedade devido a variância sazonal.",
                              "finalVerifications": [
                                "Picos/vales periódicos identificados em pelo menos 3 ciclos.",
                                "Periodicidade consistente calculada (ex: 12 meses).",
                                "Gráfico anotado salvo com destaques.",
                                "Resumo escrito liga padrões à não-estacionariedade.",
                                "Sugestões para análise avançada incluídas.",
                                "Ausência de confusão com tendências lineares."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção de repetições (90%+ de ciclos corretos).",
                                "Quantificação adequada de periodicidade e amplitude.",
                                "Interpretação correta de impacto na estacionariedade.",
                                "Clareza e completude das anotações visuais.",
                                "Documentação estruturada e concisa.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções trigonométricas e decomposição de Fourier.",
                                "Economia: Previsão sazonal em séries de vendas ou PIB.",
                                "Ciência Ambiental: Padrões climáticos em dados de temperatura.",
                                "Programação: Visualização de dados com bibliotecas como ggplot2 ou seaborn."
                              ],
                              "realWorldApplication": "Em varejo, identificar sazonalidade em vendas permite ajustar estoques e promoções, como aumentar produção de roupas de inverno antecipadamente, melhorando eficiência e lucros."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.2",
                        "name": "Função de Autocorrelação (ACF e PACF)",
                        "description": "Análise das funções de autocorrelação simples (ACF) e parcial (PACF) para avaliar dependências seriais e detectar não-estacionariedade.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.2.1",
                            "name": "Calcular e plotar a função ACF",
                            "description": "Computar coeficientes de autocorrelação para lags múltiplos e interpretar decaimento lento como indício de não-estacionariedade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e carregar a série temporal",
                                  "subSteps": [
                                    "Instalar pacotes necessários: pip install pandas matplotlib statsmodels",
                                    "Importar bibliotecas: import pandas as pd, import matplotlib.pyplot as plt, from statsmodels.tsa.stattools import acf, from statsmodels.graphics.tsaplots import plot_acf",
                                    "Carregar dataset exemplo: from statsmodels.datasets import get_rdataset; data = get_rdataset('AirPassengers', 'datasets').data",
                                    "Converter índice para datetime: data.index = pd.date_range(start='1949-01', periods=len(data), freq='M')",
                                    "Visualizar dados iniciais: print(data.head()); data.plot()"
                                  ],
                                  "verification": "Dados carregados, índice datetime configurado e gráfico inicial exibido sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Jupyter Notebook ou Python IDE",
                                    "Dataset AirPassengers (built-in statsmodels)"
                                  ],
                                  "tips": "Sempre use datasets built-in para testes rápidos e evite downloads desnecessários.",
                                  "learningObjective": "Configurar ambiente Python para análise de séries temporais com foco em ACF.",
                                  "commonMistakes": [
                                    "Não converter índice para datetime",
                                    "Esquecer importações de statsmodels",
                                    "Usar dados não numéricos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Computar coeficientes de autocorrelação para múltiplos lags",
                                  "subSteps": [
                                    "Definir número de lags: nlags = 24 (para capturar sazonalidade mensal)",
                                    "Calcular ACF: acf_values = acf(data['value'], nlags=nlags, alpha=0.05)",
                                    "Extrair valores e intervalos de confiança: acf_vals = acf_values[0]; conf_int = acf_values[1]",
                                    "Criar DataFrame para análise: acf_df = pd.DataFrame({'lag': range(nlags+1), 'acf': acf_vals, 'lower': conf_int[:,0], 'upper': conf_int[:,1]})",
                                    "Visualizar tabela: print(acf_df.head(10))"
                                  ],
                                  "verification": "DataFrame com ACF values entre -1 e 1, lags corretos e intervalos de confiança calculados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Bibliotecas statsmodels e pandas instaladas"
                                  ],
                                  "tips": "Escolha nlags baseado na frequência da série (ex: 2x período sazonal).",
                                  "learningObjective": "Calcular ACF numericamente com suporte a intervalos de confiança.",
                                  "commonMistakes": [
                                    "Definir nlags muito baixo",
                                    "Ignorar alpha para confiança",
                                    "Não armazenar resultados em estrutura acessível"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Plotar a função ACF de forma clara e informativa",
                                  "subSteps": [
                                    "Preparar figura: plt.figure(figsize=(10,6))",
                                    "Gerar plot ACF: plot_acf(data['value'], lags=24, ax=plt.gca())",
                                    "Customizar plot: plt.title('Função de Autocorrelação (ACF) - AirPassengers'); plt.xlabel('Lags'); plt.ylabel('ACF')",
                                    "Adicionar grid e salvar: plt.grid(True); plt.tight_layout(); plt.savefig('acf_plot.png')",
                                    "Exibir plot: plt.show()"
                                  ],
                                  "verification": "Gráfico de barras azuis com linha de confiança (95%) exibido e salvo corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Matplotlib instalado"
                                  ],
                                  "tips": "Use figsize maior para melhor visualização de múltiplos lags.",
                                  "learningObjective": "Visualizar ACF com convenções padrão para interpretação fácil.",
                                  "commonMistakes": [
                                    "Não especificar lags no plot_acf",
                                    "Plot sem títulos ou labels",
                                    "Ignorar bandas de confiança"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar o decaimento da ACF para inferir não-estacionariedade",
                                  "subSteps": [
                                    "Analisar decaimento: Observar se barras ACF cruzam bandas de confiança lentamente (decay lento)",
                                    "Identificar padrões: Notar lags significativos além de 1-2 e ausência de corte abrupto",
                                    "Comparar com teoria: Decay lento indica tendência ou não-estacionariedade",
                                    "Documentar achados: Escrever relatório: 'ACF decai lentamente, sugerindo não-estacionariedade'",
                                    "Testar hipótese: Sugerir próximo passo como diferenciação e re-plot ACF"
                                  ],
                                  "verification": "Relatório escrito identificando corretamente decay lento como indício de não-estacionariedade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Plot ACF gerado no step anterior"
                                  ],
                                  "tips": "Foquem em lags iniciais (1-10) primeiro para tendências claras.",
                                  "learningObjective": "Interpretar visualmente ACF para diagnósticos de estacionariedade.",
                                  "commonMistakes": [
                                    "Confundir decay lento com sazonalidade",
                                    "Ignorar bandas de confiança",
                                    "Concluir estacionariedade prematuramente"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando o dataset AirPassengers (passageiros aéreos mensais 1949-1960), calcule e plote ACF com 24 lags. Observe decay sinusoidal lento das barras acima da banda de confiança, indicando tendência e sazonalidade (não-estacionariedade).",
                              "finalVerifications": [
                                "Código roda sem erros e gera plot ACF legível.",
                                "ACF calculada para pelo menos 20 lags com intervalos de confiança.",
                                "Decay lento corretamente identificado no plot.",
                                "Interpretação escrita liga decay a não-estacionariedade.",
                                "Sugestão de diferenciação como próximo passo.",
                                "Valores ACF iniciais próximos de 1 (ex: lag 1 > 0.9)."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica da ACF (valores coerentes com statsmodels).",
                                "Qualidade visual do plot (labels, grid, figsize adequado).",
                                "Interpretação correta de decay lento vs. estacionariedade.",
                                "Eficiência e limpeza do código (sem warnings).",
                                "Uso apropriado de lags baseado no contexto da série.",
                                "Documentação de achados em comentários ou relatório."
                              ],
                              "crossCurricularConnections": [
                                "Programação em Python (manipulação de dados com pandas).",
                                "Estatística inferencial (intervalos de confiança).",
                                "Visualização de dados (matplotlib para gráficos diagnósticos).",
                                "Econometria (análise de séries em finanças e economia)."
                              ],
                              "realWorldApplication": "Em previsão de demanda de varejo, plote ACF de vendas diárias para detectar não-estacionariedade (ex: decay lento devido a feriados), permitindo diferenciação antes de modelar ARIMA para estoque otimizado."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.2.2",
                            "name": "Interpretar gráfico PACF para estacionariedade",
                            "description": "Analisar a função de autocorrelação parcial para identificar corte abrupto após poucos lags, contrastando com decaimento gradual em séries não estacionárias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos da Função de Autocorrelação Parcial (PACF)",
                                  "subSteps": [
                                    "Defina PACF como a correlação entre a série e seus lags, removendo efeitos de lags intermediários.",
                                    "Compare PACF com ACF: PACF isola correlações diretas, útil para ordem AR(p).",
                                    "Aprenda que em processos estacionários AR(p), PACF corta abruptamente após lag p.",
                                    "Estude o contraste: em séries não estacionárias, PACF decai gradualmente como ACF.",
                                    "Revise bandas de confiança (tipicamente 95%) para significância estatística."
                                  ],
                                  "verification": "Explique em suas palavras a diferença entre PACF e ACF e o padrão esperado para estacionariedade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de statsmodels (Python) ou forecast (R)",
                                    "Vídeo tutorial sobre PACF (ex: YouTube StatQuest)"
                                  ],
                                  "tips": "Sempre considere as bandas de confiança azuis no gráfico; spikes dentro delas não são significativos.",
                                  "learningObjective": "Dominar os conceitos teóricos da PACF e seus padrões diagnósticos para estacionariedade.",
                                  "commonMistakes": [
                                    "Confundir PACF com ACF",
                                    "Ignorar remoção de efeitos intermediários",
                                    "Assumir todos os spikes como significativos sem bandas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar o gráfico PACF para uma série temporal",
                                  "subSteps": [
                                    "Carregue uma série temporal estacionária de exemplo (ex: AirPassengers diferenciada).",
                                    "Use biblioteca statsmodels.tsa.stattools.pacf() em Python ou pacf() em R.",
                                    "Plote o gráfico com lags suficientes (ex: 20 lags) e inclua bandas de confiança.",
                                    "Salve o gráfico e anote lags significativos.",
                                    "Repita para uma série não diferenciada para contraste."
                                  ],
                                  "verification": "Gere e exiba gráficos PACF para duas séries (estacionária e não), confirmando visualmente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python: pandas, statsmodels, matplotlib",
                                    "R: forecast, ggplot2",
                                    "Dataset: AirPassengers ou similar"
                                  ],
                                  "tips": "Defina nlags=20 para capturar padrões iniciais; foque nos primeiros 10 lags para AR típicos.",
                                  "learningObjective": "Executar geração prática de gráficos PACF com ferramentas padrão.",
                                  "commonMistakes": [
                                    "Não diferenciar série não estacionária primeiro",
                                    "Plotar lags insuficientes",
                                    "Esquecer bandas de confiança no plot"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar padrões no gráfico PACF para detectar estacionariedade",
                                  "subSteps": [
                                    "Identifique corte abrupto: spikes significativos nos primeiros lags, zero após.",
                                    "Conte os lags até o corte (ex: significativo em lag 1-2, insignificante depois = AR(2)).",
                                    "Compare com decaimento gradual em não estacionárias (spikes persistentes).",
                                    "Documente observações: 'Corte após lag 2 indica estacionariedade AR(2)'.",
                                    "Teste sensibilidade variando lags ou transformações."
                                  ],
                                  "verification": "Anote o número de lags até corte e justifique se indica estacionariedade.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Gráficos gerados no Step 2",
                                    "Planilha para anotar padrões"
                                  ],
                                  "tips": "Corte significa spikes dentro das bandas após certo lag; procure padrão 'dentes de serra' inicial.",
                                  "learningObjective": "Interpretar visualmente PACF para diagnosticar estacionariedade e ordem AR.",
                                  "commonMistakes": [
                                    "Interpretar spikes marginais como corte",
                                    "Confundir com ACF (PACF para AR, ACF para MA)",
                                    "Ignorar tendência sazonal"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e contrastar interpretações com testes complementares",
                                  "subSteps": [
                                    "Compare PACF com ACF do mesmo dataset para confirmação cruzada.",
                                    "Aplique teste formal como ADF após interpretação visual.",
                                    "Simule séries AR estacionárias vs. random walk não estacionária.",
                                    "Registre conclusão: 'PACF sugere estacionariedade; ADF p-value <0.05 confirma'.",
                                    "Pratique em 2-3 datasets variados."
                                  ],
                                  "verification": "Produza relatório curto contrastando PACF de 3 séries com conclusões consistentes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código para ADF test (statsmodels.adfuller)",
                                    "Datasets múltiplos: sunspots, sales data"
                                  ],
                                  "tips": "Use PACF como exploratório; sempre valide com testes estatísticos para robustez.",
                                  "learningObjective": "Integrar PACF em workflow completo de análise de estacionariedade.",
                                  "commonMistakes": [
                                    "Depender só de visual sem testes",
                                    "Não contrastar múltiplos datasets",
                                    "Sobreajustar ordem AR alta"
                                  ]
                                }
                              ],
                              "practicalExample": "Em dados de passageiros aéreos (AirPassengers), após diferenciação 1ª: PACF mostra spikes significativos em lag 1 e 2, cortando abruptamente após (dentro das bandas), indicando AR(2) estacionário. Contrastando com original não diferenciada: decaimento gradual, sugerindo não estacionariedade.",
                              "finalVerifications": [
                                "Identifica corretamente corte abrupto em PACF de série AR estacionária.",
                                "Explica contraste com decaimento em não estacionárias.",
                                "Conta lags até corte com precisão, considerando bandas.",
                                "Valida com ACF e teste ADF.",
                                "Aplica em dataset novo sem erros.",
                                "Documenta interpretação em relatório claro."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de padrões PACF (90%+ acerto em exemplos).",
                                "Explicação teórica clara e correta.",
                                "Uso adequado de software e visualizações.",
                                "Integração com testes complementares.",
                                "Análise de erros comuns evitados.",
                                "Relatório prático e acionável."
                              ],
                              "crossCurricularConnections": [
                                "Estatística Inferencial: Testes de hipóteses como ADF.",
                                "Programação: Manipulação de dados em Python/R.",
                                "Economia/Finanças: Previsão de séries temporais econômicas.",
                                "Matemática: Modelos ARIMA e processos estocásticos."
                              ],
                              "realWorldApplication": "Em finanças, interpretar PACF de retornos de ações para detectar estacionariedade e modelar AR, melhorando previsões de risco; em meteorologia, analisar temperaturas para forecasts sazonais estacionários."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.2.3",
                            "name": "Comparar ACF e PACF antes e após diferenciação",
                            "description": "Gerar gráficos ACF/PACF da série original e diferenciada para validar visualmente a indução de estacionariedade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Carregar e visualizar a série temporal original",
                                  "subSteps": [
                                    "Importar bibliotecas necessárias (pandas, matplotlib, statsmodels.tsa).",
                                    "Carregar o conjunto de dados de série temporal (ex: CSV com datas e valores).",
                                    "Converter a coluna de datas em índice datetime.",
                                    "Plotar o gráfico da série temporal original para inspeção visual.",
                                    "Calcular estatísticas descritivas básicas (média, variância)."
                                  ],
                                  "verification": "Gráfico da série temporal original plotado corretamente e estatísticas calculadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python com pandas, matplotlib, statsmodels",
                                    "Arquivo CSV de série temporal"
                                  ],
                                  "tips": "Use pd.read_csv com parse_dates para índices de tempo automáticos.",
                                  "learningObjective": "Preparar dados de série temporal para análise de estacionariedade.",
                                  "commonMistakes": "Ignorar conversão de datas ou usar formato incorreto de índice temporal."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar e plotar ACF e PACF da série original",
                                  "subSteps": [
                                    "Usar statsmodels.graphics.tsaplots.plot_acf() para ACF.",
                                    "Usar statsmodels.graphics.tsaplots.plot_pacf() para PACF.",
                                    "Definir lags apropriados (ex: 20-40 lags).",
                                    "Plotar ambos os gráficos lado a lado para comparação inicial.",
                                    "Adicionar títulos e rótulos claros aos gráficos."
                                  ],
                                  "verification": "Gráficos ACF e PACF da série original gerados e exibidos com barras de confiança.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "statsmodels.tsa.graphics",
                                    "matplotlib.pyplot"
                                  ],
                                  "tips": "Ajuste lags com base no tamanho da série para evitar overfitting visual.",
                                  "learningObjective": "Visualizar padrões de autocorrelação na série não diferenciada.",
                                  "commonMistakes": "Não incluir intervalos de confiança ou usar lags insuficientes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar diferenciação à série temporal",
                                  "subSteps": [
                                    "Decidir ordem de diferenciação (geralmente 1 para início).",
                                    "Usar diff() do pandas para primeira diferenciação: serie.diff().dropna().",
                                    "Plotar a série diferenciada para verificar remoção de tendência.",
                                    "Verificar se há necessidade de diferenciação adicional (inspeção visual).",
                                    "Armazenar a série diferenciada em nova variável."
                                  ],
                                  "verification": "Série diferenciada criada e plotada, sem valores NaN iniciais.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "pandas Series"
                                  ],
                                  "tips": "Sempre use dropna() após diff() para remover NaN.",
                                  "learningObjective": "Induzir estacionariedade através de diferenciação.",
                                  "commonMistakes": "Esquecer dropna() ou diferenciar múltiplas vezes sem verificação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Gerar e plotar ACF e PACF da série diferenciada",
                                  "subSteps": [
                                    "Aplicar plot_acf() e plot_pacf() na série diferenciada.",
                                    "Usar os mesmos lags da análise original para consistência.",
                                    "Plotar gráficos lado a lado com os originais (subplots).",
                                    "Salvar figuras para relatório (plt.savefig()).",
                                    "Anotar picos significativos em cada gráfico."
                                  ],
                                  "verification": "Gráficos ACF e PACF da série diferenciada plotados e comparáveis aos originais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "statsmodels.tsa.graphics",
                                    "matplotlib.subplots"
                                  ],
                                  "tips": "Use fig, axs = plt.subplots(2,2) para organizar 4 gráficos.",
                                  "learningObjective": "Comparar visualmente mudanças pós-diferenciação.",
                                  "commonMistakes": "Diferentes escalas ou lags nos gráficos de comparação."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar e comparar os gráficos ACF/PACF",
                                  "subSteps": [
                                    "Identificar decaimento lento na ACF original (não estacionária).",
                                    "Verificar decaimento rápido na ACF diferenciada (estacionária).",
                                    "Analisar spikes na PACF para ordem AR.",
                                    "Documentar diferenças chave em relatório ou notebook.",
                                    "Concluir sobre indução de estacionariedade."
                                  ],
                                  "verification": "Relatório escrito com interpretação das mudanças observadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Jupyter Notebook ou relatório Markdown"
                                  ],
                                  "tips": "Procure por ACF cortando 95% das barras de confiança após lag 1-2.",
                                  "learningObjective": "Validar estacionariedade visualmente via ACF/PACF.",
                                  "commonMistakes": "Interpretar erroneamente ruído como sinal significativo."
                                }
                              ],
                              "practicalExample": "Carregue dados de passageiros aéreos (airpassengers.csv), gere ACF/PACF originais (decaimento lento), diferencie uma vez, gere novos gráficos (ACF rápida para zero após lag 1) e compare para validar estacionariedade.",
                              "finalVerifications": [
                                "ACF original mostra autocorrelações significativas em lags altos.",
                                "PACF original tem spikes persistentes.",
                                "ACF diferenciada decai exponencialmente para zero após poucos lags.",
                                "PACF diferenciada tem poucos spikes iniciais.",
                                "Série diferenciada não exibe tendência visual.",
                                "Gráficos salvos com legendas claras."
                              ],
                              "assessmentCriteria": [
                                "Precisão na geração de gráficos ACF/PACF (sem erros de código).",
                                "Correta aplicação e verificação da diferenciação.",
                                "Interpretação precisa das mudanças (decaimento lento -> rápido).",
                                "Uso consistente de lags e visualizações comparativas.",
                                "Documentação clara de conclusões sobre estacionariedade.",
                                "Ausência de erros comuns como NaN não tratados."
                              ],
                              "crossCurricularConnections": [
                                "Programação em Python/R para visualização de dados.",
                                "Estatística inferencial (testes de significância em autocorrelações).",
                                "Machine Learning (pré-processamento para modelos ARIMA).",
                                "Análise Exploratória de Dados (EDA visual).",
                                "Econometria (análise de séries financeiras)."
                              ],
                              "realWorldApplication": "Em finanças, comparar ACF/PACF de retornos de ações antes/depois de diferenciação para confirmar estacionariedade antes de modelar ARIMA para previsões de preços."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.3",
                        "name": "Testes Estatísticos de Estacionariedade",
                        "description": "Aplicação de testes formais iniciais para rejeitar ou não a hipótese nula de não-estacionariedade, complementando a análise visual.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.3.1",
                            "name": "Realizar Teste de Dickey-Fuller Aumentado (ADF)",
                            "description": "Executar o teste ADF em R ou Python, interpretando o p-valor e estatística de teste para decidir sobre presença de raiz unitária (não-estacionariedade).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o Ambiente e os Dados da Série Temporal",
                                  "subSteps": [
                                    "Instale as bibliotecas necessárias: em Python, use `pip install pandas statsmodels`; em R, `install.packages(c('tseries', 'urca'))`.",
                                    "Carregue o conjunto de dados da série temporal em um DataFrame (Python) ou data.frame (R), garantindo index temporal.",
                                    "Verifique e trate valores ausentes (NAs) usando métodos como forward-fill ou interpolação.",
                                    "Plote a série temporal para visual inspeção de tendências, sazonalidade ou não-estacionariedade.",
                                    "Confirme que os dados são unidimensionais e ordenados cronologicamente."
                                  ],
                                  "verification": "Gráfico da série temporal gerado sem erros e dados limpos confirmados (sem NAs).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python (Jupyter Notebook) ou RStudio",
                                    "Dataset de série temporal (ex: CSV com coluna de datas e valores)"
                                  ],
                                  "tips": [
                                    "Sempre plote os dados primeiro para intuition visual antes de testes formais.",
                                    "Use `pd.to_datetime()` em Python para index temporal correto."
                                  ],
                                  "learningObjective": "Configurar ambiente computacional e preparar dados limpos para análise de estacionariedade.",
                                  "commonMistakes": [
                                    "Ignorar valores ausentes, levando a resultados inválidos.",
                                    "Não converter datas corretamente, causando erros de indexação.",
                                    "Usar dados não temporais ou multivariados."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar o Teste de Dickey-Fuller Aumentado (ADF)",
                                  "subSteps": [
                                    "Em Python: use `from statsmodels.tsa.stattools import adfuller; result = adfuller(data)`.",
                                    "Em R: use `adf.test(data, alternative='stationary')` do pacote tseries ou `ur.df(data)` do urca.",
                                    "Especifique o número de lags apropriado (use critérios como AIC/BIC ou regra de thumb: 12*(T/100)^{1/4}).",
                                    "Execute o teste com hipótese nula H0: raiz unitária (não-estacionária).",
                                    "Armazene os resultados: estatística de teste, p-valor e valores críticos."
                                  ],
                                  "verification": "Resultado do teste ADF retornado com estatística, p-valor e valores críticos sem erros de execução.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Bibliotecas statsmodels (Python) ou tseries/urca (R)",
                                    "Série temporal preparada do Step 1"
                                  ],
                                  "tips": [
                                    "Comece com lags automáticos se disponível para evitar under/over-specification.",
                                    "Registre seed para reproducibilidade em simulações."
                                  ],
                                  "learningObjective": "Executar o teste ADF corretamente em R ou Python com parâmetros adequados.",
                                  "commonMistakes": [
                                    "Não especificar lags, levando a estatísticas enviesadas.",
                                    "Confundir ordem de integração com lags do modelo AR.",
                                    "Executar em dados diferenciados prematuramente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar as Estatísticas do Teste ADF",
                                  "subSteps": [
                                    "Extraia a estatística de teste ADF e compare com valores críticos (1%, 5%, 10%).",
                                    "Interprete o p-valor: se < 0.05, rejeite H0 (série estacionária); caso contrário, não rejeite (não-estacionária).",
                                    "Verifique coeficientes do modelo AR (lags) e resíduos para autocorrelação.",
                                    "Gere um resumo tabular dos resultados: stat, p-value, critical values.",
                                    "Teste sensibilidade variando lags e compare resultados."
                                  ],
                                  "verification": "Tabela de resultados ADF criada e estatísticas chave destacadas corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Resultados do Step 2",
                                    "Ferramentas de plotagem (matplotlib/ggplot2)"
                                  ],
                                  "tips": [
                                    "p-valor é mais robusto que comparação direta de stats para tamanhos de amostra pequenos.",
                                    "Plot residuals para checar suposições do teste."
                                  ],
                                  "learningObjective": "Extrair e analisar métricas chave do teste ADF para insights iniciais.",
                                  "commonMistakes": [
                                    "Interpretar p-valor >0.05 como 'provadamente não-estacionária' (é falha em rejeitar H0).",
                                    "Ignorar valores críticos ao focar só no p-valor.",
                                    "Não testar múltiplos lags."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Resultados e Decidir sobre Estacionariedade",
                                  "subSteps": [
                                    "Decida: se ADF rejeita H0, série é estacionária; senão, considere diferenciação ou transformações.",
                                    "Reporte implicações: para modelagem, não-estacionariedade pode causar regressões espúrias.",
                                    "Visualize ACF/PACF para confirmar achados do ADF.",
                                    "Documente relatório: inclua código, resultados e conclusão.",
                                    "Sugira próximos passos: KPSS test para confirmação ou diferenciação se necessário."
                                  ],
                                  "verification": "Relatório escrito com decisão clara sobre presença de raiz unitária e próximos passos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Resultados dos steps anteriores",
                                    "Template de relatório Markdown"
                                  ],
                                  "tips": [
                                    "Combine ADF com KPSS para testes complementares (ADF fraco contra trend-stationary).",
                                    "Sempre contextualize com plot original."
                                  ],
                                  "learningObjective": "Tomar decisões baseadas em resultados ADF e planejar análises subsequentes.",
                                  "commonMistakes": [
                                    "Concluir estacionariedade sem checar resíduos.",
                                    "Não considerar tamanho de amostra (teste fraco para T<50).",
                                    "Ignorar trend/drift no modelo ADF."
                                  ]
                                }
                              ],
                              "practicalExample": "Carregue dados diários de preços de fechamento da ação AAPL (2020-2023) via yfinance em Python. Plote a série, execute ADF com 12 lags, interprete p-valor ~0.8 (não rejeita H0, não-estacionária), e teste retornos log (diff(log(prices))) que passa no teste (p<0.05).",
                              "finalVerifications": [
                                "Teste ADF executado sem erros em código reproduzível.",
                                "p-valor e estatística interpretados corretamente contra H0.",
                                "Decisão sobre estacionariedade alinhada com resultados.",
                                "Gráficos de série e resíduos incluídos.",
                                "Relatório documenta lags usados e sensibilidade.",
                                "Próximos passos sugeridos (ex: diferenciação)."
                              ],
                              "assessmentCriteria": [
                                "Escolha correta de software e bibliotecas.",
                                "Tratamento adequado de dados (NAs, index temporal).",
                                "Seleção apropriada de lags (automático ou regra).",
                                "Interpretação precisa de p-valor e critical values.",
                                "Relatório claro com evidências visuais e conclusões.",
                                "Reconhecimento de limitações do teste ADF."
                              ],
                              "crossCurricularConnections": [
                                "Econometria: Testes de cointegração e modelagem VAR.",
                                "Machine Learning: Pré-processamento para LSTM/ARIMA.",
                                "Finanças: Análise de risco e previsão de retornos.",
                                "Economia: Modelagem macroeconômica de PIB/inflação.",
                                "Estatística: Hipótese testing e power de testes."
                              ],
                              "realWorldApplication": "Em finanças quantitativas, o teste ADF é usado para validar estacionariedade de retornos de ativos antes de modelos de previsão, evitando regressões espúrias em portfólios; em economia, testa se séries como desemprego têm raiz unitária para guiar políticas monetárias."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.3.2",
                            "name": "Aplicar Teste KPSS de Estacionariedade",
                            "description": "Implementar o teste KPSS, onde a hipótese nula é estacionariedade, e comparar resultados com ADF para confirmação robusta.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos do Teste KPSS",
                                  "subSteps": [
                                    "Estude a definição do teste KPSS: Kwiatkowski-Phillips-Schmidt-Shin, que testa a hipótese nula (H0) de estacionariedade contra a alternativa de não-estacionariedade.",
                                    "Revise a estatística do teste baseada na regressão de resíduos e o cálculo do LM (Lagrange Multiplier).",
                                    "Compare com o teste ADF: no KPSS, H0 é estacionariedade (oposto ao ADF), útil para confirmação robusta.",
                                    "Analise os tipos de teste KPSS: nível (constante), tendência (trend) e modelo sazonal.",
                                    "Consulte documentação oficial ou papers originais para equações chave."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito as diferenças entre KPSS e ADF, incluindo hipóteses nulas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação statsmodels",
                                    "Artigos acadêmicos sobre KPSS (Kwiatkowski et al., 1992)",
                                    "Notebook Jupyter para anotações"
                                  ],
                                  "tips": "Use diagramas para visualizar H0 vs H1 e memorize que p-value alto em KPSS confirma estacionariedade.",
                                  "learningObjective": "Dominar os princípios teóricos do teste KPSS e sua complementaridade com ADF.",
                                  "commonMistakes": [
                                    "Confundir H0 de KPSS com ADF (estacionariedade vs raiz unitária)",
                                    "Ignorar os diferentes lags de teste disponíveis"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar os dados da série temporal",
                                  "subSteps": [
                                    "Carregue os dados em formato Pandas Series ou DataFrame, garantindo índice temporal.",
                                    "Realize plotagens exploratórias: gráfico da série, ACF e PACF para inspecionar estacionariedade visual.",
                                    "Trate missing values e outliers, aplicando log ou diferenciação se necessário para pré-visualização.",
                                    "Divida a série em treino/teste se aplicável, e defina parâmetros iniciais como lags.",
                                    "Salve o dataset preparado em variável limpa."
                                  ],
                                  "verification": "Gere gráficos que mostrem a série original e confirmem ausência de erros de carregamento.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Biblioteca pandas",
                                    "Biblioteca matplotlib ou seaborn",
                                    "Dataset exemplo de série temporal (ex: dados de PIB)"
                                  ],
                                  "tips": "Sempre plote primeiro: visual é rei na análise de séries temporais.",
                                  "learningObjective": "Preparar dados adequadamente para aplicação do teste, evitando vieses.",
                                  "commonMistakes": [
                                    "Não tratar NaNs, causando falhas no teste",
                                    "Usar dados não temporais como se fossem séries"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o teste KPSS em Python",
                                  "subSteps": [
                                    "Instale e importe statsmodels.tsa.stattools.kpss.",
                                    "Execute kpss(data, regression='c' ou 'ct', nlags='auto') para nível ou tendência.",
                                    "Capture saídas: estatística KPSS, p-value, lags usados e critical values.",
                                    "Repita para diferentes configurações (nível e tendência) e registre resultados.",
                                    "Implemente ADF para comparação usando adfuller do mesmo módulo."
                                  ],
                                  "verification": "Execute o código sem erros e imprima resultados numéricos para ambos testes.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python com statsmodels, pandas",
                                    "Jupyter Notebook",
                                    "Dataset real (ex: de quandl ou yfinance)"
                                  ],
                                  "tips": "Use nlags='auto' inicialmente; ajuste manualmente se p-value borderline.",
                                  "learningObjective": "Executar o teste KPSS programaticamente com precisão.",
                                  "commonMistakes": [
                                    "Esquecer de importar corretamente",
                                    "Confundir parâmetros regression='c' vs 'ct'"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados e comparar com ADF",
                                  "subSteps": [
                                    "Analise p-value KPSS: <0.05 rejeita H0 (não-estacionária); alto confirma estacionariedade.",
                                    "Compare com ADF: concordância reforça conclusão (ex: ambos rejeitam não-estacionariedade).",
                                    "Gere relatório: tabela com stats, p-values e recomendação (diferenciar ou não).",
                                    "Visualize resíduos ou resíduos cumulativos se disponível.",
                                    "Documente limitações: tamanho amostral pequeno afeta robustez."
                                  ],
                                  "verification": "Produza um relatório escrito com interpretação coerente e tabela comparativa.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Resultados dos testes anteriores",
                                    "Ferramentas de formatação (pandas to_latex ou print)",
                                    "Notebook para relatório"
                                  ],
                                  "tips": "Regra prática: se ADF indica estacionária E KPSS confirma, prossiga para modelagem.",
                                  "learningObjective": "Interpretar e validar resultados para decisões robustas em séries temporais.",
                                  "commonMistakes": [
                                    "Inverter interpretação de p-value",
                                    "Não comparar com ADF, perdendo robustez"
                                  ]
                                }
                              ],
                              "practicalExample": "Aplique o teste KPSS aos dados mensais de inflação (IPCA) no Brasil de 2010-2023 (disponíveis no IBGE ou FRED). Plote a série, execute KPSS para nível e tendência, compare com ADF e conclua se a série é estacionária ou requer diferenciação para modelagem ARIMA.",
                              "finalVerifications": [
                                "Código executa sem erros e produz p-values válidos para KPSS e ADF.",
                                "Interpretação correta: série estacionária se p-KPSS >0.05 e p-ADF >0.05.",
                                "Relatório inclui gráficos, tabela comparativa e recomendação acionável.",
                                "Teste sensível a lags: resultados consistentes com 'auto' e manual.",
                                "Conclusão alinhada com visual exploratória da série.",
                                "Documentação completa com fontes e limitações."
                              ],
                              "assessmentCriteria": [
                                "Precisão teórica: compreensão correta de H0 e diferenças com ADF (30%).",
                                "Implementação técnica: código limpo e reproduzível (25%).",
                                "Interpretação robusta: comparação lógica e conclusão válida (20%).",
                                "Qualidade visual e relatório: gráficos claros e tabela organizada (15%).",
                                "Tratamento de edge cases: lags, tamanhos amostrais (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Econometria: modelagem ARIMA/SARIMA pós-testes de estacionariedade.",
                                "Finanças: análise de retornos de ações ou câmbio para trading algorítmico.",
                                "Machine Learning: pré-processamento para LSTM ou Prophet em forecasting.",
                                "Economia: testes em séries macroeconômicas como PIB ou desemprego."
                              ],
                              "realWorldApplication": "Em bancos e consultorias econômicas, o teste KPSS confirma estacionariedade em séries de preços de commodities antes de forecasting de demanda, evitando modelos enviesados e melhorando precisão em previsões de vendas ou riscos financeiros."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.3.3",
                            "name": "Interpretar resultados conjuntos de testes",
                            "description": "Combinar evidências de testes visuais, ACF/PACF e estatísticos para concluir sobre estacionariedade e sugerir transformações necessárias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Coletar e Organizar Resultados dos Testes Individuais",
                                  "subSteps": [
                                    "Liste todos os testes realizados: visuais (gráfico da série, resíduos), ACF/PACF plots e estatísticos (ADF, KPSS, Phillips-Perron).",
                                    "Registre os valores p-value, estatísticas de teste e conclusões preliminares para cada um.",
                                    "Crie uma tabela ou dashboard resumindo os resultados para fácil visualização.",
                                    "Identifique inconsistências iniciais, como testes contraditórios.",
                                    "Salve os gráficos e outputs em um relatório único."
                                  ],
                                  "verification": "Verifique se há uma tabela ou documento com todos os resultados organizados e sem dados faltantes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Planilha (Excel/Google Sheets), software de análise (Python com pandas/statsmodels ou R), dataset de série temporal exemplo (ex: AirPassengers).",
                                  "tips": "Use cores na tabela para destacar resultados significativos (verde para estacionária, vermelho para não-estacionária).",
                                  "learningObjective": "Organizar evidências de múltiplas fontes para análise integrada.",
                                  "commonMistakes": "Ignorar testes menos familiares ou não registrar p-values exatos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Interpretar Evidências Visuais",
                                  "subSteps": [
                                    "Examine o gráfico da série temporal original por tendências, sazonalidade ou variância não-constante.",
                                    "Analise resíduos de modelos preliminares para padrões aleatórios.",
                                    "Avalie se a série parece estacionária visualmente (sem drifts ou ciclos óbvios).",
                                    "Compare com critérios qualitativos: variância constante? Média estável?",
                                    "Anotar forças e fraquezas da evidência visual."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo a interpretação visual e justifique com referências aos gráficos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Gráficos gerados (matplotlib/seaborn em Python ou ggplot em R), lupa digital para zoom em plots.",
                                  "tips": "Procure por 'olhos no gráfico': tendências lineares indicam não-estacionariedade.",
                                  "learningObjective": "Desenvolver intuição visual para estacionariedade em séries temporais.",
                                  "commonMistakes": "Confundir sazonalidade com tendência ou ignorar heteroscedasticidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Plots ACF e PACF",
                                  "subSteps": [
                                    "Observe decaimento da ACF: lento sugere não-estacionariedade; rápido decay indica estacionariedade.",
                                    "Verifique PACF para spikes persistentes ou padrão MA/AR.",
                                    "Compare limites de confiança (95%): barras fora indicam significância.",
                                    "Classifique: ACF lenta decay = integrar; ambos rápidos = possivelmente estacionária.",
                                    "Documente padrões observados com capturas de tela."
                                  ],
                                  "verification": "Crie um fluxograma simples mostrando interpretação ACF/PACF -> conclusão preliminar.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Funções ACF/PACF em statsmodels (Python) ou forecast (R), dataset plotado.",
                                  "tips": "Lembre: ACF lenta é sinal clássico de necessidade de diferenciação.",
                                  "learningObjective": "Interpretar correlogramas para diagnosticar dependências temporais.",
                                  "commonMistakes": "Interpretar barras dentro da banda como significativas ou vice-versa."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Examinar Resultados de Testes Estatísticos",
                                  "subSteps": [
                                    "Para ADF: rejeitar H0 (p<0.05) = estacionária; não rejeitar = não-estacionária.",
                                    "Para KPSS: não rejeitar H0 (p>0.05) = estacionária; rejeitar = tendência ou não-estacionária.",
                                    "Considere Phillips-Perron para robustez a heteroscedasticidade.",
                                    "Anota conflitos: ADF vs KPSS frequentemente complementares.",
                                    "Calcule poder do teste baseado no tamanho da amostra."
                                  ],
                                  "verification": "Liste conclusões binárias (estacionária/não) para cada teste com p-values citados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Bibliotecas statsmodels.tsa.stattools (ADF/KPSS), output de testes salvos.",
                                  "tips": "Sempre use ambos ADF e KPSS para confirmação cruzada.",
                                  "learningObjective": "Aplicar hipóteses nulas corretas em testes unit root.",
                                  "commonMistakes": "Confundir H0 de ADF (unit root) com KPSS (estacionariedade)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar Evidências e Sugerir Transformações",
                                  "subSteps": [
                                    "Pondere evidências: visuais + ACF/PACF + estatísticos; maioria decide.",
                                    "Se não-estacionária: sugira 1ª diferenciação, log-transform se variância crescente.",
                                    "Para sazonal: diferenciação sazonal ou STL decomposition.",
                                    "Valide sugestão com lógica: ex. tendência linear -> diff(1).",
                                    "Escreva relatório final com recomendação acionável."
                                  ],
                                  "verification": "Gere um resumo executivo: 'Conclusão: Não-estacionária. Transformação: diff(1)'.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Todos os outputs anteriores, template de relatório.",
                                  "tips": "Use regra '3 de 3': se 2/3 fontes concordam, siga a maioria.",
                                  "learningObjective": "Sintetizar múltiplas evidências para decisões robustas em séries temporais.",
                                  "commonMistakes": "Sobre-diferenciar (over-differencing) baseado em um teste isolado."
                                }
                              ],
                              "practicalExample": "Usando dataset AirPassengers (passageiros aéreos mensais): Visuais mostram tendência crescente; ACF decai lentamente; ADF p=0.99 (não rejeita unit root), KPSS p=0.01 (rejeita estacionariedade). Conclusão: Não-estacionária com tendência. Sugestão: log(AirPassengers) + diff(1). Após: ADF p=0.03 (estacionária).",
                              "finalVerifications": [
                                "Tabela de resultados integrada cobre todos testes sem omissões.",
                                "Conclusão sobre estacionariedade alinhada com pelo menos 3/4 evidências.",
                                "Sugestão de transformação específica e justificável (ex: diff(order)).",
                                "Relatório inclui plots anotados e p-values exatos.",
                                "Validação cruzada: aplicar transformação sugerida resulta em testes passando.",
                                "Ausência de contradições não resolvidas nos resultados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na interpretação individual de cada teste (90% correto).",
                                "Qualidade da integração: lógica clara de ponderação de evidências.",
                                "Adequação das sugestões de transformação baseadas em padrões observados.",
                                "Completude do relatório: todos elementos visuais e numéricos incluídos.",
                                "Profundidade: identificação de nuances como sazonalidade ou heteroscedasticidade.",
                                "Clareza e comunicação: explicações acessíveis sem jargão excessivo."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: Hipóteses nulas e p-values em testes unit root.",
                                "Programação e Computação: Uso de bibliotecas como statsmodels para automação.",
                                "Economia e Finanças: Aplicação em previsão de PIB ou retornos de ações.",
                                "Machine Learning: Pré-processamento para modelos ARIMA/SARIMA.",
                                "Visualização de Dados: Interpretação de plots ACF/PACF com ferramentas como ggplot."
                              ],
                              "realWorldApplication": "Em finanças, interpretar testes conjuntos em séries de preços de ações para decidir differencing antes de ARIMA, evitando modelos enviesados e melhorando previsões de risco; em meteorologia, analisar precipitação para detectar não-estacionariedade climática e planejar adaptações."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.5",
                    "name": "Transformações de Dados para Exploração",
                    "description": "Aplicação de logaritmos, diferenciações e outras transformações para estabilizar variância e média.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.5.1",
                        "name": "Transformação Logarítmica para Estabilização de Variância",
                        "description": "Uso de logaritmos para reduzir variância heteroscédastica em séries temporais, tornando a variância mais constante ao longo do tempo.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.1.1",
                            "name": "Aplicar transformação logarítmica natural (ln)",
                            "description": "Calcular e aplicar o logaritmo natural aos dados de uma série temporal usando ferramentas como R ou Python para estabilizar variância em séries com crescimento exponencial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente de programação e carregar dados de série temporal",
                                  "subSteps": [
                                    "Instale as bibliotecas necessárias: pandas, numpy, matplotlib e statsmodels via pip.",
                                    "Crie um DataFrame com dados de série temporal simulados ou reais exibindo crescimento exponencial (ex: população ou vendas).",
                                    "Defina o índice temporal usando pd.to_datetime() para garantir formatação correta.",
                                    "Inspecione os dados com .head(), .describe() e plot inicial para confirmar variância crescente.",
                                    "Trate valores ausentes ou zeros (substitua zeros por um pequeno epsilon como 1e-10 para evitar ln(0))."
                                  ],
                                  "verification": "Dados carregados corretamente, plot inicial mostra crescimento exponencial e variância instável.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "Bibliotecas: pandas, numpy, matplotlib",
                                    "Dataset exemplo: CSV com colunas 'date' e 'value'"
                                  ],
                                  "tips": "Use dados reais de fontes como World Bank para maior relevância; sempre verifique NaNs antes de prosseguir.",
                                  "learningObjective": "Configurar ambiente e preparar dados de série temporal para análise.",
                                  "commonMistakes": [
                                    "Aplicar ln diretamente em zeros causando -inf",
                                    "Índice não datetime levando a erros em plots",
                                    "Ignorar outliers que distorcem variância"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar a transformação logarítmica natural (ln) aos dados",
                                  "subSteps": [
                                    "Importe numpy as np e use np.log() na coluna de valores: df['log_value'] = np.log(df['value']).",
                                    "Verifique se há valores inválidos pós-transformação com np.isfinite().",
                                    "Crie uma cópia do DataFrame original para comparação: df_original = df.copy().",
                                    "Salve a série transformada em uma nova coluna ou variável separada.",
                                    "Calcule estatísticas descritivas básicas (média, variância) antes e depois para inspeção inicial."
                                  ],
                                  "verification": "Nova coluna 'log_value' criada sem NaNs ou infs, e estatísticas mostram redução preliminar na variância.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Código Python com numpy",
                                    "DataFrame preparado do Step 1"
                                  ],
                                  "tips": "Adicione 1 ao valor antes do ln se houver zeros: np.log(df['value'] + 1); isso é Box-Cox aproximado.",
                                  "learningObjective": "Executar computacionalmente a transformação ln para estabilizar variância.",
                                  "commonMistakes": [
                                    "Usar log10 em vez de ln (np.log é natural)",
                                    "Não tratar negativos ou zeros",
                                    "Sobrescrever dados originais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Visualizar e comparar séries temporal original e transformada",
                                  "subSteps": [
                                    "Use plt.plot() para sobrepor plots: original vs log-transformada na mesma figura com subplot(1,2).",
                                    "Adicione títulos, labels e legendas claras (ex: 'Série Original' vs 'ln(Transformada)').",
                                    "Calcule e plote a variância rolling (janela de 12 períodos) para ambas as séries.",
                                    "Ajuste escalas dos eixos para melhor visualização (log scale no original se necessário).",
                                    "Salve o gráfico como PNG para documentação."
                                  ],
                                  "verification": "Gráficos mostram variância estabilizada na série ln (menos dispersão em valores altos).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "matplotlib.pyplot",
                                    "DataFrames original e transformado"
                                  ],
                                  "tips": "Use seaborn para plots mais elegantes; foque em tail da série onde variância explode.",
                                  "learningObjective": "Interpretar visualmente o efeito estabilizador da transformação ln.",
                                  "commonMistakes": [
                                    "Escalas inadequadas escondendo diferenças",
                                    "Não plotar rolling variance",
                                    "Confundir ln com diff"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e interpretar a estabilização da variância",
                                  "subSteps": [
                                    "Aplique teste de variância (ex: Levene's test via scipy.stats.levene em janelas deslizantes).",
                                    "Use Augmented Dickey-Fuller (ADF) test do statsmodels para checar estacionariedade pós-ln.",
                                    "Compare ACF/PACF plots antes e depois usando statsmodels.graphics.tsaplots.",
                                    "Documente conclusões: variância estabilizada? Resíduos mais homocedásticos?",
                                    "Prepare relatório curto com métricas (ex: std dev reduzida em X%)."
                                  ],
                                  "verification": "Testes confirmam p-value >0.05 para variância estável ou ADF rejeita não-estacionariedade.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "statsmodels",
                                    "scipy.stats",
                                    "Gráficos do Step 3"
                                  ],
                                  "tips": "Para séries curtas, priorize visual + rolling stats sobre testes formais.",
                                  "learningObjective": "Avaliar quantitativamente o sucesso da transformação ln em estabilizar variância.",
                                  "commonMistakes": [
                                    "Interpretar testes sem contexto (ex: ignorar autocorrelação)",
                                    "Não comparar métricas pré/pós",
                                    "Usar teste errado para variância"
                                  ]
                                }
                              ],
                              "practicalExample": "Carregue dados de crescimento populacional de uma cidade (1950-2020, valores de 10k a 1M habitantes). Aplique ln: população cresce linearmente pós-transformação, variância rolling cai de 20% para 5%, facilitando modelagem ARIMA.",
                              "finalVerifications": [
                                "Série ln exibe variância aproximadamente constante em plots rolling.",
                                "Teste ADF indica estacionariedade melhorada (p-value <0.05 pós-ln).",
                                "ACF decays faster na transformada, confirmando estabilização.",
                                "Nenhum NaN/inf na série transformada.",
                                "Relatório documenta redução percentual na std dev.",
                                "Código reproduzível sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na aplicação de np.log() sem artefatos (zeros tratados).",
                                "Visualizações claras comparando pré/pós com métricas quantitativas.",
                                "Interpretação correta: estabilização confirmada por pelo menos 2 métodos.",
                                "Código limpo, comentado e modular.",
                                "Tratamento edge cases (ausentes, zeros).",
                                "Conclusões alinhadas com evidências empíricas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Propriedades de logaritmos e funções exponenciais.",
                                "Programação: Manipulação de dados com pandas/numpy.",
                                "Economia: Modelagem de crescimento em séries financeiras.",
                                "Biologia: Análise de curvas epidêmicas (ex: COVID casos).",
                                "Física: Transformações em dados sensoriais exponenciais."
                              ],
                              "realWorldApplication": "Em finanças, estabiliza retornos de ações para Value-at-Risk; em epidemiologia, transforma contagens de casos COVID para previsão precisa; em marketing, normaliza vendas sazonais exponenciais para forecasting."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.1.2",
                            "name": "Identificar necessidade de logaritmo pela análise gráfica",
                            "description": "Analisar gráficos de série temporal original e log-transformada para verificar redução de variância crescente, usando testes como ACF para confirmação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e visualizar a série temporal original",
                                  "subSteps": [
                                    "Carregue o conjunto de dados de série temporal usando pandas.read_csv() ou similar.",
                                    "Converta a coluna de tempo em índice datetime com pd.to_datetime().",
                                    "Plote o gráfico da série original usando plt.plot() ou equivalent em R.",
                                    "Adicione rótulos de eixos, título e grade para clareza visual.",
                                    "Salve ou exiba o gráfico para análise inicial."
                                  ],
                                  "verification": "Gráfico da série temporal original é gerado e exibido corretamente, mostrando o comportamento ao longo do tempo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python com pandas, matplotlib; ou R com ggplot2; conjunto de dados de série temporal (ex: vendas mensais).",
                                  "tips": "Use log escala no eixo y inicialmente para inspeção rápida, mas compare com escala linear.",
                                  "learningObjective": "Dominar a preparação e visualização básica de séries temporais para análise exploratória.",
                                  "commonMistakes": "Ignorar a conversão de índice temporal, resultando em eixo x incorreto; não adicionar rótulos claros."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar variância na série original",
                                  "subSteps": [
                                    "Inspecione visualmente o gráfico para padrões de variância crescente (heteroscendasticidade).",
                                    "Calcule e plote a variância rolante (rolling variance) com df.rolling(window=12).var().",
                                    "Observe se a amplitude das flutuações aumenta com o nível da série.",
                                    "Anote evidências qualitativas e quantitativas de variância não constante.",
                                    "Documente observações em um relatório ou notebook."
                                  ],
                                  "verification": "Relatório ou anotações confirmam identificação de variância crescente com suporte visual e rolling stats.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Pandas para rolling stats; matplotlib para plots adicionais.",
                                  "tips": "Escolha window size baseado na frequência da série (ex: 12 para mensal).",
                                  "learningObjective": "Identificar heteroscendasticidade visual e quantitativamente em séries temporais.",
                                  "commonMistakes": "Confundir tendência com variância; usar window muito pequena que adiciona ruído."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar transformação logarítmica e visualizar",
                                  "subSteps": [
                                    "Crie a série log-transformada com np.log(df['value']) ou log() em R, lidando com zeros adicionando pequena constante se necessário.",
                                    "Plote o gráfico da série log-transformada ao lado do original para comparação.",
                                    "Calcule e plote a variância rolante da série log-transformada.",
                                    "Inspecione se a variância agora parece constante ao longo do tempo.",
                                    "Salve gráficos comparativos."
                                  ],
                                  "verification": "Gráficos lado a lado mostram redução na variância crescente na versão log-transformada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "NumPy para log; mesmo ambiente de plotting.",
                                  "tips": "Use np.log1p() para valores próximos de zero para evitar -inf.",
                                  "learningObjective": "Aplicar e visualizar transformação logarítmica para estabilizar variância.",
                                  "commonMistakes": "Aplicar log em série com zeros ou negativos sem ajuste; não comparar diretamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Confirmar com análise ACF e concluir necessidade",
                                  "subSteps": [
                                    "Calcule a Função de Autocorrelação (ACF) para ambas as séries usando statsmodels.tsa.stattools.acf().",
                                    "Plote ACF para original e log-transformada, focando em decaimento lento ou padrões irregulares.",
                                    "Compare: ACF da log deve mostrar decaimento mais estável sem variância crescente afetando.",
                                    "Decida necessidade baseada em: variância estabilizada + ACF melhorada.",
                                    "Registre conclusão: 'Log necessário' ou 'Não necessário' com justificativa."
                                  ],
                                  "verification": "Plots ACF comparativos e conclusão documentada suportam decisão sobre transformação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Statsmodels ou forecast em R para ACF.",
                                  "tips": "Foco nos primeiros 20 lags; use confiança intervals para significância.",
                                  "learningObjective": "Usar ACF como confirmação quantitativa para necessidade de estabilização de variância.",
                                  "commonMistakes": "Interpretar ACF sem contexto de variância; ignorar lags iniciais fortes comuns em tendências."
                                }
                              ],
                              "practicalExample": "Usando dados de vendas mensais de varejo (ex: dataset 'ausair' ou vendas Walmart), plote a série original mostrando variância crescente com picos sazonais amplificando. Após log, variância estabiliza, confirmado por ACF com decaimento suave.",
                              "finalVerifications": [
                                "Gráficos comparativos mostram redução clara de variância crescente.",
                                "Variância rolante é aproximadamente constante na série log.",
                                "ACF da log-transformada exibe decaimento mais estável sem artefatos de heteroscendasticidade.",
                                "Conclusão justificada com evidências visuais e quantitativas.",
                                "Documentação inclui todos os plots e métricas.",
                                "Série log pronta para próximas análises (ex: estacionariedade)."
                              ],
                              "assessmentCriteria": [
                                "Identificação precisa de variância crescente na original (pontos totais: 20%).",
                                "Aplicação correta de log-transformação sem erros numéricos (20%).",
                                "Comparação visual e quantitativa robusta (25%).",
                                "Uso adequado de ACF para confirmação (20%).",
                                "Conclusão lógica e documentada (15%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Propriedades de funções logarítmicas e estabilização de variância.",
                                "Programação: Manipulação de dados com pandas/NumPy e visualização.",
                                "Economia: Aplicação em previsão de vendas ou PIB.",
                                "Física: Modelagem de fenômenos exponenciais como crescimento populacional."
                              ],
                              "realWorldApplication": "Em finanças, estabilizar variância em retornos de ações para modelagem ARIMA precisa; em epidemiologia, analisar curvas de casos COVID-19 para prever surtos sem viés de variância crescente."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.1.3",
                            "name": "Interpretar e reverter transformação logarítmica",
                            "description": "Explicar o impacto da transformação nos resíduos e prever valores originais via exponencial da previsão log-transformada, ajustando bias se necessário.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o impacto da transformação logarítmica nos resíduos",
                                  "subSteps": [
                                    "Revise a fórmula da transformação: y_log = log(y), onde log é geralmente log natural (ln).",
                                    "Explique como variância multiplicativa em y se torna aditiva em y_log, estabilizando a variância.",
                                    "Analise resíduos originais: identifique heterocedasticidade (variância crescente).",
                                    "Compare resíduos após transformação: verifique homocedasticidade e normalidade.",
                                    "Discuta propriedades: resíduos em y_log ≈ N(0, σ²), facilitando modelagem linear."
                                  ],
                                  "verification": "Plotar resíduos originais vs. transformados mostra estabilização de variância (gráficos de resíduos aleatórios e constantes).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python (pandas, matplotlib, statsmodels)",
                                    "Dataset de série temporal com variância crescente (ex: vendas mensais)"
                                  ],
                                  "tips": "Use qqplot para checar normalidade dos resíduos transformados.",
                                  "learningObjective": "Explicar teoricamente como a log-transformação converte variância multiplicativa em aditiva nos resíduos.",
                                  "commonMistakes": [
                                    "Usar log10 em vez de ln sem justificativa",
                                    "Ignorar valores zero ou negativos (pré-tratar com log(1+y))",
                                    "Confundir impacto na média vs. variância"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Interpretar resíduos na escala log-transformada",
                                  "subSteps": [
                                    "Ajuste um modelo simples (ex: ARIMA) nos dados log-transformados.",
                                    "Extraia e plote resíduos: verifique média zero, ausência de autocorrelação (ACF/PACF).",
                                    "Teste normalidade (Shapiro-Wilk) e homocedasticidade (Breusch-Pagan).",
                                    "Interprete desvios: resíduos positivos indicam subestimação relativa no log.",
                                    "Documente melhorias: redução na variância dos resíduos em comparação ao original."
                                  ],
                                  "verification": "Testes estatísticos confirmam resíduos estacionários e normais (p-value > 0.05).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Jupyter Notebook",
                                    "Bibliotecas: statsmodels, scipy.stats",
                                    "Dataset log-transformado"
                                  ],
                                  "tips": "Padronize resíduos para interpretação: z-score = resíduo / σ.",
                                  "learningObjective": "Interpretar resíduos transformados para validar estabilização de variância.",
                                  "commonMistakes": [
                                    "Não testar autocorrelação nos resíduos",
                                    "Interpretar resíduos log como absolutos originais",
                                    "Ignorar outliers que distorcem variância"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Reverter a transformação logarítmica nas previsões",
                                  "subSteps": [
                                    "Gere previsões no espaço log: ŷ_log = modelo.predict().",
                                    "Aplique inversa: ŷ = exp(ŷ_log).",
                                    "Compare com valores originais: calcule erros (MAE, RMSE na escala original).",
                                    "Plote séries original, log, previsão log e previsão revertida.",
                                    "Explique viés: E[exp(ε)] ≠ 1 para ε ~ N(0,σ²), causando subestimação sistemática."
                                  ],
                                  "verification": "Previsões revertidas alinham-se visualmente com tendência original; RMSE < threshold definido.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python (numpy para exp)",
                                    "Gráficos comparativos"
                                  ],
                                  "tips": "Use np.exp() para precisão numérica; evite overflow com clipping.",
                                  "learningObjective": "Executar reversão exponencial correta de previsões log-transformadas.",
                                  "commonMistakes": [
                                    "Esquecer exp() e reportar ŷ_log como original",
                                    "Não plotar para validar alinhamento",
                                    "Aplicar exp em resíduos ao invés de previsões"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ajustar viés e validar reversão completa",
                                  "subSteps": [
                                    "Calcule fator de viés: bias_factor = mean(exp(resíduos_log)).",
                                    "Ajuste previsão: ŷ_adjusted = exp(ŷ_log) * bias_factor.",
                                    "Valide com cross-validation: compare erros ajustados vs. não ajustados.",
                                    "Avalie incerteza: intervalos de previsão revertidos via exp(limites_log).",
                                    "Conclua: documente impacto nos resíduos originais pós-ajuste."
                                  ],
                                  "verification": "Viés ajustado reduz RMSE em >10%; resíduos originais mostram média próxima de zero.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código para bias_factor",
                                    "Funções de avaliação (sklearn.metrics)"
                                  ],
                                  "tips": "Para σ pequeno (<0.1), viés é negligible; sempre reporte ambos.",
                                  "learningObjective": "Corrigir viés na reversão e validar precisão na escala original.",
                                  "commonMistakes": [
                                    "Calcular viés como mean(resíduos_log) em vez de exp()",
                                    "Ajustar in-sample apenas, sem out-of-sample",
                                    "Ignorar propagação de variância nos intervalos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma série temporal de preços de ações diários (ex: AAPL), variância crescente é estabilizada por log(preço). Modelo ARIMA prevê log(preço_t+1) = 4.65. Reversão: preço = exp(4.65) ≈ 104.5. Viés médio exp(resíduos) = 1.02, ajustado: 104.5 * 1.02 ≈ 106.6, alinhando melhor com preço real de 107.",
                              "finalVerifications": [
                                "Explica corretamente como log estabiliza variância nos resíduos.",
                                "Reverte previsões via exp() com precisão numérica.",
                                "Identifica e corrige viés usando mean(exp(resíduos_log)).",
                                "Valida com plots e métricas na escala original.",
                                "Discute limitações (ex: valores zero).",
                                "Compara resíduos pré e pós-reversão."
                              ],
                              "assessmentCriteria": [
                                "Exatidão teórica da interpretação de resíduos (nota 1-5).",
                                "Correção na implementação de exp() e bias adjustment (pass/fail).",
                                "Qualidade dos plots e visualizações (clareza, labels).",
                                "Precisão das métricas de erro (RMSE < 15% do MAE baseline).",
                                "Profundidade da discussão de viés e incerteza.",
                                "Validação out-of-sample realizada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Propriedades de funções logarítmica e exponencial (inversas).",
                                "Programação: Implementação em Python/R com numpy/statsmodels.",
                                "Economia/Finanças: Modelagem de séries com variância condicional (GARCH-like).",
                                "Probabilidade: Distribuição log-normal e momentos (E[exp(X)] para X normal).",
                                "Visualização de Dados: Plots de resíduos e forecasts."
                              ],
                              "realWorldApplication": "Em previsão de demanda de produtos (ex: varejo), log estabiliza variância sazonal; reversão ajustada por viés melhora estoque e pricing. Em epidemiologia, log(casos) modela crescimento exponencial, revertendo para projeções reais de infecções."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.5.2",
                        "name": "Diferenciação para Estabilização de Média",
                        "description": "Aplicação de operadores de diferença para remover tendência e tornar a série estacionária em média.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.2.1",
                            "name": "Realizar diferenciação de primeira ordem",
                            "description": "Computar diferenças sucessivas (Y_t - Y_{t-1}) em uma série temporal não estacionária para eliminar tendência linear, verificando estacionariedade com teste ADF.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e carregar a série temporal original",
                                  "subSteps": [
                                    "Instale as bibliotecas necessárias: pandas, matplotlib, statsmodels.",
                                    "Carregue o conjunto de dados de série temporal (ex: CSV com coluna de data e valores Y_t).",
                                    "Converta a coluna de data em índice datetime e defina a frequência (mensal, trimestral etc.).",
                                    "Plote a série temporal original para visualizar tendência linear.",
                                    "Calcule estatísticas descritivas básicas (média, variância)."
                                  ],
                                  "verification": "Gráfico da série original exibido corretamente com tendência visível; estatísticas calculadas sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "Bibliotecas: pandas, matplotlib, statsmodels",
                                    "Dataset de série temporal (ex: PIB trimestral)"
                                  ],
                                  "tips": "Use pd.read_csv com parse_dates=True para facilitar o índice datetime.",
                                  "learningObjective": "Configurar ambiente de análise de séries temporais e visualizar dados iniciais.",
                                  "commonMistakes": [
                                    "Ignorar frequência da série (use .asfreq())",
                                    "Plotar sem índice datetime",
                                    "Não verificar valores ausentes (use .dropna())"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Testar estacionariedade da série temporal original com ADF",
                                  "subSteps": [
                                    "Importe o teste Augmented Dickey-Fuller de statsmodels.tsa.stattools.",
                                    "Execute adfuller(serie_original) e capture estatísticas: statistic, pvalue, lags.",
                                    "Interprete: se p-value > 0.05, série não estacionária (confirme tendência).",
                                    "Plote ACF/PACF para auxiliar diagnóstico visual.",
                                    "Registre resultados em um dicionário ou DataFrame para comparação posterior."
                                  ],
                                  "verification": "Resultado ADF da original mostra p-value > 0.05; ACF decay lento indicando não-estacionariedade.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "statsmodels.tsa.stattools.adfuller",
                                    "statsmodels.graphics.tsaplots.plot_acf"
                                  ],
                                  "tips": "Use lags='auto' para seleção automática de lags no teste.",
                                  "learningObjective": "Aplicar e interpretar teste ADF para diagnosticar não-estacionariedade.",
                                  "commonMistakes": [
                                    "Confundir p-value com test statistic",
                                    "Não plotar ACF para confirmação visual",
                                    "Executar teste em dados com NaNs"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar a diferenciação de primeira ordem",
                                  "subSteps": [
                                    "Crie a série diferenciada: diff_serie = serie_original.diff().dropna()",
                                    "Verifique o comprimento: deve ser len(original) - 1.",
                                    "Plote a série diferenciada ao lado da original para comparação.",
                                    "Calcule estatísticas descritivas da diferenciada (média próxima de zero indica remoção de tendência).",
                                    "Salve a série diferenciada em variável para testes subsequentes."
                                  ],
                                  "verification": "Série diferenciada calculada corretamente (Y_t - Y_{t-1}); sem NaNs iniciais; gráfico mostra remoção de tendência.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Método pandas.Series.diff()"
                                  ],
                                  "tips": "Sempre use .dropna() após diff() para remover o NaN inicial.",
                                  "learningObjective": "Implementar diferenciação de primeira ordem para eliminar tendência linear.",
                                  "commonMistakes": [
                                    "Esquecer .dropna()",
                                    "Usar diff(1) incorretamente",
                                    "Confundir com diff de segunda ordem prematuramente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar estacionariedade da série diferenciada com ADF",
                                  "subSteps": [
                                    "Execute adfuller(diff_serie) e compare com resultados originais.",
                                    "Confirme p-value < 0.05 na diferenciada (rejeitar H0 de não-estacionariedade).",
                                    "Plote ACF/PACF da diferenciada: decay mais rápido esperado.",
                                    "Compare gráficos e estatísticas em subplot (original vs diferenciada).",
                                    "Documente conclusão: tendência linear eliminada."
                                  ],
                                  "verification": "ADF na diferenciada mostra p-value < 0.05; gráficos confirmam estabilização de média.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "statsmodels.tsa.stattools.adfuller",
                                    "matplotlib.pyplot.subplot"
                                  ],
                                  "tips": "Use critical values do ADF para interpretação robusta além do p-value.",
                                  "learningObjective": "Validar efetividade da diferenciação via teste estatístico e visual.",
                                  "commonMistakes": [
                                    "Não comparar p-values corretamente",
                                    "Ignorar lags diferentes entre testes",
                                    "Concluir estacionariedade sem plot ACF"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar resultados e preparar para modelagem",
                                  "subSteps": [
                                    "Resuma diferenças: estatísticas, p-values, observações visuais.",
                                    "Se ainda não estacionária, note necessidade de diferenciação adicional ou outras transformações.",
                                    "Exporte série diferenciada para uso em ARIMA ou outros modelos.",
                                    "Crie relatório com gráficos e tabelas de testes ADF.",
                                    "Teste robustez com subamostra dos dados."
                                  ],
                                  "verification": "Relatório completo com evidência de eliminação de tendência; série pronta para modelagem.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "pandas.DataFrame.to_csv()",
                                    "Jupyter Notebook para relatório"
                                  ],
                                  "tips": "Salve plots com plt.savefig() para inclusão no relatório.",
                                  "learningObjective": "Sintetizar análise e conectar com etapas subsequentes de séries temporais.",
                                  "commonMistakes": [
                                    "Não documentar comparações",
                                    "Assumir estacionariedade sem verificação múltipla",
                                    "Exportar sem dropna final"
                                  ]
                                }
                              ],
                              "practicalExample": "Carregue dados de PIB trimestral dos EUA (fonte: FRED). A série original mostra tendência crescente. Aplique diff(): a diferenciada oscila em torno de zero sem tendência linear. ADF original: p=0.85 (não estacionária); diferenciada: p=0.01 (estacionária).",
                              "finalVerifications": [
                                "Série original exibe tendência linear visível no plot.",
                                "Teste ADF original tem p-value > 0.05.",
                                "Diferenciação de 1ª ordem remove tendência (média ~0 na diff).",
                                "Teste ADF diferenciada tem p-value < 0.05.",
                                "ACF da diferenciada decai rapidamente.",
                                "Relatório compara original vs diferenciada corretamente."
                              ],
                              "assessmentCriteria": [
                                "Cálculo exato da diff sem erros numéricos.",
                                "Interpretação correta de p-values ADF (rejeitar/aceitar H0).",
                                "Gráficos claros comparando original e diferenciada.",
                                "Uso apropriado de .dropna() e índice datetime.",
                                "Conclusão alinhada com resultados (estacionariedade alcançada).",
                                "Documentação completa com estatísticas e plots."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de diferenças finitas e sequências.",
                                "Programação: Manipulação de dados com pandas e visualização.",
                                "Economia: Análise de indicadores macroeconômicos como PIB.",
                                "Estatística: Testes de hipóteses unit root.",
                                "Machine Learning: Pré-processamento para modelos de previsão."
                              ],
                              "realWorldApplication": "Em finanças, diferenciação de preços de ações remove tendências para modelar retornos estacionários em trading algorítmico; em previsão de demanda, estabiliza vendas mensais para ARIMA em supply chain."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.2.2",
                            "name": "Aplicar diferenciação sazonal",
                            "description": "Executar diferenças sazonais (Y_t - Y_{t-s}) para séries com periodicidade sazonal conhecida (ex: s=12 para dados mensais), combinando com diferenciação regular se necessário.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar a Periodicidade Sazonal na Série Temporal",
                                  "subSteps": [
                                    "Carregue a série temporal em um software como R ou Python (pacotes forecast ou statsmodels).",
                                    "Plote o gráfico da série temporal para observar padrões repetitivos.",
                                    "Calcule e plote a Função de Autocorrelação (ACF) para detectar picos em lags múltiplos de s (ex: s=12 para mensais).",
                                    "Confirme a periodicidade s com base no domínio do problema (ex: 12 para mensal, 4 para trimestral).",
                                    "Documente a escolha de s e evidências visuais."
                                  ],
                                  "verification": "Gráfico da ACF exibe picos significativos em lags s, 2s, 3s, indicando sazonalidade clara.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Dados da série temporal (CSV ou DataFrame)",
                                    "R (pacote forecast) ou Python (statsmodels, pandas)",
                                    "Funções plot() e acf()"
                                  ],
                                  "tips": "Comece sempre com visualização; padrões anuais em mensais são comuns (picos em lag 12).",
                                  "learningObjective": "Reconhecer e quantificar periodicidade sazonal usando gráficos e ACF.",
                                  "commonMistakes": [
                                    "Ignorar picos fracos na ACF",
                                    "Confundir sazonalidade com tendência de longo prazo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar a Diferenciação Sazonal",
                                  "subSteps": [
                                    "Selecione o lag s identificado (ex: s=12).",
                                    "Compute a nova série: Y_diff_sazonal[t] = Y[t] - Y[t-s] para t > s.",
                                    "Use funções prontas: diff(Y, lag=s) no R ou seasonal_decompose/diff no Python.",
                                    "Remova valores NA iniciais (primeiros s observações).",
                                    "Plote a série diferenciada sazonalmente para inspeção inicial."
                                  ],
                                  "verification": "Nova série gerada sem NA's excessivos e gráfico mostra remoção de padrão sazonal repetitivo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Série temporal original",
                                    "R (diff() com lag) ou Python (pandas diff(periods=s))"
                                  ],
                                  "tips": "Sempre verifique o comprimento da série pós-diferença para evitar perda de dados.",
                                  "learningObjective": "Executar computacionalmente a operação Y_t - Y_{t-s} de forma precisa.",
                                  "commonMistakes": [
                                    "Aplicar lag errado (ex: s=4 em mensais)",
                                    "Não tratar NA's iniciais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar Necessidade e Aplicar Diferenciação Regular",
                                  "subSteps": [
                                    "Plote a série sazonalmente diferenciada e verifique presença de tendência (média não constante).",
                                    "Aplique teste de estacionariedade (KPSS ou ADF) na série sazonal.",
                                    "Se não estacionária, aplique diferenciação regular: diff(Y_diff_sazonal, lag=1).",
                                    "Repita testes e plots até estacionariedade.",
                                    "Registre o número de diferenciações regulares usadas (geralmente 0 ou 1)."
                                  ],
                                  "verification": "Testes KPSS/ADF rejeitam não-estacionariedade (p-valor > 0.05) e gráfico sem tendência.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "R (urca para testes) ou Python (statsmodels.tsa.stattools adfuller/kpss)"
                                  ],
                                  "tips": "Combine apenas se necessário; overdifferencing cria não-estacionariedade invertida.",
                                  "learningObjective": "Integrar diferenciação sazonal com regular para estabilizar média.",
                                  "commonMistakes": [
                                    "Aplicar regular sem testar",
                                    "Ignorar overdifferencing (ACF cortada abruptamente)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Interpretar a Transformação Final",
                                  "subSteps": [
                                    "Compare gráficos originais, sazonal e combinada.",
                                    "Recompute ACF da série final para confirmar ausência de sazonalidade e tendência.",
                                    "Realize testes formais de estacionariedade na série final.",
                                    "Documente mudanças (ex: variância reduzida, remoção de picos).",
                                    "Salve a série transformada para análises futuras."
                                  ],
                                  "verification": "ACF da final sem picos sazonais ou tendência, testes confirmam estacionariedade.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Gráficos comparativos",
                                    "Funções ACF e testes de estacionariedade"
                                  ],
                                  "tips": "Use múltiplas visualizações lado a lado para comparação intuitiva.",
                                  "learningObjective": "Validar efetividade da diferenciação sazonal na estabilização.",
                                  "commonMistakes": [
                                    "Não comparar com original",
                                    "Aceitar resultados sem testes estatísticos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em dados mensais de vendas de sorvetes (s=12), aplique diff(vendas, lag=12): vendas_jun_2023 - vendas_jun_2022 remove picos de verão anuais, resultando em série estável para modelagem ARIMA.",
                              "finalVerifications": [
                                "Série sazonalmente diferenciada remove padrões repetitivos visíveis.",
                                "ACF não mostra picos em múltiplos de s.",
                                "Testes ADF/KPSS indicam estacionariedade (p>0.05).",
                                "Gráficos comparativos evidenciam estabilização de média.",
                                "Combinação com regular aplicada corretamente se necessário.",
                                "Documentação inclui s, plots e testes."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de s (baseada em ACF/domínio).",
                                "Correta implementação da fórmula Y_t - Y_{t-s}.",
                                "Uso apropriado de testes de estacionariedade.",
                                "Interpretação correta de gráficos e ACF pré/pós.",
                                "Ausência de erros comuns como NA's ou overdifferencing.",
                                "Documentação clara e reproduzível."
                              ],
                              "crossCurricularConnections": [
                                "Economia: Análise sazonal em PIB trimestral (s=4).",
                                "Meteorologia: Temperaturas mensais com s=12.",
                                "Finanças: Retornos de ações com sazonalidade anual.",
                                "Saúde Pública: Casos de doenças sazonais (ex: gripe).",
                                "Agricultura: Produção de colheitas com ciclos anuais."
                              ],
                              "realWorldApplication": "Em empresas de varejo, diferenciação sazonal estabiliza séries de vendas para previsões precisas de estoque, reduzindo desperdícios em picos como Natal (s=12 mensais)."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.2.3",
                            "name": "Avaliar ordem de diferenciação via inspeção gráfica e testes",
                            "description": "Usar PACF e teste KPSS para determinar o número mínimo de diferenciações necessárias, evitando sobrediferenciação que introduz não-estacionariedade artificial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparação dos Dados e Inspeção Gráfica Inicial",
                                  "subSteps": [
                                    "Carregue o dataset de série temporal usando pandas (ex: dados de PIB trimestral).",
                                    "Plote a série temporal original para observar tendências e variância.",
                                    "Calcule e plote os gráficos de autocorrelação (ACF) e autocorrelação parcial (PACF) usando statsmodels.",
                                    "Analise visualmente: procure por decaimento lento no ACF (indicando não-estacionariedade).",
                                    "Documente observações iniciais em um relatório."
                                  ],
                                  "verification": "Gráficos de ACF/PACF gerados e análise escrita confirmando sinais de não-estacionariedade (ex: ACF decai lentamente).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python (pandas, matplotlib, statsmodels.tsa.stattools), dataset de série temporal (ex: airpassengers ou PIB.csv)",
                                  "tips": "Use escala logarítmica se houver tendência crescente na variância para melhor visualização.",
                                  "learningObjective": "Identificar visualmente padrões de não-estacionariedade em séries temporais via ACF e PACF.",
                                  "commonMistakes": "Confundir ruído com tendência; ignorar múltiplas lags no PACF."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicação do Teste KPSS na Série Original",
                                  "subSteps": [
                                    "Implemente o teste KPSS usando statsmodels.tsa.stattools.kpss com regress='c' para média constante.",
                                    "Registre o p-value e estatística do teste.",
                                    "Interprete: se p-value < 0.05, rejeite H0 (série não estacionária).",
                                    "Compare resultados com inspeção gráfica para validação.",
                                    "Salve resultados em uma tabela comparativa."
                                  ],
                                  "verification": "Relatório com p-value < 0.05 confirmando não-estacionariedade, alinhado à análise gráfica.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Python (statsmodels.tsa.stattools.kpss), notebook Jupyter",
                                  "tips": "Sempre especifique o tipo de regressor correto (c para constante, ct para tendência).",
                                  "learningObjective": "Executar e interpretar o teste KPSS para testar estacionariedade em média.",
                                  "commonMistakes": "Usar ADF em vez de KPSS (testes complementares, mas KPSS é mais poderoso para sobredif); ignorar tamanho da amostra."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciação Iterativa e Reteste até Estacionariedade",
                                  "subSteps": [
                                    "Aplique diferenciação de primeira ordem: diff1 = serie.diff().dropna().",
                                    "Repita inspeção gráfica (ACF/PACF) e teste KPSS na diff1.",
                                    "Se ainda não estacionária (p<0.05), aplique segunda diferenciação (diff2) e reteste.",
                                    "Continue até p-value >= 0.05, registrando ordem d em cada iteração.",
                                    "Plote todas as versões diferenciadas para comparação visual."
                                  ],
                                  "verification": "Tabela de resultados mostrando ordem mínima d onde KPSS p>=0.05, com plots correspondentes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python (pandas para diff(), statsmodels para testes e plots)",
                                  "tips": "Use um loop while para automação, parando quando p>=0.05 ou d=2 (máximo prático).",
                                  "learningObjective": "Implementar diferenciação iterativa guiada por testes estatísticos para alcançar estacionariedade.",
                                  "commonMistakes": "Diferenciar excessivamente sem reteste (leva a sobredif); não remover NaNs após diff()."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validação com PACF e Verificação de Sobrediferenciação",
                                  "subSteps": [
                                    "Analise PACF da série diferenciada ótima: corte significativo após lag baixo indica ordem AR.",
                                    "Teste KPSS na diferenciação d+1 para detectar não-estacionariedade artificial (p<0.05 indica sobredif).",
                                    "Compare variância e espectro de ACF entre d e d+1.",
                                    "Confirme ordem mínima: menor d com estacionariedade confirmada.",
                                    "Gere relatório final com recomendação de d."
                                  ],
                                  "verification": "Relatório final especificando d ótima, com evidência de PACF estável e KPSS falhando em d+1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Python (statsmodels para PACF e KPSS), ferramentas de plotting",
                                  "tips": "PACF com spikes significativos só nos primeiros lags valida a diferenciação mínima.",
                                  "learningObjective": "Usar PACF para refinar ordem de diferenciação e evitar sobrediferenciação via testes reversos.",
                                  "commonMistakes": "Assumir d=1 sempre; ignorar PACF em favor só de KPSS."
                                }
                              ],
                              "practicalExample": "Usando o dataset clássico 'airpassengers' (passageiros aéreos mensais): ACF original decai lentamente (não-estacionária), KPSS p<0.05. Após 1ª diff, ainda não; 2ª diff atinge p=0.08 (>=0.05). PACF de 2ª diff mostra corte após lag 1, mas teste em 3ª diff falha (p<0.05), confirmando d=2 mínima.",
                              "finalVerifications": [
                                "KPSS p-value >=0.05 na ordem d recomendada.",
                                "ACF decai rapidamente (< lag 10) na série diferenciada.",
                                "PACF tem poucos spikes significativos, indicando modelo simples.",
                                "Teste KPSS em d+1 tem p<0.05 (evidência contra sobredif).",
                                "Variância da residual não aumenta artificialmente.",
                                "Plots visuais confirmam estabilização de média."
                              ],
                              "assessmentCriteria": [
                                "Correta implementação e interpretação de KPSS (p-value e decisão).",
                                "Identificação precisa da ordem mínima d via iteração.",
                                "Uso integrado de gráficos ACF/PACF com testes estatísticos.",
                                "Detecção e justificativa contra sobrediferenciação.",
                                "Relatório claro com tabelas/plots e recomendação fundamentada.",
                                "Eficiência: tempo e código otimizados sem erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estatística inferencial e processos estocásticos.",
                                "Programação: Manipulação de dados em Python/R e visualização.",
                                "Economia: Análise de séries macroeconômicas como PIB/inflação.",
                                "Machine Learning: Pré-processamento para modelos de forecasting (ARIMA/LSTM)."
                              ],
                              "realWorldApplication": "Em finanças, determinar d para modelar retornos de ações (ex: prever volatilidade da AAPL), evitando forecasts enviesados por sobrediferenciação; ou em supply chain, estabilizar séries de vendas sazonais para planejamento preciso de estoque."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.5.3",
                        "name": "Outras Transformações para Estabilização",
                        "description": "Transformações adicionais como Box-Cox para estabilizar variância e média de forma parametrizada em séries complexas.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.3.1",
                            "name": "Implementar transformação Box-Cox",
                            "description": "Estimar parâmetro lambda via máxima verossimilhança e aplicar transformação Box-Cox em software estatístico para séries com variância não estabilizada por log simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente de software e carregar dados da série temporal",
                                  "subSteps": [
                                    "Instalar e carregar bibliotecas necessárias (ex: forecast ou MASS em R, ou scipy.stats em Python).",
                                    "Importar o conjunto de dados da série temporal com variância não constante.",
                                    "Visualizar a série original com plots (ex: plot de linha e plot de resíduos quadrados para detectar heterocedasticidade).",
                                    "Confirmar que log simples não estabiliza a variância via plot de log-transformados.",
                                    "Preparar o vetor de dados numéricos positivos (requisito Box-Cox)."
                                  ],
                                  "verification": "Plots gerados mostram variância instável na série original e após log; dados preparados sem erros.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software R ou Python com bibliotecas forecast/MASS/scipy",
                                    "Dataset de série temporal exemplo (ex: AirPassengers)"
                                  ],
                                  "tips": "Sempre verifique se todos valores são positivos antes de Box-Cox; adicione pequeno epsilon se necessário.",
                                  "learningObjective": "Configurar ambiente e diagnosticar necessidade de transformação Box-Cox.",
                                  "commonMistakes": [
                                    "Usar dados com zeros ou negativos",
                                    "Pular visualização inicial",
                                    "Bibliotecas não carregadas corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estimar o parâmetro lambda via máxima verossimilhança",
                                  "subSteps": [
                                    "Aplicar função boxcox() em R ou boxcox_transform em Python para estimar lambda.",
                                    "Definir intervalo de lambda (ex: c(-2,2)) e método 'mle' para máxima verossimilhança.",
                                    "Extrair o valor ótimo de lambda e seu intervalo de confiança.",
                                    "Plotar perfil de log-verossimilhança para validar a estimação.",
                                    "Comparar lambda estimado com valores comuns (ex: 0 para log, 1 para linear)."
                                  ],
                                  "verification": "Lambda estimado com IC não contém 0 ou 1 se log simples falhou; plot de perfil suave.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Funções boxcox() do pacote MASS em R ou scipy.stats.boxcox em Python"
                                  ],
                                  "tips": "Use lambda=0 para log se próximo; teste robustez com bootstrap se dataset pequeno.",
                                  "learningObjective": "Compreender e aplicar estimação MLE para lambda Box-Cox.",
                                  "commonMistakes": [
                                    "Intervalo de lambda muito restrito",
                                    "Ignorar IC de lambda",
                                    "Confundir lambda ótimo com outros métodos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a transformação Box-Cox à série temporal",
                                  "subSteps": [
                                    "Usar lambda estimado para transformar os dados com função boxcox() ou equivalente.",
                                    "Criar nova série transformada e plotá-la ao lado da original.",
                                    "Verificar estabilização de variância nos resíduos da transformada.",
                                    "Se necessário, diferenciar a série transformada para estacionariedade.",
                                    "Salvar/transformar dados para análises subsequentes."
                                  ],
                                  "verification": "Plot da transformada mostra variância constante; teste de Breusch-Pagan p-valor >0.05.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Mesmo software e funções do step anterior",
                                    "Função para teste de heterocedasticidade (lmtest::bptest em R)"
                                  ],
                                  "tips": "Aplique transformação em todo período, mas avalie separadamente in-sample/out-of-sample.",
                                  "learningObjective": "Implementar transformação usando lambda ótimo e validar impacto.",
                                  "commonMistakes": [
                                    "Usar lambda errado",
                                    "Não plotar comparação antes/depois",
                                    "Esquecer de transformar previsões futuras"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e interpretar a transformação Box-Cox",
                                  "subSteps": [
                                    "Realizar testes estatísticos: Shapiro-Wilk para normalidade, Breusch-Pagan para variância.",
                                    "Comparar ACF/PACF antes e depois para estacionariedade.",
                                    "Back-transformar amostra para verificar reversibilidade.",
                                    "Documentar lambda usado e métricas de melhoria (ex: variância de resíduos reduzida).",
                                    "Preparar relatório com plots e conclusões."
                                  ],
                                  "verification": "Testes confirmam estabilização (p>0.05 em variância); ACF mostra menos autocorrelação.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Testes: shapiro.test(), bptest() em R; statsmodels em Python"
                                  ],
                                  "tips": "Se lambda extremo, considere alternativas como Yeo-Johnson para dados não-positivos.",
                                  "learningObjective": "Avaliar eficácia da transformação e preparar para modelagem.",
                                  "commonMistakes": [
                                    "Ignorar back-transformation",
                                    "Testes inadequados para séries temporais",
                                    "Concluir sem métricas quantitativas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em dados de passageiros aéreos mensais (AirPassengers), variância aumenta com tempo. Estimar lambda ≈0.5 via MLE, aplicar Box-Cox, plotar transformada com variância estável, permitindo modelagem ARIMA mais precisa.",
                              "finalVerifications": [
                                "Lambda estimado via MLE com IC reportado.",
                                "Plots antes/depois mostram estabilização de variância.",
                                "Testes de variância e normalidade aprovados (p>0.05).",
                                "Série transformada pronta para análise exploratória subsequente.",
                                "Back-transformation reversível sem perda.",
                                "Documentação completa com código e outputs."
                              ],
                              "assessmentCriteria": [
                                "Correta estimação de lambda com método MLE e validação visual.",
                                "Aplicação precisa da transformação sem erros de dados.",
                                "Validação robusta com testes estatísticos apropriados.",
                                "Interpretação clara de melhorias na série.",
                                "Código reproduzível e bem comentado.",
                                "Uso de exemplos reais de séries temporais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização e máxima verossimilhança.",
                                "Programação: Manipulação de dados em R/Python.",
                                "Econometria: Preparação de dados para forecasting.",
                                "Visualização de Dados: Plots para diagnóstico.",
                                "Probabilidade: Distribuições e transformações."
                              ],
                              "realWorldApplication": "Em finanças, estabilizar variância de retornos de ações voláteis para modelos GARCH; em epidemiologia, transformar contagens de casos COVID para previsão precisa."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.3.2",
                            "name": "Usar transformações auxiliares como raiz quadrada",
                            "description": "Aplicar sqrt(Y) ou outras potências para variâncias multiplicativas moderadas, comparando com logaritmo via critérios como AIC em modelos ARIMA.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar variância multiplicativa moderada na série temporal",
                                  "subSteps": [
                                    "Carregue os dados da série temporal usando pandas.",
                                    "Plote a série original e verifique visualmente se a variância aumenta com o nível dos valores.",
                                    "Calcule e plote resíduos quadrados ou use teste de Breusch-Pagan para confirmar heterocedasticidade moderada.",
                                    "Compare amplitude de flutuações em diferentes períodos para diferenciar de variância fortemente multiplicativa (onde log é preferível)."
                                  ],
                                  "verification": "Gráficos mostram variância crescente moderada, mas não explosiva; teste BP p-value < 0.05.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python com pandas, matplotlib, statsmodels; dataset de série temporal (ex: vendas mensais).",
                                  "tips": "Foquem em séries onde variância cresce linearmente com o nível, não exponencialmente.",
                                  "learningObjective": "Reconhecer quando sqrt é apropriada vs log para variâncias moderadas.",
                                  "commonMistakes": "Confundir variância moderada com aditiva (sem transformação) ou fortemente multiplicativa (use log)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar transformação de raiz quadrada e potências auxiliares",
                                  "subSteps": [
                                    "Aplique sqrt(Y) à série: Y_transformed = np.sqrt(Y.abs()) * np.sign(Y) para lidar com negativos.",
                                    "Experimente potências fracionárias como Y^(1/3) ou Y^(1/4) se sqrt não estabilizar perfeitamente.",
                                    "Plote a série transformada e compare com a original.",
                                    "Calcule estatísticas descritivas (variância em janelas móveis) antes/depois para quantificar estabilização.",
                                    "Ajuste para zeros ou negativos adicionando constante pequena se necessário."
                                  ],
                                  "verification": "Variância em janelas móveis torna-se aproximadamente constante nos plots.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Python com numpy, pandas, matplotlib; mesmo dataset.",
                                  "tips": "Use np.power(Y, 0.5) para flexibilidade em potências.",
                                  "learningObjective": "Executar transformações de potência para estabilizar variância moderada.",
                                  "commonMistakes": "Esquecer de tratar valores negativos ou zeros, levando a erros de domínio."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar estabilização da variância e preparar para modelagem",
                                  "subSteps": [
                                    "Plote resíduos ao quadrado da transformada vs tempo e vs nível fitted.",
                                    "Aplique teste de Breusch-Pagan ou White na transformada para confirmar homocedasticidade.",
                                    "Diferencie a série transformada se necessário para estacionariedade.",
                                    "Gere ACF/PACF plots para confirmar adequação pré-modelagem.",
                                    "Documente métricas de estabilização (ex: ratio de variâncias max/min antes/depois)."
                                  ],
                                  "verification": "Testes indicam p-value > 0.05 para homocedasticidade; plots visuais estáveis.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "statsmodels para testes; scipy para diferenciação.",
                                  "tips": "Use rolling variance para visual intuitiva.",
                                  "learningObjective": "Validar efetividade da transformação via diagnósticos gráficos e testes.",
                                  "commonMistakes": "Ignorar necessidade de diferenciação pós-transformação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar sqrt com log via AIC em modelos ARIMA",
                                  "subSteps": [
                                    "Ajuste ARIMA(p,d,q) na série sqrt-transformada usando auto_arima ou grid search.",
                                    "Repita para log-transformada: log(Y+1) e compare AIC.",
                                    "Selecione modelo com menor AIC; avalie residuals para autocorrelação.",
                                    "Back-transforme previsões: pred_original = pred_sqrt**2 para sqrt.",
                                    "Compare forecasts e intervalos de confiança entre transformações."
                                  ],
                                  "verification": "AIC da sqrt é menor ou similar para variância moderada; residuals white noise.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "pmdarima para auto_arima; statsmodels.tsa.arima.",
                                  "tips": "Use BIC como critério secundário para parcimônia.",
                                  "learningObjective": "Usar AIC para seleção imparcial de transformações em ARIMA.",
                                  "commonMistakes": "Comparar AIC sem ajustar parâmetros ARIMA adequadamente."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar resultados e documentar escolha",
                                  "subSteps": [
                                    "Resuma comparação: 'sqrt estabilizou variância moderada com AIC=XXX vs log AIC=YYY'.",
                                    "Plote forecasts originais para ambas transformações.",
                                    "Discuta trade-offs: sqrt preserva interpretabilidade melhor para moderado.",
                                    "Salve relatório com plots e métricas.",
                                    "Teste sensibilidade variando potência (ex: Box-Cox)."
                                  ],
                                  "verification": "Relatório explica escolha com evidências quantitativas e plots.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Jupyter notebook para documentação.",
                                  "tips": "Box-Cox automatiza seleção de potência.",
                                  "learningObjective": "Documentar decisões baseadas em evidências para reprodutibilidade.",
                                  "commonMistakes": "Não back-transformar previsões corretamente."
                                }
                              ],
                              "practicalExample": "Em dados de vendas mensais de varejo (ex: dataset AirPassengers adaptado), variância cresce moderadamente. Aplique sqrt: estabiliza variância (rolling var de 10 para 2), AIC ARIMA(2,1,2) = 120 vs log AIC=125. Forecast de vendas futuras com IC mais estreitos.",
                              "finalVerifications": [
                                "Plots confirmam variância estabilizada pós-sqrt.",
                                "AIC sqrt <= AIC log para dados moderados.",
                                "Residuals ARIMA: Ljung-Box p>0.05, sem padrões.",
                                "Back-transform forecasts coerentes com escala original.",
                                "Teste BP p>0.05 na transformada.",
                                "Rolling variance ratio <1.5 pós-transformação."
                              ],
                              "assessmentCriteria": [
                                "Correta identificação de variância multiplicativa moderada (80% acerto em quiz).",
                                "Implementação sem erros de código/domínio (funciona em dataset teste).",
                                "Seleção via AIC justificada com valores numéricos.",
                                "Plots diagnósticos claros e interpretados.",
                                "Relatório completo com trade-offs discutidos.",
                                "Tempo total dentro de 2 horas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Propriedades de funções potência e Box-Cox.",
                                "Programação: Manipulação de dados em Python/R.",
                                "Economia: Modelagem de séries em previsão de demanda.",
                                "Física: Transformações em sinais com ruído multiplicativo."
                              ],
                              "realWorldApplication": "Em finanças, estabilizar retornos de ações com variância moderada crescente para ARIMA preciso em risco VaR; em epidemiologia, contagens de casos com variância proporcional ao nível para forecasts confiáveis."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.4",
                "name": "Séries Temporais Estacionárias",
                "description": "Propriedades das séries estacionárias e métodos de previsão apropriados.",
                "totalSkills": 45,
                "atomicTopics": [
                  {
                    "id": "10.1.4.1",
                    "name": "Definição de Estacionariedade",
                    "description": "Conceito de estacionariedade fraca e forte em séries temporais, incluindo média constante, variância constante e autocovariância dependente apenas do lag.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.1.1",
                        "name": "Estacionariedade Fraca",
                        "description": "Conceito de estacionariedade fraca (ou covariância estacionária) em séries temporais, caracterizado pela constância da média, da variância finita e pela dependência da autocovariância apenas do lag temporal, independentemente do tempo absoluto.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.1.1",
                            "name": "Definir estacionariedade em média",
                            "description": "Explicar que uma série temporal {X_t} é estacionária em média se a esperança matemática E[X_t] = μ é constante para todo t ∈ ℤ, garantindo ausência de tendência linear ou drift temporal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Séries Temporais e Esperança Matemática",
                                  "subSteps": [
                                    "Revise a definição de uma série temporal {X_t} como uma sequência de variáveis aleatórias indexadas pelo tempo t ∈ ℤ.",
                                    "Explique a esperança matemática E[X_t] como a média populacional teórica de X_t.",
                                    "Discuta como calcular a média amostral \bar{X} = (1/n) Σ X_t para uma amostra finita.",
                                    "Compare média populacional (constante) com média amostral (pode variar).",
                                    "Visualize séries temporais com plot de linha para observar variações ao longo do tempo."
                                  ],
                                  "verification": "Crie um gráfico simples de uma série temporal fictícia e compute a média amostral para subperíodos; confirme compreensão verbal.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Notebook com Python/R (bibliotecas pandas, matplotlib), notas de aula sobre probabilidade básica.",
                                  "tips": "Use dados reais curtos, como temperaturas diárias, para tornar concreto.",
                                  "learningObjective": "Entender os fundamentos de séries temporais e o conceito de esperança matemática.",
                                  "commonMistakes": "Confundir média amostral com populacional; ignorar que t é discreto em séries temporais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Formalmente Estacionariedade em Média",
                                  "subSteps": [
                                    "Estabeleça a definição: {X_t} é estacionária em média se ∃ μ ∈ ℝ tal que E[X_t] = μ ∀ t ∈ ℤ.",
                                    "Escreva a notação matemática: E[X_t] = μ (constante no tempo).",
                                    "Diferencie de não-estacionariedade: se E[X_t] = μ + βt, há tendência linear.",
                                    "Discuta estacionariedade fraca (em 1ª e 2ª momentos).",
                                    "Pratique escrevendo a definição em palavras e símbolos."
                                  ],
                                  "verification": "Escreva a definição formal e um contraexemplo não-estacionário; explique em 1 parágrafo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel/caneta ou editor LaTeX para fórmulas, vídeo tutorial curto sobre notação probabilística.",
                                  "tips": "Memorize a fórmula chave; recite em voz alta para fixar.",
                                  "learningObjective": "Dominar a definição precisa de estacionariedade em média.",
                                  "commonMistakes": "Escrever E[X_t] constante como Var(X_t) constante (confundir com estacionariedade em variância)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Ausência de Tendência ou Drift Temporal",
                                  "subSteps": [
                                    "Explique tendência linear: E[X_t] = μ + βt, onde β ≠ 0 causa drift.",
                                    "Compare gráficos: série estacionária (níveis horizontais) vs. tendência (inclinação).",
                                    "Calcule médias móveis em janelas deslizantes para detectar mudanças.",
                                    "Teste visual: plot E[X_t] estimado vs. t; deve ser horizontal.",
                                    "Discuta implicações: estacionariedade permite modelagem simples sem detrending."
                                  ],
                                  "verification": "Analise um gráfico de série com tendência e reescreva sem ela; identifique μ.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Software estatístico (R: ts.plot(), Python: pandas.plot()), dataset exemplo (ex: AirPassengers).",
                                  "tips": "Use zoom em plots para detectar drifts sutis.",
                                  "learningObjective": "Reconhecer visual e conceitualmente ausência de tendência em médias.",
                                  "commonMistakes": "Confundir sazonalidade com tendência; assumir estacionariedade sem verificação gráfica."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Aplicar o Conceito em Exemplos",
                                  "subSteps": [
                                    "Selecione um dataset real (ex: preços de ações estacionarizados).",
                                    "Compute E[X_t] amostral por período e teste constância (teste t ou plot).",
                                    "Simule série estacionária vs. não-estacionária em código.",
                                    "Explique por que estacionariedade em média é pré-requisito para ARIMA.",
                                    "Documente achados em relatório curto."
                                  ],
                                  "verification": "Gere relatório com plots e conclusão: 'estacionária em média: sim/não'.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Python/R com datasets (ex: de statsmodels ou forecast package), Jupyter notebook.",
                                  "tips": "Comece com dados conhecidos não-estacionários para contraste.",
                                  "learningObjective": "Aplicar a definição para verificar estacionariedade em prática.",
                                  "commonMistakes": "Usar amostra pequena (n<50) para inferir constância; ignorar autocoerelacionamento."
                                }
                              ],
                              "practicalExample": "Considere a série de temperaturas médias diárias em uma cidade estável: E[T_t] ≈ 20°C todo dia (estacionária em média). Já vendas de sorvete: E[V_t] aumenta no verão (não-estacionária, drift sazonal). Plote e compute médias por mês para verificar.",
                              "finalVerifications": [
                                "Escreva corretamente a definição matemática de estacionariedade em média.",
                                "Identifique em um gráfico se uma série tem tendência linear na média.",
                                "Compute média amostral em subperíodos e conclua sobre constância.",
                                "Diferencie estacionariedade em média de variância.",
                                "Explique verbalmente por que ausência de drift é crucial para modelagem.",
                                "Simule uma série estacionária em código e verifique E[X_t]."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal (100% correta).",
                                "Capacidade de detectar tendência via plot e cálculo (acurácia >90%).",
                                "Explicação clara de implicações sem erros conceituais.",
                                "Uso correto de notação probabilística (E[ ], ∀ t).",
                                "Aplicação prática em exemplo real com evidências.",
                                "Ausência de confusão com outros tipos de estacionariedade."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade: Conceitos de esperança e variáveis aleatórias.",
                                "Economia: Análise de séries de PIB ou inflação para políticas monetárias.",
                                "Física: Modelagem de processos estocásticos em movimento browniano.",
                                "Programação: Manipulação de dados temporais em Python/R."
                              ],
                              "realWorldApplication": "Em finanças, verificar estacionariedade em médias de retornos de ações permite modelar riscos sem viés de tendência, essencial para portfólios estáveis e previsões de mercado."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.2",
                            "name": "Definir estacionariedade em variância",
                            "description": "Descrever que a variância Var(X_t) = σ² é finita e constante para todo t ∈ ℤ, implicando homocedasticidade ao longo do tempo na série temporal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o conceito fundamental de variância",
                                  "subSteps": [
                                    "Defina variância como a medida de dispersão de uma variável aleatória em torno de sua média.",
                                    "Escreva a fórmula matemática: Var(X) = E[(X - μ)²] = σ², onde μ é a média e E é o valor esperado.",
                                    "Explique que a variância é sempre não-negativa e finita para distribuições com momentos de segunda ordem.",
                                    "Diferencie variância populacional de amostral, usando n no denominador para populacional."
                                  ],
                                  "verification": "Calcule a variância de um conjunto de dados simples e confirme que o resultado é finito e positivo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Folha de papel, calculadora ou software como Excel/Python.",
                                  "tips": "Sempre verifique se os dados são centrados na média antes de calcular desvios quadrados.",
                                  "learningObjective": "Compreender a variância como medida de dispersão finita e sua fórmula básica.",
                                  "commonMistakes": "Confundir variância com desvio padrão; esquecer de elevar ao quadrado os desvios."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar variância ao contexto de séries temporais",
                                  "subSteps": [
                                    "Introduza X_t como um processo estocástico indexado pelo tempo t ∈ ℤ.",
                                    "Defina Var(X_t) como a variância condicional ou incondicional no tempo t.",
                                    "Discuta que em séries temporais, a variância pode variar com o tempo, levando a heterocedasticidade.",
                                    "Calcule Var(X_t) para diferentes valores de t em um exemplo simples de série.",
                                    "Observe se Var(X_t) muda ao longo do tempo em dados reais."
                                  ],
                                  "verification": "Plote a variância estimada em janelas deslizantes de uma série temporal e analise a constância.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Software R ou Python (pacotes como numpy, pandas), conjunto de dados de série temporal.",
                                  "tips": "Use janelas de tamanho fixo (ex: 30 observações) para estimar variância local.",
                                  "learningObjective": "Entender como a variância se comporta em processos temporais indexados.",
                                  "commonMistakes": "Ignorar dependências temporais ao estimar variância; usar toda a amostra sem janelas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir estacionariedade na variância",
                                  "subSteps": [
                                    "Estabeleça que uma série é estacionária em variância se Var(X_t) = σ² finita e constante ∀ t ∈ ℤ.",
                                    "Escreva formalmente: Var(X_t) = σ² < ∞ para todo t, independentemente do tempo.",
                                    "Explique que isso requer momentos de segunda ordem finitos (E[X_t²] < ∞).",
                                    "Diferencie de estacionariedade média, focando apenas na segunda momento."
                                  ],
                                  "verification": "Verifique matematicamente se Var(X_t) é invariante sob shifts temporais em uma definição formal.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Livro de séries temporais (ex: Brockwell & Davis), quadro branco.",
                                  "tips": "Lembre-se: estacionariedade fraca requer constância em 1º e 2º momentos apenas.",
                                  "learningObjective": "Formalizar a definição de variância constante em séries temporais.",
                                  "commonMistakes": "Confundir constância com valor zero; omitir finitude da variância."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar implicações e homocedasticidade",
                                  "subSteps": [
                                    "Descreva homocedasticidade como variância constante ao longo do tempo (oposto a heterocedasticidade).",
                                    "Discuta impactos em modelagem: facilita ARMA, evita modelos GARCH.",
                                    "Ilustre com gráfico de resíduos: dispersão uniforme indica homocedasticidade.",
                                    "Teste informal: compare variâncias em subperíodos da série."
                                  ],
                                  "verification": "Aplique um teste simples de variância (ex: Levene) em subamostras e interprete p-valor > 0.05.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python (scipy.stats.levene), dados de série temporal.",
                                  "tips": "Visualize boxplots de resíduos por período para detectar mudanças rápidas.",
                                  "learningObjective": "Compreender as consequências práticas da estacionariedade em variância.",
                                  "commonMistakes": "Assumir homocedasticidade sem teste; confundir com autocorrelação."
                                }
                              ],
                              "practicalExample": "Em uma série temporal de preços de ações diários, calcule Var(X_t) em janelas de 30 dias ao longo de 1 ano. Se todas as variâncias forem aproximadamente iguais a σ² = 0.05 (finita e constante), a série exibe estacionariedade em variância, indicando homocedasticidade útil para modelagem de previsão.",
                              "finalVerifications": [
                                "Pode enunciar corretamente: Var(X_t) = σ² finita e constante ∀ t?",
                                "Calcula variância em múltiplos t e confirma constância?",
                                "Explica homocedasticidade como implicação direta?",
                                "Diferencia de heterocedasticidade com exemplo?",
                                "Identifica quando a variância não é finita (ex: caudas pesadas)?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição matemática (finitude e constância).",
                                "Capacidade de calcular e interpretar variância temporal.",
                                "Correta ligação com homocedasticidade.",
                                "Uso de exemplos concretos sem erros.",
                                "Compreensão de pré-requisitos (momentos finitos).",
                                "Aplicação em testes simples de constância."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade: Momentos de segunda ordem e distribuições estacionárias.",
                                "Econometria: Modelos ARIMA e testes de estacionariedade.",
                                "Finanças: Volatilidade constante em séries de retornos.",
                                "Engenharia: Controle de sistemas lineares invariantes no tempo."
                              ],
                              "realWorldApplication": "Na previsão de demanda de produtos em varejo, assumir variância constante nas vendas diárias permite modelos simples e confiáveis, evitando erros em períodos de alta volatilidade sazonal, como Black Friday, onde heterocedasticidade exigiria ajustes complexos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.3",
                            "name": "Definir autocovariância dependente apenas do lag",
                            "description": "Formalizar que a autocovariância γ(t, t+k) = Cov(X_t, X_{t+k}) = γ(k) depende unicamente do lag k, não do instante t, permitindo modelagem simplificada de dependências.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição geral de autocovariância",
                                  "subSteps": [
                                    "Defina covariância bivariada: Cov(X, Y) = E[(X - μ_X)(Y - μ_Y)]",
                                    "Estenda para séries temporais: autocovariância γ(t, t+k) = Cov(X_t, X_{t+k})",
                                    "Escreva a fórmula explícita: γ(t, t+k) = E[(X_t - μ_t)(X_{t+k} - μ_{t+k})]",
                                    "Discuta a notação padrão e propriedades básicas (ex: γ(t,t) = Var(X_t))",
                                    "Diferencie de autocorrelação: ρ(k) = γ(k)/γ(0)"
                                  ],
                                  "verification": "Escrever corretamente a fórmula de γ(t, t+k) e calcular γ(0) para uma série simples",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de probabilidade",
                                    "Livro de séries temporais (cap. estacionariedade)",
                                    "Calculadora ou Python (numpy.cov)"
                                  ],
                                  "tips": [
                                    "Sempre subtraia as médias antes de calcular; pratique com dados simulados."
                                  ],
                                  "learningObjective": "Compreender a autocovariância como medida de dependência linear em séries temporais.",
                                  "commonMistakes": [
                                    "Confundir autocovariância com correlação",
                                    "Esquecer de centralizar as variáveis (subtrair médias)",
                                    "Usar momentos não centrados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir os componentes da estacionariedade fraca",
                                  "subSteps": [
                                    "Defina estacionariedade fraca: 1) E[X_t] = μ constante; 2) Var(X_t) = σ² constante; 3) Cov(X_t, X_{t+k}) depende só de k",
                                    "Explique por que a dependência temporal deve ser 'homogênea' no tempo",
                                    "Discuta implicações: simplifica modelagem, pois funções de autocovariância são invariantes a translações temporais",
                                    "Compare com não-estacionariedade: γ(t, t+k) varia com t em tendências ou heteroscedasticidade",
                                    "Liste funções de autocovariância válidas (positiva semi-definida)"
                                  ],
                                  "verification": "Listar os três requisitos da estacionariedade fraca e identificar qual envolve autocovariância",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Slides sobre estacionariedade",
                                    "Exemplos de séries ARMA",
                                    "Software R ou Python (statsmodels)"
                                  ],
                                  "tips": [
                                    "Visualize com gráficos de ACF (função de autocorrelação) para séries estacionárias vs não.",
                                    "Lembre: estacionariedade forte é mais restritiva (distribuição invariante)."
                                  ],
                                  "learningObjective": "Identificar como a estacionariedade fraca impõe estrutura na autocovariância.",
                                  "commonMistakes": [
                                    "Confundir estacionariedade fraca com forte",
                                    "Ignorar variância constante",
                                    "Pensar que autocovariância zero implica independência"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formalizar a dependência apenas do lag",
                                  "subSteps": [
                                    "Escreva a propriedade: γ(t, t+k) = Cov(X_t, X_{t+k}) = γ(k) para todo t e k fixo",
                                    "Prove intuitivamente: sob estacionariedade fraca, μ_t = μ e σ_t² = σ² constantes",
                                    "Mostre que γ(k) = γ(-k) (simetria)",
                                    "Discuta γ(0) = σ² e decrescimento típico |γ(k)| ≤ γ(0)",
                                    "Verifique com matriz de covariância Toeplitz para processos estacionários"
                                  ],
                                  "verification": "Demonstrar que γ(t, t+k) = γ(s, s+k) para t ≠ s, usando definição",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Papel e lápis para provas",
                                    "Matriz de covariância exemplo",
                                    "Python (pandas para simular série)"
                                  ],
                                  "tips": [
                                    "Use notação γ(h) onde h = lag; pratique provando simetria γ(h) = γ(-h)."
                                  ],
                                  "learningObjective": "Formalizar matematicamente que a autocovariância é função apenas do lag k.",
                                  "commonMistakes": [
                                    "Escrever γ(t+k) em vez de γ(k)",
                                    "Esquecer simetria para lags negativos",
                                    "Confundir com dependência condicional"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar implicações e validar com exemplo",
                                  "subSteps": [
                                    "Discuta simplificação modelagem: espectro, previsão via Wold decomposition",
                                    "Calcule γ(k) para processo white noise: γ(k) = σ² se k=0, 0 caso contrário",
                                    "Simule série AR(1): X_t = φ X_{t-1} + ε_t, derive γ(k) = σ² φ^{|k|} / (1-φ²)",
                                    "Compare ACF de série estacionária vs com tendência",
                                    "Conclua: propriedade permite testes como Dickey-Fuller"
                                  ],
                                  "verification": "Calcular γ(1) para AR(1) com φ=0.5 e verificar independência de t",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Python/Jupyter com statsmodels.tsa",
                                    "Dados simulados",
                                    "Gráficos ACF/PACF"
                                  ],
                                  "tips": [
                                    "Simule em código para visualizar; lags grandes devem ter γ(k)→0 em estacionárias."
                                  ],
                                  "learningObjective": "Aplicar a propriedade em exemplos e entender suas consequências práticas.",
                                  "commonMistakes": [
                                    "Assumir estacionariedade sem verificar raízes unitárias",
                                    "Calcular covariância amostral sem centralizar",
                                    "Ignorar normalização em ACF"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma série de temperaturas diárias estacionária (média sazonalmente ajustada), calcule γ(1) = Cov(T_t, T_{t+1}). Para qualquer t, γ(1) é o mesmo (ex: 2.5°C²), permitindo modelo AR(1) com φ estimado via Yule-Walker: φ = γ(1)/γ(0). Simule em Python: gere AR(1), plote ACF e confirme constância.",
                              "finalVerifications": [
                                "Define corretamente γ(t, t+k) = γ(k)",
                                "Explica por que depende só de k (estacionariedade fraca)",
                                "Calcula γ(k) para white noise e AR(1)",
                                "Distingue de autocorrelação",
                                "Identifica violações em séries não estacionárias",
                                "Descreve matriz covariância Toeplitz"
                              ],
                              "assessmentCriteria": [
                                "Precisão na formalização matemática (fórmulas corretas)",
                                "Compreensão conceitual (explicação intuitiva da independência de t)",
                                "Habilidade computacional (cálculo/exemplo numérico)",
                                "Aplicação em contexto (implicações para modelagem)",
                                "Identificação de erros comuns",
                                "Uso correto de terminologia (lag, estacionariedade fraca)"
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade: Covariância e momentos conjuntos",
                                "Álgebra Linear: Matrizes Toeplitz e positiva semi-definida",
                                "Programação: Implementação em Python/R (statsmodels, acf)",
                                "Econometria: Testes de raiz unitária (ADF)",
                                "Física: Processos estocásticos em dinâmica de sistemas"
                              ],
                              "realWorldApplication": "Em finanças, modela retornos de ações estacionários para previsão de risco (VaR via GARCH); em meteorologia, analisa padrões climáticos para forecasts; em controle de qualidade, monitora sinais industriais detectando não-estacionaridades."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.1.2",
                        "name": "Estacionariedade Forte",
                        "description": "Conceito de estacionariedade forte (ou estrita), no qual a lei de probabilidade conjunta de qualquer subconjunto finito da série é invariante sob deslocamentos temporais arbitrários.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.2.1",
                            "name": "Definir estacionariedade forte formalmente",
                            "description": "Estabelecer que {X_t} é estritamente estacionária se, para todo h ∈ ℤ e k ∈ ℕ, a distribuição conjunta de (X_{t_1}, ..., X_{t_k}) é idêntica à de (X_{t_1 + h}, ..., X_{t_k + h}), preservando todas as propriedades distributivas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de séries temporais e distribuições",
                                  "subSteps": [
                                    "Estude a notação básica de séries temporais: {X_t}_{t∈ℤ} como processo estocástico indexado pelo tempo.",
                                    "Revise o conceito de distribuição conjunta para k variáveis aleatórias (X_{t1}, ..., X_{tk}).",
                                    "Entenda os conjuntos ℕ (naturais) e ℤ (inteiros), e seu papel em shifts temporais (h ∈ ℤ).",
                                    "Identifique exemplos simples de processos i.i.d. (independentes e identicamente distribuídos).",
                                    "Anote as diferenças intuitivas entre estacionariedade fraca (momentos) e forte (distribuições)."
                                  ],
                                  "verification": "Liste corretamente os símbolos ℕ, ℤ e explique distribuição conjunta em um parágrafo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de probabilidade básica",
                                    "Livro de séries temporais (ex: Brockwell & Davis)",
                                    "Calculadora simbólica online (Wolfram Alpha)"
                                  ],
                                  "tips": "Use diagramas temporais para visualizar shifts h.",
                                  "learningObjective": "Compreender os blocos de construção matemáticos da definição.",
                                  "commonMistakes": "Confundir ℤ com ℕ, limitando shifts apenas a positivos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a invariância de distribuições sob shifts temporais",
                                  "subSteps": [
                                    "Defina formalmente o shift: (X_{t1 + h}, ..., X_{tk + h}) para h fixo.",
                                    "Analise por que a igualdade de distribuições deve valer para todo h ∈ ℤ e todo k ∈ ℕ.",
                                    "Estude o caso k=1: implica distribuição marginal idêntica em todo t.",
                                    "Para k=2, verifique covariâncias e dependências preservadas.",
                                    "Discuta implicações: preserva todas as propriedades distributivas (momentos, caudas, etc.)."
                                  ],
                                  "verification": "Escreva a igualdade de distribuições para k=1 e k=2, confirmando invariância.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta para anotações matemáticas",
                                    "Software R ou Python para simular distribuições simples"
                                  ],
                                  "tips": "Comece com h=0 (trivial) e teste h=1, -1.",
                                  "learningObjective": "Graspar o cerne da invariância temporal nas distribuições.",
                                  "commonMistakes": "Ignorar h negativos, assumindo causalidade unidirecional."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a definição formal de estacionariedade forte",
                                  "subSteps": [
                                    "Escreva o quantificador: 'para todo h ∈ ℤ e k ∈ ℕ'.",
                                    "Adicione as variáveis: distribuições de (X_{t1}, ..., X_{tk}) e (X_{t1+h}, ..., X_{tk+h}).",
                                    "Especifique 'distribuição conjunta idêntica', denotada como Lei(X) = Lei(Y).",
                                    "Inclua os índices t1, ..., tk arbitrários em ℤ.",
                                    "Formalize completamente: {X_t} é estritamente estacionária se... (definição integral)."
                                  ],
                                  "verification": "Escreva a definição completa em LaTeX ou texto matemático e compare com referência.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor LaTeX online (Overleaf)",
                                    "Referência: Hamilton 'Time Series Analysis' capítulo 2"
                                  ],
                                  "tips": "Use símbolos consistentes: evite subscritos confusos.",
                                  "learningObjective": "Montar a definição matemática precisa e rigorosa.",
                                  "commonMistakes": "Omitir 'para todo' ou especificar ti explicitamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e contrastar com exemplos práticos",
                                  "subSteps": [
                                    "Teste com ruído branco gaussiano: confirme estacionariedade forte.",
                                    "Contrastar com processo não-estacionário: caminhada aleatória.",
                                    "Simule em software: gere amostras e compare histogramas shiftados.",
                                    "Discuta condições suficientes: i.i.d. implica forte estacionariedade.",
                                    "Resuma propriedades preservadas: todos os momentos, quantis, etc."
                                  ],
                                  "verification": "Gere um exemplo numérico onde a propriedade falha se violada.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Python (bibliotecas numpy, matplotlib)",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Visualize distribuições com plots de densidade.",
                                  "learningObjective": "Aplicar a definição para validar processos reais.",
                                  "commonMistakes": "Confundir forte com fraca: momentos finitos não bastam."
                                }
                              ],
                              "practicalExample": "Considere {X_t} onde X_t são lançamentos independentes de uma moeda viciada (P(X_t=1)=0.6). Para k=2, h=5, a distribuição conjunta P(X_1=1, X_3=0) = 0.6*0.4 = P(X_6=1, X_8=0), preservando independência e probabilidades marginais em qualquer shift.",
                              "finalVerifications": [
                                "Escrever a definição formal sem erros de notação.",
                                "Explicar verbalmente o papel de 'para todo h ∈ ℤ e k ∈ ℕ'.",
                                "Identificar um processo estritamente estacionário simples.",
                                "Distinguir de estacionariedade fraca com contraexemplo.",
                                "Verificar numericamente em simulação para k=3.",
                                "Listar 3 propriedades distributivas preservadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação matemática (100% correta).",
                                "Compreensão conceitual: explica invariância corretamente.",
                                "Uso rigoroso de quantificadores ('para todo').",
                                "Capacidade de exemplificar e contrastar.",
                                "Aplicação prática via simulação ou cálculo.",
                                "Clareza na escrita formal da definição."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade Avançada: distribuições conjuntas multivariadas.",
                                "Programação Estatística: simulações em R/Python para séries temporais.",
                                "Econometria: modelagem de retornos financeiros estacionários.",
                                "Machine Learning: pré-processamento de dados temporais para redes neurais."
                              ],
                              "realWorldApplication": "Em finanças, definir estacionariedade forte formalmente permite validar pressupostos em modelos ARIMA para previsão de preços de ações, garantindo que distribuições de retornos diários sejam invariantes a shifts, melhorando robustez de forecasts em trading algorítmico."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.1.2.2",
                            "name": "Relacionar estacionariedade forte e fraca",
                            "description": "Demonstrar que estacionariedade forte implica fraca quando os momentos de primeira e segunda ordem existem e são finitos, mas o inverso não é necessariamente verdadeiro, com exemplos como processos gaussianos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições de Estacionariedade Forte e Fraca",
                                  "subSteps": [
                                    "Ler e anotar a definição formal de estacionariedade forte: a distribuição conjunta {X_t, X_{t+1}, ..., X_{t+k}} é idêntica a {X_{t+h}, X_{t+h+1}, ..., X_{t+h+k}} para qualquer h e k.",
                                    "Ler e anotar a definição de estacionariedade fraca: E[X_t] = μ constante, Var(X_t) = σ² constante, Cov(X_t, X_{t+h}) = γ(h) depende apenas de h.",
                                    "Comparar as duas definições destacando que forte é sobre toda a distribuição, enquanto fraca é sobre momentos de 1ª e 2ª ordem.",
                                    "Discutir pré-requisitos: existência e finitude dos momentos de 1ª e 2ª ordem."
                                  ],
                                  "verification": "Escrever as definições em suas próprias palavras e confirmar que menciona os pré-requisitos de momentos finitos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro-texto de Séries Temporais (ex: Brockwell & Davis), notas de aula, calculadora"
                                  ],
                                  "tips": "Use diagramas de Venn para visualizar a relação hierárquica entre forte e fraca.",
                                  "learningObjective": "Compreender precisamente as diferenças e condições entre estacionariedade forte e fraca.",
                                  "commonMistakes": "Confundir estacionariedade fraca com independência ou ignorar a necessidade de momentos finitos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Provar que Estacionariedade Forte Implica Fraca",
                                  "subSteps": [
                                    "Assumir estacionariedade forte e existência finita de E[|X_t|] e E[X_t²].",
                                    "Mostrar que a média é constante: E[X_{t+h}] = E[X_t] para todo h, usando invariância da distribuição marginal.",
                                    "Mostrar que a variância é constante: Var(X_{t+h}) = Var(X_t), similarmente pela invariância.",
                                    "Mostrar que a covariância depende só do lag: Cov(X_{t+h}, X_{t+k+h}) = Cov(X_t, X_{t+|k-t|}), pela invariância conjunta.",
                                    "Verificar com um exemplo simples como ruído branco i.i.d."
                                  ],
                                  "verification": "Escrever a prova formal em 5-10 linhas e computar momentos para um exemplo numérico simples.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Papel e caneta para provas, software como Python (numpy para momentos), apostilas de probabilidade"
                                  ],
                                  "tips": "Comece pelas distribuições marginais e junte para covariâncias; use notação probabilística padrão.",
                                  "learningObjective": "Demonstrar matematicamente a implicação unidireccional sob condições de momentos.",
                                  "commonMistakes": "Esquecer de assumir finitude dos momentos ou pular passos na invariância da covariância."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Demonstrar que Estacionariedade Fraca Não Implica Forte",
                                  "subSteps": [
                                    "Explicar que fraca controla só 1º e 2º momentos, não a forma da distribuição.",
                                    "Construir contraexemplo: processo não-gaussiano com média constante, variância constante, mas autocovariância por lag, porém distribuições não invariantes (ex: mistura de distribuições assimétricas deslocadas).",
                                    "Simular numericamente: gerar duas séries com mesmas propriedades fracas mas distribuições diferentes em lags.",
                                    "Comparar histogramas ou testes KS para diferentes lags.",
                                    "Discutir por que isso falha em forte."
                                  ],
                                  "verification": "Gerar simulação em código e plotar evidências de que propriedades fracas valem mas forte não.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Python/R com bibliotecas (numpy, matplotlib, scipy.stats), dados simulados"
                                  ],
                                  "tips": "Use sementes fixas para reprodutibilidade; foque em assimetria ou caudas para quebrar forte.",
                                  "learningObjective": "Construir e validar um contraexemplo concreto para a não-implicação reversa.",
                                  "commonMistakes": "Escolher exemplo gaussiano acidentalmente ou não verificar numericamente a invariância."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Exemplo de Processos Gaussianos",
                                  "subSteps": [
                                    "Recordar que para gaussianos multivariados, distribuição é determinada unicamente pelos momentos de 1ª e 2ª ordem.",
                                    "Mostrar que se fraca, então as médias e covariâncias são invariantes, logo toda a distribuição conjunta é invariante (forte).",
                                    "Simular um processo AR(1) gaussiano estacionário e verificar ambas as estacionaridades.",
                                    "Comparar com não-gaussiano equivalente fraco mas não forte.",
                                    "Generalizar para processos lineares gaussianos."
                                  ],
                                  "verification": "Executar simulação gaussiana, computar testes de estacionariedade (ADF para fraca, visual para forte) e explicar ligação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python (statsmodels para AR, scipy para gaussianos), gráficos de séries temporais"
                                  ],
                                  "tips": "Use cholesky para gerar gaussianos multivariados; teste com QQ-plots para gaussianidade.",
                                  "learningObjective": "Entender o caso especial onde fraca implica forte devido à propriedade gaussiana.",
                                  "commonMistakes": "Assumir que todo processo fraco é gaussiano ou ignorar dependência linear."
                                }
                              ],
                              "practicalExample": "Considere um processo AR(1): X_t = 0.5 X_{t-1} + ε_t onde ε_t ~ N(0,1). É fracamente estacionário (média 0, var constante, ACF geométrica). Como gaussiano, também fortemente estacionário. Contraste com ε_t de uma distribuição não-gaussiana assimétrica com mesmas 1ª/2ª momentos.",
                              "finalVerifications": [
                                "Pode definir e diferenciar estacionariedade forte e fraca corretamente?",
                                "Consegue provar forte => fraca assumindo momentos finitos?",
                                "Fornece um contraexemplo válido para fraca não => forte?",
                                "Explica por que processos gaussianos são exceção?",
                                "Simula e verifica numericamente pelo menos um exemplo?"
                              ],
                              "assessmentCriteria": [
                                "Prova de implicação forte=>fraca: completa e correta (3 pts)",
                                "Contraexemplo: bem construído e validado (3 pts)",
                                "Explicação gaussiana: precisa e com simulação (2 pts)",
                                "Clareza na escrita e uso de notação (1 pt)",
                                "Verificações numéricas/plots incluídos (1 pt)"
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade Avançada (distribuições multivariadas)",
                                "Análise Numérica (simulações Monte Carlo)",
                                "Machine Learning (preprocessamento de séries temporais)",
                                "Econometria (testes de estacionariedade em dados econômicos)",
                                "Processos Estocásticos (propriedades de Markov)"
                              ],
                              "realWorldApplication": "Em finanças, distinguir forte/fraca afeta escolha de modelos para previsão de retornos de ações; processos gaussianos aproximam ruído em alta frequência, mas não-gaussianos em crashes requerem testes fortes para evitar vieses em Value-at-Risk."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.1.2.3",
                            "name": "Identificar implicações práticas da estacionariedade forte",
                            "description": "Discutir como a estacionariedade forte facilita teoremas ergódicos e estimação de parâmetros, contrastando com a fraca usada em análises lineares como ARMA.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições de Estacionariedade Forte e Fraca",
                                  "subSteps": [
                                    "Defina estacionariedade fraca: média constante, variância finita e constante, autocovariância dependendo apenas do lag.",
                                    "Defina estacionariedade forte: distribuição conjunta invariante sob deslocamentos temporais.",
                                    "Compare as duas: estacionariedade forte implica fraca, mas não vice-versa.",
                                    "Identifique exemplos: processos i.i.d. são fortemente estacionários; ARMA estacionário é fracamente estacionário.",
                                    "Discuta limitações da fraca em contextos não lineares."
                                  ],
                                  "verification": "Resuma as diferenças em um diagrama ou tabela e explique com um exemplo simples.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de texto de séries temporais (ex: Brockwell & Davis)",
                                    "Notas de aula sobre estacionariedade",
                                    "Software R ou Python para simulações básicas"
                                  ],
                                  "tips": "Use analogias: fraca é como ritmo constante, forte é como composição idêntica em qualquer trecho.",
                                  "learningObjective": "Diferenciar conceitualmente estacionariedade forte e fraca.",
                                  "commonMistakes": [
                                    "Confundir as implicações: assumir que fraca basta para ergódica.",
                                    "Ignorar que forte requer invariância de distribuições conjuntas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Teoremas Ergódicos e Estacionariedade Forte",
                                  "subSteps": [
                                    "Explique teorema ergódico: médias temporais convergem para expectativas sob condições ergódicas.",
                                    "Discuta por que estacionariedade forte é crucial: garante independência de amostras iniciais.",
                                    "Estude teorema de Birkhoff: aplica-se diretamente a processos fortemente estacionários.",
                                    "Simule um processo ergódico vs. não-ergódico em software.",
                                    "Identifique implicações práticas: amostras longas representam a distribuição verdadeira."
                                  ],
                                  "verification": "Demonstre com simulação numérica que médias temporais estabilizam em processo fortemente estacionário.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "R ou Python (pacotes: tsibble, forecast)",
                                    "Artigos sobre teoremas ergódicos",
                                    "Simulador online de processos estocásticos"
                                  ],
                                  "tips": "Visualize trajetórias múltiplas: ergódico mistura todas; não-ergódico mantém caminhos separados.",
                                  "learningObjective": "Compreender como estacionariedade forte habilita ergódicidade para inferência estatística.",
                                  "commonMistakes": [
                                    "Achar que fraca basta para ergódicidade em processos não lineares.",
                                    "Não simular para validar conceitos teóricos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Estimação de Parâmetros sob Estacionariedade Forte",
                                  "subSteps": [
                                    "Descreva estimação por momentos: viável sob forte estacionariedade via lei dos grandes números.",
                                    "Compare com máxima verossimilhança: converge consistentemente mais rápido.",
                                    "Discuta cenários práticos: estimação em processos Markov estacionários fortes.",
                                    "Calcule variância assintótica de estimadores em um exemplo simples.",
                                    "Avalie robustez: forte estacionariedade permite bootstrapping válido."
                                  ],
                                  "verification": "Estime parâmetros de um processo simulado e compare com valores verdadeiros.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python (statsmodels, pymc)",
                                    "Dados simulados de processos estacionários",
                                    "Referências: Hamilton 'Time Series Analysis'"
                                  ],
                                  "tips": "Comece com processos simples como i.i.d. antes de Markov chains.",
                                  "learningObjective": "Identificar vantagens na estimação estatística proporcionadas pela estacionariedade forte.",
                                  "commonMistakes": [
                                    "Subestimar dependência de amostra inicial em estimação.",
                                    "Confundir consistência com eficiência assintótica."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Contrastar com Estacionariedade Fraca em Modelos Lineares como ARMA",
                                  "subSteps": [
                                    "Revise modelos ARMA: requerem apenas estacionariedade fraca para ACF e PACF.",
                                    "Explique limitações: não garantem ergódicidade em análises não lineares ou testes de hipóteses.",
                                    "Discuta implicações práticas: previsão em ARMA é local, não global como em forte.",
                                    "Aplique a um dataset real: teste estacionariedade e escolha abordagem.",
                                    "Conclua trade-offs: fraca é mais comum, mas forte é essencial para inferência avançada."
                                  ],
                                  "verification": "Analise um dataset ARMA, discuta por que fraca basta e quando forte seria melhor.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Dataset público (ex: AirPassengers em R)",
                                    "Software para testes ADF/KPSS",
                                    "Tutoriais ARMA"
                                  ],
                                  "tips": "Use testes formais (ADF para fraca) e gráficos QQ para distribuições.",
                                  "learningObjective": "Contrastar usos práticos e contrastar limitações entre forte e fraca.",
                                  "commonMistakes": [
                                    "Aplicar ARMA sem testar estacionariedade.",
                                    "Generalizar fraca para todos cenários ergódicos."
                                  ]
                                }
                              ],
                              "practicalExample": "Em dados de retornos diários de ações (ex: S&P500), verifique estacionariedade forte via testes de invariância de distribuições em janelas deslizantes. Discuta como isso permite estimação confiável de volatilidade via GARCH ergódico, contrastando com ARMA que assume apenas fraca e falha em capturar heteroscedasticidade.",
                              "finalVerifications": [
                                "Explicar corretamente como forte estacionariedade habilita convergência ergódica.",
                                "Dar exemplo numérico de estimação de parâmetro melhorada.",
                                "Contrastar com ARMA em um caso prático.",
                                "Simular e verificar lei dos grandes números em processo forte.",
                                "Identificar cenário onde fraca falha mas forte succeeds."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições e teoremas corretos (30%)",
                                "Profundidade prática: simulações e exemplos relevantes (25%)",
                                "Contraste claro: diferenças forte vs. fraca explicadas (20%)",
                                "Aplicação: ligação com estimação e ergódicidade (15%)",
                                "Clareza: comunicação estruturada sem erros (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: teoremas ergódicos e leis limites.",
                                "Econometria: modelagem de séries financeiras estacionárias.",
                                "Física: processos estocásticos em dinâmica de sistemas.",
                                "Ciência de Dados: validação de premissas em ML para séries temporais."
                              ],
                              "realWorldApplication": "Em finanças, estacionariedade forte valida backtesting de estratégias de trading, garantindo que médias históricas representem expectativas futuras; em controle de qualidade industrial, permite estimação confiável de parâmetros de processos para previsão de falhas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.1.1",
                              "10.1.4.1.1.2",
                              "10.1.4.1.1.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.2",
                    "name": "Propriedades Estatísticas das Séries Estacionárias",
                    "description": "Características como função de autocovariância, função de autocorrelação e espectro de potência.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.2.1",
                        "name": "Função de Autocovariância",
                        "description": "A função de autocovariância γ(h) mede a dependência linear entre observações separadas por h períodos em uma série temporal estacionária, dependendo apenas do lag h e apresentando propriedades como simetria (γ(h) = γ(-h)) e γ(0) igual à variância.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.1.1",
                            "name": "Definir a função de autocovariância",
                            "description": "Definir formalmente γ(h) = Cov(X_t, X_{t+h}) = E[(X_t - μ)(X_{t+h} - μ)] para processos estacionários de segunda ordem, destacando independência da posição temporal t.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Processos Estacionários de Segunda Ordem",
                                  "subSteps": [
                                    "Revise a definição de estacionariedade fraca (segunda ordem): média constante μ e covariância que depende apenas do lag h.",
                                    "Identifique que para estacionariedade de segunda ordem, E[X_t] = μ para todo t e Cov(X_t, X_{t+h}) = γ(h) independente de t.",
                                    "Diferencie de estacionariedade estrita, focando em momentos de primeira e segunda ordem.",
                                    "Exemplo simples: ruído branco é estacionário de segunda ordem.",
                                    "Anote as condições matemáticas em um caderno."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito as condições de estacionariedade de segunda ordem e dê um exemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Caderno e caneta",
                                    "Livro ou notas sobre séries temporais",
                                    "Vídeo introdutório sobre estacionariedade (ex: Khan Academy)"
                                  ],
                                  "tips": "Comece com exemplos intuitivos como temperatura diária média para visualizar constância.",
                                  "learningObjective": "Compreender os pré-requisitos de estacionariedade necessários para definir autocovariância.",
                                  "commonMistakes": [
                                    "Confundir estacionariedade fraca com estrita",
                                    "Achar que média constante implica variância constante sem lag"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar Conceito de Covariância Bivariada",
                                  "subSteps": [
                                    "Lembre a fórmula geral de covariância: Cov(X, Y) = E[(X - μ_X)(Y - μ_Y)].",
                                    "Entenda que mede dependência linear entre duas variáveis aleatórias.",
                                    "Calcule Cov(X_t, X_{t+h}) para o caso geral, notando dependência em t e h.",
                                    "Pratique com variáveis aleatórias i.i.d. onde Cov = 0 para h ≠ 0.",
                                    "Desenhe um diagrama ilustrando pares (X_t, X_{t+h})."
                                  ],
                                  "verification": "Calcule Cov para duas variáveis simples e verifique se obtém zero quando independentes.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Folha de exercícios básicos de probabilidade"
                                  ],
                                  "tips": "Use a propriedade E[XY] - E[X]E[Y] para simplificar cálculos.",
                                  "learningObjective": "Dominar a covariância como base para autocovariância em séries temporais.",
                                  "commonMistakes": [
                                    "Esquecer de centralizar as variáveis (subtrair médias)",
                                    "Confundir com correlação normalizada"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Formalmente a Função de Autocovariância",
                                  "subSteps": [
                                    "Escreva γ(h) = Cov(X_t, X_{t+h}) = E[(X_t - μ)(X_{t+h} - μ)] para processos estacionários.",
                                    "Enfatize que, pela estacionariedade, γ(h) não depende de t.",
                                    "Verifique propriedades: γ(0) = Var(X_t), γ(-h) = γ(h), |γ(h)| ≤ γ(0).",
                                    "Derive γ(h) a partir da definição de covariância condicional à estacionariedade.",
                                    "Escreva a fórmula 3 vezes para memorizar."
                                  ],
                                  "verification": "Reescreva a fórmula de γ(h) do zero e explique cada termo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Software como R ou Python para simular (opcional)"
                                  ],
                                  "tips": "Pense em h como 'deslocamento temporal' para intuição.",
                                  "learningObjective": "Escrever e justificar a definição formal de γ(h).",
                                  "commonMistakes": [
                                    "Incluir dependência de t na notação final",
                                    "Esquecer o E[ ] na expectativa"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Destacar Independência Temporal e Aplicar",
                                  "subSteps": [
                                    "Explique por que γ(h) é função apenas de h: segue da estacionariedade Cov(X_t, X_s) = γ(|t-s|).",
                                    "Compare com processos não estacionários onde Cov depende de t e s.",
                                    "Calcule γ(h) para uma série AR(1): X_t = φ X_{t-1} + ε_t.",
                                    "Plote γ(h) para visualização (manual ou software).",
                                    "Resuma em uma frase: 'Autocovariância mede dependência em lags fixos, ignorando posição absoluta no tempo.'"
                                  ],
                                  "verification": "Dê um exemplo onde γ(h) difere se não estacionário e corrija.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Gráfico de autocovariância exemplo",
                                    "Simulador online de séries temporais"
                                  ],
                                  "tips": "Use simulações numéricas para 'ver' a independência de t.",
                                  "learningObjective": "Compreender e demonstrar a independência da posição temporal t.",
                                  "commonMistakes": [
                                    "Achar que γ(h) é sempre simétrica sem provar",
                                    "Ignorar γ(-h) = γ(h)"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma série de temperaturas diárias estacionária com μ=20°C. Calcule γ(1) = E[(X_t - 20)(X_{t+1} - 20)] ≈ 5°C² usando dados históricos de 100 dias, verificando que o valor é o mesmo para t=1 ou t=50.",
                              "finalVerifications": [
                                "Escreve corretamente γ(h) = E[(X_t - μ)(X_{t+h} - μ)].",
                                "Explica independência de t via estacionariedade.",
                                "Identifica γ(0) como variância.",
                                "Calcula γ(h) para exemplo simples como ruído branco.",
                                "Distingue autocovariância de autocorrelação.",
                                "Lista propriedades básicas: simetria e acotamento."
                              ],
                              "assessmentCriteria": [
                                "Precisão na fórmula matemática (100% correta).",
                                "Explicação clara da independência temporal.",
                                "Uso correto de notação estatística (E[], Cov, μ).",
                                "Aplicação em exemplo numérico simples.",
                                "Identificação de pelo menos 3 propriedades de γ(h).",
                                "Diferenciação de conceitos relacionados."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade: Expectativas e covariâncias multivariadas.",
                                "Programação: Implementação em Python/R com funções acf().",
                                "Análise de Dados: Pré-processamento de séries para estacionariedade.",
                                "Economia: Modelagem de séries financeiras como retornos de ações."
                              ],
                              "realWorldApplication": "Em finanças, γ(h) mede persistência em retornos de ações para prever volatilidade; em meteorologia, analisa dependência em lags de precipitação para modelos de previsão."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.1.2",
                            "name": "Listar propriedades da autocovariância",
                            "description": "Identificar e explicar propriedades chave: γ(0) = Var(X_t), |γ(h)| ≤ γ(0), simetria γ(h) = γ(-h) e não crescente positiva γ(h+1)^2 ≤ γ(h)γ(h+2).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição e notação da autocovariância",
                                  "subSteps": [
                                    "Defina autocovariância como γ(h) = Cov(X_t, X_{t+h}) para uma série estacionária.",
                                    "Escreva a fórmula explícita: γ(h) = E[(X_t - μ)(X_{t+h} - μ)], onde μ = E[X_t].",
                                    "Explique que h é o lag (deslocamento temporal).",
                                    "Diferencie de autocorrelação, que é γ(h)/γ(0).",
                                    "Discuta pressuposto de estacionariedade fraca."
                                  ],
                                  "verification": "Escreva corretamente a fórmula de γ(h) e explique seu significado em palavras próprias.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel ou notebook",
                                    "Livro ou notas sobre séries temporais",
                                    "Calculadora"
                                  ],
                                  "tips": [
                                    "Visualize h como o número de períodos de deslocamento.",
                                    "Use exemplos simples como ruído branco para γ(h)=0 se h≠0."
                                  ],
                                  "learningObjective": "Dominar a definição fundamental da função de autocovariância.",
                                  "commonMistakes": [
                                    "Confundir com variância (apenas para h=0)",
                                    "Ignorar o pressuposto de estacionariedade",
                                    "Esquecer a subtração da média μ"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar a propriedade γ(0) = Var(X_t)",
                                  "subSteps": [
                                    "Substitua h=0 na fórmula: γ(0) = Cov(X_t, X_t) = Var(X_t).",
                                    "Prove matematicamente: E[(X_t - μ)^2] = Var(X_t).",
                                    "Interprete: γ(0) é a variância total da série.",
                                    "Calcule γ(0) para uma série estacionária simples.",
                                    "Compare com variância amostral em dados reais."
                                  ],
                                  "verification": "Demonstre que γ(0) = Var(X_t) com prova e exemplo numérico.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora ou software como R/Python",
                                    "Exemplo de dados de série temporal"
                                  ],
                                  "tips": [
                                    "γ(0) é sempre positivo e representa a 'energia' da série."
                                  ],
                                  "learningObjective": "Entender e provar a relação entre autocovariância no lag zero e variância.",
                                  "commonMistakes": [
                                    "Pensar que γ(0) depende de t (viola estacionariedade)",
                                    "Confundir com desvio padrão"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar simetria γ(h) = γ(-h) e |γ(h)| ≤ γ(0)",
                                  "subSteps": [
                                    "Prove simetria: Cov(X_t, X_{t+h}) = Cov(X_{t+h}, X_t) = γ(-h).",
                                    "Desenvolva desigualdade de Cauchy-Schwarz: |γ(h)| = |Cov(X_t, X_{t+h})| ≤ √[Var(X_t)Var(X_{t+h})] = γ(0).",
                                    "Interprete: autocovariância é máxima em h=0 e simétrica.",
                                    "Verifique graficamente em uma ACF plot.",
                                    "Teste com exemplo numérico."
                                  ],
                                  "verification": "Escreva as provas e verifique |γ(1)| ≤ γ(0) em um exemplo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel para provas matemáticas",
                                    "Software para plotar ACF (ex: R)",
                                    "Dados simulados"
                                  ],
                                  "tips": [
                                    "Simetria implica função autocovariância par.",
                                    "Use | | para módulo absoluto."
                                  ],
                                  "learningObjective": "Dominar as propriedades de simetria e acoplamento.",
                                  "commonMistakes": [
                                    "Esquecer o módulo em |γ(h)|",
                                    "Confundir γ(h) com γ(|h|)",
                                    "Ignorar prova de Cauchy-Schwarz"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar a propriedade não crescente positiva γ(h+1)^2 ≤ γ(h)γ(h+2)",
                                  "subSteps": [
                                    "Enuncie a desigualdade para funções autocovariância positivas definidas.",
                                    "Prove usando determinantes de matrizes de covariância 2x2 ≥ 0.",
                                    "Interprete: autocovariância não aumenta com lags maiores.",
                                    "Verifique em série AR(1) ou MA(1).",
                                    "Liste todas as propriedades em um quadro resumo."
                                  ],
                                  "verification": "Prove a desigualdade e liste as 4 propriedades principais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de álgebra linear",
                                    "Exemplos de processos ARMA"
                                  ],
                                  "tips": [
                                    "Equivale a correlação não aumentando monotonicamente.",
                                    "Útil para verificar validade de funções ACF estimadas."
                                  ],
                                  "learningObjective": "Compreender e provar a propriedade de não-aumento da autocovariância.",
                                  "commonMistakes": [
                                    "Aplicar só para h≥0 sem simetria",
                                    "Confundir com autocorrelação",
                                    "Esquecer positividade definida"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma série de retornos diários de ações (ex: dados do IBOVESPA), calcule a autocovariância amostral para lags 0,1,2. Verifique: γ(0) ≈ variância >0; |γ(1)| ≤ γ(0); γ(1)=γ(-1); e γ(2)^2 ≤ γ(1)γ(3). Use R: acf(returns, plot=FALSE).",
                              "finalVerifications": [
                                "Listar corretamente as 4 propriedades principais.",
                                "Provar γ(0)=Var(X_t) e simetria.",
                                "Explicar desigualdade |γ(h)| ≤ γ(0) com Cauchy-Schwarz.",
                                "Demonstrar γ(h+1)^2 ≤ γ(h)γ(h+2) em exemplo.",
                                "Aplicar propriedades a uma série real.",
                                "Identificar violação de propriedades como indício de não-estacionariedade."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas fórmulas e provas (90% correto).",
                                "Clareza na explicação verbal das propriedades.",
                                "Uso correto de exemplos numéricos ou gráficos.",
                                "Compreensão de implicações para estacionariedade.",
                                "Identificação de erros comuns e como evitá-los.",
                                "Capacidade de conectar propriedades a diagnósticos de séries."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade: Conceitos de covariância e expectativa.",
                                "Álgebra Linear: Matrizes de covariância positivas definidas.",
                                "Cálculo: Desigualdades como Cauchy-Schwarz.",
                                "Física: Análise de sinais e correlações temporais.",
                                "Economia: Modelagem de séries financeiras estacionárias."
                              ],
                              "realWorldApplication": "Em finanças, verificar propriedades da autocovariância em retornos de ativos para confirmar estacionariedade antes de modelar com ARIMA; em meteorologia, analisar correlações em temperaturas para previsões; em controle de qualidade, detectar padrões em processos industriais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.1.3",
                            "name": "Calcular autocovariância amostral",
                            "description": "Calcular o estimador amostral γ̂(h) = (1/n) Σ_{t=1}^{n-h} (X_t - X̄)(X_{t+h} - X̄) e discutir vieses em amostras finitas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os dados e calcular a média amostral",
                                  "subSteps": [
                                    "Colete uma série temporal estacionária de pelo menos 50 observações (ex: dados de temperatura diária).",
                                    "Calcule a média amostral X̄ = (1/n) Σ_{t=1}^n X_t usando uma calculadora, Excel ou Python.",
                                    "Centre os dados subtraindo X̄ de cada X_t, obtendo Z_t = X_t - X̄ para t=1 a n.",
                                    "Verifique se os dados estão ordenados cronologicamente e sem valores ausentes.",
                                    "Salve os dados centrados em uma lista ou array para uso posterior."
                                  ],
                                  "verification": "Confirme que a média dos Z_t é aproximadamente zero (erro < 1e-10) e que todos os valores foram centrados corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Série temporal de dados (CSV ou lista)",
                                    "Python (NumPy/Pandas)",
                                    "Excel ou papel e lápis"
                                  ],
                                  "tips": "Use funções prontas como np.mean() no Python para evitar erros de arredondamento manuais.",
                                  "learningObjective": "Compreender o processo de centralização de dados como pré-requisito para autocovariância.",
                                  "commonMistakes": [
                                    "Esquecer de dividir por n na média",
                                    "Usar mediana em vez de média",
                                    "Não tratar valores ausentes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar lag h e calcular produtos centrados",
                                  "subSteps": [
                                    "Escolha um lag h (ex: h=1) menor que n/2 para evitar poucos termos na soma.",
                                    "Para t=1 até n-h, compute cada produto (Z_t * Z_{t+h}).",
                                    "Liste todos os n-h produtos em uma tabela ou array.",
                                    "Some os produtos: S = Σ_{t=1}^{n-h} Z_t * Z_{t+h}.",
                                    "Divida pela amostra total: γ̂(h) = S / n."
                                  ],
                                  "verification": "Conte o número de termos na soma (deve ser n-h) e verifique os primeiros e últimos produtos manualmente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Dados centrados do Step 1",
                                    "Python (loop ou np.correlate)",
                                    "Planilha Excel"
                                  ],
                                  "tips": "Implemente um loop simples em Python para automatizar; teste com h=0 para obter variância amostral.",
                                  "learningObjective": "Dominar o cálculo dos produtos defasados para um lag específico.",
                                  "commonMistakes": [
                                    "Dividir por (n-h) em vez de n",
                                    "Inverter o lag (usar t+h e t)",
                                    "Incluir termos além de n-h"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular γ̂(h) para múltiplos lags e visualizar",
                                  "subSteps": [
                                    "Repita o Step 2 para h=0 até h=10 (ou n/4).",
                                    "Crie uma função ou script para computar o vetor de autocovariâncias.",
                                    "Plote a função de autocovariância amostral (ACF) usando matplotlib ou Excel.",
                                    "Compare γ̂(0) com a variância amostral.",
                                    "Salve o plot e os valores em um relatório."
                                  ],
                                  "verification": "γ̂(0) deve igualar a variância amostral; valores decrescentes para lags maiores em séries estacionárias.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Script Python completo",
                                    "Bibliotecas: NumPy, Pandas, Matplotlib",
                                    "Exemplo de dados reais"
                                  ],
                                  "tips": "Use np.correlate(x, x, mode='full') e ajuste para amostral; normalize pelo tamanho correto.",
                                  "learningObjective": "Automatizar e visualizar a função de autocovariância para análise completa.",
                                  "commonMistakes": [
                                    "Confundir autocovariância com autocorrelação",
                                    "Plotar sem centralizar",
                                    "Escala errada no eixo y"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir vieses em amostras finitas",
                                  "subSteps": [
                                    "Simule séries com n=20, 50, 200 e compare γ̂(h) com autocovariância teórica (se conhecida).",
                                    "Explique o viés: E[γ̂(h)] ≈ (1 - h/n) γ(h), subestimando para h>0.",
                                    "Discuta correções: dividir por (n-h) ou usar Bartlett's formula.",
                                    "Teste com ruído branco (γ(h)=0 para h>0) para ver viés positivo.",
                                    "Conclua com recomendações para n grande (>100)."
                                  ],
                                  "verification": "Simulações mostram viés decrescendo com n; explique em parágrafo escrito.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python para simulações (np.random)",
                                    "Gráficos comparativos"
                                  ],
                                  "tips": "Gere 100 réplicas por n para média do viés; foque em h=1.",
                                  "learningObjective": "Analisar limitações do estimador e estratégias de correção.",
                                  "commonMistakes": [
                                    "Ignorar que viés é pequeno para h<<n",
                                    "Confundir viés com variância",
                                    "Não simular"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a série de vendas mensais: [100, 105, 102, 108, 103, 107]. Calcule X̄=105. Média centrada Z=[-5,0,-3,3,-2,2]. Para h=1: produtos (-5*0=0, 0*-3=0, -3*3=-9, 3*-2=-6) soma=-15, n=6, γ̂(1)=-15/6=-2.5. Repita para h=2 e discuta viés com n pequeno.",
                              "finalVerifications": [
                                "Cálculo manual de γ̂(1) bate com código Python (erro <1e-6).",
                                "Plot de ACF mostra decay suave e γ̂(0)=variância.",
                                "Simulação com n=20 mostra |viés| < 0.1 para h=1 em ruído branco.",
                                "Explicação escrita cobre fórmula, soma correta e divisão por n.",
                                "Correção para viés proposta e testada.",
                                "Todos lags h=0 a 5 computados sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nos cálculos (100% dos produtos corretos).",
                                "Correta identificação e quantificação do viés em amostras finitas.",
                                "Visualização clara da ACF com lags rotulados.",
                                "Explicação teórica completa (fórmula, expectativa, propriedades).",
                                "Automação via código funcional e reutilizável.",
                                "Análise de sensibilidade a tamanho da amostra."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (produtos internos defasados).",
                                "Programação: Loops, vetores e funções em Python/R.",
                                "Economia: Previsão de séries temporais em finanças.",
                                "Física: Análise de sinais em oscilações estacionárias."
                              ],
                              "realWorldApplication": "Em finanças, calcular autocovariância amostral de retornos diários de ações para modelar dependências temporais em ARIMA, detectando sazonalidades e melhorando previsões de risco (ex: VaR em bancos)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.2.2",
                        "name": "Função de Autocorrelação",
                        "description": "A função de autocorrelação ρ(h) = γ(h)/γ(0) normaliza a autocovariância, fornecendo uma medida adimensional da correlação serial em lags h para séries estacionárias.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.2.1",
                            "name": "Definir e relacionar com autocovariância",
                            "description": "Definir ρ(h) = γ(h)/γ(0), com ρ(0)=1 e |ρ(h)| ≤ 1, e explicar sua relação direta com a função de autocovariância.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Função de Autocovariância γ(h)",
                                  "subSteps": [
                                    "Defina γ(h) = Cov(X_t, X_{t+h}) para uma série estacionária.",
                                    "Liste as propriedades principais: γ(0) = Var(X_t), γ(-h) = γ(h) e |γ(h)| ≤ γ(0).",
                                    "Calcule γ(h) manualmente para uma série simples de 5 observações.",
                                    "Interprete γ(h) como medida de dependência linear em lags.",
                                    "Compare γ(h) com covariância em variáveis independentes."
                                  ],
                                  "verification": "Calcule corretamente γ(1) e γ(0) para um exemplo dado e explique sua interpretação.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": "Folha de papel, calculadora, notas sobre séries temporais estacionárias.",
                                  "tips": "Sempre normalize pelo lag h para evitar confusões com variância.",
                                  "learningObjective": "Compreender o conceito e cálculo da autocovariância em séries estacionárias.",
                                  "commonMistakes": "Confundir γ(h) com correlação ou esquecer a simetria γ(-h) = γ(h)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a Função de Autocorrelação ρ(h)",
                                  "subSteps": [
                                    "Escreva a fórmula ρ(h) = γ(h) / γ(0).",
                                    "Explique que γ(0) é a variância, normalizando a autocovariância.",
                                    "Verifique ρ(0) = γ(0)/γ(0) = 1.",
                                    "Demonstre que |ρ(h)| ≤ 1 derivado de propriedades de covariância.",
                                    "Esboce um gráfico de ρ(h) vs h para visualização."
                                  ],
                                  "verification": "Escreva a definição exata de ρ(h) e comprove ρ(0)=1 com um cálculo simples.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": "Calculadora, software como Excel ou Python (opcional para plot).",
                                  "tips": "Pense na autocorrelação como autocovariância 'padronizada' para comparação entre séries.",
                                  "learningObjective": "Definir precisamente ρ(h) e entender sua normalização.",
                                  "commonMistakes": "Esquecer de dividir por γ(0) ou assumir ρ(0) ≠ 1."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Propriedades da Função de Autocorrelação",
                                  "subSteps": [
                                    "Liste propriedades: ρ(0)=1, |ρ(h)| ≤ 1, ρ(-h)=ρ(h).",
                                    "Prove |ρ(h)| ≤ 1 usando desigualdade de Cauchy-Schwarz.",
                                    "Calcule ρ(h) para lags h=1,2 em uma série de exemplo.",
                                    "Discuta implicações: ρ(h)=0 implica independência linear.",
                                    "Compare com correlação em amostras bivariadas."
                                  ],
                                  "verification": "Liste todas as propriedades e prove |ρ(h)| ≤ 1 para um caso numérico.",
                                  "estimatedTime": "30-40 minutos",
                                  "materials": "Papel para provas matemáticas, tabela de dados de série temporal.",
                                  "tips": "Use desigualdades básicas de probabilidade para provas intuitivas.",
                                  "learningObjective": "Dominar e provar as propriedades fundamentais de ρ(h).",
                                  "commonMistakes": "Ignorar a simetria ou confundir limite superior com igualdade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar Autocorrelação com Autocovariância",
                                  "subSteps": [
                                    "Explique a relação direta: ρ(h) é γ(h) escalonada por γ(0).",
                                    "Mostre como ρ(h) facilita comparações entre séries de variâncias diferentes.",
                                    "Converta γ(h) em ρ(h) e vice-versa em um exemplo prático.",
                                    "Discuta interpretação: ρ(h) mede força relativa da dependência.",
                                    "Aplique em um contexto de série temporal real."
                                  ],
                                  "verification": "Dado γ(h) e γ(0), calcule ρ(h) e explique a relação conceitual.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": "Exemplo de dados reais (ex: série de temperaturas), software R/Python.",
                                  "tips": "Sempre relacione de volta à variância para manter o contexto.",
                                  "learningObjective": "Explicar a interdependência entre ρ(h) e γ(h) de forma clara.",
                                  "commonMistakes": "Tratar ρ(h) como independente de γ(h) ou ignorar escalonamento."
                                }
                              ],
                              "practicalExample": "Considere uma série de temperaturas diárias: X = [20, 22, 21, 23, 22]. Calcule γ(0) ≈ 1.2, γ(1) ≈ 0.8, então ρ(1) = 0.8/1.2 ≈ 0.67, indicando correlação moderada positiva no lag 1.",
                              "finalVerifications": [
                                "Defina corretamente ρ(h) = γ(h)/γ(0).",
                                "Comprove ρ(0)=1 e |ρ(h)| ≤ 1 com prova ou exemplo.",
                                "Calcule ρ(h) a partir de γ(h) em uma série de 10 observações.",
                                "Explique verbalmente a relação entre autocorrelação e autocovariância.",
                                "Identifique quando ρ(h) ≈ 0 em um gráfico ACF.",
                                "Converta ρ(h) de volta para γ(h) dado γ(0)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na fórmula de ρ(h) (obrigatório).",
                                "Compreensão das propriedades ρ(0)=1 e |ρ(h)| ≤ 1.",
                                "Capacidade de cálculo numérico correto.",
                                "Explicação clara da normalização por γ(0).",
                                "Interpretação contextual em séries temporais.",
                                "Ausência de erros comuns como confusão com γ(h)."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade: Uso de covariância e correlação.",
                                "Álgebra Linear: Matrizes de covariância em vetores temporais.",
                                "Programação: Implementação em R (acf()) ou Python (pandas).",
                                "Economia: Análise de séries financeiras estacionárias.",
                                "Física: Modelos de processos estocásticos em sinais."
                              ],
                              "realWorldApplication": "Na previsão de vendas em varejo, ρ(1) alto indica que vendas de hoje preveem amanhã, permitindo modelos AR(1) para estoque eficiente e redução de perdas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.2.2.2",
                            "name": "Interpretar o correlograma",
                            "description": "Analisar o gráfico do correlograma (plot de ρ̂(h) vs h), identificando decaimento lento (não estacionariedade) ou corte rápido (branco ruído).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os componentes básicos do correlograma",
                                  "subSteps": [
                                    "Identifique o eixo x (lag h) e o eixo y (autocorrelação amostral ρ̂(h)).",
                                    "Localize as bandas de confiança (geralmente ±1.96/√n para 95% de confiança).",
                                    "Observe que ρ̂(0) = 1 sempre.",
                                    "Revise a definição de função de autocorrelação teórica ρ(h).",
                                    "Anote os lags mostrados no gráfico (tipicamente até 20-50)."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito cada componente principal do correlograma fornecido.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Gráfico de correlograma de exemplo (em R, Python ou software estatístico)",
                                    "Documentação sobre ACF (ex: help(acf) no R)"
                                  ],
                                  "tips": "Comece sempre pelo lag 0 e avance sequencialmente para construir intuição visual.",
                                  "learningObjective": "Compreender a estrutura visual e estatística do correlograma.",
                                  "commonMistakes": [
                                    "Confundir ρ̂(h) com correlação cruzada",
                                    "Ignorar as bandas de confiança",
                                    "Assumir simetria sem verificar"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o decaimento das autocorrelações em lags iniciais",
                                  "subSteps": [
                                    "Examine ρ̂(1) e ρ̂(2): devem ser altos e significativos em processos estacionários com dependência.",
                                    "Verifique se ρ̂(h) cai gradualmente para dentro das bandas de confiança.",
                                    "Compare com padrão esperado: decaimento exponencial para AR(1), sinusoidal para ARMA.",
                                    "Registre lags onde |ρ̂(h)| > limite de significância.",
                                    "Calcule aproximadamente o número de lags significativos."
                                  ],
                                  "verification": "Liste os primeiros 5 lags e indique quais são significativos, justificando com bandas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Correlograma de uma série estacionária (ex: AR(1))",
                                    "Calculadora ou software para √n"
                                  ],
                                  "tips": "Foquem nos primeiros lags, pois capturam dependência serial de curto prazo.",
                                  "learningObjective": "Identificar padrões de dependência em lags baixos.",
                                  "commonMistakes": [
                                    "Considerar todos os lags igualmente importantes",
                                    "Ignorar sinal (positivo/negativo)",
                                    "Confundir magnitude com significância"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detectar indícios de não-estacionariedade ou branco ruído",
                                  "subSteps": [
                                    "Procure decaimento lento: ρ̂(h) permanece significativo por muitos lags (>10-20).",
                                    "Identifique corte rápido: ρ̂(h) insignificante após lag 1 ou 2 (branco ruído).",
                                    "Verifique padrão de 'cauda pesada' para não-estacionariedade (ex: random walk).",
                                    "Compare com bandas: muitos pontos fora indicam estrutura serial.",
                                    "Diferencie: oscilações persistentes sugerem sazonalidade."
                                  ],
                                  "verification": "Classifique o correlograma como estacionário, não-estacionário ou branco ruído, com evidências.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos de correlogramas: random walk, white noise, AR(1)",
                                    "Tabela de regras de Box-Jenkins"
                                  ],
                                  "tips": "Use a regra prática: se >10% dos lags são significativos em lags altos, suspeite de não-estacionariedade.",
                                  "learningObjective": "Diagnosticar violações de estacionariedade via padrões de decaimento.",
                                  "commonMistakes": [
                                    "Confundir ruído com estacionariedade fraca",
                                    "Sobrepor sazonalidade a tendência",
                                    "Ignorar tamanho da amostra no cálculo de bandas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar a interpretação geral e propor próximos passos",
                                  "subSteps": [
                                    "Resuma o padrão: 'Decaimento exponencial sugere AR(p)'.",
                                    "Sugira testes complementares: ADF para estacionariedade, Ljung-Box para ruído.",
                                    "Documente conclusões em relatório curto.",
                                    "Compare com propriedades teóricas da série.",
                                    "Planeje modelagem: PACF para ordem do modelo."
                                  ],
                                  "verification": "Escreva um parágrafo de interpretação e lista de ações seguintes.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Templates de relatório de séries temporais",
                                    "Gráficos comparativos ACF/PACF"
                                  ],
                                  "tips": "Sempre ligue a interpretação a um modelo possível (AR, MA, etc.).",
                                  "learningObjective": "Integrar análise visual em diagnóstico completo de séries temporais.",
                                  "commonMistakes": [
                                    "Parar na descrição sem implicações",
                                    "Não considerar variância da estimativa",
                                    "Generalizar de um exemplo"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere dados de preços diários de ações (ex: AAPL). Plote o correlograma: observe decaimento muito lento (ρ̂(h) significativo até lag 20), indicando não-estacionariedade (tendência ou random walk). Converta para retornos log (diff(log(preços))) e re-plote: agora corte rápido após lag 1, sugerindo possível MA(1) ou ruído com estrutura fraca.",
                              "finalVerifications": [
                                "Correto identificação de pelo menos 80% dos lags significativos.",
                                "Classificação precisa de estacionariedade/branco ruído em 3 exemplos.",
                                "Explicação coerente do decaimento observada.",
                                "Uso apropriado das bandas de confiança.",
                                "Sugestão válida de testes/modelos seguintes.",
                                "Relatório escrito sem erros conceituais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção de padrões (decaimento lento vs. rápido): 30%",
                                "Compreensão de significância estatística: 25%",
                                "Qualidade da síntese e implicações: 20%",
                                "Uso de terminologia correta (ρ̂(h), lag, bandas): 15%",
                                "Criatividade em exemplos reais: 10%"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar acf() em R/Python (Ciência da Computação).",
                                "Economia: Análise de séries financeiras para previsão de mercado.",
                                "Física: Detecção de ruído em sinais experimentais.",
                                "Matemática: Propriedades de processos estocastros e limites de estacionariedade."
                              ],
                              "realWorldApplication": "Em finanças, interpretar correlogramas de retornos de ações para detectar dependência serial e evitar modelos inválidos em trading algorítmico; em meteorologia, diagnosticar não-estacionariedade em temperaturas para melhorar previsões climáticas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.2.3",
                            "name": "Calcular autocorrelação amostral",
                            "description": "Computar ρ̂(h) = γ̂(h)/γ̂(0) e calcular intervalos de confiança aproximados usando variância assintótica 1/n para testes de significância.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a série temporal e calcular a média amostral",
                                  "subSteps": [
                                    "Obtenha uma série temporal estacionária com n observações {X_t}_{t=1}^n",
                                    "Calcule a média amostral μ̂ = (1/n) Σ_{t=1}^n X_t",
                                    "Centre a série: defina Y_t = X_t - μ̂ para t=1 a n",
                                    "Verifique stationaridade básica plotando a série centrada",
                                    "Salve os dados centrados em uma lista ou vetor para uso posterior"
                                  ],
                                  "verification": "Confirme que a média dos Y_t é aproximadamente zero (erro < 0.01) e plote a série para visualização",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Dados de série temporal (ex: CSV com temperaturas diárias)",
                                    "Software R ou Python (pacotes: base R ou pandas/numpy)",
                                    "Calculadora ou planilha Excel"
                                  ],
                                  "tips": "Use funções prontas como mean() no R para μ̂, mas implemente manualmente primeiro para compreensão",
                                  "learningObjective": "Compreender o centramento da série como pré-requisito para autocovariância",
                                  "commonMistakes": [
                                    "Esquecer de centrar a série, levando a bias nas estimativas",
                                    "Usar média populacional em vez de amostral",
                                    "Não verificar stationaridade inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a autocovariância amostral γ̂(h) para lag h",
                                  "subSteps": [
                                    "Escolha o lag h (ex: h=1) e defina n_h = n - h",
                                    "Compute γ̂(h) = (1/n_h) Σ_{t=1}^{n_h} Y_t Y_{t+h}",
                                    "Implemente o loop ou fórmula vetorizada: soma de produtos cruzados",
                                    "Calcule para múltiplos h se necessário (h=1 a 10)",
                                    "Armazene γ̂(h) em um vetor ou tabela"
                                  ],
                                  "verification": "Para h=0, γ̂(0) deve ser positivo e igual à variância amostral; compare com var(Y) no software",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Série centrada do Step 1",
                                    "R (função acf() para validação)",
                                    "Python (numpy.correlate para checagem)"
                                  ],
                                  "tips": "Use divisão por n_h em vez de n para consistência assintótica; vetorize em Python com np.dot(Y[:-h], Y[h:])/n_h",
                                  "learningObjective": "Dominar a fórmula da autocovariância amostral e sua implementação numérica",
                                  "commonMistakes": [
                                    "Dividir por n em vez de n-h, causando viés",
                                    "Índices errados no loop (off-by-one)",
                                    "Não centrar antes do cálculo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a autocorrelação amostral ρ̂(h) = γ̂(h)/γ̂(0)",
                                  "subSteps": [
                                    "Calcule γ̂(0) = (1/n) Σ_{t=1}^n Y_t^2 (variância amostral)",
                                    "Para cada h, compute ρ̂(h) = γ̂(h) / γ̂(0)",
                                    "Gere a função de autocorrelação (ACF) para h=0 a 20",
                                    "Plote o correlogram ρ̂(h) vs h com barras de erro",
                                    "Interprete: ρ̂(0)=1, decaindo para 0 em séries brancas"
                                  ],
                                  "verification": "Verifique ρ̂(0) = 1 e |ρ̂(h)| ≤ 1 para todos h; plote deve mostrar decaimento",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "γ̂(h) do Step 2",
                                    "R (plot(acf())",
                                    "Python (matplotlib e statsmodels.tsa.stattools.acf)"
                                  ],
                                  "tips": "Normalize sempre por γ̂(0) > 0; use acf() built-in apenas para validação após implementação manual",
                                  "learningObjective": "Aplicar a normalização para obter correlação adimensional entre -1 e 1",
                                  "commonMistakes": [
                                    "Dividir por γ̂(h) em vez de γ̂(0)",
                                    "Ignorar sinal de ρ̂(h) negativo",
                                    "Não plotar para visual inspeção"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular intervalos de confiança e testar significância",
                                  "subSteps": [
                                    "Para ρ̂(h) ≈ N(0, 1/n) sob hipótese nula de ruído branco (h>0)",
                                    "Compute limite: ± 1.96 / sqrt(n) para 95% IC (z=1.96)",
                                    "Teste: se |ρ̂(h)| > 1.96/sqrt(n), rejeite H0: ρ(h)=0",
                                    "Plote barras de erro no correlogram ± 1.96/sqrt(n)",
                                    "Interprete resultados para lags significativos"
                                  ],
                                  "verification": "Calcule IC para h=1 e confirme se contém 0 ou não baseado em ρ̂(1); n grande dá IC estreito",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "ρ̂(h) e n do Step 3",
                                    "Tabela z-score (1.96 para 95%)",
                                    "Software para plot com ci"
                                  ],
                                  "tips": "Aproximação assintótica válida para n>50; para n pequeno, use Bartlett SE mais avançado",
                                  "learningObjective": "Usar variância assintótica para inferência estatística na ACF",
                                  "commonMistakes": [
                                    "Usar 1/sqrt(n) sem ±1.96",
                                    "Aplicar IC para h=0 (inválido)",
                                    "Confundir com IC para γ̂(h)"
                                  ]
                                }
                              ],
                              "practicalExample": "Dada uma série de 100 temperaturas diárias médias (ex: dados de Janeiro a Abril), centre os dados, calcule ρ̂(1) ≈ 0.75, γ̂(1)/γ̂(0), e IC 95%: ±0.196 (já que 1.96/sqrt(100)=0.196); como 0.75 > 0.196, lag 1 é significativo, indicando dependência serial.",
                              "finalVerifications": [
                                "ρ̂(0) = 1 exatamente",
                                "Todos |ρ̂(h)| ≤ 1",
                                "Correlogram plotado com decaimento visível",
                                "IC calculados corretamente: ±1.96/sqrt(n)",
                                "Identificados lags significativos corretamente",
                                "Interpretação coerente com propriedades de estacionariedade"
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nos cálculos de γ̂(h) e ρ̂(h) (erro < 0.01)",
                                "Implementação correta do centramento e fórmulas",
                                "Plot do correlogram com IC apropriados",
                                "Interpretação correta de significância (rejeição H0)",
                                "Uso adequado de aproximação assintótica (n>50)",
                                "Código ou cálculos manuais reproduzíveis"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em R/Python (pacotes forecast, statsmodels)",
                                "Probabilidade: Distribuição assintótica normal e testes de hipótese",
                                "Economia: Análise de séries financeiras (retornos de ações)",
                                "Física: Séries de medidas experimentais (ex: oscilações)",
                                "Machine Learning: Pré-processamento para modelos ARIMA"
                              ],
                              "realWorldApplication": "Em finanças, calcular ACF de retornos diários de ações para detectar autocorrelação (persistência), auxiliando em modelos de previsão de preços e detecção de ineficiências de mercado; em meteorologia, identificar lags significativos em precipitação para alertas de enchentes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.1.3"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.2.3",
                        "name": "Espectro de Potência",
                        "description": "O espectro de potência f(ω) representa a decomposição da variância da série estacionária em componentes de frequência ω, relacionada à autocovariância pela transformada de Fourier.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.3.1",
                            "name": "Definir o espectro de potência",
                            "description": "Definir f(ω) = (1/(2π)) Σ_{h=-∞}^∞ γ(h) e^{ -i h ω } para ω ∈ [-π, π], destacando sua interpretação como densidade espectral de potência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a função de autocovariância γ(h)",
                                  "subSteps": [
                                    "Defina γ(h) = Cov(X_t, X_{t+h}) para uma série estacionária.",
                                    "Note que γ(h) = γ(-h) e γ(0) = Var(X_t).",
                                    "Discuta propriedades: γ(h) → 0 quando |h| → ∞ para séries de mistura forte.",
                                    "Calcule γ(h) para exemplos simples como ruído branco."
                                  ],
                                  "verification": "Escreva a definição de γ(h) e compute para h=0 e h=1 em um exemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de aula sobre séries estacionárias",
                                    "Calculadora ou software como R/Python"
                                  ],
                                  "tips": "Lembre-se de que a estacionariedade implica dependência apenas de h, não de t.",
                                  "learningObjective": "Compreender a função autocovariância como base para o espectro.",
                                  "commonMistakes": [
                                    "Confundir autocovariância com autocorrelação normalizada",
                                    "Ignorar a simetria γ(h)=γ(-h)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a transformada de Fourier discreta",
                                  "subSteps": [
                                    "Explique a transformada de Fourier como soma ponderada por exponenciais complexas.",
                                    "Apresente a fórmula genérica: ˆf(ω) = Σ_{h=-∞}^∞ c(h) e^{-i h ω}.",
                                    "Discuta o intervalo ω ∈ [-π, π] devido à periodicidade 2π.",
                                    "Relacione com a ideia de decomposição em frequências.",
                                    "Verifique normalização comum em estatística."
                                  ],
                                  "verification": "Escreva a transformada de Fourier de uma sequência c(h) e identifique o papel de ω.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráfico de funções exponenciais",
                                    "Software de plotagem como MATLAB ou Python (matplotlib)"
                                  ],
                                  "tips": "Visualize e^{-i h ω} como vetores no plano complexo rotacionando com ω.",
                                  "learningObjective": "Entender como a transformada de Fourier converte autocovariância em espectro.",
                                  "commonMistakes": [
                                    "Usar intervalo errado para ω (ex: [0,2π] em vez de [-π,π])",
                                    "Esquecer o sinal negativo no expoente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir formalmente o espectro de potência f(ω)",
                                  "subSteps": [
                                    "Escreva f(ω) = (1/(2π)) Σ_{h=-∞}^∞ γ(h) e^{-i h ω} para ω ∈ [-π, π].",
                                    "Justifique o fator 1/(2π) para que ∫_{-π}^π f(ω) dω = γ(0).",
                                    "Mostre que f(ω) é real e par: f(ω) = f(-ω) > 0.",
                                    "Discuta convergência sob condições de estacionariedade.",
                                    "Calcule para caso simples: ruído branco."
                                  ],
                                  "verification": "Derive ou recite a fórmula completa e verifique para ruído branco.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de papel para derivação",
                                    "Exemplos de livros como Brockwell & Davis"
                                  ],
                                  "tips": "Use a propriedade γ(h)=γ(-h) para simplificar a soma em parte real.",
                                  "learningObjective": "Memorizar e derivar a fórmula exata do espectro de potência.",
                                  "commonMistakes": [
                                    "Omitir o 1/(2π)",
                                    "Escrever soma de h=0 a ∞ em vez de -∞ a ∞"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar f(ω) como densidade espectral de potência",
                                  "subSteps": [
                                    "Explique que f(ω) dω representa a contribuição de potência na faixa [ω, ω+dω].",
                                    "Relacione com variância total: γ(0) = ∫_{-π}^π f(ω) dω.",
                                    "Discuta picos em f(ω) indicando periodicidades na série.",
                                    "Compare com períodoograma como estimador empírico."
                                  ],
                                  "verification": "Explique verbalmente o significado de um pico em f(ω_0) e relacione com γ(0).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráficos de espectros de exemplos conhecidos",
                                    "Vídeos tutoriais sobre interpretação espectral"
                                  ],
                                  "tips": "Pense em f(ω) como 'distribuição de energia' ao longo das frequências.",
                                  "learningObjective": "Interpretar o espectro como densidade de potência no domínio da frequência.",
                                  "commonMistakes": [
                                    "Confundir com densidade espectral de amplitude",
                                    "Ignorar que f(ω) ≥ 0"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma série de ruído branco com Var(X_t)=σ², γ(h)=σ² se h=0 e 0 caso contrário. Assim, f(ω) = σ² / (2π) para todo ω ∈ [-π, π], um espectro plano indicando ausência de dependência serial.",
                              "finalVerifications": [
                                "Recitar a fórmula exata de f(ω).",
                                "Explicar o papel do fator 1/(2π).",
                                "Verificar que f(ω) é real, par e não-negativa.",
                                "Relacionar ∫ f(ω) dω = γ(0).",
                                "Interpretar um pico espectral.",
                                "Calcular f(ω) para ruído branco."
                              ],
                              "assessmentCriteria": [
                                "Precisão na escrita da fórmula (incluindo limites e normalização).",
                                "Correta derivação da simetria e positividade.",
                                "Interpretação física como densidade de potência.",
                                "Uso correto do intervalo ω ∈ [-π, π].",
                                "Aplicação em exemplo simples sem erros aritméticos.",
                                "Conexão clara com autocovariância."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de Fourier em ondas e vibrações.",
                                "Engenharia: Processamento de sinais digitais.",
                                "Economia: Análise espectral de séries financeiras para ciclos.",
                                "Matemática: Teoria de transformadas integrais."
                              ],
                              "realWorldApplication": "Na análise de sinais de áudio para identificar frequências dominantes em música ou fala; em finanças para detectar ciclos em retornos de ações; em meteorologia para estudar periodicidades em temperaturas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.2.3.2",
                            "name": "Relacionar com autocovariância",
                            "description": "Explicar a relação inversa via fórmula de inversão γ(h) = ∫_{-π}^π f(ω) e^{i h ω} dω e propriedades como f(ω) ≥ 0 e ∫ f(ω) dω = γ(0).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Autocovariância",
                                  "subSteps": [
                                    "Defina autocovariância γ(h) = Cov(X_t, X_{t+h}) para uma série estacionária.",
                                    "Calcule γ(0) como a variância e note que γ(h) = γ(-h).",
                                    "Discuta propriedades como decadência e simetria.",
                                    "Represente γ(h) como uma função de h em um gráfico.",
                                    "Verifique estacionariedade assumida."
                                  ],
                                  "verification": "Escreva as definições e plote γ(h) para um exemplo simples como ruído branco.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Caderno, calculadora, software R/Python para plotar ACF.",
                                  "tips": "Use exemplos numéricos pequenos para fixar ideias.",
                                  "learningObjective": "Compreender γ(h) como base para a relação espectral.",
                                  "commonMistakes": "Confundir autocovariância com autocorrelação (normalizada)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Espectro de Potência f(ω)",
                                  "subSteps": [
                                    "Defina f(ω) como a transformada de Fourier discreta de γ(h): f(ω) = (1/(2π)) Σ γ(h) e^{-i h ω}.",
                                    "Explique que f(ω) é uma densidade espectral de potência.",
                                    "Discuta periodicidade em [-π, π] e suavidade para processos reais.",
                                    "Mostre que f(ω) ≥ 0 para todo ω (propriedade de densidade).",
                                    "Integre f(ω) sobre [-π, π] para recuperar γ(0)."
                                  ],
                                  "verification": "Derive a integral ∫_{-π}^π f(ω) dω = γ(0) usando ortogonalidade de exponenciais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Folha de derivadas de Fourier, tabela de integrais complexas.",
                                  "tips": "Pense em f(ω) como 'distribuição de variância por frequência'.",
                                  "learningObjective": "Reconhecer f(ω) como representação frequência da autocovariância.",
                                  "commonMistakes": "Esquecer o fator 1/(2π) na definição direta."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar a Fórmula de Inversão",
                                  "subSteps": [
                                    "Apresente γ(h) = ∫_{-π}^π f(ω) e^{i h ω} dω.",
                                    "Derive a inversão a partir da transformada inversa de Fourier.",
                                    "Verifique para h=0: γ(0) = ∫ f(ω) dω.",
                                    "Mostre simetria: γ(-h) = ∫ f(ω) e^{-i h ω} dω = γ(h) pois f real.",
                                    "Discuta convergência absoluta para γ(h) absoluta somável."
                                  ],
                                  "verification": "Compute γ(h) numericamente para um f(ω) simples (ex: constante) e compare.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Software MATLAB/R para integração numérica, exemplos de processos ARMA.",
                                  "tips": "Use aproximação de Riemann para integrais em código.",
                                  "learningObjective": "Dominar a relação bidirecional entre domínio tempo e frequência.",
                                  "commonMistakes": "Confundir sinal do expoente (direta vs inversa)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Propriedades e Verificações",
                                  "subSteps": [
                                    "Prove f(ω) ≥ 0 usando forma quadrática positiva de γ.",
                                    "Verifique ∫ f(ω) dω = γ(0) via inversão em h=0.",
                                    "Discuta implicações para estacionariedade: espectro define covariância.",
                                    "Analise exemplo: MA(1) com γ(h) triangular e f(ω) suave.",
                                    "Simule em software para validar."
                                  ],
                                  "verification": "Gere gráfico de f(ω) e γ(h) para AR(1) e confirme relação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "R com pacotes 'forecast' ou Python 'statsmodels'.",
                                  "tips": "Sempre normalize frequências em [-π, π].",
                                  "learningObjective": "Aplicar e validar propriedades teóricas.",
                                  "commonMistakes": "Ignorar normalização de frequência ou assumir f complexa."
                                }
                              ],
                              "practicalExample": "Para um processo AR(1): X_t = 0.5 X_{t-1} + ε_t, compute γ(h) = σ² (0.5)^|h| / (1-0.25). Então, derive f(ω) = (σ² / 2π) / |1 - 0.5 e^{-iω}|² e inverta para recuperar γ(1) via integral numérica em Python.",
                              "finalVerifications": [
                                "Deriva corretamente γ(h) da fórmula de inversão para h≠0.",
                                "Explica por que f(ω) ≥ 0 usando positividade de variância.",
                                "Mostra que ∫ f(ω) dω = γ(0) com cálculo explícito.",
                                "Valida numericamente em um exemplo AR(1) com erro <1%.",
                                "Discute limitações para séries não estacionárias.",
                                "Plota espectro e autocovariância sobrepostos."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação da inversão (80%).",
                                "Clareza na explicação de propriedades (f≥0, integral=γ(0)).",
                                "Uso correto de exemplos numéricos/simulações.",
                                "Compreensão conceitual da dualidade tempo-frequência.",
                                "Identificação de erros comuns e precauções.",
                                "Criatividade em conexões práticas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise espectral de ondas e vibrações.",
                                "Engenharia de Sinais: Transformada de Fourier em processamento digital.",
                                "Economia: Espectro de séries financeiras para ciclos econômicos.",
                                "Processamento de Imagens: Espectro 2D para texturas."
                              ],
                              "realWorldApplication": "Em finanças, relacionar espectro de retornos de ações com autocovariância detecta ciclos sazonais; em engenharia, filtra ruído em sinais de sensores via domínio frequência, otimizando previsão e controle."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.1.2"
                            ]
                          },
                          {
                            "id": "10.1.4.2.3.3",
                            "name": "Interpretar o periodograma",
                            "description": "Analisar o periodograma I(ω) como estimador não suavizado de f(ω), identificando picos em frequências de ciclos dominantes em séries estacionárias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição e propriedades do periodograma",
                                  "subSteps": [
                                    "Revise a definição de espectro de potência f(ω) para séries estacionárias como a transformada de Fourier da função de autocovariância.",
                                    "Entenda o periodograma I(ω) como |∑ y_t exp(-iωt)|^2 / (2π n), um estimador não suavizado e assim assintoticamente não viesado de f(ω).",
                                    "Estude propriedades: I(ω) é não-negativo, integra a 2π γ(0), mas tem variância alta (2 ∫ f(ω)^2 dω).",
                                    "Compare com densidade espectral: periodograma é 'ruído' em torno de f(ω).",
                                    "Discuta limitações: inconsistente para ω fixo devido à variância."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a relação I(ω) ≈ f(ω) e liste 3 propriedades chave.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Notas de aula sobre séries temporais",
                                    "Software R ou Python com pacotes astsa ou statsmodels",
                                    "Artigo introdutório sobre espectro de potência"
                                  ],
                                  "tips": "Use diagramas esquemáticos para visualizar a relação entre autocovariância e f(ω).",
                                  "learningObjective": "Dominar a interpretação teórica do periodograma como estimador do espectro.",
                                  "commonMistakes": [
                                    "Confundir periodograma com DFT diretamente sem normalização",
                                    "Ignorar a alta variância do estimador não suavizado",
                                    "Assumir suavidade sem windowing"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar e visualizar o periodograma de uma série estacionária",
                                  "subSteps": [
                                    "Selecione ou simule uma série temporal estacionária (ex: AR(1) com ruído ou sinal senoidal + ruído).",
                                    "Implemente o cálculo do periodograma usando funções built-in (periodogram em R ou scipy.signal em Python).",
                                    "Plote I(ω) vs ω (frequências de 0 a π), usando escala log se necessário para visualizar picos.",
                                    "Ajuste parâmetros: número de Fourier frequencies (n/2+1 pontos).",
                                    "Salve o gráfico e anote eixos: ω em radianos ou ciclos/unidade tempo."
                                  ],
                                  "verification": "Gere e exiba um plot de periodograma para uma série de exemplo, confirmando visualização correta.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python/Jupyter com scipy, matplotlib",
                                    "R com astsa ou spectrum",
                                    "Dados de série temporal simulada (ex: 512 observações)"
                                  ],
                                  "tips": "Simule séries com ciclos conhecidos para validação visual imediata.",
                                  "learningObjective": "Adquirir proficiência prática na computação e visualização do periodograma.",
                                  "commonMistakes": [
                                    "Usar frequências erradas (ex: além de π)",
                                    "Não normalizar corretamente",
                                    "Plotar sem log-scale para séries com variância alta"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar picos no periodograma",
                                  "subSteps": [
                                    "Examine o gráfico em busca de picos proeminentes acima do nível de ruído de fundo.",
                                    "Localize as frequências ω_k onde I(ω_k) é máximo local, usando zoom ou detecção automática (find_peaks).",
                                    "Meça a altura e largura dos picos para avaliar significância.",
                                    "Compare múltiplos picos e ordene por magnitude para priorizar ciclos dominantes.",
                                    "Ignore picos em ω=0 ou ω=π se irrelevantes para ciclos intermediários."
                                  ],
                                  "verification": "Liste as top 3 frequências de picos com suas alturas para um periodograma dado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Plots gerados no step 2",
                                    "Ferramentas de análise numérica como numpy.find_peaks"
                                  ],
                                  "tips": "Use escala log10(I(ω)) para detectar picos sutis em ruído.",
                                  "learningObjective": "Desenvolver habilidade em detectar visual e numericamente picos indicativos de ciclos.",
                                  "commonMistakes": [
                                    "Confundir ruído com picos (sem threshold)",
                                    "Não considerar simetria em ω e 2π-ω",
                                    "Focar só no pico global ignorando secundários"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar picos como ciclos dominantes e validar",
                                  "subSteps": [
                                    "Associe cada pico ω_k a um ciclo com período 2π / ω_k (em unidades de tempo).",
                                    "Valide se a série é estacionária (teste ADF) e se picos persistem em subamostras.",
                                    "Compare com ACF/PACF para confirmação de lags periódicos.",
                                    "Discuta implicações: picos altos indicam variância concentrada em certas frequências.",
                                    "Sugira suavização (ex: Welch) se variância excessiva."
                                  ],
                                  "verification": "Escreva um relatório curto interpretando 2 picos em termos de ciclos e valide com ACF.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Periodogramas analisados",
                                    "Funções de teste de estacionariedade (adf.test em R)"
                                  ],
                                  "tips": "Converta ω para frequência cíclica f_k = ω_k / (2π) para interpretação intuitiva.",
                                  "learningObjective": "Integrar análise espectral à interpretação contextual de séries temporais.",
                                  "commonMistakes": [
                                    "Interpretar picos sem validar estacionariedade",
                                    "Esquecer conversão de frequência para período",
                                    "Sobreinterpretar picos isolados sem robustez"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule y_t = 2 sin(2π*0.15 t) + ε_t para t=1..512, ε_t ~ N(0,1). Compute periodograma: pico dominante em ω≈0.3 (período ≈21 unidades). Identifique como ciclo quinzenal dominante apesar do ruído.",
                              "finalVerifications": [
                                "Explica corretamente I(ω) como estimador não viesado mas inconsistente de f(ω).",
                                "Gera e plota periodograma para série estacionária simulada.",
                                "Identifica pelo menos 2 picos com frequências e períodos corretos.",
                                "Valida interpretação com ACF ou subamostras.",
                                "Discute limitações da alta variância.",
                                "Aplica a uma série real simples (ex: sunspots)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de picos (erro <5% em ω).",
                                "Correta relação teórica entre I(ω), f(ω) e autocovariância.",
                                "Qualidade visual e anotação dos plots.",
                                "Validação cruzada com outras ferramentas espectrais.",
                                "Profundidade na interpretação de ciclos dominantes.",
                                "Consciência de assunções de estacionariedade."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de Fourier em sinais periódicos e ondas sonoras.",
                                "Economia: Detecção de ciclos econômicos em PIB ou inflação.",
                                "Engenharia: Processamento de sinais em telecomunicações.",
                                "Biologia: Ritmos circadianos em dados fisiológicos."
                              ],
                              "realWorldApplication": "Em finanças, interpretar periodogramas de retornos de ações para detectar ciclos semanais/mensais; em meteorologia, identificar sazonalidades em precipitação; em engenharia, diagnosticar vibrações em máquinas via picos frequenciais dominantes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.3",
                    "name": "Testes de Estacionariedade",
                    "description": "Testes unit root como Dickey-Fuller e KPSS para verificar estacionariedade.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.3.1",
                        "name": "Estacionariedade e Raiz Unitária",
                        "description": "Conceito de estacionariedade em séries temporais, incluindo definições de estacionariedade fraca (média e variância constantes) e forte, e a relação com processos de raiz unitária que indicam não-estacionariedade.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.1.1",
                            "name": "Definir estacionariedade fraca e forte",
                            "description": "Explicar as propriedades estatísticas de uma série estacionária, como média constante, variância finita e covariância dependente apenas do lag, diferenciando de processos com raiz unitária.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fundamentos de Séries Temporais e Estacionariedade",
                                  "subSteps": [
                                    "Revise a definição de uma série temporal como uma sequência de observações ordenadas no tempo.",
                                    "Identifique por que a estacionariedade é crucial para modelagem e previsão em séries temporais.",
                                    "Diferencie processos estacionários de não estacionários com exemplos simples, como tendência linear.",
                                    "Estude as implicações de não estacionariedade, como testes espúrios em regressões.",
                                    "Anote as três propriedades principais da estacionariedade fraca: média constante, variância finita e autocovariância dependente do lag."
                                  ],
                                  "verification": "Resuma em suas palavras as razões para assumir estacionariedade em análises de séries temporais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro-texto de séries temporais (capítulo introdutório)",
                                    "Vídeo tutorial sobre séries temporais estacionárias (YouTube ou Khan Academy)"
                                  ],
                                  "tips": "Use diagramas para visualizar séries estacionárias vs. não estacionárias.",
                                  "learningObjective": "Compreender o papel da estacionariedade na análise de séries temporais.",
                                  "commonMistakes": [
                                    "Confundir estacionariedade com ausência de tendência",
                                    "Ignorar a importância da autocovariância no lag"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e Exemplificar Estacionariedade Fraca",
                                  "subSteps": [
                                    "Defina formalmente estacionariedade fraca: E[X_t] = μ (constante), Var(X_t) = σ² < ∞, Cov(X_t, X_{t+k}) = γ(k) dependendo apenas de k.",
                                    "Calcule a média e variância de uma série AR(1) estacionária para verificar condições.",
                                    "Plote uma série simulada estacionária fraca e observe a estabilidade da média móvel.",
                                    "Compare com uma série com drift (não estacionária) para destacar diferenças.",
                                    "Derive a condição de estacionariedade para processos ARMA simples."
                                  ],
                                  "verification": "Gere um gráfico de uma série estacionária fraca e confirme visualmente as propriedades.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software R ou Python (pacotes forecast ou statsmodels)",
                                    "Notebook Jupyter para simulações"
                                  ],
                                  "tips": "Simule séries em código para reforçar o entendimento intuitivo.",
                                  "learningObjective": "Definir precisamente e verificar estacionariedade fraca.",
                                  "commonMistakes": [
                                    "Esquecer que a variância deve ser finita",
                                    "Confundir covariância com correlação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Estacionariedade Forte e Suas Diferenças",
                                  "subSteps": [
                                    "Defina estacionariedade forte: a distribuição conjunta de (X_t, X_{t+1}, ..., X_{t+m}) é idêntica para todo t e m.",
                                    "Explique que estacionariedade fraca é necessária mas não suficiente para forte.",
                                    "Dê exemplos: ruído branco i.i.d. é fortemente estacionário; AR(1) com |φ|<1 é fracamente mas nem sempre fortemente.",
                                    "Discuta implicações para inferência estatística e modelagem.",
                                    "Compare formalmente as definições matemáticas lado a lado."
                                  ],
                                  "verification": "Escreva as definições matemáticas de ambas e forneça um contraexemplo onde fraca vale mas forte não.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula ou PDF sobre propriedades de processos estocásticos",
                                    "Artigo acadêmico introdutório sobre estacionariedade"
                                  ],
                                  "tips": "Use analogias: fraca é como média e variância estáveis; forte é toda a 'forma' da distribuição.",
                                  "learningObjective": "Distinguir estacionariedade fraca de forte com rigor matemático.",
                                  "commonMistakes": [
                                    "Achar que fraca e forte são equivalentes",
                                    "Ignorar a invariância da distribuição conjunta"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar de Processos com Raiz Unitária",
                                  "subSteps": [
                                    "Explique raiz unitária: polinômio característico com raiz 1, levando a não estacionariedade.",
                                    "Mostre que processos com raiz unitária têm variância crescente com o tempo.",
                                    "Simule um passeio aleatório (raiz unitária) vs. AR(1) estacionário e compare ACF.",
                                    "Discuta testes como Dickey-Fuller para detectar não estacionariedade.",
                                    "Relacione com explosão de variância em previsões de longo prazo."
                                  ],
                                  "verification": "Identifique em um gráfico fornecido se a série tem raiz unitária e justifique.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código Python/R para simular RW e AR(1)",
                                    "Gráficos de exemplo de séries não estacionárias"
                                  ],
                                  "tips": "Foco na divergência das propriedades de segunda ordem em raiz unitária.",
                                  "learningObjective": "Contrastar estacionariedade com processos de raiz unitária.",
                                  "commonMistakes": [
                                    "Confundir tendência determinística com raiz unitária",
                                    "Subestimar impacto em regressões"
                                  ]
                                }
                              ],
                              "practicalExample": "Ao analisar a série temporal de preços diários de Bitcoin, verifique se é fracamente estacionária calculando média móvel e ACF; se tiver raiz unitária, diferencie log-retornos para induzir estacionariedade e modelar volatilidade.",
                              "finalVerifications": [
                                "Define corretamente as três condições da estacionariedade fraca.",
                                "Explica a invariância da distribuição conjunta para estacionariedade forte.",
                                "Fornece um exemplo onde fraca vale mas forte não.",
                                "Identifica propriedades violadas em processos com raiz unitária.",
                                "Distingue visual e matematicamente estacionárias de não estacionárias.",
                                "Aplica conceitos a uma série real simulada."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições matemáticas (80%+ correto).",
                                "Capacidade de diferenciar fraca vs. forte com exemplos.",
                                "Análise correta de simulações ou gráficos.",
                                "Compreensão de implicações para testes e modelagem.",
                                "Uso apropriado de terminologia técnica.",
                                "Criatividade em aplicações práticas."
                              ],
                              "crossCurricularConnections": [
                                "Economia: Modelagem de ciclos econômicos e previsão de PIB.",
                                "Finanças: Testes de eficiência de mercado em retornos de ativos.",
                                "Física: Análise de sinais em processos estocásticos como movimento browniano.",
                                "Engenharia: Controle de sistemas com ruído estacionário."
                              ],
                              "realWorldApplication": "Em finanças, detectar não estacionariedade devido a raiz unitária em preços de ações permite transformar dados (ex: retornos log) para modelar riscos e prever volatilidade com ARIMA, evitando previsões enviesadas em portfólios de investimento."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.1.2",
                            "name": "Identificar sinais visuais de não-estacionariedade",
                            "description": "Analisar gráficos de séries temporais para detectar tendências, heteroscedasticidade ou sazonalidade que violam a estacionariedade, usando exemplos como walk random com drift.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Estacionariedade",
                                  "subSteps": [
                                    "Defina estacionariedade fraca como média constante, variância constante e autocovariância dependendo apenas do lag.",
                                    "Examine exemplos de séries estacionárias, como ruído branco, e compare com não-estacionárias.",
                                    "Identifique os três componentes principais: média, variância e covariância.",
                                    "Revise definições de tendência, sazonalidade e heteroscedasticidade como violações.",
                                    "Crie um diagrama mental ligando cada componente a sinais visuais em gráficos."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras explicando os três componentes e dê um exemplo de violação para cada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráficos de séries temporais estacionárias e não-estacionárias (ex: de Python matplotlib ou R ggplot)",
                                    "Artigo introdutório sobre estacionariedade (ex: de Towards Data Science)"
                                  ],
                                  "tips": "Use cores diferentes para destacar cada componente em gráficos de exemplo para melhor retenção visual.",
                                  "learningObjective": "Dominar a definição e componentes da estacionariedade para reconhecer violações visuais.",
                                  "commonMistakes": [
                                    "Confundir estacionariedade com estacionariedade forte (distribuição invariante)",
                                    "Ignorar a autocovariância e focar apenas em média e variância"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Tendências e Drift em Gráficos",
                                  "subSteps": [
                                    "Observe a linha central do gráfico: uma inclinação consistente indica drift ou tendência.",
                                    "Trace uma linha de regressão linear visualmente para confirmar direção e força da tendência.",
                                    "Compare com random walk sem drift: flutuações aleatórias sem direção.",
                                    "Meça visualmente a mudança na média ao longo do tempo usando médias móveis.",
                                    "Pratique com múltiplos gráficos, rotulando 'tendência ascendente', 'descendente' ou 'ausente'."
                                  ],
                                  "verification": "Analise 3 gráficos fornecidos e classifique cada um quanto à presença de tendência, justificando com evidências visuais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Gráficos de random walk com drift (gerados via Python: np.cumsum(np.random.randn(n) + 0.01))",
                                    "Ferramenta interativa como Plotly para zoom em gráficos"
                                  ],
                                  "tips": "Procure por 'escadas' ou inclinações persistentes; ignore flutuações curtas.",
                                  "learningObjective": "Detectar visualmente mudanças na média que violam estacionariedade.",
                                  "commonMistakes": [
                                    "Confundir tendência curta com ruído",
                                    "Não diferenciar drift linear de não-linear"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detectar Sazonalidade e Heteroscedasticidade",
                                  "subSteps": [
                                    "Procure padrões repetitivos cíclicos em intervalos fixos (ex: picos mensais em dados de vendas).",
                                    "Meça a amplitude das oscilações: consistência indica sazonalidade pura.",
                                    "Observe a largura das faixas de confiança ou dispersão: alargamento indica heteroscedasticidade.",
                                    "Sobreponha médias móveis sazonais para visualizar ciclos.",
                                    "Compare gráficos com e sem sazonalidade, anotando períodos e amplitudes."
                                  ],
                                  "verification": "Em um gráfico composto, circule e rotule padrões sazonais e regiões de variância crescente.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Gráficos de dados sazonais (ex: temperatura mensal, vendas natalinas)",
                                    "Software como Excel ou Google Sheets para plotar dados de exemplo"
                                  ],
                                  "tips": "Conte o número de ciclos em um período fixo para confirmar sazonalidade.",
                                  "learningObjective": "Reconhecer padrões cíclicos e mudanças na variância visualmente.",
                                  "commonMistakes": [
                                    "Confundir sazonalidade com tendência longa",
                                    "Ignorar heteroscedasticidade em caudas de distribuições"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Realizar Análise Integrada e Prática com Exemplos",
                                  "subSteps": [
                                    "Analise um gráfico completo: verifique tendência, sazonalidade e heteroscedasticidade sequencialmente.",
                                    "Use o exemplo de random walk com drift: identifique drift dominante e variância crescente.",
                                    "Crie uma checklist visual: média? variância? ciclos?",
                                    "Compare múltiplas séries e priorize violações principais.",
                                    "Gere seu próprio gráfico não-estacionário e autoavalie."
                                  ],
                                  "verification": "Produza um relatório curto (200 palavras) analisando 2 gráficos reais, listando todos os sinais de não-estacionariedade.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Datasets reais (ex: preços de ações do Yahoo Finance)",
                                    "Python/R para gerar e plotar random walks"
                                  ],
                                  "tips": "Sempre comece pela visão geral do gráfico antes de zoomar em detalhes.",
                                  "learningObjective": "Integrar detecções para uma análise holística de não-estacionariedade.",
                                  "commonMistakes": [
                                    "Sobrestimar ruído como sazonalidade",
                                    "Não considerar múltiplas violações simultâneas"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um gráfico de preços diários de Bitcoin de 2020-2023: observe a tendência ascendente clara (drift), picos sazonais semanais (volatilidade de fim de semana) e heteroscedasticidade com variância explosiva durante bull runs. Circule a inclinação linear, padrões repetitivos e faixas alargadas para confirmar não-estacionariedade.",
                              "finalVerifications": [
                                "Classifica corretamente 90% dos gráficos como estacionários ou não-estacionários.",
                                "Identifica e descreve pelo menos uma violação específica (tendência, sazonalidade ou heteroscedasticidade) em cada gráfico não-estacionário.",
                                "Justifica detecções com evidências visuais quantificáveis (ex: inclinação média).",
                                "Diferencia random walk com drift de sem drift em exemplos cegos.",
                                "Gera um gráfico não-estacionário e explica suas violações.",
                                "Aplica checklist integrada sem omitir componentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de tendências (ausência de falsos positivos/negativos >95%).",
                                "Detalhe na descrição de sazonalidade (período e amplitude corretos).",
                                "Reconhecimento de heteroscedasticidade em 80% dos casos com dispersão variável.",
                                "Integração coerente de múltiplas violações em análises.",
                                "Uso efetivo de ferramentas visuais (anotações, zoom).",
                                "Tempo de análise eficiente (<5 min por gráfico após prática)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Regressão linear e testes de tendência (ex: Augmented Dickey-Fuller visual pré-teste).",
                                "Economia: Análise de séries macroeconômicas como PIB ou inflação.",
                                "Ciência de Dados: Pré-processamento para modelos ARIMA ou Prophet.",
                                "Física: Séries temporais em sinais experimentais (ex: detecção de drifts em medições).",
                                "Finanças: Modelagem de ativos voláteis e risk management."
                              ],
                              "realWorldApplication": "Em previsão de demanda de varejo, identificar sazonalidade e tendências em vendas passadas permite aplicar transformações (differencing, decomposição) para modelos precisos, evitando forecasts enviesados e otimizando estoque em até 20%."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.1.3",
                            "name": "Explicar o impacto da não-estacionariedade em previsões",
                            "description": "Discutir como séries não-estacionárias levam a previsões inválidas em modelos ARIMA e a necessidade de diferenciação para induzir estacionariedade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Estacionariedade",
                                  "subSteps": [
                                    "Defina estacionariedade: média, variância e covariância constantes ao longo do tempo.",
                                    "Diferencie estacionariedade fraca (covariância) de forte (distribuição invariante).",
                                    "Identifique componentes de não-estacionariedade: tendência, sazonalidade e heterocedasticidade.",
                                    "Analise gráficos de séries temporais para detectar padrões não-estacionários.",
                                    "Revise propriedades estatísticas como autocorrelação em séries estacionárias."
                                  ],
                                  "verification": "Crie um diagrama explicando os componentes de uma série não-estacionária e liste 3 exemplos reais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Gráficos de séries temporais (ex: dados de PIB), software R ou Python (pacotes forecast ou statsmodels).",
                                  "tips": "Use plots ACF/PACF para visualizar violações de estacionariedade.",
                                  "learningObjective": "Explicar com precisão os critérios de estacionariedade e identificar não-estacionariedade em dados.",
                                  "commonMistakes": "Confundir variância crescente com tendência linear; ignorar sazonalidade como forma de não-estacionariedade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar as Assunções dos Modelos ARIMA",
                                  "subSteps": [
                                    "Descreva o modelo ARIMA(p,d,q) e o papel do parâmetro d (diferenciação).",
                                    "Explique por que ARIMA requer estacionariedade nos resíduos para validade estatística.",
                                    "Discuta a invertibilidade e estacionariedade nos componentes AR e MA.",
                                    "Simule uma série estacionária e ajuste um ARIMA(1,0,0) para verificar resíduos brancos.",
                                    "Compare com uma série não-estacionária para mostrar falha no ajuste."
                                  ],
                                  "verification": "Ajuste um ARIMA em dados estacionários e não-estacionários; verifique resíduos com teste Ljung-Box.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python (statsmodels, pandas), dados sintéticos de séries temporais.",
                                  "tips": "Sempre plote resíduos e ACF para validar assunções.",
                                  "learningObjective": "Articular as premissas matemáticas do ARIMA e sua dependência em estacionariedade.",
                                  "commonMistakes": "Achar que ARIMA funciona sem d=0 nos resíduos; ignorar diagnósticos de modelo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Demonstrar o Impacto da Não-Estacionariedade em Previsões",
                                  "subSteps": [
                                    "Gere previsões com ARIMA em série não-estacionária sem diferenciação.",
                                    "Avalie métricas: MAE, RMSE e intervalos de confiança inválidos.",
                                    "Explique viés em previsões: tendência não capturada leva a desvios crescentes.",
                                    "Compare previsões inválidas vs. estacionarizadas (com diff).",
                                    "Discuta implicações: confiança falsa em forecasts econômicos ou financeiros."
                                  ],
                                  "verification": "Produza gráficos de previsões ruins vs. corrigidas e calcule erro percentual >20% em casos não-estacionários.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Dados reais (ex: AirPassengers dataset), Jupyter Notebook.",
                                  "tips": "Use zoom em previsões de longo prazo para destacar divergência.",
                                  "learningObjective": "Quantificar e visualizar como não-estacionariedade invalida previsões ARIMA.",
                                  "commonMistakes": "Subestimar impacto em horizontes curtos; não escalar erros adequadamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Diferenciação para Induzir Estacionariedade",
                                  "subSteps": [
                                    "Aplique diferenciação de primeira ordem (ΔY_t = Y_t - Y_{t-1}).",
                                    "Teste estacionariedade pós-diferenciação com ADF ou KPSS.",
                                    "Ajuste ARIMA com d apropriado e valide previsões.",
                                    "Discuta sobrediferenciação (ruído excessivo) vs. insuficiente.",
                                    "Resuma o processo: teste → diff → modelar → prever."
                                  ],
                                  "verification": "Transforme uma série não-estacionária em estacionária e mostre previsão estável com p-value ADF <0.05.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Funções adfuller() em Python/R, dados com tendência conhecida.",
                                  "tips": "Comece com diff=1; teste iterativamente para evitar over-differencing.",
                                  "learningObjective": "Implementar diferenciação como solução prática para restaurar validade em ARIMA.",
                                  "commonMistakes": "Diferenciar sem teste prévio; confundir diff com detrending."
                                }
                              ],
                              "practicalExample": "Usando o dataset AirPassengers (passageiros aéreos mensais com tendência e sazonalidade): ajuste ARIMA(0,1,1) sem diff leva a previsões com RMSE=150+ e intervalos explodindo; após diff=1 e sazonal, RMSE cai para <20, capturando padrões reais.",
                              "finalVerifications": [
                                "Explique em 2 minutos o porquê de previsões inválidas sem estacionariedade.",
                                "Gere e compare 3 gráficos de previsões antes/depois da diferenciação.",
                                "Passe em teste ADF pós-diferenciação com p<0.05.",
                                "Identifique não-estacionariedade em novo dataset fornecido.",
                                "Discuta limitação: diferenciação não resolve heterocedasticidade.",
                                "Resuma assunções ARIMA em bullet points precisos."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas de estacionariedade e impacto (30%)",
                                "Evidências empíricas: gráficos e métricas de previsão comparativas (25%)",
                                "Aplicação prática: uso correto de diff e testes (20%)",
                                "Clareza explicativa: linguagem acessível sem jargões desnecessários (15%)",
                                "Análise crítica: menção a limitações e alternativas (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Econometria: Modelos VAR e cointegration para séries não-estacionárias.",
                                "Machine Learning: Feature engineering em LSTM para séries temporais.",
                                "Finanças: Previsão de retornos de ações e testes de raiz unitária.",
                                "Engenharia: Controle de processos com sinais não-estacionários."
                              ],
                              "realWorldApplication": "Em previsão de demanda de varejo, séries de vendas não-estacionárias (com crescimento) levam a estoques excessivos se não diferenciadas; diferenciação permite ARIMA preciso, otimizando supply chain e reduzindo custos em 15-20%."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.3.2",
                        "name": "Teste de Dickey-Fuller (DF e ADF)",
                        "description": "Teste unit root baseado em regressão autoregressiva para testar a hipótese nula de presença de raiz unitária (não-estacionariedade) contra a alternativa de estacionariedade.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.2.1",
                            "name": "Formular as hipóteses do teste Dickey-Fuller",
                            "description": "Estabelecer H0: ρ=1 (raiz unitária) vs H1: |ρ|<1 (estacionária), incluindo versões com drift e tendência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o modelo AR(1) subjacente ao teste Dickey-Fuller",
                                  "subSteps": [
                                    "Revise a equação do processo AR(1): y_t = ρ y_{t-1} + ε_t",
                                    "Transforme em diferenças primeiras: Δy_t = (ρ - 1) y_{t-1} + ε_t",
                                    "Identifique o parâmetro γ = ρ - 1, onde H0: γ = 0 (ρ = 1, raiz unitária)",
                                    "Explique verbalmente por que ρ = 1 implica não-estacionariedade",
                                    "Anote a regressão básica sem constantes ou tendências"
                                  ],
                                  "verification": "Escreva corretamente a equação Δy_t = γ y_{t-1} + ε_t e defina γ = ρ - 1",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de aula sobre AR(1)",
                                    "Livro 'Análise de Séries Temporais' (cap. sobre testes de raiz unitária)",
                                    "Calculadora ou papel para derivações"
                                  ],
                                  "tips": "Lembre-se: o teste é sobre a significância de γ, não de ρ diretamente na regressão.",
                                  "learningObjective": "Compreender a transformação do modelo AR(1) para a forma de teste Dickey-Fuller.",
                                  "commonMistakes": [
                                    "Confundir ρ com γ",
                                    "Esquecer a diferença primeira Δy_t"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular hipóteses para o teste Dickey-Fuller sem drift ou tendência",
                                  "subSteps": [
                                    "Defina H0: ρ = 1 (ou γ = 0), significando raiz unitária e não-estacionariedade",
                                    "Defina H1: |ρ| < 1 (ou γ < 0), significando estacionariedade em torno de uma média constante",
                                    "Escreva as hipóteses em notação matemática: H0: ρ = 1 vs. H1: ρ < 1",
                                    "Interprete: rejeitar H0 implica a série é estacionária",
                                    "Pratique reescrevendo para um exemplo simples de série temporal"
                                  ],
                                  "verification": "Formule corretamente H0: ρ = 1 vs H1: |ρ| < 1 em um papel ou documento",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Folha de papel ou editor de texto",
                                    "Exemplos de séries temporais estacionárias vs. não-estacionárias"
                                  ],
                                  "tips": "Sempre especifique que H1 é de estacionariedade (ρ < 1), não bidirecional.",
                                  "learningObjective": "Dominar a formulação básica das hipóteses do teste DF puro.",
                                  "commonMistakes": [
                                    "Escrever H1 como ρ ≠ 1 em vez de |ρ| < 1",
                                    "Inverter H0 e H1"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporar drift (constante) nas hipóteses do teste Dickey-Fuller",
                                  "subSteps": [
                                    "Adicione o termo de drift: Δy_t = α + γ y_{t-1} + ε_t",
                                    "Formule H0: γ = 0 (raiz unitária com drift aleatório)",
                                    "H1: γ < 0 (estacionária em torno de uma média não-zero)",
                                    "Discuta implicações: sob H0, a série tem tendência estocástica",
                                    "Compare com o modelo sem drift anotando diferenças nas hipóteses"
                                  ],
                                  "verification": "Escreva a regressão com α e as hipóteses H0: γ=0 vs H1: γ<0",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Gráficos de walk random com drift",
                                    "Software como R para simular séries"
                                  ],
                                  "tips": "O drift α é testado separadamente; foque nas hipóteses sobre γ.",
                                  "learningObjective": "Formular hipóteses corretas para a versão DF com drift.",
                                  "commonMistakes": [
                                    "Incluir α na H0 principal",
                                    "Confundir drift determinístico com estocástico"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Incluir tendência linear e formular hipóteses completas do ADF",
                                  "subSteps": [
                                    "Estenda o modelo: Δy_t = α + β t + γ y_{t-1} + ε_t",
                                    "H0: γ = 0 (raiz unitária com drift e tendência linear)",
                                    "H1: γ < 0 (estacionária em torno de tendência determinística)",
                                    "Escreva todas as três versões de hipóteses lado a lado para comparação",
                                    "Pratique selecionando a versão apropriada baseado no contexto da série"
                                  ],
                                  "verification": "Liste as três formulações (sem drift, com drift, com tendência) com H0 e H1 corretas",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela comparativa de modelos DF/ADF",
                                    "Documentação do comando ur.df no R ou adfuller no Python"
                                  ],
                                  "tips": "Use ADF para lags extras, mas hipóteses sobre ρ permanecem as mesmas.",
                                  "learningObjective": "Formular hipóteses para todas as variantes do teste Dickey-Fuller.",
                                  "commonMistakes": [
                                    "Escrever H1 como estacionariedade sem qualificar o tipo de tendência",
                                    "Confundir tendência linear βt com drift"
                                  ]
                                }
                              ],
                              "practicalExample": "Para analisar a série temporal de preços diários do Bitcoin (BTC/USD) de 2020-2023, formule as hipóteses do teste ADF com drift e tendência: H0: γ = 0 (raiz unitária com drift e tendência linear, série não-estacionária) vs. H1: γ < 0 (estacionária em torno de uma tendência determinística). Isso permite testar se diferenciar os preços é necessário antes de modelar retornos.",
                              "finalVerifications": [
                                "Formulação correta de H0: ρ=1 (γ=0) em todas as variantes",
                                "H1 corretamente como |ρ|<1 ou γ<0, com qualificações para drift/tendência",
                                "Identificação precisa das regressões associadas (sem/constante/tendência)",
                                "Interpretação verbal das implicações de não rejeitar H0",
                                "Seleção apropriada da variante baseada em gráfico da série",
                                "Sem erros na notação matemática (Δy_t, γ = ρ-1)"
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de H0 e H1 (100% correto ganha nota máxima)",
                                "Compreensão conceitual: explicar raiz unitária vs. estacionariedade",
                                "Capacidade de diferenciar variantes (sem drift, drift, tendência)",
                                "Aplicação contextual: escolher modelo certo para uma série dada",
                                "Clareza na escrita matemática e verbal das hipóteses",
                                "Ausência de erros comuns como inverter hipóteses"
                              ],
                              "crossCurricularConnections": [
                                "Econometria: Aplicação em modelos de regressão com séries temporais",
                                "Programação: Implementação em R (ur.df) ou Python (statsmodels.tsa.stattools.adfuller)",
                                "Matemática: Álgebra linear e processos estocásticos (raiz unitária)",
                                "Finanças: Testes de estacionariedade em retornos de ativos",
                                "Machine Learning: Pré-processamento de features temporais para modelos preditivos"
                              ],
                              "realWorldApplication": "Em finanças, formular hipóteses do Dickey-Fuller é essencial para detectar não-estacionariedade em séries como PIB ou preços de ações, evitando modelos inválidos e guiando diferenciações para previsões precisas em bancos centrais ou trading algorítmico."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.2.2",
                            "name": "Calcular e interpretar a estatística DF/ADF",
                            "description": "Implementar o teste em software como R, comparando a estatística de teste com valores críticos de MacKinnon e p-valor para rejeitar ou não H0.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e os dados no R",
                                  "subSteps": [
                                    "Instalar e carregar os pacotes necessários: urca para testes ADF e tseries para DF.",
                                    "Carregar o conjunto de dados de série temporal (ex: dados de PIB trimestral).",
                                    "Verificar a estrutura dos dados com summary() e plot() para identificar tendências.",
                                    "Transformar os dados em objeto ts() se necessário.",
                                    "Realizar testes preliminares de autocorrelação com acf() e pacf()."
                                  ],
                                  "verification": "Confirme que os pacotes estão carregados sem erros e que o plot da série temporal é exibido corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "R e RStudio instalados",
                                    "Pacotes: urca, tseries",
                                    "Dataset exemplo: AirPassengers ou dados econômicos CSV"
                                  ],
                                  "tips": "Sempre use set.seed() para reprodutibilidade em simulações.",
                                  "learningObjective": "Configurar corretamente o ambiente R para testes de estacionariedade.",
                                  "commonMistakes": [
                                    "Esquecer de instalar pacotes",
                                    "Não converter dados para ts()",
                                    "Ignorar missing values"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o teste Dickey-Fuller (DF) ou Aumentado (ADF)",
                                  "subSteps": [
                                    "Executar o teste DF com ur.df() ou adf.test() especificando type='none', 'drift' ou 'trend'.",
                                    "Definir lags apropriados usando critérios como AIC ou BIC.",
                                    "Armazenar o resultado em uma variável (ex: df_result <- ur.df(data, type='trend', lags=4)).",
                                    "Exibir o summary(df_result) para inspecionar saídas iniciais.",
                                    "Repetir para ADF se necessário, ajustando lags automaticamente."
                                  ],
                                  "verification": "O output do summary() mostra estatística de teste, valores p e críticos sem erros de execução.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Funções ur.df() e adf.test()",
                                    "Documentação do pacote urca"
                                  ],
                                  "tips": "Comece com lags=0 e aumente baseado em diagnósticos.",
                                  "learningObjective": "Executar corretamente os testes DF e ADF com diferentes especificações.",
                                  "commonMistakes": [
                                    "Escolha errada de type (ex: drift em série sem tendência)",
                                    "Número inadequado de lags levando a especificação errada"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Extrair e comparar a estatística de teste com valores críticos de MacKinnon",
                                  "subSteps": [
                                    "Extrair a estatística DF/ADF do resultado (ex: df_result@teststat).",
                                    "Obter valores críticos de MacKinnon do summary() ou tabela manual.",
                                    "Comparar manualmente: se |estatística| > |crítico 5%|, rejeitar H0.",
                                    "Verificar o p-valor fornecido (ex: df_result@signif).",
                                    "Calcular e imprimir uma tabela comparativa usando data.frame()."
                                  ],
                                  "verification": "Criar uma tabela que liste estatística, críticos (1%,5%,10%) e p-valor corretamente extraídos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabelas de valores críticos de MacKinnon (disponíveis em pacotes ou PDF)",
                                    "Funções summary() e coef()"
                                  ],
                                  "tips": "Use round() para formatar valores e facilitar comparação visual.",
                                  "learningObjective": "Identificar e extrair componentes chave dos resultados do teste.",
                                  "commonMistakes": [
                                    "Confundir sinal da estatística (DF é negativa)",
                                    "Ignorar o p-valor em favor apenas de críticos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados e decidir sobre a hipótese nula (H0)",
                                  "subSteps": [
                                    "Se p-valor < 0.05 ou |estatística| > crítico, concluir estacionariedade e rejeitar H0 (raiz unitária).",
                                    "Se não rejeitar, discutir implicações (ex: diferenciar a série).",
                                    "Gerar relatório textual com cat() ou knitr explicando a decisão.",
                                    "Visualizar resíduos com plot(df_result@residuals) para validar suposições.",
                                    "Recomendar próximos passos (ex: se não estacionária, teste KPSS)."
                                  ],
                                  "verification": "Produzir um parágrafo interpretativo correto baseado nos resultados simulados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Exemplos de interpretação de papers acadêmicos",
                                    "Funções plot() para resíduos"
                                  ],
                                  "tips": "Sempre relate nível de significância usado (ex: 5%).",
                                  "learningObjective": "Tomar decisões baseadas em evidências estatísticas e comunicar conclusões.",
                                  "commonMistakes": [
                                    "Rejeitar H0 incorretamente invertendo lógica",
                                    "Não considerar poder do teste em amostras pequenas"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dados AirPassengers no R: execute ADF com trend e lags=12. Estatística ≈ -1.87, crítico 5% = -3.45, p=0.45 → não rejeitar H0, série não estacionária; aplique log e diff para corrigir.",
                              "finalVerifications": [
                                "Executa teste ADF/DF sem erros em dataset novo.",
                                "Extrai corretamente estatística, p-valor e críticos de MacKinnon.",
                                "Interpreta decisão sobre H0 com justificativa precisa.",
                                "Compara resultados manuais vs. automáticos.",
                                "Identifica e corrige especificação inadequada (ex: lags errados).",
                                "Gera plot de resíduos e verifica normalidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na implementação do código R (sem erros sintáticos).",
                                "Correta extração e comparação de estatísticas/valores críticos.",
                                "Interpretação lógica e alinhada com teoria (rejeição/aceitação H0).",
                                "Uso apropriado de lags e type baseado em dados.",
                                "Relatório claro com tabelas/plots explicativos.",
                                "Tratamento de edge cases (ex: amostras pequenas)."
                              ],
                              "crossCurricularConnections": [
                                "Economia: Testar estacionariedade em séries de PIB ou inflação para modelagem ARIMA.",
                                "Finanças: Análise de retornos de ações para trading algorítmico.",
                                "Engenharia: Previsão de demanda em sistemas de controle.",
                                "Biologia: Séries temporais de populações para ecologia.",
                                "Machine Learning: Pré-processamento de dados temporais antes de LSTM."
                              ],
                              "realWorldApplication": "Em bancos centrais, testar estacionariedade de taxas de juros para políticas monetárias; em empresas, prever vendas sazonais evitando modelos inválidos em séries não estacionárias."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.2.3",
                            "name": "Aplicar teste ADF com seleção de lags",
                            "description": "Usar critérios como AIC ou BIC para escolher o número ótimo de lags na regressão aumentada e realizar o teste em dados reais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e os dados para o teste ADF",
                                  "subSteps": [
                                    "Instale as bibliotecas necessárias: pandas, numpy e statsmodels via pip.",
                                    "Carregue um conjunto de dados reais de série temporal (ex: dados de PIB trimestral ou preços de ações de um CSV).",
                                    "Inspecione os dados: verifique missing values, plote a série temporal e calcule estatísticas descritivas básicas.",
                                    "Transforme os dados em um formato adequado (DataFrame com coluna de data e valor numérico).",
                                    "Teste a estacionariedade visualmente com plot de autocorrelação (ACF)."
                                  ],
                                  "verification": "Confirme que os dados estão carregados sem erros, plots exibidos corretamente e sem valores ausentes.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python 3.x",
                                    "Bibliotecas: pandas, numpy, statsmodels, matplotlib",
                                    "Dataset real (ex: dados de PIB do FRED ou Yahoo Finance)"
                                  ],
                                  "tips": "Use dados com pelo menos 100 observações para confiabilidade; padronize nomes de colunas.",
                                  "learningObjective": "Configurar ambiente computacional e preparar série temporal para análise de estacionariedade.",
                                  "commonMistakes": [
                                    "Ignorar valores missing levando a erros no teste",
                                    "Não plotar dados iniciais para inspeção visual",
                                    "Usar datasets muito curtos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar o número ótimo de lags usando critérios AIC ou BIC",
                                  "subSteps": [
                                    "Importe a função adfuller do statsmodels.tsa.stattools.",
                                    "Defina um range máximo de lags (ex: maxlags=12) baseado no tamanho da amostra.",
                                    "Use um loop para testar diferentes números de lags e calcular AIC/BIC para cada modelo AR.",
                                    "Selecione o lag com o menor valor de AIC ou BIC (prefira BIC para parcimônia).",
                                    "Registre os valores de AIC/BIC para cada lag em uma tabela para visualização."
                                  ],
                                  "verification": "Crie uma tabela mostrando lags testados, valores de AIC/BIC e o lag selecionado como ótimo.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Jupyter Notebook ou script Python",
                                    "Função statsmodels.tsa.stattools.adfuller"
                                  ],
                                  "tips": "Comece com maxlags = floor(12*(n/100)^{1/4}) pela regra de Schwert; prefira BIC para evitar sobreajuste.",
                                  "learningObjective": "Aplicar critérios de informação para seleção automática de lags em regressão aumentada.",
                                  "commonMistakes": [
                                    "Escolher lags fixos sem critério",
                                    "Confundir AIC (mais lags) com BIC (menos lags)",
                                    "Ignorar o tamanho da amostra na escolha de maxlags"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar o teste ADF com os lags selecionados",
                                  "subSteps": [
                                    "Execute adfuller(série, maxlag=lag_otimo, regression='c' ou 'ct', autolag='AIC').",
                                    "Capture os outputs: estatística do teste, p-value, valor crítico e info do modelo.",
                                    "Repita o teste com diferentes especificações (constante, tendência) se necessário.",
                                    "Salve os resultados em um dicionário ou DataFrame para comparação.",
                                    "Gere um relatório resumido dos outputs."
                                  ],
                                  "verification": "Obtenha p-value < 0.05 ou estatística mais negativa que o crítico ao 5%, confirmando rejeição de H0.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "statsmodels.tsa.stattools.adfuller",
                                    "Dataset preparado do step 1"
                                  ],
                                  "tips": "Use autolag='AIC' para automação, mas valide manualmente; teste com e sem tendência.",
                                  "learningObjective": "Realizar o teste Augmented Dickey-Fuller com lags ótimos em dados reais.",
                                  "commonMistakes": [
                                    "Usar lags errados",
                                    "Interpretar p-value incorretamente (H0 é não-estacionariedade)",
                                    "Esquecer de especificar regression"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados e validar estacionariedade",
                                  "subSteps": [
                                    "Compare a estatística ADF com valores críticos em diferentes níveis de significância.",
                                    "Decida sobre estacionariedade: rejeitar H0 se p-value < 0.05.",
                                    "Se não estacionária, sugira diferenciação e re-teste.",
                                    "Plote resíduos do modelo ADF para checar autocorrelação.",
                                    "Documente conclusões em um relatório com gráficos e tabelas."
                                  ],
                                  "verification": "Relatório final com interpretação clara: estacionária ou não, com evidências numéricas e visuais.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Gráficos de resíduos via statsmodels",
                                    "Relatório em Markdown ou PDF"
                                  ],
                                  "tips": "Sempre reporte p-value, estatística e lags usados; valide com KPSS test como complemento.",
                                  "learningObjective": "Interpretar outputs do ADF e conectar com implicações para modelagem de séries temporais.",
                                  "commonMistakes": [
                                    "Aceitar H0 sem checar poder do teste",
                                    "Não reportar todos os outputs",
                                    "Ignorar resíduos autocorrelacionados"
                                  ]
                                }
                              ],
                              "practicalExample": "Carregue dados mensais de preços de Bitcoin de 2018-2023 via yfinance. Selecione lags via BIC (ex: 4 lags ótimos), execute ADF: se p-value=0.03, conclua estacionariedade após log-retornos, útil para modelar volatilidade em trading algorítmico.",
                              "finalVerifications": [
                                "Tabela de AIC/BIC mostra lag ótimo selecionado corretamente.",
                                "Output ADF inclui estatística, p-value e valores críticos válidos.",
                                "Interpretação correta: rejeição de não-estacionariedade com evidências.",
                                "Gráficos de série, ACF e resíduos sem anomalias óbvias.",
                                "Relatório documenta passos e conclusões replicáveis.",
                                "Teste sensível a diferentes specs (c/ct) considerado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na seleção de lags (AIC/BIC minimizado corretamente).",
                                "Execução impecável do teste ADF sem erros de código.",
                                "Interpretação estatística rigorosa e sem ambiguidades.",
                                "Uso de dados reais com pelo menos 100 obs e visualizações claras.",
                                "Relatório completo com conexões teóricas (H0, poder do teste).",
                                "Tratamento de edge cases como não-estacionariedade."
                              ],
                              "crossCurricularConnections": [
                                "Econometria: Integra com testes de cointegração (Johansen).",
                                "Programação: Aplicação de loops e otimização em Python/R.",
                                "Finanças: Análise de retornos de ativos para ARIMA/GARCH.",
                                "Matemática: Estatística inferencial e critérios de informação.",
                                "Machine Learning: Pré-processamento para forecasting com LSTM."
                              ],
                              "realWorldApplication": "Em bancos centrais, usar ADF com lags ótimos para testar estacionariedade em séries de inflação ou câmbio antes de modelar ARIMA, evitando forecasts enviesados; em trading, validar retornos de ações para estratégias de mean-reversion."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.3.3",
                        "name": "Teste KPSS",
                        "description": "Teste de estacionariedade em torno de nível ou tendência, com hipótese nula de estacionariedade contra alternativa de não-estacionariedade, complementar ao Dickey-Fuller.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.3.1",
                            "name": "Formular as hipóteses do teste KPSS",
                            "description": "Definir H0: série estacionária (resíduo de regressão com variância constante) vs H1: presença de raiz unitária ou tendência aleatória.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de estacionariedade em séries temporais",
                                  "subSteps": [
                                    "Defina estacionariedade fraca: média constante, variância finita e constante, autocovariâncias que dependem apenas do lag.",
                                    "Diferencie estacionariedade ao redor de um nível constante versus tendência linear.",
                                    "Explique o impacto da não-estacionariedade: raízes unitárias levam a variância explosiva e dependência serial.",
                                    "Relacione com resíduos de regressão: variância constante nos resíduos indica estacionariedade.",
                                    "Exemplo: uma série estacionária oscila ao redor de uma média sem tendência."
                                  ],
                                  "verification": "Resuma em 3 frases os tipos de estacionariedade e forneça um exemplo de série não-estacionária.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de aula sobre séries temporais",
                                    "Gráficos de exemplos de séries estacionárias e não-estacionárias"
                                  ],
                                  "tips": "Use gráficos para visualizar: plote uma AR(1) com |φ|<1 (estacionária) vs φ=1 (não-estacionária).",
                                  "learningObjective": "Compreender os pré-requisitos conceituais para as hipóteses do KPSS.",
                                  "commonMistakes": [
                                    "Confundir estacionariedade com estacionariedade estrita",
                                    "Ignorar a distinção entre nível e tendência"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o modelo estatístico subjacente do teste KPSS",
                                  "subSteps": [
                                    "Estude o modelo: y_t = ξ_t + r_t, onde ξ_t é o componente estacionário (H0) e r_t é o aleatório caminhada (H1).",
                                    "Regressão auxiliar: regredir y_t em constante (nível) ou constante + tendência (tendência).",
                                    "Extraia resíduos e_t da regressão.",
                                    "O teste examina a estacionariedade dos resíduos e_t via estatística LM baseada em estimativa de variância de longo prazo.",
                                    "Note: KPSS testa H0 de estacionariedade nos resíduos."
                                  ],
                                  "verification": "Descreva o modelo y_t e a regressão auxiliar em notação matemática.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Artigo original KPSS (1992)",
                                    "Software R/Python para simular o modelo"
                                  ],
                                  "tips": "Implemente uma regressão simples em R: lm(y ~ 1) e extraia residuals.",
                                  "learningObjective": "Dominar o framework matemático que define as hipóteses.",
                                  "commonMistakes": [
                                    "Confundir resíduos com a série original",
                                    "Esquecer a regressão auxiliar"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular a hipótese nula (H0) do teste KPSS",
                                  "subSteps": [
                                    "Defina H0: a série (ou resíduos) é estacionária ao redor de um nível constante ou tendência determinística.",
                                    "Especifique: variância dos resíduos constante, sem raiz unitária.",
                                    "Notação: H0: γ = 0 em ξ_t = γ * random walk + estacionário.",
                                    "Para teste de nível: H0: estacionária em nível.",
                                    "Para teste de tendência: H0: estacionária ao redor de tendência."
                                  ],
                                  "verification": "Escreva H0 em palavras e notação formal para ambos os casos (nível e tendência).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela comparativa KPSS vs ADF",
                                    "Folha de fórmulas de testes de unit root"
                                  ],
                                  "tips": "Lembre: KPSS inverte ADF; H0 é estacionariedade aqui.",
                                  "learningObjective": "Articular precisamente a H0 como estacionariedade dos resíduos.",
                                  "commonMistakes": [
                                    "Invertir com ADF (H0 não-estacionária no ADF)",
                                    "Omitir 'resíduos de regressão'"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formular a hipótese alternativa (H1) e contrastar com H0",
                                  "subSteps": [
                                    "Defina H1: presença de raiz unitária ou tendência estocástica nos resíduos.",
                                    "Notação: H1: γ > 0, implicando não-estacionariedade.",
                                    "Compare: rejeitar H0 significa não-estacionária (diferente de ADF).",
                                    "Discuta implicações: H1 leva a variância crescente com tempo.",
                                    "Pratique escrevendo o par H0 vs H1 completo."
                                  ],
                                  "verification": "Formule o par completo de hipóteses e explique a diferença com teste ADF.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Exemplos de output de kpps.test() no R",
                                    "Quiz online sobre testes de unit root"
                                  ],
                                  "tips": "Use mnemônico: KPSS 'Keeps' H0 como estacionária.",
                                  "learningObjective": "Formular H1 corretamente e entender o contraste.",
                                  "commonMistakes": [
                                    "Definir H1 como estacionária",
                                    "Confundir tendência determinística com estocástica"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e refinar a formulação das hipóteses",
                                  "subSteps": [
                                    "Revise H0: 'Os resíduos da regressão têm variância constante (estacionários)'.",
                                    "Revise H1: 'Resíduos possuem raiz unitária ou tendência aleatória'.",
                                    "Teste com exemplo: para PIB, H0 vs H1.",
                                    "Compare com literatura padrão (ex: Hamilton's Time Series).",
                                    "Autoavalie: hipóteses invertidas corretamente vs outros testes?"
                                  ],
                                  "verification": "Escreva as hipóteses finais e justifique com referência ao modelo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Livro 'Time Series Analysis' de Hamilton",
                                    "Resumo de testes de estacionariedade"
                                  ],
                                  "tips": "Sempre especifique o tipo: nível ou tendência.",
                                  "learningObjective": "Garantir formulação precisa e livre de erros.",
                                  "commonMistakes": [
                                    "Não especificar resíduos",
                                    "Ignorar variantes do teste"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma série de preços de ações diários (y_t), regresse em constante: y_t = α + e_t. H0: e_t estacionários (variância constante). H1: e_t com raiz unitária (preços têm caminhada aleatória, comum em finanças). Use R: library(tseries); kpss(residuals(lm(returns ~ 1))).",
                              "finalVerifications": [
                                "H0 corretamente definida como 'série/resíduos estacionários com variância constante'.",
                                "H1 inclui 'raiz unitária ou tendência aleatória'.",
                                "Referência aos resíduos da regressão auxiliar incluída.",
                                "Diferença com ADF explicitada (H0 invertida).",
                                "Variantes (nível vs tendência) distinguidas.",
                                "Notação matemática ou verbal precisa."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: 30% (definições corretas de H0/H1).",
                                "Completude: 25% (inclui resíduos, variantes do teste).",
                                "Clareza na formulação: 20% (linguagem formal e concisa).",
                                "Contraste com outros testes: 15% (ex: ADF).",
                                "Exemplo prático: 10% (aplicação coerente)."
                              ],
                              "crossCurricularConnections": [
                                "Econometria: Complementa testes ADF/PP para unit roots.",
                                "Finanças: Análise de retornos de ativos (estacionariedade).",
                                "Economia: Modelagem de PIB, inflação (previsão).",
                                "Matemática: Estatística de processos estocásticos.",
                                "Ciência de Dados: Pré-processamento em ML para séries temporais."
                              ],
                              "realWorldApplication": "Em bancos centrais, formular H0/H1 no KPSS testa se inflação é estacionária para políticas monetárias; rejeição H0 indica necessidade de diferenciação antes de modelar ARIMA."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.3.2",
                            "name": "Implementar e interpretar o teste KPSS",
                            "description": "Executar o teste em R ou Python, analisando a estatística LM comparada a valores críticos e usando em conjunto com DF para confirmação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente de programação e os dados da série temporal",
                                  "subSteps": [
                                    "Instale as bibliotecas necessárias: em Python, use pip install statsmodels pandas numpy; em R, instale urca e tseries.",
                                    "Carregue um conjunto de dados de série temporal de exemplo, como dados de PIB trimestral ou preços de ações (ex: AirPassengers em R ou fetch de Yahoo Finance em Python).",
                                    "Verifique e limpe os dados: remova NAs, converta para formato de série temporal (ts em R ou DatetimeIndex em Python).",
                                    "Plote a série para visual inspeção inicial de estacionariedade.",
                                    "Defina parâmetros do teste: tipo='Level' ou 'Trend' dependendo da suspeita de tendência."
                                  ],
                                  "verification": "Ambiente pronto se o código roda sem erros e o gráfico da série é exibido corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python: Jupyter Notebook, statsmodels, pandas, numpy; R: RStudio, pacotes urca, tseries; Dados sample: AirPassengers ou yfinance"
                                  ],
                                  "tips": "Sempre use seed para reprodutibilidade em simulações; comece com dados reais para motivação.",
                                  "learningObjective": "Configurar corretamente o ambiente e preparar dados válidos para testes de séries temporais.",
                                  "commonMistakes": [
                                    "Esquecer de instalar pacotes",
                                    "Não tratar missing values",
                                    "Ignorar frequência da série temporal"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a execução do teste KPSS em R ou Python",
                                  "subSteps": [
                                    "Em Python: use statsmodels.tsa.stattools.kpss(data, regression='c' ou 'ct', nlags='auto').",
                                    "Em R: use urca::kpss.test(data, null='Level' ou 'Trend', lshort=TRUE).",
                                    "Extraia os outputs chave: estatística LM (test statistic), p-value, lags usados.",
                                    "Salve os resultados em variáveis para análise posterior.",
                                    "Execute o teste em diferentes configurações (Level vs Trend) para comparação."
                                  ],
                                  "verification": "Teste executado com sucesso, exibindo estatística LM, p-value e valores críticos sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Código pronto: exemplos de statsmodels.kpss ou urca::kpss.test; Dados preparados do Step 1"
                                  ],
                                  "tips": "Use nlags='auto' para evitar under/over-fitting; teste em subamostras para robustez.",
                                  "learningObjective": "Executar o teste KPSS corretamente em pelo menos uma linguagem, obtendo todos os outputs necessários.",
                                  "commonMistakes": [
                                    "Confundir parâmetros de regression/null hypothesis",
                                    "Usar lags fixos inadequados",
                                    "Não capturar todos os outputs"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar os resultados do teste KPSS",
                                  "subSteps": [
                                    "Compare a estatística LM com valores críticos (1%, 5%, 10%) ou use p-value (>0.05 rejeita H0 de estacionariedade?).",
                                    "Decida: se LM > crítico ou p-value <0.05, rejeite estacionariedade (série não-estacionária).",
                                    "Analise o tipo de não-estacionariedade (Level ou Trend) baseado na configuração.",
                                    "Documente a interpretação em um relatório curto: 'Estatística LM=1.23 > crítico 5%=0.46 → não estacionária'.",
                                    "Visualize resíduos ou ACF para suporte qualitativo."
                                  ],
                                  "verification": "Interpretação escrita correta, alinhada com regras de decisão do KPSS.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Outputs do Step 2; Tabela de valores críticos KPSS (buscar em literatura ou pacotes)"
                                  ],
                                  "tips": "Lembre: H0 é estacionariedade (oposto ao ADF); p-value baixo indica problema.",
                                  "learningObjective": "Interpretar estatística LM, p-value e críticos para concluir sobre estacionariedade.",
                                  "commonMistakes": [
                                    "Confundir H0 com ADF (KPSS H0=estacionária)",
                                    "Ignorar p-value vs críticos",
                                    "Não considerar tamanho da amostra"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar com teste Dickey-Fuller (DF) e formular conclusão final",
                                  "subSteps": [
                                    "Execute teste DF (ADF em Python/R) na mesma série para comparação.",
                                    "Compare resultados: KPSS e DF concordam? (ex: ambos rejeitam → confirma não-estacionária).",
                                    "Se discordância, analise tamanho da amostra ou poder do teste.",
                                    "Conclua sobre estacionariedade e sugira próximos passos (diferenciação se necessário).",
                                    "Gere um relatório integrado com plots e tabelas."
                                  ],
                                  "verification": "Relatório final com comparação DF-KPSS e recomendação clara.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código ADF: statsmodels.tsa.stattools.adfuller ou urca::adf.test; Outputs anteriores"
                                  ],
                                  "tips": "Use ambos testes complementares; DF bom para unit root, KPSS para level/trend estacionariedade.",
                                  "learningObjective": "Usar KPSS em conjunto com DF para robusta confirmação de estacionariedade.",
                                  "commonMistakes": [
                                    "Não executar DF",
                                    "Ignorar discordâncias sem análise",
                                    "Concluir prematuramente"
                                  ]
                                }
                              ],
                              "practicalExample": "Aplique o teste KPSS aos dados AirPassengers (R) ou preços diários de AAPL (Python via yfinance). Execute em configuração 'Level': obtenha LM=0.74, p=0.01 → rejeite estacionariedade, confirme com ADF (p=0.99), conclua necessidade de diferenciação para modelagem ARIMA.",
                              "finalVerifications": [
                                "Código roda sem erros em R/Python produzindo outputs KPSS completos.",
                                "Interpretação correta: LM vs críticos/p-value leva à decisão certa.",
                                "Comparação com DF feita e explicada.",
                                "Relatório escrito resume resultados e implicações.",
                                "Gráficos de série original e resíduos incluídos.",
                                "Teste sensível a parâmetros (lags, type) demonstrado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na implementação (outputs corretos: 30%)",
                                "Interpretação estatística rigorosa (35%)",
                                "Integração com DF e análise de robustez (20%)",
                                "Clareza do relatório e visualizações (10%)",
                                "Tratamento de edge cases (lags, tamanho amostra: 5%)"
                              ],
                              "crossCurricularConnections": [
                                "Economia: Testar estacionariedade em séries macroeconômicas como PIB ou inflação para forecasting.",
                                "Finanças: Análise de retornos de ativos para modelos GARCH ou Value-at-Risk.",
                                "Engenharia: Monitoramento de sinais em controle de processos industriais.",
                                "Ciência de Dados: Pré-processamento para ML em previsão de demanda."
                              ],
                              "realWorldApplication": "Em finanças, use KPSS para validar estacionariedade de retornos de ações antes de modelar volatilidade; em marketing, teste séries de vendas para campanhas sazonais, evitando forecasts enviesados por não-estacionariedade."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.3.3",
                            "name": "Comparar resultados de DF e KPSS",
                            "description": "Interpretar combinações de resultados dos dois testes para classificar a série como estacionária, com tendência ou não-estacionária.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Hipóteses Nulas e Alternativas dos Testes DF e KPSS",
                                  "subSteps": [
                                    "Estude a hipótese nula (H0) do teste Dickey-Fuller (DF): presença de raiz unitária (não-estacionária).",
                                    "Identifique a hipótese alternativa (HA) do DF: série estacionária em níveis.",
                                    "Analise a H0 do teste KPSS: série estacionária em níveis (sem tendência).",
                                    "Compare com HA do KPSS: presença de tendência ou não-estacionariedade.",
                                    "Anote as diferenças complementares entre os testes em um quadro comparativo."
                                  ],
                                  "verification": "Crie um quadro resumindo H0 e HA de ambos os testes e explique verbalmente as diferenças.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação dos testes DF e KPSS (ex: help(ur.df) no R ou statsmodels no Python)",
                                    "Papel e caneta ou editor de texto"
                                  ],
                                  "tips": "Lembre-se: DF e KPSS são complementares; rejeitar H0 em um e não no outro fornece evidência clara.",
                                  "learningObjective": "Compreender as diferenças fundamentais nas hipóteses para evitar confusões na interpretação.",
                                  "commonMistakes": [
                                    "Confundir H0 do DF com KPSS",
                                    "Ignorar variantes do KPSS (com ou sem tendência)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Interpretar Resultados Individuais de Cada Teste",
                                  "subSteps": [
                                    "Execute o teste DF em uma série temporal de exemplo e identifique p-value e estatística do teste.",
                                    "Determine se rejeita H0 do DF (p < 0.05 indica estacionariedade).",
                                    "Execute o teste KPSS e interprete: não rejeitar H0 (p > 0.05) indica estacionariedade.",
                                    "Registre os resultados em uma tabela: Teste | Estatística | p-value | Decisão.",
                                    "Pratique com diferentes níveis de significância (1%, 5%, 10%)."
                                  ],
                                  "verification": "Gere outputs de ambos os testes e classifique corretamente a decisão para cada um isoladamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software R (pacotes urca, tseries) ou Python (statsmodels.tsa)",
                                    "Dataset de série temporal exemplo (ex: AirPassengers)"
                                  ],
                                  "tips": "Sempre verifique suposições como lag selection; use AIC/BIC para lags automáticos.",
                                  "learningObjective": "Interpretar p-values e decisões individuais para preparar comparação.",
                                  "commonMistakes": [
                                    "Interpretar estatística bruta sem p-value",
                                    "Usar limiares errados para rejeição"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir e Aplicar Tabela de Decisão para Combinações",
                                  "subSteps": [
                                    "Crie uma tabela 2x2: linhas para DF (rejeita/não rejeita H0), colunas para KPSS.",
                                    "Preencha: DF rejeita + KPSS não rejeita = Estacionária; DF não + KPSS rejeita = Não-estacionária; ambos rejeitam = Tendência; ambos não = Inconclusivo.",
                                    "Aplique a tabela a resultados de exemplo: registre combinações e classificações.",
                                    "Teste com 3 séries diferentes (estacionária, tendência, não-estacionária).",
                                    "Documente conclusões em um relatório curto."
                                  ],
                                  "verification": "Classifique corretamente 3 exemplos usando a tabela sem erros.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Planilha Excel/Google Sheets para tabela",
                                    "Códigos R/Python prontos para testes",
                                    "Datasets variados (ex: sunspots, Nile)"
                                  ],
                                  "tips": "Priorize combinações discordantes para resolução; use gráficos ACF/PACF como suporte.",
                                  "learningObjective": "Dominar regras de combinação para classificação precisa da série.",
                                  "commonMistakes": [
                                    "Ignorar caso inconclusivo",
                                    "Confundir 'tendência' com 'drift'"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar Classificação com Diagnósticos Adicionais",
                                  "subSteps": [
                                    "Plote a série e resíduos dos testes para visual inspeção.",
                                    "Verifique autocorrelação nos resíduos (Ljung-Box test).",
                                    "Compare com testes alternativos (ex: ADF vs DF).",
                                    "Ajuste modelo ARIMA baseado na classificação e verifique resíduos.",
                                    "Conclua com confiança na classificação final."
                                  ],
                                  "verification": "Produza relatório com gráficos e testes confirmando a classificação da tabela.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Bibliotecas de plotagem (ggplot2 no R, matplotlib no Python)",
                                    "Códigos para diagnósticos adicionais"
                                  ],
                                  "tips": "Gráficos são cruciais; tendência linear vs estocástica diferencia classificações.",
                                  "learningObjective": "Reforçar classificação com evidências visuais e testes complementares.",
                                  "commonMistakes": [
                                    "Confiar só em p-values sem plots",
                                    "Não testar resíduos"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dados AirPassengers no R: DF p=0.99 (não rejeita H0, sugere não-estacionária), KPSS p=0.01 (rejeita H0, confirma não-estacionária). Classificação: Não-estacionária. Diferença com log(AirPassengers): ambos indicam estacionária após transformação.",
                              "finalVerifications": [
                                "Explica corretamente H0/HA de DF e KPSS sem erros.",
                                "Classifica 4 combinações de resultados usando tabela.",
                                "Aplica testes a novo dataset e conclui adequadamente.",
                                "Identifica e corrige erros comuns em interpretações.",
                                "Produz relatório com plots confirmando classificação.",
                                "Discute limitações dos testes (ex: tamanho de amostra)"
                              ],
                              "assessmentCriteria": [
                                "Precisão na tabela de decisão (100% correto).",
                                "Profundidade de sub-steps executados (mínimo 4 por step).",
                                "Uso correto de software e interpretação de outputs.",
                                "Inclusão de verificações visuais e diagnósticos.",
                                "Clareza no relatório final com exemplos concretos.",
                                "Identificação de pelo menos 2 erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Econometria: Testes para modelagem VAR/ARIMA em previsão econômica.",
                                "Finanças: Análise de retornos de ações para trading algorítmico.",
                                "Engenharia: Monitoramento de sinais em controle de processos.",
                                "Ciência de Dados: Pré-processamento para ML em séries temporais."
                              ],
                              "realWorldApplication": "Em bancos centrais, comparar DF/KPSS classifica inflação como estacionária para políticas monetárias estáveis; em empresas de varejo, detecta tendências sazonais em vendas para estoque otimizado."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.4",
                    "name": "Modelos ARMA para Séries Estacionárias",
                    "description": "Modelos Autorregressivo (AR), Média Móvel (MA) e ARMA, incluindo identificação, estimação e diagnóstico.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.4.1",
                        "name": "Modelo Autorregressivo (AR)",
                        "description": "Os modelos AR(p) representam uma série temporal estacionária como uma regressão linear de seus próprios valores defasados, úteis para capturar dependências seriais persistentes em dados estacionários.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.1.1",
                            "name": "Definir notação e equação do modelo AR(p)",
                            "description": "Explicar a equação geral do modelo AR(p): Y_t = c + φ_1 Y_{t-1} + ... + φ_p Y_{t-p} + ε_t, incluindo interpretação dos coeficientes φ_i e do termo de erro ε_t ~ WN(0, σ²).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a notação básica de séries temporais",
                                  "subSteps": [
                                    "Defina Y_t como o valor da série temporal no tempo t.",
                                    "Explique o conceito de lag: Y_{t-1} é o valor no tempo anterior, Y_{t-p} no p-ésimo lag.",
                                    "Discuta o índice temporal t como discreto (ex.: dias, meses).",
                                    "Identifique c como constante (intercepto) e ε_t como erro.",
                                    "Revise white noise (WN): média zero, variância σ², não correlacionado."
                                  ],
                                  "verification": "Escreva definições corretas para Y_t, Y_{t-p} e ε_t em um papel.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use subscritos para lags claramente, como Y_{t-1}, para evitar confusão visual.",
                                  "learningObjective": "Dominar símbolos e conceitos fundamentais da notação AR(p).",
                                  "commonMistakes": [
                                    "Confundir Y_t com parâmetro φ",
                                    "Ignorar que t é discreto",
                                    "Esquecer independência dos erros"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a equação geral do modelo AR(p)",
                                  "subSteps": [
                                    "Comece com AR(1): Y_t = c + φ_1 Y_{t-1} + ε_t.",
                                    "Expanda para AR(2): Y_t = c + φ_1 Y_{t-1} + φ_2 Y_{t-2} + ε_t.",
                                    "Generalize para AR(p): Y_t = c + ∑_{i=1}^p φ_i Y_{t-i} + ε_t.",
                                    "Escreva a soma em notação sigma: Y_t = c + φ_1 Y_{t-1} + ... + φ_p Y_{t-p} + ε_t.",
                                    "Pratique escrevendo para p=3."
                                  ],
                                  "verification": "Escreva a equação AR(p) corretamente para p=1,2 e geral.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplos de séries temporais impressos"
                                  ],
                                  "tips": "Use setas para mostrar dependência: Y_t ← Y_{t-1}, etc., para visualizar regressão.",
                                  "learningObjective": "Construir e escrever a forma matemática exata do modelo AR(p).",
                                  "commonMistakes": [
                                    "Esquecer a constante c",
                                    "Usar φ_0 em vez de c",
                                    "Confundir ordem p com número de termos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar os coeficientes φ_i",
                                  "subSteps": [
                                    "Explique φ_i como peso do lag i: impacto de Y_{t-i} em Y_t.",
                                    "Discuta estacionariedade: |φ_1| < 1 para AR(1); raízes da polinômio característica fora do círculo unitário para AR(p).",
                                    "Interprete sinal: φ_i > 0 indica persistência positiva; <0 oscilação.",
                                    "Exemplo: φ_1=0.8 significa 80% da previsão vem do passado imediato.",
                                    "Verifique soma de φ_i <1 para não explosão."
                                  ],
                                  "verification": "Para AR(1) com φ_1=0.5, explique o que significa em palavras.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráfico de autocorrelação",
                                    "Calculadora para raízes"
                                  ],
                                  "tips": "Pense em φ_i como coeficientes de regressão linear em Y passado.",
                                  "learningObjective": "Compreender o significado econômico/estatístico dos parâmetros φ_i.",
                                  "commonMistakes": [
                                    "Ignorar condição de estacionariedade",
                                    "Confundir φ_i com variância",
                                    "Achar que φ_i é probabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar o termo de erro ε_t e resumir o modelo",
                                  "subSteps": [
                                    "Defina ε_t ~ WN(0, σ²): E(ε_t)=0, Var(ε_t)=σ², Cov(ε_t, ε_s)=0 para t≠s.",
                                    "Explique papel: captura choques aleatórios não explicados pelo passado.",
                                    "Discuta independência: erros não correlacionados com Y passado.",
                                    "Resuma equação completa: componentes determinísticos (c + φ's) + estocástico (ε_t).",
                                    "Escreva notação final com todas interpretações."
                                  ],
                                  "verification": "Descreva propriedades de ε_t e role no modelo em 3 frases.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel para resumo final",
                                    "Referência de livro de séries temporais"
                                  ],
                                  "tips": "Compare ε_t a resíduos em regressão linear comum.",
                                  "learningObjective": "Integrar todos elementos e interpretar o erro adequadamente.",
                                  "commonMistakes": [
                                    "Achar ε_t determinístico",
                                    "Confundir WN com normalidade",
                                    "Esquecer variância σ²"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere temperaturas diárias em uma cidade: Y_t = 10 + 0.7 Y_{t-1} + 0.2 Y_{t-2} + ε_t. Aqui, φ_1=0.7 indica forte influência do dia anterior, φ_2=0.2 do anterior a ele, c=10 ajusta média sazonal, e ε_t captura variações climáticas imprevisíveis.",
                              "finalVerifications": [
                                "Escreve corretamente a equação AR(p) com notação padrão.",
                                "Interpreta φ_i como coeficientes de lag com exemplo numérico.",
                                "Descreve ε_t ~ WN(0, σ²) incluindo independência.",
                                "Explica papel da constante c no modelo.",
                                "Identifica condições básicas para estacionariedade em AR(1).",
                                "Resume o modelo em uma frase coesa."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação matemática (fórmula exata).",
                                "Correta interpretação de φ_i (peso e sinal).",
                                "Compreensão completa de propriedades do erro ε_t.",
                                "Uso apropriado de soma sigma para generalização.",
                                "Capacidade de aplicar a um exemplo simples.",
                                "Identificação de erros comuns como confundir AR com MA."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (vetores de lags) e polinômios característicos.",
                                "Economia: Modelagem de séries como PIB ou inflação para previsão.",
                                "Programação: Implementação em R (arima) ou Python (statsmodels).",
                                "Física: Modelos de osciladores amortecidos semelhantes a AR(p).",
                                "Engenharia: Controle de processos com feedback autoregressivo."
                              ],
                              "realWorldApplication": "Em finanças, modelos AR(p) preveem retornos de ações baseados em histórico (ex.: S&P 500), auxiliando traders a detectar padrões persistentes e choques de mercado via ε_t."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.1.2",
                            "name": "Determinar condições de estacionariedade",
                            "description": "Derivar as raízes da equação característica φ(z) = 1 - φ_1 z - ... - φ_p z^p = 0 e verificar que todas as raízes estão fora do círculo unitário (|z| > 1) para garantir estacionariedade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular a Equação Característica do Modelo AR(p)",
                                  "subSteps": [
                                    "Escrever a forma geral do modelo AR(p): y_t = φ₁ y_{t-1} + φ₂ y_{t-2} + ... + φ_p y_{t-p} + ε_t",
                                    "Derivar a equação característica movendo termos para um lado: φ(z) = 1 - φ₁ z - φ₂ z² - ... - φ_p z^p = 0",
                                    "Identificar e listar os coeficientes φ₁ até φ_p a partir do modelo especificado",
                                    "Confirmar que o polinômio é monico (coeficiente de z^0 = 1) e os sinais negativos nos termos φ z^k",
                                    "Anotar o grau p do polinômio"
                                  ],
                                  "verification": "A equação φ(z) = 0 está corretamente escrita e corresponde aos coeficientes do modelo AR(p).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Referência ao modelo AR(p) com coeficientes φ"
                                  ],
                                  "tips": [
                                    "Sempre comece com o operador de atraso B para formalizar: φ(B) y_t = ε_t leva a φ(z)=0."
                                  ],
                                  "learningObjective": "Compreender a derivação da equação característica a partir da definição do modelo AR(p).",
                                  "commonMistakes": [
                                    "Confundir os sinais dos coeficientes (esquecer o negativo)",
                                    "Escrever φ(z) = z^p - φ₁ z^{p-1} - ... em vez da forma padrão"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular as Raízes da Equação Característica",
                                  "subSteps": [
                                    "Para p=1: resolver z = 1/φ₁ analiticamente",
                                    "Para p=2: usar fórmula quadrática z = [φ₁ ± sqrt(φ₁² + 4 φ₂)] / (2 φ₂)",
                                    "Para p>2: implementar função numérica como np.roots([1, -φ₁, -φ₂, ..., -φ_p]) no Python ou polyroot() no R",
                                    "Listar todas as raízes complexas z₁, z₂, ..., z_p com precisão de pelo menos 4 casas decimais",
                                    "Verificar numericamente substituindo uma raiz na φ(z) para confirmar ≈0"
                                  ],
                                  "verification": "Raízes calculadas corretamente; φ(z_i) ≈ 0 para cada raiz z_i.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com numpy ou R com base",
                                    "Calculadora para casos simples (p≤2)"
                                  ],
                                  "tips": [
                                    "Raízes vêm em pares conjugados se coeficientes reais; use funções que retornam complexos"
                                  ],
                                  "learningObjective": "Dominar métodos analíticos e numéricos para encontrar raízes de polinômios associados a AR(p).",
                                  "commonMistakes": [
                                    "Usar ordem errada dos coeficientes no polyroots (deve ser [1, -φ1, -φ2,...])",
                                    "Ignorar raízes complexas ou arredondamentos que levam a erro"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar os Módulos das Raízes e a Condição de Estacionariedade",
                                  "subSteps": [
                                    "Para cada raiz z_i = a + bi, calcular |z_i| = sqrt(a² + b²)",
                                    "Criar uma tabela: raiz z_i | módulo |z_i| > 1?",
                                    "Identificar se QUALQUER |z_i| ≤ 1 (incluindo =1 ou <1)",
                                    "Confirmar que TODAS as raízes satisfazem |z_i| > 1",
                                    "Calcular o módulo mínimo min(|z_i|) para análise de estabilidade"
                                  ],
                                  "verification": "Tabela completa com módulos calculados e condição booleana para todas as raízes.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python/R para abs() ou cabs() em complexos",
                                    "Planilha (Excel) para tabela simples"
                                  ],
                                  "tips": [
                                    "O círculo unitário é |z|=1; raízes dentro levam a não-estacionariedade"
                                  ],
                                  "learningObjective": "Aplicar a condição espectral de estacionariedade usando módulos no plano complexo.",
                                  "commonMistakes": [
                                    "Calcular 1/|z| em vez de |z|",
                                    "Confundir |z|>1 (fora) com |z|<1 (dentro, instável)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Resultados e Concluir Estacionariedade",
                                  "subSteps": [
                                    "Se todas |z_i| > 1: concluir 'Modelo AR(p) é estacionário'",
                                    "Se qualquer |z_i| ≤ 1: concluir 'Não estacionário' e sugerir restrições nos φ (ex: φ1 + φ2 <1 para AR(2))",
                                    "Opcionalmente, plotar raízes no plano complexo com círculo unitário",
                                    "Discutir implicações: ACF decaí exponential se estacionário",
                                    "Documentar relatório final com equação, raízes, módulos e conclusão"
                                  ],
                                  "verification": "Relatório escrito com conclusão justificada e evidências numéricas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python matplotlib ou R ggplot2 para plot",
                                    "Template de relatório"
                                  ],
                                  "tips": [
                                    "Plots ajudam a visualizar: raízes fora do círculo confirmam visualmente"
                                  ],
                                  "learningObjective": "Interpretar condições de estacionariedade no contexto de análise de séries temporais.",
                                  "commonMistakes": [
                                    "Concluir estacionariedade sem checar todas raízes",
                                    "Ignorar multiplicidade de raízes (raiz dupla conta duas vezes)"
                                  ]
                                }
                              ],
                              "practicalExample": "Para AR(2) com φ₁=0.6, φ₂=0.3: φ(z)=1 - 0.6z - 0.3z²=0. Raízes (numpy.roots([-0.3,-0.6,1])): z≈[-1.81, 1.84]. Módulos: 1.81 e 1.84, ambos >1 → estacionário. Se φ₂=0.8: raízes ≈[0.75, -1.33], |0.75|<1 → não estacionário.",
                              "finalVerifications": [
                                "Equação característica derivada corretamente dos coeficientes φ.",
                                "Todas raízes calculadas com φ(z_i)≈0.",
                                "Módulos |z_i| computados precisamente para cada raiz.",
                                "Condição |z_i|>1 verificada para todas as raízes.",
                                "Conclusão de estacionariedade justificada com evidências.",
                                "Opcional: plot das raízes fora do círculo unitário."
                              ],
                              "assessmentCriteria": [
                                "Correção na formulação da equação φ(z) (20%).",
                                "Precisão no cálculo das raízes (30%).",
                                "Aplicação exata da condição |z|>1 (20%).",
                                "Interpretação clara e relatório completo (20%).",
                                "Uso eficiente de ferramentas computacionais (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: autovalores de matrizes companheiras equivalentes às raízes.",
                                "Análise Complexa: domínio do plano complexo e módulo euclidiano.",
                                "Programação: bibliotecas numéricas para polinômios (numpy.polyroots).",
                                "Econometria: verificação de modelos em séries financeiras.",
                                "Visualização de Dados: gráficos polares ou Argand para raízes."
                              ],
                              "realWorldApplication": "Em previsão de vendas ou retornos de ações, verificar estacionariedade de um AR(p) garante que o modelo não explode (divergência), permitindo forecasts confiáveis em ferramentas como R's arima() ou Python's statsmodels."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.1.3",
                            "name": "Interpretar ACF e PACF para AR(p)",
                            "description": "Analisar o decaimento exponencial da ACF e o corte abrupto após lag p na PACF para identificar a ordem p em gráficos de autocorrelação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de ACF e PACF",
                                  "subSteps": [
                                    "Defina ACF como a correlação serial em diferentes lags para uma série temporal estacionária.",
                                    "Defina PACF como a correlação parcial após remover efeitos de lags anteriores.",
                                    "Explique a diferença: ACF inclui todos os lags anteriores, PACF isola o lag específico.",
                                    "Revise fórmulas básicas: ACF(ρ_k) = Cov(y_t, y_{t-k}) / Var(y_t).",
                                    "Discuta importância para identificação de modelos ARMA."
                                  ],
                                  "verification": "Resuma em suas palavras as diferenças entre ACF e PACF e forneça um exemplo simples.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Documentação de séries temporais (ex: Hyndman livro online)",
                                    "Notebook Jupyter com funções ACF/PACF em Python (statsmodels)"
                                  ],
                                  "tips": "Use diagramas visuais para diferenciar ACF (todas as barras decrescendo) vs PACF (barra específica isolada).",
                                  "learningObjective": "Compreender as definições e propósitos de ACF e PACF em séries temporais.",
                                  "commonMistakes": [
                                    "Confundir ACF com PACF; achar que ambas medem correlação direta sem ajustes."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Padrão da ACF em Modelos AR(p)",
                                  "subSteps": [
                                    "Observe que em AR(p), ACF exibe decaimento exponencial ou senoidal após lag 0.",
                                    "Identifique lags iniciais significativos (geralmente até p), depois decaimento suave para zero.",
                                    "Compare com MA(q): MA tem corte abrupto na ACF após q, diferente de AR.",
                                    "Plote ACF de uma simulação AR(1) e AR(2) para visualizar o decaimento.",
                                    "Quantifique: barras devem cair gradualmente, não cortar abruptamente."
                                  ],
                                  "verification": "Desenhe ou descreva o gráfico ACF esperado para AR(2) e explique o decaimento.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Python/R com pacotes statsmodels ou forecast",
                                    "Dados simulados AR(p) via arima_sim() ou similar"
                                  ],
                                  "tips": "Foquem em confiança intervals (95%): barras dentro indicam insignificância.",
                                  "learningObjective": "Reconhecer o padrão de decaimento exponencial da ACF como indício de componente AR.",
                                  "commonMistakes": [
                                    "Interpretar decaimento lento como MA; ignorar intervalos de confiança."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Padrão da PACF em Modelos AR(p)",
                                  "subSteps": [
                                    "Identifique que PACF em AR(p) é significativa até lag p, depois corta abruptamente para zero.",
                                    "Para AR(1): apenas lag 1 significativo; AR(2): lags 1 e 2 significativos, resto zero.",
                                    "Compare com ARMA: PACF decairia em modelos mistos.",
                                    "Gere gráficos PACF de simulações AR(p) e marque o ponto de corte.",
                                    "Confirme com teoria: coeficientes parciais φ_k = 0 para k > p."
                                  ],
                                  "verification": "Para um gráfico PACF dado, indique o lag p onde ocorre o corte abrupto.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Gráficos de PACF de exemplos AR(1), AR(2), AR(3)",
                                    "Software para plot_acf e plot_pacf"
                                  ],
                                  "tips": "Procure o 'corte' após p lags: barras subsequentes dentro da zona azul (insignificantes).",
                                  "learningObjective": "Identificar o corte abrupto na PACF para determinar a ordem p do modelo AR.",
                                  "commonMistakes": [
                                    "Confundir corte na PACF com decaimento na ACF; superestimar p por ruído."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Interpretação Conjunta de ACF e PACF para Identificar AR(p)",
                                  "subSteps": [
                                    "Combine padrões: ACF decaimento exponencial + PACF corte após p = AR(p).",
                                    "Analise 3-5 gráficos reais/simulados: estime p e justifique.",
                                    "Teste ajustando modelo AR(p) e verifique resíduos (ACF/PACF brancos).",
                                    "Registre observações: 'ACF decai exponencialmente; PACF corta em lag 2 → AR(2)'.",
                                    "Discuta ambiguidades: se ambos decaem, considerar ARMA."
                                  ],
                                  "verification": "Interprete um gráfico novo e proponha ordem p com justificativa escrita.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Conjunto de gráficos ACF/PACF de séries AR variadas",
                                    "Ambiente Python/R para ajuste ARIMA"
                                  ],
                                  "tips": "Sempre valide com AIC/BIC após ajuste para confirmar p.",
                                  "learningObjective": "Integrar ACF e PACF para diagnosticar com precisão a ordem p em AR(p).",
                                  "commonMistakes": [
                                    "Focar só em um gráfico; ignorar não-estacionaridade prévia."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma série temporal de temperaturas diárias simulada como AR(2): φ1=0.6, φ2=0.3. O gráfico ACF mostra decaimento exponencial lento após lag 0 (lags 1-2 significativos, depois diminuindo). A PACF tem barras significativas em lag 1 e 2, cortando abruptamente para zero em lags >2. Conclusão: ordem p=2, pois PACF indica AR(2) claramente.",
                              "finalVerifications": [
                                "Descreve corretamente o decaimento exponencial na ACF para AR(p).",
                                "Identifica o corte abrupto na PACF após lag p.",
                                "Diferencia padrões AR de MA usando ambos os gráficos.",
                                "Aplica a interpretação a um gráfico novo com precisão.",
                                "Explica por que a combinação ACF+PACF é usada para identificação.",
                                "Valida com ajuste de modelo (resíduos sem autocorrelação)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de padrões ACF/PACF (90%+ correto).",
                                "Justificativa lógica para ordem p identificada.",
                                "Uso correto de intervalos de confiança nos gráficos.",
                                "Diferenciação clara entre AR(p), MA(q) e ARMA.",
                                "Capacidade de aplicar em exemplos variados sem erros comuns.",
                                "Clareza na comunicação da interpretação."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python (statsmodels.tsa.stattools.acf/pacf).",
                                "Economia: Identificação de modelos para previsão de PIB ou inflação.",
                                "Matemática: Equações de Yule-Walker para soluções AR(p).",
                                "Machine Learning: Pré-processamento de features em séries temporais.",
                                "Física: Modelagem de oscilações amortecidas em sistemas dinâmicos."
                              ],
                              "realWorldApplication": "Em finanças, interpretar ACF/PACF de retornos de ações para ajustar AR(p) e prever volatilidade futura; em meteorologia, modelar temperaturas para alertas climáticos; em supply chain, prever demanda de produtos com padrões sazonais autorregressivos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.1.4",
                            "name": "Estimar parâmetros do modelo AR(p)",
                            "description": "Aplicar métodos como equações de Yule-Walker ou máxima verossimilhança (MLE) para estimar φ_i e σ², usando software como R.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos teóricos da estimação em modelos AR(p)",
                                  "subSteps": [
                                    "Revise a definição do modelo AR(p): Y_t = φ_1 Y_{t-1} + ... + φ_p Y_{t-p} + ε_t.",
                                    "Estude as equações de Yule-Walker: relacionam coeficientes de autocorrelação com parâmetros φ_i.",
                                    "Aprenda o princípio da máxima verossimilhança (MLE): maximizar a função de verossimilhança assumindo ε_t ~ N(0, σ²).",
                                    "Derive manualmente as equações para AR(1) e AR(2) como exemplos.",
                                    "Compare vantagens e desvantagens de Yule-Walker (simples, mas enviesado para p alto) vs. MLE (eficiente, mas computacionalmente intensivo)."
                                  ],
                                  "verification": "Resolva exercícios manuais de derivação para AR(1) e AR(2), confirmando resultados com fórmulas padrão.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro 'Time Series Analysis' de Hamilton (cap. 3)",
                                    "Notas de aula sobre ARMA",
                                    "Calculadora ou papel para derivações"
                                  ],
                                  "tips": "Comece com AR(1) para intuitar antes de generalizar para p > 1.",
                                  "learningObjective": "Dominar as bases matemáticas para estimação de parâmetros AR(p).",
                                  "commonMistakes": [
                                    "Confundir autocorrelações teóricas com amostrais",
                                    "Ignorar a estacionariedade requerida",
                                    "Esquecer de normalizar por σ² na MLE"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar e validar dados para estimação AR(p)",
                                  "subSteps": [
                                    "Colete uma série temporal estacionária (teste ADF ou KPSS).",
                                    "Transforme dados se necessário (diferenciação, log).",
                                    "Calcule autocorrelações parciais (PACF) para identificar ordem p.",
                                    "Divida dados em treino/teste (ex: 80/20).",
                                    "Visualize a série, ACF e PACF com gráficos."
                                  ],
                                  "verification": "Gráficos de ACF/PACF mostram decaimento exponencial típico de AR(p), e teste de estacionariedade é aprovado.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software R com pacotes forecast, tseries",
                                    "Dataset exemplo: AirPassengers ou sunspots"
                                  ],
                                  "tips": "Use diff() ou log() para estacionarizar; valide p via PACF cortando em lag p.",
                                  "learningObjective": "Preparar dados adequadamente para evitar estimações inválidas.",
                                  "commonMistakes": [
                                    "Usar séries não estacionárias",
                                    "Escolha errada de p sem PACF",
                                    "Amostra muito pequena (<100 obs)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar estimação via equações de Yule-Walker em R",
                                  "subSteps": [
                                    "Instale pacotes: ar, stats.",
                                    "Use função ar() com method='yule-walker'.",
                                    "Extraia φ_i com coef(ar_model) e σ² com ar_model$var.pred.",
                                    "Interprete resultados: verifique invertibilidade (|φ_i| <1 para AR(1)).",
                                    "Plote resíduos e teste Ljung-Box para autocorrelação."
                                  ],
                                  "verification": "Modelo estima φ_i coerentes com PACF e resíduos brancos (p-value Ljung-Box >0.05).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "R/RStudio",
                                    "Script R com dados sunspots",
                                    "Documentação ?ar"
                                  ],
                                  "tips": "Defina order.max=p para fixar ordem; compare com OLS via lm().",
                                  "learningObjective": "Aplicar Yule-Walker computacionalmente de forma precisa.",
                                  "commonMistakes": [
                                    "Não especificar order corretamente",
                                    "Ignorar warnings de convergência",
                                    "Confundir var.pred com sigma^2"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar estimação por MLE em R e validar o modelo",
                                  "subSteps": [
                                    "Use ar() com method='mle' ou arima() para AR(p).",
                                    "Compare estimativas Yule-Walker vs. MLE (AIC/BIC).",
                                    "Calcule intervalos de confiança com confint().",
                                    "Diagnostique: Q-Q plot, teste de normalidade (Shapiro), forecast h-steps ahead.",
                                    "Valide com hold-out: compare MSE de previsões."
                                  ],
                                  "verification": "MLE tem AIC menor que Yule-Walker em datasets longos; previsões precisas no teste.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "R com pacotes arima, forecast",
                                    "Dataset treino/teste personalizado"
                                  ],
                                  "tips": "Para p alto, prefira MLE; use auto.arima() para automação inicial.",
                                  "learningObjective": "Dominar MLE e técnicas de validação para modelos AR(p).",
                                  "commonMistakes": [
                                    "Sobreajuste com p alto sem BIC",
                                    "Não testar resíduos",
                                    "Ignorar diferenças numéricas YW vs MLE"
                                  ]
                                }
                              ],
                              "practicalExample": "Carregue dados de sunspots no R (sunspots <- sunspots[1:200]). Teste estacionariedade, identifique p=2 via PACF, estime AR(2) com ar(sunspots, order.max=2, method='yule-walker') e method='mle'. Compare φ1, φ2, σ² e preveja próximos 12 meses, validando com dados reais.",
                              "finalVerifications": [
                                "Deriva corretamente equações Yule-Walker para AR(2).",
                                "Implementa ar() em R para YW e MLE sem erros.",
                                "Interpreta coeficientes e verifica invertibilidade.",
                                "Diagnostica resíduos como brancos.",
                                "Compara métodos via AIC e valida previsões.",
                                "Aplica em dataset real com relatório curto."
                              ],
                              "assessmentCriteria": [
                                "Precisão das estimativas φ_i e σ² (erro <5% vs. verdadeiros).",
                                "Correta identificação de p via PACF.",
                                "Qualidade de diagnóstico de resíduos (Ljung-Box p>0.05).",
                                "Comparação válida entre YW e MLE (critérios de info).",
                                "Relatório claro com código, gráficos e interpretação.",
                                "Capacidade de forecast com MSE baixo no teste."
                              ],
                              "crossCurricularConnections": [
                                "Programação em R (Ciência da Computação).",
                                "Econometria e Finanças (Economia).",
                                "Machine Learning (previsão em IA).",
                                "Cálculo e Álgebra Linear (derivações matriciais).",
                                "Probabilidade (MLE e distribuições gaussianas)."
                              ],
                              "realWorldApplication": "Em finanças, estimar AR(p) para retornos de ações estacionários e prever volatilidade; em meteorologia, modelar temperaturas diárias para alertas climáticos; em controle de qualidade, analisar séries de defeitos em produção."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.4.2",
                        "name": "Modelo de Média Móvel (MA)",
                        "description": "Os modelos MA(q) expressam a série como uma combinação linear finita de erros passados, ideais para dependências seriais de curto alcance em séries estacionárias.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.2.1",
                            "name": "Definir notação e equação do modelo MA(q)",
                            "description": "Descrever a equação MA(q): Y_t = μ + ε_t + θ_1 ε_{t-1} + ... + θ_q ε_{t-q}, destacando os coeficientes θ_j e a invertibilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito Básico de Média Móvel (MA)",
                                  "subSteps": [
                                    "Revise o que é uma série temporal estacionária e o papel dos ruídos brancos (ε_t).",
                                    "Leia a definição de processo MA: uma média ponderada finita de erros passados.",
                                    "Identifique a diferença entre MA e AR: MA depende apenas de erros passados, não de valores passados da série.",
                                    "Estude um exemplo simples MA(1): Y_t = μ + ε_t + θ_1 ε_{t-1}.",
                                    "Anote os pressupostos: ε_t ~ WN(0, σ²), média zero e variância constante."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que é um modelo MA e dê um exemplo MA(1).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Séries Temporais (ex: Brockwell & Davis)",
                                    "Notas de aula sobre ruído branco",
                                    "Vídeo introdutório no YouTube sobre MA models"
                                  ],
                                  "tips": "Comece com MA(1) para visualizar intuitivamente antes de generalizar.",
                                  "learningObjective": "Entender o conceito fundamental e motivação do modelo MA(q).",
                                  "commonMistakes": [
                                    "Confundir MA com suavização de médias móveis em gráficos.",
                                    "Ignorar que ε_t é ruído branco independente."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender a Notação Padrão dos Componentes",
                                  "subSteps": [
                                    "Defina Y_t como o valor da série no tempo t.",
                                    "Explique μ como a média constante da série (opcional em alguns contextos).",
                                    "Descreva ε_t como erro branco no tempo t: E(ε_t)=0, Var(ε_t)=σ², Cov(ε_t, ε_s)=0 para t≠s.",
                                    "Introduza θ_j como coeficientes de média móvel (j=1 a q).",
                                    "Esboce a estrutura geral: soma de termos atuais e passados ponderados."
                                  ],
                                  "verification": "Liste e defina todos os símbolos na notação MA(q) com exemplos numéricos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Folha de anotações",
                                    "Tabela de símbolos estatísticos",
                                    "Software como R ou Python para visualizar ε_t"
                                  ],
                                  "tips": "Use subscritos consistentes: t para tempo atual, t-j para lag j.",
                                  "learningObjective": "Dominar a notação exata dos elementos do modelo MA(q).",
                                  "commonMistakes": [
                                    "Confundir θ_j com φ_j de modelos AR.",
                                    "Esquecer que μ é a constante de drift."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Escrever e Expandir a Equação Geral MA(q)",
                                  "subSteps": [
                                    "Escreva a equação: Y_t = μ + ε_t + θ_1 ε_{t-1} + θ_2 ε_{t-2} + ... + θ_q ε_{t-q}.",
                                    "Expanda para q=2: Y_t = μ + ε_t + θ_1 ε_{t-1} + θ_2 ε_{t-2}.",
                                    "Verifique a ordem: termo atual primeiro, depois lags crescentes.",
                                    "Simule numericamente com valores fictícios para θ_j e ε_t.",
                                    "Confirme que é uma representação linear dos erros."
                                  ],
                                  "verification": "Escreva a equação MA(q) do zero e preencha com q=3 e valores exemplo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Caderno para equações",
                                    "Calculadora ou Excel para simulação simples",
                                    "Script R básico: arima.sim(model=list(ma=c(0.5,0.3)))"
                                  ],
                                  "tips": "Memorize o padrão: ε_t + sum θ_j ε_{t-j}.",
                                  "learningObjective": "Capacidade de formular corretamente a equação MA(q).",
                                  "commonMistakes": [
                                    "Inverter a ordem dos lags.",
                                    "Incluir Y_{t-j} em vez de ε_{t-j}."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Destacar Coeficientes θ_j e Condição de Invertibilidade",
                                  "subSteps": [
                                    "Explique o papel de θ_j: pesos decrescentes nos erros passados, |θ_j| <1 tipicamente.",
                                    "Defina invertibilidade: o processo MA(q) pode ser expresso como AR(∞) com coeficientes decaindo.",
                                    "Estude a condição: raízes do polinômio θ(z) = 1 + θ_1 z + ... + θ_q z^q fora do círculo unitário (|z|>1).",
                                    "Para MA(1): invertível se |θ_1| <1.",
                                    "Verifique com exemplo: θ_1=0.5 é invertível; θ_1=2 não é."
                                  ],
                                  "verification": "Para um MA(1) dado, verifique se é invertível e justifique.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Gráfico do polinômio característico",
                                    "Software como R: polyroot(c(1, theta)) para raízes",
                                    "Artigo sobre invertibilidade em ARMA"
                                  ],
                                  "tips": "Use o teste de invertibilidade para garantir estimabilidade.",
                                  "learningObjective": "Compreender o significado e restrições nos coeficientes θ_j.",
                                  "commonMistakes": [
                                    "Confundir invertibilidade com estacionariedade.",
                                    "Esquecer que invertibilidade afeta previsão."
                                  ]
                                }
                              ],
                              "practicalExample": "Gere uma série MA(1) com θ_1=0.6 em R: set.seed(123); y <- arima.sim(model=list(ma=0.6), n=100). Plote y e compare com ε_t puro, observando a suavização dos erros passados.",
                              "finalVerifications": [
                                "Escreva corretamente a equação MA(q) sem consulta.",
                                "Defina todos os símbolos: Y_t, μ, ε_t, θ_j.",
                                "Explique invertibilidade para MA(1).",
                                "Simule uma MA(2) e identifique os lags.",
                                "Diferencie MA de AR em uma frase.",
                                "Verifique raízes de um polinômio θ(z) simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na equação e notação (correta em 100%).",
                                "Compreensão conceitual de componentes (explicação clara).",
                                "Aplicação de invertibilidade (cálculo correto de raízes).",
                                "Uso correto de exemplos numéricos/simulações.",
                                "Identificação de erros comuns evitados.",
                                "Conexão com contexto de séries estacionárias."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade: Distribuição e propriedades do ruído branco ε_t.",
                                "Álgebra Linear: Representação matricial da equação MA(q).",
                                "Programação: Simulação em R/Python com pacotes forecast ou statsmodels.",
                                "Economia: Modelagem de resíduos em séries financeiras estacionárias."
                              ],
                              "realWorldApplication": "Em finanças, modelar retornos de ações estacionários com MA(q) para remover ruído e melhorar previsões de curto prazo em trading algorítmico."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.2.2",
                            "name": "Verificar condições de invertibilidade",
                            "description": "Examinar as raízes do polinômio θ(z) = 1 + θ_1 z + ... + θ_q z^q = 0, garantindo que todas estejam fora do círculo unitário para representabilidade AR(∞).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular o polinômio de média móvel θ(z)",
                                  "subSteps": [
                                    "Identifique os coeficientes θ_1, θ_2, ..., θ_q do modelo MA(q).",
                                    "Escreva o polinômio θ(z) = 1 + θ_1 z + θ_2 z^2 + ... + θ_q z^q.",
                                    "Verifique se o polinômio está na forma padrão (grau q).",
                                    "Confirme que o termo constante é 1.",
                                    "Anote o modelo MA específico para referência."
                                  ],
                                  "verification": "Polinômio θ(z) escrito corretamente e coeficientes correspondem ao modelo MA.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Folha de papel ou editor de texto",
                                    "Definição do modelo MA(q)"
                                  ],
                                  "tips": "Sempre comece com o termo 1 para normalização.",
                                  "learningObjective": "Construir corretamente o polinômio associado ao modelo MA.",
                                  "commonMistakes": [
                                    "Esquecer o termo constante 1",
                                    "Inverter os sinais dos coeficientes",
                                    "Confundir com o polinômio AR φ(z)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular as raízes do polinômio θ(z)",
                                  "subSteps": [
                                    "Resolva θ(z) = 0 para encontrar as raízes z_1, z_2, ..., z_q.",
                                    "Use métodos analíticos para q baixo (ex: MA(1)) ou numéricos/software para q alto.",
                                    "Liste todas as raízes complexas.",
                                    "Verifique a precisão numérica das raízes.",
                                    "Armazene as raízes em formato complexo (a + bi)."
                                  ],
                                  "verification": "Raízes calculadas e listadas com precisão de pelo menos 4 casas decimais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora gráfica ou software como R/Python/MATLAB",
                                    "Função polyroot() em R ou roots() em MATLAB"
                                  ],
                                  "tips": "Para polinômios de grau >4, prefira métodos numéricos para evitar erros analíticos.",
                                  "learningObjective": "Resolver numericamente ou analiticamente equações polinomiais de grau q.",
                                  "commonMistakes": [
                                    "Ignorar raízes complexas",
                                    "Erros de arredondamento em cálculos manuais",
                                    "Confundir raízes múltiplas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar magnitudes das raízes (|z_i| > 1)",
                                  "subSteps": [
                                    "Para cada raiz z_i, calcule |z_i| = sqrt(Re(z_i)^2 + Im(z_i)^2).",
                                    "Compare cada |z_i| com 1.",
                                    "Identifique raízes dentro (|z_i| ≤ 1) ou fora (|z_i| > 1) do círculo unitário.",
                                    "Registre o módulo de cada raiz em uma tabela.",
                                    "Confirme se TODAS as raízes satisfazem |z_i| > 1."
                                  ],
                                  "verification": "Tabela de |z_i| criada e condição |z_i| > 1 verificada para todas as raízes.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora ou software para módulo complexo",
                                    "Planilha Excel ou tabela em papel"
                                  ],
                                  "tips": "Use abs(z) em software para cálculo automático do módulo.",
                                  "learningObjective": "Avaliar geometricamente as raízes no plano complexo em relação ao círculo unitário.",
                                  "commonMistakes": [
                                    "Calcular |1/z_i| em vez de |z_i|",
                                    "Ignorar raízes na fronteira |z_i|=1",
                                    "Arredondar incorretamente módulos próximos a 1"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir sobre invertibilidade e representabilidade AR(∞)",
                                  "subSteps": [
                                    "Se todas |z_i| > 1, conclua que o modelo é invertível.",
                                    "Discuta implicações: representação AR(∞) converge.",
                                    "Se não invertível, sugira transformações (ex: inverter raízes).",
                                    "Documente a conclusão final.",
                                    "Relacione com estacionariedade do processo."
                                  ],
                                  "verification": "Conclusão explícita de invertibilidade com justificativa baseada nas raízes.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Resumo dos passos anteriores"
                                  ],
                                  "tips": "Invertibilidade garante interpretação causal dos erros passados.",
                                  "learningObjective": "Interpretar condições de invertibilidade no contexto de modelos ARMA.",
                                  "commonMistakes": [
                                    "Confundir invertibilidade com estacionariedade",
                                    "Ignorar impacto em previsões",
                                    "Concluir invertibilidade prematuramente"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um modelo MA(1): X_t = ε_t - 0.5 ε_{t-1}, θ(z) = 1 - 0.5 z = 0 → z = 2. Raiz |2| = 2 > 1, logo invertível. Representação AR(∞): X_t = 0.5 X_{t-1} + ε_t - 0.25 ε_{t-2} + ... (coeficientes decrescem).",
                              "finalVerifications": [
                                "Polinômio θ(z) formulado corretamente.",
                                "Todas as raízes calculadas com precisão.",
                                "Todos os módulos |z_i| > 1 confirmados.",
                                "Conclusão de invertibilidade justificada.",
                                "Representação AR(∞) mencionada.",
                                "Sem raízes unitárias ou internas detectadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de raízes (erro < 0.01).",
                                "Correta interpretação geométrica no círculo unitário.",
                                "Uso apropriado de ferramentas numéricas.",
                                "Conclusão lógica e completa.",
                                "Identificação de erros comuns evitados.",
                                "Clareza na documentação dos passos."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra: Resolução de polinômios e números complexos.",
                                "Programação: Uso de bibliotecas como numpy.polyroots() em Python.",
                                "Análise Numérica: Estabilidade de algoritmos para raízes.",
                                "Probabilidade: Implicações em processos estocásticos estacionários."
                              ],
                              "realWorldApplication": "Em finanças, verificar invertibilidade de modelos MA em séries de retornos de ações garante previsões estáveis via representação AR(∞), essencial para risco e trading algorítmico."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.2.3",
                            "name": "Interpretar ACF e PACF para MA(q)",
                            "description": "Identificar o corte abrupto da ACF após lag q e o decaimento sinusoidal da PACF para determinação da ordem q.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de ACF e PACF",
                                  "subSteps": [
                                    "Defina ACF como a correlação entre a série e seus lags.",
                                    "Explique PACF como a correlação parcial removendo efeitos de lags intermediários.",
                                    "Discuta importância na identificação de modelos ARMA.",
                                    "Revise fórmulas básicas: ACF(τ) = Cov(Y_t, Y_{t-τ}) / Var(Y_t).",
                                    "Diferencie ACF teórica de amostral."
                                  ],
                                  "verification": "Resuma em 3 frases as diferenças entre ACF e PACF.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de séries temporais (Box-Jenkins)",
                                    "Notebook Jupyter ou RStudio"
                                  ],
                                  "tips": "Use diagramas visuais para memorizar as diferenças.",
                                  "learningObjective": "Compreender as bases teóricas de ACF e PACF para interpretação em MA(q).",
                                  "commonMistakes": [
                                    "Confundir ACF com PACF",
                                    "Ignorar a estacionariedade prévia"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar características da ACF em modelos MA(q)",
                                  "subSteps": [
                                    "Simule uma série MA(q) com q conhecido (ex: q=2).",
                                    "Gere e plote a ACF amostral da série.",
                                    "Identifique o corte abrupto: ACF significativa até lag q, zero após.",
                                    "Compare com ACF teórica usando funções como acf() em R.",
                                    "Teste significância com intervalos de confiança (2 desvios padrão)."
                                  ],
                                  "verification": "Plote ACF de MA(2) e aponte o lag onde corta abruptamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python (statsmodels.tsa.arima_process)",
                                    "R (arima.sim)"
                                  ],
                                  "tips": "Aumente o tamanho da amostra (>200) para ACF amostral estável.",
                                  "learningObjective": "Reconhecer o padrão de corte abrupto na ACF para determinar q.",
                                  "commonMistakes": [
                                    "Interpretar ruído como sinal significativo",
                                    "Não verificar estacionariedade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar o decaimento sinusoidal da PACF em MA(q)",
                                  "subSteps": [
                                    "Gere PACF para a mesma série MA(q).",
                                    "Observe o decaimento gradual e oscilatório (sinusoidal) sem corte abrupto.",
                                    "Compare com PACF de modelos AR(p), que cortam abruptamente.",
                                    "Use pacf() em R ou Python para plotar.",
                                    "Analise amplitude decrescente ao longo dos lags."
                                  ],
                                  "verification": "Descreva o padrão da PACF em MA(1) vs MA(2).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Bibliotecas statsmodels (Python) ou tseries (R)",
                                    "Dados simulados"
                                  ],
                                  "tips": "Foque nos primeiros 20 lags para visualização clara.",
                                  "learningObjective": "Identificar o decaimento sinusoidal da PACF como confirmação de MA(q).",
                                  "commonMistakes": [
                                    "Confundir decaimento MA com corte AR",
                                    "Ignorar overdifferencing"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar ACF e PACF para identificação de q em MA(q)",
                                  "subSteps": [
                                    "Combine plots de ACF e PACF de uma série desconhecida.",
                                    "Determine q pelo último lag significativo na ACF.",
                                    "Confirme com PACF não cortando abruptamente.",
                                    "Ajuste modelo MA(q) e verifique resíduos brancos.",
                                    "Pratique com 3 séries simuladas variando q=0,1,2."
                                  ],
                                  "verification": "Identifique q corretamente em um plot duplo ACF/PACF fornecido.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Scripts prontos para simulação ARMA",
                                    "Gráficos de exemplo de Box-Jenkins"
                                  ],
                                  "tips": "Sempre valide com teste Ljung-Box nos resíduos.",
                                  "learningObjective": "Aplicar interpretação conjunta para determinar ordem q em MA(q).",
                                  "commonMistakes": [
                                    "Escolher q muito alto por ruído",
                                    "Não considerar sazonalidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule uma série MA(1) em R: set.seed(123); y <- arima.sim(model = list(ma=0.5), n=200). Plote acf(y) e pacf(y): ACF corta após lag 1 (significativo em lag 0 e 1, zero após); PACF mostra decaimento sinusoidal. Identifique q=1 pelo corte na ACF e confirme pela PACF.",
                              "finalVerifications": [
                                "Identifica corretamente o lag q pelo corte abrupto na ACF.",
                                "Descreve o padrão sinusoidal na PACF para MA(q).",
                                "Diferencia MA(q) de AR(p) via plots duplos.",
                                "Valida com ajuste de modelo e resíduos.",
                                "Aplica em dados simulados com acurácia >90%.",
                                "Explica limitações em séries curtas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de q (corte ACF correto).",
                                "Descrição qualitativa correta da PACF (sinusoidal).",
                                "Uso adequado de intervalos de confiança.",
                                "Integração lógica de ambos os gráficos.",
                                "Validação prática com software.",
                                "Consciência de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de processos estocários e covariâncias.",
                                "Programação: Manipulação de dados em Python/R (pandas, dplyr).",
                                "Economia: Modelagem de séries financeiras estacionárias.",
                                "Engenharia: Previsão de sinais em controle de processos.",
                                "Machine Learning: Feature engineering para modelos de previsão."
                              ],
                              "realWorldApplication": "Em finanças, interpretar ACF/PACF de retornos diários de ações para ajustar MA(q) e prever volatilidade de curto prazo, auxiliando traders em decisões de risco."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.2.4",
                            "name": "Estimar parâmetros do modelo MA(q)",
                            "description": "Utilizar máxima verossimilhança condicional ou incondicional para estimar θ_j e σ², considerando não-linearidades na estimação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparação dos dados e especificação do modelo MA(q)",
                                  "subSteps": [
                                    "Verificar estacionariedade da série temporal usando testes como ADF.",
                                    "Determinar ordem q com base em ACF ou critérios de informação (AIC/BIC).",
                                    "Simular ou carregar dados estacionários adequados para MA(q).",
                                    "Padronizar os dados (remover média se necessário)."
                                  ],
                                  "verification": "Dados preparados confirmados por gráficos de ACF e testes de estacionariedade aprovados.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Série temporal estacionária (ex: dados simulados ou reais)",
                                    "Software R (forecast) ou Python (statsmodels)"
                                  ],
                                  "tips": "Sempre comece com q pequeno e aumente iterativamente para evitar sobreajuste.",
                                  "learningObjective": "Compreender a estrutura do modelo MA(q) e preparar dados para estimação.",
                                  "commonMistakes": [
                                    "Ignorar não-estacionariedade",
                                    "Escolha inadequada de q sem evidência empírica"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definição da função de log-verossimilhança",
                                  "subSteps": [
                                    "Escrever a equação do modelo MA(q): Y_t = ∑_{j=1}^q θ_j ε_{t-j} + ε_t.",
                                    "Definir likelihood condicional: assumir ε_0=...=ε_{-q}=0 para inicialização.",
                                    "Implementar log-likelihood incondicional considerando distribuição normal multivariada.",
                                    "Codificar a função em R/Python, parametrizando θ e σ²."
                                  ],
                                  "verification": "Função de likelihood computada para valores iniciais e retorna valores finitos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Documentação de statsmodels ou arima em R",
                                    "Editor de código (Jupyter ou RStudio)"
                                  ],
                                  "tips": "Use likelihood condicional para simplicidade em séries longas; incondicional para precisão em curtas.",
                                  "learningObjective": "Formular matematicamente a verossimilhança para modelos MA(q).",
                                  "commonMistakes": [
                                    "Confundir conditional com unconditional",
                                    "Esquecer restrições |θ_j| <1 para invertibilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Otimização numérica dos parâmetros",
                                  "subSteps": [
                                    "Definir valores iniciais para θ_j (ex: zeros ou de ACF) e σ².",
                                    "Aplicar otimizador (BFGS ou Nelder-Mead) para maximizar log-likelihood.",
                                    "Executar estimação considerando não-linearidades e gradientes numéricos.",
                                    "Monitorar convergência e iterações."
                                  ],
                                  "verification": "Otimização converge com mensagens de sucesso e parâmetros finitos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Bibliotecas de otimização (scipy.optimize ou optim em R)",
                                    "Dados preparados do Step 1"
                                  ],
                                  "tips": "Teste múltiplos iniciais para evitar mínimos locais devido a não-linearidades.",
                                  "learningObjective": "Implementar e executar estimação por máxima verossimilhança.",
                                  "commonMistakes": [
                                    "Valores iniciais ruins levando a não-convergência",
                                    "Ignorar warnings de hessiana singular"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validação e interpretação das estimativas",
                                  "subSteps": [
                                    "Calcular erros padrão via hessiana observada ou informação esperada.",
                                    "Verificar invertibilidade (|raízes do polinômio MA| >1).",
                                    "Realizar diagnósticos residuais (Ljung-Box, normalidade).",
                                    "Comparar com critérios AIC/BIC para modelos concorrentes."
                                  ],
                                  "verification": "Resíduos brancos, parâmetros significativos e modelo invertível.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Funções de diagnóstico em statsmodels/R",
                                    "Gráficos de resíduos e ACF"
                                  ],
                                  "tips": "Sempre plote resíduos para inspeção visual antes de testes formais.",
                                  "learningObjective": "Interpretar e validar estimativas considerando incertezas.",
                                  "commonMistakes": [
                                    "Não checar invertibilidade",
                                    "Interpretar parâmetros sem erros padrão"
                                  ]
                                }
                              ],
                              "practicalExample": "Estime os parâmetros de um modelo MA(1) para retornos diários da ação PETR4 usando dados de 2020-2023 no Python com statsmodels. Inicialize θ1=0.5, otimize e valide com testes residuais.",
                              "finalVerifications": [
                                "Parâmetros θ_j estimados com |θ_j| <1 e significância estatística.",
                                "σ² positivo e finito.",
                                "Log-likelihood máxima com convergência confirmada.",
                                "Resíduos sem autocorrelação (teste Ljung-Box p>0.05).",
                                "Modelo invertível via raízes do polinômio MA.",
                                "AIC/BIC competitivo com ARMA alternativos."
                              ],
                              "assessmentCriteria": [
                                "Correta formulação da log-likelihood (condicional/incondicional).",
                                "Implementação precisa da otimização numérica com convergência.",
                                "Cálculo adequado de erros padrão e intervalos de confiança.",
                                "Diagnósticos residuais completos e interpretação correta.",
                                "Consideração de não-linearidades na estimação.",
                                "Uso eficiente de recursos computacionais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização não-linear e cálculo multivariado.",
                                "Programação: Bibliotecas de séries temporais (statsmodels, forecast).",
                                "Economia: Modelagem de séries financeiras e previsão.",
                                "Computação: Algoritmos numéricos e gradiente descendente.",
                                "Probabilidade: Distribuições condicionais e multivariadas."
                              ],
                              "realWorldApplication": "Em finanças, estimação de MA(q) modela dependências de curto prazo em retornos de ativos para previsão de risco (VaR); em manufatura, prevê erros de processo em controles de qualidade; em meteorologia, modela ruídos em séries de temperatura para alertas climáticos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.4.3",
                        "name": "Modelo ARMA(p,q)",
                        "description": "Os modelos ARMA(p,q) combinam componentes AR e MA para modelar estruturas de dependência complexas em séries temporais estacionárias, seguindo a metodologia Box-Jenkins.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.3.1",
                            "name": "Definir modelo ARMA(p,q) e metodologia Box-Jenkins",
                            "description": "Apresentar a equação geral ARMA(p,q): Y_t - ∑ φ_i Y_{t-i} = ε_t + ∑ θ_j ε_{t-j}, e os passos: identificação, estimação, diagnóstico e previsão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Apresentar a Equação Geral do Modelo ARMA(p,q)",
                                  "subSteps": [
                                    "Explicar os componentes: parte autoregressiva (AR(p)) com coeficientes φ_i e parte de média móvel (MA(q)) com coeficientes θ_j.",
                                    "Escrever a equação: Y_t - ∑_{i=1}^p φ_i Y_{t-i} = ε_t + ∑_{j=1}^q θ_j ε_{t-j}, onde ε_t é ruído branco.",
                                    "Definir estacionariedade: média e variância constantes, autocovariância depende apenas do lag.",
                                    "Discutir restrições para estacionariedade (raízes do polinômio AR fora do círculo unitário).",
                                    "Exemplificar com ARMA(1,1): Y_t - φ_1 Y_{t-1} = ε_t + θ_1 ε_{t-1}."
                                  ],
                                  "verification": "Escrever corretamente a equação geral e um exemplo ARMA(1,1) sem erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e lápis, quadro branco, software R ou Python para visualização.",
                                  "tips": "Use notação padrão e memorize a forma compacta Φ(B)Y_t = Θ(B)ε_t com operadores atraso B.",
                                  "learningObjective": "Compreender e reproduzir a estrutura matemática do modelo ARMA(p,q).",
                                  "commonMistakes": "Confundir os papéis de φ_i (passado de Y) e θ_j (passado de ε); inverter os lados da equação."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificação do Modelo (Determinar p e q)",
                                  "subSteps": [
                                    "Plotar a Função de Autocorrelação (ACF): decai exponencialmente para AR, sinusoidal ou corte para MA.",
                                    "Plotar a Função de Autocorrelação Parcial (PACF): corte após lag p para AR, decai para MA.",
                                    "Testar estacionariedade com teste de Dickey-Fuller se necessário.",
                                    "Selecionar ordens iniciais baseadas em regras: PACF significativo até p para AR(p), ACF até q para MA(q).",
                                    "Usar critério AIC/BIC para refinar candidatas."
                                  ],
                                  "verification": "Identificar corretamente p=1, q=1 para uma série simulada ARMA(1,1) via ACF/PACF.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software R (forecast package) ou Python (statsmodels), dados de série temporal estacionária.",
                                  "tips": "Ajuste lags até 20-30 para plots claros; ignore spikes insignificantes.",
                                  "learningObjective": "Selecionar ordens p e q apropriadas usando gráficos ACF e PACF.",
                                  "commonMistakes": "Ignorar não-estacionariedade; superestimar p/q por ruído; confundir decay de ACF/PACF."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estimação dos Parâmetros",
                                  "subSteps": [
                                    "Usar máxima verossimilhança condicional ou exata para estimar φ_i e θ_j.",
                                    "Implementar em software: arima() no R ou ARIMA em statsmodels Python.",
                                    "Verificar convergência do otimizador e valores iniciais razoáveis.",
                                    "Calcular intervalos de confiança para parâmetros.",
                                    "Avaliar significância via t-testes."
                                  ],
                                  "verification": "Ajustar um modelo ARMA(1,1) a dados simulados e relatar coeficientes com p-valores <0.05.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "R ou Python com bibliotecas statsmodels/forecast, conjunto de dados exemplo.",
                                  "tips": "Comece com valores iniciais próximos de 0; use método='CSS-ML' para robustez.",
                                  "learningObjective": "Estimar parâmetros do modelo ARMA usando métodos padrão.",
                                  "commonMistakes": "Não verificar convergência; ignorar multicolinearidade em ordens altas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diagnóstico do Modelo",
                                  "subSteps": [
                                    "Analisar resíduos: plotar ACF/PACF dos resíduos (devem ser ruído branco).",
                                    "Teste de Ljung-Box para autocorrelação serial nos resíduos.",
                                    "Verificar normalidade com Q-Q plot e teste Jarque-Bera.",
                                    "Analisar heteroscedasticidade com plot de resíduos vs tempo/fitted.",
                                    "Iterar: se falhar, voltar à identificação e ajustar p/q."
                                  ],
                                  "verification": "Resíduos passam Ljung-Box (p>0.05) e ACF cortada em lag 0.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Mesmo software anterior, funções checkresiduals() no R.",
                                  "tips": "Resíduos bons: média 0, variância constante, sem padrões.",
                                  "learningObjective": "Validar adequação do modelo via análise de resíduos.",
                                  "commonMistakes": "Aceitar modelo com ACF residual significativo; ignorar outliers."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Previsão com o Modelo ARMA",
                                  "subSteps": [
                                    "Gerar previsões pontuais: h passos à frente usando equação recursiva.",
                                    "Calcular intervalos de previsão: ±1.96 * σ_ε * sqrt(1 + var forecast).",
                                    "Avaliar precisão out-of-sample com RMSE/MAE em conjunto de teste.",
                                    "Plotar série original + previsões + intervalos.",
                                    "Comparar com baselines como média ou ARIMA sazonal."
                                  ],
                                  "verification": "Produzir previsões para 12 passos com intervalos e RMSE < baseline.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software com forecast() ou predict(), dados de validação.",
                                  "tips": "Horizonte curto para ARMA; incerteza cresce com h.",
                                  "learningObjective": "Aplicar modelo para previsões confiáveis.",
                                  "commonMistakes": "Extrapolação sem intervalos; avaliação apenas in-sample."
                                }
                              ],
                              "practicalExample": "Usando dados mensais de passageiros aéreos (1949-1960, após diferenciação para estacionariedade): identificar ARMA(1,1) via ACF/PACF decay, estimar φ≈0.7, θ≈0.3, diagnosticar resíduos brancos, prever próximos 12 meses com RMSE≈15.",
                              "finalVerifications": [
                                "Escrever equação ARMA(p,q) corretamente.",
                                "Identificar p,q para série exemplo usando ACF/PACF.",
                                "Estimar parâmetros com software e interpretar significância.",
                                "Diagnosticar modelo com testes padrão (Ljung-Box p>0.05).",
                                "Gerar previsões com intervalos e calcular métrica de erro.",
                                "Explicar ciclo Box-Jenkins em 4 frases."
                              ],
                              "assessmentCriteria": [
                                "Precisão na equação e notação (20%)",
                                "Correção na identificação via ACF/PACF (25%)",
                                "Adequação da estimação e convergência (20%)",
                                "Qualidade do diagnóstico de resíduos (20%)",
                                "Precisão e interpretação das previsões (15%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear para operadores atraso e matrizes de covariância.",
                                "Programação: Implementação em R/Python para automação de Box-Jenkins.",
                                "Economia: Modelagem de séries financeiras como PIB ou inflação.",
                                "Física: Análise de sinais temporais em experimentos.",
                                "Machine Learning: Base para modelos como ARIMA-SARIMA ou LSTM."
                              ],
                              "realWorldApplication": "Previsão de demanda em supply chain (ex: vendas sazonais Walmart), modelagem de retornos de ações em finanças quantitativas, ou monitoramento de séries climáticas como temperatura para agricultura sustentável."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.3.2",
                            "name": "Identificar ordens p e q via ACF e PACF",
                            "description": "Combinar padrões de ACF (decaimento lento para AR, corte para MA) e PACF (corte para AR, decaimento para MA) para propor ordens candidatas em processos ARMA.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Padrões Teóricos de ACF e PACF para Modelos AR e MA",
                                  "subSteps": [
                                    "Estude a ACF para AR(p): decaimento lento ou sinusoidal após lag p.",
                                    "Estude a ACF para MA(q): corte abrupto (zero significativo) após lag q.",
                                    "Estude a PACF para AR(p): corte abrupto após lag p.",
                                    "Estude a PACF para MA(q): decaimento lento após lag q.",
                                    "Memorize regras combinadas para ARMA(p,q): ACF decaimento para AR parte, corte para MA; vice-versa para PACF."
                                  ],
                                  "verification": "Resuma os 4 padrões principais em um diagrama ou tabela própria e compare com referências padrão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de texto de séries temporais (ex: Brockwell & Davis)",
                                    "Notas ou slides sobre ARMA",
                                    "Papel e caneta para diagrama"
                                  ],
                                  "tips": "Use mnemônicos: 'ACF corta em MA, PACF corta em AR'. Desenhe gráficos esquemáticos para fixar.",
                                  "learningObjective": "Compreender e diferenciar visualmente os padrões de ACF e PACF para componentes AR e MA.",
                                  "commonMistakes": [
                                    "Confundir decaimento lento com corte",
                                    "Ignorar a parte sinusoidal em AR de ordem par",
                                    "Não considerar significância estatística dos lags"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar Série Temporal Estacionária e Gerar Plots de ACF e PACF",
                                  "subSteps": [
                                    "Carregue ou gere uma série temporal estacionária simulada (ex: ARMA(1,1)) usando Python/R.",
                                    "Verifique estacionariedade com teste ADF e diferencie se necessário.",
                                    "Plote a série temporal original.",
                                    "Gere e plote ACF com barras de confiança (ex: ts.plot_acf() no statsmodels).",
                                    "Gere e plote PACF da mesma forma."
                                  ],
                                  "verification": "Confirme que os plots mostram barras de confiança e lags até pelo menos 20; salve os gráficos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python com statsmodels, pandas ou R com forecast",
                                    "Notebook Jupyter ou RStudio",
                                    "Dados simulados ou dataset exemplo (ex: AirPassengers diferenciado)"
                                  ],
                                  "tips": "Use lags=20-30 para visualização clara. Sempre inclua bandas de confiança para identificar significância.",
                                  "learningObjective": "Produzir visualizações precisas de ACF e PACF para uma série dada.",
                                  "commonMistakes": [
                                    "Plotar sem verificar estacionariedade",
                                    "Usar lags insuficientes",
                                    "Ignorar escala log ou normalização"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar ACF para Identificar Ordem q (Parte MA)",
                                  "subSteps": [
                                    "Identifique o lag onde ACF corta para zero (fora das bandas de confiança).",
                                    "Conte os lags significativos consecutivos antes do corte: isso sugere q.",
                                    "Registre decaimento lento se presente (indica componente AR).",
                                    "Anotar lags significativos em uma tabela.",
                                    "Compare com teoria: corte em q para MA pura."
                                  ],
                                  "verification": "Escreva: 'ACF sugere q=X baseado em corte no lag Y' com justificativa visual.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Plots de ACF gerados",
                                    "Folha de anotações",
                                    "Referência teórica"
                                  ],
                                  "tips": "Foque apenas em lags iniciais (1-10); ignore flutuações aleatórias após corte.",
                                  "learningObjective": "Diagnosticar ordem MA(q) exclusivamente via padrões de ACF.",
                                  "commonMistakes": [
                                    "Contar lags não-significativos",
                                    "Confundir com PACF",
                                    "Sobreinterpretar ruído como sinal"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar PACF para Identificar Ordem p (Parte AR)",
                                  "subSteps": [
                                    "Identifique o lag onde PACF corta para zero (fora das bandas).",
                                    "Conte lags significativos consecutivos antes do corte: sugere p.",
                                    "Note decaimento lento se presente (indica componente MA).",
                                    "Anotar em tabela e compare com ACF.",
                                    "Proponha p candidato combinando com q de ACF."
                                  ],
                                  "verification": "Escreva: 'PACF sugere p=X baseado em corte no lag Y' e liste ordens candidatas (p,q).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Plots de PACF",
                                    "Tabela de anotações do Step 3"
                                  ],
                                  "tips": "PACF é mais 'limpa' para AR; priorize cortes nítidos.",
                                  "learningObjective": "Diagnosticar ordem AR(p) via PACF e integrar com análise ACF.",
                                  "commonMistakes": [
                                    "Inverter regras AR/MA",
                                    "Não combinar com ACF",
                                    "Ignorar sobreposição em ARMA misto"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Propor Ordens Candidatas e Validar Inicialmente",
                                  "subSteps": [
                                    "Combine sugestões: p de PACF, q de ACF; liste 2-3 pares (p,q) candidatos.",
                                    "Ajuste modelos ARMA(p,q) rápidos e compare AIC/BIC.",
                                    "Verifique resíduos: plots de ACF/PACF dos resíduos devem ser ruído branco.",
                                    "Documente escolha final com justificativa.",
                                    "Teste previsão out-of-sample básica."
                                  ],
                                  "verification": "Gere relatório com ordens propostas, AIC values e plot de resíduos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código Python/R para auto.arima() ou ARIMA()",
                                    "Dados de treino/teste"
                                  ],
                                  "tips": "Use critérios de informação para desempate; comece com ordens baixas.",
                                  "learningObjective": "Finalizar identificação de ordens p,q com validação quantitativa.",
                                  "commonMistakes": [
                                    "Escolher única ordem sem candidatos",
                                    "Não validar resíduos",
                                    "Overfitting com ordens altas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em dados de passageiros aéreos (AirPassengers diferenciado para estacionariedade), ACF mostra corte em lag 1 (q=1), PACF decaimento lento (p>=1). Candidatos: ARMA(1,1), ARMA(2,1). Ajuste confirma ARMA(1,1) com AIC baixo e resíduos brancos.",
                              "finalVerifications": [
                                "ACF corta em lag q+1 e PACF em p+1 corretamente identificados.",
                                "Lista de 2-3 ordens candidatas com justificativa visual.",
                                "Modelos ajustados mostram AIC/BIC coerentes.",
                                "Resíduos têm ACF/PACF compatíveis com ruído branco.",
                                "Previsão simples out-of-sample plausível.",
                                "Relatório documenta todos os passos e plots."
                              ],
                              "assessmentCriteria": [
                                "Precisão na interpretação de padrões ACF/PACF (80%+ correção em exemplos).",
                                "Número adequado de substeps executados por step.",
                                "Uso correto de validação (AIC, resíduos).",
                                "Clareza em documentação e justificativas.",
                                "Identificação correta de p,q em pelo menos 2 datasets teste.",
                                "Eficiência temporal dentro dos estimados."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Uso de statsmodels/forecast em Python/R.",
                                "Estatística Inferencial: Testes de significância em lags.",
                                "Matemática: Funções de autocorrelação e Yule-Walker.",
                                "Machine Learning: Seleção de hiperparâmetros em modelos de previsão.",
                                "Análise de Dados: Visualização e diagnóstico de resíduos."
                              ],
                              "realWorldApplication": "Em finanças, identificar ordens ARMA em retornos de ações para modelar volatilidade e prever riscos; em meteorologia, para séries de temperatura em previsões de curto prazo."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.3.3",
                            "name": "Estimar parâmetros ARMA(p,q)",
                            "description": "Implementar estimação por máxima verossimilhança em R (função arima()), avaliando critérios como AIC, BIC para seleção de modelo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente R e os dados da série temporal estacionária",
                                  "subSteps": [
                                    "Instale e carregue pacotes necessários: base R (arima()), forecast para auto.arima opcional, tseries para testes.",
                                    "Carregue um dataset estacionário exemplo, como sunspots (disponível em R).",
                                    "Verifique estacionariedade com teste ADF (adf.test() do pacote tseries).",
                                    "Transforme dados se necessário (ex: log ou diff) e plote a série com plot() e acf().",
                                    "Crie um objeto ts() se não for já."
                                  ],
                                  "verification": "Série plotada corretamente, teste ADF rejeita H0 de não-estacionariedade (p-value < 0.05), ACF/PACF visíveis.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "R e RStudio",
                                    "Pacotes: tseries, forecast",
                                    "Dataset: data(sunspots)"
                                  ],
                                  "tips": "Sempre use set.seed() para reprodutibilidade em simulações.",
                                  "learningObjective": "Configurar ambiente R e validar pré-requisitos de estacionariedade para modelagem ARMA.",
                                  "commonMistakes": [
                                    "Ignorar teste de estacionariedade",
                                    "Usar dados não-estacionários diretamente",
                                    "Esquecer de converter para ts()"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar ACF e PACF para sugerir ordens iniciais p e q",
                                  "subSteps": [
                                    "Gere gráficos ACF com acf(ts_data) e identifique decaimento exponencial ou sinusoidal.",
                                    "Gere PACF com pacf(ts_data) e conte lags significativos para sugerir p (corte em PACF).",
                                    "Identifique q similarmente pelo corte em ACF.",
                                    "Anote possíveis combinações (p,q) como (1,1), (2,0), etc., baseadas em lags > 2*SE.",
                                    "Use auto.arima() do pacote forecast para sugestão automática como referência."
                                  ],
                                  "verification": "Gráficos ACF/PACF gerados e interpretados com pelo menos 3 combinações (p,q) anotadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Pacotes: forecast",
                                    "Funções: acf(), pacf()",
                                    "Dataset preparado do Step 1"
                                  ],
                                  "tips": "Foque em lags iniciais; ignore ruído em lags altos.",
                                  "learningObjective": "Interpretar funções de autocorrelação para identificar ordens ARMA iniciais.",
                                  "commonMistakes": [
                                    "Confundir ACF com PACF",
                                    "Interpretar lags insignificantes como significativos",
                                    "Não considerar sazonalidade mesmo em estacionárias"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Ajustar modelos ARMA(p,q) usando máxima verossimilhança com arima()",
                                  "subSteps": [
                                    "Ajuste modelos para combinações sugeridas: model1 <- arima(data, order=c(p,0,q)) (d=0 para estacionária).",
                                    "Verifique convergência: summary(model) deve mostrar coeficientes significativos (p-value <0.05).",
                                    "Extraia parâmetros estimados: coef(model) e erros padrão.",
                                    "Plote resíduos: tsdiag(model) para verificar independência e normalidade.",
                                    "Calcule log-likelihood: logLik(model)."
                                  ],
                                  "verification": "Pelo menos 3 modelos ajustados com convergência, resíduos brancos (Ljung-Box test p>0.05).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Função arima()",
                                    "Dataset do Step 1"
                                  ],
                                  "tips": "Use method='ML' explicitamente para máxima verossimilhança.",
                                  "learningObjective": "Implementar estimação MLE de parâmetros ARMA em R e validar ajuste inicial.",
                                  "commonMistakes": [
                                    "Definir d>0 em séries estacionárias",
                                    "Ignorar warnings de não-convergência",
                                    "Não checar significância dos coefs"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar e selecionar o melhor modelo com AIC e BIC",
                                  "subSteps": [
                                    "Calcule AIC: AIC(model1, model2, ...).",
                                    "Calcule BIC: BIC(model1, model2, ...).",
                                    "Compare valores: menor AIC/BIC indica melhor modelo (penaliza complexidade).",
                                    "Selecione o modelo com menor AIC/BIC e confirme com plot de resíduos e Q-Q plot.",
                                    "Documente a escolha e parâmetros finais."
                                  ],
                                  "verification": "Tabela comparativa de AIC/BIC criada, melhor modelo selecionado e justificado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Funções AIC(), BIC()",
                                    "Modelos do Step 3"
                                  ],
                                  "tips": "BIC penaliza mais a complexidade que AIC; use para amostras grandes.",
                                  "learningObjective": "Usar critérios de informação para seleção de modelo ARMA otimizado.",
                                  "commonMistakes": [
                                    "Escolher por menor p+q sem AIC/BIC",
                                    "Confundir AIC com erro quadrático",
                                    "Ignorar sobreajuste em modelos complexos"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando o dataset sunspots (dados mensais de manchas solares, 1749-1983): Após confirmar estacionariedade via ADF, explore ACF/PACF sugerindo AR(2), ajuste ARMA(2,0), ARMA(1,1), etc., compare AIC/BIC (ex: ARMA(1,1) vence com AIC=~2100), parâmetros φ1=0.67, θ1=-0.32.",
                              "finalVerifications": [
                                "Teste ADF confirma estacionariedade (p<0.05).",
                                "Resíduos do modelo selecionado são ruído branco (Ljung-Box p>0.05).",
                                "AIC/BIC calculados e tabela comparativa gerada.",
                                "Parâmetros estimados significativos (t-test p<0.05).",
                                "Gráficos de diagnóstico (ACF resíduos, Q-Q) aprovados.",
                                "Modelo reproduzível com set.seed()."
                              ],
                              "assessmentCriteria": [
                                "Precisão na estimação MLE (coefs próximos a valores teóricos).",
                                "Correta interpretação de ACF/PACF para sugestão de ordens.",
                                "Seleção de modelo baseada rigorosamente em AIC/BIC menor.",
                                "Validação completa de resíduos e convergência.",
                                "Código R limpo, comentado e executável.",
                                "Explicação clara da escolha final do modelo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização (MLE) e funções de correlação.",
                                "Programação: Manipulação de dados em R e automação com loops.",
                                "Economia: Previsão de séries como PIB ou inflação.",
                                "Física: Modelagem de fenômenos oscilatórios como manchas solares."
                              ],
                              "realWorldApplication": "Em finanças, estimar ARMA para retornos de ações e selecionar modelo via AIC para previsões de risco; em meteorologia, modelar temperaturas estacionárias para alertas climáticos."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.3.4",
                            "name": "Realizar diagnóstico de adequação",
                            "description": "Verificar resíduos: normalidade (Q-Q plot), independência (teste Ljung-Box), homocedasticidade (ACF/PACF resíduos), e iterar se necessário.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Verificar Normalidade dos Resíduos",
                                  "subSteps": [
                                    "Extraia os resíduos do modelo ARMA ajustado usando o método residuals() no statsmodels ou residuals em R.",
                                    "Gere o Q-Q plot comparando resíduos quantis com quantis normais teóricos.",
                                    "Analise visualmente: verifique se os pontos seguem a linha reta diagonal.",
                                    "Complemente com teste estatístico como Shapiro-Wilk ou Jarque-Bera para p-valor.",
                                    "Registre observações sobre desvios nas caudas ou centro."
                                  ],
                                  "verification": "Pontos no Q-Q plot alinhados à linha reta e p-valor do teste > 0.05.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python (statsmodels, scipy.stats, matplotlib)",
                                    "Notebook Jupyter ou RStudio",
                                    "Modelo ARMA ajustado"
                                  ],
                                  "tips": "Transforme resíduos com log se houver assimetria; foque nas caudas extremas.",
                                  "learningObjective": "Aplicar testes visuais e estatísticos para validar suposição de normalidade nos resíduos.",
                                  "commonMistakes": [
                                    "Interpretar apenas visualmente sem teste estatístico.",
                                    "Usar histograma em vez de Q-Q plot para normalidade."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar Independência dos Resíduos",
                                  "subSteps": [
                                    "Obtenha a série de resíduos padronizados do modelo.",
                                    "Aplique o teste de Ljung-Box para diferentes lags (ex: lags=10,20).",
                                    "Interprete o p-valor: alto valor indica ausência de autocorrelação.",
                                    "Plote ACF dos resíduos para visualização complementar.",
                                    "Documente lags significativos se houver."
                                  ],
                                  "verification": "P-valor do teste Ljung-Box > 0.05 para lags relevantes e ACF dentro de bandas de confiança.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python (statsmodels.tsa.stattools.q_stat)",
                                    "R (Box.test())",
                                    "Gráficos ACF"
                                  ],
                                  "tips": "Teste múltiplos lags; ignore lags próximos ao tamanho da amostra.",
                                  "learningObjective": "Detectar e quantificar dependência serial nos resíduos de séries temporais.",
                                  "commonMistakes": [
                                    "Usar lags muito altos levando a baixa potência do teste.",
                                    "Confundir independência com estacionariedade."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar Homocedasticidade dos Resíduos",
                                  "subSteps": [
                                    "Gere os resíduos e plote ACF e PACF dos resíduos.",
                                    "Verifique se barras estão dentro das bandas de confiança (ausência de estrutura).",
                                    "Teste formal como Breusch-Pagan para heteroscedasticidade condicional.",
                                    "Analise resíduos vs. valores ajustados para padrões de dispersão.",
                                    "Anote qualquer spike significativo em lags baixos."
                                  ],
                                  "verification": "ACF/PACF dos resíduos sem picos significativos e teste de heteroscedasticidade não rejeita nulidade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python (statsmodels.graphics.tsaplots.plot_acf, plot_pacf)",
                                    "R (acf(), pacf())"
                                  ],
                                  "tips": "Padronize resíduos antes; examine lags 1-20 principalmente.",
                                  "learningObjective": "Identificar variância não constante nos resíduos usando ferramentas gráficas e testes.",
                                  "commonMistakes": [
                                    "Ignorar PACF focando só em ACF.",
                                    "Confundir heteroscedasticidade com autocorrelação."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Resultados e Iterar Modelo se Necessário",
                                  "subSteps": [
                                    "Compile resultados dos três diagnósticos em um relatório resumido.",
                                    "Decida adequação: prossiga se todos OK; senão, identifique problema principal.",
                                    "Itere: ajuste p/q no ARMA, adicione ARI/MAI ou modele não-linear (ex: ARCH).",
                                    "Reajuste modelo iterado e repita diagnósticos.",
                                    "Compare AIC/BIC e diagnósticos para validar melhoria."
                                  ],
                                  "verification": "Todos diagnósticos passam ou iteração melhora métricas sem violar suposições.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Modelos ARMA múltiplos",
                                    "Critérios AIC/BIC",
                                    "Notebook para iterações"
                                  ],
                                  "tips": "Priorize violação mais crítica (ex: independência > normalidade); limite iterações a 3.",
                                  "learningObjective": "Tomar decisões baseadas em diagnósticos para refinar modelos de séries temporais.",
                                  "commonMistakes": [
                                    "Overfitting com muitas iterações.",
                                    "Ignorar trade-off entre critérios de informação."
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dados de passageiros aéreos (AirPassengers), ajuste ARMA(1,1), verifique Q-Q plot (normalidade OK), Ljung-Box p=0.45 (independente), ACF resíduos sem spikes (homocedástico); itere para ARMA(2,1) se necessário.",
                              "finalVerifications": [
                                "Q-Q plot linear sem desvios significativos.",
                                "P-valor Ljung-Box > 0.05 para lags 1-20.",
                                "ACF/PACF resíduos dentro de bandas de 95% CI.",
                                "Nenhuma iteração pendente ou melhoria confirmada por AIC.",
                                "Relatório documentado com plots e p-valores.",
                                "Resíduos brancos (white noise) confirmados."
                              ],
                              "assessmentCriteria": [
                                "Geração correta de plots e testes (Q-Q, Ljung-Box, ACF/PACF).",
                                "Interpretação precisa de resultados gráficos e estatísticos.",
                                "Lógica de iteração baseada em violações identificadas.",
                                "Documentação completa com evidências visuais.",
                                "Melhoria mensurável no modelo final (AIC/BIC).",
                                "Ausência de erros comuns em cada diagnóstico."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade: Testes de hipóteses e distribuições (normal, qui-quadrado).",
                                "Programação: Manipulação de dados em Python/R e visualizações.",
                                "Matemática: Análise de processos estocásticos e funções de autocorrelação.",
                                "Economia: Aplicação em séries financeiras e forecasting."
                              ],
                              "realWorldApplication": "Em previsão de demanda de energia elétrica, diagnosticar ARMA para detectar falhas no modelo, iterando para precisão em billing e planejamento de rede."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.5",
                    "name": "Métodos de Previsão em Séries Estacionárias",
                    "description": "Previsão pontual, intervalos de previsão e validação de modelos ARMA.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.5.1",
                        "name": "Previsão Pontual com Modelos ARMA",
                        "description": "Compreensão e aplicação de métodos para gerar previsões pontuais de curto e longo prazo em séries temporais estacionárias utilizando modelos autoregressivos de média móvel (ARMA).",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.1.1",
                            "name": "Identificar componentes ARMA para previsão pontual",
                            "description": "Reconhecer os parâmetros AR(p) e MA(q) em um modelo ARMA ajustado e explicar como eles contribuem para o cálculo de previsões pontuais em séries estacionárias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura geral do modelo ARMA(p,q)",
                                  "subSteps": [
                                    "Revise a definição de um processo ARMA(p,q) como combinação de componentes autoregressivo (AR) de ordem p e média móvel (MA) de ordem q.",
                                    "Estude a equação geral: Y_t = ∑_{i=1}^p φ_i Y_{t-i} + ∑_{j=1}^q θ_j ε_{t-j} + ε_t, onde φ_i são coeficientes AR e θ_j são coeficientes MA.",
                                    "Confirme que o modelo é aplicável apenas a séries temporais estacionárias, verificando condições de estacionariedade (raízes do polinômio característica fora do círculo unitário).",
                                    "Identifique os parâmetros p e q a partir da notação ARMA(p,q) em um modelo ajustado.",
                                    "Diferencie AR (dependência passada de Y) de MA (dependência passada de erros)."
                                  ],
                                  "verification": "Escreva a equação ARMA(1,1) e explique verbalmente os papéis de φ_1 e θ_1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de séries temporais",
                                    "Livro 'Forecasting: Principles and Practice' (Hyndman)",
                                    "Jupyter Notebook com exemplos"
                                  ],
                                  "tips": "Sempre verifique estacionariedade com teste ADF antes de ARMA.",
                                  "learningObjective": "Dominar a notação e equação fundamental do ARMA para reconhecimento imediato.",
                                  "commonMistakes": [
                                    "Confundir φ (AR) com θ (MA)",
                                    "Aplicar ARMA a séries não estacionárias"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e interpretar os componentes AR(p)",
                                  "subSteps": [
                                    "Localize os coeficientes φ_1 a φ_p na saída de um modelo ajustado (ex: em R com arima() ou Python statsmodels).",
                                    "Explique que AR(p) captura dependências lineares das p observações passadas de Y_t.",
                                    "Analise a significância estatística de cada φ_i (p-valor < 0.05).",
                                    "Visualize o impacto com ACF parcial (PACF), onde picos significativos até lag p indicam ordem AR.",
                                    "Calcule manualmente o termo AR para uma previsão pontual simples."
                                  ],
                                  "verification": "Dado um modelo ARMA(2,0), isole e interprete os termos φ_1 Y_{t-1} + φ_2 Y_{t-2}.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software R/Python com dados de exemplo estacionários",
                                    "Gráficos ACF/PACF gerados"
                                  ],
                                  "tips": "Use PACF para estimar p: número de lags significativos.",
                                  "learningObjective": "Reconhecer e quantificar a contribuição AR para modelagem de autocorrelação.",
                                  "commonMistakes": [
                                    "Ignorar significância dos coeficientes",
                                    "Confundir lags de Y com lags de erros"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e interpretar os componentes MA(q)",
                                  "subSteps": [
                                    "Localize os coeficientes θ_1 a θ_q na saída do modelo ajustado.",
                                    "Explique que MA(q) modela dependências dos q erros passados ε_{t-j}.",
                                    "Verifique significância de θ_j e visualize com ACF (picos até lag q para MA).",
                                    "Entenda que MA contribui para previsões suavizando choques passados.",
                                    "Integre MA no cálculo de previsão: para h=1, inclui θ_j ε_{T+1-j} conhecidos."
                                  ],
                                  "verification": "Para ARMA(0,1), demonstre como θ_1 ε_{t-1} afeta Y_t.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos de output de ajuste ARMA",
                                    "Simulador de séries MA em Python"
                                  ],
                                  "tips": "ACF corta após q lags para MA pura; use para estimar q.",
                                  "learningObjective": "Diferenciar e quantificar o papel do MA na captura de ruído correlacionado.",
                                  "commonMistakes": [
                                    "Pensar que MA usa Y passadas ao invés de erros",
                                    "Subestimar impacto em previsões de curto prazo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar contribuição dos componentes para previsões pontuais",
                                  "subSteps": [
                                    "Recapitule a fórmula de previsão pontual h passos à frente: para h=1, E[Y_{T+1}] = ∑ φ_i Y_{T+1-i} + ∑ θ_j ε_{T+1-j}.",
                                    "Demonstre como AR usa observações recentes e MA usa resíduos recentes.",
                                    "Ajuste um modelo ARMA a dados reais estacionários e gere previsão pontual.",
                                    "Compare previsões AR-only, MA-only e ARMA completa para ver contribuições.",
                                    "Valide com erro de previsão out-of-sample."
                                  ],
                                  "verification": "Calcule manualmente a previsão pontual h=1 para um ARMA(1,1) com valores dados.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Dados estacionários sintéticos",
                                    "Código Python/R pronto para ajuste"
                                  ],
                                  "tips": "Para h>q, MA terms zeram, deixando previsão puramente AR.",
                                  "learningObjective": "Integrar AR e MA para computar e justificar previsões pontuais precisas.",
                                  "commonMistakes": [
                                    "Esquecer que ε futuro é zero",
                                    "Não truncar MA após q passos"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma série estacionária de vendas mensais de um produto (média 100, variância constante). Modelo ajustado: ARMA(1,1) com φ_1=0.6, θ_1=0.4. Últimas observações: Y_5=105, Y_4=98, ε_5=2, ε_4=1. Previsão pontual Y_6 = 0.6*105 + 0.4*2 = 63.8 + 0.8 = 64.6. AR contribui com memória das vendas passadas; MA suaviza o erro recente.",
                              "finalVerifications": [
                                "Identificar corretamente p e q de um output de modelo ARMA.",
                                "Escrever e interpretar a equação completa ARMA(p,q).",
                                "Calcular previsão pontual h=1 manualmente com valores fornecidos.",
                                "Explicar diferença entre contribuição AR e MA em uma previsão.",
                                "Gerar e interpretar PACF/ACF para estimar ordens p e q.",
                                "Validar estacionariedade antes de aplicar ARMA."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de φ_i e θ_j (100% correto).",
                                "Explicação clara e correta do papel de cada componente (rubrica 1-5).",
                                "Cálculo exato de previsão pontual sem erros aritméticos.",
                                "Uso apropriado de gráficos ACF/PACF para justificativa.",
                                "Demonstração de compreensão de estacionariedade.",
                                "Integração coerente de AR e MA em exemplos reais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Solução de equações lineares recorrentes e polinômios características.",
                                "Programação: Implementação de ARMA em Python (statsmodels) ou R (forecast).",
                                "Economia: Previsão de séries financeiras estacionárias como retornos ajustados.",
                                "Engenharia: Modelagem de sinais estacionários em controle de processos.",
                                "Machine Learning: Base para modelos SARIMA e LSTM em séries temporais."
                              ],
                              "realWorldApplication": "Em finanças, identificar componentes ARMA em retornos diários estacionários de ações para previsões pontuais de curto prazo, auxiliando traders em decisões de compra/venda; ou em meteorologia para prever temperaturas estacionárias sazonalmente ajustadas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.1.2",
                            "name": "Calcular previsões pontuais de h passos à frente",
                            "description": "Executar o cálculo manual e interpretativo de previsões pontuais para 1, 2 e h passos à frente em um modelo ARMA(p,q), considerando a reversibilidade para MA e estacionariedade para AR.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar fórmulas e condições do modelo ARMA(p,q)",
                                  "subSteps": [
                                    "Identifique os parâmetros p e q do modelo ARMA.",
                                    "Verifique estacionariedade para a parte AR (raízes do polinômio AR fora do círculo unitário).",
                                    "Verifique reversibilidade para a parte MA (raízes do polinômio MA fora do círculo unitário).",
                                    "Escreva a equação geral do modelo: Y_t - ∑φ_i Y_{t-i} = ε_t + ∑θ_j ε_{t-j}.",
                                    "Liste os resíduos ε_t até o tempo t disponíveis para previsão."
                                  ],
                                  "verification": "Confirme que as condições de estacionariedade e reversibilidade são atendidas e a equação está corretamente escrita.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel ou caderno",
                                    "Calculadora",
                                    "Documentação do modelo ARMA fornecido"
                                  ],
                                  "tips": "Use diagramas de raízes do polinômio para visualização rápida.",
                                  "learningObjective": "Compreender as premissas fundamentais para previsões válidas em ARMA.",
                                  "commonMistakes": [
                                    "Ignorar verificação de estacionariedade levando a previsões instáveis",
                                    "Confundir polinômios AR e MA"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular previsão pontual de 1 passo à frente (h=1)",
                                  "subSteps": [
                                    "Calcule Ŷ_{t+1} = ∑_{i=1}^p φ_i Y_{t+1-i} + ∑_{j=1}^q θ_j ε_{t+1-j} + ε_{t+1}, onde ε_{t+1}=0.",
                                    "Use os valores observados Y_t até Y_{t-p+1} e resíduos ε_t até ε_{t-q+1}.",
                                    "Registre o valor numérico da previsão.",
                                    "Calcule o erro padrão se aplicável (var(Ŷ_{t+1}) = σ²(1 + ∑θ_j² + 2∑covários)).",
                                    "Interprete: a previsão é o valor esperado condicional."
                                  ],
                                  "verification": "Compare com fórmula padrão ou software (ex: R forecast) para h=1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Dados da série temporal até t",
                                    "Parâmetros estimados φ, θ, σ²",
                                    "Software R ou Python (opcional)"
                                  ],
                                  "tips": "Mantenha resíduos passados em uma tabela para facilitar cálculos.",
                                  "learningObjective": "Executar e interpretar previsão pontual imediata em ARMA.",
                                  "commonMistakes": [
                                    "Esquecer de zerar ε_{t+1}",
                                    "Usar Y futuro incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular previsão pontual de 2 passos à frente (h=2)",
                                  "subSteps": [
                                    "Para Ŷ_{t+2} = ∑_{i=1}^p φ_i Ŷ_{t+2-i} + ∑_{j=1}^q θ_j ε̂_{t+2-j}, onde ε̂ são resíduos previstos (0 se j>1).",
                                    "Substitua Y_{t+1} por Ŷ_{t+1} do passo anterior.",
                                    "Ajuste resíduos: para MA, termos θ_j ε_{t+2-j} diminuem conforme h aumenta.",
                                    "Calcule numericamente e anote.",
                                    "Verifique recursividade na parte AR."
                                  ],
                                  "verification": "A previsão deve convergir para a média da série se estacionária.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Resultados do passo 2",
                                    "Tabela de resíduos e previsões",
                                    "Calculadora"
                                  ],
                                  "tips": "Construa uma tabela recursiva: colunas para h=1,2,... com linhas para termos AR e MA.",
                                  "learningObjective": "Aplicar recursão para previsões multi-step em ARMA.",
                                  "commonMistakes": [
                                    "Não substituir Y_{t+1} por previsão",
                                    "Persistir resíduos MA além de q passos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Generalizar e calcular para h passos à frente (h>2)",
                                  "subSteps": [
                                    "Para h > max(p,q): Ŷ_{t+h} ≈ μ (média) se AR estacionário e MA reversível.",
                                    "Use recursão: Ŷ_{t+h} = ∑φ_i Ŷ_{t+h-i} + ∑θ_j ε_{t+h-j} (ε futuros=0).",
                                    "Calcule para h=3 até o desejado, parando quando termos MA zeram.",
                                    "Discuta limite: para AR(p), decai exponencialmente; MA(q), zero após q.",
                                    "Implemente em loop manual ou código simples."
                                  ],
                                  "verification": "Para h grande, Ŷ_{t+h} deve aproximar μ; valide com exemplo conhecido.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Tabela recursiva dos passos anteriores",
                                    "Software para validação (R arima forecast)"
                                  ],
                                  "tips": "Para MA pura, previsões h>q são zero; memorize isso.",
                                  "learningObjective": "Generalizar algoritmo recursivo para qualquer h em ARMA.",
                                  "commonMistakes": [
                                    "Não zerar resíduos futuros",
                                    "Ignorar decaimento para h grande"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar previsões e verificar consistência",
                                  "subSteps": [
                                    "Compare Ŷ_{t+h} com série histórica e μ.",
                                    "Analise variância crescente com h.",
                                    "Discuta impactos de não-estacionariedade ou não-reversibilidade.",
                                    "Gere gráfico manual de previsões vs. observados.",
                                    "Resuma em relatório curto."
                                  ],
                                  "verification": "Previsões consistentes com propriedades do modelo (ex: convergência a μ).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Gráfico da série",
                                    "Resultados numéricos",
                                    "Caneta e papel"
                                  ],
                                  "tips": "Sempre relacione com contexto da série (ex: sazonalidade ausente).",
                                  "learningObjective": "Interpretar previsões pontuais no contexto prático.",
                                  "commonMistakes": [
                                    "Interpretar como certeza absoluta, ignorar incerteza"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere ARMA(1,1): Y_t = 0.5 Y_{t-1} + ε_t + 0.4 ε_{t-1}, σ²=1, μ=0. Dados até t=5: Y=[1,1.2,0.9,1.1,1.0], ε=[0.5,0.3,-0.1,0.2,0]. Ŷ_{6}=0.5*1.0 + 0.4*0=0.5; Ŷ_{7}=0.5*0.5 +0=0.25; para h>1, aproxima 0.",
                              "finalVerifications": [
                                "Previsões h=1,2 calculadas corretamente com recursão.",
                                "Termos MA zeram após q passos.",
                                "Convergência para média μ observada.",
                                "Condições de estacionariedade/reversibilidade confirmadas.",
                                "Variância de previsão aumenta com h.",
                                "Validação numérica com software coincide."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos recursivos (erro <1%).",
                                "Correta aplicação de condições AR/MA.",
                                "Generalização válida para qualquer h.",
                                "Interpretação contextual clara.",
                                "Uso eficiente de tabelas recursivas.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade: Uso de expectativas condicionais E[Y_{t+h}|F_t].",
                                "Programação: Implementação em loops recursivos (Python/R).",
                                "Economia: Previsão de PIB ou vendas em séries temporais.",
                                "Matemática: Polinômios característicos e raízes complexas."
                              ],
                              "realWorldApplication": "Em finanças, calcular previsões pontuais de preços de ações h dias à frente para estratégias de trading; em meteorologia, prever temperaturas h horas adiante para alertas climáticos, usando ARMA para séries estacionárias após diferenciação."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.1.3",
                            "name": "Implementar previsão pontual em software",
                            "description": "Utilizar funções como forecast() no pacote forecast do R para gerar previsões pontuais de modelos ARMA em dados estacionários simulados ou reais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambiente R e preparar dados estacionários",
                                  "subSteps": [
                                    "Instalar e carregar os pacotes necessários: install.packages(c('forecast', 'tseries')) e library(forecast); library(tseries)",
                                    "Gerar ou carregar dados estacionários simulados (ex: simular ARMA(1,1) com arima.sim()) ou usar dados reais como AirPassengers após diferenciação",
                                    "Verificar estacionariedade com teste ADF (adf.test()) e plotar a série para inspeção visual",
                                    "Transformar dados em objeto ts() com frequência apropriada (ex: frequency=12 para mensais)",
                                    "Dividir dados em treino e teste (ex: 80% treino)"
                                  ],
                                  "verification": "Ambiente configurado sem erros de pacote; teste ADF confirma estacionariedade (p-value < 0.05); plot mostra série estável",
                                  "estimatedTime": "20 minutos",
                                  "materials": "R e RStudio instalados; pacotes forecast, tseries; dataset simulado ou AirPassengers",
                                  "tips": "Sempre use set.seed() para reprodutibilidade em simulações",
                                  "learningObjective": "Preparar dados estacionários adequadamente para modelagem ARMA",
                                  "commonMistakes": "Esquecer de verificar estacionariedade antes; usar dados não-ts()"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Ajustar modelo ARMA aos dados de treino",
                                  "subSteps": [
                                    "Identificar ordens p, d, q usando auto.arima() ou ACF/PACF plots",
                                    "Ajustar modelo com Arima() especificando order=c(p,d,q) e method='ML'",
                                    "Examinar resumo do modelo (summary()) para coeficientes significativos e diagnósticos",
                                    "Verificar resíduos com Ljung-Box test (Box.test(residuals(model), type='Ljung-Box'))",
                                    "Plotar resíduos e QQ-plot para normalidade"
                                  ],
                                  "verification": "Modelo ajustado com AIC baixo; resíduos brancos (p-value Ljung-Box > 0.05); plots sem padrões",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Dados ts() preparados; funções auto.arima(), Arima()",
                                  "tips": "Comece com auto.arima() para sugestão automática de ordens",
                                  "learningObjective": "Selecionar e ajustar modelo ARMA ótimo para série estacionária",
                                  "commonMistakes": "Ignorar d>0 mesmo em dados supostamente estacionários; não checar resíduos"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar previsões pontuais com forecast()",
                                  "subSteps": [
                                    "Aplicar forecast(model, h=12) onde h é horizonte de previsão (ex: 12 períodos à frente)",
                                    "Extrair valores pontuais com as.numeric(forecast$mean)",
                                    "Plotar previsão com plot(forecast) incluindo intervalos de confiança",
                                    "Comparar previsões com dados de teste (se disponíveis) usando accuracy(forecast, test_data)",
                                    "Salvar previsões em vetor ou data.frame para relatório"
                                  ],
                                  "verification": "Objeto forecast gerado; plot mostra linha pontual suave; MAE/RMSE calculados < threshold razoável",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Modelo ARMA ajustado; função forecast()",
                                  "tips": "Especifique level=c(80,95) para intervalos; use h alinhado ao contexto",
                                  "learningObjective": "Implementar e extrair previsões pontuais de modelos ARMA",
                                  "commonMistakes": "Confundir mean com fitted; prever em dados não estacionários"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar e interpretar resultados da previsão",
                                  "subSteps": [
                                    "Calcular métricas: accuracy(forecast, test) para MAPE, MAE, RMSE",
                                    "Analisar cobertura de intervalos de confiança nos dados de teste",
                                    "Interpretar valores pontuais em contexto (ex: 'previsão de 150 unidades no mês 13')",
                                    "Gerar relatório com summary(forecast) e tabelas de valores",
                                    "Documentar limitações (ex: suposições de estacionariedade)"
                                  ],
                                  "verification": "Métricas calculadas; interpretação escrita; relatório salvo como PDF ou Rmd",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Objeto forecast; dados de teste; funções accuracy(), summary()",
                                  "tips": "Use autoplot(forecast) do ggplot2 para visualizações profissionais",
                                  "learningObjective": "Avaliar qualidade e interpretar previsões pontuais ARMA",
                                  "commonMistakes": "Superestimar precisão sem teste out-of-sample; ignorar largura de intervalos"
                                }
                              ],
                              "practicalExample": "Simule dados de vendas mensais estacionárias com arima.sim(model=list(ar=0.5, ma=0.3), n=100). Ajuste ARMA(1,1), gere forecast(h=12). Compare com 20 pontos hold-out: previsão pontual para mês 101 ~450 unidades, MAE=15.2.",
                              "finalVerifications": [
                                "forecast() executado sem erros e retorna objeto válido",
                                "Previsões pontuais extraídas corretamente como vetor numérico",
                                "Plots mostram alinhamento lógico com tendência histórica",
                                "Métricas de accuracy calculadas e abaixo de benchmarks (ex: MAPE<10%)",
                                "Resíduos do modelo confirmam adequação ARMA",
                                "Relatório inclui valores pontuais, intervalos e interpretação"
                              ],
                              "assessmentCriteria": [
                                "Correto uso de forecast() com modelo ARMA ajustado (100%)",
                                "Verificação de estacionariedade e resíduos brancos (90-100%)",
                                "Extração precisa de mean pontual e métricas de erro (90-100%)",
                                "Visualizações claras e interpretação contextual (80-100%)",
                                "Código reprodutível com set.seed() e comentários (80-100%)",
                                "Tratamento de edge cases como h=0 ou dados curtos (70-100%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação em R (manipulação de dados ts e pacotes)",
                                "Estatística inferencial (testes de hipóteses como ADF)",
                                "Machine Learning (previsão como subárea de séries temporais)",
                                "Análise de Dados Exploratória (ACF/PACF, plots)",
                                "Gestão de Projetos (relatórios e validação de modelos)"
                              ],
                              "realWorldApplication": "Em empresas de varejo, usar ARMA para prever vendas mensais estacionárias ajustadas sazonalmente, otimizando estoque e reduzindo custos em 10-20%; ex: Walmart prevendo demanda de produtos estáveis."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.5.2",
                        "name": "Intervalos de Previsão em Modelos ARMA",
                        "description": "Construção de intervalos de confiança para previsões pontuais em séries temporais estacionárias modeladas por ARMA, considerando variância condicional e incondicional.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.2.1",
                            "name": "Calcular variância das previsões em ARMA",
                            "description": "Derivar e computar a variância das previsões pontuais de h passos à frente, distinguindo entre variância para modelos AR, MA e ARMA em processos estacionários.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Previsões Pontuais em Modelos ARMA",
                                  "subSteps": [
                                    "Defina um processo ARMA(p,q) estacionário: Y_t = ∑ φ_i Y_{t-i} + ∑ θ_j ε_{t-j} + ε_t",
                                    "Explique a previsão pontual h-steps à frente: Ŷ_{t+h|t} = E[Y_{t+h} | Y_t, Y_{t-1}, ...]",
                                    "Discuta a representação em infinito AR(∞) e MA(∞) para simplificar previsões",
                                    "Identifique que erros de previsão η_{t+h|t} = Y_{t+h} - Ŷ_{t+h|t} são função dos ε futuros",
                                    "Verifique estacionariedade via raízes do polinômio característico"
                                  ],
                                  "verification": "Escreva corretamente a fórmula de Ŷ_{t+1|t} para um ARMA(1,1) e explique os termos condicionais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula sobre ARMA",
                                    "Livro 'Time Series Analysis' de Brockwell & Davis (cap. 8)",
                                    "Calculadora ou Python/Jupyter para simulações"
                                  ],
                                  "tips": "Sempre condicione na informação disponível até t; use recursão para h > q em MA.",
                                  "learningObjective": "Compreender a estrutura das previsões pontuais e sua dependência em parâmetros ARMA.",
                                  "commonMistakes": [
                                    "Confundir previsão condicional com incondicional",
                                    "Ignorar a estacionariedade ao derivar expectativas",
                                    "Esquecer que ε_{t+j|t} = 0 para j > 0"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar Variância das Previsões em Modelos AR(p)",
                                  "subSteps": [
                                    "Para AR(p), mostre que Var(η_{t+h|t}) = σ² [1 + ∑_{k=1}^{h-1} φ_k² + 2 ∑_{m=1}^{h-1} ∑_{k=1}^{m} φ_k φ_{k+m-h}] recursivamente",
                                    "Comece com h=1: Var(Ŷ_{t+1|t}) = φ_1² Var(Ŷ_{t|t-1}) + σ², mas simplifique para AR(1)",
                                    "Para AR(1): prove que Var(η_{t+h|t}) = σ² (1 - φ^{2h}) / (1 - φ²)",
                                    "Generalize para AR(p) usando a recursão η_{t+h|t} = ∑ φ_i η_{t+h-i|t} + ε_{t+h}",
                                    "Calcule numericamente para um AR(1) com φ=0.5, σ²=1, h=3"
                                  ],
                                  "verification": "Derive e compute Var(η_{t+2|t}) para AR(1), confirmando com fórmula fechada.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Papel e lápis para derivações",
                                    "Software R ou Python (pacote 'statsmodels')",
                                    "Tabela de coeficientes AR"
                                  ],
                                  "tips": "Use a forma recursiva para evitar somas complexas; teste com simulações Monte Carlo.",
                                  "learningObjective": "Dominar a derivação da variância crescente das previsões em AR(p).",
                                  "commonMistakes": [
                                    "Usar variância incondicional em vez de condicional",
                                    "Erros na recursão dos coeficientes φ",
                                    "Confundir com autocovariância da série"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar Variância das Previsões em Modelos MA(q)",
                                  "subSteps": [
                                    "Para MA(q), note que η_{t+h|t} = ε_{t+h} + θ_1 ε_{t+h-1|t} + ... mas ε_{t+j|t}=0 para j>0",
                                    "Mostre que para h > q, Var(η_{t+h|t}) = σ² (constante)",
                                    "Para h ≤ q, Var(η_{t+h|t}) = σ² (1 + θ_h² + 2 ∑_{j=1}^{h-1} θ_j θ_{j+h})",
                                    "Exemplo MA(1): Var(η_{t+1|t}) = σ², Var(η_{t+2|t}) = σ² (1 + θ²)",
                                    "Compare com AR para destacar convergência rápida em MA"
                                  ],
                                  "verification": "Escreva fórmulas para Var em MA(2), h=1,2,3 e verifique limite h→∞.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de derivações",
                                    "Exemplos de código em Python para MA",
                                    "Gráficos de variância vs h"
                                  ],
                                  "tips": "Lembre que MA tem memória finita; plote Var(h) para visualizar platô.",
                                  "learningObjective": "Entender por que variância em MA estabiliza rapidamente.",
                                  "commonMistakes": [
                                    "Incluir θ_j para j > q em somas",
                                    "Confundir θ com φ na notação",
                                    "Esquecer o fator 2 nas covariâncias cruzadas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Generalizar para ARMA(p,q) e Computar Numericamente",
                                  "subSteps": [
                                    "Combine AR e MA: η_{t+h|t} segue recursão AR com inovações MA truncadas",
                                    "Fórmula geral: ψ_j coeficientes MA(∞), Var(η_{t+h|t}) = σ² ∑_{j=0}^∞ ψ_j² para h grande, mas exata via recursão",
                                    "Implemente função em Python/R para calcular Var(h) dado φ, θ, σ²",
                                    "Ajuste um ARMA(1,1) a dados simulados e compute variâncias para h=1 a 10",
                                    "Construa intervalo de previsão: Ŷ ± 1.96 √Var(η)"
                                  ],
                                  "verification": "Implemente código que reproduz variâncias para ARMA(1,1) e valide com simulações.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Python com statsmodels ou R com forecast",
                                    "Dados simulados ARMA",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Use pacotes prontos para validação, mas derive manualmente primeiro.",
                                  "learningObjective": "Aplicar derivações em ARMA geral com implementação computacional.",
                                  "commonMistakes": [
                                    "Erro na estimação de σ² do modelo ajustado",
                                    "Ignorar inovações condicionais em código",
                                    "Usar aproximação normal sem verificar estacionariedade"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar e Verificar Resultados",
                                  "subSteps": [
                                    "Compare curvas de Var(h) para AR, MA, ARMA: crescente, platô, híbrida",
                                    "Discuta implicações para intervalos de confiança em previsões longas",
                                    "Teste sensibilidade a parâmetros (ex: φ próximo a 1 aumenta Var)",
                                    "Valide com bootstrap ou simulações para cobertura de 95%",
                                    "Documente fórmulas e código em relatório"
                                  ],
                                  "verification": "Gere gráfico de √Var(h) vs h e interprete diferenças entre modelos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Gráficos em Matplotlib/ggplot",
                                    "Relatório template",
                                    "Dados reais opcionais (ex: série econômica)"
                                  ],
                                  "tips": "Sempre plote para insight visual; use log-scale para grandes h.",
                                  "learningObjective": "Interpretar variâncias no contexto de confiabilidade de previsões.",
                                  "commonMistakes": [
                                    "Interpretar Var como desvio absoluto sem raiz",
                                    "Generalizar fórmulas sem contexto estacionário",
                                    "Subestimar impacto de não-estacionariedade"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um modelo ARMA(1,1) ajustado a dados mensais de PIB (φ=0.7, θ=0.4, σ²=0.1), calcule Var(Ŷ_{t+3|t}) = σ² (1 + ψ_1² + ψ_2²) onde ψ são coefs MA(∞), resultando em ≈0.15, permitindo intervalo [Ŷ - 1.96√0.15, Ŷ + 1.96√0.15] para previsão trimestral.",
                              "finalVerifications": [
                                "Derivação correta de fórmulas para AR(p), MA(q) e ARMA(p,q)",
                                "Cálculos numéricos coincidem com implementações em software",
                                "Gráficos de Var(h) mostram comportamento esperado (crescente em AR, platô em MA)",
                                "Intervalos de previsão têm cobertura próxima a 95% em simulações",
                                "Distinção clara entre variâncias condicionais e incondicionais",
                                "Código reproduzível e comentado"
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas derivações (fórmulas exatas)",
                                "Correção computacional (erros <1% vs simulações)",
                                "Profundidade de substeps (cobertura completa de casos)",
                                "Interpretação contextual (implicações para h grande)",
                                "Uso eficiente de materiais e tempo",
                                "Identificação e correção de erros comuns"
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade: Cálculo de variâncias condicionais e covariâncias",
                                "Programação: Implementação numérica em Python/R (vetorização)",
                                "Econometria: Previsões em séries financeiras com risco",
                                "Machine Learning: Similar a uncertainty quantification em modelos de sequência",
                                "Cálculo Numérico: Recursão e estabilidade de algoritmos"
                              ],
                              "realWorldApplication": "Em meteorologia, calcular variância de previsões de temperatura 7 dias à frente com ARMA para alertas de confiança; em finanças, dimensionar posições baseadas no risco de previsões de retornos de ações, evitando perdas por superconfiança em horizontes longos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.2.2",
                            "name": "Construir intervalos de confiança",
                            "description": "Aplicar aproximações normais ou distribuição t para construir intervalos de previsão de 95% de confiança em previsões ARMA, interpretando o alargamento com o horizonte h.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Previsões Pontuais do Modelo ARMA",
                                  "subSteps": [
                                    "Ajuste o modelo ARMA aos dados da série temporal estacionária usando software como R ou Python.",
                                    "Gere previsões pontuais para horizontes h = 1 até H (ex: 12 meses).",
                                    "Extraia os resíduos do modelo ajustado para uso posterior.",
                                    "Verifique a estacionariedade dos resíduos via teste Ljung-Box.",
                                    "Documente as previsões pontuais em uma tabela."
                                  ],
                                  "verification": "Previsões pontuais geradas e resíduos extraídos corretamente, sem erros de convergência no ajuste.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software R (pacote forecast ou stats)",
                                    "Dataset de série temporal estacionária (ex: AirPassengers)",
                                    "Notebook Jupyter ou R Markdown"
                                  ],
                                  "tips": "Use funções prontas como forecast() no R para agilizar; sempre plote as previsões para visual inspeção.",
                                  "learningObjective": "Compreender como obter previsões pontuais como base para intervalos de confiança.",
                                  "commonMistakes": [
                                    "Ajustar ARMA sem verificar estacionariedade",
                                    "Ignorar warnings de convergência no ajuste"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a Variância do Erro de Previsão para Horizonte h",
                                  "subSteps": [
                                    "Recupere a variância dos resíduos (sigma^2) do modelo ajustado.",
                                    "Calcule a variância de previsão ψ_h usando recursão: ψ_0 = 1, ψ_h = φ_1 ψ_{h-1} + ... + φ_p ψ_{h-p} para AR(p), similar para MA.",
                                    "Some as variâncias: Var(ê_h) = σ^2 (1 + ψ_1^2 + ... + ψ_h^2).",
                                    "Implemente em código ou calcule manualmente para h pequenos.",
                                    "Plote Var(ê_h) vs h para observar o crescimento."
                                  ],
                                  "verification": "Variâncias calculadas coincidem com output de funções como predict() com se=TRUE; gráfico mostra aumento com h.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código R/Python para recursão MA/infinita",
                                    "Fórmulas de ARMA em referência (ex: Brockwell & Davis)",
                                    "Calculadora ou spreadsheet para validação manual"
                                  ],
                                  "tips": "Para ARMA(1,1), use fórmulas fechadas quando possível para verificação rápida.",
                                  "learningObjective": "Dominar o cálculo da variância condicional de previsão, chave para o alargamento dos intervalos.",
                                  "commonMistakes": [
                                    "Confundir variância de resíduos com variância de previsão",
                                    "Esquecer o termo 1 na soma de ψ"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Selecionar e Calcular o Quantil Crítico Apropriado",
                                  "subSteps": [
                                    "Avalie o tamanho da amostra n: se n > 30, use normal N(0,1); senão, distribuição t com n-p-q-1 graus de liberdade.",
                                    "Para 95% confiança, encontre z_{0.975} ≈ 1.96 ou t crítico via qnorm() ou qt() no R.",
                                    "Ajuste para horizonte h se usando t (df fixo, mas multiplique pelo fator sqrt(1 + 1/n) approx).",
                                    "Registre os quantis para cada h.",
                                    "Compare z vs t em um exemplo numérico."
                                  ],
                                  "verification": "Quantis corretos: z=1.96 para normal, t≈2.0+ para amostras pequenas; código reproduz valores tabelados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Tabelas de distribuição normal/t",
                                    "Funções qnorm/qt no R/Python (scipy.stats)"
                                  ],
                                  "tips": "Sempre prefira normal para séries longas; teste sensibilidade trocando distribuições.",
                                  "learningObjective": "Escolher aproximação correta baseada em n, garantindo validade assintótica.",
                                  "commonMistakes": [
                                    "Usar sempre normal sem checar n",
                                    "Confundir α/2 com α"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir os Intervalos de Confiança de 95%",
                                  "subSteps": [
                                    "Para cada h: limite inferior = ŷ_h - quantil * sqrt(Var(ê_h)), superior = ŷ_h + quantil * sqrt(Var(ê_h)).",
                                    "Implemente em loop ou vetorizado no software.",
                                    "Gere bandas de confiança plotando IC ao redor das previsões.",
                                    "Verifique cobertura: simule dados e cheque % de cobertura ≈95%.",
                                    "Exporte tabela e gráfico dos IC."
                                  ],
                                  "verification": "Intervalos simétricos em torno de ŷ_h, alargando com h; simulação cobre 95% dos pontos verdadeiros.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código para plot CI (ggplot ou matplotlib)",
                                    "Função forecast() com level=95 no R"
                                  ],
                                  "tips": "Use intervalos fan-chart para visualização clara do alargamento.",
                                  "learningObjective": "Construir IC numericamente e visualmente corretos.",
                                  "commonMistakes": [
                                    "Esquecer sqrt na multiplicação",
                                    "Usar variância em vez de desvio-padrão"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar Intervalos e o Alargamento com Horizonte h",
                                  "subSteps": [
                                    "Analise: IC estreitos para h=1 (alta certeza), alargam por acumulação de incerteza.",
                                    "Explique: ψ_h →1 para AR estacionário, Var cresce linearmente com h.",
                                    "Discuta implicações: previsões longas têm alta incerteza, prefira h curtos.",
                                    "Compare com dados reais: IC contém valores observados?",
                                    "Escreva relatório resumindo achados."
                                  ],
                                  "verification": "Relatório explica corretamente por que IC alarga (crescimento de Var(ê_h)), com evidências gráficas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Gráficos gerados no step 4",
                                    "Template de relatório"
                                  ],
                                  "tips": "Foquem na intuição: cada passo à frente adiciona ruído novo.",
                                  "learningObjective": "Interpretar incerteza crescente, guiando decisões práticas.",
                                  "commonMistakes": [
                                    "Ignorar alargamento como artefato",
                                    "Superestimar precisão em h longos"
                                  ]
                                }
                              ],
                              "practicalExample": "Ajuste um modelo ARMA(1,1) aos dados mensais de passageiros aéreos (AirPassengers, após diferenciação para estacionariedade). Gere previsões para h=1 a 12 meses, calcule IC 95% usando aproximação normal, e plote mostrando alargamento das bandas de confiança.",
                              "finalVerifications": [
                                "Variâncias de previsão calculadas corretamente e crescem com h.",
                                "Quantis escolhidos adequadamente (normal/t baseado em n).",
                                "Intervalos construídos simetricamente e plotados corretamente.",
                                "Interpretação verbaliza alargamento devido a acumulação de variância.",
                                "Simulação valida cobertura próxima a 95%.",
                                "Relatório integra todos elementos sem erros matemáticos."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de ψ_h e Var(ê_h) (80% peso).",
                                "Correta seleção e aplicação de quantis (15% peso).",
                                "Qualidade da visualização e interpretação (5% peso).",
                                "Ausência de erros comuns como confusão de variâncias.",
                                "Relatório claro e completo.",
                                "Validação via simulação ou dados reais."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade: Distribuições normal e t para inferência.",
                                "Programação: Implementação numérica em R/Python (loops, vetores).",
                                "Análise de Dados: Visualização com ggplot/matplotlib.",
                                "Econometria: Aplicação em previsões macroeconômicas."
                              ],
                              "realWorldApplication": "Em finanças, construir IC para previsões de preços de ações com ARMA, ajudando traders a quantificar risco em horizontes de 1-6 meses; em meteorologia, para bandas de confiança em temperaturas futuras, informando alertas climáticos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.2.3",
                            "name": "Visualizar e interpretar intervalos de previsão",
                            "description": "Gerar gráficos de previsões com intervalos de confiança usando ferramentas como ggplot2 no R e analisar a incerteza crescente em horizontes longos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o modelo ARMA e gerar previsões com intervalos de confiança",
                                  "subSteps": [
                                    "Carregue uma série temporal estacionária de exemplo (ex: dados de passageiros aéreos do pacote datasets).",
                                    "Teste a estacionariedade usando testes como ADF para confirmar adequação.",
                                    "Ajuste um modelo ARMA(p,q) usando a função arima() com ordem apropriada baseada em ACF/PACF.",
                                    "Gere previsões com intervalos usando forecast(modelo, h=12, level=95), onde h é o horizonte de previsão."
                                  ],
                                  "verification": "Verifique se o objeto forecast contém componentes 'mean', 'lower' e 'upper' com valores numéricos válidos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "R instalado",
                                    "Pacotes: forecast, ggplot2, tseries (para testes de estacionariedade)",
                                    "Dados de exemplo: AirPassengers"
                                  ],
                                  "tips": [
                                    "Sempre especifique level=c(80,95) para múltiplos intervalos.",
                                    "Use autoplot(forecast_obj) inicialmente para inspeção rápida."
                                  ],
                                  "learningObjective": "Compreender como os intervalos de confiança são calculados com base na variância residual e covariância do modelo ARMA.",
                                  "commonMistakes": [
                                    "Ajustar modelo em dados não estacionários, levando a intervalos inválidos.",
                                    "Esquecer de especificar o horizonte h, resultando em previsões curtas demais."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar dados para visualização em formato tidy",
                                  "subSteps": [
                                    "Extraia as séries observada, previsão pontual (mean), lower e upper dos intervalos do objeto forecast.",
                                    "Crie um data frame com colunas: tempo (índice), valor, tipo (observed, point, lower, upper).",
                                    "Use tidyr::pivot_longer() ou similar para formatar em formato longo adequado para ggplot2.",
                                    "Adicione rótulos para legendas e defina o ponto de corte entre observado e previsto."
                                  ],
                                  "verification": "Data frame resultante tem 4-5 colunas e linhas cobrindo toda a série + previsão, sem NAs.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Pacote tidyverse (inclui ggplot2 e tidyr)",
                                    "Objeto forecast do step anterior"
                                  ],
                                  "tips": [
                                    "Use fortify(forecast_obj) do pacote fabletools para automação.",
                                    "Garanta que o índice de tempo seja contínuo para evitar gaps no gráfico."
                                  ],
                                  "learningObjective": "Dominar manipulação de dados de forecast para visualização flexível com ggplot2.",
                                  "commonMistakes": [
                                    "Misturar escalas de tempo entre observado e previsto.",
                                    "Ignorar NAs em lower/upper, causando erros no ribbon."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir o gráfico de previsões com intervalos usando ggplot2",
                                  "subSteps": [
                                    "Inicie com ggplot(data, aes(x=tempo, y=valor, color=tipo)).",
                                    "Adicione geom_line() para observed e point forecast.",
                                    "Use geom_ribbon(aes(ymin=lower, ymax=upper, fill=tipo), alpha=0.3) para intervalos.",
                                    "Personalize com labs(title='Previsão com Intervalos de Confiança', x='Tempo', y='Valor'), theme_minimal() e scale_color_manual().",
                                    "Adicione linha vertical no ponto de previsão com geom_vline()"
                                  ],
                                  "verification": "Gráfico renderizado mostra linha observada, previsão pontual e faixas de confiança se alargando progressivamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Pacote ggplot2",
                                    "Data frame tidy do step anterior"
                                  ],
                                  "tips": [
                                    "Use alpha baixo no ribbon para transparência e sobreposição visual clara.",
                                    "Experimente facet_wrap se múltiplos intervalos (ex: 80% e 95%)."
                                  ],
                                  "learningObjective": "Aplicar camadas ggplot2 para representar incerteza visualmente de forma intuitiva.",
                                  "commonMistakes": [
                                    "Esquecer alpha no ribbon, obscurecendo dados subjacentes.",
                                    "Cores inadequadas que não distinguem observed de forecast."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar os intervalos de previsão e analisar incerteza crescente",
                                  "subSteps": [
                                    "Identifique o formato cônico dos intervalos (alargando com o tempo).",
                                    "Explique probabilisticamente: 95% das previsões reais caem dentro das faixas.",
                                    "Analise razões: acumulação de erros de previsão e variância crescente em horizontes longos.",
                                    "Discuta implicações: confiança baixa em previsões longas, preferir horizontes curtos.",
                                    "Escreva um relatório curto resumindo insights do gráfico específico."
                                  ],
                                  "verification": "Relatório escrito descreve corretamente o alargamento e suas causas, com referência ao gráfico.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Gráfico gerado do step 3",
                                    "Ferramenta de texto (R Markdown ou notebook)"
                                  ],
                                  "tips": [
                                    "Compare largura de intervalos em h=1 vs h=12 para quantificar crescimento.",
                                    "Relacione com propriedades teóricas de ARMA (variância assintótica)."
                                  ],
                                  "learningObjective": "Interpretar visualmente a propagação de incerteza em séries temporais.",
                                  "commonMistakes": [
                                    "Confundir intervalo de confiança com probabilidade pontual.",
                                    "Ignorar que intervalos assumem normalidade residual."
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dados AirPassengers (passageiros aéreos mensais), ajuste ARMA(1,1) após log e diferenciação para estacionariedade. Gere forecast h=24, plote com ggplot2 mostrando faixas 95% alargando de ~10% no curto prazo para >50% em 2 anos, interpretando maior risco em planejamento de longo prazo para companhias aéreas.",
                              "finalVerifications": [
                                "Gráfico exibe faixas de confiança se alargando monotonicamente com o horizonte.",
                                "Previsão pontual alinhada com tendência observada.",
                                "Interpretação escrita menciona pelo menos 3 razões para incerteza crescente.",
                                "Código R reproduzível gera o mesmo gráfico.",
                                "Relatório discute limitações dos intervalos em horizontes longos."
                              ],
                              "assessmentCriteria": [
                                "Correção na geração de intervalos (verificação de lower/upper).",
                                "Qualidade visual: legibilidade, cores intuitivas, escalas adequadas.",
                                "Profundidade da interpretação: ligação com teoria ARMA e incerteza.",
                                "Eficiência do código: uso limpo de tidyverse sem loops desnecessários.",
                                "Criatividade: adição de elementos como múltiplos levels ou comparações."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade: Compreensão de intervalos baseados em distribuições normais e quantis.",
                                "Programação: Manipulação de dados tidy e gramática ggplot2.",
                                "Visualização de Dados: Princípios de Edward Tufte para representar incerteza.",
                                "Econometria: Aplicação em previsão econômica com bandas de confiança.",
                                "Machine Learning: Paralelo com previsão probabilística em modelos como Prophet."
                              ],
                              "realWorldApplication": "Em finanças, bancos usam gráficos de intervalos de previsão para Value-at-Risk (VaR) em retornos de portfólio, decidindo limites de exposição baseado no alargamento das faixas em horizontes de 1-30 dias, evitando perdas catastróficas em cenários incertos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.5.3",
                        "name": "Validação de Modelos ARMA",
                        "description": "Técnicas estatísticas para avaliar a adequação e robustez de modelos ARMA ajustados a séries temporais estacionárias, garantindo previsões confiáveis.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.3.1",
                            "name": "Analisar resíduos de modelos ARMA",
                            "description": "Verificar a independência e homocedasticidade dos resíduos via ACF, PACF e teste Ljung-Box, identificando inadequações no modelo ARMA.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Extrair e preparar os resíduos do modelo ARMA",
                                  "subSteps": [
                                    "Ajuste o modelo ARMA aos dados da série temporal usando software como R (função arima) ou Python (statsmodels).",
                                    "Extraia os resíduos utilizando comandos específicos (ex: residuals(model) em R ou model.resid em Python).",
                                    "Visualize os resíduos em um gráfico de séries temporais para inspeção inicial.",
                                    "Padronize os resíduos se necessário (subtraia a média e divida pelo desvio padrão).",
                                    "Salve os resíduos em um objeto para análises subsequentes."
                                  ],
                                  "verification": "Confirme que os resíduos foram extraídos corretamente comparando com valores esperados e visualizando o plot sem padrões óbvios.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software R ou Python com bibliotecas statsmodels/forecast",
                                    "Dados de série temporal ajustada (ex: AirPassengers dataset)"
                                  ],
                                  "tips": "Sempre verifique se o modelo foi ajustado corretamente antes de extrair resíduos; use summary() para inspeção inicial.",
                                  "learningObjective": "Compreender como obter resíduos de um modelo ARMA e prepará-los para diagnóstico.",
                                  "commonMistakes": [
                                    "Usar resíduos brutos sem padronização.",
                                    "Confundir resíduos com valores ajustados.",
                                    "Não visualizar inicialmente."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar autocorrelação com gráficos ACF e PACF",
                                  "subSteps": [
                                    "Gere o gráfico de autocorrelação (ACF) dos resíduos com lags suficientes (ex: 20 lags).",
                                    "Gere o gráfico de autocorrelação parcial (PACF) dos resíduos.",
                                    "Identifique se as autocorrelações estão dentro das bandas de confiança (95%).",
                                    "Anote lags significativos que indicam dependência residual.",
                                    "Compare com critérios teóricos: ACF/PACF devem se assemelhar a ruído branco."
                                  ],
                                  "verification": "Gráficos ACF e PACF mostram barras dentro das bandas de confiança para a maioria dos lags.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Funções acf() e pacf() em R; plot_acf() e plot_pacf() em Python",
                                    "Resíduos extraídos do step anterior"
                                  ],
                                  "tips": "Use lags = 2*p + 2*q + 10 para cobertura adequada; ignore lag 0 que é sempre 1.",
                                  "learningObjective": "Diagnosticar dependências lineares nos resíduos via funções de autocorrelação.",
                                  "commonMistakes": [
                                    "Interpretar lag 0 como problema.",
                                    "Usar poucos lags.",
                                    "Confundir ACF com PACF."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar o teste de Ljung-Box para independência",
                                  "subSteps": [
                                    "Aplique o teste Ljung-Box aos resíduos (ex: Box.test(residuals, lag=10, type='Ljung-Box') em R).",
                                    "Escolha lags apropriados (ex: 10-20) baseado no tamanho da amostra.",
                                    "Interprete o p-valor: >0.05 indica independência (não rejeita H0 de ruído branco).",
                                    "Repita para diferentes lags se necessário.",
                                    "Registre estatística Q e p-valor para relatório."
                                  ],
                                  "verification": "p-valor > 0.05 para lags relevantes, confirmando ausência de autocorrelação serial.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Função Box.test() em R ou acorr_ljungbox() em Python statsmodels",
                                    "Resíduos padronizados"
                                  ],
                                  "tips": "Teste múltiplos lags mas foque em lags até 20; p-valor baixo indica inadequação.",
                                  "learningObjective": "Aplicar teste formal de independência serial nos resíduos.",
                                  "commonMistakes": [
                                    "Usar poucos lags.",
                                    "Ignorar ajuste por tamanho de amostra.",
                                    "Confundir com teste de normalidade."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar homocedasticidade e interpretar inadequações",
                                  "subSteps": [
                                    "Plote resíduos vs valores ajustados ou tempo para detectar heterocedasticidade.",
                                    "Aplique teste Breusch-Pagan ou White para homocedasticidade.",
                                    "Analise Q-Q plot para normalidade aproximada.",
                                    "Sintetize achados: identifique padrões (ex: autocorrelação em lag 1 sugere AR(1) adicional).",
                                    "Recomende ajustes no modelo ARMA se inadequações detectadas."
                                  ],
                                  "verification": "Resíduos exibem variância constante e sem padrões nos plots; testes confirmam homocedasticidade.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Funções bptest() em R ou het_breuschpagan() em Python",
                                    "Resíduos e valores fitted"
                                  ],
                                  "tips": "Combine plots visuais com testes; heterocedasticidade pode requerer modelo ARCH/GARCH.",
                                  "learningObjective": "Avaliar homocedasticidade e sintetizar diagnóstico para melhoria do modelo.",
                                  "commonMistakes": [
                                    "Apenas plots sem testes.",
                                    "Ignorar normalidade.",
                                    "Não propor soluções."
                                  ]
                                }
                              ],
                              "practicalExample": "Usando o dataset AirPassengers em R: ajuste ARIMA(0,1,1), extraia resíduos, plote ACF/PACF (devem ser ruído branco após diferenciação), aplique Ljung-Box (p>0.05) e verifique homocedasticidade via plot resíduos vs fitted, identificando se o modelo captura a dinâmica adequadamente.",
                              "finalVerifications": [
                                "ACF e PACF dos resíduos mostram ausência de significância além das bandas de confiança.",
                                "Teste Ljung-Box apresenta p-valor > 0.05 para lags 1-20.",
                                "Plot de resíduos vs fitted não exibe padrões de dispersão crescente/decrescente.",
                                "Teste Breusch-Pagan confirma homocedasticidade (p>0.05).",
                                "Relatório identifica corretamente qualquer inadequação e sugere ajustes.",
                                "Resíduos se assemelham a ruído branco visualmente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na extração e preparação dos resíduos (100% correto).",
                                "Interpretação correta de ACF/PACF (identifica padrões ausentes/presentes).",
                                "Execução e interpretação adequada do teste Ljung-Box (p-valor e conclusão).",
                                "Detecção de homocedasticidade via plots e testes formais.",
                                "Síntese coerente de resultados com recomendações acionáveis.",
                                "Uso eficiente de software e documentação clara."
                              ],
                              "crossCurricularConnections": [
                                "Programação Estatística (R/Python para análise de séries).",
                                "Estatística Inferencial (testes de hipóteses como Ljung-Box).",
                                "Análise Exploratória de Dados (plots diagnósticos).",
                                "Machine Learning (validação de modelos preditivos).",
                                "Econometria (diagnóstico em modelos de séries temporais financeiras)."
                              ],
                              "realWorldApplication": "Em finanças, validar modelos ARMA para previsão de retornos de ações, garantindo previsões confiáveis; em supply chain, analisar resíduos de demanda sazonal para otimizar estoques e evitar sobreprevisão."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.3.2",
                            "name": "Aplicar critérios de informação AIC e BIC",
                            "description": "Comparar múltiplos modelos ARMA usando critérios AIC e BIC para seleção do melhor ajuste parsimonioso em séries estacionárias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos de AIC e BIC",
                                  "subSteps": [
                                    "Estude a fórmula do AIC: AIC = -2 * log(L) + 2 * k, onde L é a verossimilhança e k o número de parâmetros.",
                                    "Analise a fórmula do BIC: BIC = -2 * log(L) + k * log(n), destacando a penalização maior para amostras pequenas.",
                                    "Compare AIC (penalização por parâmetros) vs BIC (penalização por tamanho da amostra), entendendo que BIC favorece modelos mais parcimoniosos.",
                                    "Revise propriedades: valores menores indicam melhor ajuste; AIC permite overfitting leve, BIC é mais conservador.",
                                    "Pratique com exemplos teóricos: calcule manualmente para um modelo AR(1) fictício."
                                  ],
                                  "verification": "Resuma em 3 frases as diferenças entre AIC e BIC e forneça um exemplo numérico simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação de estatística (livro 'Time Series Analysis' de Hamilton ou notas online), calculadora ou planilha Excel.",
                                  "tips": "Visualize fórmulas com diagramas para fixar a relação entre verossimilhança e penalização.",
                                  "learningObjective": "Explicar matematicamente AIC e BIC e suas implicações na seleção de modelos.",
                                  "commonMistakes": "Confundir log(L) com RSS; ignorar que n afeta apenas BIC."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar e Testar Estacionariedade da Série Temporal",
                                  "subSteps": [
                                    "Carregue dados de uma série temporal estacionária (ex: AirPassengers diferenciado).",
                                    "Aplique teste ADF para confirmar estacionariedade (p-value < 0.05).",
                                    "Plote ACF e PACF para identificar ordens iniciais p e q de ARMA.",
                                    "Gere grid de modelos candidatos: ARMA(p,q) para p,q de 0 a 3.",
                                    "Ajuste preliminarmente modelos usando máxima verossimilhança."
                                  ],
                                  "verification": "Confirme estacionariedade via teste ADF e liste 6-9 modelos ARMA candidatos com ordens p,q.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python (statsmodels, pandas) ou R (forecast package), dataset estacionário (ex: de statsmodels.datasets).",
                                  "tips": "Use auto_arima() inicialmente para inspiração, mas ajuste manualmente para aprendizado.",
                                  "learningObjective": "Preparar dados estacionários e gerar candidatos de modelos ARMA.",
                                  "commonMistakes": "Prosseguir sem testar estacionariedade; escolher grid muito amplo (>10 modelos)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular e Comparar AIC e BIC para Modelos ARMA",
                                  "subSteps": [
                                    "Ajuste todos os modelos candidatos usando função fit() em statsmodels ou arima() em R.",
                                    "Extraia valores de AIC e BIC de cada modelo ajustado.",
                                    "Crie tabela comparativa: ordens p,q, AIC, BIC, log-likelihood.",
                                    "Identifique o modelo com menor AIC e menor BIC separadamente.",
                                    "Analise discrepâncias: se AIC e BIC divergem, discuta implicações de parcimônia."
                                  ],
                                  "verification": "Gere tabela com AIC/BIC para pelo menos 6 modelos e destaque os 2 melhores.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Jupyter Notebook ou RStudio, código pronto para grid search de ARMA.",
                                  "tips": "Ordene a tabela por AIC crescente para visualização rápida.",
                                  "learningObjective": "Computar e tabular critérios AIC/BIC para comparação objetiva.",
                                  "commonMistakes": "Usar AIC de um modelo com BIC de outro; ignorar warnings de convergência."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Selecionar Modelo, Validar e Interpretar Resultados",
                                  "subSteps": [
                                    "Selecione o modelo com menor BIC (mais parcimonioso) ou AIC se n grande.",
                                    "Valide com resíduos: teste Ljung-Box para autocorrelação (p>0.05).",
                                    "Compare forecasts de 1-5 passos à frente com hold-out set.",
                                    "Interprete: explique por que o modelo escolhido é o melhor ajuste parsimonioso.",
                                    "Documente decisão em relatório curto."
                                  ],
                                  "verification": "Apresente modelo selecionado, resíduos ok e forecast plot com métricas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Mesmo ambiente de programação, conjunto de validação (20% dos dados).",
                                  "tips": "Prefira BIC para séries curtas (<100 obs) para evitar overfitting.",
                                  "learningObjective": "Selecionar e validar o melhor modelo ARMA usando AIC/BIC.",
                                  "commonMistakes": "Escolher modelo complexo sem validação de resíduos; não considerar tamanho da amostra."
                                }
                              ],
                              "practicalExample": "Usando dados de passageiros aéreos (AirPassengers, diferenciado para estacionariedade): ajuste ARMA(1,1), ARMA(2,1), ARMA(1,2). Calcule AIC/BIC; suponha ARMA(2,1) tenha AIC=125.3, BIC=130.1 (melhor); valide resíduos e preveja próximos 12 meses.",
                              "finalVerifications": [
                                "Tabela comparativa de AIC/BIC para múltiplos modelos ARMA gerada corretamente.",
                                "Modelo selecionado justificado com menor BIC/AIC e resíduos brancos confirmados.",
                                "Forecast plot com hold-out mostrando bom ajuste.",
                                "Relatório explicando trade-off entre ajuste e parcimônia.",
                                "Testes de diagnóstico (ADF, Ljung-Box) passaram.",
                                "Código reproduzível sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de AIC/BIC (erro <1%).",
                                "Seleção correta do modelo parcimonioso com justificativa.",
                                "Validação completa de resíduos e estacionariedade.",
                                "Interpretação clara das diferenças AIC vs BIC.",
                                "Uso eficiente de ferramentas computacionais.",
                                "Relatório estruturado e acionável."
                              ],
                              "crossCurricularConnections": [
                                "Econometria: Seleção de lags em VAR/ARIMA para previsão econômica.",
                                "Machine Learning: Analogia com critérios como AIC em regularização de modelos.",
                                "Matemática: Otimização de funções de verossimilhança e penalização Bayesiana.",
                                "Computação Científica: Implementação numérica em otimização não-linear."
                              ],
                              "realWorldApplication": "Em finanças, selecionar ARMA para modelar retornos de ações estacionários, otimizando previsões de risco sem overfitting, como em fundos de hedge para alocação de portfólio."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.3.3",
                            "name": "Realizar validação cruzada temporal",
                            "description": "Implementar validação out-of-sample com divisão temporal dos dados para avaliar o desempenho preditivo de modelos ARMA em previsões.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e dividir os dados temporalmente",
                                  "subSteps": [
                                    "Carregue o conjunto de dados de série temporal estacionária usando bibliotecas como pandas.",
                                    "Verifique a estacionariedade com testes como ADF para confirmar adequação para ARMA.",
                                    "Defina o ponto de corte temporal (ex: 80% para treino, 20% para teste, respeitando ordem cronológica).",
                                    "Divida os dados em treino e teste sem embaralhamento aleatório.",
                                    "Salve as divisões em variáveis separadas e visualize as séries para inspeção."
                                  ],
                                  "verification": "Confirme que o conjunto de teste contém apenas dados posteriores ao treino via plotagem das séries divididas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python com pandas, matplotlib, statsmodels",
                                    "Dataset de série temporal estacionária (ex: AirPassengers)"
                                  ],
                                  "tips": "Sempre priorize divisão temporal crescente para simular previsões reais; evite look-ahead bias.",
                                  "learningObjective": "Entender e aplicar divisão temporal correta para validação out-of-sample em séries temporais.",
                                  "commonMistakes": [
                                    "Embaralhar dados aleatoriamente",
                                    "Incluir dados futuros no treino",
                                    "Ignorar gaps ou missing values"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e estimar o modelo ARMA no conjunto de treino",
                                  "subSteps": [
                                    "Use ACF/PACF ou critérios AIC/BIC para identificar ordens p e q do ARMA.",
                                    "Ajuste o modelo ARMA(p,q) apenas nos dados de treino com statsmodels.",
                                    "Verifique resíduos para ausência de autocorrelação com Ljung-Box test.",
                                    "Ajuste hiperparâmetros se necessário via grid search limitado.",
                                    "Salve o modelo ajustado para uso posterior."
                                  ],
                                  "verification": "Resíduos do modelo devem ser white noise (p-value > 0.05 no Ljung-Box).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "statsmodels.tsa.arima.model.ARIMA",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Comece com ARMA(1,1) simples e refine; plote resíduos sempre.",
                                  "learningObjective": "Dominar estimação de parâmetros ARMA em dados de treino isolados.",
                                  "commonMistakes": [
                                    "Sobreajuste com ordens altas",
                                    "Usar dados de teste para seleção de modelo",
                                    "Ignorar diagnósticos de resíduos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar previsões out-of-sample no conjunto de teste",
                                  "subSteps": [
                                    "Use o modelo treinado para prever h-steps ahead no período de teste.",
                                    "Gere previsões iterativas ou diretas dependendo do horizonte.",
                                    "Calcule intervalos de confiança (ex: 95%) para as previsões.",
                                    "Alinhe previsões com índices temporais do teste.",
                                    "Plote previsões vs. valores reais para inspeção visual."
                                  ],
                                  "verification": "Previsões devem corresponder exatamente ao período de teste sem sobreposição com treino.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "statsmodels forecast method",
                                    "matplotlib para plotting"
                                  ],
                                  "tips": "Para horizontes longos, use previsões iterativas; capture incerteza com ICs.",
                                  "learningObjective": "Implementar previsões puramente out-of-sample mantendo integridade temporal.",
                                  "commonMistakes": [
                                    "Retreinar modelo no teste",
                                    "Prever além do horizonte disponível",
                                    "Ignorar intervalos de confiança"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular e analisar métricas de desempenho",
                                  "subSteps": [
                                    "Compute métricas como MAE, RMSE, MAPE entre previsões e reais.",
                                    "Calcule cobertura de intervalos de confiança.",
                                    "Compare com baseline (ex: média ou naive forecast).",
                                    "Gere relatório com tabelas e gráficos de resíduos/previsões.",
                                    "Interprete se o modelo supera baselines."
                                  ],
                                  "verification": "Métricas numéricas consistentes e plotagens mostram alinhamento temporal.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "numpy, sklearn.metrics",
                                    "pandas para tabelas"
                                  ],
                                  "tips": "Use RMSE para penalizar erros grandes; sempre benchmark contra naive.",
                                  "learningObjective": "Avaliar rigorosamente o poder preditivo via métricas out-of-sample.",
                                  "commonMistakes": [
                                    "Calcular métricas no treino",
                                    "Escolha errada de métrica para escala",
                                    "Omitir comparação com baselines"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar resultados e validar robustez",
                                  "subSteps": [
                                    "Analise padrões em erros residuais ao longo do tempo.",
                                    "Teste sensibilidade variando pontos de corte temporal.",
                                    "Documente limitações (ex: não estacionariedade residual).",
                                    "Conclua sobre viabilidade do modelo ARMA para os dados.",
                                    "Sugira melhorias como SARIMA se necessário."
                                  ],
                                  "verification": "Relatório escrito justifica aceitação/rejeição do modelo com evidências.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Relatório em Markdown ou Notebook"
                                  ],
                                  "tips": "Varie cortes (rolling window) para validação mais robusta.",
                                  "learningObjective": "Interpretar validação cruzada temporal para decisões de modelagem.",
                                  "commonMistakes": [
                                    "Generalizar de um corte único",
                                    "Ignorar violações de pressupostos",
                                    "Concluir sem análise qualitativa"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dados mensais de passageiros aéreos (AirPassengers, 1949-1960), divida em treino (1949-1957) e teste (1958-1960). Ajuste ARMA(1,1) no treino, preveja 36 meses à frente, calcule RMSE=25.3 (melhor que naive=45.7), confirmando bom desempenho preditivo.",
                              "finalVerifications": [
                                "Divisão temporal sem vazamento de dados futuros confirmada por plots.",
                                "Modelo ARMA ajustado só em treino com resíduos white noise.",
                                "Previsões out-of-sample alinhadas cronologicamente com teste.",
                                "Métricas (RMSE, MAE, MAPE) calculadas corretamente e benchmarked.",
                                "Relatório interpreta robustez e limitações do modelo.",
                                "Intervalos de confiança cobrem ~95% dos valores reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na divisão temporal (sem shuffle, ordem cronológica preservada).",
                                "Correta estimação ARMA com diagnósticos de resíduos válidos.",
                                "Geração de previsões puramente out-of-sample com ICs.",
                                "Cálculo exato de múltiplas métricas vs. baselines.",
                                "Análise interpretativa profunda e sensibilidade testada.",
                                "Código limpo, reproduzível e comentado."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Manipulação de dados em Python/R com pandas/statsmodels.",
                                "Machine Learning: Conceitos de validação out-of-sample e overfitting.",
                                "Econometria: Aplicações em previsão econômica e finanças.",
                                "Estatística Inferencial: Testes de hipóteses em resíduos (Ljung-Box).",
                                "Visualização de Dados: Plots de séries e erros para comunicação."
                              ],
                              "realWorldApplication": "Em finanças, validar modelos ARMA para previsão de retornos de ações ou PIB trimestral, garantindo que previsões usem apenas dados históricos disponíveis no momento da previsão, evitando ilusões de precisão em trading algorítmico ou relatórios econômicos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.5",
                "name": "Séries Temporais Não Estacionárias",
                "description": "Características das séries não estacionárias e técnicas de previsão adequadas.",
                "totalSkills": 51,
                "atomicTopics": [
                  {
                    "id": "10.1.5.1",
                    "name": "Características das Séries Temporais Não Estacionárias",
                    "description": "Definição e propriedades como tendência, variância não constante e autocorrelação dependente do tempo.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.1.1",
                        "name": "Definição de Séries Temporais Não Estacionárias",
                        "description": "Conceito fundamental que define uma série temporal não estacionária como aquela cujas propriedades estatísticas, como média e variância, mudam ao longo do tempo, violando as premissas de estacionariedade.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.1.1",
                            "name": "Explicar a definição formal de não-estacionariedade",
                            "description": "Descrever com precisão a definição matemática de uma série temporal não estacionária, destacando que a distribuição conjunta dos valores da série varia com o deslocamento temporal, com exemplos simples como crescimento populacional.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Conceito de Estacionariedade",
                                  "subSteps": [
                                    "Leia a definição formal de estacionariedade: uma série {Y_t} é estacionária se a distribuição conjunta de (Y_{t+1}, ..., Y_{t+k}) é invariante ao deslocamento temporal t, para qualquer k.",
                                    "Identifique as propriedades principais: média constante E[Y_t] = μ, variância constante Var(Y_t) = σ² e covariâncias que dependem apenas do lag.",
                                    "Estude exemplos de séries estacionárias, como ruído branco.",
                                    "Anote as implicações para análise estatística.",
                                    "Compare com intuição: 'o comportamento estatístico não muda ao longo do tempo'."
                                  ],
                                  "verification": "Escreva um parágrafo explicando estacionariedade em suas palavras e dê um exemplo simples.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula sobre séries temporais",
                                    "Artigo introdutório sobre estacionariedade (ex: Wikipedia ou livro de Brockwell & Davis)",
                                    "Caderno para anotações"
                                  ],
                                  "tips": "Use diagramas para visualizar média e variância constantes.",
                                  "learningObjective": "Compreender a base conceitual de estacionariedade para contrastar com não-estacionariedade.",
                                  "commonMistakes": [
                                    "Confundir estacionariedade fraca (momentos) com estrita (distribuição completa).",
                                    "Ignorar covariâncias dependentes de lag."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a Noção de Não-Estacionariedade",
                                  "subSteps": [
                                    "Defina não-estacionariedade como o oposto: a distribuição conjunta varia com t.",
                                    "Discuta tipos: variância crescente (heterocedasticidade temporal), média mudando (tendência), dependência serial não invariante.",
                                    "Explore implicações: inferências estatísticas inválidas se assumida estacionariedade.",
                                    "Liste causas comuns: tendências determinísticas, ciclos, choques estruturais.",
                                    "Crie um fluxograma contrastando estacionária vs. não-estacionária."
                                  ],
                                  "verification": "Identifique se uma série descrita (ex: temperatura com aquecimento global) é não-estacionária e por quê.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Gráficos de séries reais (ex: dados de PIB)",
                                    "Software como R ou Python para plotar",
                                    "Vídeo curto sobre estacionariedade (Khan Academy)"
                                  ],
                                  "tips": "Pense em termos de 'estatísticas descritivas mudando ao longo do tempo'.",
                                  "learningObjective": "Reconhecer intuitivamente quando uma série viola estacionariedade.",
                                  "commonMistakes": [
                                    "Reduzir não-estacionariedade apenas a 'tendência'; ignorar variância ou distribuições."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formalizar a Definição Matemática de Não-Estacionariedade",
                                  "subSteps": [
                                    "Escreva a definição matemática: {Y_t} é não-estacionária se ∃ t, s, k tal que a distribuição de (Y_{t+1},...,Y_{t+k}) ≠ distribuição de (Y_{s+1},...,Y_{s+k}).",
                                    "Expanda para momentos: se E[Y_t] ≠ μ constante ou Cov(Y_t, Y_{t+h}) depende de t.",
                                    "Derive exemplos formais: para tendência linear Y_t = a + b t + ε_t, E[Y_t] = a + b t varia com t.",
                                    "Discuta estacionariedade estrita vs. fraca e como não-estacionariedade afeta cada uma.",
                                    "Resolva exercícios: prove que uma caminhada aleatória é não-estacionária."
                                  ],
                                  "verification": "Escreva a definição formal e prove com um exemplo matemático simples.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Livro 'Time Series Analysis' de Hamilton ou Hamilton",
                                    "Papel e caneta para derivações",
                                    "Jupyter Notebook com sympy para símbolos"
                                  ],
                                  "tips": "Comece com estacionariedade fraca (mais comum em prática) antes da estrita.",
                                  "learningObjective": "Dominar a precisão matemática da definição.",
                                  "commonMistakes": [
                                    "Escrever definição vaga sem quantificadores ∃ ou ∀.",
                                    "Confundir não-constância de média com variância."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a Definição a Exemplos Simples",
                                  "subSteps": [
                                    "Analise crescimento populacional: Y_t = Y_0 * r^t + ε_t; E[Y_t] cresce exponencialmente.",
                                    "Teste estatisticamente: compute médias móveis e mostre variação.",
                                    "Gere dados simulados em software e plote autocoovariâncias.",
                                    "Compare com série estacionária: diferencie e verifique.",
                                    "Discuta testes como ADF para detecção prática."
                                  ],
                                  "verification": "Crie um gráfico de uma série não-estacionária e aponte violações específicas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Python/R com bibliotecas pandas, matplotlib, statsmodels",
                                    "Dados reais de população (World Bank)",
                                    "Templates de código para simulação"
                                  ],
                                  "tips": "Use logs para séries exponenciais para visualizar melhor.",
                                  "learningObjective": "Conectar teoria formal a evidências empíricas.",
                                  "commonMistakes": [
                                    "Usar exemplos estacionários como 'não-estacionários'.",
                                    "Ignorar ruído nos exemplos."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a série de população mundial Y_t (em milhões, t=anos desde 1800). Modelada como Y_t ≈ 1000 * e^{0.015 t} + ε_t. A média E[Y_t] ≈ 1000 * e^{0.015 t} aumenta com t, e a distribuição conjunta desloca-se (mais massa em valores altos em t recentes), violando estacionariedade. Plote Y_t vs. t para visualizar tendência.",
                              "finalVerifications": [
                                "Explicar verbalmente a definição formal sem consultar notas.",
                                "Identificar corretamente 3 exemplos reais de não-estacionariedade.",
                                "Provar matematicamente por que uma tendência linear implica não-estacionariedade.",
                                "Diferenciar estacionariedade estrita de fraca em contexto.",
                                "Aplicar a definição a uma série gráfica fornecida.",
                                "Discutir implicações para modelagem sem estacionariedade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição matemática (distribuição conjunta variando com t).",
                                "Uso correto de notação probabilística (E[ ], Cov[ ]).",
                                "Exemplos relevantes e análise correta de violações.",
                                "Clareza na distinção entre tipos de não-estacionariedade.",
                                "Profundidade nas implicações para análise de séries temporais.",
                                "Capacidade de derivação simples ou teste empírico."
                              ],
                              "crossCurricularConnections": [
                                "Economia: Modelagem de PIB ou inflação com tendências.",
                                "Biologia: Crescimento populacional ou epidemias (SIR models).",
                                "Física: Processos com drift como movimento browniano.",
                                "Finanças: Preços de ações como caminhadas aleatórias.",
                                "Climatologia: Temperaturas globais com aquecimento."
                              ],
                              "realWorldApplication": "Em previsões econômicas, reconhecer não-estacionariedade no PIB permite aplicar differencing ou modelos ARIMA para estabilizar, evitando erros em políticas monetárias ou investimentos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.2",
                            "name": "Diferenciar séries estacionárias de não estacionárias",
                            "description": "Comparar características estatísticas chave, como média constante vs. média variável, usando gráficos e testes conceituais para ilustrar as diferenças.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Estacionariedade",
                                  "subSteps": [
                                    "Defina série temporal estacionária: propriedades estatísticas invariantes ao tempo (média constante, variância constante, autocovariância dependente apenas do lag).",
                                    "Defina série temporal não estacionária: mudanças na média, variância ou covariância ao longo do tempo.",
                                    "Estude exemplos simples: ruído branco (estacionário) vs. tendência linear (não estacionário).",
                                    "Revise definições matemáticas: E[X_t] = μ (constante), Var(X_t) = σ² (constante), Cov(X_t, X_{t+k}) = γ(k).",
                                    "Compare com processos estocásticos básicos como caminhada aleatória."
                                  ],
                                  "verification": "Escreva definições precisas e exemplos em um resumo de 1 página, sem erros conceituais.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de texto de séries temporais (ex: Brockwell & Davis)",
                                    "Notas de aula sobre processos estocásticos",
                                    "Vídeo introdutório no YouTube sobre estacionariedade"
                                  ],
                                  "tips": "Use analogias como 'estacionário é como um rio calmo com fluxo constante vs. rio com marés variando'.",
                                  "learningObjective": "Dominar definições teóricas de estacionariedade e não estacionariedade.",
                                  "commonMistakes": [
                                    "Confundir estacionariedade fraca com estrita",
                                    "Ignorar autocovariância",
                                    "Achar que variância zero é estacionária"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Características Estatísticas Chave",
                                  "subSteps": [
                                    "Calcule e compare média móvel em janelas de tempo para séries estacionárias (constante) vs. não estacionárias (variável).",
                                    "Analise variância em subperíodos: constante em estacionárias, crescente em não estacionárias.",
                                    "Examine autocorrelação: decay rápido em estacionárias vs. persistente em não estacionárias.",
                                    "Discuta impacto de não estacionariedade: spurious regressions e previsões inválidas.",
                                    "Pratique com fórmulas: teste de média constante via t-test em subamostras."
                                  ],
                                  "verification": "Gere tabelas de média e variância para 2 séries exemplo e interprete diferenças corretamente.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software R ou Python (pacotes forecast ou statsmodels)",
                                    "Datasets simples: simular AR(1) estacionário e random walk"
                                  ],
                                  "tips": "Sempre normalize séries para comparação justa.",
                                  "learningObjective": "Reconhecer padrões estatísticos diagnósticos de cada tipo de série.",
                                  "commonMistakes": [
                                    "Usar toda a amostra para média sem janelas deslizantes",
                                    "Confundir variância com volatilidade condicional"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Visualizar Diferenças Usando Gráficos",
                                  "subSteps": [
                                    "Plote séries temporais: observe tendência/drift em não estacionárias vs. flutuações em torno de média em estacionárias.",
                                    "Crie gráficos de média móvel e variância rolante para evidenciar mudanças.",
                                    "Gere Autocorrelation Function (ACF) plots: decay exponencial em estacionárias vs. lento em não estacionárias.",
                                    "Compare Partial ACF (PACF) para confirmação.",
                                    "Anote diferenças qualitativas em um relatório visual."
                                  ],
                                  "verification": "Produza 4 gráficos (série, média móvel, ACF estacionária, ACF não estacionária) com legendas explicativas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python (matplotlib, pandas) ou R (ggplot2)",
                                    "Datasets: AirPassengers (não est.) e simulação estacionária"
                                  ],
                                  "tips": "Use escalas log para variância explosiva; zoom em lags iniciais no ACF.",
                                  "learningObjective": "Interpretar visualmente evidências de estacionariedade.",
                                  "commonMistakes": [
                                    "Ignorar escala no eixo Y",
                                    "Confundir sazonalidade com não estacionariedade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Testes Conceituais e Diferenciação Prática",
                                  "subSteps": [
                                    "Realize teste conceitual de Dickey-Fuller unit root (interpretação qualitativa).",
                                    "Diferencie exemplos reais: PIB com tendência vs. retornos diários de ações (aprox. estacionários).",
                                    "Crie fluxograma de decisão: gráfico → stats → teste.",
                                    "Classifique 5 séries mistas como estacionária ou não.",
                                    "Documente razões para cada classificação."
                                  ],
                                  "verification": "Classifique corretamente 5 séries novas com relatório justificando com stats e gráficos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Tutoriais ADF test em Python/R",
                                    "Datasets públicos: FRED economic data"
                                  ],
                                  "tips": "Comece sempre com visual; testes confirmam, não substituem.",
                                  "learningObjective": "Diferenciar com confiança usando múltiplas evidências.",
                                  "commonMistakes": [
                                    "Aceitar p-value sem contexto gráfico",
                                    "Aplicar testes em amostras pequenas"
                                  ]
                                }
                              ],
                              "practicalExample": "Analise a série de passageiros aéreos (AirPassengers): plote a série (tendência crescente, não estacionária), ACF (decadência lenta), calcule média móvel (aumentando) e compare com uma simulação AR(1) estacionária (média constante, ACF decay rápido).",
                              "finalVerifications": [
                                "Explica corretamente as 3 propriedades de estacionariedade fraca.",
                                "Identifica não estacionariedade em gráfico sem hesitação.",
                                "Interpreta ACF plot para ambos tipos.",
                                "Lista 2 riscos de modelar não estacionárias como estacionárias.",
                                "Classifica nova série com 90% acurácia.",
                                "Descreve quando diferenciar é crítico em forecasting."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (definições sem erros: 30%)",
                                "Qualidade de análise visual (gráficos claros e interpretados: 25%)",
                                "Uso correto de estatísticas descritivas (20%)",
                                "Aplicação de testes conceituais (15%)",
                                "Clareza na diferenciação e justificativa (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Economia: Detecção de tendências em PIB para policy making.",
                                "Finanças: Teste de retornos de ativos para modelagem de risco.",
                                "Ciência de Dados: Pré-processamento em machine learning de séries temporais.",
                                "Meteorologia: Análise de temperaturas para detecção de mudanças climáticas."
                              ],
                              "realWorldApplication": "Em finanças, diferenciar permite evitar previsões erradas em ações com drift (não est.), ajustando com differencing para modelos ARIMA válidos, melhorando hedges e portfólios."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.3",
                            "name": "Identificar exemplos reais de não-estacionariedade",
                            "description": "Reconhecer séries não estacionárias em contextos como finanças (preços de ações) e economia (PIB), explicando por que elas não atendem aos critérios de estacionariedade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os critérios fundamentais de estacionariedade",
                                  "subSteps": [
                                    "Defina estacionariedade fraca: média constante, variância constante e autocovariância dependendo apenas do lag.",
                                    "Estude a estacionariedade forte e sua relação com distribuições independentes e identicamente distribuídas (i.i.d.).",
                                    "Compare com processos estacionários vs. não estacionários usando definições matemáticas simples.",
                                    "Identifique testes qualitativos iniciais, como visualização de tendências.",
                                    "Anote exemplos hipotéticos de séries estacionárias (ex: ruído branco)."
                                  ],
                                  "verification": "Crie um resumo de 1 página listando os 3 critérios principais e dê exemplos simples; revise se cobre todos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Notas de aula sobre séries temporais; vídeo introdutório no YouTube sobre estacionariedade (ex: canal StatQuest).",
                                  "tips": "Use analogias: pense em estacionariedade como um 'carro em velocidade constante' vs. 'acelerando'.",
                                  "learningObjective": "Compreender precisamente os critérios que definem uma série estacionária.",
                                  "commonMistakes": "Confundir variância constante com ausência total de variância; ignorar autocovariância."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar visualizações de séries não estacionárias comuns",
                                  "subSteps": [
                                    "Baixe e plote dados de preços de ações (ex: AAPL de 2010-2023 via Yahoo Finance).",
                                    "Observe tendências de longo prazo, sazonalidade e volatilidade crescente.",
                                    "Plote PIB trimestral de um país (ex: EUA via FRED database) e note crescimento exponencial.",
                                    "Calcule estatísticas rolantes de média e variância para visualizar mudanças.",
                                    "Compare com uma série estacionária simulada (ex: AR(1) com φ<1)."
                                  ],
                                  "verification": "Gere gráficos com anotações destacando violações de estacionariedade; confirme se variância e média mudam.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python (pandas, matplotlib) ou R; datasets de Yahoo Finance e FRED; Jupyter notebook.",
                                  "tips": "Use log-retornos para ações para diferenciar níveis de retornos.",
                                  "learningObjective": "Reconhecer padrões visuais de não-estacionariedade em dados reais.",
                                  "commonMistakes": "Atribuir toda tendência a não-estacionariedade sem verificar variância; ignorar escala nos gráficos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar exemplos reais e explicar violações específicas",
                                  "subSteps": [
                                    "Para preços de ações: explique drift (média crescente), heteroscedasticidade (variância variável).",
                                    "Para PIB: destaque tendência linear/exponencial e ciclos econômicos afetando autocovariância.",
                                    "Aplique testes informais: Dickey-Fuller aumentado (ADF) em software para confirmar p-valor >0.05.",
                                    "Discuta impactos: por que modelos como ARIMA requerem diferenciação.",
                                    "Registre em tabela: Exemplo | Critério Violado | Evidência."
                                  ],
                                  "verification": "Complete uma tabela com 3 exemplos, incluindo explicações e evidências; peer-review ou autoavaliação.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Software statsmodels (Python) ou forecast (R); tutoriais ADF test.",
                                  "tips": "Sempre diferencie níveis (não-estacionários) de primeiras diferenças (potencialmente estacionárias).",
                                  "learningObjective": "Explicar matematicamente por que exemplos reais falham nos critérios.",
                                  "commonMistakes": "Confundir não-estacionariedade com volatilidade aleatória; pular testes estatísticos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação em novos contextos e sintetizar",
                                  "subSteps": [
                                    "Selecione 2 séries novas (ex: taxa de câmbio USD/BRL, temperatura média global).",
                                    "Classifique como estacionária/não-estacionária com justificativa.",
                                    "Crie um checklist de verificação baseado nos critérios.",
                                    "Simule uma série não estacionária e aplique diferenciação para torná-la estacionária.",
                                    "Escreva um parágrafo explicando importância em modelagem."
                                  ],
                                  "verification": "Submeta relatório com classificações corretas e checklist; teste com dados desconhecidos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Datasets adicionais (ex: Quandl, World Bank); simulador online de séries temporais.",
                                  "tips": "Pratique com dados diários vs. mensais para ver efeitos de agregação.",
                                  "learningObjective": "Aplicar conhecimento para identificar e justificar não-estacionariedade independentemente.",
                                  "commonMistakes": "Sobrestimar estacionariedade em séries com ciclos longos; não considerar contexto domain-specific."
                                }
                              ],
                              "practicalExample": "Baixe preços diários da ação Apple (AAPL) de 2015-2023. Plote o gráfico: observe tendência ascendente (média não constante), volatilidade crescente em bull markets (variância não constante) e dependência serial forte. Aplique ADF test (p>0.05), confirmando não-estacionariedade. Diferencie uma vez: plote retornos log e reteste.",
                              "finalVerifications": [
                                "Lista corretamente 3+ exemplos reais de não-estacionariedade com contextos (finanças, economia).",
                                "Explica violações dos 3 critérios para cada exemplo com evidências visuais/estatísticas.",
                                "Distingue visualmente séries estacionárias de não-estacionárias em novos gráficos.",
                                "Aplica teste ADF corretamente em pelo menos 2 séries reais.",
                                "Sugere transformações (diferenciação) para estacionarizar.",
                                "Discute implicações para modelagem de previsão."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições e critérios corretos (30%).",
                                "Análise de evidências: gráficos, testes e explicações robustas (25%).",
                                "Profundidade de exemplos: variedade e relevância real-world (20%).",
                                "Clareza de comunicação: tabelas, resumos legíveis (15%).",
                                "Criatividade em prática: novos exemplos e checklist (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Finanças: modelagem de risco em portfólios de ações.",
                                "Economia: análise de ciclos de negócios e crescimento.",
                                "Meteorologia: previsão de temperaturas com tendências climáticas.",
                                "Engenharia: monitoramento de sinais com drift (ex: sensores)."
                              ],
                              "realWorldApplication": "Em finanças, identificar não-estacionariedade em preços de ações permite aplicar modelos como GARCH ou diferenciação para previsões precisas de volatilidade, evitando erros em trading algorítmico; em economia, diferencia PIB não estacionário para analisar crescimento real e políticas fiscais."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.1.2",
                        "name": "Tendência em Séries Temporais Não Estacionárias",
                        "description": "Propriedade que indica uma mudança sistemática e persistente na média da série ao longo do tempo, como crescimento linear ou exponencial.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.2.1",
                            "name": "Detectar presença de tendência em uma série",
                            "description": "Analisar visualmente e conceitualmente gráficos de séries temporais para identificar tendências crescentes, decrescentes ou em U, utilizando decomposição básica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Tendência em Séries Temporais",
                                  "subSteps": [
                                    "Defina tendência como a componente de longo prazo em uma série temporal, representando direção geral (crescente, decrescente ou em U).",
                                    "Diferencie tendência de sazonalidade e ruído: tendência é suave e persistente.",
                                    "Estude exemplos: tendência crescente (ex.: população), decrescente (ex.: recursos esgotáveis), em U (ex.: ciclos econômicos).",
                                    "Revise decomposição aditiva: Série = Tendência + Sazonalidade + Resíduo.",
                                    "Pratique identificando tendências em gráficos simples fornecidos."
                                  ],
                                  "verification": "Explique corretamente o que é tendência e dê 3 exemplos distintos em um quiz curto.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro-texto de séries temporais (cap. 1)",
                                    "Vídeo introdutório no YouTube (5 min)",
                                    "Folha de anotações"
                                  ],
                                  "tips": "Use analogias cotidianas, como crescimento de uma planta para tendência crescente.",
                                  "learningObjective": "Dominar definições e tipos de tendências para análise conceitual.",
                                  "commonMistakes": [
                                    "Confundir tendência com flutuações curtas",
                                    "Ignorar decomposição básica",
                                    "Não diferenciar de sazonalidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar e Visualizar a Série Temporal",
                                  "subSteps": [
                                    "Colete dados de série temporal (ex.: valores mensais ao longo de anos).",
                                    "Use software como Excel, Python (Matplotlib/Pandas) ou R para plotar o gráfico de linha temporal.",
                                    "Ajuste eixos: tempo no x, valor no y; adicione grid e rótulos claros.",
                                    "Aplique suavização inicial (média móvel simples de 3-5 períodos) para destacar tendência.",
                                    "Salve o gráfico e anote observações preliminares."
                                  ],
                                  "verification": "Produza um gráfico limpo e suavizado de uma série de dados fornecida.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Dataset exemplo (ex.: CSV de vendas mensais)",
                                    "Python/Jupyter Notebook ou Excel",
                                    "Tutorial de plotagem (5 min)"
                                  ],
                                  "tips": "Sempre plote dados brutos primeiro para evitar viés de suavização precoce.",
                                  "learningObjective": "Habilitar visualização clara de séries temporais para detecção inicial.",
                                  "commonMistakes": [
                                    "Escala inadequada nos eixos",
                                    "Não suavizar ruído excessivo",
                                    "Plotar sem rótulos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Visualmente a Presença e Tipo de Tendência",
                                  "subSteps": [
                                    "Examine o gráfico: procure direção geral ignorando oscilações curtas.",
                                    "Identifique crescente (inclinação positiva sustentada), decrescente (negativa) ou em U (queda seguida de alta).",
                                    "Marque pontos de inflexão ou mudanças abruptas.",
                                    "Compare com linha de tendência manual (desenhe reto ou curvo aproximando dados).",
                                    "Documente evidências: percentual de pontos alinhados (>70% indica forte tendência)."
                                  ],
                                  "verification": "Classifique corretamente o tipo de tendência em 3 gráficos de teste com justificativa.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráficos de exemplo impressos ou digitais",
                                    "Ferramenta de desenho (ex.: PowerPoint)",
                                    "Checklist de análise"
                                  ],
                                  "tips": "Feche os olhos e 'sinta' a direção geral; evite focar em picos isolados.",
                                  "learningObjective": "Desenvolver habilidade de detecção visual precisa de tendências.",
                                  "commonMistakes": [
                                    "Influência de outliers",
                                    "Confundir sazonalidade com tendência",
                                    "Análise subjetiva sem marcações"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Confirmar com Decomposição Básica e Interpretar Resultados",
                                  "subSteps": [
                                    "Aplique decomposição: subtraia média móvel longa (ex.: 12 meses) para isolar tendência.",
                                    "Use regressão linear simples (tempo vs. valor) para quantificar inclinação.",
                                    "Valide: resíduo deve ser estacionário (sem tendência óbvia).",
                                    "Interprete: força (R² alto), direção (coeficiente positivo/negativo) e implicações.",
                                    "Gere relatório resumido com gráfico de tendência extraída."
                                  ],
                                  "verification": "Extraia e plote tendência de uma série, com R² > 0.6 e interpretação correta.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Python (statsmodels.tsa) ou Excel (FORECAST.LINEAR)",
                                    "Dataset de prática",
                                    "Template de relatório"
                                  ],
                                  "tips": "Comece com janela de suavização par a séries mensais (ex.: 12).",
                                  "learningObjective": "Integrar análise conceitual e quantitativa para confirmação robusta.",
                                  "commonMistakes": [
                                    "Janela de suavização inadequada",
                                    "Ignorar estacionariedade do resíduo",
                                    "Interpretação errada de R²"
                                  ]
                                }
                              ],
                              "practicalExample": "Analise dados mensais de temperatura média em uma cidade (2000-2023). Plote o gráfico, detecte tendência crescente (aquecimento global), suavize com média móvel de 12 meses e confirme com regressão linear (inclinação positiva, R²=0.75).",
                              "finalVerifications": [
                                "Identifica corretamente tendência em 90% dos gráficos de teste.",
                                "Extrai tendência via suavização e valida estacionariedade do resíduo.",
                                "Justifica tipo de tendência com evidências visuais e quantitativas.",
                                "Produz relatório claro com gráficos anotados.",
                                "Diferencia tendência de outros componentes em decomposição."
                              ],
                              "assessmentCriteria": [
                                "Precisão na classificação de tendência (crescente/decrescente/U): 40%.",
                                "Qualidade da visualização e decomposição: 30%.",
                                "Justificativa conceitual e quantitativa: 20%.",
                                "Relatório completo e sem erros comuns: 10%."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Regressão linear e suavização.",
                                "Economia: Previsão de vendas e PIB.",
                                "Ciências Ambientais: Monitoramento climático.",
                                "Finanças: Análise de ações e inflação."
                              ],
                              "realWorldApplication": "Em empresas, detectar tendência crescente em vendas para planejar expansão; em meteorologia, identificar aquecimento para políticas ambientais; em finanças, tendências decrescentes em lucros para ajustes estratégicos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.2.2",
                            "name": "Classificar tipos de tendência",
                            "description": "Diferenciar tendências lineares, quadráticas e exponenciais, com fórmulas matemáticas e impactos na previsão de séries temporais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as fórmulas e características matemáticas das tendências",
                                  "subSteps": [
                                    "Estude a fórmula linear: y = a + b*x, onde representa crescimento constante.",
                                    "Analise a fórmula quadrática: y = a*x² + b*x + c, caracterizada por aceleração parabólica.",
                                    "Examine a fórmula exponencial: y = a * b^x ou y = a * e^(k*x), com crescimento acelerado.",
                                    "Compare taxas de crescimento: linear (constante), quadrática (acelerada), exponencial (explosiva).",
                                    "Identifique domínios de aplicação em séries temporais não estacionárias."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito as três fórmulas, suas diferenças e exemplos simples.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Folha de papel e caneta",
                                    "Calculadora gráfica ou app como Desmos",
                                    "Tabelas de fórmulas impressas"
                                  ],
                                  "tips": "Desenhe gráficos manuais das funções para fixar visualmente as curvas.",
                                  "learningObjective": "Dominar as equações matemáticas e comportamentos qualitativos das tendências.",
                                  "commonMistakes": [
                                    "Confundir crescimento linear com exponencial em estágios iniciais",
                                    "Esquecer o termo quadrático na parábola",
                                    "Ignorar o impacto do parâmetro 'b' na exponencial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Visualizar e plotar tendências em gráficos de séries temporais",
                                  "subSteps": [
                                    "Gere dados sintéticos para cada tipo usando planilhas (ex: Excel ou Google Sheets).",
                                    "Plote os dados em gráficos de linha para observar padrões visuais.",
                                    "Ajuste curvas (trendlines) nos gráficos e compare com fórmulas teóricas.",
                                    "Identifique sinais visuais: reta (linear), parábola (quadrática), curva em S ou J (exponencial).",
                                    "Teste com ruído aleatório para simular séries temporais reais."
                                  ],
                                  "verification": "Crie e interprete três gráficos corretamente classificados.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software de planilhas (Excel/Google Sheets)",
                                    "Biblioteca Python (Matplotlib/Seaborn) ou R",
                                    "Dados de exemplo pré-prontos"
                                  ],
                                  "tips": "Use logaritmo na escala Y para linearizar exponenciais e facilitar identificação.",
                                  "learningObjective": "Desenvolver habilidade em reconhecimento visual de tendências em dados plotados.",
                                  "commonMistakes": [
                                    "Atribuir ruído como tendência principal",
                                    "Escolher escala errada no eixo",
                                    "Confundir quadrática com exponencial em porções curtas de dados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Classificar tendências em conjuntos de dados reais de séries temporais",
                                  "subSteps": [
                                    "Selecione datasets públicos (ex: vendas, população, ações).",
                                    "Aplique testes visuais e estatísticos (ex: coeficiente de correlação, resíduos).",
                                    "Use regressão para ajustar modelos e comparar R² ou AIC.",
                                    "Classifique: linear se resíduos aleatórios em modelo linear; caso contrário, teste quadrático/exponencial.",
                                    "Documente justificativas para cada classificação."
                                  ],
                                  "verification": "Classifique corretamente 4-5 datasets fornecidos ou coletados.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Datasets de Kaggle ou UCI (ex: AirPassengers)",
                                    "Python (statsmodels, scikit-learn) ou R",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Comece sempre com plot e decomposição da série (tendência + sazonalidade + ruído).",
                                  "learningObjective": "Aplicar métodos para classificar tendências em dados empíricos.",
                                  "commonMistakes": [
                                    "Sobreajustar modelo sem validação cruzada",
                                    "Ignorar não-estacionariedade inicial",
                                    "Classificar prematuramente sem múltiplos testes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar impactos na previsão de séries temporais",
                                  "subSteps": [
                                    "Simule previsões com cada modelo e compare erros (MAE, RMSE).",
                                    "Discuta limitações: linear subestima explosões, exponencial pode superestimar platôs.",
                                    "Explore transformações (log, diferenças) para estacionariedade.",
                                    "Avalie cenários de longo prazo: divergência em horizontes extensos.",
                                    "Integre com ARIMA ou Prophet para modelagem híbrida."
                                  ],
                                  "verification": "Gere previsões e explique impactos de classificação errada em 2 cenários.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Bibliotecas de forecasting (Prophet, statsmodels)",
                                    "Dados de séries temporais longas",
                                    "Gráficos de previsão vs real"
                                  ],
                                  "tips": "Valide previsões com hold-out set para evitar overfitting.",
                                  "learningObjective": "Entender implicações práticas da classificação na modelagem preditiva.",
                                  "commonMistakes": [
                                    "Usar horizonte de previsão curto para testar",
                                    "Não considerar incerteza em previsões exponenciais",
                                    "Ignorar breakpoints ou mudanças de tendência"
                                  ]
                                }
                              ],
                              "practicalExample": "Analise a série temporal de passageiros aéreos (dataset AirPassengers): plote os dados, identifique tendência exponencial via log-transform (linear no log), ajuste y = a * e^(k*t), classifique visual e matematicamente, e preveja os próximos 12 meses comparando com modelo linear (subestima).",
                              "finalVerifications": [
                                "Classificar corretamente 80% de 10 gráficos de tendências mistas.",
                                "Explicar fórmulas e diferenças em uma apresentação de 5 minutos.",
                                "Gerar previsões precisas (RMSE < 20%) em dataset de teste.",
                                "Identificar e corrigir classificação errada em exemplos com ruído.",
                                "Documentar relatório com plots, fórmulas e justificativas.",
                                "Discutir impactos qualitativos em 3 aplicações reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação visual e matemática (70% peso).",
                                "Correta aplicação de fórmulas e testes estatísticos.",
                                "Qualidade das previsões e análise de erros.",
                                "Profundidade na discussão de impactos preditivos.",
                                "Clareza na documentação e comunicação.",
                                "Criatividade em exemplos e conexões práticas."
                              ],
                              "crossCurricularConnections": [
                                "Economia: Previsão de crescimento do PIB ou inflação.",
                                "Biologia: Modelagem de crescimento populacional ou epidemias (ex: COVID-19).",
                                "Física: Trajetórias aceleradas ou decaimento radioativo.",
                                "Meio Ambiente: Curvas de aquecimento global ou poluição.",
                                "Finanças: Análise de retornos de ações ou criptomoedas."
                              ],
                              "realWorldApplication": "Em empresas de e-commerce, classificar tendência exponencial nas vendas permite otimizar estoque e campanhas, evitando rupturas ou excessos; em saúde pública, identificar exponencial em surtos de doenças guia alocação de recursos e lockdowns preventivos."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.2.3",
                            "name": "Explicar o impacto da tendência na estacionariedade",
                            "description": "Demonstrar como a tendência causa não estacionariedade na média e como remoções como diferenciação podem restaurar estacionariedade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos de Estacionariedade e Tendência",
                                  "subSteps": [
                                    "Defina estacionariedade: média, variância e covariância constantes ao longo do tempo.",
                                    "Explique não estacionariedade na média causada por tendência (drift linear ou não linear).",
                                    "Diferencie tendência determinística (ex: linear) de estocástica.",
                                    "Revise testes básicos como visual inspeção de plots de séries temporais.",
                                    "Compare séries estacionárias vs. não estacionárias com exemplos simples."
                                  ],
                                  "verification": "Crie um plot de uma série com tendência e identifique visualmente a mudança na média.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Notebook Jupyter com Python (pandas, matplotlib), dados de exemplo de série temporal com tendência (ex: airpassengers dataset).",
                                  "tips": "Sempre comece com plots para intuição visual antes de testes formais.",
                                  "learningObjective": "Compreender como tendência viola a constante da média, definindo não estacionariedade.",
                                  "commonMistakes": "Confundir variância crescente com mudança na média; ignorar que estacionariedade requer todas as propriedades constantes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Visualizar Tendência em Séries Temporais",
                                  "subSteps": [
                                    "Colete ou gere dados de série temporal com tendência conhecida (ex: y_t = 0.1*t + erro).",
                                    "Plote a série original e calcule a média móvel para destacar a tendência.",
                                    "Aplique regressão linear simples para estimar a tendência (y ~ t).",
                                    "Use decomposição STL para separar tendência de sazonalidade e resíduo.",
                                    "Discuta como tendência crescente faz a média E[y_t] depender de t."
                                  ],
                                  "verification": "Mostre um plot com linha de tendência ajustada e comente como a média muda ao longo do tempo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python (statsmodels para regressão, seasonal_decompose), datasets como sunspots ou GDP growth.",
                                  "tips": "Use médias móveis de janela longa (ex: 12 períodos) para suavizar ruído e revelar tendência.",
                                  "learningObjective": "Detectar e quantificar tendência, demonstrando sua relação com não estacionariedade na média.",
                                  "commonMistakes": "Atribuir toda não estacionariedade a tendência sem verificar variância ou autocorrelação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Demonstrar o Impacto da Tendência na Não Estacionariedade",
                                  "subSteps": [
                                    "Calcule estatísticas descritivas rolantes (média, variância) para mostrar mudança na média.",
                                    "Aplique teste Augmented Dickey-Fuller (ADF) na série original e interprete p-valor > 0.05 como não estacionária.",
                                    "Analise a Função de Autocorrelação (ACF) para padrões persistentes devido à tendência.",
                                    "Simule remoção manual da tendência via regressão e compare antes/depois.",
                                    "Explique matematicamente: se y_t = β t + ε_t, então E[y_t] = β t ≠ constante."
                                  ],
                                  "verification": "Execute ADF test e mostre p-valor indicando não estacionariedade; plot ACF com decaimento lento.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Biblioteca statsmodels.tsa.stattools.adfuller, matplotlib para ACF plot.",
                                  "tips": "Interprete ADF: hipótese nula é unidade raiz (não estacionária); rejeite só se p < 0.05.",
                                  "learningObjective": "Provar que tendência causa dependência temporal na média, violando estacionariedade.",
                                  "commonMistakes": "Ignorar lags no ADF test, levando a especificação errada; confundir não rejeição com prova de não estacionariedade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Diferenciação para Restaurar Estacionariedade",
                                  "subSteps": [
                                    "Compute a primeira diferença: Δy_t = y_t - y_{t-1}.",
                                    "Plote a série diferenciada e verifique visualmente se a média agora é constante (próxima de zero).",
                                    "Aplique ADF test na série diferenciada e confirme rejeição da hipótese nula.",
                                    "Compare ACF da diferenciada (deve decair rapidamente) vs. original.",
                                    "Discuta limitações: diferenciação remove tendência de primeira ordem, mas pode introduzir MA(1)."
                                  ],
                                  "verification": "ADF test na diferenciada com p-valor < 0.05 e plot mostrando média estável.",
                                  "estimatedTime": "55 minutos",
                                  "materials": "Python pandas diff() method, statsmodels para testes.",
                                  "tips": "Sempre diferencie uma vez para tendência linear; verifique segunda diferença se necessário.",
                                  "learningObjective": "Demonstrar como diferenciação remove tendência, restaurando estacionariedade na média.",
                                  "commonMistakes": "Sobrediferenciação (over-differencing), causando variância não constante ou invertibilidade perdida."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e Avaliar a Restauração Completa de Estacionariedade",
                                  "subSteps": [
                                    "Execute múltiplos testes: ADF, KPSS (complementar, H0 estacionária).",
                                    "Analise resíduos pós-diferenciação para normalidade e ausência de autocorrelação (Ljung-Box test).",
                                    "Compare estatísticas antes/depois: média rolante estável, variância constante.",
                                    "Simule cenários com tendência quadrática e aplique segunda diferenciação.",
                                    "Documente em relatório: antes/depois plots, testes e conclusões."
                                  ],
                                  "verification": "Relatório com plots, testes estatísticos confirmando estacionariedade restaurada.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "statsmodels.tsa.stattools.kpss, arch_unitroot para testes adicionais.",
                                  "tips": "Use KPSS para confirmar: se ADF rejeita H0 original mas aceita pós-dif, estacionariedade restaurada.",
                                  "learningObjective": "Validar robustamente a remoção de não estacionariedade via diferenciação.",
                                  "commonMistakes": "Confiar só em um teste; ignorar que testes têm poder limitado em amostras pequenas."
                                }
                              ],
                              "practicalExample": "Usando o dataset de passageiros aéreos (airpassengers): plote a série mostrando tendência crescente; aplique primeira diferenciação, execute ADF test (original p>0.05, diferenciada p<0.05), e mostre ACF decair rapidamente, provando restauração de estacionariedade na média.",
                              "finalVerifications": [
                                "Plot da série diferenciada mostra média constante em torno de zero.",
                                "ADF test na diferenciada rejeita H0 de não estacionariedade (p < 0.05).",
                                "KPSS test aceita H0 de estacionariedade na diferenciada.",
                                "ACF da diferenciada decai exponencialmente sem padrões persistentes.",
                                "Média rolante (janela=12) da diferenciada é estável.",
                                "Ljung-Box test nos resíduos não rejeita ausência de autocorrelação."
                              ],
                              "assessmentCriteria": [
                                "Explicação clara do mecanismo matemático: tendência faz E[y_t] = f(t), diferenciação torna E[Δy_t] = 0.",
                                "Demonstração correta com código Python reproduzível em dataset real.",
                                "Interpretação precisa de testes estatísticos (ADF, ACF, etc.).",
                                "Identificação de limitações da diferenciação (ex: perda de longo prazo).",
                                "Visualizações intuitivas comparando antes/depois.",
                                "Aplicação a exemplo prático com conclusões corretas."
                              ],
                              "crossCurricularConnections": [
                                "Economia: Modelagem de PIB com tendências de crescimento e uso de ARIMA diferenciada.",
                                "Física: Posição de objeto com velocidade constante (tendência linear), aceleração via segunda derivada.",
                                "Finanças: Preços de ações não estacionários, retornos diferenciados para trading.",
                                "Engenharia: Sinais com drift, filtros diferenciais para controle."
                              ],
                              "realWorldApplication": "Em previsão de demanda de energia elétrica, onde consumo tem tendência crescente devido a urbanização; diferenciação permite modelar ARIMA estável, melhorando forecasts para planejamento de redes e evitando blackouts."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.1.3",
                        "name": "Variância Não Constante",
                        "description": "Característica conhecida como heterocedasticidade temporal, onde a dispersão dos valores da série varia ao longo do tempo, afetando a confiabilidade das previsões.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.3.1",
                            "name": "Identificar variância não constante em séries",
                            "description": "Observar padrões de dispersão crescente ou volátil em gráficos de séries temporais, como em retornos financeiros durante crises.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de variância constante versus não constante",
                                  "subSteps": [
                                    "Defina variância constante (homocedasticidade): dispersão estável ao longo do tempo.",
                                    "Defina variância não constante (heterocedasticidade): dispersão que aumenta, diminui ou oscila.",
                                    "Estude exemplos gráficos: dispersão em funil (aumentando) ou contração súbita.",
                                    "Revise fórmulas básicas de variância: σ² = Σ(x_i - μ)² / n.",
                                    "Compare com autocorrelação para diferenciar de outras não-estacionaridades."
                                  ],
                                  "verification": "Explique em suas palavras a diferença e desenhe um gráfico simples de cada tipo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de estatística descritiva",
                                    "Gráficos de exemplo de séries temporais (ex: Python Matplotlib plots)"
                                  ],
                                  "tips": "Use analogias como 'nuvem de chuva constante vs. tempestade crescente' para visualizar.",
                                  "learningObjective": "Dominar definições teóricas e visuais de variância não constante.",
                                  "commonMistakes": [
                                    "Confundir com tendência linear",
                                    "Ignorar escala do eixo Y",
                                    "Assumir estacionariedade sem teste visual"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar visualmente variância não constante em gráficos",
                                  "subSteps": [
                                    "Carregue um gráfico de série temporal (ex: retornos diários de ações).",
                                    "Observe o padrão de dispersão: procure 'expansão' em períodos de volatilidade.",
                                    "Marque regiões de alta/baixa dispersão com linhas horizontais nos resíduos.",
                                    "Compare múltiplos gráficos: um estacionário vs. não estacionário.",
                                    "Anote observações qualitativas: 'dispersão crescente pós-2008'."
                                  ],
                                  "verification": "Anote 3 exemplos de padrões voláteis em um gráfico fornecido e justifique.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Gráficos de séries reais (ex: Yahoo Finance dados S&P500)",
                                    "Ferramenta de plotagem como Excel ou Python"
                                  ],
                                  "tips": "Aumente o zoom em períodos de crise para detectar padrões sutis.",
                                  "learningObjective": "Desenvolver intuição visual para detectar heterocedasticidade.",
                                  "commonMistakes": [
                                    "Focar apenas em médias, ignorando dispersão",
                                    "Não ajustar escala do gráfico",
                                    "Confundir com outliers isolados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar testes quantitativos para variância não constante",
                                  "subSteps": [
                                    "Calcule variância rolante (rolling variance) em janelas de 30-90 pontos.",
                                    "Plote a variância rolante e identifique picos/ondas.",
                                    "Aplique teste de Breusch-Pagan ou White para heterocedasticidade.",
                                    "Interprete p-valor: <0.05 indica variância não constante.",
                                    "Compare com log-retornos para estabilizar variância."
                                  ],
                                  "verification": "Gere plot de variância rolante e interprete um pico significativo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python (pandas, statsmodels)",
                                    "R (forecast package)",
                                    "Dados CSV de séries temporais"
                                  ],
                                  "tips": "Use janela rolante adaptativa para séries curtas; teste múltiplas tamanhos.",
                                  "learningObjective": "Usar métricas quantitativas para confirmar observações visuais.",
                                  "commonMistakes": [
                                    "Janela rolante muito pequena (ruído)",
                                    "Ignorar normalização de dados",
                                    "Confundir com não-estacionariedade de média"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação em contexto real e documentar achados",
                                  "subSteps": [
                                    "Selecione dados de crise financeira (ex: retornos Bitcoin 2022).",
                                    "Combine análise visual e teste: identifique variância volátil.",
                                    "Documente relatório: gráfico anotado + teste estatístico + interpretação.",
                                    "Compare com série estacionária (ex: temperatura diária).",
                                    "Discuta implicações para modelagem (ex: GARCH necessário)."
                                  ],
                                  "verification": "Produza relatório de 1 página com evidências claras de variância não constante.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Dados reais de finanças (Quandl ou Yahoo)",
                                    "Template de relatório Jupyter Notebook"
                                  ],
                                  "tips": "Sempre contextualize: 'variância explode em crises devido a pânico de mercado'.",
                                  "learningObjective": "Integrar análise qualitativa e quantitativa em cenários reais.",
                                  "commonMistakes": [
                                    "Sobreajuste de testes múltiplos sem correção",
                                    "Não considerar sazonalidade",
                                    "Generalizar de um exemplo"
                                  ]
                                }
                              ],
                              "practicalExample": "Em retornos diários do índice S&P 500 durante a crise de 2008, observe dispersão crescente a partir de setembro: desvios padrão dobram de 1% para 4% em poucas semanas, visível como 'leque aberto' no gráfico de preços, confirmada por variância rolante com picos acima de 0.002.",
                              "finalVerifications": [
                                "Identifica corretamente dispersão crescente em 80% dos gráficos fornecidos.",
                                "Calcula e interpreta variância rolante sem erros em dados de teste.",
                                "Diferencia variância não constante de tendência ou autocorrelação.",
                                "Aplica teste Breusch-Pagan e explica p-valor.",
                                "Documenta análise com gráficos anotados e conclusões acionáveis.",
                                "Sugere próximos passos como modelagem ARCH/GARCH."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção visual (pontos por gráfico correto).",
                                "Correção matemática em cálculos de variância (erro <5%).",
                                "Profundidade de interpretação contextual (ex: ligações econômicas).",
                                "Qualidade de documentação e clareza de comunicação.",
                                "Criatividade em exemplos reais e conexões interdisciplinares.",
                                "Tempo de execução eficiente sem sacrificar precisão."
                              ],
                              "crossCurricularConnections": [
                                "Finanças: Volatilidade em modelagem de risco (VaR).",
                                "Economia: Regimes de mercado e ciclos de negócios.",
                                "Física: Ruído browniano heterogêneo em processos estocásticos.",
                                "Machine Learning: Pré-processamento para redes neurais em séries.",
                                "Medicina: Variância em sinais vitais durante epidemias."
                              ],
                              "realWorldApplication": "Em trading algorítmico, detectar variância crescente em retornos de ações sinaliza mudança de regime, ativando estratégias de hedge ou stop-loss para mitigar perdas em crises como a de 2020 (COVID), melhorando precisão de previsões em 20-30%."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.3.2",
                            "name": "Descrever efeitos da heterocedasticidade temporal",
                            "description": "Explicar como variância não constante viola premissas de modelos ARIMA e sugere transformações como logaritmo ou Box-Cox.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Heterocedasticidade Temporal",
                                  "subSteps": [
                                    "Defina heterocedasticidade como variância não constante ao longo do tempo em séries temporais.",
                                    "Diferencie de homocedasticidade, onde a variância é constante.",
                                    "Identifique padrões comuns, como variância crescente (e.g., em dados financeiros).",
                                    "Revise exemplos gráficos de séries com variância instável.",
                                    "Explique a relação com não-estacionariedade na variância."
                                  ],
                                  "verification": "Crie um diagrama ou descrição escrita distinguindo heterocedasticidade de homocedasticidade.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Gráficos de séries temporais exemplo (e.g., dados de preços de ações), software como R ou Python (ggplot ou matplotlib).",
                                  "tips": "Use plots de resíduos vs. tempo para visualizar variância instável.",
                                  "learningObjective": "Definir e reconhecer heterocedasticidade temporal em séries temporais.",
                                  "commonMistakes": "Confundir com autocorrelação ou tendência; foque apenas na variância."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Violações das Premissas de Modelos ARIMA",
                                  "subSteps": [
                                    "Revise premissas ARIMA: estacionariedade em média e variância.",
                                    "Explique como variância não constante viola a premissa de homocedasticidade nos resíduos.",
                                    "Demonstre com equações: Var(ε_t) ≠ constante leva a resíduos não-iid.",
                                    "Compare resíduos de modelo ARIMA em dados homocedásticos vs. heterocedásticos.",
                                    "Teste premissas usando Breusch-Pagan ou White test adaptado para séries temporais."
                                  ],
                                  "verification": "Aplique um teste de heterocedasticidade em dados simulados e interprete p-valor.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Dados simulados heterocedásticos (R: arima.sim), pacotes statsmodels (Python) ou forecast (R).",
                                  "tips": "Simule dados com variância crescente: ε_t ~ N(0, σ_t^2) onde σ_t aumenta.",
                                  "learningObjective": "Identificar como heterocedasticidade viola premissas ARIMA específicas.",
                                  "commonMistakes": "Ignorar que ARIMA assume variância constante nos erros; não confundir com não-estacionariedade em média."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Descrever os Efeitos e Consequências nos Modelos",
                                  "subSteps": [
                                    "Liste efeitos: previsões enviesadas, intervalos de confiança inválidos, testes de significância distorcidos.",
                                    "Explique impacto em forecasts: subestimação de incerteza em períodos de alta variância.",
                                    "Discuta instabilidade de parâmetros estimados ao longo do tempo.",
                                    "Ilustre com exemplo: modelo ARIMA em dados de volatilidade de ações falha em crises.",
                                    "Quantifique: maior MSE em validação out-of-sample devido a variância ignorada."
                                  ],
                                  "verification": "Escreva um parágrafo descrevendo 3 efeitos principais com justificativa.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Exemplos de forecasts ruins (gráficos), calculadora ou script para MSE.",
                                  "tips": "Pense em termos de risco: heterocedasticidade amplifica erros em tails.",
                                  "learningObjective": "Articular impactos quantitativos e qualitativos da heterocedasticidade em ARIMA.",
                                  "commonMistakes": "Superestimar efeitos apenas em média; enfatize variância nos resíduos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Recomendar Transformações para Correção",
                                  "subSteps": [
                                    "Introduza transformações estabilizadoras: logaritmo para variância proporcional ao nível.",
                                    "Explique Box-Cox: λ otimizado para máxima verossimilhança, generaliza log (λ=0).",
                                    "Aplique passo-a-passo: teste estacionariedade pós-transformação (KPSS/ADF).",
                                    "Compare before/after: plots de resíduos e testes ARCH para variância condicional.",
                                    "Discuta limitações: log não funciona para zeros/negativos; use alternativas como diferenciação."
                                  ],
                                  "verification": "Transforme um dataset heterocedástico, re-ajuste ARIMA e verifique melhorias em AIC/MSE.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Dados reais (e.g., AirPassengers ou stock prices), funções boxcox() em R ou Python scipy.",
                                  "tips": "Sempre plote Q-Q e ACF resíduos pós-transformação para confirmação.",
                                  "learningObjective": "Selecionar e justificar transformações apropriadas para mitigar heterocedasticidade.",
                                  "commonMistakes": "Aplicar log sem checar valores negativos; valide estacionariedade após."
                                }
                              ],
                              "practicalExample": "Em dados de preços diários de Bitcoin (2017-2023), a variância aumenta dramaticamente durante bull runs. Ajustar ARIMA(1,1,1) sem transformação leva a resíduos com variância crescente (teste Breusch-Pagan p<0.01). Aplicar log-transform estabiliza variância, reduzindo MSE de forecast em 25%.",
                              "finalVerifications": [
                                "Explicar em 2 minutos os efeitos da heterocedasticidade em ARIMA sem consultar notas.",
                                "Identificar heterocedasticidade em um plot de resíduos fornecido.",
                                "Recomendar transformação correta para variância crescente vs. decrescente.",
                                "Calcular e interpretar teste de heterocedasticidade em dados simulados.",
                                "Comparar forecasts before/after transformação em exemplo prático.",
                                "Descrever limitações de ARIMA com heterocedasticidade não corrigida."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definição correta de heterocedasticidade e violações ARIMA (30%).",
                                "Profundidade de efeitos: lista completa de impactos com exemplos (25%).",
                                "Recomendações práticas: transformações justificadas e validadas (20%).",
                                "Clareza na comunicação: explicação estruturada e sem jargão excessivo (15%).",
                                "Evidências empíricas: uso de testes/plots para suporte (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Economia: Modelagem de volatilidade em mercados financeiros (GARCH extensions).",
                                "Finanças: Risk management e Value-at-Risk com variância condicional.",
                                "Engenharia: Controle de processos com variância instável em sensores IoT.",
                                "Biologia: Análise de crescimento populacional com variância heterocedástica."
                              ],
                              "realWorldApplication": "Em previsão de demanda de varejo, heterocedasticidade temporal (picos sazonais de variância) distorce forecasts ARIMA, levando a estoques excessivos. Transformações log/Box-Cox estabilizam, melhorando precisão em 15-20% e otimizando cadeia de suprimentos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.1.4",
                        "name": "Autocorrelação Dependente do Tempo",
                        "description": "Propriedade em que a correlação entre valores da série depende do lag e do tempo absoluto, levando a dependências não estacionárias.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.4.1",
                            "name": "Analisar funções de autocorrelação em não-estacionárias",
                            "description": "Interpretar gráficos de ACF onde autocorrelações decaem lentamente devido à não estacionariedade, contrastando com séries estacionárias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de autocorrelação e estacionariedade",
                                  "subSteps": [
                                    "Defina autocorrelação como a correlação entre valores de uma série temporal em diferentes lags.",
                                    "Explique estacionariedade: média, variância e autocovariância constantes ao longo do tempo.",
                                    "Discuta não-estacionariedade: presença de tendência, sazonalidade ou dependência temporal que causa decaimento lento na ACF.",
                                    "Revise fórmula da função de autocorrelação (ACF): ρ_k = γ_k / γ_0.",
                                    "Identifique que em séries estacionárias, ACF decai rapidamente para zero."
                                  ],
                                  "verification": "Resuma em 3 frases os conceitos chave e forneça um exemplo simples de ACF estacionária vs. não-estacionária.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de texto de séries temporais (ex: 'Análise de Séries Temporais' de Hamilton)",
                                    "Notebook Jupyter ou RStudio"
                                  ],
                                  "tips": "Use diagramas visuais para diferenciar estacionariedade; memorize o padrão de decaimento lento como sinal de alerta.",
                                  "learningObjective": "Compreender a base teórica da ACF e como a não-estacionariedade afeta seu comportamento.",
                                  "commonMistakes": [
                                    "Confundir ACF com PACF",
                                    "Ignorar a importância da estacionariedade antes da análise",
                                    "Assumir estacionariedade sem teste"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Carregar e visualizar dados não-estacionários e calcular ACF",
                                  "subSteps": [
                                    "Carregue um dataset não-estacionário (ex: série de preços de ações ou PIB trimestral).",
                                    "Plote a série temporal para observar tendência ou variância crescente.",
                                    "Calcule e plote a função de autocorrelação (ACF) usando Python (statsmodels.tsa.stattools.acf) ou R (acf()).",
                                    "Analise lags iniciais: verifique se barras da ACF permanecem significativas além de 10-20 lags.",
                                    "Marque intervalos de confiança (geralmente 95%) para identificar autocorrelações significativas."
                                  ],
                                  "verification": "Gere o gráfico ACF e anote lags onde |ACF| > 2/√n (n=tamanho da amostra).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com pandas, matplotlib, statsmodels",
                                    "Dataset exemplo: dados de PIB do FRED ou yfinance para ações",
                                    "R com forecast package"
                                  ],
                                  "tips": "Use plot_acf() no statsmodels para automação; foque em lags até 1/4 do tamanho da série.",
                                  "learningObjective": "Executar computação prática de ACF em dados reais não-estacionários.",
                                  "commonMistakes": [
                                    "Não remover sazonalidade antes",
                                    "Escala errada no gráfico (use lags limitados)",
                                    "Ignorar limites de confiança"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar padrões de decaimento lento na ACF",
                                  "subSteps": [
                                    "Identifique decaimento lento: ACF diminui gradualmente, permanecendo acima do limite de confiança por muitos lags.",
                                    "Compare com ACF estacionária: decaimento exponencial rápido para zero após poucos lags.",
                                    "Classifique o tipo de não-estacionariedade: tendência unitária (ACF sinusoidal ou lento) vs. variância não-constante.",
                                    "Quantifique: calcule metade-vida da ACF (lag onde ACF cai para 0.5).",
                                    "Documente observações: 'ACF decai em 0.95, 0.92, 0.89... indicando não-estacionariedade'."
                                  ],
                                  "verification": "Escreva um relatório de 100 palavras interpretando o gráfico, destacando evidências de não-estacionariedade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráficos ACF gerados no step anterior",
                                    "Ferramenta de anotação como Draw.io ou papel"
                                  ],
                                  "tips": "Olhe para os primeiros 20 lags; decaimento <5% por lag é sinal clássico de não-estacionariedade.",
                                  "learningObjective": "Desenvolver habilidade em leitura diagnóstica de gráficos ACF.",
                                  "commonMistakes": [
                                    "Interpretar todas as barras altas como sazonalidade",
                                    "Confundir ruído com sinal",
                                    "Não contrastar com estacionária"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar com séries estacionárias e propor correções",
                                  "subSteps": [
                                    "Aplique diferenciação de primeira ordem (diff()) nos dados não-estacionários.",
                                    "Recalcule e plote ACF da série diferenciada; verifique decaimento rápido.",
                                    "Compare gráficos lado a lado: antes/depois da transformação.",
                                    "Discuta testes complementares: ADF ou KPSS para confirmar estacionariedade.",
                                    "Conclua implicações: modelagem ARIMA requer estacionariedade para validade."
                                  ],
                                  "verification": "Mostre gráficos comparativos e afirme se a diferenciação resolveu o decaimento lento.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Mesmo software do step 2",
                                    "Funções: adfuller() no statsmodels ou ur.df() no R"
                                  ],
                                  "tips": "Sempre teste múltiplas diferenças se necessário; visualize resíduos.",
                                  "learningObjective": "Aplicar contrastes e transformações para validar análise.",
                                  "commonMistakes": [
                                    "Diferenciar excessivamente (over-differencing)",
                                    "Não testar estacionariedade pós-transformação",
                                    "Ignorar PACF na comparação"
                                  ]
                                }
                              ],
                              "practicalExample": "Carregue dados diários de preços da ação AAPL (não-estacionária com tendência). Plote ACF: observe decaimento lento (ex: ACF(1)=0.99, ACF(10)=0.95). Diferencie os dados (preços -> retornos) e replote: ACF agora decai para zero após 2-3 lags, confirmando não-estacionariedade original.",
                              "finalVerifications": [
                                "Identifica corretamente decaimento lento em ACF de dados com tendência.",
                                "Compara com sucesso ACF estacionária vs. não-estacionária.",
                                "Propõe diferenciação como correção e verifica seu impacto.",
                                "Calcula lags significativos usando limites de confiança.",
                                "Explica implicações para modelagem de séries temporais.",
                                "Gera gráficos ACF profissionais com anotações."
                              ],
                              "assessmentCriteria": [
                                "Precisão na interpretação: 90% de acerto em identificação de padrões ACF.",
                                "Profundidade de análise: inclui quantificação (ex: metade-vida) e testes estatísticos.",
                                "Qualidade visual: gráficos claros, legíveis, com lags apropriados.",
                                "Raciocínio lógico: contraste explícito e propostas de ação corretas.",
                                "Aplicação prática: usa dados reais e transforma adequadamente.",
                                "Comunicação: relatório conciso e técnico correto."
                              ],
                              "crossCurricularConnections": [
                                "Economia: Análise de ciclos econômicos em PIB ou inflação.",
                                "Finanças: Detecção de caminhadas aleatórias em preços de ativos.",
                                "Engenharia: Monitoramento de sinais em controle de processos industriais.",
                                "Ciência Ambiental: Modelagem de temperaturas globais com tendências climáticas."
                              ],
                              "realWorldApplication": "Em finanças, detectar não-estacionariedade via ACF lento em preços de ações evita modelos inválidos, permitindo diferenciação para prever retornos voláteis e otimizar portfólios de investimento."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.4.2",
                            "name": "Explicar dependência temporal na autocorrelação",
                            "description": "Descrever como em séries com tendência ou variância variável, a autocorrelação serial varia com o tempo, requerendo testes como Dickey-Fuller.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de Autocorrelação em Séries Temporais Estacionárias",
                                  "subSteps": [
                                    "Defina autocorrelação serial como a correlação entre valores de uma série temporal em lags diferentes.",
                                    "Calcule a função de autocorrelação (ACF) para uma série estacionária usando fórmulas padrão.",
                                    "Plote a ACF de uma série estacionária simulada (ex: ruído branco vs. AR(1)).",
                                    "Interprete picos significativos na ACF e sua relação com dependência linear.",
                                    "Compare ACF de processos estacionários (MA, AR) para fixar o comportamento esperado."
                                  ],
                                  "verification": "Gere e interprete corretamente o plot ACF de uma série estacionária simulada, identificando lags significativos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python/R com bibliotecas statsmodels ou forecast",
                                    "Notebook Jupyter",
                                    "Dados simulados de AR(1) e ruído branco"
                                  ],
                                  "tips": "Sempre normalize a ACF para que o lag 0 seja 1; foque em bandas de confiança para significância.",
                                  "learningObjective": "Compreender o comportamento padrão da autocorrelação em séries estacionárias como base para contrastar com não-estacionárias.",
                                  "commonMistakes": [
                                    "Confundir autocorrelação com correlação cruzada",
                                    "Ignorar testes de significância nos lags",
                                    "Assumir estacionariedade sem verificação prévia"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Fontes de Não-Estacionariedade que Afetam a Autocorrelação",
                                  "subSteps": [
                                    "Explique tendência determinística e estocástica e seu impacto na variância da autocorrelação.",
                                    "Discuta heteroscedasticidade (variância variável) e como ela distorce a ACF ao longo do tempo.",
                                    "Simule uma série com tendência linear e plote sua ACF para observar padrões espúrios.",
                                    "Compare ACF de séries com variância crescente vs. constante.",
                                    "Descreva verbalmente por que a autocorrelação 'vaza' em séries não estacionárias."
                                  ],
                                  "verification": "Simule e plote ACF de uma série com tendência, explicando diferenças em relação à estacionária.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python/R",
                                    "Funções para adicionar tendência (ex: np.cumsum)",
                                    "Gráficos interativos com Plotly"
                                  ],
                                  "tips": "Use detrending temporário para visualizar o efeito isolado da tendência.",
                                  "learningObjective": "Reconhecer como tendência e variância variável introduzem dependência temporal na autocorrelação.",
                                  "commonMistakes": [
                                    "Atribuir toda não-estacionariedade apenas à tendência",
                                    "Não diferenciar entre tendência e sazonalidade",
                                    "Plotar ACF sem primeiro checar o gráfico da série"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar a Dependência Temporal na Autocorrelação",
                                  "subSteps": [
                                    "Defina dependência temporal na autocorrelação: coeficientes ACF mudam com o tempo ou janela de cálculo.",
                                    "Demonstre com ACF em janelas rolantes (rolling window ACF) em dados não estacionários.",
                                    "Analise como em séries com drift, lags iniciais mostram alta correlação que decai irregularmente.",
                                    "Discuta implicações para modelagem: suposições de estacionariedade violadas levam a forecasts enviesados.",
                                    "Formule matematicamente usando expectativa condicional variável no tempo."
                                  ],
                                  "verification": "Calcule e plote ACF rolante, descrevendo variações temporais observadas.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Código para rolling ACF (pandas rolling.apply)",
                                    "Dados reais como PIB ou ações",
                                    "Referência teórica: Brockwell & Davis"
                                  ],
                                  "tips": "Use janelas de tamanho 50-100 para equilíbrio entre suavidade e responsividade.",
                                  "learningObjective": "Articular conceitualmente como a não-estacionariedade causa autocorrelação dependente do tempo.",
                                  "commonMistakes": [
                                    "Assumir ACF constante em todas as séries",
                                    "Confundir dependência temporal com não-linearidade",
                                    "Não considerar o tamanho da amostra em janelas rolantes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Testes para Detectar e Confirmar Dependência Temporal (ex: Dickey-Fuller)",
                                  "subSteps": [
                                    "Descreva o teste Augmented Dickey-Fuller (ADF) para raiz unitária e não-estacionariedade.",
                                    "Implemente ADF em Python/R em séries com e sem tendência.",
                                    "Interprete p-valor, estatística teste e gráficos de resíduos.",
                                    "Compare com KPSS test para confirmação complementar.",
                                    "Discuta quando usar diferenças ou log-transforms baseados nos resultados."
                                  ],
                                  "verification": "Execute ADF em uma série não estacionária, rejeitando nula corretamente e propondo transformação.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "statsmodels.tsa.stattools.adfuller",
                                    "Dados de exemplo: AirPassengers ou stock prices",
                                    "Tabelas críticas de ADF"
                                  ],
                                  "tips": "Inclua lags no ADF para autocorrelação serial nos resíduos; cheque diagnósticos pós-teste.",
                                  "learningObjective": "Usar testes estatísticos para validar presença de dependência temporal na autocorrelação.",
                                  "commonMistakes": [
                                    "Ignorar lags nos resíduos do ADF",
                                    "Confundir não-rejeição da nula com estacionariedade",
                                    "Não testar múltiplas especificações (com/sem tendência)"
                                  ]
                                }
                              ],
                              "practicalExample": "Analise dados mensais de preços de ações (ex: AAPL). Plote a série (tendência clara), ACF padrão (alta persistência espúria), ACF rolante (variação temporal), e aplique ADF (não estacionária). Após log-diferença, ACF estabiliza, ilustrando dependência temporal resolvida.",
                              "finalVerifications": [
                                "Explique em 3 frases como tendência causa dependência temporal na ACF.",
                                "Gere plots ACF antes/depois de detrending em dados simulados.",
                                "Aplique ADF e interprete resultados corretamente (p-valor <0.05 após transformação).",
                                "Identifique 2 fontes de não-estacionariedade em um dataset real.",
                                "Descreva implicações para ARIMA se ignorar essa dependência.",
                                "Compare ACF rolante em janelas de diferentes tamanhos."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: Correta distinção entre ACF estacionária e dependente do tempo (30%)",
                                "Implementação prática: Plots e testes executados sem erros (25%)",
                                "Interpretação: Explicações claras com evidências visuais (20%)",
                                "Profundidade: Inclusão de fórmulas e exemplos reais (15%)",
                                "Criatividade: Sugestões de transformações personalizadas (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Economia: Análise de ciclos econômicos em PIB ou inflação.",
                                "Finanças: Detecção de bolhas em retornos de ativos.",
                                "Machine Learning: Pré-processamento para LSTM em séries temporais.",
                                "Física: Modelagem de sinais não estacionários em sensores."
                              ],
                              "realWorldApplication": "Em finanças, detectar dependência temporal na autocorrelação de retornos de ações evita modelos enviesados, melhorando previsões de risco (VaR) e estratégias de trading algorítmico; em meteorologia, corrige forecasts de temperatura com tendências climáticas."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.4.3",
                            "name": "Relacionar autocorrelação com métodos de previsão",
                            "description": "Discutir como autocorrelação dependente do tempo indica necessidade de modelos como ARIMA com diferenciação para capturar dependências.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de Autocorrelação em Séries Temporais",
                                  "subSteps": [
                                    "Defina autocorrelação (ACF) e sua função em séries temporais.",
                                    "Calcule a ACF para uma série estacionária vs. não estacionária usando software como Python (statsmodels).",
                                    "Interprete gráficos de ACF: decay exponencial rápido para estacionárias vs. lento para não estacionárias.",
                                    "Discuta o conceito de dependência temporal na autocorrelação.",
                                    "Compare ACF com PACF para entender ordens AR e MA."
                                  ],
                                  "verification": "Gere e interprete um gráfico ACF para uma série de exemplo; explique se indica estacionariedade.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python com bibliotecas pandas, statsmodels; dataset de série temporal simples (ex: AirPassengers).",
                                  "tips": "Sempre plote a série original junto com ACF para contexto visual.",
                                  "learningObjective": "Compreender como ACF revela padrões de dependência temporal.",
                                  "commonMistakes": "Confundir ACF com correlação simples; ignorar bandas de confiança no gráfico."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Autocorrelação Dependente do Tempo em Séries Não Estacionárias",
                                  "subSteps": [
                                    "Explique não-estacionariedade como variação na média/variância ao longo do tempo.",
                                    "Analise ACF em séries com tendência ou sazonalidade: observe decay lento ou sinusoidal.",
                                    "Teste estacionariedade com Augmented Dickey-Fuller (ADF) e relacione com ACF.",
                                    "Diferencie visualmente ACF de séries não estacionárias (alta persistência em lags iniciais).",
                                    "Documente evidências de dependência temporal via ACF."
                                  ],
                                  "verification": "Aplique ADF test e ACF plot em uma série não estacionária; conclua necessidade de modelagem avançada.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Jupyter Notebook; datasets não estacionários (ex: PIB trimestral); statsmodels.tsa.stattools.adfuller.",
                                  "tips": "Use log-transformação inicial para estabilizar variância antes de ACF.",
                                  "learningObjective": "Reconhecer sinais de autocorrelação dependente do tempo indicando não-estacionariedade.",
                                  "commonMistakes": "Assumir estacionariedade sem testes; focar só em lags baixos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir Modelos ARIMA e o Papel da Diferenciação",
                                  "subSteps": [
                                    "Descreva ARIMA(p,d,q): AR para autocorrelação, I para integração (diferenciação), MA para resíduos.",
                                    "Explique diferenciação: d=1 remove tendência linear; aplique em série não estacionária.",
                                    "Verifique ACF/PACF pós-diferenciação: deve mostrar decay rápido.",
                                    "Selecione parâmetros p,d,q via inspeção ACF/PACF e critérios como AIC.",
                                    "Ajuste modelo ARIMA e valide resíduos (sem autocorrelação)."
                                  ],
                                  "verification": "Ajuste ARIMA(0,1,1) em série diferenciada; confirme ACF de resíduos é ruído branco.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Python statsmodels.tsa.arima.model.ARIMA; mesmo dataset do Step 2.",
                                  "tips": "Comece com d=1; use auto_arima de pmdarima para automação inicial.",
                                  "learningObjective": "Entender como ARIMA com diferenciação captura dependências reveladas por ACF.",
                                  "commonMistakes": "Sobrediferenciação (d>2); ignorar sazonalidade (use SARIMA)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar Autocorrelação com Escolha e Aplicação de Métodos de Previsão",
                                  "subSteps": [
                                    "Sintetize: ACF lenta → não estacionária → diferenciação em ARIMA.",
                                    "Compare ARIMA com outros (ex: ETS para sazonalidade; Prophet para tendências).",
                                    "Gere previsões com ARIMA e avalie com MAE/RMSE.",
                                    "Discuta limitações: ARIMA assume linearidade; migre para LSTM se não linear.",
                                    "Escreva relatório relacionando ACF inicial com modelo escolhido."
                                  ],
                                  "verification": "Produza relatório de 1 página explicando relação ACF-ARIMA em exemplo real.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Relatório template; ferramentas de plotagem (matplotlib/seaborn).",
                                  "tips": "Sempre valide previsões out-of-sample para robustez.",
                                  "learningObjective": "Aplicar logicamente ACF para guiar seleção de modelos de previsão.",
                                  "commonMistakes": "Não validar estacionariedade pós-diferenciação; superestimar precisão sem métricas."
                                }
                              ],
                              "practicalExample": "Em dados de passageiros aéreos mensais (AirPassengers dataset), a ACF mostra decay muito lento nos lags iniciais, indicando não-estacionariedade por tendência. Aplique diferenciação (d=1): ACF pós-dif. mostra corte em lag 1 (MA(1)) e decay exponencial (AR(1)). Ajuste ARIMA(1,1,1), gere previsões para 12 meses à frente e compare com dados reais usando RMSE.",
                              "finalVerifications": [
                                "Explique verbalmente por que ACF lenta requer diferenciação em ARIMA.",
                                "Gere ACF plots antes/depois diferenciação e interprete diferenças.",
                                "Ajuste ARIMA em novo dataset e confirme resíduos sem autocorrelação (Ljung-Box test p>0.05).",
                                "Compare previsões ARIMA vs. média móvel simples.",
                                "Identifique 3 cenários onde ACF guia escolha de modelo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na interpretação de ACF (90% correção em identificação de não-estacionariedade).",
                                "Corretude na seleção e aplicação de diferenciação (d apropriado baseado em testes).",
                                "Qualidade das previsões (RMSE < benchmark simples).",
                                "Profundidade da relação explicada entre ACF e ARIMA (cobertura completa de p,d,q).",
                                "Clareza no relatório/prática (gráficos legíveis, explicações concisas).",
                                "Criatividade em extensões (ex: SARIMA para sazonalidade)."
                              ],
                              "crossCurricularConnections": [
                                "Economia: Previsão de séries macroeconômicas como inflação ou PIB.",
                                "Finanças: Modelagem de retornos de ações voláteis com ARIMA-GARCH.",
                                "Machine Learning: Transição de ARIMA para redes recorrentes (LSTM) em deep learning.",
                                "Ciência de Dados: Integração com feature engineering em pipelines preditivos."
                              ],
                              "realWorldApplication": "Em supply chain, analise ACF de demanda de produtos para detectar não-estacionariedade sazonal; aplique ARIMA com diferenciação para previsões precisas de estoque, reduzindo overstock em 20% e melhorando eficiência operacional em varejo como Amazon."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.2",
                    "name": "Testes de Estacionariedade",
                    "description": "Métodos como Teste de Dickey-Fuller Aumentado (ADF) e KPSS para detectar não-estacionariedade.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.2.1",
                        "name": "Estacionariedade em Séries Temporais",
                        "description": "Conceito fundamental de estacionariedade, definido como propriedades estatísticas constantes ao longo do tempo, incluindo média constante, variância finita e constante, e autocovariância que depende apenas do lag, essencial para validar modelos de previsão.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.1.1",
                            "name": "Definir estacionariedade",
                            "description": "Explicar formalmente o que é uma série temporal estacionária de segunda ordem, destacando os três componentes principais: média constante E[X_t] = μ, variância constante Var(X_t) = σ² e autocovariância Cov(X_t, X_{t+k}) = γ(k) independente de t.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de Séries Temporais",
                                  "subSteps": [
                                    "Revise a definição de uma série temporal como uma sequência de observações X_t ordenadas no tempo.",
                                    "Identifique exemplos comuns de séries temporais, como preços de ações ou temperaturas diárias.",
                                    "Diferencie séries temporais de dados independentes, enfatizando a dependência temporal.",
                                    "Estude a notação básica: X_t para o valor no tempo t.",
                                    "Explore gráficos de séries temporais para visualizar padrões."
                                  ],
                                  "verification": "Crie um gráfico simples de uma série temporal fictícia e rotule os eixos tempo e valor.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis ou software como Excel/Python (matplotlib)",
                                    "Exemplos de séries temporais online"
                                  ],
                                  "tips": "Comece com dados reais baixados de fontes como Yahoo Finance para visualização prática.",
                                  "learningObjective": "Entender o que constitui uma série temporal e sua representação básica.",
                                  "commonMistakes": [
                                    "Confundir séries temporais com regressões lineares simples",
                                    "Ignorar a ordem temporal nos dados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Conceito de Estacionariedade",
                                  "subSteps": [
                                    "Defina estacionariedade informalmente como propriedades estatísticas constantes ao longo do tempo.",
                                    "Discuta por que a estacionariedade é crucial para modelagem e previsão em séries temporais.",
                                    "Compare estacionariedade fraca (segunda ordem) com estacionariedade estrita.",
                                    "Liste condições necessárias para estacionariedade: ausência de tendência e sazonalidade variáveis.",
                                    "Analise um exemplo visual: gráfico estacionário vs. não estacionário."
                                  ],
                                  "verification": "Explique em suas palavras por que uma série com tendência crescente não é estacionária.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráficos de exemplo (estacionário: ruído branco; não estacionário: caminhada aleatória)",
                                    "Video tutorial curto sobre estacionariedade"
                                  ],
                                  "tips": "Use animações interativas online para ver como tendências quebram estacionariedade.",
                                  "learningObjective": "Graspar o conceito intuitivo de estacionariedade e sua importância.",
                                  "commonMistakes": [
                                    "Confundir estacionariedade com estacionariedade; focar apenas em média constante",
                                    "Pensar que variância zero implica estacionariedade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Formalmente Estacionariedade de Segunda Ordem",
                                  "subSteps": [
                                    "Estude a definição formal: E[X_t] = μ para todo t (média constante).",
                                    "Aprenda Var(X_t) = σ² constante para todo t (variância constante).",
                                    "Defina autocovariância: Cov(X_t, X_{t+k}) = γ(k), dependente apenas de k, não de t.",
                                    "Escreva as equações matemáticas para os três componentes.",
                                    "Verifique as propriedades derivadas, como autocorrelação ρ(k) = γ(k)/σ²."
                                  ],
                                  "verification": "Escreva as três equações principais e identifique qual componente falha em uma série com tendência.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de fórmulas de séries temporais",
                                    "Software R ou Python para calcular momentos (média, variância)"
                                  ],
                                  "tips": "Memorize as equações recitando-as em voz alta e derivando γ(k) de exemplos simples.",
                                  "learningObjective": "Dominar a definição matemática precisa de estacionariedade de segunda ordem.",
                                  "commonMistakes": [
                                    "Esquecer que autocovariância deve ser função apenas de lag k",
                                    "Confundir Cov com Cor"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Verificar os Componentes em Exemplos",
                                  "subSteps": [
                                    "Calcule manualmente média, variância e autocovariância para uma pequena série estacionária simulada.",
                                    "Identifique violações em séries reais: tendência afeta média, heteroscedasticidade afeta variância.",
                                    "Use fórmulas para provar que ruído branco gaussiano é estacionário.",
                                    "Compare com AR(1) estacionário vs. não estacionário (|φ| < 1).",
                                    "Documente os três componentes em um relatório curto."
                                  ],
                                  "verification": "Gere uma série de 10 pontos, calcule os momentos e confirme independência de t.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Calculadora ou Python (numpy para momentos, pandas para séries)",
                                    "Dados de exemplo: série de ruído branco"
                                  ],
                                  "tips": "Simule dados no Python com np.random.normal para prática hands-on.",
                                  "learningObjective": "Aplicar a definição formal aos três componentes em contextos práticos.",
                                  "commonMistakes": [
                                    "Calcular variância amostral incorretamente",
                                    "Não verificar independência de t na autocovariância"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere a série de retornos diários de ações (ex: log-retornos de AAPL). Calcule E[retorno_t] ≈ 0, Var(retorno_t) constante ≈ 0.01, e Cov(retorno_t, retorno_{t+1}) ≈ 0.05 independente de t, confirmando estacionariedade de segunda ordem para modelagem ARMA.",
                              "finalVerifications": [
                                "Explique verbalmente os três componentes sem consultar notas.",
                                "Identifique corretamente se uma série com média crescente é estacionária.",
                                "Escreva as equações de média, variância e autocovariância.",
                                "Calcule autocovariância para lag 1 em uma série de 5 pontos.",
                                "Diferencie estacionariedade de segunda ordem de estrita.",
                                "Forneça um exemplo real de série estacionária."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal dos três componentes (100% match com equações).",
                                "Capacidade de identificar violações em gráficos ou dados (acurácia >90%).",
                                "Explicação clara da independência de t na autocovariância.",
                                "Uso correto de notação matemática (E[], Var[], Cov[]).",
                                "Aplicação prática em exemplo numérico sem erros de cálculo.",
                                "Compreensão da relevância para testes futuros como Dickey-Fuller."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Probabilidade e Estatística (momentos, covariância).",
                                "Economia: Modelagem financeira (previsão de séries de preços).",
                                "Física: Processos estocásticos em dinâmica de sistemas.",
                                "Ciência de Dados: Pré-processamento para machine learning em time series."
                              ],
                              "realWorldApplication": "Em finanças, verificar estacionariedade de retornos de ações permite usar modelos ARIMA para previsões precisas de riscos e portfólios; em meteorologia, séries de temperatura estacionárias melhoram forecasts de longo prazo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.2",
                            "name": "Identificar sinais de não-estacionariedade",
                            "description": "Reconhecer visualmente e conceitualmente indícios de não-estacionariedade em séries temporais, como presença de tendência linear ou quadrática, heteroscedasticidade ou sazonalidade forte, usando gráficos de séries, autocorrelações e histogramas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos de estacionariedade e não-estacionariedade",
                                  "subSteps": [
                                    "Defina estacionariedade: média, variância e covariância constantes ao longo do tempo.",
                                    "Identifique tipos de não-estacionariedade: tendência (linear/quadrática), sazonalidade e heteroscedasticidade.",
                                    "Estude exemplos clássicos: série com drift vs. ruído branco.",
                                    "Revise propriedades matemáticas: autocovariância dependente do tempo.",
                                    "Compare estacionária vs. não-estacionária em termos de modelagem."
                                  ],
                                  "verification": "Explique em suas palavras os três componentes da estacionariedade e dê um exemplo de cada violação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de séries temporais (ex: Statsmodels docs)",
                                    "Vídeo introdutório sobre estacionariedade (YouTube ou Khan Academy)"
                                  ],
                                  "tips": "Use analogias como 'um rio calmo (estacionário) vs. um rio com correnteza crescente (não-estacionário)'.",
                                  "learningObjective": "Dominar definições conceituais para basear análises visuais.",
                                  "commonMistakes": [
                                    "Confundir variância constante com média constante",
                                    "Ignorar sazonalidade como forma de não-estacionariedade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inspecionar visualmente o gráfico da série temporal",
                                  "subSteps": [
                                    "Carregue dados de série temporal em Python (pandas.read_csv).",
                                    "Plote o gráfico de linha: séries vs. tempo.",
                                    "Identifique tendência: visualmente crescente/decrescente ou curva quadrática.",
                                    "Busque padrões sazonais: ciclos repetitivos (ex: picos anuais).",
                                    "Observe mudanças abruptas ou quebras estruturais."
                                  ],
                                  "verification": "Anote no gráfico setas apontando tendência ou sazonalidade e descreva-as.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python/Jupyter Notebook",
                                    "Bibliotecas: pandas, matplotlib",
                                    "Dataset exemplo: AirPassengers.csv"
                                  ],
                                  "tips": "Aumente o tamanho da figura para melhor visualização e use zoom em períodos suspeitos.",
                                  "learningObjective": "Reconhecer indícios visuais primários de não-estacionariedade.",
                                  "commonMistakes": [
                                    "Interpretar ruído aleatório como tendência",
                                    "Não escalar eixos para melhor percepção"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar funções de autocorrelação (ACF e PACF)",
                                  "subSteps": [
                                    "Calcule e plote ACF: correlações em lags.",
                                    "Identifique decaimento lento: indício de tendência (ACF não cai para zero rápido).",
                                    "Observe picos em lags múltiplos: sazonalidade forte (ex: lag 12 para mensal).",
                                    "Plote PACF: para confirmar componentes não sazonais.",
                                    "Compare com bandas de confiança: lags significativos fora das bandas."
                                  ],
                                  "verification": "Interprete o gráfico ACF/PACF: liste lags significativos e sua implicação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python: statsmodels.tsa.stattools.acf, plot_acf",
                                    "Dataset com sazonalidade conhecida"
                                  ],
                                  "tips": "Use plot_acf() e plot_pacf() do statsmodels para automação visual.",
                                  "learningObjective": "Usar ACF/PACF para detectar dependências temporais indicativas de não-estacionariedade.",
                                  "commonMistakes": [
                                    "Ignorar bandas de confiança",
                                    "Confundir ACF lenta com sazonalidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar heteroscedasticidade e distribuição",
                                  "subSteps": [
                                    "Plote histograma dos valores da série.",
                                    "Observe assimetria ou caudas pesadas: variância não constante.",
                                    "Divida a série em janelas móveis e compare variâncias.",
                                    "Plote resíduos ou diferenças: busque variância crescente/decrescente.",
                                    "Use teste visual de Box-Cox para normalidade aproximada."
                                  ],
                                  "verification": "Descreva mudanças na dispersão ao longo do tempo com evidências do histograma.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python: matplotlib.pyplot.hist, pandas.rolling.var",
                                    "Dataset com heteroscedasticidade (ex: retornos financeiros)"
                                  ],
                                  "tips": "Normalize os dados antes do histograma para focar na forma.",
                                  "learningObjective": "Detectar variância instável como sinal de não-estacionariedade.",
                                  "commonMistakes": [
                                    "Assumir homoscedasticidade sem checagem",
                                    "Usar histograma único sem janelas"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar evidências e concluir",
                                  "subSteps": [
                                    "Liste todos os indícios de cada análise anterior.",
                                    "Classifique: tendência, sazonalidade ou heteroscedasticidade dominante.",
                                    "Documente em relatório: gráficos + interpretações.",
                                    "Sugira transformações: log, diferenciação ou desazonalização.",
                                    "Valide com um colega ou auto-teste em nova série."
                                  ],
                                  "verification": "Crie um sumário escrito confirmando ou refutando não-estacionariedade com justificativas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notebook Jupyter para relatório",
                                    "Templates de relatório de análise"
                                  ],
                                  "tips": "Use uma tabela para resumir: Tipo | Evidência | Gráfico Referência.",
                                  "learningObjective": "Integrar múltiplas análises para diagnóstico robusto.",
                                  "commonMistakes": [
                                    "Priorizar visual sobre ACF",
                                    "Concluir sem múltiplas evidências"
                                  ]
                                }
                              ],
                              "practicalExample": "Carregue o dataset AirPassengers (passageiros aéreos mensais). Plote a série: observe tendência crescente e sazonalidade anual. ACF mostra decaimento lento e picos em lag 12. Histograma revela variância crescente. Conclusão: não-estacionária por tendência e sazonalidade.",
                              "finalVerifications": [
                                "Identificar corretamente tendência em 3 gráficos de séries fornecidos.",
                                "Interpretar ACF com decaimento lento como não-estacionariedade.",
                                "Detectar sazonalidade em picos regulares de ACF.",
                                "Reconhecer heteroscedasticidade em histograma com variância variável.",
                                "Sintetizar relatório com pelo menos 3 evidências convergentes.",
                                "Sugerir transformação apropriada (ex: diff para tendência)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação visual: 90% de acerto em indícios.",
                                "Correta interpretação de ACF/PACF: lags significativos explicados.",
                                "Análise de heteroscedasticidade com evidências quantitativas.",
                                "Relatório estruturado e completo com gráficos anotados.",
                                "Integração conceitual: ligação entre visual e estatístico.",
                                "Criatividade em exemplos reais aplicados."
                              ],
                              "crossCurricularConnections": [
                                "Economia: Análise de séries de PIB ou inflação para políticas públicas.",
                                "Finanças: Detecção em retornos de ações para modelagem de risco.",
                                "Meteorologia: Séries de temperatura com sazonalidade climática.",
                                "Engenharia: Monitoramento de sensores com tendências de desgaste."
                              ],
                              "realWorldApplication": "Em previsão de demanda de varejo, identificar não-estacionariedade em vendas mensais (tendência de crescimento + sazonalidade natalina) permite aplicar log-diferenças antes de ARIMA, melhorando precisão em estoques e receitas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.3",
                            "name": "Explicar implicações da não-estacionariedade",
                            "description": "Discutir por que séries não estacionárias invalidam modelos como ARMA, levando a previsões espúrias, e a necessidade de diferenciação ou transformações para induzir estacionariedade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir Estacionariedade e Identificar Não-Estacionariedade",
                                  "subSteps": [
                                    "Revise a definição estatística de estacionariedade: média, variância e covariância constantes ao longo do tempo.",
                                    "Analise componentes de uma série não estacionária: tendência, sazonalidade e heterocedasticidade.",
                                    "Examine gráficos de séries temporais reais para visualizar padrões não estacionários.",
                                    "Calcule estatísticas descritivas rolantes (média e variância) para demonstrar mudanças ao longo do tempo.",
                                    "Compare séries estacionárias vs. não estacionárias usando exemplos simples como caminhada aleatória."
                                  ],
                                  "verification": "Crie um gráfico mostrando média rolante variando, confirmando não-estacionariedade visualmente.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Python/R com bibliotecas pandas, matplotlib/statsmodels; dataset exemplo (ex: AirPassengers).",
                                  "tips": "Sempre plote a série primeiro; gráficos revelam problemas antes de testes formais.",
                                  "learningObjective": "Compreender conceitualmente o que torna uma série não estacionária.",
                                  "commonMistakes": "Confundir tendência determinística com estocástica; ignorar variância crescente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explicar Requisitos de Modelos ARMA para Estacionariedade",
                                  "subSteps": [
                                    "Estude a estrutura de modelos ARMA: dependência apenas em lags passados, assumindo processos estacionários.",
                                    "Derive matematicamente por que autocorrelações em séries não estacionárias não decaem rapidamente.",
                                    "Simule um modelo ARMA em uma série estacionária e observe ajuste adequado.",
                                    "Aplique o mesmo modelo a uma série não estacionária e note coeficientes instáveis.",
                                    "Discuta a teoria de Wold: decomposição de processos estacionários em componentes previsíveis e ruído."
                                  ],
                                  "verification": "Execute simulação em código e compare ACF/PACF plots antes/depois de modelagem.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Jupyter Notebook; bibliotecas statsmodels ou forecast em R; dados simulados.",
                                  "tips": "Use ACF para diagnóstico rápido: decaimento lento indica não-estacionariedade.",
                                  "learningObjective": "Entender por que ARMA falha em séries não estacionárias devido a dependências espúrias.",
                                  "commonMistakes": "Assumir que ARMA lida com tendências sem diferenciação; ignorar pressupostos teóricos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Previsões Espúrias e Seus Riscos",
                                  "subSteps": [
                                    "Defina previsões espúrias: correlações significativas entre séries não relacionadas devido a tendências comuns.",
                                    "Simule duas caminhadas aleatórias integradas e aplique regressão/cointegração falsa.",
                                    "Calcule testes de significância e mostre p-valores baixos erroneamente.",
                                    "Compare com séries estacionárias para destacar a diferença em resultados.",
                                    "Discuta implicações práticas: políticas baseadas em modelos inválidos."
                                  ],
                                  "verification": "Gere relatório com regressão espúria mostrando R² alto mas resíduos não estacionários.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Python com statsmodels.tsa; datasets simulados de caminhadas aleatórias.",
                                  "tips": "Teste resíduos do modelo para estacionariedade para detectar espúrias.",
                                  "learningObjective": "Identificar e quantificar riscos de modelagem em dados não estacionários.",
                                  "commonMistakes": "Interpretar significância estatística como causalidade real; subestimar impacto em previsões de longo prazo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Transformações para Induzir Estacionariedade",
                                  "subSteps": [
                                    "Introduza diferenciação de primeira ordem e verifique impacto em ACF.",
                                    "Aplique log-transformação para estabilizar variância em séries multiplicativas.",
                                    "Teste detrending (remoção de tendência linear) e des-sazonalização.",
                                    "Avalie múltiplas transformações em um dataset real e selecione a melhor via testes.",
                                    "Modele ARMA na série transformada e valide previsões out-of-sample."
                                  ],
                                  "verification": "Execute teste ADF/KPSS pós-transformação mostrando p-valor indicando estacionariedade.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "R/Python com urca/forecast; dataset real (ex: preços de ações ou PIB).",
                                  "tips": "Comece com diferenciação simples; over-differencing cria unit roots desnecessários.",
                                  "learningObjective": "Dominar técnicas práticas para corrigir não-estacionariedade.",
                                  "commonMistakes": "Diferenciar excessivamente levando a perda de informação; ignorar sazonalidade."
                                }
                              ],
                              "practicalExample": "Analise a série de preços diários do Bitcoin (não estacionária devido a bolhas). Aplique ARMA diretamente: ACF lento, previsões ruins. Diferencie uma vez, aplique ARMA(1,1), compare MSE de previsões vs. modelo original.",
                              "finalVerifications": [
                                "Explicar verbalmente por que ARMA requer estacionariedade com exemplo matemático.",
                                "Simular previsão espúria entre PIB e temperatura aleatória.",
                                "Aplicar diferenciação em dataset real e mostrar teste ADF passando.",
                                "Discutir 3 riscos de ignorar não-estacionariedade em forecasting.",
                                "Comparar gráficos ACF pré/pós-transformação.",
                                "Identificar não-estacionariedade em nova série desconhecida."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas de estacionariedade e espúrias (30%).",
                                "Profundidade analítica: uso correto de simulações e testes (25%).",
                                "Exemplos práticos: relevância e código funcional (20%).",
                                "Clareza explicativa: linguagem acessível sem erros (15%).",
                                "Completude: cobertura de transformações e verificações (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Econometria: cointegração em finanças (ex: pares de ações).",
                                "Economia: modelagem de ciclos econômicos e inflação.",
                                "Ciência de Dados: pré-processamento em ML para time series forecasting.",
                                "Física: análise de sinais não estacionários em sensores."
                              ],
                              "realWorldApplication": "Em bancos centrais, prever inflação sem corrigir não-estacionariedade leva a políticas monetárias falhas; corretamente, diferenciação permite modelos ARIMA precisos para metas de inflação estável."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.2.2",
                        "name": "Teste de Dickey-Fuller Aumentado (ADF)",
                        "description": "Teste unit root para detectar não-estacionariedade, baseado na regressão aumentada com lags para corrigir autocorrelação, testando H0: presença de raiz unitária (não-estacionária) contra H1: estacionária.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.2.1",
                            "name": "Enunciar hipóteses e modelo do ADF",
                            "description": "Formular as hipóteses nula (ρ=0, raiz unitária) e alternativa do teste ADF, e escrever a equação de regressão Δy_t = α + β t + γ y_{t-1} + ∑ δ_i Δy_{t-i} + ε_t, incluindo casos sem tendência ou constante.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as Hipóteses Nula e Alternativa do Teste ADF",
                                  "subSteps": [
                                    "Revise o conceito de raiz unitária em processos AR(1): y_t = ρ y_{t-1} + ε_t.",
                                    "Identifique a hipótese nula H0: ρ = 1 (equivalente a ρ = 0 na forma transformada, indicando não-estacionariedade).",
                                    "Defina a hipótese alternativa H1: |ρ| < 1 (estacionariedade ao redor de uma tendência determinística).",
                                    "Compare com teste t tradicional: por que não usamos t-stat padrão?",
                                    "Anote exemplos onde H0 é verdadeira (ex: caminhada aleatória)."
                                  ],
                                  "verification": "Escreva H0 e H1 corretamente em um papel ou documento, confirmando ρ=0 na forma Δy.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de aula sobre séries temporais",
                                    "Artigo introdutório sobre teste ADF (Dickey-Fuller 1979)"
                                  ],
                                  "tips": "Lembre-se: H0 sempre indica presença de raiz unitária (não-estacionariedade).",
                                  "learningObjective": "Dominar a formulação precisa das hipóteses nula e alternativa no contexto ADF.",
                                  "commonMistakes": [
                                    "Confundir ρ=1 com ρ=0 (use a reparametrização Δy_t = (ρ-1)y_{t-1} + ... para γ = ρ-1, H0: γ=0).",
                                    "Invertar H0 e H1.",
                                    "Ignorar que H1 é estacionariedade de dois lados."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender a Equação de Regressão Geral do ADF",
                                  "subSteps": [
                                    "Estude a transformação: Δy_t = α + β t + γ y_{t-1} + ∑_{i=1}^p δ_i Δy_{t-i} + ε_t.",
                                    "Explique cada parâmetro: α (intercepto), β (coeficiente de tendência), γ (teste de raiz unitária), δ_i (lags para correção serial).",
                                    "Implemente em software como R (ur.df) ou Python (statsmodels.tsa.stattools.adfuller) para visualizar.",
                                    "Calcule manualmente para p=0 (DF simples) com dados fictícios.",
                                    "Registre a importância dos lags para tornar ε_t branco."
                                  ],
                                  "verification": "Escreva a equação completa e identifique todos os termos corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software R/Python com pacotes forecast/statsmodels",
                                    "Dados de série temporal exemplo (ex: AirPassengers)"
                                  ],
                                  "tips": "A equação vem da subtração do AR(p+1) para eliminar raiz unitária.",
                                  "learningObjective": "Reproduzir e interpretar a equação de regressão ADF padrão.",
                                  "commonMistakes": [
                                    "Esquecer os lags Δy_{t-i}.",
                                    "Confundir γ com ρ (γ = ρ - 1).",
                                    "Omitir ε_t como ruído branco."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Casos Especiais: Sem Constante ou Tendência",
                                  "subSteps": [
                                    "Caso 1 - Sem constante, com tendência: Δy_t = β t + γ y_{t-1} + ∑ δ_i Δy_{t-i} + ε_t.",
                                    "Caso 2 - Com constante, sem tendência: Δy_t = α + γ y_{t-1} + ∑ δ_i Δy_{t-i} + ε_t.",
                                    "Caso 3 - Nenhum: Δy_t = γ y_{t-1} + ∑ δ_i Δy_{t-i} + ε_t.",
                                    "Discuta quando usar cada (ex: sem drift para retornos de ações).",
                                    "Compare estatísticas críticas para cada caso."
                                  ],
                                  "verification": "Liste as 3 variações da equação com α=0 ou β=0 explicitamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela de valores críticos ADF (MacKinnon)",
                                    "Exemplos de código para diferentes especificações"
                                  ],
                                  "tips": "Use o teste de significância de α e β para escolher o modelo.",
                                  "learningObjective": "Adaptar o modelo ADF às características da série temporal.",
                                  "commonMistakes": [
                                    "Aplicar modelo com tendência a séries sem ela (supresspecification).",
                                    "Confundir ordem de lags com presença de termos determinísticos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar a Formulação Completa de Hipóteses e Modelo",
                                  "subSteps": [
                                    "Escolha uma série real (ex: log PIB Brasil).",
                                    "Enuncie H0: γ=0 (raiz unitária) vs H1: γ<0.",
                                    "Escreva a equação apropriada baseada em plot (com tendência?).",
                                    "Simule regressão e interprete.",
                                    "Repita com outra série para reforço."
                                  ],
                                  "verification": "Produza um parágrafo com H0/H1 e equação para uma série dada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Dados econômicos (FGV/IBGE)",
                                    "Jupyter Notebook ou R script"
                                  ],
                                  "tips": "Sempre justifique a escolha do modelo com gráficos ACF/PACF.",
                                  "learningObjective": "Integrar hipóteses e modelo em um enunciado completo e contextualizado.",
                                  "commonMistakes": [
                                    "Não especificar lags p.",
                                    "Usar estatística t padrão ao invés de ADF crítica."
                                  ]
                                }
                              ],
                              "practicalExample": "Para a série de preços de ações da PETR4 (diários): Enuncie H0: γ=0 (raiz unitária, não-estacionária) vs H1: γ<0. Escreva ΔP_t = α + γ P_{t-1} + ∑_{i=1}^2 δ_i ΔP_{t-i} + ε_t (com constante, sem tendência, lags=2 por AIC).",
                              "finalVerifications": [
                                "Pode enunciar H0 como 'presença de raiz unitária (γ=0)' e H1 corretamente.",
                                "Escreve a equação geral ADF sem erros.",
                                "Adapta o modelo para casos sem α ou β.",
                                "Explica o papel dos lags δ_i.",
                                "Identifica valores críticos vs t padrão.",
                                "Aplica a uma série real com justificativa."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação de H0/H1 (ρ=0/raiz unitária).",
                                "Correção na equação de regressão (todos termos presentes).",
                                "Compreensão de variações do modelo (3 casos).",
                                "Justificativa contextual para escolha de especificação.",
                                "Ausência de confusões comuns (ex: γ vs ρ).",
                                "Capacidade de aplicação prática."
                              ],
                              "crossCurricularConnections": [
                                "Estatística Inferencial: Testes de hipóteses e distribuições assintóticas.",
                                "Econometria: Modelos ARIMA e cointegration.",
                                "Programação: Implementação em R/Python (statsmodels/urca).",
                                "Economia: Análise de ciclos e previsão macroeconômica.",
                                "Matemática: Álgebra linear em processos estocários."
                              ],
                              "realWorldApplication": "Em finanças, testar estacionariedade de retornos de ativos para modelar volatilidade (GARCH); em macroeconomia, verificar se PIB per capita tem raiz unitária antes de forecasting ou cointegration com juros."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.2.2",
                            "name": "Interpretar resultados do ADF",
                            "description": "Analisar a estatística de teste, valor p e valores críticos de MacKinnon, rejeitando H0 se p < 0.05, e discutir poder do teste em presença de tendência ou breaks estruturais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Examinar a saída padrão do teste ADF",
                                  "subSteps": [
                                    "Identifique a estatística de teste ADF (ADF statistic) no output.",
                                    "Localize o valor p (p-value) associado ao teste.",
                                    "Anote os valores críticos de MacKinnon para 1%, 5% e 10% de significância.",
                                    "Verifique o número de lags selecionados e o modelo usado (sem constante, com constante, com tendência).",
                                    "Confira o tamanho da amostra e quaisquer avisos sobre o teste."
                                  ],
                                  "verification": "Liste corretamente todos os componentes principais da saída do ADF de um exemplo de output.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Software de análise (Python com statsmodels ou R com urca)",
                                    "Exemplo de output ADF de um dataset de série temporal"
                                  ],
                                  "tips": "Sempre copie a saída completa do teste para análise antes de interpretar.",
                                  "learningObjective": "Compreender e identificar todos os elementos chave na saída do teste ADF.",
                                  "commonMistakes": [
                                    "Confundir a estatística ADF com o p-value",
                                    "Ignorar o tipo de modelo especificado (c, t, ct)",
                                    "Não notar avisos sobre amostra pequena"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a estatística de teste e valor p",
                                  "subSteps": [
                                    "Compare a estatística ADF com os valores críticos de MacKinnon (mais negativo indica rejeição de H0).",
                                    "Interprete o p-value: p < 0.05 sugere rejeição de H0 em 5% de nível.",
                                    "Calcule manualmente se a estatística está abaixo do crítico de 5%.",
                                    "Considere o nível de significância escolhido (1%, 5%, 10%).",
                                    "Registre se o teste é one-sided e a direção da rejeição."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que o p-value leva a uma decisão específica em um exemplo.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Tabela de valores críticos de MacKinnon (disponível online ou em pacotes)",
                                    "Output ADF de exemplo"
                                  ],
                                  "tips": "Use o p-value como métrica primária para simplicidade, mas sempre cheque os críticos para confirmação.",
                                  "learningObjective": "Avaliar corretamente a significância estatística da estatística ADF.",
                                  "commonMistakes": [
                                    "Usar p > 0.05 para rejeitar H0 incorretamente",
                                    "Comparar com valores críticos errados para o modelo",
                                    "Ignorar que valores críticos variam com o tamanho da amostra"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Decidir sobre a rejeição da H0 e estacionariedade",
                                  "subSteps": [
                                    "Enuncie a H0: presença de raiz unitária (não-estacionariedade).",
                                    "Rejeite H0 se p < 0.05 ou estatística < crítico de 5%; caso contrário, não rejeite.",
                                    "Conclua sobre estacionariedade: rejeição implica estacionária; não rejeição sugere não-estacionária.",
                                    "Documente a decisão com evidência numérica do teste.",
                                    "Considere testes complementares se borderline (ex: p próximo a 0.05)."
                                  ],
                                  "verification": "Escreva uma conclusão clara sobre estacionariedade baseada em um output ADF fornecido.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "Output ADF real ou simulado",
                                    "Folha de decisão H0/H1 para ADF"
                                  ],
                                  "tips": "Sempre especifique o nível de significância usado na decisão para transparência.",
                                  "learningObjective": "Tomar decisões hipoteséticas precisas sobre estacionariedade com base no ADF.",
                                  "commonMistakes": [
                                    "Confundir H0 com estacionariedade (H0 é não-estacionária)",
                                    "Rejeitar H0 baseado apenas em intuição sem números",
                                    "Não especificar o modelo no relatório da decisão"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir poder do teste e limitações",
                                  "subSteps": [
                                    "Explique que o poder do ADF diminui com tendência determinística forte.",
                                    "Descreva como breaks estruturais (ex: crises) reduzem o poder, levando a falsos não-rejeições.",
                                    "Sugira alternativas como testes com breaks (ex: Zivot-Andrews) ou detrending prévio.",
                                    "Avalie o impacto no contexto da série: verifique plots para tendências/breaks.",
                                    "Recomende interpretação cautelosa se houver suspeita de breaks."
                                  ],
                                  "verification": "Identifique limitações específicas em um output ADF com tendência ou break simulado.",
                                  "estimatedTime": "30-40 minutos",
                                  "materials": [
                                    "Gráficos de séries com tendência/breaks",
                                    "Referências sobre poder do ADF (Dickey-Fuller papers)"
                                  ],
                                  "tips": "Sempre plote a série temporal primeiro para detectar problemas visuais antes de interpretar poder.",
                                  "learningObjective": "Reconhecer e discutir cenários onde o ADF tem baixo poder estatístico.",
                                  "commonMistakes": [
                                    "Ignorar limitações e tratar ADF como infalível",
                                    "Não diferenciar tendência determinística de estocástica",
                                    "Subestimar breaks estruturais em séries econômicas"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dados mensais de PIB real do Brasil (1980-2023) em Python: from statsmodels.tsa.stattools import adfuller; result = adfuller(pib_data); print(result). Suponha estatística ADF = -2.8, p-value=0.23, críticos MacKinnon 5%=-2.9. Não rejeite H0 (p>0.05), série não-estacionária. Discuta: possível break em 2014 (crise), reduzindo poder; sugira teste com breaks.",
                              "finalVerifications": [
                                "Corretamente identifica estatística ADF, p-value e críticos em qualquer output.",
                                "Decide rejeição de H0 com justificativa numérica precisa.",
                                "Explica impacto de tendência/breaks no poder do teste.",
                                "Conclui sobre estacionariedade com qualificações apropriadas.",
                                "Sugere próximos passos se ADF falhar (ex: diferenciar ou testes robustos).",
                                "Documenta interpretação em relatório curto e claro."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de componentes do output (90%+ correto).",
                                "Correta aplicação de regra p<0.05 e comparação com críticos.",
                                "Profundidade na discussão de limitações e poder do teste.",
                                "Clareza e estrutura na conclusão escrita.",
                                "Uso de evidências numéricas e plots para suporte.",
                                "Identificação de erros comuns evitados na interpretação."
                              ],
                              "crossCurricularConnections": [
                                "Econometria: Aplicação em modelagem VAR/ARIMA para forecasting econômico.",
                                "Economia: Análise de ciclos business e políticas monetárias.",
                                "Finanças: Teste de eficiência de mercados e modelagem de retornos.",
                                "Matemática Aplicada: Teoria de processos estocásticos e raiz unitária.",
                                "Ciência de Dados: Pré-processamento de séries temporais em ML."
                              ],
                              "realWorldApplication": "Em bancos centrais, como o BC do Brasil, interpretar ADF em inflação ou câmbio para decidir differencing em modelos de previsão, evitando spurious regressions em políticas anti-inflacionárias; ou em trading algorítmico para detectar mean-reversion em ativos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.2.3",
                            "name": "Selecionar lags no ADF",
                            "description": "Aplicar critérios como AIC, BIC ou teste sequencial para determinar o número ótimo de lags no modelo aumentado, evitando subespecificação que infla a estatística de teste.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os critérios de seleção de lags: AIC, BIC e teste sequencial",
                                  "subSteps": [
                                    "Estude a fórmula do Critério de Informação de Akaike (AIC): AIC = -2*log(L) + 2*k, onde L é a verossimilhança e k o número de parâmetros.",
                                    "Analise o Critério de Informação Bayesiano (BIC): BIC = -2*log(L) + k*log(n), penalizando mais modelos complexos em amostras grandes.",
                                    "Aprenda o teste sequencial de Dickey-Fuller: inicie com lag máximo e reduza até rejeitar a hipótese nula de autocorrelação serial nos resíduos.",
                                    "Compare vantagens: AIC favorece mais lags, BIC é mais parcimonioso; teste sequencial é robusto para resíduos.",
                                    "Revise impactos da subespecificação: poucos lags causam resíduos autocorrelacionados, inflando a estatística ADF."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre AIC e BIC, com fórmulas, e dê um exemplo numérico simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação de statsmodels (Python) ou urca (R)",
                                    "Artigos sobre critérios de informação",
                                    "Planilha para simular fórmulas"
                                  ],
                                  "tips": [
                                    "Memorize que BIC penaliza mais que AIC para grandes n; pratique com dados simulados AR(1)."
                                  ],
                                  "learningObjective": "Dominar os conceitos teóricos dos critérios AIC, BIC e teste sequencial para seleção de lags no ADF.",
                                  "commonMistakes": [
                                    "Confundir AIC com BIC sem notar a penalização log(n)",
                                    "Ignorar que AIC pode superespecificar lags",
                                    "Não considerar tamanho da amostra na escolha do critério"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar dados e estimar modelos ADF com diferentes números de lags",
                                  "subSteps": [
                                    "Carregue a série temporal não estacionária (ex: log-retornos de PIB) em Python (statsmodels.tsa.stattools.adfuller) ou R (ur.df).",
                                    "Defina um intervalo de lags: de 0 até 12 (regra prática: 12*(100/T)^{1/4}, onde T é o tamanho da amostra).",
                                    "Estime o teste ADF para cada lag, salvando estatísticas, p-valores e resíduos.",
                                    "Extraia resíduos dos modelos e teste autocorrelação inicial com Ljung-Box.",
                                    "Registre em tabela: lag, estatística ADF, p-valor e resíduos sumário."
                                  ],
                                  "verification": "Gere uma tabela com resultados ADF para lags 0-5 em um dataset teste, confirmando sem erros de código.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python com pandas, statsmodels",
                                    "R com urca, tseries",
                                    "Dataset exemplo: AirPassengers ou PIB trimestral"
                                  ],
                                  "tips": [
                                    "Use maxlag='auto' inicialmente para benchmark; sempre plote resíduos ACF/PACF."
                                  ],
                                  "learningObjective": "Implementar computacionalmente testes ADF com variação de lags em software estatístico.",
                                  "commonMistakes": [
                                    "Definir lags fixos sem regra heurística",
                                    "Não testar resíduos por autocorrelação",
                                    "Usar lags excessivos causando perda de graus de liberdade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular e comparar critérios AIC, BIC e aplicar teste sequencial",
                                  "subSteps": [
                                    "Calcule AIC e BIC para cada modelo ADF usando funções built-in (statsmodels.summary() ou ur.df$vcM).",
                                    "Identifique o lag mínimo para AIC e BIC separadamente.",
                                    "Aplique teste sequencial: comece com lag max, teste LM para autocorrelação nos resíduos; reduza lag até p>0.05.",
                                    "Compare resultados: plote AIC/BIC vs lags e destaque mínimos.",
                                    "Avalie consistência entre critérios; escolha o mais parcimonioso se divergirem."
                                  ],
                                  "verification": "Produza gráfico de AIC/BIC por lag e selecione lags ótimos, justificando com valores numéricos.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Jupyter Notebook ou R Markdown",
                                    "Funções statsmodels.tsa.stattools ou urca::ur.df",
                                    "Gráficos matplotlib/ggplot2"
                                  ],
                                  "tips": [
                                    "BIC é preferido em amostras grandes; teste sequencial resolve ambiguidades."
                                  ],
                                  "learningObjective": "Aplicar quantitativamente critérios para ranquear modelos ADF por lags.",
                                  "commonMistakes": [
                                    "Calcular AIC/BIC manualmente sem funções prontas",
                                    "Ignorar resíduos no teste sequencial",
                                    "Selecionar lag por visual só, sem valores"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Selecionar lag ótimo, validar e interpretar resultados",
                                  "subSteps": [
                                    "Escolha lag final: mínimo BIC ou sequencial, confirmando resíduos sem autocorrelação (Ljung-Box p>0.05).",
                                    "Re-estime ADF com lag selecionado e interprete estatística/p-valor para H0 de unidade raiz.",
                                    "Teste sensibilidade: varie ±1 lag e compare p-valores.",
                                    "Documente decisão: tabela final com critérios e justificativa.",
                                    "Discuta implicações: lag ótimo evita viés na rejeição de estacionariedade."
                                  ],
                                  "verification": "Relatório curto (1 página) com lag escolhido, critérios e validação de resíduos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Notebook com código completo",
                                    "Testes Ljung-Box (statsmodels.stats.diagnostic.acorr_ljungbox)"
                                  ],
                                  "tips": [
                                    "Sempre valide com múltiplos critérios; lags altos indicam possível não-linearidade."
                                  ],
                                  "learningObjective": "Integrar critérios para decisão final robusta na seleção de lags ADF.",
                                  "commonMistakes": [
                                    "Não validar resíduos finais",
                                    "Mudar critério arbitrariamente",
                                    "Ignorar perda de poder estatístico com lags altos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma série de preços de Bitcoin diários (2015-2023), carregue dados via yfinance em Python. Estime ADF com lags 0-20: AIC seleciona lag=3 (AIC=-2450), BIC lag=1 (BIC=-2480), sequencial confirma lag=2 (resíduos sem AR). Use lag=2 para teste final: p-valor=0.85, não rejeita não-estacionariedade.",
                              "finalVerifications": [
                                "Explicar por que subespecificar lags infla estatística ADF.",
                                "Calcular manualmente AIC para dois modelos hipotéticos.",
                                "Implementar código completo para seleção em novo dataset.",
                                "Identificar lag ótimo em tabela de resultados fornecida.",
                                "Discutir quando preferir BIC vs AIC.",
                                "Validar resíduos com Ljung-Box em exemplo próprio."
                              ],
                              "assessmentCriteria": [
                                "Correta compreensão teórica de AIC/BIC/sequencial (fórmulas e penalizações).",
                                "Implementação precisa de código ADF com variação de lags sem erros.",
                                "Seleção consistente de lag ótimo com múltiplos critérios.",
                                "Validação robusta de resíduos (sem autocorrelação detectada).",
                                "Interpretação clara de implicações para teste de estacionariedade.",
                                "Documentação completa com tabelas/gráficos justificativos.",
                                "Tratamento de edge cases (amostras pequenas/grandes lags)."
                              ],
                              "crossCurricularConnections": [
                                "Programação Estatística (Python/R para automação de testes).",
                                "Econometria (aplicação em séries macroeconômicas).",
                                "Otimização e Machine Learning (seleção de hiperparâmetros via critérios informação).",
                                "Estatística Inferencial (testes de hipóteses em resíduos).",
                                "Análise de Dados Financeiros (previsão de ativos voláteis)."
                              ],
                              "realWorldApplication": "Na previsão de séries econômicas como taxa de câmbio ou inflação, selecionar lags ótimos no ADF via BIC garante testes de estacionariedade confiáveis, evitando modelagem errônea que leva a políticas monetárias falhas ou estratégias de trading perdidas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.2.4",
                            "name": "Implementar ADF em software",
                            "description": "Executar o teste ADF em R usando ur.df() do pacote urca ou em Python com adfuller() do statsmodels, interpretando saídas como estatística, p-valor e lags selecionados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de software e instalar pacotes necessários",
                                  "subSteps": [
                                    "Instale R ou Python se não estiverem disponíveis no seu sistema.",
                                    "No R, execute install.packages('urca') no console.",
                                    "No Python, execute pip install statsmodels no terminal.",
                                    "Reinicie o ambiente (RStudio ou Jupyter Notebook) para garantir carregamento.",
                                    "Verifique a instalação importando/carregando os pacotes."
                                  ],
                                  "verification": "Execute library(urca) em R ou import statsmodels em Python sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "R ou Python instalado",
                                    "RStudio ou Jupyter Notebook",
                                    "Acesso à internet para pacotes"
                                  ],
                                  "tips": [
                                    "Use um ambiente virtual no Python para evitar conflitos.",
                                    "Teste em um script novo para isolar dependências."
                                  ],
                                  "learningObjective": "Configurar corretamente ferramentas para testes de séries temporais.",
                                  "commonMistakes": [
                                    "Esquecer de reiniciar o kernel/session após instalação.",
                                    "Instalar pacotes errados como 'urdf' em vez de 'urca'."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar e carregar a série temporal de dados",
                                  "subSteps": [
                                    "Obtenha um conjunto de dados de série temporal (ex: AirPassengers no R ou dataset similar no Python).",
                                    "No R: data(AirPassengers); ap <- AirPassengers.",
                                    "No Python: from statsmodels.datasets import get_rdataset; data = get_rdataset('AirPassengers').data; ap = data['value'].astype(float).",
                                    "Converta para vetor/ts se necessário: ts(ap, frequency=12).",
                                    "Visualize com plot() para confirmar estrutura temporal."
                                  ],
                                  "verification": "Gráfico da série exibido corretamente sem erros de formato.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Dataset exemplo: AirPassengers",
                                    "Funções plot() ou matplotlib"
                                  ],
                                  "tips": [
                                    "Garanta que os dados sejam numéricos e sem NAs.",
                                    "Defina frequency corretamente para sazonalidade."
                                  ],
                                  "learningObjective": "Preparar dados adequados para teste ADF.",
                                  "commonMistakes": [
                                    "Ignorar NAs, causando falha no teste.",
                                    "Não converter para ts, levando a lags incorretos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar o teste ADF usando ur.df() ou adfuller()",
                                  "subSteps": [
                                    "No R: summary(ur.df(ap, type='trend', lags=12)).",
                                    "No Python: from statsmodels.tsa.stattools import adfuller; result = adfuller(ap).",
                                    "Registre os outputs: estatística do teste, p-valor, lags selecionados.",
                                    "Teste com diferentes tipos: 'none', 'drift', 'trend'.",
                                    "Salve resultados em variáveis para inspeção."
                                  ],
                                  "verification": "Output completo gerado com estatística, p-valor e critical values.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Pacotes urca/statsmodels carregados",
                                    "Dados preparados do step 2"
                                  ],
                                  "tips": [
                                    "Comece com lags automáticos (AIC).",
                                    "Use type='trend' para séries com tendência."
                                  ],
                                  "learningObjective": "Executar ADF corretamente em ambos os softwares.",
                                  "commonMistakes": [
                                    "Usar lags fixos baixos, invalidando o teste.",
                                    "Confundir adfuller() com outros testes como kpss()."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar as saídas do teste ADF",
                                  "subSteps": [
                                    "Identifique a estatística do teste (Test statistic).",
                                    "Compare p-valor com 0.05: <0.05 rejeita H0 (estacionária).",
                                    "Analise lags selecionados e valores críticos.",
                                    "Conclua sobre estacionariedade: estacionária se rejeitar H0.",
                                    "Documente interpretação em relatório ou print."
                                  ],
                                  "verification": "Relatório escrito com conclusão clara sobre estacionariedade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Outputs do step 3",
                                    "Tabela de valores críticos padrão"
                                  ],
                                  "tips": [
                                    "p-valor é chave; estatística deve ser mais negativa que crítica.",
                                    "Considere tamanho da amostra para robustez."
                                  ],
                                  "learningObjective": "Interpretar resultados ADF para decisões em séries temporais.",
                                  "commonMistakes": [
                                    "Rejeitar H0 incorretamente se p-valor >0.05.",
                                    "Ignorar lags, afetando significância."
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dados mensais de passageiros aéreos (AirPassengers): Execute ADF e interprete p-valor ~0.99 indicando não-estacionariedade, justificando diferenciação antes de modelagem ARIMA.",
                              "finalVerifications": [
                                "Códigos R e Python executados sem erros.",
                                "Outputs incluem estatística, p-valor e lags.",
                                "Interpretação correta de estacionariedade.",
                                "Gráficos de dados e resultados salvos.",
                                "Relatório com conclusões documentado.",
                                "Teste repetido com variação de parâmetros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na execução do código (sem erros sintáticos).",
                                "Correta preparação de dados temporais.",
                                "Interpretação precisa de p-valor e conclusão.",
                                "Uso apropriado de lags e tipos de teste.",
                                "Documentação clara dos resultados.",
                                "Reprodutibilidade do código."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Manipulação de dados em R/Python.",
                                "Econometria: Aplicação em forecasting econômico.",
                                "Matemática: Estatística inferencial e hipóteses.",
                                "Ciência de Dados: Pré-processamento de séries temporais."
                              ],
                              "realWorldApplication": "Em finanças, testar estacionariedade de retornos de ações antes de modelar volatilidade; em meteorologia, validar séries de temperatura para previsões climáticas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.2.3",
                        "name": "Teste KPSS",
                        "description": "Teste complementar ao ADF para estacionariedade em nível ou tendência, com H0: série é estacionária (ou estacionária em tendência) contra H1: não-estacionária, útil para confirmação conjunta.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.3.1",
                            "name": "Enunciar hipóteses e modelo do KPSS",
                            "description": "Descrever as hipóteses do teste KPSS: H0 de estacionariedade (η=0 no modelo de nível) versus H1 de raiz unitária, baseado na regressão y_t = r_t + θ_t com r_t como random walk e θ_t estacionário.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a motivação e o contexto do teste KPSS",
                                  "subSteps": [
                                    "Estudar a diferença entre testes de raiz unitária (como ADF) e testes de estacionariedade (como KPSS).",
                                    "Reconhecer que o KPSS testa a nulidade da estacionariedade, invertendo o teste padrão.",
                                    "Revisar definições básicas de processos estacionários e random walk.",
                                    "Analisar por que o KPSS é complementar ao ADF para robustez em análises de séries temporais.",
                                    "Ler a referência original de Kwiatkowski et al. (1992) ou resumo."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito por que o KPSS é usado em conjunto com outros testes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula sobre testes de estacionariedade",
                                    "Artigo original KPSS (resumo)",
                                    "Software R ou Python para visualização de séries"
                                  ],
                                  "tips": "Sempre compare com ADF para fixar a inversão das hipóteses.",
                                  "learningObjective": "Entender o propósito único do KPSS na detecção de não-estacionariedade.",
                                  "commonMistakes": [
                                    "Confundir H0 do KPSS com H0 do ADF",
                                    "Ignorar a necessidade de testes complementares"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o modelo de nível do teste KPSS",
                                  "subSteps": [
                                    "Escrever a equação geral do modelo: y_t = r_t + θ_t.",
                                    "Identificar r_t como o componente de random walk com drift opcional.",
                                    "Descrever θ_t como o componente estacionário ao redor de uma média.",
                                    "Especificar que o teste foca no modelo de nível (sem tendência linear).",
                                    "Diferenciar do modelo com tendência: y_t = x_t + r_t + θ_t."
                                  ],
                                  "verification": "Reescrever corretamente o modelo y_t = r_t + θ_t em um papel ou editor.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Quadro branco ou papel para equações",
                                    "Tutorial de séries temporais em PDF"
                                  ],
                                  "tips": "Use notação consistente: sublinhe diferenças entre modelos de nível e tendência.",
                                  "learningObjective": "Dominar a formulação matemática do modelo de nível do KPSS.",
                                  "commonMistakes": [
                                    "Incluir tendência no modelo de nível",
                                    "Confundir r_t com θ_t"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar os componentes r_t e θ_t em detalhes",
                                  "subSteps": [
                                    "Definir r_t como random walk: r_t = r_{t-1} + ε_t, onde ε_t ~ WN(0, σ²).",
                                    "Descrever θ_t como processo estacionário: E(θ_t) = 0, Var(θ_t) finita e constante.",
                                    "Entender que sob H0, η=0 implica r_t = 0 (sem random walk).",
                                    "Visualizar graficamente: simular séries com e sem random walk.",
                                    "Calcular estatísticas descritivas para diferenciar componentes."
                                  ],
                                  "verification": "Simular e plotar uma série com r_t=0 vs. r_t random walk usando R/Python.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "R ou Python com pacotes forecast ou urca",
                                    "Gráficos de exemplo de séries temporais"
                                  ],
                                  "tips": "Simule dados para ver o impacto visual do random walk.",
                                  "learningObjective": "Diferenciar matematicamente e intuitivamente os componentes do modelo.",
                                  "commonMistakes": [
                                    "Assumir θ_t como trend estacionário",
                                    "Esquecer variância finita de θ_t"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Enunciar formalmente as hipóteses H0 e H1",
                                  "subSteps": [
                                    "Escrever H0: η = 0 (série estacionária ao redor de nível constante).",
                                    "Escrever H1: η > 0 (presença de raiz unitária via random walk).",
                                    "Relacionar η ao parâmetro de variância do random walk em r_t.",
                                    "Praticar enunciando em contexto de uma série real (ex: PIB trimestral).",
                                    "Memorizar: 'KPSS testa estacionariedade como nula'."
                                  ],
                                  "verification": "Redigir um parágrafo completo enunciando H0, H1 e modelo para uma série exemplo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de séries econômicas (dados CSV)",
                                    "Modelo de resposta pronto para comparação"
                                  ],
                                  "tips": "Use mnemônico: 'KPSS: Keep Phillips Stationary? (H0 sim)'",
                                  "learningObjective": "Enunciar com precisão as hipóteses e ligá-las ao modelo.",
                                  "commonMistakes": [
                                    "Inverter H0 e H1 como no ADF",
                                    "Omitir η=0 explicitamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Ao analisar a série temporal de preços de ações diárias de uma empresa (ex: PETR4), enunciar: Modelo y_t = r_t + θ_t; H0: η=0 (preços estacionários ao redor de nível, sem drift); H1: η>0 (random walk, inadequado para ARIMA sem diferenciação).",
                              "finalVerifications": [
                                "Enunciar corretamente H0 e H1 sem inversão com ADF.",
                                "Escrever o modelo y_t = r_t + θ_t com definições de componentes.",
                                "Explicar o papel de η no teste.",
                                "Diferenciar modelo de nível vs. tendência.",
                                "Aplicar a um exemplo real verbalmente.",
                                "Simular rejeição/aceitação de H0 em software."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação matemática do modelo e hipóteses (100% correto).",
                                "Clareza na distinção entre componentes r_t e θ_t.",
                                "Correta inversão de hipóteses em relação a testes unit root padrão.",
                                "Uso apropriado de notação e termos técnicos.",
                                "Capacidade de relacionar a uma aplicação prática.",
                                "Ausência de erros comuns como confusão com ADF."
                              ],
                              "crossCurricularConnections": [
                                "Econometria: Testes em modelos VAR e cointegration.",
                                "Finanças: Análise de retornos de ativos e risco.",
                                "Engenharia: Controle de processos com sinais temporais.",
                                "Economia: Modelagem de ciclos econômicos e inflação."
                              ],
                              "realWorldApplication": "Em bancos centrais, para testar estacionariedade de séries como inflação ou PIB antes de modelar previsões ARIMA, evitando erros de especificação que levam a políticas monetárias inadequadas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.3.2",
                            "name": "Interpretar resultados do KPSS",
                            "description": "Avaliar a estatística LM, p-valor e bandas de confiança de Newey-West, rejeitando H0 se p < 0.05 indicando não-estacionariedade, e comparar com ADF para diagnósticos robustos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura do output do teste KPSS",
                                  "subSteps": [
                                    "Localize a estatística LM (Lagrange Multiplier) no output do teste.",
                                    "Identifique o p-valor associado à estatística LM.",
                                    "Observe o número de lags de truncamento usados para as bandas de Newey-West.",
                                    "Registre as bandas de confiança críticas (ex: 1%, 5%, 10%) fornecidas.",
                                    "Anote o nível de significância escolhido (geralmente 5%)."
                                  ],
                                  "verification": "Confirme que todos os componentes principais (LM, p-valor, lags, bandas) foram identificados corretamente no output.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Output do teste KPSS de software como R (tseries::kpss()) ou Python (statsmodels.tsa.stattools.kpss())",
                                    "Documentação do teste KPSS"
                                  ],
                                  "tips": "Sempre verifique se o teste foi executado com o tipo correto ('Level' ou 'Trend').",
                                  "learningObjective": "Identificar e nomear todos os componentes essenciais do output do KPSS.",
                                  "commonMistakes": [
                                    "Confundir estatística LM com t-stat do ADF",
                                    "Ignorar o número de lags usado",
                                    "Não notar o tipo de teste (nível vs tendência)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Avaliar a estatística LM e bandas de confiança de Newey-West",
                                  "subSteps": [
                                    "Compare a estatística LM com as bandas críticas de Newey-West para 5% de significância.",
                                    "Se LM > banda crítica superior, prepare para rejeição de H0.",
                                    "Calcule ou visualize graficamente a posição relativa da LM às bandas.",
                                    "Considere o ajuste por autocorrelação via Newey-West para robustez.",
                                    "Documente se a LM cai dentro ou fora das bandas."
                                  ],
                                  "verification": "Crie um resumo escrito comparando LM às bandas e justificando a interpretação inicial.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Gráfico do teste KPSS com bandas (plot.kpss() no R)",
                                    "Output numérico do KPSS"
                                  ],
                                  "tips": "Use plots para visualização intuitiva das bandas em torno da LM.",
                                  "learningObjective": "Avaliar visual e numericamente a significância da estatística LM ajustada por Newey-West.",
                                  "commonMistakes": [
                                    "Comparar LM com bandas erradas (ex: usar 1% em vez de 5%)",
                                    "Ignorar ajuste Newey-West para heterocedasticidade",
                                    "Confundir bandas superior/inferior"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar o p-valor e decidir sobre a hipótese nula (H0)",
                                  "subSteps": [
                                    "Compare o p-valor com o limiar de 0.05 (ou nível escolhido).",
                                    "Se p < 0.05, rejeite H0 (estacionariedade em nível/tendência), indicando não-estacionariedade.",
                                    "Se p >= 0.05, falhe em rejeitar H0, sugerindo estacionariedade.",
                                    "Registre a decisão explicitamente: 'Rejeitar H0' ou 'Não rejeitar H0'.",
                                    "Explique o que a decisão implica para a série temporal."
                                  ],
                                  "verification": "Escreva uma declaração de decisão de hipótese com justificativa baseada no p-valor.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela de output KPSS",
                                    "Folha de cálculo para anotar p-valor vs limiar"
                                  ],
                                  "tips": "Lembre-se: KPSS testa H0 de estacionariedade (oposto ao ADF).",
                                  "learningObjective": "Tomar decisões de hipótese baseadas no p-valor do KPSS com precisão.",
                                  "commonMistakes": [
                                    "Confundir H0 do KPSS com ADF (KPSS: H0=estacionário)",
                                    "Usar limiar errado como 0.01 sem justificativa",
                                    "Ignorar implicações para modelagem"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar com teste ADF e realizar diagnósticos robustos",
                                  "subSteps": [
                                    "Execute ou revise o teste ADF na mesma série para comparação.",
                                    "Verifique consistência: KPSS rejeita H0 e ADF também sugere não-estacionariedade.",
                                    "Analise discrepâncias potenciais e razões (lags, tipo de teste).",
                                    "Conclua sobre estacionariedade com base em ambos os testes.",
                                    "Recomende próximos passos (ex: diferenciação se não-estacionária)."
                                  ],
                                  "verification": "Produza um relatório comparativo curto entre KPSS e ADF, com conclusão final.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Output do ADF (ur.df() no R ou statsmodels ADF)",
                                    "Série temporal original"
                                  ],
                                  "tips": "Use ambos testes complementares para diagnósticos robustos; discordâncias indicam problemas de especificação.",
                                  "learningObjective": "Integrar KPSS com ADF para validação cruzada de estacionariedade.",
                                  "commonMistakes": [
                                    "Não comparar com ADF",
                                    "Ignorar lags diferentes entre testes",
                                    "Concluir prematuramente sem ambos"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a série temporal mensal de preços de ações da AAPL (2010-2020): Output KPSS (nível): LM=1.25, p=0.012 <0.05, LM > banda 5% (0.463). Rejeite H0 de estacionariedade. ADF: p=0.08 (falha em rejeitar não-estacionariedade). Conclusão: Série não-estacionária, proceda para diferenciação antes de ARIMA.",
                              "finalVerifications": [
                                "Identifica corretamente LM, p-valor e bandas no output KPSS.",
                                "Decide adequadamente sobre H0 baseado em p<0.05.",
                                "Compara consistentemente com ADF sem erros de interpretação.",
                                "Explica implicações para modelagem de séries temporais.",
                                "Documenta todos os componentes em um relatório claro.",
                                "Reconhece limitações do KPSS (ex: sensível a lags)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação e interpretação de LM/p-valor (30%)",
                                "Correta decisão de hipótese e comparação com ADF (25%)",
                                "Uso apropriado de bandas Newey-West (20%)",
                                "Clareza e completude do relatório diagnóstico (15%)",
                                "Identificação de erros comuns evitados (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Econometria: Testes unit root em modelos econômicos.",
                                "Finanças: Análise de retornos de ativos para trading algorítmico.",
                                "Economia: Previsão de PIB ou inflação com séries temporais.",
                                "Machine Learning: Pré-processamento de dados para LSTM/ARIMA híbridos."
                              ],
                              "realWorldApplication": "Em bancos centrais, analistas usam KPSS para detectar não-estacionariedade em séries de inflação ou câmbio, garantindo modelos preditivos robustos como ARIMA ou VAR antes de políticas monetárias."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.3.3",
                            "name": "Implementar KPSS em software",
                            "description": "Realizar o teste KPSS em R com kpss() do pacote tseries ou em Python com kpss() do statsmodels, especificando tipo 'Level' ou 'Trend' e interpretando saídas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente de software e os dados da série temporal",
                                  "subSteps": [
                                    "Instale os pacotes necessários: tseries para R ou statsmodels para Python.",
                                    "Carregue uma série temporal de exemplo (ex: dados de AirPassengers no R ou simule em Python).",
                                    "Verifique a estrutura dos dados com summary() em R ou .describe() em Python.",
                                    "Garanta que os dados sejam convertidos para ts() em R ou pd.Series com index datetime em Python.",
                                    "Plote a série para visual inspeção inicial."
                                  ],
                                  "verification": "Ambiente configurado sem erros de importação e dados plotados corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "RStudio ou Jupyter Notebook, datasets de exemplo (AirPassengers em R, ou fetch de yfinance em Python).",
                                  "tips": "Use datasets built-in para testes iniciais para evitar problemas de download.",
                                  "learningObjective": "Configurar corretamente o ambiente e preparar dados para testes de estacionariedade.",
                                  "commonMistakes": "Esquecer de converter para objeto ts em R ou não definir frequência/index temporal em Python."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o teste KPSS em R usando kpss() do pacote tseries",
                                  "subSteps": [
                                    "Carregue o pacote: library(tseries).",
                                    "Execute kpss(ts_data, null='Level') para hipótese nula de nível constante.",
                                    "Execute kpss(ts_data, null='Trend') para hipótese nula de tendência.",
                                    "Capture o p-value e estatística do teste das saídas.",
                                    "Armazene resultados em variáveis para posterior análise."
                                  ],
                                  "verification": "Função kpss executa sem erros e retorna p-value visível no console.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "R com tseries instalado, script R.",
                                  "tips": "Sempre especifique null explicitamente para evitar defaults inesperados.",
                                  "learningObjective": "Executar o teste KPSS em R com variações de hipótese nula.",
                                  "commonMistakes": "Usar pacote errado (urca em vez de tseries) ou não especificar null, levando a erros."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o teste KPSS em Python usando kpss() do statsmodels",
                                  "subSteps": [
                                    "Importe: from statsmodels.tsa.stattools import kpss.",
                                    "Execute kpss(data, regression='c') para nível constante (equivalente a 'Level').",
                                    "Execute kpss(data, regression='ct') para tendência (equivalente a 'Trend').",
                                    "Extraia pvalue do dicionário de resultados: results[1].",
                                    "Imprima estatística KPSS e p-value."
                                  ],
                                  "verification": "Código roda sem ImportError e p-values são exibidos corretamente.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Python com statsmodels e pandas instalados, Jupyter ou script .py.",
                                  "tips": "Use regression='c' para Level e 'ct' para Trend; verifique versão do statsmodels.",
                                  "learningObjective": "Executar o teste KPSS em Python com parâmetros corretos.",
                                  "commonMistakes": "Confundir regression='nc' (sem constante) ou passar dados não estacionários sem preprocessamento."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar saídas e validar resultados entre R e Python",
                                  "subSteps": [
                                    "Compare p-values: p < 0.05 rejeita H0 (não estacionária).",
                                    "Analise estatística KPSS: valores altos indicam forte evidência contra H0.",
                                    "Verifique consistência entre R e Python nos mesmos dados.",
                                    "Documente conclusões em relatório ou print.",
                                    "Teste com dados estacionários/diferenciados para validação cruzada."
                                  ],
                                  "verification": "Interpretação escrita matches com regras padrão e resultados R/Python concordam.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Mesmos dados em ambos ambientes, bloco de notas para documentação.",
                                  "tips": "Lembre: KPSS testa H0 estacionária (oposto ao ADF).",
                                  "learningObjective": "Interpretar corretamente resultados KPSS e validar cross-plataforma.",
                                  "commonMistakes": "Confundir H0 com ADF (KPSS H0 é estacionariedade) ou ignorar lags automáticos."
                                }
                              ],
                              "practicalExample": "Use dados de passageiros aéreos (AirPassengers). Em R/Python, execute KPSS com 'Level'/'c': espere p-value baixo, indicando não-estacionariedade. Diferencie os dados e reteste para confirmar estacionariedade pós-diferenciação.",
                              "finalVerifications": [
                                "Códigos em R e Python executam sem erros e produzem p-values consistentes.",
                                "Interpretação correta: rejeição H0 para dados originais.",
                                "Resultados salvos/exportados (ex: CSV de p-values).",
                                "Plot com séries originais e diferenciadas.",
                                "Relatório breve com conclusões.",
                                "Teste em dataset alternativo valida generalização."
                              ],
                              "assessmentCriteria": [
                                "Precisão na especificação de parâmetros (null/regression).",
                                "Correta extração e uso de p-value/estatística.",
                                "Interpretação alinhada com teoria KPSS.",
                                "Consistência entre implementações R/Python.",
                                "Documentação clara de passos e resultados.",
                                "Tratamento de edge cases (ex: lags, dados curtos)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Manipulação de dados em R/Python.",
                                "Estatística: Hipóteses nulas/alternativas em testes unitários.",
                                "Econometria: Aplicação em séries financeiras.",
                                "Machine Learning: Pré-processamento para forecasting.",
                                "Visualização de Dados: Plots de séries temporais."
                              ],
                              "realWorldApplication": "Em análise financeira, testar estacionariedade de retornos de ações antes de modelar ARIMA; em economia, validar séries de PIB/Inflação para previsões políticas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.3",
                    "name": "Transformações para Estacionariedade",
                    "description": "Técnicas como diferenciação, logaritmo e remoção de tendência para tornar a série estacionária.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.3.1",
                        "name": "Diferenciação",
                        "description": "Técnica fundamental para remover tendências e estabilizar a média de séries temporais não estacionárias, calculando diferenças entre observações consecutivas ou sazonais.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.1.1",
                            "name": "Identificar a necessidade de diferenciação",
                            "description": "Aplicar testes de estacionariedade como o teste de Dickey-Fuller Aumentado (ADF) para determinar o número de diferenciações necessárias em uma série temporal não estacionária.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos de estacionariedade e necessidade de diferenciação",
                                  "subSteps": [
                                    "Defina estacionariedade: média, variância e covariância constantes ao longo do tempo.",
                                    "Explique problemas de séries não estacionárias em modelagem (ex.: autocorrelação espúria).",
                                    "Descreva a diferenciação como remoção de tendência e/ou sazonalidade.",
                                    "Estude a hipótese nula do teste ADF: presença de raiz unitária (não estacionária).",
                                    "Revise fórmulas básicas do ADF: Δy_t = α + β t + γ y_{t-1} + ∑ δ_i Δy_{t-i} + ε_t."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras explicando estacionariedade e quando diferenciar, com exemplos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação Statsmodels/Python ou R",
                                    "Artigos introdutórios sobre séries temporais (ex.: Hyndman book)"
                                  ],
                                  "tips": "Use analogias como 'um rio calmo (estacionário) vs. rio com correnteza crescente (não estacionário)'.",
                                  "learningObjective": "Dominar a teoria por trás da estacionariedade e justificativa para testes como ADF.",
                                  "commonMistakes": [
                                    "Confundir estacionariedade com normalidade dos resíduos",
                                    "Ignorar a importância da hipótese nula no ADF"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar e analisar visualmente a série temporal",
                                  "subSteps": [
                                    "Carregue dados de série temporal (ex.: preços de ações ou PIB trimestral).",
                                    "Plote a série temporal original para identificar tendências ou sazonalidade.",
                                    "Calcule e plote autocorrelação (ACF) e autocorrelação parcial (PACF).",
                                    "Realize teste de Ljung-Box para autocorrelação inicial.",
                                    "Documente observações visuais que sugiram não estacionariedade."
                                  ],
                                  "verification": "Gere gráficos de série, ACF e PACF, e anote evidências de não estacionariedade.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python (pandas, matplotlib, statsmodels)",
                                    "Dataset exemplo: dados de PIB do FRED ou yfinance para ações"
                                  ],
                                  "tips": "Se ACF decai lentamente, suspeite de não estacionariedade.",
                                  "learningObjective": "Identificar sinais visuais de não estacionariedade antes de testes formais.",
                                  "commonMistakes": [
                                    "Interpretar erroneamente decaimento rápido de ACF como estacionariedade",
                                    "Usar escalas inadequadas nos plots"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar o teste de Dickey-Fuller Aumentado (ADF)",
                                  "subSteps": [
                                    "Instale e importe biblioteca (statsmodels.tsa.stattools.adfuller em Python).",
                                    "Execute adfuller(série, regression='ct', autolag='AIC').",
                                    "Registre estatística do teste, p-value, lags usados e valores críticos.",
                                    "Repita com diferentes configurações (sem constante, com tendência).",
                                    "Salve resultados em tabela comparativa."
                                  ],
                                  "verification": "Execute o teste e capture saída completa com p-value e estatística.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Jupyter Notebook",
                                    "Biblioteca statsmodels ou urca em R"
                                  ],
                                  "tips": "Use autolag='AIC' para seleção automática de lags para evitar sobreajuste.",
                                  "learningObjective": "Executar o teste ADF corretamente com parâmetros apropriados.",
                                  "commonMistakes": [
                                    "Não incluir lags suficientes causando rejeição errônea",
                                    "Ignorar valores críticos ao interpretar"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados e determinar número de diferenciações",
                                  "subSteps": [
                                    "Compare p-value com 0.05: se >0.05, rejeite estacionariedade (não rejeitar H0).",
                                    "Aplique diferenciação de primeira ordem (diff = série.diff()) se não estacionária.",
                                    "Reteste ADF na série diferenciada até p-value <0.05.",
                                    "Conte o número mínimo de diferenciações necessárias.",
                                    "Plote séries diferenciadas para confirmação visual."
                                  ],
                                  "verification": "Retorne número de diferenciações e p-value final <0.05 na série diferenciada.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Mesmo notebook do Step 3",
                                    "Funções diff() em pandas ou R"
                                  ],
                                  "tips": "Pare no menor número de diffs para evitar sobrediferenciação (ruído excessivo).",
                                  "learningObjective": "Interpretar testes iterativamente para encontrar ordem de diferenciação ótima.",
                                  "commonMistakes": [
                                    "Continuar diferenciando além do necessário",
                                    "Confundir H0 (raiz unitária) com estacionariedade"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e documentar o processo completo",
                                  "subSteps": [
                                    "Compare resultados com teste KPSS para confirmação complementar.",
                                    "Gere relatório com gráficos, tabelas de testes e conclusões.",
                                    "Teste sensibilidade variando lags ou datasets.",
                                    "Discuta limitações do ADF (ex.: breaks estruturais).",
                                    "Salve código e resultados para reutilização."
                                  ],
                                  "verification": "Produza relatório final com evidências de que a série diferenciada é estacionária.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Notebook completo",
                                    "Ferramentas de exportação PDF/HTML"
                                  ],
                                  "tips": "Sempre valide com múltiplos testes para robustez.",
                                  "learningObjective": "Consolidar o workflow de identificação de diferenciação de forma reprodutível.",
                                  "commonMistakes": [
                                    "Não documentar parâmetros usados",
                                    "Aceitar um único teste sem validação cruzada"
                                  ]
                                }
                              ],
                              "practicalExample": "Carregue dados diários de preços de fechamento da ação AAPL (Apple) via yfinance. Plote a série, aplique ADF (p-value inicial ~0.8, não estacionária), diferencie uma vez (retornos log), reteste ADF (p-value <0.01, estacionária). Conclusão: 1 diferenciação necessária para modelagem ARIMA.",
                              "finalVerifications": [
                                "p-value do ADF final <0.05 na série diferenciada.",
                                "Gráficos mostram remoção de tendência após diferenciação.",
                                "Número mínimo de diffs determinado corretamente.",
                                "Código executável e reprodutível fornecido.",
                                "Interpretação da H0 e decisão alinhada com resultados.",
                                "Validação com KPSS ou visual confirma estacionariedade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na execução do teste ADF (lags, parâmetros corretos): 25%.",
                                "Interpretação correta de p-value e decisão de diferenciação: 30%.",
                                "Uso de análise visual complementar: 15%.",
                                "Documentação clara e completa do processo: 15%.",
                                "Validação iterativa e robustez dos resultados: 15%."
                              ],
                              "crossCurricularConnections": [
                                "Econometria: Aplicação em modelos VAR/VECM.",
                                "Programação: Manipulação de dados em Python/R (pandas, dplyr).",
                                "Machine Learning: Pré-processamento para LSTM/Prophet em forecasting.",
                                "Finanças: Análise de retornos de ativos e Value at Risk.",
                                "Estatística Inferencial: Testes de hipóteses e poder estatístico."
                              ],
                              "realWorldApplication": "Em bancos centrais para analisar séries de inflação ou PIB e decidir transformações antes de forecasting com ARIMA, evitando previsões enviesadas em políticas monetárias; ou em trading algorítmico para tornar retornos de criptomoedas estacionários e melhorar sinais de compra/venda."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.1.2",
                            "name": "Aplicar diferenciação simples",
                            "description": "Calcular e implementar a primeira e segunda diferenças de uma série temporal usando ferramentas como R ou Python (pacotes forecast ou statsmodels) para remover tendência linear ou quadrática.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Diferenciação em Séries Temporais",
                                  "subSteps": [
                                    "Estude o conceito de tendência linear (primeira diferença) e quadrática (segunda diferença) em séries temporais não estacionárias.",
                                    "Aprenda a fórmula: primeira diferença Δy_t = y_t - y_{t-1}; segunda diferença Δ²y_t = Δy_t - Δy_{t-1}.",
                                    "Identifique quando usar diferenciação: presença de tendência via plot ou teste ACF.",
                                    "Revise estacionariedade: média e variância constantes no tempo.",
                                    "Explore exemplos visuais de séries com e sem tendência."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre primeira e segunda diferenciação, com fórmulas corretas.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Notebook ou papel para anotações",
                                    "Vídeos tutoriais sobre séries temporais (ex: YouTube - StatQuest)",
                                    "Documentação pandas.statsmodels"
                                  ],
                                  "tips": "Desenhe gráficos manualmente para visualizar o efeito da diferenciação.",
                                  "learningObjective": "Dominar os conceitos teóricos da diferenciação simples para identificar sua aplicação.",
                                  "commonMistakes": [
                                    "Confundir primeira com segunda diferença",
                                    "Ignorar a necessidade de verificar estacionariedade pós-diferenciação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar o Ambiente e Carregar Dados",
                                  "subSteps": [
                                    "Instale pacotes necessários: pip install pandas matplotlib statsmodels.",
                                    "Carregue um dataset exemplo de série temporal (ex: AirPassengers ou dados de vendas mensais via pandas.read_csv).",
                                    "Converta para DataFrame com índice temporal usando pd.to_datetime.",
                                    "Plote a série original para visualizar tendência linear/quadrática.",
                                    "Execute teste Augmented Dickey-Fuller (ADF) inicial para confirmar não-estacionariedade."
                                  ],
                                  "verification": "Série temporal carregada e plotada corretamente, com p-value ADF > 0.05 indicando não-estacionariedade.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "Python 3.x com Jupyter Notebook",
                                    "Dataset CSV de série temporal (ex: de Kaggle - Airline Passengers)"
                                  ],
                                  "tips": "Use %matplotlib inline em Jupyter para plots imediatos.",
                                  "learningObjective": "Configurar ambiente pronto para análise de séries temporais.",
                                  "commonMistakes": [
                                    "Índice não convertido para datetime",
                                    "Pacotes não importados corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a Primeira Diferenciação",
                                  "subSteps": [
                                    "Calcule a primeira diferença: df['first_diff'] = df['value'].diff().dropna().",
                                    "Plote a série diferenciada e compare com a original.",
                                    "Execute teste ADF na série diferenciada.",
                                    "Analise ACF/PACF da diferenciada para verificar remoção de tendência linear.",
                                    "Documente o código em células Jupyter com comentários."
                                  ],
                                  "verification": "Plot mostra remoção de tendência linear; ADF p-value < 0.05.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Jupyter Notebook aberto com dados carregados",
                                    "Bibliotecas: pandas, matplotlib, statsmodels.tsa.stattools"
                                  ],
                                  "tips": "Use dropna() após diff() para remover NaN inicial.",
                                  "learningObjective": "Aplicar e validar primeira diferenciação para remover tendência linear.",
                                  "commonMistakes": [
                                    "Esquecer dropna()",
                                    "Não plotar antes/depois para comparação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Segunda Diferenciação e Interpretar Resultados",
                                  "subSteps": [
                                    "Se primeira diff ainda não estacionária (ADF >0.05 ou tendência residual), calcule segunda: df['second_diff'] = df['first_diff'].diff().dropna().",
                                    "Plote segunda diff e execute ADF final.",
                                    "Compare ACF/PACF antes/depois para confirmar estacionariedade.",
                                    "Salve resultados e gere relatório resumido (gráficos + stats).",
                                    "Teste invertibilidade: integrate() para recuperar original."
                                  ],
                                  "verification": "Série final estacionária (ADF <0.05), plots sem tendência, relatório salvo.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Código da primeira diff",
                                    "Funções statsmodels.adfuller e plot_acf"
                                  ],
                                  "tips": "Limite a 2 diffs para evitar sobrediferenciação; use ordem=1 ou 2 em ARIMA depois.",
                                  "learningObjective": "Completar transformações para estacionariedade e interpretar impactos.",
                                  "commonMistakes": [
                                    "Sobrediferenciar (mais de 2 diffs)",
                                    "Não verificar invertibilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e Documentar a Transformação Completa",
                                  "subSteps": [
                                    "Compile todos plots (original, 1ª diff, 2ª diff) em subplots.",
                                    "Registre métricas: ADF p-values, número de diffs aplicadas.",
                                    "Discuta limitações: perda de longo prazo, sazonalidade não tratada.",
                                    "Compartilhe notebook via GitHub ou exporte PDF.",
                                    "Responda perguntas: 'Por que essa diff removeu a tendência?'"
                                  ],
                                  "verification": "Notebook completo com plots, testes e explicações claras.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Notebook finalizado",
                                    "GitHub account opcional"
                                  ],
                                  "tips": "Use plt.subplot() para múltiplos gráficos eficientes.",
                                  "learningObjective": "Documentar processo para reproducibilidade e aprendizado.",
                                  "commonMistakes": [
                                    "Falta de labels/legendas em plots",
                                    "Não discutir limitações"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dados de passageiros aéreos (AirPassengers.csv): série com tendência linear crescente. Após primeira diff(), plot mostra flutuações ao redor de zero sem tendência; ADF vai de p=0.99 para p<0.05. Segunda diff() não necessária aqui.",
                              "finalVerifications": [
                                "Série diferenciada plotada sem tendência visível linear/quadrática.",
                                "Teste ADF confirma estacionariedade (p-value < 0.05).",
                                "ACF/PACF decay rápido sem padrões de tendência.",
                                "Código executável sem erros e comentado.",
                                "Recuperação da original via cumsum() matches input.",
                                "Relatório resume transformações aplicadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: fórmulas e indicações corretas (30%).",
                                "Implementação código: sem erros, eficiente (25%).",
                                "Visualizações claras e comparativas (20%).",
                                "Validação estatística (ADF/ACF) adequada (15%).",
                                "Documentação e interpretação (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Diferenças finitas e cálculo discreto.",
                                "Programação: Manipulação de dados com pandas e visualização.",
                                "Economia: Análise de séries macroeconômicas como PIB.",
                                "Física: Modelagem de trajetórias com remoção de aceleração (tendência quadrática)."
                              ],
                              "realWorldApplication": "Em finanças, diferenciação de preços de ações remove tendências para modelar retornos estacionários em ARIMA; em vendas, transforma dados mensais com crescimento linear para previsões precisas de demanda."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.1.3",
                            "name": "Realizar diferenciação sazonal",
                            "description": "Executar diferenciação sazonal para séries com periodicidade conhecida, como diferenças de lag sazonal (ex: lag 12 para dados mensais), e verificar estacionariedade pós-transformação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar a periodicidade sazonal da série temporal",
                                  "subSteps": [
                                    "Carregue os dados da série temporal em um ambiente de programação como Python ou R.",
                                    "Plote o gráfico da série temporal original para visualizar padrões repetitivos.",
                                    "Calcule e plote a Função de Autocorrelação (ACF) para detectar picos significativos em lags específicos.",
                                    "Determine o lag sazonal com base na periodicidade conhecida (ex: lag=12 para dados mensais, lag=4 para trimestrais).",
                                    "Confirme a periodicidade consultando metadados ou conhecimento domínio-específico."
                                  ],
                                  "verification": "ACF mostra picos claros em múltiplos do lag sazonal identificado (ex: 12, 24).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Dados de série temporal (CSV ou similar), Python com pandas, matplotlib e statsmodels; ou R com forecast.",
                                  "tips": "Foque nos picos que decayem lentamente para confirmar sazonalidade forte.",
                                  "learningObjective": "Reconhecer e quantificar padrões sazonais em séries temporais.",
                                  "commonMistakes": "Confundir sazonalidade com tendência linear ou ruído aleatório."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar a diferenciação sazonal",
                                  "subSteps": [
                                    "Selecione a ordem de diferenciação sazonal inicial (geralmente d_s=1 para sazonalidade simples).",
                                    "Use a função de diferenciação sazonal (ex: diff(x, lag=12) em R ou seasonal_decompose/diff em Python).",
                                    "Calcule a série diferenciada sazonalmente: y_t = y_t - y_{t-lag}.",
                                    "Remova valores NA iniciais gerados pela diferenciação.",
                                    "Salve a série diferenciada para análise posterior."
                                  ],
                                  "verification": "Série diferenciada gerada com comprimento correto (original menos lag) e sem erros de execução.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Ambiente Python/R com bibliotecas statsmodels ou forecast, dados carregados do Step 1.",
                                  "tips": "Comece com d_s=1; aumente se ACF ainda mostrar sazonalidade residual.",
                                  "learningObjective": "Executar matematicamente a remoção de componentes sazonais via diferenciação.",
                                  "commonMistakes": "Usar lag incorreto ou esquecer de tratar NAs, causando erros em plots posteriores."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar estacionariedade da série diferenciada",
                                  "subSteps": [
                                    "Plote a série diferenciada sazonalmente e sua ACF/PACF.",
                                    "Aplique teste de Dickey-Fuller Aumentado (ADF) na série diferenciada.",
                                    "Realize teste KPSS para confirmar estacionariedade em torno de uma média.",
                                    "Compare estatísticas com a série original para validar melhoria.",
                                    "Se não estacionária, considere diferenciação adicional (não sazonal)."
                                  ],
                                  "verification": "Teste ADF p-value < 0.05 (rejeita não-estacionariedade) e ausência de picos sazonais na ACF.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Bibliotecas statsmodels.tsa.stattools (ADF) e statsmodels.tsa.stattools.kpss em Python; ou ur.df em R.",
                                  "tips": "Visualize sempre antes de testes; gráficos revelam problemas que testes podem ignorar.",
                                  "learningObjective": "Avaliar empiricamente a estacionariedade pós-transformação.",
                                  "commonMistakes": "Ignorar autocorrelações residuais ou interpretar mal p-values."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados e documentar a transformação",
                                  "subSteps": [
                                    "Analise mudanças nos gráficos: redução de tendência e sazonalidade.",
                                    "Registre parâmetros usados (lag, ordem d_s) e resultados dos testes.",
                                    "Discuta implicações para modelagem futura (ex: ARIMA com sazonalidade).",
                                    "Prepare relatório com código, plots e conclusões.",
                                    "Teste robustez com subconjuntos de dados."
                                  ],
                                  "verification": "Relatório completo com evidências de estacionariedade alcançada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Jupyter Notebook ou R Markdown para documentação.",
                                  "tips": "Inclua código reproduzível para validação por pares.",
                                  "learningObjective": "Sintetizar análises de séries temporais em insights acionáveis.",
                                  "commonMistakes": "Sobrediferenciação, causando perda de informação útil."
                                }
                              ],
                              "practicalExample": "Para dados mensais de vendas de varejo (lag=12), aplique diferenciação sazonal: vendas_diff_s = vendas.diff(12). Plote ACF original (picos em 12,24) vs. diferenciada (sem picos sazonais). Teste ADF: original p=0.85 (não-estacionária), diferenciada p=0.01 (estacionária).",
                              "finalVerifications": [
                                "ACF da série diferenciada não apresenta picos sazonais significativos.",
                                "Teste ADF rejeita hipótese nula de não-estacionariedade (p < 0.05).",
                                "Gráfico da série diferenciada mostra flutuações aleatórias sem padrões repetitivos.",
                                "Teste KPSS confirma estacionariedade em torno de zero.",
                                "Comprimento da série diferenciada é consistente (n - lag).",
                                "Código executa sem erros e é reproduzível."
                              ],
                              "assessmentCriteria": [
                                "Identificação precisa do lag sazonal baseada em ACF e contexto.",
                                "Implementação correta da diferenciação sazonal sem erros técnicos.",
                                "Interpretação adequada dos testes de estacionariedade.",
                                "Visualizações claras e informativas em todos os steps.",
                                "Documentação completa com parâmetros e resultados.",
                                "Eficiência: transformação atinge estacionariedade com mínima ordem."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelos de funções periódicas e diferenças finitas.",
                                "Programação: Manipulação de arrays e funções de séries temporais em Python/R.",
                                "Economia: Análise de ciclos econômicos sazonais em dados macroeconômicos.",
                                "Ciência de Dados: Pré-processamento para machine learning em previsões.",
                                "Estatística: Testes de hipóteses unit root e autocorrelação."
                              ],
                              "realWorldApplication": "Em finanças para estabilizar retornos sazonais de ações e commodities; em meteorologia para modelar temperaturas e precipitações com ciclos anuais; em varejo para prever vendas ajustadas por feriados sazonais, melhorando precisão de forecasts em ARIMA ou Prophet."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.1.4",
                            "name": "Interpretar ACF e PACF após diferenciação",
                            "description": "Analisar as funções de autocorrelação (ACF) e autocorrelação parcial (PACF) da série diferenciada para confirmar estacionariedade e identificar estrutura ARIMA adequada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e Gerar Plots de ACF e PACF da Série Diferenciada",
                                  "subSteps": [
                                    "Carregue a série temporal diferenciada usando pandas em Python ou tsibble em R.",
                                    "Defina o número de lags apropriado (ex: 20-40 lags para séries mensais).",
                                    "Gere o plot de ACF usando statsmodels.tsa.stattools.plot_acf() ou acf() em R.",
                                    "Gere o plot de PACF usando statsmodels.tsa.stattools.plot_pacf() ou pacf() em R.",
                                    "Salve ou exiba os plots com títulos claros indicando 'pós-diferenciação'."
                                  ],
                                  "verification": "Plots de ACF e PACF são gerados corretamente, com bandas de confiança visíveis e sem erros de código.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python (pandas, statsmodels, matplotlib) ou R (forecast, ggplot2)",
                                    "Jupyter Notebook ou RStudio",
                                    "Dataset de série temporal diferenciada"
                                  ],
                                  "tips": [
                                    "Use lags = len(dados)//5 para evitar overfitting visual.",
                                    "Ajuste o tamanho da figura para melhor visualização (figsize=(12,8)).",
                                    "Compare visualmente com plots pré-diferenciação."
                                  ],
                                  "learningObjective": "Dominar a geração precisa de visualizações ACF e PACF para séries diferenciadas.",
                                  "commonMistakes": [
                                    "Esquecer de importar bibliotecas necessárias.",
                                    "Usar lags insuficientes, mascarando padrões.",
                                    "Não diferenciar a série antes da análise."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Interpretar ACF para Confirmar Estacionariedade",
                                  "subSteps": [
                                    "Observe se os picos da ACF caem rapidamente dentro das bandas de confiança (ex: após 2-3 lags).",
                                    "Verifique ausência de padrão sinusoidal ou decaimento lento.",
                                    "Compare com ACF da série original (deve mostrar correlações persistentes pré-dif).",
                                    "Registre lags significativos (acima da banda azul).",
                                    "Conclua se a diferenciação alcançou estacionariedade (ACF ~ ruído branco)."
                                  ],
                                  "verification": "Análise escrita confirma que ACF indica estacionariedade, com pelo menos 95% dos lags dentro das bandas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Plots gerados no Step 1",
                                    "Papel ou notebook para anotações",
                                    "Referência: Box-Jenkins methodology"
                                  ],
                                  "tips": [
                                    "Foco nos primeiros 10 lags para decisões iniciais.",
                                    "Use zoom nos plots para lags iniciais.",
                                    "Se ACF ainda lenta, considere diferenciação de ordem 2."
                                  ],
                                  "learningObjective": "Identificar sinais de estacionariedade via ACF pós-diferenciação.",
                                  "commonMistakes": [
                                    "Ignorar bandas de confiança (5% significância).",
                                    "Confundir ruído com padrão real.",
                                    "Não comparar com pré-diferenciação."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar PACF para Identificar Componentes AR",
                                  "subSteps": [
                                    "Identifique lags significativos no PACF (picos cortantes acima das bandas).",
                                    "Conte o número de lags significativos consecutivos (ordem p do AR).",
                                    "Note se PACF corta abruptamente após lag q (sugere MA(q)).",
                                    "Anote padrões: ex: spike em lag 1 = AR(1); múltiplos = AR(p).",
                                    "Diferencie de ACF: PACF controla correlações parciais."
                                  ],
                                  "verification": "Lista de lags significativos no PACF anotada, com justificativa baseada em bandas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Plots do Step 1",
                                    "Tabela para registrar lags (Excel ou Markdown)"
                                  ],
                                  "tips": [
                                    "PACF é mais útil para AR; ignore caudas longas como ruído.",
                                    "Combine com Ljung-Box test para validação quantitativa.",
                                    "Desenhe setas nos plots para lags chave."
                                  ],
                                  "learningObjective": "Extrair ordem ARIMA(p,d,q) via padrões PACF.",
                                  "commonMistakes": [
                                    "Confundir PACF com ACF (PACF para AR, ACF para MA).",
                                    "Contar lags não significativos.",
                                    "Ignorar o corte abrupto como indicador chave."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar ACF e PACF para Propor Modelo ARIMA",
                                  "subSteps": [
                                    "Combine: ACF lenta + PACF spike lag1 = ARIMA(1,d,0).",
                                    "PACF lenta + ACF spike = MA; ambos lentos = ARMA misto.",
                                    "Proponha (p,d,q) baseado em regras Box-Jenkins.",
                                    "Teste estacionariedade com ADF test pós-ajuste.",
                                    "Documente hipótese do modelo em relatório curto."
                                  ],
                                  "verification": "Modelo ARIMA proposto com justificativa, e código para ajuste inicial executado sem erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código Python/R para ARIMA (statsmodels.tsa.arima.model)",
                                    "Referência rápida ARIMA identification"
                                  ],
                                  "tips": [
                                    "Regra: PACF significativo até p, zero após = AR(p); inverta para MA via ACF.",
                                    "Comece com modelo simples e refine.",
                                    "Salve script completo para reprodutibilidade."
                                  ],
                                  "learningObjective": "Integrar ACF/PACF para identificação robusta de ARIMA.",
                                  "commonMistakes": [
                                    "Sobrestimar ordens altas sem evidência.",
                                    "Não considerar sazonalidade (use SARIMA se ACF periódica).",
                                    "Pular validação com testes estatísticos."
                                  ]
                                }
                              ],
                              "practicalExample": "Para dados mensais de vendas de varejo (ex: AirPassengers dataset), após 1a diferenciação: ACF cai para zero após lag 2 (estacionária); PACF spike significativo em lag 1 e zero após (AR(1)). Proponha ARIMA(1,1,0) e ajuste para prever vendas futuras.",
                              "finalVerifications": [
                                "ACF pós-dif mostra decaimento rápido dentro de bandas (confirma estacionariedade).",
                                "PACF identifica lags AR precisos sem ambiguidades.",
                                "Modelo ARIMA proposto alinha com regras Box-Jenkins.",
                                "Teste ADF p-value < 0.05 na série diferenciada.",
                                "Previsão inicial do modelo converge sem warnings.",
                                "Relatório resume interpretações com plots anotados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de estacionariedade via ACF (90% lags insignificantes).",
                                "Correta extração de ordens p e q de PACF/ACF.",
                                "Justificativa lógica e referenciada para modelo ARIMA.",
                                "Uso correto de ferramentas e visualizações limpas.",
                                "Detecção e correção de erros comuns (ex: overdifferencing).",
                                "Integração com testes complementares (ADF, Ljung-Box)."
                              ],
                              "crossCurricularConnections": [
                                "Programação Estatística (Python/R para statsmodels/forecast).",
                                "Estatística Inferencial (testes de hipóteses como ADF).",
                                "Análise de Dados Exploratória (visualizações e padrões).",
                                "Modelagem Preditiva (previsão em machine learning).",
                                "Econometria (aplicações financeiras e séries macroeconômicas)."
                              ],
                              "realWorldApplication": "Em finanças, interpretar ACF/PACF pós-dif em retornos de ações para modelar ARIMA, permitindo previsões de volatilidade e estratégias de trading automatizadas em bancos ou hedge funds."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.3.2",
                        "name": "Transformação Logarítmica",
                        "description": "Método para estabilizar a variância em séries com variabilidade crescente, transformando valores multiplicativos em aditivos via logaritmo natural.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.2.1",
                            "name": "Reconhecer heterocedasticidade na série",
                            "description": "Identificar padrões de variância não constante (ex: cone de expansão) em gráficos da série original e decidir pela aplicação de logaritmo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de heterocedasticidade em séries temporais",
                                  "subSteps": [
                                    "Defina heterocedasticidade como variância não constante ao longo do tempo na série.",
                                    "Compare com homocedasticidade, onde a variância é constante.",
                                    "Estude exemplos teóricos: variância crescente em séries multiplicativas como preços de ações.",
                                    "Revise a relação com não-estacionariedade: heterocedasticidade viola pressupostos de modelos ARIMA.",
                                    "Leia definições em fontes como Brockwell & Davis ou tutoriais de séries temporais."
                                  ],
                                  "verification": "Explique em suas palavras o que é heterocedasticidade e dê um exemplo simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro de séries temporais (ex: Brockwell & Davis), notebook Jupyter ou R para anotações"
                                  ],
                                  "tips": "Use analogias visuais, como um funil invertido para variância crescente.",
                                  "learningObjective": "Diferenciar heterocedasticidade de homocedasticidade e sua implicação em estacionariedade.",
                                  "commonMistakes": "Confundir com autocorrelação; foque apenas na dispersão dos resíduos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar e visualizar a série temporal original",
                                  "subSteps": [
                                    "Carregue dados de uma série temporal real (ex: preços de ações via yfinance em Python).",
                                    "Plote o gráfico da série original com eixos tempo vs. valor.",
                                    "Adicione bandas de confiança ou desvios móveis para destacar variância.",
                                    "Calcule e plote variância rolante (rolling variance) para quantificar mudanças.",
                                    "Ajuste escalas e zoom em períodos suspeitos de variância crescente."
                                  ],
                                  "verification": "Gere um gráfico com variância rolante e anote observações iniciais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python/R com bibliotecas pandas, matplotlib/ggplot2, dados de séries (ex: AAPL stock)"
                                  ],
                                  "tips": "Use log-scale no eixo y inicialmente para comparar, mas volte ao linear para inspeção crua.",
                                  "learningObjective": "Visualizar padrões de variância em gráficos de séries temporais.",
                                  "commonMistakes": "Ignorar escala logarítmica prematuramente; sempre comece com linear."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar padrões clássicos de heterocedasticidade",
                                  "subSteps": [
                                    "Procure pelo 'cone de expansão': variância aumentando com o nível da série (ex: erros maiores em valores altos).",
                                    "Identifique outros padrões: variância decrescente, clusters irregulares ou funil.",
                                    "Teste qualitativamente: divida a série em janelas e compare desvios-padrão.",
                                    "Anote evidências visuais: desenhe setas no gráfico apontando o cone.",
                                    "Compare com resíduos de um modelo simples (ex: média móvel) para confirmar."
                                  ],
                                  "verification": "Marque no gráfico os pontos de variância não constante e descreva o padrão.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Gráficos gerados no Step 2, ferramentas de anotação como matplotlib annotate()"
                                  ],
                                  "tips": "Olhe para a dispersão ao redor da tendência; ignore a tendência em si.",
                                  "learningObjective": "Reconhecer visualmente heterocedasticidade, especialmente o cone de expansão.",
                                  "commonMistakes": "Confundir tendência crescente com variância; foque na largura das oscilações."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Decidir pela aplicação de transformação logarítmica",
                                  "subSteps": [
                                    "Justifique: logaritmo estabiliza variância em séries com cone de expansão (multiplicativas).",
                                    "Aplique log na série e re-plote para comparar antes/depois.",
                                    "Verifique se a variância rolante se torna mais constante pós-log.",
                                    "Discuta alternativas: Box-Cox se log não for suficiente.",
                                    "Documente a decisão com prints de gráficos comparativos."
                                  ],
                                  "verification": "Produza gráfico lado a lado (original vs. log) mostrando estabilização da variância.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Código Python/R para np.log() ou log(), gráficos comparativos"
                                  ],
                                  "tips": "Use diff(log(Y)) para primeira diferença se necessário, mas foque na variância primeiro.",
                                  "learningObjective": "Decidir corretamente pela transformação logarítmica baseada em evidências visuais.",
                                  "commonMistakes": "Aplicar log sem evidência clara; sempre justifique com gráficos."
                                }
                              ],
                              "practicalExample": "Em dados de preços diários da ação AAPL (Apple), plote de 2010-2023: observe cone de expansão onde volatilidade aumenta com preço crescente. Após log, a série mostra variância mais estável, ideal para modelagem ARIMA.",
                              "finalVerifications": [
                                "Identifica corretamente o cone de expansão em um gráfico fornecido.",
                                "Explica por que logaritmo é apropriado para esse padrão.",
                                "Gera gráficos comparativos antes/depois da transformação.",
                                "Calcula variância rolante e aponta estabilização pós-log.",
                                "Discute limitações, como valores zero ou negativos na série."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação visual (90%+ acurácia em exemplos testados).",
                                "Justificativa clara e baseada em evidências gráficas.",
                                "Qualidade dos gráficos: legíveis, anotados e comparativos.",
                                "Compreensão conceitual demonstrada em explicação escrita.",
                                "Eficiência: completa em tempo estimado sem erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estatística descritiva e transformações não-lineares (logaritmos).",
                                "Economia/Finanças: Análise de volatilidade em mercados financeiros.",
                                "Computação: Programação em Python/R para visualização de dados.",
                                "Física: Modelagem de fenômenos com ruído heterocedástico (ex: crescimento populacional)."
                              ],
                              "realWorldApplication": "Em finanças, reconhecer heterocedasticidade em retornos de ações permite estabilizar variância via log-retornos, melhorando previsões de risco (VaR) e modelos de trading algorítmico; em epidemiologia, estabiliza variância em curvas de casos COVID para forecasting mais preciso."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.2.2",
                            "name": "Aplicar transformação logarítmica",
                            "description": "Implementar log(y_t) em software estatístico, tratar valores zero ou negativos com ajustes (ex: log(y_t + 1)), e plotar a série transformada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambiente e carregar dados da série temporal",
                                  "subSteps": [
                                    "Instale bibliotecas necessárias (ex: pandas, numpy, matplotlib para Python ou tidyverse para R)",
                                    "Carregue o dataset da série temporal em um DataFrame ou vetor",
                                    "Inspecione os dados com summary() ou describe() para verificar estrutura e valores iniciais",
                                    "Crie um índice temporal se não existir",
                                    "Visualize a série original com um plot básico"
                                  ],
                                  "verification": "Confirme que os dados carregaram sem erros e o plot inicial exibe a série corretamente",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python/R instalado",
                                    "Bibliotecas: pandas, numpy, matplotlib ou ggplot2",
                                    "Dataset de exemplo (ex: AirPassengers.csv)"
                                  ],
                                  "tips": "Use datasets públicos como AirPassengers para prática inicial",
                                  "learningObjective": "Preparar ambiente de análise de séries temporais de forma eficiente",
                                  "commonMistakes": [
                                    "Esquecer de definir índice temporal",
                                    "Ignorar NaNs nos dados",
                                    "Usar dataset sem variância crescente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e diagnosticar valores zero ou negativos",
                                  "subSteps": [
                                    "Execute verificações: min(y_t), sum(y_t == 0), sum(y_t < 0)",
                                    "Calcule estatísticas descritivas por período para detectar heterocedasticidade",
                                    "Crie um plot da série com escala logarítmica informal para preview",
                                    "Documente a proporção de valores problemáticos",
                                    "Decida o ajuste necessário (ex: +1 para zeros pequenos)"
                                  ],
                                  "verification": "Relatório mostra contagem exata de zeros/negativos e justificativa para ajuste",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Código de inspeção pronto",
                                    "Notebook Jupyter ou RMarkdown"
                                  ],
                                  "tips": "Para zeros raros, +1 é suficiente; para negativos, investigue origem dos dados",
                                  "learningObjective": "Diagnosticar issues que impedem log(y_t) direto",
                                  "commonMistakes": [
                                    "Assumir ausência de zeros sem checagem",
                                    "Ajustar sem documentar impacto",
                                    "Confundir zeros com missing values"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar transformação logarítmica com ajustes",
                                  "subSteps": [
                                    "Defina a fórmula: log_transformed = np.log(y_t + c) onde c=1 para zeros",
                                    "Crie nova coluna ou vetor com a transformação",
                                    "Trate NaNs resultantes (ex: imputar ou remover)",
                                    "Compare estatísticas antes/depois (média, variância)",
                                    "Salve a série transformada para uso posterior"
                                  ],
                                  "verification": "Nova série tem valores reais (não -inf ou NaN) e variância reduzida",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Funções np.log() ou log()",
                                    "Dataset do step anterior"
                                  ],
                                  "tips": "Teste c=0.01 para dados muito pequenos para evitar over-adjust",
                                  "learningObjective": "Implementar log(y_t + c) corretamente em software",
                                  "commonMistakes": [
                                    "Aplicar log em negativos sem ajuste",
                                    "Esquecer import de log",
                                    "Não tratar overflow para valores muito grandes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Plotar e visualizar a série transformada",
                                  "subSteps": [
                                    "Crie subplot com série original e transformada lado a lado",
                                    "Adicione títulos, labels e grid para clareza",
                                    "Plote ACF/PACF básica para preview de estacionariedade",
                                    "Salve o gráfico como PNG/PDF",
                                    "Anote observações sobre estabilização de variância"
                                  ],
                                  "verification": "Gráficos mostram linearização e estabilização visual clara",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "matplotlib/ggplot2",
                                    "Série transformada"
                                  ],
                                  "tips": "Use escala log no eixo y para original para melhor comparação",
                                  "learningObjective": "Visualizar impacto da transformação logarítmica",
                                  "commonMistakes": [
                                    "Plots sem legendas",
                                    "Escalas diferentes distorcendo comparação",
                                    "Ignorar zoom em regiões críticas"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e interpretar resultados da transformação",
                                  "subSteps": [
                                    "Teste estatístico de variância (ex: Levene ou visual)",
                                    "Compare resíduos ou diferencas para estacionariedade",
                                    "Documente mudanças em propriedades da série",
                                    "Prepare relatório com código e plots",
                                    "Planeje próximos passos (ex: diferenciação)"
                                  ],
                                  "verification": "Interpretação escrita justifica uso da transformação",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Testes estatísticos (scipy.stats)",
                                    "Notebook completo"
                                  ],
                                  "tips": "Se variância ainda cresce, considere Box-Cox",
                                  "learningObjective": "Interpretar e validar transformação para estacionariedade",
                                  "commonMistakes": [
                                    "Concluir sucesso sem testes",
                                    "Ignorar autocorrelação residual",
                                    "Não comparar métricas quantitativas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um dataset de passageiros aéreos mensais (AirPassengers), com tendência e variância crescente, aplique log(y_t + 1) para estabilizar variância; plote original vs transformada mostrando linearização da tendência e variância constante.",
                              "finalVerifications": [
                                "Série transformada sem valores -inf ou NaN",
                                "Plot comparativo evidencia estabilização de variância",
                                "Estatísticas mostram redução na variância relativa",
                                "Código reproduzível gera mesmos resultados",
                                "Interpretação identifica melhorias para modelagem",
                                "Ajuste (ex: +1) justificado pela presença de zeros"
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção e tratamento de zeros/negativos (100% corretos)",
                                "Qualidade visual dos plots (clareza, labels, escalas adequadas)",
                                "Correção matemática da transformação (verificação numérica)",
                                "Documentação completa com comentários no código",
                                "Análise interpretativa profunda (não só execução)",
                                "Eficiência temporal (dentro de 2h total)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Propriedades logarítmicas e estabilização de variância",
                                "Programação: Manipulação vetorial e visualização de dados",
                                "Economia: Modelagem de séries financeiras (ex: retornos log)",
                                "Física: Análise de sinais com heterocedasticidade",
                                "Biologia: Transformação de contagens em populações"
                              ],
                              "realWorldApplication": "Em finanças, transforma retornos de ações para assumir normalidade em modelos ARIMA; em epidemiologia, estabiliza contagens de casos COVID para previsão; em vendas, lineariza crescimento exponencial para forecasting preciso."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.2.3",
                            "name": "Comparar série antes e após transformação",
                            "description": "Avaliar visualmente e por testes estatísticos a estabilização da variância e impacto na média após logaritmo, decidindo combinações com outras transformações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e Visualizar Séries Temporais Antes e Após Log-Transformação",
                                  "subSteps": [
                                    "Carregue o conjunto de dados de série temporal não estacionária usando pandas.",
                                    "Aplique a transformação logarítmica: np.log(série_original) para criar a série transformada.",
                                    "Crie gráficos de linha lado a lado: série original vs. log-transformada.",
                                    "Adicione estatísticas descritivas básicas (média, variância) para cada série.",
                                    "Observe padrões visuais iniciais de variância e tendência."
                                  ],
                                  "verification": "Gráficos gerados mostram ambas as séries plotadas com estatísticas resumidas impressas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python (pandas, numpy, matplotlib), Jupyter Notebook, dataset de série temporal (ex: preços de ações).",
                                  "tips": "Use scale='log' no eixo y para o gráfico original se necessário para melhor visualização.",
                                  "learningObjective": "Dominar a preparação visual comparativa de séries temporais antes e após transformação logarítmica.",
                                  "commonMistakes": "Aplicar log em valores zero ou negativos (use log(1 + série) para evitar erros)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Avaliar Visualmente a Estabilização da Variância",
                                  "subSteps": [
                                    "Examine o gráfico da série original para heteroscedasticidade (variância crescente/decrescente).",
                                    "Compare com o gráfico da série log-transformada para homoscedasticidade (variância constante).",
                                    "Calcule e plote variâncias móveis (rolling variance) para ambas as séries.",
                                    "Identifique se a variância se estabilizou após a transformação.",
                                    "Documente observações qualitativas em um relatório curto."
                                  ],
                                  "verification": "Relatório com prints de gráficos de variância móvel e conclusões visuais escritas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Python (pandas rolling(), matplotlib), mesmo dataset.",
                                  "tips": "Use janela de 12-24 períodos para variância móvel em séries mensais/anuais.",
                                  "learningObjective": "Desenvolver habilidade em análise visual de estabilização de variância em séries temporais.",
                                  "commonMistakes": "Ignorar escala nos gráficos, levando a interpretações erradas de estabilização."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar Testes Estatísticos para Estacionariedade e Variância",
                                  "subSteps": [
                                    "Aplique teste Augmented Dickey-Fuller (ADF) em ambas as séries para estacionariedade.",
                                    "Use teste de Levene ou Bartlett para comparar variâncias entre subperíodos.",
                                    "Calcule p-values e interprete: p < 0.05 indica estabilização/rejeição de não-estacionariedade.",
                                    "Compare resultados antes e após transformação.",
                                    "Registre todos os outputs estatísticos em uma tabela."
                                  ],
                                  "verification": "Tabela com resultados de ADF e testes de variância para ambas séries, com interpretações.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python (statsmodels.tsa.stattools.adfuller, scipy.stats.levene), dataset transformado.",
                                  "tips": "Inclua lags no ADF baseado no ACF para precisão.",
                                  "learningObjective": "Aplicar e interpretar testes estatísticos para validar transformações em séries temporais.",
                                  "commonMistakes": "Não verificar premissas dos testes, como normalidade aproximada."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Impacto na Média e Decidir Combinações de Transformações",
                                  "subSteps": [
                                    "Compare médias móveis das séries original e log-transformada.",
                                    "Avalie se a transformação estabilizou variância sem distorcer excessivamente a média.",
                                    "Teste necessidade de diferenciação: aplique diff() na série log e reavalie com ADF.",
                                    "Decida combinações (ex: log + diff) baseado em resultados visuais e estatísticos.",
                                    "Documente recomendação final com justificativa."
                                  ],
                                  "verification": "Relatório final com comparações de médias, testes adicionais e decisão de combinação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Python (pandas.diff(), statsmodels), gráficos anteriores.",
                                  "tips": "Sempre priorize testes estatísticos sobre visuais para decisões robustas.",
                                  "learningObjective": "Integrar análises para decidir transformações compostas em séries não estacionárias.",
                                  "commonMistakes": "Sobrepasar com múltiplas transformações sem validação stepwise."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar e Sintetizar Resultados",
                                  "subSteps": [
                                    "Compile todos os gráficos, testes e decisões em um dashboard ou relatório.",
                                    "Resuma impactos: estabilização de variância, mudança na média, necessidade de combinações.",
                                    "Sugira próximos passos para modelagem (ex: ARIMA na série transformada).",
                                    "Autoavalie com critérios de sucesso.",
                                    "Salve notebook e exporte PDF."
                                  ],
                                  "verification": "Dashboard/relatório completo salvo e compartilhável.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Jupyter Notebook, matplotlib/seaborn para dashboard.",
                                  "tips": "Use seaborn para visualizações profissionais.",
                                  "learningObjective": "Sintetizar análises de transformações para comunicação clara.",
                                  "commonMistakes": "Omitir justificativas estatísticas nas conclusões."
                                }
                              ],
                              "practicalExample": "Usando dados históricos de preços de ações da AAPL (Apple), aplique log-transformação. Visualmente, a variância crescente nos retornos originais estabiliza; ADF p-value cai de 0.45 para 0.03 após log + 1ª diff, confirmando necessidade de combinação.",
                              "finalVerifications": [
                                "Gráficos comparativos mostram estabilização visual da variância.",
                                "Teste ADF rejeita não-estacionariedade na série transformada (p < 0.05).",
                                "Teste de variância confirma homoscedasticidade pós-transformação.",
                                "Análise de média móvel quantifica impacto sem distorções excessivas.",
                                "Decisão explícita de combinação (ex: log + diff) com justificativa estatística.",
                                "Relatório sintetiza todos os resultados de forma clara."
                              ],
                              "assessmentCriteria": [
                                "Precisão na aplicação e interpretação de testes estatísticos (ADF, Levene).",
                                "Qualidade e clareza dos gráficos comparativos.",
                                "Correta identificação de estabilização de variância e impacto na média.",
                                "Lógica robusta na decisão de combinações adicionais.",
                                "Completude do relatório com todas as verificações.",
                                "Eficiência temporal e uso adequado de materiais."
                              ],
                              "crossCurricularConnections": [
                                "Programação em Python/R para análise de dados.",
                                "Visualização de dados e storytelling com gráficos.",
                                "Matemática: logaritmos e propriedades estatísticas.",
                                "Economia/Finanças: modelagem de séries temporais em forecasting.",
                                "Machine Learning: pré-processamento para modelos de previsão."
                              ],
                              "realWorldApplication": "Em finanças, analistas usam isso para estabilizar séries de retornos de ações antes de ARIMA/SARIMA, melhorando previsões de portfólios; em vendas, estabiliza demanda sazonal para otimização de estoque."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.3.3",
                        "name": "Remoção de Tendência",
                        "description": "Processo de eliminar componentes de tendência determinística ou estocástica de uma série temporal para alcançar estacionariedade na média.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.3.1",
                            "name": "Ajustar modelo de tendência linear",
                            "description": "Realizar regressão linear da série contra tempo (t) para estimar e subtrair a tendência, obtendo resíduos estacionários.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os dados da série temporal e variável tempo",
                                  "subSteps": [
                                    "Carregue a série temporal em um DataFrame usando pandas.",
                                    "Crie uma coluna de tempo 't' indexada sequencialmente (ex: range(1, len(serie)+1)).",
                                    "Visualize a série original com plot para identificar a tendência linear.",
                                    "Verifique valores ausentes e trate-os se necessário (ex: interpolação).",
                                    "Defina a série como variável dependente 'y'."
                                  ],
                                  "verification": "DataFrame contém colunas 't' e 'y'; plot mostra tendência clara.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python com pandas e matplotlib instalados",
                                    "Dataset de série temporal (ex: CSV com dados mensais)"
                                  ],
                                  "tips": "Use pd.date_range() se houver datas; normalize 't' para escala 0-1 se necessário.",
                                  "learningObjective": "Compreender a preparação de dados para modelagem de tendência.",
                                  "commonMistakes": [
                                    "Ignorar valores ausentes",
                                    "Usar índice errado para 't'",
                                    "Não visualizar dados iniciais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Ajustar o modelo de regressão linear",
                                  "subSteps": [
                                    "Importe statsmodels.api como sm.",
                                    "Adicione constante ao modelo: X = sm.add_constant(t).",
                                    "Ajuste o modelo: model = sm.OLS(y, X).fit().",
                                    "Inspecione o summary do modelo (R², p-valores dos coeficientes).",
                                    "Confirme significância da tendência (p < 0.05 para slope)."
                                  ],
                                  "verification": "Modelo ajustado com summary mostrando coeficiente de 't' significativo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Biblioteca statsmodels",
                                    "Jupyter Notebook ou script Python"
                                  ],
                                  "tips": "Use model.summary() para diagnósticos rápidos; considere robustez se heteroscedasticidade.",
                                  "learningObjective": "Executar e interpretar regressão linear simples para tendência.",
                                  "commonMistakes": [
                                    "Esquecer constante no modelo",
                                    "Interpretar errado coeficientes",
                                    "Ignorar diagnósticos de ajuste"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Extrair tendência e calcular resíduos",
                                  "subSteps": [
                                    "Gere predições: trend = model.predict(X).",
                                    "Calcule resíduos: residuals = y - trend.",
                                    "Crie nova série de resíduos estacionários.",
                                    "Plote original, tendência e resíduos lado a lado.",
                                    "Salve resíduos em variável para análises futuras."
                                  ],
                                  "verification": "Resíduos plotados mostram ausência de tendência linear.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Matplotlib ou seaborn para plots"
                                  ],
                                  "tips": "Use subplots para comparação visual clara; armazene em Series com mesmo índice.",
                                  "learningObjective": "Isolar componente de tendência e obter resíduos estacionários.",
                                  "commonMistakes": [
                                    "Erro no cálculo residuals (sinal invertido)",
                                    "Não plotar para validação visual",
                                    "Perder índice temporal"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar estacionariedade dos resíduos",
                                  "subSteps": [
                                    "Importe teste ADF de statsmodels.tsa.stattools.",
                                    "Execute adfuller(residuals) e interprete p-value (<0.05 indica estacionariedade).",
                                    "Plote ACF/PACF dos resíduos para confirmar ausência de tendência/autocorrelação.",
                                    "Compare estatísticas descritivas (média, variância) antes/depois.",
                                    "Documente resultados em relatório."
                                  ],
                                  "verification": "Teste ADF rejeita H0 (p<0.05); plots confirmam estacionariedade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "statsmodels.tsa para testes",
                                    "Exemplo de código para ACF"
                                  ],
                                  "tips": "Use lags='auto' no ADF; visualize QQ-plot para normalidade.",
                                  "learningObjective": "Verificar efetividade da remoção de tendência.",
                                  "commonMistakes": [
                                    "Interpretar errado p-value do ADF",
                                    "Usar lags inadequados",
                                    "Não comparar visualmente"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dados de temperatura média mensal em uma cidade (ex: dataset AirPassengers adaptado), crie 't' de 1 a 144, ajuste OLS(temperatura ~ t), subtraia tendência e verifique que resíduos flutuam em torno de zero sem inclinação.",
                              "finalVerifications": [
                                "Coeficiente de tendência no modelo é estatisticamente significativo (p<0.05).",
                                "R² do modelo > 0.5 indicando boa captura da tendência.",
                                "Plot dos resíduos sem tendência linear visível.",
                                "Teste ADF dos resíduos com p-value <0.05.",
                                "ACF dos resíduos decai rapidamente sem padrão linear.",
                                "Média dos resíduos próxima de zero."
                              ],
                              "assessmentCriteria": [
                                "Correta preparação de 't' e ajuste OLS com constante.",
                                "Cálculo preciso de resíduos sem erros aritméticos.",
                                "Interpretação adequada de summary e testes.",
                                "Visualizações claras e informativas.",
                                "Validação completa com ADF e plots.",
                                "Código limpo, reproduzível e comentado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear e mínimos quadrados.",
                                "Programação: Manipulação de dados em Python/pandas.",
                                "Economia: Detrending em séries de PIB ou vendas.",
                                "Física: Remoção de drift em medições sensoriais.",
                                "Machine Learning: Pré-processamento para modelos de previsão."
                              ],
                              "realWorldApplication": "Em finanças, remove tendência de preços de ações para analisar volatilidade; em meteorologia, detrenda temperaturas para estudar ciclos sazonais; em marketing, estacionariza vendas para forecasting preciso."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.3.2",
                            "name": "Usar suavização móvel para detrending",
                            "description": "Aplicar médias móveis ou filtros de Hodrick-Prescott para remover tendência suave, implementando em R (pacote mFilter) ou Python.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar Ambiente e Compreender Conceitos Básicos",
                                  "subSteps": [
                                    "Instale e importe bibliotecas necessárias: em Python (pandas, statsmodels, matplotlib); em R (mFilter, ggplot2).",
                                    "Carregue um dataset de série temporal exemplo (ex: dados de PIB trimestral do FRED via pandas_datareader ou read.csv).",
                                    "Explique detrending: remoção de tendência suave para obter componente cíclico.",
                                    "Compare média móvel (simples ou exponencial) vs. filtro HP (otimizado para suavidade com penalidade lambda)."
                                  ],
                                  "verification": "Ambiente configurado com dados carregados e plot inicial da série mostrando tendência clara.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python: pandas, statsmodels, matplotlib; R: mFilter, ggplot2",
                                    "Dataset exemplo: PIB US (FRED: GDPC1)"
                                  ],
                                  "tips": "Use dados reais para motivação; plot sempre antes e depois para visualização intuitiva.",
                                  "learningObjective": "Entender fundamentos teóricos e preparar ferramentas para implementação prática.",
                                  "commonMistakes": [
                                    "Ignorar frequência dos dados (mensal/diário afeta lambda no HP)",
                                    "Não plotar série original primeiro"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Detrending com Média Móvel",
                                  "subSteps": [
                                    "Calcule média móvel simples: em Python (df['trend'] = df['y'].rolling(window=12).mean()); em R (ma <- filter(y, rep(1/12,12), sides=2)).",
                                    "Subtraia a tendência: resíduo = série - média móvel.",
                                    "Ajuste janela (ex: 12 para mensal) e teste exponencial se necessário (ewm).",
                                    "Plote original, tendência e resíduo para inspeção visual.",
                                    "Teste estacionariedade inicial do resíduo com ADF test (statsmodels.tsa.stattools.adfuller)."
                                  ],
                                  "verification": "Gráfico mostra tendência suavizada removida; ADF p-value <0.05 indica estacionariedade parcial.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código Jupyter/R script",
                                    "Dataset carregado do Step 1"
                                  ],
                                  "tips": "Janela ímpar evita lag; use sides=2 em R para média centrada.",
                                  "learningObjective": "Dominar aplicação prática de médias móveis para remoção de tendência suave.",
                                  "commonMistakes": [
                                    "Janela muito curta (under-smoothing, tendência residual)",
                                    "Não centralizar média (bias em ends)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Filtro Hodrick-Prescott (HP)",
                                  "subSteps": [
                                    "Em Python: from statsmodels.tsa.filters.hp_filter import hpfilter; cycle, trend = hpfilter(série, lamb=129600).",
                                    "Em R: library(mFilter); hp <- hpfilter(série, freq=12, type='lambda'); trend=hp$trend; cycle=hp$cycle.",
                                    "Escolha lambda: 129600 (trimestral), 14400 (mensal), 1600 (anual).",
                                    "Subtraia trend para obter cycle e plote componentes.",
                                    "Compare suavidade visual com média móvel do Step 2."
                                  ],
                                  "verification": "Componentes HP plotados; trend suave sem oscilações rápidas, cycle oscila em torno de zero.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Pacotes statsmodels (Python) ou mFilter (R)",
                                    "Série do Step 1"
                                  ],
                                  "tips": "Lambda alto = trend mais suave; teste sensibilidade variando ±10%.",
                                  "learningObjective": "Implementar filtro HP otimizado para detrending em séries econômicas.",
                                  "commonMistakes": [
                                    "Lambda errado para frequência (over/under smoothing)",
                                    "Confundir cycle com trend no output"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar, Comparar e Interpretar Resultados",
                                  "subSteps": [
                                    "Compare resíduos de média móvel vs. HP: ACF/PACF plots e testes ADF/KPSS.",
                                    "Avalie suavidade: compute variância de segunda diferenças na trend.",
                                    "Documente código em função reutilizável: def detrend_mobile(series, method='ma' or 'hp').",
                                    "Aplique em subconjunto de dados e interprete: 'Tendência crescente indica crescimento econômico'.",
                                    "Salve resultados: exporte plots e resíduos para CSV."
                                  ],
                                  "verification": "Relatório com comparações mostra HP superior em suavidade; função funciona em novos dados.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Bibliotecas de teste: statsmodels.tsa.stattools (ADF/ACF)",
                                    "Jupyter/RMarkdown para relatório"
                                  ],
                                  "tips": "Use grid de plots (subplots) para comparações lado a lado.",
                                  "learningObjective": "Avaliar efetividade de métodos e criar ferramentas reutilizáveis.",
                                  "commonMistakes": [
                                    "Não testar estacionariedade final",
                                    "Ignorar ends effects em séries curtas"
                                  ]
                                }
                              ],
                              "practicalExample": "Carregue dados mensais de desemprego US (FRED: UNRATE, 1948-2023). Aplique HP com lambda=14400 para extrair ciclo: visualize como recessões (picos no ciclo) são isoladas da tendência de longo prazo crescente.",
                              "finalVerifications": [
                                "Trend suavizada sem ruído de alta frequência.",
                                "Resíduos oscilam em torno de zero com variância estável.",
                                "Testes de estacionariedade (ADF p<0.05) confirmam sucesso.",
                                "Gráficos comparativos mostram remoção efetiva de tendência.",
                                "Função personalizada detrend() funciona em novos datasets.",
                                "Lambda ajustado otimiza suavidade visual."
                              ],
                              "assessmentCriteria": [
                                "Código executável e reproduzível sem erros.",
                                "Plots claros demonstram detrending visual.",
                                "Seleção correta de parâmetros (janela/lambda) justificada.",
                                "Testes estatísticos aplicados e interpretados.",
                                "Comparação entre métodos com evidências quantitativas.",
                                "Relatório conciso com insights práticos."
                              ],
                              "crossCurricularConnections": [
                                "Economia: Decomposição PIB em tendência/ciclo para política monetária.",
                                "Finanças: Detrending retornos de ações para análise de ciclos de mercado.",
                                "Machine Learning: Pré-processamento de TS para modelos ARIMA/LSTM.",
                                "Matemática: Otimização convexa no HP filter (penalidade L2)."
                              ],
                              "realWorldApplication": "Bancos centrais (ex: FED) usam HP para separar ciclo econômico de tendência em PIB/inflação, guiando decisões de juros; empresas de varejo detrendam vendas sazonais para forecasting preciso."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.3.3",
                            "name": "Avaliar estacionariedade pós-remoção",
                            "description": "Verificar testes ADF e gráficos QQ dos resíduos após remoção de tendência para confirmar estacionariedade e preparar para modelagem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os resíduos após remoção de tendência",
                                  "subSteps": [
                                    "Carregue a série temporal original e aplique a remoção de tendência (ex: regressão linear ou polinomial).",
                                    "Extraia os resíduos do modelo de tendência usando a fórmula: resíduos = série - tendência ajustada.",
                                    "Visualize os resíduos em um gráfico de linha para inspeção inicial de estacionariedade.",
                                    "Salve os resíduos em um array ou DataFrame para testes subsequentes.",
                                    "Confirme que não há valores ausentes ou outliers extremos nos resíduos."
                                  ],
                                  "verification": "Gráfico de resíduos mostra ausência clara de tendência e variância constante.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Python com pandas, numpy, matplotlib; ou R com base e ggplot2.",
                                  "tips": "Use detrend() no pandas para remoção rápida de tendência linear.",
                                  "learningObjective": "Compreender como obter resíduos limpos para testes de estacionariedade.",
                                  "commonMistakes": "Esquecer de remover valores NA após ajuste; ignorar outliers que afetam testes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar e interpretar o teste ADF nos resíduos",
                                  "subSteps": [
                                    "Instale e importe statsmodels (Python) ou urca (R).",
                                    "Aplique o teste ADF: adfuller(resíduos, regression='c' ou 'ct' conforme contexto).",
                                    "Registre estatística ADF, p-value e lags selecionados.",
                                    "Interprete: rejeite H0 (não estacionária) se p-value < 0.05.",
                                    "Compare com valores críticos para confirmação robusta."
                                  ],
                                  "verification": "P-value do ADF reportado e < 0.05, indicando estacionariedade.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Biblioteca statsmodels.tsa.stattools (Python) ou ur.df (R).",
                                  "tips": "Inclua constante ('c') se resíduos têm média não zero; teste diferentes lags.",
                                  "learningObjective": "Aplicar e interpretar corretamente o teste Augmented Dickey-Fuller.",
                                  "commonMistakes": "Não especificar lags adequados, levando a p-values enviesados; confundir H0 com estacionariedade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar e analisar o gráfico QQ dos resíduos",
                                  "subSteps": [
                                    "Gere resíduos padronizados: (resíduos - média) / desvio padrão.",
                                    "Crie QQ plot usando qqplot(resíduos) em statsmodels ou qqnorm() em R.",
                                    "Inspecione linearidade: pontos próximos à linha reta indicam normalidade.",
                                    "Identifique desvios nas caudas (outliers ou não-normalidade).",
                                    "Adicione gráfico de resíduos vs tempo para checar heterocedasticidade."
                                  ],
                                  "verification": "QQ plot mostra alinhamento linear com distribuição normal teórica.",
                                  "estimatedTime": "12 minutos",
                                  "materials": "statsmodels.graphics.tsaplots.qqplot; scipy.stats.probplot (Python).",
                                  "tips": "Use log-scale para resíduos com variância heterogênea nas caudas.",
                                  "learningObjective": "Avaliar normalidade e estacionariedade via inspeção visual QQ.",
                                  "commonMistakes": "Interpretar desvios menores como falha total; não padronizar resíduos antes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Combinar resultados e concluir sobre estacionariedade",
                                  "subSteps": [
                                    "Integre evidências: ADF significativo + QQ linear = estacionária.",
                                    "Se ADF falhar, considere diferenciação adicional ou modelo ARIMA.",
                                    "Documente relatório: inclua p-value, QQ plot e conclusão.",
                                    "Teste robustez com subamostras ou bootstrap.",
                                    "Prepare resíduos para modelagem (ex: ARMA se estacionários)."
                                  ],
                                  "verification": "Relatório escrito confirma estacionariedade com evidências quantitativas e visuais.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Jupyter Notebook ou R Markdown para relatório.",
                                  "tips": "Sempre priorize ADF para decisão formal, QQ como suporte visual.",
                                  "learningObjective": "Sintetizar múltiplas evidências para decisão informada em séries temporais.",
                                  "commonMistakes": "Concluir estacionariedade só por um teste; ignorar poder estatístico baixo em amostras pequenas."
                                }
                              ],
                              "practicalExample": "Em dados mensais de vendas de varejo (2010-2023), remova tendência linear via OLS. Resíduos: ADF p-value=0.01 (estacionário), QQ plot linear exceto cauda superior. Conclusão: estacionário, pronto para ARMA(1,1).",
                              "finalVerifications": [
                                "P-value ADF < 0.05 nos resíduos.",
                                "QQ plot dos resíduos alinhado à reta diagonal.",
                                "Gráfico de resíduos sem tendência ou sazonalidade residual.",
                                "Estatística ADF mais negativa que valor crítico 5%.",
                                "Ausência de autocorrelação significativa em ACF dos resíduos.",
                                "Variância constante visualizada em plot de resíduos."
                              ],
                              "assessmentCriteria": [
                                "Correta execução do teste ADF com parâmetros apropriados.",
                                "Interpretação precisa do p-value e implicações para estacionariedade.",
                                "Geração e análise qualitativa correta do QQ plot.",
                                "Integração lógica de testes ADF e QQ para conclusão.",
                                "Relatório claro com plots e métricas numéricas.",
                                "Identificação de limitações (ex: tamanho da amostra)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística Inferencial: Hipóteses nulas em testes unit root.",
                                "Visualização de Dados: Interpretação de QQ plots e resíduos.",
                                "Programação: Manipulação de dados em Python/R.",
                                "Econometria: Preparação para modelos de forecasting."
                              ],
                              "realWorldApplication": "Em finanças, avaliar resíduos pós-detendenciação de preços de ações para modelar retornos estacionários em Value-at-Risk; ou em meteorologia, confirmar estacionariedade de temperaturas detrended para previsões climáticas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.4",
                    "name": "Métodos de Previsão para Séries Não Estacionárias",
                    "description": "Modelos ARIMA com diferenciação e outros métodos automáticos adequados.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.4.1",
                        "name": "Diferenciação para Tornar Séries Estacionárias",
                        "description": "Processo de transformar séries temporais não estacionárias em estacionárias por meio de diferenças, removendo tendências e estabilizando a variância.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.1.1",
                            "name": "Identificar Não Estacionariedade",
                            "description": "Aplicar testes estatísticos como o teste de Dickey-Fuller Aumentado (ADF) para detectar raízes unitárias e confirmar a necessidade de diferenciação em séries temporais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Estacionariedade e Raiz Unitária",
                                  "subSteps": [
                                    "Defina estacionariedade fraca: média, variância e covariância constantes ao longo do tempo",
                                    "Explique raiz unitária como causa comum de não-estacionariedade em processos AR(1) com φ=1",
                                    "Discuta implicações para previsão: autocorrelações persistentes levam a forecasts inválidos",
                                    "Revise hipóteses do teste ADF: H0 (raiz unitária) vs H1 (estacionária)",
                                    "Estude variações do ADF: sem constante, com drift, com tendência"
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras explicando os conceitos e hipóteses em suas próprias palavras",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação statsmodels.stats.diagnostic.adfuller",
                                    "Vídeo 'Time Series Stationarity' no YouTube",
                                    "Livro 'Forecasting: Principles and Practice' capítulo 9"
                                  ],
                                  "tips": [
                                    "Use analogia de 'caminhada aleatória' para raiz unitária vs 'média-revertente' para estacionariedade",
                                    "Memorize: p-value > 0.05 geralmente indica não-estacionariedade"
                                  ],
                                  "learningObjective": "Dominar os fundamentos teóricos para justificar a aplicação do teste ADF",
                                  "commonMistakes": [
                                    "Confundir estacionariedade com normalidade dos resíduos",
                                    "Ignorar a presença de tendência determinística",
                                    "Assumir estacionariedade sem teste formal"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar e Visualizar a Série Temporal",
                                  "subSteps": [
                                    "Carregue dataset de série temporal em Python usando pandas (ex: pd.read_csv)",
                                    "Plote a série temporal com matplotlib para inspecionar tendências e sazonalidade",
                                    "Calcule e plote estatísticas rolling (média e desvio padrão) para evidência visual de não-estacionariedade",
                                    "Gere gráfico de autocorrelação (ACF) para detectar persistência",
                                    "Trate missing values e defina índice temporal com pd.to_datetime"
                                  ],
                                  "verification": "Gere e salve 3 plots (série, rolling stats, ACF) mostrando indícios claros de não-estacionariedade",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python 3.9+, bibliotecas: pandas, matplotlib, seaborn",
                                    "Dataset AirPassengers do R/datasets ou statsmodels",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": [
                                    "Use log-transformação inicial se variância aumentar",
                                    "Escala y-axis adequadamente para detectar subtilezas"
                                  ],
                                  "learningObjective": "Identificar visualmente padrões não estacionários como pré-teste para ADF",
                                  "commonMistakes": [
                                    "Plotar sem índice temporal levando a eixos errados",
                                    "Ignorar sazonalidade confundindo com tendência",
                                    "Não normalizar escala de tempo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar o Teste de Dickey-Fuller Aumentado (ADF)",
                                  "subSteps": [
                                    "Importe from statsmodels.tsa.stattools import adfuller",
                                    "Aplique adfuller(série, maxlag='auto', regression='ct') capturando resultados completos",
                                    "Extraia estatísticas chave: test_statistic, pvalue, lags usados, critical_values",
                                    "Repita com diferentes regression types ('c', 'ct', 'ctt') se necessário",
                                    "Salve output em DataFrame para comparação"
                                  ],
                                  "verification": "Obtenha output com p-value > 0.05 e test_statistic pior que critical value a 5%",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Biblioteca statsmodels instalada via pip install statsmodels",
                                    "Jupyter Notebook com dados carregados",
                                    "Referência: statsmodels docs adfuller"
                                  ],
                                  "tips": [
                                    "Comece com regression='ct' para séries com tendência",
                                    "Aumente maxlag se dados ruidosos"
                                  ],
                                  "learningObjective": "Executar o teste ADF de forma reprodutível e capturar todas métricas essenciais",
                                  "commonMistakes": [
                                    "Usar dados não temporais (sem pd.DatetimeIndex)",
                                    "Ignorar lags automáticos levando a especificação errada",
                                    "Confundir H0 com estacionariedade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Resultados e Confirmar Necessidade de Diferenciação",
                                  "subSteps": [
                                    "Avalie p-value: falha em rejeitar H0 (p>0.05) confirma não-estacionariedade",
                                    "Compare test_statistic com critical_values para múltiplos níveis de significância",
                                    "Plote série diferenciada (diff()) e reaplique ADF para validação",
                                    "Documente decisão: se não estacionária, prossiga para diferenciação de 1ª ordem",
                                    "Escreva relatório com evidências visuais e estatísticas"
                                  ],
                                  "verification": "Conclua corretamente com justificativa baseada em p-value e plots pós-diferença",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Mesmo ambiente Python",
                                    "Função np.diff() ou série.diff() no pandas"
                                  ],
                                  "tips": [
                                    "Sempre valide com plot da 1st diff",
                                    "Considere KPSS test como complemento (H0 estacionária)"
                                  ],
                                  "learningObjective": "Interpretar resultados ADF para guiar pré-processamento em modelagem",
                                  "commonMistakes": [
                                    "Rejeitar H0 prematuramente com p próximo a 0.05",
                                    "Não diferenciar após confirmação",
                                    "Omitir contexto de tendência no relatório"
                                  ]
                                }
                              ],
                              "practicalExample": "Carregue o dataset AirPassengers (passageiros aéreos mensais 1949-1960). Plote para ver tendência crescente. Aplique ADF: p-value ≈0.99 >0.05, confirmando raiz unitária. Diferencie uma vez e reaplique ADF (p-value <0.05), validando estacionariedade pós-diferença. Use para preparar ARIMA forecasting.",
                              "finalVerifications": [
                                "Teste ADF executado em série original com p-value indicando não-estacionariedade",
                                "Gráficos de ACF e rolling stats suportam conclusão visual",
                                "Série diferenciada testada com ADF confirmando estacionariedade",
                                "Relatório escrito resume hipóteses, resultados e decisão",
                                "Código Jupyter compartilhável e reprodutível",
                                "Parâmetros do teste (lags, regression) justificados"
                              ],
                              "assessmentCriteria": [
                                "Formulação correta das hipóteses nulas/alternativas do ADF",
                                "Seleção e justificativa de parâmetros (regression type, maxlag)",
                                "Interpretação precisa de p-value, test statistic e critical values",
                                "Integração de evidências visuais com resultados estatísticos",
                                "Decisão sobre diferenciação alinhada rigorosamente aos resultados",
                                "Qualidade e clareza do relatório final"
                              ],
                              "crossCurricularConnections": [
                                "Econometria: Pré-requisito para modelos ARIMA/SARIMA",
                                "Finanças: Detecção em retornos de ativos para modelos GARCH",
                                "Machine Learning: Pré-processamento em features temporais para LSTM/RNN",
                                "Economia: Análise de PIB ou inflação para ciclos econômicos",
                                "Engenharia: Monitoramento de sinais sensoriais não estacionários"
                              ],
                              "realWorldApplication": "Em análise financeira, aplique ADF a séries de preços de ações (ex: AAPL) para detectar não-estacionariedade, diferenciando antes de fitting ARIMA, evitando previsões spurious e melhorando accuracy em trading algorítmico ou gerenciamento de risco."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.1.2",
                            "name": "Aplicar Diferenciação de Primeira Ordem",
                            "description": "Calcular e interpretar a primeira diferença de uma série temporal (Y_t - Y_{t-1}) para remover tendências lineares e preparar dados para modelagem ARIMA.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a Série Temporal Original",
                                  "subSteps": [
                                    "Carregue o conjunto de dados da série temporal usando pandas.",
                                    "Converta a coluna de datas em índice datetime.",
                                    "Visualize a série original com plot para identificar tendências lineares.",
                                    "Realize testes preliminares de estacionariedade (ex: ADF test).",
                                    "Documente estatísticas descritivas (média, variância, autocorrelação)."
                                  ],
                                  "verification": "Gráfico da série original exibido e teste ADF confirma não-estacionariedade (p-value > 0.05).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python com pandas, matplotlib, statsmodels",
                                    "Dataset exemplo: AirPassengers.csv"
                                  ],
                                  "tips": "Sempre verifique valores ausentes e trate-os com forward-fill se necessário.",
                                  "learningObjective": "Entender a estrutura de uma série temporal não estacionária e prepará-la para diferenciação.",
                                  "commonMistakes": [
                                    "Ignorar datas irregulares",
                                    "Não plotar a série antes de diferenciar",
                                    "Esquecer de importar bibliotecas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a Diferenciação de Primeira Ordem",
                                  "subSteps": [
                                    "Crie uma nova série com diff(1): diferencas = serie.diff().dropna().",
                                    "Calcule manualmente para os primeiros termos: Y_t - Y_{t-1}.",
                                    "Armazene a série diferenciada em um DataFrame separado.",
                                    "Atualize o índice para alinhar com as diferenças.",
                                    "Salve a série diferenciada em um arquivo CSV para backup."
                                  ],
                                  "verification": "Comprimento da série diferenciada é n-1, e primeiras diferenças coincidem com cálculo manual.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Jupyter Notebook ou script Python",
                                    "Série temporal preparada do Step 1"
                                  ],
                                  "tips": "Use .dropna() imediatamente após diff() para remover NaN inicial.",
                                  "learningObjective": "Dominar o cálculo matemático da primeira diferença e implementá-lo em código.",
                                  "commonMistakes": [
                                    "Não remover o NaN inicial",
                                    "Confundir ordem da subtração (Y_t - Y_{t-1})",
                                    "Aplicar diff() múltiplas vezes acidentalmente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Visualizar e Analisar a Série Diferenciada",
                                  "subSteps": [
                                    "Plote a série diferenciada ao lado da original para comparação.",
                                    "Calcule e plote a função de autocorrelação (ACF) para ambas as séries.",
                                    "Aplique teste ADF na série diferenciada.",
                                    "Examine estatísticas descritivas da série diferenciada.",
                                    "Identifique resíduos de tendência ou sazonalidade restantes."
                                  ],
                                  "verification": "Gráficos mostram remoção de tendência linear; ACF decai rapidamente; ADF p-value < 0.05.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "statsmodels.tsa.stattools.adfuller",
                                    "matplotlib.pyplot"
                                  ],
                                  "tips": "Use lags=20 no ACF plot para capturar dependências.",
                                  "learningObjective": "Interpretar visual e estatisticamente o impacto da diferenciação na estacionariedade.",
                                  "commonMistakes": [
                                    "Interpretar erroneamente p-value do ADF",
                                    "Não comparar com a original",
                                    "Ignorar picos sazonais no ACF"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Resultados e Preparar para ARIMA",
                                  "subSteps": [
                                    "Explique como a diferenciação removeu a tendência linear.",
                                    "Determine o parâmetro d=1 para o modelo ARIMA(p,d,q).",
                                    "Verifique se diferenciação adicional é necessária (PACF análise).",
                                    "Documente insights em um relatório curto.",
                                    "Prepare o dataset final para ajuste de modelo ARIMA."
                                  ],
                                  "verification": "Relatório escrito confirma estacionariedade e sugere próximos passos para ARIMA.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notebook para relatório",
                                    "Série diferenciada analisada"
                                  ],
                                  "tips": "Se ACF ainda lento, considere diferenciação sazonal em seguida.",
                                  "learningObjective": "Conectar diferenciação à modelagem ARIMA e interpretar implicações práticas.",
                                  "commonMistakes": [
                                    "Assumir estacionariedade sem teste",
                                    "Não documentar mudanças",
                                    "Confundir d com p ou q"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dados mensais de passageiros aéreos (AirPassengers.csv): Série original crescente linearmente. Após diff(1), as diferenças oscilam em torno de zero sem tendência, pronta para ARIMA(2,1,2).",
                              "finalVerifications": [
                                "Série diferenciada tem comprimento correto (n-1) sem NaNs.",
                                "Teste ADF na diferenciada indica estacionariedade (p<0.05).",
                                "Gráficos confirmam remoção de tendência linear.",
                                "ACF da diferenciada decai rapidamente.",
                                "Estatísticas descritivas mostram variância estável.",
                                "Preparação documentada para ARIMA com d=1."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo das diferenças (100% match manual).",
                                "Interpretação correta de testes de estacionariedade.",
                                "Visualizações claras e comparativas.",
                                "Identificação precisa de remoção de tendência.",
                                "Documentação completa dos passos e insights.",
                                "Preparação adequada para modelagem subsequente."
                              ],
                              "crossCurricularConnections": [
                                "Cálculo: Derivadas discretas como aproximação de taxas de mudança.",
                                "Programação: Manipulação de dados com pandas e visualização.",
                                "Economia: Análise de tendências em PIB ou vendas para previsões.",
                                "Física: Modelagem de velocidades em trajetórias discretas.",
                                "Machine Learning: Pré-processamento para modelos de séries temporais."
                              ],
                              "realWorldApplication": "Em finanças, diferenciação de preços de ações remove tendências para detectar ciclos; em varejo, prepara dados de vendas para previsão de demanda e otimização de estoque."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.1.3",
                            "name": "Realizar Diferenciação Sazonal",
                            "description": "Executar diferenciação sazonal (ex.: Y_t - Y_{t-s} onde s é o período sazonal) para séries com padrões repetitivos anuais ou mensais, combinando com diferenciação regular se necessário.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar o Período Sazonal (s)",
                                  "subSteps": [
                                    "Examine o gráfico da série temporal original para padrões repetitivos anuais ou mensais.",
                                    "Calcule e plote a Função de Autocorrelação (ACF) para detectar picos significativos em lags múltiplos de s.",
                                    "Analise a Função de Autocorrelação Parcial (PACF) para confirmar o comprimento do ciclo sazonal.",
                                    "Teste hipóteses de períodos comuns (ex.: s=12 para dados mensais, s=4 para trimestrais).",
                                    "Documente o valor de s escolhido com evidências gráficas e estatísticas."
                                  ],
                                  "verification": "ACF mostra picos claros em lags k*s e o valor de s está justificado com plots salvos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Série temporal de dados (ex.: CSV com vendas mensais)",
                                    "Python com pandas, matplotlib, statsmodels",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Comece com lags óbvios baseados na frequência de dados; use zoom nos plots para detalhes.",
                                  "learningObjective": "Reconhecer e quantificar padrões sazonais em séries temporais.",
                                  "commonMistakes": [
                                    "Confundir sazonalidade com tendência",
                                    "Ignorar lags não múltiplos de s",
                                    "Escolher s muito pequeno sem evidência"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar Diferenciação Sazonal",
                                  "subSteps": [
                                    "Carregue os dados e crie a série diferenciada sazonal: Y_t' = Y_t - Y_{t-s}.",
                                    "Implemente usando shift(s) em Python (ex.: df['seasonal_diff'] = df['Y'] - df['Y'].shift(s)).",
                                    "Trate valores NaN iniciais removendo-os ou interpolando.",
                                    "Plote a série diferenciada sazonal ao lado da original para visual inspeção.",
                                    "Calcule estatísticas descritivas (média, variância) antes e depois."
                                  ],
                                  "verification": "Série diferenciada gerada corretamente sem erros de índice e plot comparativo salvo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código Python preparado",
                                    "Dados da Step 1",
                                    "Bibliotecas: pandas, numpy"
                                  ],
                                  "tips": "Use diff(periods=s) no pandas para simplicidade; verifique o comprimento da série pós-shift.",
                                  "learningObjective": "Aplicar a fórmula de diferenciação sazonal de forma precisa e eficiente.",
                                  "commonMistakes": [
                                    "Erro no valor de s no shift",
                                    "Não remover NaNs levando a plots errados",
                                    "Confundir com diferenciação regular (s=1)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar Estacionariedade da Série Diferenciada",
                                  "subSteps": [
                                    "Aplique o Teste de Dickey-Fuller Aumentado (ADF) na série diferenciada sazonal.",
                                    "Plote ACF e PACF da série diferenciada para ausência de padrões sazonais persistentes.",
                                    "Compare boxplots por estações ou meses para variância constante.",
                                    "Calcule estatísticas de estacionariedade (média rolante, variância rolante).",
                                    "Conclua se estacionária; se não, planeje passos adicionais."
                                  ],
                                  "verification": "p-valor ADF < 0.05 e ACF decai rapidamente; relatório de teste salvo.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "statsmodels.tsa.stattools.adfuller",
                                    "Plots de ACF/PACF",
                                    "Dados diferenciados"
                                  ],
                                  "tips": "Interprete p-valor corretamente: rejeitar H0 significa estacionária.",
                                  "learningObjective": "Avaliar empiricamente a estacionariedade pós-diferenciação.",
                                  "commonMistakes": [
                                    "Ignorar NaNs no teste ADF",
                                    "Confundir não-rejeição com estacionariedade",
                                    "Focar só em visual sem teste formal"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Combinar com Diferenciação Regular e Finalizar",
                                  "subSteps": [
                                    "Se não estacionária, aplique diferenciação regular: ΔY_t' = Y_t' - Y_{t-1}'.",
                                    "Repita verificações de estacionariedade na série dupla diferenciada.",
                                    "Documente o modelo final (ex.: sazonal apenas ou sazonal + regular).",
                                    "Plote todas as séries (original, sazonal diff, final) para comparação.",
                                    "Salve o código e resultados em um notebook reproduzível."
                                  ],
                                  "verification": "Série final estacionária por ADF e plots; código comentado e executável.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Código das steps anteriores",
                                    "statsmodels para testes adicionais"
                                  ],
                                  "tips": "Mantenha track de ordens de diferenciação (ex.: (1,0,0)(0,1,0)_s para sazonal).",
                                  "learningObjective": "Integrar diferenciações regular e sazonal iterativamente.",
                                  "commonMistakes": [
                                    "Sobrediferenciação causando não-estacionariedade invertida",
                                    "Não documentar sequência",
                                    "Esquecer de testar após combinação"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dados mensais de vendas de varejo (ex.: dataset 'AirPassengers' ou vendas de sorvete): identifique s=12, compute Y_t - Y_{t-12}, verifique ADF (p<0.05), aplique diff(1) se necessário, e plote evolução para previsão de demanda futura.",
                              "finalVerifications": [
                                "Série diferenciada sazonal calculada corretamente para todo período.",
                                "Teste ADF confirma estacionariedade (p-valor <0.05).",
                                "Plots de ACF/PACF mostram decaimento rápido sem sazonalidade residual.",
                                "Estatísticas rolantes estáveis (média e variância).",
                                "Código reproduzível gera mesmos resultados.",
                                "Documentação explica escolhas de s e diferenciações adicionais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de s (evidências gráficas claras).",
                                "Implementação correta da fórmula sem erros computacionais.",
                                "Interpretação adequada de testes de estacionariedade.",
                                "Eficiência: tempo dentro do estimado e código limpo.",
                                "Capacidade de combinar diferenciações quando necessário.",
                                "Qualidade dos plots e documentação para comunicação.",
                                "Detecção e correção de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Economia: Análise de ciclos econômicos sazonais em PIB ou vendas.",
                                "Meteorologia: Modelagem de temperaturas com sazonalidade anual.",
                                "Finanças: Previsão de retornos de ações com padrões mensais.",
                                "Biologia: Ciclos populacionais sazonais em ecossistemas."
                              ],
                              "realWorldApplication": "Em empresas de varejo, diferenciação sazonal em vendas mensais permite previsões precisas de estoque para Natal ou verão, reduzindo desperdícios e otimizando logística; usado por analistas em bancos para modelar fluxos de caixa sazonais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.1.4",
                            "name": "Verificar Estacionariedade Após Diferenciação",
                            "description": "Reaplicar testes ADF e analisar gráficos ACF/PACF após diferenciação para confirmar que a série transformada é estacionária e adequada para modelagem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a Série Temporal Diferenciada",
                                  "subSteps": [
                                    "Carregue o conjunto de dados da série temporal original usando pandas.",
                                    "Aplique a diferenciação de primeira ordem com diff() para criar a série diferenciada.",
                                    "Remova valores NA resultantes da diferenciação com dropna().",
                                    "Visualize a série diferenciada com plot() para inspeção inicial.",
                                    "Salve a série diferenciada em uma nova variável para análise."
                                  ],
                                  "verification": "Confirme que a série diferenciada não contém valores NA e exibe uma plotagem sem tendências óbvias.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python com pandas e matplotlib",
                                    "Notebook Jupyter",
                                    "Dataset de série temporal (ex: dados de vendas)"
                                  ],
                                  "tips": "Sempre plote antes de testes formais para ganhar intuição visual.",
                                  "learningObjective": "Preparar corretamente dados diferenciados para testes de estacionariedade.",
                                  "commonMistakes": [
                                    "Esquecer de remover NAs",
                                    "Aplicar diferenciação múltipla sem necessidade",
                                    "Não visualizar a série"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar Teste ADF na Série Diferenciada",
                                  "subSteps": [
                                    "Importe adfuller do statsmodels.tsa.stattools.",
                                    "Execute adfuller(série_diferenciada) para obter resultados.",
                                    "Extraia o valor-p, estatística de teste e valores críticos.",
                                    "Compare o valor-p com 0.05 para rejeitar hipótese nula de não-estacionariedade.",
                                    "Registre os resultados em um dicionário ou DataFrame para relatório."
                                  ],
                                  "verification": "Valor-p < 0.05 e estatística de teste menor que o crítico ao 5%.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python com statsmodels",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Use maxlag='auto' para seleção automática de lags no teste ADF.",
                                  "learningObjective": "Executar e interpretar o teste Augmented Dickey-Fuller corretamente.",
                                  "commonMistakes": [
                                    "Ignorar lags inadequados",
                                    "Confundir hipótese nula (não-estacionária)",
                                    "Não considerar valores críticos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar e Analisar Gráficos ACF e PACF",
                                  "subSteps": [
                                    "Importe plot_acf e plot_pacf do statsmodels.graphics.tsaplots.",
                                    "Gere plot_acf(série_diferenciada, lags=20) e salve a figura.",
                                    "Gere plot_pacf(série_diferenciada, lags=20) e salve a figura.",
                                    "Analise decaimento rápido das autocorrelações além do lag 1.",
                                    "Documente observações sobre presença de autocorrelação serial."
                                  ],
                                  "verification": "Barras ACF/PACF caem dentro das bandas de confiança após poucos lags.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python com statsmodels.graphics",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Aumente lags se a série for longa para melhor visualização.",
                                  "learningObjective": "Identificar estacionariedade através de padrões em ACF/PACF.",
                                  "commonMistakes": [
                                    "Interpretar lags iniciais como não-estacionariedade",
                                    "Não ajustar lags adequadamente",
                                    "Ignorar bandas de confiança"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Resultados e Concluir Estacionariedade",
                                  "subSteps": [
                                    "Combine resultados ADF, ACF e PACF em um relatório resumido.",
                                    "Confirme estacionariedade se ADF rejeita H0 e ACF/PACF mostram decaimento rápido.",
                                    "Se não estacionária, considere diferenciação adicional ou transformações log.",
                                    "Salve plots e resultados em um arquivo PDF ou Markdown.",
                                    "Prepare recomendação para modelagem ARIMA se estacionária."
                                  ],
                                  "verification": "Relatório escrito confirmando ou refutando estacionariedade com evidências.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notebook Jupyter",
                                    "Ferramentas de exportação como matplotlib.savefig()"
                                  ],
                                  "tips": "Use tabelas para resumir estatísticas ADF para clareza.",
                                  "learningObjective": "Sintetizar múltiplas evidências para decisão sobre estacionariedade.",
                                  "commonMistakes": [
                                    "Confiar apenas em um teste",
                                    "Não documentar raciocínio",
                                    "Prosseguir para modelagem sem confirmação"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um dataset de preços diários de ações da AAPL (2000-2023), aplique diferenciação de primeira ordem aos retornos log. Reaplique ADF (valor-p deve cair para <0.01), e observe ACF/PACF com decaimento imediato após lag 0, confirmando estacionariedade para modelagem ARIMA.",
                              "finalVerifications": [
                                "Teste ADF na série diferenciada tem valor-p < 0.05.",
                                "Gráficos ACF/PACF mostram autocorrelações insignificantes após lag 1.",
                                "Ausência visual de tendência ou sazonalidade na plotagem da série diferenciada.",
                                "Relatório documenta todos os resultados com plots salvos.",
                                "Conclusão explícita de estacionariedade ou necessidade de mais diferenciações.",
                                "Série pronta para identificação de parâmetros ARIMA."
                              ],
                              "assessmentCriteria": [
                                "Precisão na execução do teste ADF e interpretação correta.",
                                "Qualidade da análise visual de ACF/PACF com observações detalhadas.",
                                "Documentação completa com plots e resumo.",
                                "Identificação correta de estacionariedade baseada em múltiplas evidências.",
                                "Tratamento adequado de casos não estacionários.",
                                "Eficiência no tempo e uso de melhores práticas em código."
                              ],
                              "crossCurricularConnections": [
                                "Programação em Python (pandas, statsmodels para manipulação de dados).",
                                "Estatística inferencial (testes de hipótese, valores-p).",
                                "Visualização de dados (matplotlib para gráficos de séries temporais).",
                                "Machine Learning (pré-processamento para modelos de previsão).",
                                "Econometria (aplicações em finanças e previsão econômica)."
                              ],
                              "realWorldApplication": "Em finanças, verificar estacionariedade após diferenciação em séries de retornos de ações permite modelar volatilidade com GARCH ou ARIMA, auxiliando traders em previsões de risco e portfólios otimizados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.4.2",
                        "name": "Modelos ARIMA com Diferenciação",
                        "description": "Extensão dos modelos ARMA para séries não estacionárias, incorporando o parâmetro de diferenciação (d) para capturar dependências em níveis integrados.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.2.1",
                            "name": "Especificar Parâmetros ARIMA (p,d,q)",
                            "description": "Determinar os ordens autoregressiva (p), de diferenciação (d) e média móvel (q) com base em gráficos ACF/PACF da série diferenciada e critérios como AIC/BIC.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Determinar a ordem de diferenciação (d)",
                                  "subSteps": [
                                    "Realize o teste de estacionariedade ADF (Augmented Dickey-Fuller) na série original.",
                                    "Plote o gráfico ACF da série original para identificar decaimento lento.",
                                    "Aplique diferenciação de primeira ordem e repita o teste ADF.",
                                    "Continue diferenciando até que o p-valor do ADF < 0.05 e ACF decaia rapidamente.",
                                    "Registre o número mínimo de diferenciações necessárias (d)."
                                  ],
                                  "verification": "Confirme estacionariedade com p-valor ADF < 0.05 e gráfico ACF sem decaimento lento.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com pandas, statsmodels e matplotlib",
                                    "Dataset de série temporal não estacionária (ex: AirPassengers)"
                                  ],
                                  "tips": "Use diferenciação mínima para evitar perda de informação; visualize sempre os gráficos.",
                                  "learningObjective": "Identificar o valor de d que torna a série estacionária usando testes e gráficos.",
                                  "commonMistakes": [
                                    "Sobre-diferenciação levando a não-estacionariedade invertida",
                                    "Ignorar o teste ADF e confiar apenas em gráficos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar e analisar gráficos ACF e PACF da série diferenciada",
                                  "subSteps": [
                                    "Aplique d diferenciações à série original.",
                                    "Gere o gráfico ACF (Autocorrelation Function) até lag 20-30.",
                                    "Gere o gráfico PACF (Partial Autocorrelation Function) até o mesmo lag.",
                                    "Identifique lags significativos onde as barras excedem as bandas de confiança (95%).",
                                    "Anote padrões: corte abrupto no ACF sugere q, no PACF sugere p."
                                  ],
                                  "verification": "Gráficos plotados corretamente com lags significativos destacados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Biblioteca statsmodels.tsa.stattools para acf/pacf",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Ajuste confiança para 95%; foque nos primeiros 10-15 lags para simplicidade.",
                                  "learningObjective": "Produzir e interpretar visualmente ACF/PACF para identificar dependências temporais.",
                                  "commonMistakes": [
                                    "Confundir ACF (correlação total) com PACF (correlação parcial)",
                                    "Ignorar bandas de confiança e considerar todos os lags"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar ordens candidatas p e q baseadas nos gráficos",
                                  "subSteps": [
                                    "Para p: Conte lags significativos no PACF antes do corte abrupto (ex: 2 barras → p=2).",
                                    "Para q: Conte lags significativos no ACF antes do corte (ex: 1 barra → q=1).",
                                    "Considere combinações: AR(p) se PACF significativo e ACF decai; MA(q) se inverso.",
                                    "Liste 3-5 modelos candidatos (ex: ARIMA(1,d,0), (0,d,1), (1,d,1)).",
                                    "Registre justificativa baseada nos gráficos."
                                  ],
                                  "verification": "Lista de modelos candidatos com justificativa gráfica documentada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel ou notebook para anotar lags",
                                    "Gráficos ACF/PACF salvos"
                                  ],
                                  "tips": "Se ambos ACF e PACF decaem gradualmente, considere ARMA misto.",
                                  "learningObjective": "Mapear padrões gráficos para valores iniciais de p e q.",
                                  "commonMistakes": [
                                    "Escolher p/q muito altos baseados em lags isolados",
                                    "Desconsiderar sazonalidade aparente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ajustar modelos e selecionar o melhor com AIC/BIC",
                                  "subSteps": [
                                    "Use statsmodels para ajustar cada modelo ARIMA(p,d,q) candidato.",
                                    "Extraia valores de AIC e BIC para cada modelo.",
                                    "Selecione o modelo com menor AIC/BIC (priorize AIC para previsão).",
                                    "Compare resíduos: plote ACF resíduos (deve ser ruído branco).",
                                    "Confirme com Ljung-Box test (p-valor > 0.05)."
                                  ],
                                  "verification": "Modelo final selecionado com AIC/BIC reportados e resíduos validos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "statsmodels.tsa.arima.model.ARIMA",
                                    "Função sm.stats.acorr_ljungbox"
                                  ],
                                  "tips": "Ajuste no máximo 3-4 candidatos para eficiência; use auto_arima se disponível para validação.",
                                  "learningObjective": "Aplicar critérios informativos para refinar e validar parâmetros ARIMA.",
                                  "commonMistakes": [
                                    "Selecionar pelo menor p+q sem AIC",
                                    "Não verificar resíduos por autocorrelação restante"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a série AirPassengers (passageiros aéreos mensais, não estacionária): d=1 (estacionária após 1 diff). ACF corta em lag 2 (q=2), PACF em lag 1 (p=1) → Candidatos: ARIMA(1,1,1), (1,1,2). AIC: (1,1,1)= AIC 1445, (1,1,2)=1430 → Selecione ARIMA(1,1,2). Resíduos: sem autocorr.",
                              "finalVerifications": [
                                "d correto confirmado por ADF e ACF.",
                                "p e q identificados precisamente dos gráficos ACF/PACF.",
                                "Modelo com menor AIC/BIC selecionado entre candidatos.",
                                "Resíduos do modelo são ruído branco (ACF insignificante).",
                                "Ljung-Box p-valor > 0.05 nos resíduos.",
                                "Justificativa completa documentada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na determinação de d (teste estatístico + visual).",
                                "Interpretação correta de padrões ACF/PACF (80% lags corretos).",
                                "Lista de 3+ candidatos com AIC/BIC comparados.",
                                "Validação de resíduos adequada.",
                                "Eficiência: tempo total < 2h, sem erros de código.",
                                "Documentação clara de decisões."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Uso de Python/R para modelagem estatística (statsmodels/forecast).",
                                "Matemática: Processos estocásticos e funções autorregressivas.",
                                "Economia: Previsão de séries macroeconômicas como PIB ou inflação.",
                                "Machine Learning: Base para modelos SARIMA ou Prophet."
                              ],
                              "realWorldApplication": "Em finanças, especificar ARIMA para prever retornos de ações (ex: modelo GARCH-ARIMA para volatilidade); em supply chain, prever demanda de produtos sazonais para otimizar estoque e reduzir custos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.2.2",
                            "name": "Ajustar e Estimar Modelo ARIMA",
                            "description": "Implementar o modelo ARIMA em software como R (função arima()) com dados diferenciados, estimar coeficientes via máxima verossimilhança e interpretar resultados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e os dados diferenciados no R",
                                  "subSteps": [
                                    "Instalar e carregar os pacotes necessários (forecast, tseries).",
                                    "Carregar o conjunto de dados de série temporal não estacionária.",
                                    "Aplicar diferenciação (diff()) para tornar a série estacionária e plotar para confirmação.",
                                    "Realizar teste de estacionariedade (ADF test) nos dados diferenciados.",
                                    "Visualizar a série diferenciada com plot() e summary()."
                                  ],
                                  "verification": "A série diferenciada passa no teste ADF (p-value < 0.05) e o gráfico mostra ausência de tendência.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "R e RStudio instalados",
                                    "Pacotes: forecast, tseries",
                                    "Dataset de série temporal (ex: AirPassengers)"
                                  ],
                                  "tips": "Sempre plote os dados antes e depois da diferenciação para visual inspeção.",
                                  "learningObjective": "Configurar ambiente R e preparar dados diferenciados para modelagem ARIMA.",
                                  "commonMistakes": [
                                    "Esquecer de instalar pacotes",
                                    "Diferenciar excessivamente levando a sobrediferenciação",
                                    "Ignorar testes de estacionariedade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar as ordens p, d, q do modelo ARIMA",
                                  "subSteps": [
                                    "Calcular e plotar as funções de autocorrelação (ACF) e autocorrelação parcial (PACF) da série diferenciada.",
                                    "Analisar o decaimento das ACF/PACF para determinar q (ACF corta) e p (PACF corta).",
                                    "Confirmar d como o número de diferenciações aplicadas (geralmente 1 ou 2).",
                                    "Testar ordens candidatas com auto.arima() para validação automática.",
                                    "Documentar as ordens escolhidas (ex: ARIMA(p,d,q))."
                                  ],
                                  "verification": "Gráficos ACF/PACF mostram cortes significativos nos lags corretos e auto.arima() sugere ordens compatíveis.",
                                  "estimatedTime": "1-1.5 horas",
                                  "materials": [
                                    "R com pacotes forecast e tseries",
                                    "Série temporal diferenciada"
                                  ],
                                  "tips": "Use lags significativos baseados em barras fora das linhas de confiança azul.",
                                  "learningObjective": "Selecionar parâmetros p, d, q com base em análise gráfica e testes.",
                                  "commonMistakes": [
                                    "Confundir ACF com PACF",
                                    "Escolher ordens muito altas sem justificativa",
                                    "Ignorar significância estatística"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Ajustar e estimar o modelo ARIMA via máxima verossimilhança",
                                  "subSteps": [
                                    "Usar a função arima() com ordem(c(p,d,q)) nos dados diferenciados.",
                                    "Especificar método de estimação 'ML' (máxima verossimilhança).",
                                    "Examinar o summary() do modelo para coeficientes, erros padrão e p-values.",
                                    "Verificar log-likelihood e AIC para qualidade do ajuste.",
                                    "Salvar o modelo ajustado em uma variável (ex: model_arima)."
                                  ],
                                  "verification": "summary(model_arima) mostra convergência sem warnings e coeficientes estimados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Função arima() no R",
                                    "Dados preparados e ordens p,d,q"
                                  ],
                                  "tips": "Inclua include.mean=FALSE se a série diferenciada tem média zero.",
                                  "learningObjective": "Implementar ajuste ARIMA com estimação de coeficientes por máxima verossimilhança.",
                                  "commonMistakes": [
                                    "Usar ordem errada",
                                    "Não especificar método de estimação",
                                    "Ignorar warnings de não convergência"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados e validar o modelo",
                                  "subSteps": [
                                    "Analisar significância dos coeficientes (p-value < 0.05).",
                                    "Verificar resíduos com Ljung-Box test (pacf(residuals)) e plot de resíduos.",
                                    "Gerar previsões com forecast(model_arima) e plotar.",
                                    "Comparar AIC/BIC com outros modelos e interpretar impacto dos coeficientes.",
                                    "Documentar interpretação: ex. 'AR(1)=0.5 indica persistência positiva'."
                                  ],
                                  "verification": "Resíduos são ruído branco (Ljung-Box p-value > 0.05) e previsões plausíveis.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Modelo ajustado",
                                    "Pacotes forecast para previsões"
                                  ],
                                  "tips": "Resíduos devem se comportar como ruído branco: sem autocorrelação.",
                                  "learningObjective": "Interpretar coeficientes ARIMA e validar adequação do modelo.",
                                  "commonMistakes": [
                                    "Interpretar coeficientes sem contexto",
                                    "Aceitar resíduos correlacionados",
                                    "Ignorar diagnósticos"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando o dataset AirPassengers (passageiros aéreos mensais), aplique diff() uma vez para diferenciação, identifique ARIMA(2,1,1) via ACF/PACF, ajuste com arima(AirPassengers, order=c(2,1,1), method='ML'), interprete coeficientes (ex: MA(1) negativo indica reversão) e preveja próximos 12 meses.",
                              "finalVerifications": [
                                "Modelo ARIMA ajustado sem erros de convergência.",
                                "Coeficientes estimados via máxima verossimilhança com p-values reportados.",
                                "Resíduos validados como ruído branco via testes.",
                                "Previsões geradas e plotadas corretamente.",
                                "Interpretação escrita dos coeficientes e AIC.",
                                "Documentação completa do processo."
                              ],
                              "assessmentCriteria": [
                                "Uso correto da função arima() com dados diferenciados.",
                                "Identificação precisa de p,d,q baseada em ACF/PACF.",
                                "Estimação via ML e análise de significância estatística.",
                                "Validação adequada dos resíduos e diagnósticos.",
                                "Interpretação coerente dos resultados.",
                                "Eficiência no tempo e ausência de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estatística inferencial e máxima verossimilhança.",
                                "Programação: Linguagem R e manipulação de dados.",
                                "Economia: Previsão de séries temporais econômicas.",
                                "Ciência de Dados: Modelagem preditiva e validação.",
                                "Finanças: Análise de séries financeiras voláteis."
                              ],
                              "realWorldApplication": "Em empresas de varejo, ajustar ARIMA para prever demanda de produtos sazonais e otimizar estoque; em bancos, estimar retornos de ações diferenciados para estratégias de trading; em governos, prever indicadores econômicos como PIB para políticas públicas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.2.3",
                            "name": "Validar Modelo ARIMA",
                            "description": "Diagnosticar resíduos do modelo ARIMA verificando normalidade (QQ-plot), ausência de autocorrelação (Ljung-Box) e homocedasticidade para garantir adequação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Extrair e Preparar Resíduos do Modelo ARIMA",
                                  "subSteps": [
                                    "Ajuste o modelo ARIMA usando statsmodels em Python com a ordem (p,d,q) determinada previamente.",
                                    "Extraia os resíduos utilizando model.residuais ou residuals attribute.",
                                    "Visualize os resíduos em um gráfico temporal simples para inspeção inicial.",
                                    "Remova quaisquer valores NA dos resíduos com dropna().",
                                    "Salve os resíduos em uma variável para análises subsequentes."
                                  ],
                                  "verification": "Confirme que os resíduos foram extraídos sem erros e plot inicial mostra variabilidade aleatória.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python com statsmodels",
                                    "Jupyter Notebook",
                                    "Dataset de série temporal (ex: AirPassengers)"
                                  ],
                                  "tips": "Sempre verifique o summary do modelo antes de extrair resíduos para confirmar convergência.",
                                  "learningObjective": "Compreender como obter resíduos padronizados de um modelo ARIMA ajustado.",
                                  "commonMistakes": [
                                    "Esquecer de tratar NAs",
                                    "Usar resíduos não padronizados",
                                    "Não verificar se o modelo convergiu"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar Normalidade dos Resíduos com QQ-Plot",
                                  "subSteps": [
                                    "Gere um QQ-plot usando statsmodels.qqplot(residuos, line='s').",
                                    "Adicione o plot com plt.show() ou sm.qqplot.",
                                    "Realize o teste de Shapiro-Wilk com scipy.stats.shapiro(residuos).",
                                    "Interprete o p-value: >0.05 sugere normalidade.",
                                    "Compare visualmente se os pontos seguem a linha reta nos quantis."
                                  ],
                                  "verification": "QQ-plot linear e p-value de Shapiro-Wilk >0.05.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "statsmodels.graphics",
                                    "scipy.stats",
                                    "matplotlib.pyplot"
                                  ],
                                  "tips": "Para grandes amostras, Shapiro-Wilk pode ser sensível; priorize o QQ-plot visual.",
                                  "learningObjective": "Avaliar a normalidade dos resíduos usando gráficos e testes estatísticos.",
                                  "commonMistakes": [
                                    "Ignorar caudas do QQ-plot",
                                    "Confundir p-value com significância",
                                    "Usar teste inadequado para séries temporais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Testar Ausência de Autocorrelação com Ljung-Box",
                                  "subSteps": [
                                    "Calcule o teste Ljung-Box com statsmodels.stats.diagnostic.acorr_ljungbox(residuos, lags=10).",
                                    "Analise ACF e PACF dos resíduos com plot_acf e plot_pacf.",
                                    "Verifique se p-values do Ljung-Box são >0.05 para múltiplos lags.",
                                    "Confirme que barras do ACF estão dentro das bandas de confiança.",
                                    "Documente o número de lags testados baseado no tamanho da amostra."
                                  ],
                                  "verification": "P-values Ljung-Box >0.05 e ACF sem padrões significativos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "statsmodels.stats.diagnostic",
                                    "statsmodels.graphics.tsaplots"
                                  ],
                                  "tips": "Teste múltiplos lags (ex: min(10, n/5)) para robustez.",
                                  "learningObjective": "Detectar dependências residuais remanescentes via testes e gráficos de autocorrelação.",
                                  "commonMistakes": [
                                    "Poucos lags no teste",
                                    "Ignorar PACF",
                                    "Confundir correlação com causalidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Homocedasticidade dos Resíduos",
                                  "subSteps": [
                                    "Gere plot de resíduos vs valores ajustados (fitted) com scatter(residuos, model.fittedvalues).",
                                    "Crie plot de resíduos ao quadrado vs tempo para detectar heteroscedasticidade.",
                                    "Aplique teste de Breusch-Pagan com statsmodels.stats.diagnostic.het_breuschpagan(residuos, model.model.exog).",
                                    "Verifique se não há padrões em funil ou dispersão crescente.",
                                    "Se necessário, considere transformações log ou Box-Cox no modelo original."
                                  ],
                                  "verification": "Plot sem padrões e p-value Breusch-Pagan >0.05.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "statsmodels.stats.diagnostic",
                                    "matplotlib",
                                    "pandas para fittedvalues"
                                  ],
                                  "tips": "Use resíduos padronizados para melhor interpretação.",
                                  "learningObjective": "Identificar variância não constante nos resíduos e suas implicações.",
                                  "commonMistakes": [
                                    "Plotar resíduos vs tempo em vez de fitted",
                                    "Não testar formalmente",
                                    "Ignorar heteroscedasticidade condicional"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um dataset de vendas mensais de varejo (ex: dataset 'sunspots' ou AirPassengers), após ajustar ARIMA(2,1,2), extraia resíduos e valide: QQ-plot linear, Ljung-Box p>0.05, e resíduos vs fitted sem funil, confirmando o modelo adequado para previsões futuras.",
                              "finalVerifications": [
                                "QQ-plot dos resíduos alinhado à reta diagonal.",
                                "Teste Ljung-Box com p-value >0.05 para lags relevantes.",
                                "Plot resíduos vs fittedvalues sem padrões heterocedásticos.",
                                "Teste de normalidade (Shapiro ou Jarque-Bera) aprovado.",
                                "ACF/PACF dos resíduos dentro das bandas de confiança.",
                                "Nenhum outlier extremo nos resíduos."
                              ],
                              "assessmentCriteria": [
                                "Geração correta de todos os plots e testes sem erros de código.",
                                "Interpretação precisa dos p-values e diagnósticos visuais.",
                                "Identificação de violações e sugestões de correção (ex: mais diferenciação).",
                                "Documentação clara dos resultados em relatório.",
                                "Reproduzibilidade do código em ambiente padrão.",
                                "Aplicação em dataset real com conclusões fundamentadas."
                              ],
                              "crossCurricularConnections": [
                                "Programação em Python/R para análise computacional.",
                                "Estatística inferencial e testes de hipóteses.",
                                "Visualização de dados com matplotlib/ggplot.",
                                "Machine Learning: validação de modelos preditivos.",
                                "Econometria: modelagem de séries financeiras."
                              ],
                              "realWorldApplication": "Validar modelos ARIMA para previsão de demanda em supply chain (ex: Amazon otimizando estoque), análise de risco financeiro (previsão de retornos de ações em bancos), ou monitoramento ambiental (previsões de poluição em agências governamentais), garantindo previsões confiáveis e evitando vieses em decisões estratégicas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.2.4",
                            "name": "Gerar Previsões com ARIMA",
                            "description": "Produzir previsões pontuais e intervalos de confiança com o modelo ARIMA ajustado, reintegrando as diferenças para obter previsões na escala original da série.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Gerar Previsões Pontuais na Escala Diferenciada",
                                  "subSteps": [
                                    "Carregue o modelo ARIMA ajustado previamente salvo ou treinado.",
                                    "Defina o horizonte de previsão (h passos à frente).",
                                    "Use o método forecast() do statsmodels para gerar previsões pontuais.",
                                    "Armazene as previsões em um array ou Series do pandas.",
                                    "Verifique o comprimento das previsões para matching com o horizonte."
                                  ],
                                  "verification": "Execute print(forecast_diff) e confirme que o array tem tamanho h sem NaNs.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python com statsmodels, pandas instalados",
                                    "Notebook Jupyter",
                                    "Modelo ARIMA ajustado salvo"
                                  ],
                                  "tips": "Use forecast(horizon=h) para previsões pontuais simples; evite forecast_interval() aqui.",
                                  "learningObjective": "Dominar a geração de previsões pontuais a partir de um modelo ARIMA ajustado em dados diferenciados.",
                                  "commonMistakes": [
                                    "Esquecer de definir o horizonte h",
                                    "Usar dados originais em vez de diferenciados",
                                    "Ignorar warnings de convergência"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Intervalos de Confiança na Escala Diferenciada",
                                  "subSteps": [
                                    "Utilize o método get_forecast() para obter um objeto de previsão com intervalos.",
                                    "Especifique o nível de confiança (ex: 95%) via alpha=0.05.",
                                    "Extraia os limites inferior e superior dos intervalos de confiança.",
                                    "Armazene em um DataFrame com colunas 'lower_diff' e 'upper_diff'.",
                                    "Confira a largura dos intervalos para simetria esperada."
                                  ],
                                  "verification": "Visualize df_forecast.summary_frame() e valide que lower < point < upper.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "statsmodels.tsa.arima.model.ARIMA",
                                    "pandas DataFrame"
                                  ],
                                  "tips": "get_forecast() é mais robusto que forecast_interval() para ARIMA; sempre especifique alpha.",
                                  "learningObjective": "Compreender e implementar intervalos de confiança probabilísticos em previsões ARIMA.",
                                  "commonMistakes": [
                                    "Confundir alpha com nível de confiança",
                                    "Não extrair corretamente os limites do objeto PredictionResults"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Reintegrar Previsões Pontuais para Escala Original",
                                  "subSteps": [
                                    "Identifique o número de diferenças d aplicado (ex: d=1).",
                                    "Para d=1, some as previsões diferenciadas cumulativamente ao último valor original.",
                                    "Use cumsum() no pandas para reintegração simples.",
                                    "Para múltiplas diferenças, aplique cumsum() iterativamente d vezes.",
                                    "Alinhe o índice temporal das previsões originais com a série histórica."
                                  ],
                                  "verification": "Compare a primeira previsão reintegrada: deve ser próxima ao último valor observado se estacionária.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "pandas.Series.cumsum()",
                                    "Série temporal original para último valor"
                                  ],
                                  "tips": "Mantenha o índice temporal intacto; use pd.Series(forecast_diff).cumsum() + last_original.",
                                  "learningObjective": "Aprender a inverter a diferenciação para restaurar previsões na escala original.",
                                  "commonMistakes": [
                                    "Esquecer de adicionar o último valor original",
                                    "Aplicar cumsum() incorretamente para d>1",
                                    "Desalinhar índices"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Reintegrar e Ajustar Intervalos de Confiança para Escala Original",
                                  "subSteps": [
                                    "Aplique cumsum() cumulativo aos limites inferior e superior separadamente.",
                                    "Adicione o último valor original a ambos os limites reintegrados.",
                                    "Para d>1, repita o processo iterativamente com offsets apropriados.",
                                    "Calcule a largura dos intervalos originais e compare com diferenciados.",
                                    "Crie um DataFrame final com point_forecast, lower_ci, upper_ci."
                                  ],
                                  "verification": "Plote as séries e confirme que intervalos se expandem adequadamente na escala original.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "matplotlib ou plotly para plot",
                                    "DataFrame com limites diferenciados"
                                  ],
                                  "tips": "Intervalos reintegrados crescem com o horizonte devido à acumulação de variância.",
                                  "learningObjective": "Garantir que intervalos de confiança sejam corretamente propagados após reintegração.",
                                  "commonMistakes": [
                                    "Reintegrar apenas pontuais e copiar intervalos",
                                    "Não acumular variância corretamente",
                                    "Inverter ordem de cumsum"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Visualizar, Interpretar e Validar Previsões",
                                  "subSteps": [
                                    "Plote a série original histórica + previsões + intervalos.",
                                    "Adicione linha de tendência e fan chart para intervalos.",
                                    "Calcule métricas como largura média de intervalo.",
                                    "Interprete: discuta implicações de widening intervals.",
                                    "Salve resultados em CSV ou pickle para relatórios."
                                  ],
                                  "verification": "Gráfico mostra continuidade suave e intervalos cobrindo ~95% de cenários simulados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "matplotlib.pyplot",
                                    "seaborn para estilos"
                                  ],
                                  "tips": "Use fill_between() para intervalos; teste com simulações para validar cobertura.",
                                  "learningObjective": "Interpretar visual e quantitativamente previsões ARIMA com confiança.",
                                  "commonMistakes": [
                                    "Plotar sem alinhar índices",
                                    "Ignorar widening de intervalos",
                                    "Não rotular eixos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um dataset de vendas mensais de varejo (ex: AirPassengers), após diferenciação d=1 e ajuste ARIMA(2,1,2), gere 12 previsões: pontuais mostram crescimento de 5-10%, intervalos originais de ±20% no mês 12, ajudando a planejar estoque.",
                              "finalVerifications": [
                                "Previsões pontuais reintegradas coincidem com valores observados iniciais (se disponíveis).",
                                "Intervalos de confiança na escala original widening progressivamente.",
                                "Cobertura empírica ~95% em simulações de validação out-of-sample.",
                                "Sem NaNs ou erros de índice em DataFrames finais.",
                                "Gráfico visual confirma continuidade entre histórico e previsões.",
                                "Métricas como MAE em holdout < threshold definido."
                              ],
                              "assessmentCriteria": [
                                "Correção na geração de forecast() e get_forecast() (pass/fail).",
                                "Reintegração exata via cumsum() com último valor original (erro <1%).",
                                "Intervalos propagados corretamente, com largura crescente (qualitativo).",
                                "Visualização clara com labels, legenda e fan chart (rubrica 1-5).",
                                "Interpretação escrita de pelo menos 3 insights (rubrica 1-5).",
                                "Código limpo, comentado e reproduzível (rubrica 1-5)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estatística inferencial e propagação de variância.",
                                "Programação: Manipulação avançada de pandas e statsmodels.",
                                "Economia/Negócios: Previsão de demanda e planejamento estratégico.",
                                "Ciência de Dados: Validação de modelos temporais e uncertainty quantification."
                              ],
                              "realWorldApplication": "Em finanças, prever retornos de ações para portfólios; em supply chain, forecast de demanda para otimizar inventário e reduzir custos em 15-20%; em saúde pública, projeções de casos epidêmicos com intervalos para políticas de contingência."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.4.3",
                        "name": "Métodos Automáticos de Previsão",
                        "description": "Abordagens automatizadas que selecionam e ajustam modelos como ARIMA sem intervenção manual, ideais para grandes volumes de dados não estacionários.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.3.1",
                            "name": "Utilizar auto.arima",
                            "description": "Aplicar a função auto.arima no pacote forecast do R para seleção automática de parâmetros (p,d,q) baseada em critérios de informação, incluindo diferenciação implícita.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Instalar e carregar o pacote forecast",
                                  "subSteps": [
                                    "Abra o R ou RStudio.",
                                    "Execute install.packages('forecast') se não estiver instalado.",
                                    "Execute library(forecast) para carregar o pacote.",
                                    "Verifique a versão com packageVersion('forecast').",
                                    "Carregue dados exemplo com data(AirPassengers)."
                                  ],
                                  "verification": "Confirme que não há erros ao carregar library(forecast) e que packageVersion retorna uma versão recente.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "R ou RStudio instalado, conexão à internet para instalação.",
                                  "tips": "Use um ambiente virtual com renv para gerenciar dependências.",
                                  "learningObjective": "Configurar o ambiente de trabalho para análise de séries temporais com auto.arima.",
                                  "commonMistakes": "Esquecer de instalar dependências como 'tseries' ou usar aspas incorretas no install.packages."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar e explorar a série temporal",
                                  "subSteps": [
                                    "Carregue seus dados em um objeto ts() com frequência apropriada, ex: ts(dados, frequency=12) para dados mensais.",
                                    "Plote a série com plot(série) para visualizar tendências e sazonalidade.",
                                    "Teste estacionariedade com adf.test(série) do pacote tseries.",
                                    "Aplique log(série) se necessário para estabilizar variância.",
                                    "Identifique possíveis diferenciações manuais com diff(série)."
                                  ],
                                  "verification": "Gráfico da série plotado corretamente e teste ADF executado sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Dados de série temporal (ex: AirPassengers), pacote tseries.",
                                  "tips": "Sempre defina frequency corretamente para capturar sazonalidade.",
                                  "learningObjective": "Preparar dados adequados para modelagem ARIMA automática.",
                                  "commonMistakes": "Definir frequência errada (ex: 12 para mensais) ou ignorar transformações como log."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a função auto.arima",
                                  "subSteps": [
                                    "Execute modelo <- auto.arima(série, ic='aic', stepwise=TRUE, approximation=TRUE).",
                                    "Especifique critérios como ic='aic' ou 'bic'.",
                                    "Inclua sazonalidade com seasonal=TRUE se aplicável.",
                                    "Salve o modelo em uma variável.",
                                    "Imprima summary(modelo) para ver parâmetros (p,d,q) selecionados."
                                  ],
                                  "verification": "Modelo ajustado sem warnings e summary mostra parâmetros (p,d,q) não nulos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Série temporal preparada do step anterior.",
                                  "tips": "Use ic='aicc' para séries curtas para evitar overfitting.",
                                  "learningObjective": "Selecionar automaticamente o melhor modelo ARIMA usando critérios de informação.",
                                  "commonMistakes": "Passar dados não-ts para auto.arima ou ignorar parâmetro seasonal para dados sazonais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e validar o modelo ajustado",
                                  "subSteps": [
                                    "Plote resíduos com checkresiduals(modelo).",
                                    "Verifique normalidade com shapiro.test(residuals(modelo)).",
                                    "Analise autocorrelação com acf(residuals(modelo)).",
                                    "Compare AIC/BIC com outros modelos manuais se necessário.",
                                    "Plote o modelo com plot(forecast(modelo))."
                                  ],
                                  "verification": "Resíduos mostram distribuição branca (Ljung-Box p-value > 0.05).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Modelo do step 3.",
                                  "tips": "Resíduos devem se comportar como ruído branco; ajuste manual se falhar.",
                                  "learningObjective": "Validar a adequação do modelo ARIMA automático.",
                                  "commonMistakes": "Interpretar resíduos correlacionados como válidos ou ignorar testes de diagnóstico."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Realizar previsões e avaliação final",
                                  "subSteps": [
                                    "Gere previsões com previsao <- forecast(modelo, h=12).",
                                    "Plote com plot(previsao).",
                                    "Calcule intervalos de confiança com 95% por padrão.",
                                    "Avalie com accuracy(previsao, teste_set) se houver dados de teste.",
                                    "Exporte resultados com write.csv(as.data.frame(previsao), 'previsoes.csv')."
                                  ],
                                  "verification": "Previsões geradas e plotadas sem erros, com accuracy razoável (MAPE < 10%).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Modelo validado do step 4, conjunto de teste opcional.",
                                  "tips": "Use h= número de períodos futuros relevante para o contexto.",
                                  "learningObjective": "Aplicar o modelo para previsões práticas e avaliar performance.",
                                  "commonMistakes": "Prever h muito grande sem validação ou ignorar intervalos de confiança."
                                }
                              ],
                              "practicalExample": "Usando o dataset AirPassengers (passageiros aéreos mensais de 1949-1960), aplique auto.arima(AirPassengers, seasonal=TRUE) para selecionar um modelo ARIMA(0,1,1)(0,1,1)[12], gere previsões para 12 meses à frente e valide resíduos para confirmar adequação em previsão de demanda aérea.",
                              "finalVerifications": [
                                "Modelo auto.arima executado sem erros e parâmetros (p,d,q) selecionados adequadamente.",
                                "Resíduos passam nos testes de ruído branco (checkresiduals p-value > 0.05).",
                                "Previsões plotadas com intervalos de confiança corretos.",
                                "Critérios de informação (AIC/AICc) reportados e comparados.",
                                "Aplicação em dados reais como AirPassengers reproduz resultados esperados."
                              ],
                              "assessmentCriteria": [
                                "Correta instalação e uso de auto.arima com parâmetros apropriados (ic, seasonal).",
                                "Preparação adequada da série temporal (ts, log, frequency).",
                                "Validação completa do modelo (resíduos, testes diagnósticos).",
                                "Interpretação precisa de resultados (parâmetros, critérios de informação).",
                                "Geração e avaliação de previsões com métricas como MAPE.",
                                "Código limpo, reproduzível e comentado."
                              ],
                              "crossCurricularConnections": [
                                "Programação em R: Manipulação de dados e funções avançadas.",
                                "Estatística Inferencial: Testes de estacionariedade e normalidade de resíduos.",
                                "Machine Learning: Modelos automáticos de seleção de hiperparâmetros.",
                                "Economia e Finanças: Previsão de séries temporais financeiras."
                              ],
                              "realWorldApplication": "Em empresas de varejo para previsão de vendas e gestão de estoques; em finanças para modelagem de retornos de ações; em meteorologia para previsão de temperaturas; ou em saúde pública para projeção de casos de doenças sazonais, otimizando decisões baseadas em dados históricos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.3.2",
                            "name": "Implementar ETS Automático",
                            "description": "Usar métodos de suavização exponencial com tendência e sazonalidade (ETS) automáticos para séries não estacionárias, comparando com ARIMA via forecast package.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar Ambiente e Preparar Dados",
                                  "subSteps": [
                                    "Instalar e carregar pacotes necessários: install.packages(c('forecast', 'tseries', 'ggplot2')); library(forecast); library(tseries); library(ggplot2)",
                                    "Carregar dataset de exemplo não estacionário, como data(AirPassengers); ts_data <- AirPassengers",
                                    "Explorar dados: plot(ts_data); summary(ts_data); identificar tendência e sazonalidade",
                                    "Testar estacionariedade: adf.test(ts_data); se p-value > 0.05, confirmar não estacionariedade",
                                    "Preparar dados para modelagem: diferenciar se necessário com diff(ts_data)"
                                  ],
                                  "verification": "Ambiente configurado sem erros de pacote, plot e teste ADF executados com resultados exibidos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "R ou RStudio",
                                    "Pacotes: forecast, tseries, ggplot2",
                                    "Dataset AirPassengers (built-in)"
                                  ],
                                  "tips": [
                                    "Use set.seed(123) para reprodutibilidade",
                                    "Sempre verifique a classe do objeto com class(ts_data)"
                                  ],
                                  "learningObjective": "Preparar ambiente e dados para modelagem de séries temporais não estacionárias.",
                                  "commonMistakes": [
                                    "Esquecer de carregar bibliotecas após instalar",
                                    "Ignorar testes de estacionariedade",
                                    "Usar dados estacionários por engano"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar ETS Automático",
                                  "subSteps": [
                                    "Aplicar ets() automático: model_ets <- ets(ts_data, model='ZZZ')",
                                    "Inspecionar modelo: summary(model_ets); plot(model_ets)",
                                    "Verificar componentes selecionados: error='A', trend='Ad', season='M' ou similares",
                                    "Analisar resíduos: checkresiduals(model_ets); Ljung-Box test",
                                    "Ajustar manualmente se necessário: ets(ts_data, model='AAA')"
                                  ],
                                  "verification": "Modelo ETS ajustado com summary() sem erros e resíduos plotados.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Pacote forecast carregado",
                                    "Dados preparados do Step 1"
                                  ],
                                  "tips": [
                                    "'ZZZ' permite seleção automática de componentes",
                                    "Compare AICc para diferentes modelos"
                                  ],
                                  "learningObjective": "Dominar a função ets() para suavização exponencial automática com tendência e sazonalidade.",
                                  "commonMistakes": [
                                    "Não especificar model='ZZZ' para automação",
                                    "Ignorar diagnóstico de resíduos",
                                    "Confundir componentes ETS (A=aditivo, M=multiplicativo)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar Previsões com ETS",
                                  "subSteps": [
                                    "Gerar previsões: fc_ets <- forecast(model_ets, h=12)",
                                    "Visualizar: plot(fc_ets); autoplot(fc_ets)",
                                    "Calcular intervalos de confiança: 80% e 95% por padrão",
                                    "Comparar com dados reais se disponíveis: accuracy(fc_ets, ts_data)",
                                    "Exportar resultados: write.csv(as.data.frame(fc_ets), 'ets_forecast.csv')"
                                  ],
                                  "verification": "Previsões geradas e plotadas com intervalos de confiança visíveis.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Modelo ETS do Step 2"
                                  ],
                                  "tips": [
                                    "Ajuste h= para horizonte desejado",
                                    "Use autoplot() para gráficos modernos"
                                  ],
                                  "learningObjective": "Produzir e visualizar previsões confiáveis usando ETS automático.",
                                  "commonMistakes": [
                                    "Horizonte h= muito curto ou longo",
                                    "Não plotar intervalos de confiança",
                                    "Esquecer accuracy() para métricas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar ARIMA Automático e Comparar",
                                  "subSteps": [
                                    "Aplicar auto.arima: model_arima <- auto.arima(ts_data)",
                                    "Resumir: summary(model_arima); checkresiduals(model_arima)",
                                    "Gerar previsões ARIMA: fc_arima <- forecast(model_arima, h=12); plot(fc_arima)",
                                    "Comparar modelos: accuracy(model_ets); accuracy(model_arima); comparar RMSE, MAE, MAPE",
                                    "Visualizar lado a lado: autoplot(fc_ets) + autoplot(fc_arima)"
                                  ],
                                  "verification": "Ambos modelos ajustados, previsões comparadas com métricas numéricas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Pacote forecast",
                                    "Modelos ETS e dados"
                                  ],
                                  "tips": [
                                    "auto.arima() usa stepwise para eficiência",
                                    "Priorize RMSE para comparação em séries com tendência"
                                  ],
                                  "learningObjective": "Comparar ETS automático com ARIMA automático para seleção de melhor modelo.",
                                  "commonMistakes": [
                                    "Não usar auto.arima() para automação",
                                    "Comparar apenas visualmente sem métricas",
                                    "Ignorar diferenças em escala (log se multiplicativo)"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Avaliar, Visualizar e Interpretar Resultados",
                                  "subSteps": [
                                    "Calcular métricas finais: acc <- accuracy(fc_ets, ts_data); acc_arima <- accuracy(fc_arima, ts_data)",
                                    "Criar relatório: tabela com RMSE, MAE para ETS vs ARIMA",
                                    "Visualizações avançadas: forecast plot com temas ggplot2",
                                    "Interpretar: 'ETS superior por menor RMSE devido a sazonalidade'",
                                    "Salvar workspace: save.image('ets_analysis.RData')"
                                  ],
                                  "verification": "Relatório com métricas, plots e interpretação gerados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Todos modelos e previsões anteriores"
                                  ],
                                  "tips": [
                                    "Use knitr ou R Markdown para relatório profissional",
                                    "Documente escolhas de modelo"
                                  ],
                                  "learningObjective": "Avaliar criticamente modelos e comunicar insights de previsão.",
                                  "commonMistakes": [
                                    "Focar só em um modelo sem comparação",
                                    "Métricas calculadas incorretamente (test set vs train)",
                                    "Plots sem legendas ou títulos"
                                  ]
                                },
                                {
                                  "practicalExample": "Usando dados AirPassengers (passageiros aéreos mensais 1949-1960), aplique ETS automático para prever próximos 12 meses, compare com auto.arima(), calcule RMSE e visualize, identificando ETS como superior para sazonalidade forte.",
                                  "finalVerifications": [
                                    "Modelo ETS ajustado com componentes corretos (ex: AAdM)",
                                    "Previsões ETS e ARIMA geradas para h=12",
                                    "Métricas de accuracy computadas e comparadas (RMSE < MAE)",
                                    "Resíduos testados (Ljung-Box p>0.05 ideal)",
                                    "Plots de forecast e resíduos sem padrões óbvios"
                                  ],
                                  "assessmentCriteria": [
                                    "Correta aplicação de ets(model='ZZZ') e auto.arima()",
                                    "Seleção automática de componentes validada via summary()",
                                    "Comparação quantitativa precisa (RMSE, MAE, MAPE)",
                                    "Visualizações claras com intervalos de confiança",
                                    "Interpretação coerente dos resultados (ETS vs ARIMA)"
                                  ],
                                  "crossCurricularConnections": [
                                    "Programação em R (manipulação de dados e funções)"
                                  ],
                                  "realWorldApplication": "Previsão de demanda em e-commerce (vendas sazonais), finanças (preços de ações com tendência), saúde (casos de doenças epidêmicas não estacionárias) para otimizar estoques e estratégias.",
                                  "stepNumber": 5,
                                  "title": "Comparação de Modelos ETS e ARIMA para Séries Temporais Sazonais",
                                  "subSteps": [
                                    "Carregar e preparar o conjunto de dados AirPassengers",
                                    "Ajustar modelo ETS automático usando `ets()` com seleção de componentes",
                                    "Ajustar modelo ARIMA automático usando `auto.arima()`",
                                    "Gerar previsões para os próximos 12 meses para ambos os modelos",
                                    "Calcular métricas de precisão (RMSE, MAE, MAPE) para as previsões",
                                    "Testar resíduos dos modelos usando o teste de Ljung-Box",
                                    "Criar visualizações de previsões com intervalos de confiança",
                                    "Comparar resultados e interpretar a superioridade do ETS para sazonalidade forte"
                                  ],
                                  "verification": [
                                    "Confirmação de que o modelo ETS foi ajustado com componentes adequados (ex: AAdM) via `summary()`",
                                    "Geração correta das previsões para h=12 em ambos os modelos",
                                    "Cálculo preciso das métricas de precisão com RMSE < MAE",
                                    "Aplicação válida do teste Ljung-Box (p-valor > 0.05 indicando resíduos brancos de ruído)",
                                    "Visualizações claras sem padrões óbvios nos resíduos e com intervalos de confiança"
                                  ],
                                  "estimatedTime": "2 horas e 30 minutos",
                                  "materials": [
                                    "RStudio ou ambiente R",
                                    "Pacotes `forecast`, `fpp2`",
                                    "Conjunto de dados `AirPassengers`",
                                    "Guia de funções `ets()` e `auto.arima()`",
                                    "Documentação sobre métricas de precisão e testes de resíduos"
                                  ],
                                  "tips": [
                                    "Utilize `auto.ets(model='ZZZ')` para permitir seleção automática de componentes",
                                    "Compare os resumos dos modelos para validar a seleção de componentes",
                                    "Use `accuracy()` para calcular métricas e `checkresiduals()` para testes",
                                    "Em `autoplot()`, inclua `PI = TRUE` para exibir intervalos de confiança",
                                    "Analise gráficos de resíduos para identificar padrões não aleatórios"
                                  ],
                                  "learningObjective": "O aluno será capaz de aplicar e comparar modelos ETS e ARIMA para séries temporais sazonais, interpretar métricas de precisão, validar assumições estatísticas e selecionar o modelo mais adequado com base em características de sazonalidade",
                                  "commonMistakes": [
                                    "Esquecer de especificar `h=12` ao gerar previsões",
                                    "Ignorar a validação dos componentes do modelo ETS via `summary()`",
                                    "Interpretar incorretamente o teste Ljung-Box (p-valor baixo indica problemas)",
                                    "Comparar RMSE e MAE sem considerar a escala da série",
                                    "Não ajustar a estação antes de aplicar modelos não estacionários",
                                    "Utilizar visualizações sem intervalos de confiança para análise de incerteza"
                                  ]
                                }
                              ],
                              "practicalExample": "Utilizando o dataset AirPassengers (passageiros aéreos mensais de 1949 a 1960), os estudantes devem aplicar a sequência completa: preparação de dados, ajuste automático de modelos ETS e ARIMA, geração de previsões para os próximos 12 meses, comparação das métricas RMSE e MAE, e interpretação dos resultados, destacando a superioridade do ETS para séries com forte componente sazonal multiplicativa.",
                              "finalVerifications": [
                                "Execução bem-sucedida de todas as etapas sem erros de sintaxe ou execução.",
                                "Modelo ETS ajustado com componentes automaticamente selecionados (ex: AAdM) e resíduos sem padrões visíveis.",
                                "Previsões geradas para h=12 com intervalos de confiança plotados corretamente.",
                                "Cálculo preciso das métricas RMSE, MAE e MAPE para ambos os modelos.",
                                "Comparação clara indicando qual modelo tem menor erro (ex: RMSE_ETS < RMSE_ARIMA).",
                                "Relatório gerado com visualizações e interpretação escrita."
                              ],
                              "assessmentCriteria": [
                                "Implementação correta das funções ets() com model='ZZZ' e auto.arima().",
                                "Validação da estacionariedade e escolha adequada de diferenciação.",
                                "Análise crítica dos resíduos utilizando testes Ljung-Box.",
                                "Comparação quantitativa adequada usando pelo menos três métricas de erro.",
                                "Presença de visualizações claras com rótulos, legendas e intervalos de confiança.",
                                "Interpretação justificada sobre qual modelo é mais adequado para o contexto dado."
                              ],
                              "crossCurricularConnections": [
                                "Programação estatística em R (manipulação de séries temporais, pacotes forecast e ggplot2)",
                                "Estatística inferencial (testes de hipótese, análise de resíduos)",
                                "Modelagem matemática (representação de tendências e sazonalidades)",
                                "Análise de dados (visão gráfica e métricas de desempenho)",
                                "Comunicação científica (relatórios e visualizações profissionais)"
                              ],
                              "realWorldApplication": "Otimização de estoque em redes de varejo (previsão de demanda sazonal), planejamento de capacidade em serviços de saúde (previsão de casos de doenças epidêmicas), gestão de portfólio financeiro (previsão de retornos de ativos com tendência), logística aérea (previsão de tráfego para alocação de recursos), e análise de tendências de mercado em e-commerce."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.3.3",
                            "name": "Avaliar Previsões Automáticas",
                            "description": "Calcular métricas de precisão como MAE, RMSE e MAPE para comparar desempenho de métodos automáticos em séries não estacionárias, usando validação cruzada temporal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar dados e configurar validação cruzada temporal",
                                  "subSteps": [
                                    "Carregar o conjunto de dados de série temporal não estacionária (ex: vendas mensais).",
                                    "Verificar e tratar não-estacionaridade (diferenciação, log-transformação).",
                                    "Dividir dados em treino e teste usando janela temporal (ex: 80% treino, 20% teste com expansão rolling).",
                                    "Implementar função de validação cruzada temporal para múltiplas folds.",
                                    "Gerar previsões iniciais com métodos automáticos (ex: AutoARIMA, Prophet)."
                                  ],
                                  "verification": "Conjunto de previsões e valores reais alinhados temporalmente sem vazamento de dados futuros.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python 3.x",
                                    "Bibliotecas: pandas, numpy, pmdarima, prophet",
                                    "Jupyter Notebook",
                                    "Dataset de série temporal (ex: AirPassengers)"
                                  ],
                                  "tips": "Sempre respeite a ordem temporal: use apenas dados passados para prever futuros.",
                                  "learningObjective": "Configurar corretamente validação cruzada temporal para séries não estacionárias.",
                                  "commonMistakes": [
                                    "Usar divisão aleatória (shuffle)",
                                    "Incluir dados futuros no treino",
                                    "Ignorar sazonalidade na preparação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular métrica MAE (Mean Absolute Error)",
                                  "subSteps": [
                                    "Implementar fórmula MAE: média dos valores absolutos de (real - previsto).",
                                    "Aplicar função em cada fold da validação cruzada.",
                                    "Média e desvio padrão dos MAE por fold para cada método.",
                                    "Visualizar resíduos com plot de linha (previsões vs reais).",
                                    "Comparar MAE inicial entre métodos automáticos."
                                  ],
                                  "verification": "MAE calculado manualmente coincide com função pronta (ex: sklearn.metrics.mean_absolute_error).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python",
                                    "Bibliotecas: sklearn.metrics, matplotlib",
                                    "Código do Step 1"
                                  ],
                                  "tips": "Normalize séries se escalas diferem para comparação justa.",
                                  "learningObjective": "Dominar cálculo e interpretação de MAE em contexto de previsão temporal.",
                                  "commonMistakes": [
                                    "Não agregar por fold",
                                    "Confundir com MSE",
                                    "Ignorar unidades da métrica"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular métricas RMSE e MAPE",
                                  "subSteps": [
                                    "Implementar RMSE: raiz quadrada da média dos quadrados dos erros.",
                                    "Implementar MAPE: média dos erros percentuais absolutos ((|real-pred|/real)*100).",
                                    "Calcular ambas por fold e agregar (média, mediana, quartis).",
                                    "Criar tabela comparativa de RMSE e MAPE para métodos (AutoARIMA vs Prophet).",
                                    "Identificar folds problemáticos (outliers em métricas)."
                                  ],
                                  "verification": "Valores RMSE e MAPE batem com cálculos manuais em subconjunto pequeno.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python",
                                    "Bibliotecas: numpy, sklearn.metrics",
                                    "Código anterior"
                                  ],
                                  "tips": "MAPE sensível a zeros: use MASE ou ajuste para valores próximos de zero.",
                                  "learningObjective": "Calcular e diferenciar RMSE (penaliza erros grandes) e MAPE (percentual).",
                                  "commonMistakes": [
                                    "Dividir por zero em MAPE",
                                    "Esquecer raiz em RMSE",
                                    "Não tratar NaNs"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar desempenhos e interpretar resultados",
                                  "subSteps": [
                                    "Criar tabela/ranking de métodos por MAE, RMSE, MAPE (menor é melhor).",
                                    "Teste estatístico (ex: Diebold-Mariano) para significância de diferenças.",
                                    "Analisar trade-offs (ex: método com baixo MAE mas alto MAPE).",
                                    "Visualizar boxplots de erros por método e horizonte de previsão.",
                                    "Documentar recomendações baseadas em contexto (ex: custo computacional)."
                                  ],
                                  "verification": "Relatório com tabela, gráficos e conclusão coerente com métricas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python",
                                    "Bibliotecas: statsmodels, seaborn, pandas",
                                    "Todos códigos prévios"
                                  ],
                                  "tips": "Considere horizonte de previsão: métricas pioram com h maior.",
                                  "learningObjective": "Interpretar métricas compostas para seleção de melhor método automático.",
                                  "commonMistakes": [
                                    "Escolher só pelo menor número sem contexto",
                                    "Ignorar variância entre folds",
                                    "Não visualizar erros"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dataset de passageiros aéreos (AirPassengers), aplique AutoARIMA e Prophet com validação cruzada temporal (5 folds). Calcule MAE=15.2, RMSE=22.1, MAPE=12% para AutoARIMA vs MAE=14.8, RMSE=21.5, MAPE=11.5% para Prophet, selecionando Prophet como superior.",
                              "finalVerifications": [
                                "Métricas MAE, RMSE e MAPE calculadas corretamente para todos folds e métodos.",
                                "Tabela comparativa com médias e desvios padrão.",
                                "Gráficos de previsões vs reais sem vazamento temporal.",
                                "Interpretação escrita justificando melhor método.",
                                "Teste de significância confirma diferenças (p-value < 0.05).",
                                "Relatório cobre trade-offs e limitações."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos matemáticos (erro < 1%).",
                                "Correta implementação de validação cruzada temporal.",
                                "Interpretação contextualizada das métricas.",
                                "Visualizações claras e informativas.",
                                "Seleção de método justificada por múltiplas métricas.",
                                "Código limpo, comentado e reproduzível."
                              ],
                              "crossCurricularConnections": [
                                "Programação em Python (manipulação de dados com pandas).",
                                "Machine Learning (modelos de previsão automatizados).",
                                "Estatística Inferencial (testes de hipóteses como Diebold-Mariano).",
                                "Análise de Negócios (previsão de demanda e estoque)."
                              ],
                              "realWorldApplication": "Em finanças, avaliar modelos automáticos para previsão de preços de ações; em supply chain, comparar métodos para demanda de produtos sazonais, otimizando estoques e reduzindo custos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.5",
                    "name": "Análise Exploratória de Não-Estacionariedade",
                    "description": "Gráficos e diagnósticos para identificar componentes não estacionários.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.5.1",
                        "name": "Visualização Gráfica da Série Temporal",
                        "description": "Uso de gráficos básicos e transformados para detectar visualmente componentes não estacionários, como tendência, sazonalidade e heteroscedasticidade em séries temporais.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.1.1",
                            "name": "Plotar a série temporal original",
                            "description": "Construir e interpretar o gráfico da série temporal bruta para identificar padrões visuais de não-estacionariedade, como presença de tendência crescente/decrescente, oscilações sazonais ou variações abruptas na variância.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os dados da série temporal",
                                  "subSteps": [
                                    "Carregue o dataset da série temporal usando pandas (ex: pd.read_csv('dados.csv', parse_dates=['data'], index_col='data'))",
                                    "Verifique a estrutura dos dados com info() e head() para confirmar índice temporal e ausência de valores ausentes",
                                    "Trate valores missing com métodos como ffill() ou interpolate() se necessário",
                                    "Converta a coluna de valores para numérico com pd.to_numeric()",
                                    "Defina o índice como DatetimeIndex com pd.to_datetime() se não estiver formatado"
                                  ],
                                  "verification": "Execute df.info() e df.head(); confirme que o índice é DatetimeIndex e não há NaNs",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python com pandas instalado",
                                    "Dataset de série temporal (ex: AirPassengers.csv)"
                                  ],
                                  "tips": "Sempre defina o índice temporal cedo para facilitar plots futuros",
                                  "learningObjective": "Entender a preparação adequada de dados temporais para visualização",
                                  "commonMistakes": [
                                    "Ignorar valores ausentes",
                                    "Não converter índice para datetime",
                                    "Assumir dados já limpos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar o ambiente de plotagem",
                                  "subSteps": [
                                    "Importe bibliotecas necessárias: import matplotlib.pyplot as plt e import pandas as pd",
                                    "Defina estilo de plot com plt.style.use('seaborn-v0_8') para melhor legibilidade",
                                    "Ajuste o tamanho da figura com plt.figure(figsize=(12,6))",
                                    "Configure rótulos iniciais: plt.xlabel('Tempo'), plt.ylabel('Valor da Série'), plt.title('Série Temporal Original')",
                                    "Ative grid com plt.grid(True, alpha=0.3) para facilitar identificação de padrões"
                                  ],
                                  "verification": "Execute configurações e plt.show(); confirme plot vazio com eixos e grid corretos",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Python com matplotlib instalado"
                                  ],
                                  "tips": "Use figsize largo para séries longas para melhor visualização de tendências",
                                  "learningObjective": "Dominar configurações básicas de plots para séries temporais",
                                  "commonMistakes": [
                                    "Esquecer imports",
                                    "Figsize muito pequeno",
                                    "Rótulos genéricos sem contexto"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar e plotar a série temporal original",
                                  "subSteps": [
                                    "Plote a série com plt.plot(df.index, df['valor'], linewidth=1.5, color='blue')",
                                    "Adicione marcadores opcionais com marker='o' para pontos discretos",
                                    "Rotacione labels do eixo x com plt.xticks(rotation=45)",
                                    "Ajuste limites dos eixos se necessário com plt.xlim() e plt.ylim()",
                                    "Salve o gráfico com plt.savefig('serie_original.png', dpi=300, bbox_inches='tight')"
                                  ],
                                  "verification": "Visualize o plot; confirme linha contínua seguindo o tempo e valores corretos",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código preparado dos steps anteriores"
                                  ],
                                  "tips": "Use linewidth>1 para visibilidade em telas pequenas",
                                  "learningObjective": "Construir gráfico básico da série temporal bruta",
                                  "commonMistakes": [
                                    "Plotar colunas erradas",
                                    "Eixo x não temporal",
                                    "Não rotacionar labels em séries longas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar padrões de não-estacionariedade",
                                  "subSteps": [
                                    "Identifique tendência: procure inclinação crescente/decrescente ao longo do tempo",
                                    "Busque sazonalidade: padrões repetitivos cíclicos (ex: picos anuais)",
                                    "Analise variância: verifique mudanças abruptas ou heteroscedasticidade (variância crescente)",
                                    "Anotar no plot com plt.axvline() para eventos chave ou setas com annotate()",
                                    "Documente observações em um relatório ou print('Tendência: crescente; Sazonal: sim')"
                                  ],
                                  "verification": "Liste 3+ padrões identificados; compare com descrição conhecida do dataset",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráfico gerado",
                                    "Papel/notas para anotações"
                                  ],
                                  "tips": "Zoom em sub-períodos com slicing df['2020':'2022'].plot() para detalhes",
                                  "learningObjective": "Reconhecer visualmente sinais de não-estacionariedade",
                                  "commonMistakes": [
                                    "Confundir ruído com tendência",
                                    "Ignorar escala do eixo y",
                                    "Não anotar achados"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando o dataset AirPassengers (passageiros aéreos mensais 1949-1960), carregue via seaborn.load_dataset('flights').set_index('month').rename(columns={'passengers':'valor'}). Plote para revelar tendência crescente e sazonalidade anual clara.",
                              "finalVerifications": [
                                "Gráfico exibe eixo temporal correto sem gaps",
                                "Tendência, sazonalidade ou variância instável são visíveis",
                                "Rótulos, título e grid estão presentes e legíveis",
                                "Arquivo salvo em alta resolução",
                                "Interpretação escrita identifica pelo menos 2 padrões de não-estacionariedade",
                                "Código roda sem erros em ambiente limpo"
                              ],
                              "assessmentCriteria": [
                                "Precisão na preparação de dados (índice datetime, sem NaNs)",
                                "Qualidade visual do plot (legibilidade, anotações)",
                                "Correta identificação de padrões não-estacionários",
                                "Eficiência do código (sem redundâncias)",
                                "Documentação de interpretação com evidências visuais",
                                "Tempo total dentro do estimado (70-90 min)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Gráficos cartesianos e funções contínuas",
                                "Programação: Manipulação de dados com pandas e visualização",
                                "Economia: Análise de tendências em dados econômicos",
                                "Ciência de Dados: EDA (Exploratory Data Analysis)"
                              ],
                              "realWorldApplication": "Em finanças, plotar retornos diários de ações revela tendências de bull/bear markets ou volatilidade crescente, auxiliando decisões de investimento; em meteorologia, séries de temperatura mostram mudanças climáticas via tendências de longo prazo."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.1.2",
                            "name": "Aplicar diferenciação e plotar a série diferenciada",
                            "description": "Realizar diferenciação de primeira e segunda ordem na série temporal e plotar os resultados para observar a estabilização da média e variância, diagnosticando a ordem de integração necessária.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e visualizar a série temporal original",
                                  "subSteps": [
                                    "Carregue o conjunto de dados da série temporal usando pandas (ex: pd.read_csv()).",
                                    "Converta a coluna de datas em índice datetime com pd.to_datetime().",
                                    "Plote a série original usando matplotlib.pyplot.plot() para inspecionar tendências e variância.",
                                    "Calcule estatísticas descritivas básicas (média, variância) em janelas móveis para confirmar não-estacionariedade.",
                                    "Salve o gráfico como 'serie_original.png'."
                                  ],
                                  "verification": "Gráfico da série original exibido e salvo, com estatísticas móveis mostrando tendência ou variância instável.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python com pandas, matplotlib, numpy instalados",
                                    "Dataset de série temporal (ex: AirPassengers.csv)"
                                  ],
                                  "tips": [
                                    "Use freq='M' para séries mensais ao definir o índice.",
                                    "Ajuste o tamanho da figura com plt.figure(figsize=(10,6)) para melhor visualização."
                                  ],
                                  "learningObjective": "Identificar visualmente não-estacionariedade na série original através de plot e estatísticas móveis.",
                                  "commonMistakes": [
                                    "Não converter datas corretamente, levando a índice incorreto.",
                                    "Ignorar missing values, use df.dropna().",
                                    "Plotar sem rótulos de eixos claros."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar diferenciação de primeira ordem e plotar",
                                  "subSteps": [
                                    "Crie a série diferenciada de 1ª ordem: diff1 = serie.diff().dropna().",
                                    "Plote a diff1 ao lado da original usando subplots (plt.subplot()).",
                                    "Calcule e plote médias e desvios padrão móveis da diff1 para observar estabilização.",
                                    "Compare visualmente a variância e média da diff1 com a original.",
                                    "Salve o gráfico como 'diff_primeira_ordem.png'."
                                  ],
                                  "verification": "Gráficos comparativos salvos mostrando redução na tendência da média na diff1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código Python do Step 1",
                                    "Matplotlib para subplots"
                                  ],
                                  "tips": [
                                    "Use rolling(window=12).mean() para médias móveis em séries mensais.",
                                    "Adicione títulos e legendas com plt.title() e plt.legend()."
                                  ],
                                  "learningObjective": "Executar diferenciação de 1ª ordem e visualizar impacto na estabilização da média.",
                                  "commonMistakes": [
                                    "Esquecer dropna() após diff(), causando NaN no plot.",
                                    "Não alinhar escalas nos subplots.",
                                    "Confundir diff() com diff(1), que é o padrão."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar necessidade de diferenciação de segunda ordem",
                                  "subSteps": [
                                    "Inspecione visualmente a diff1: verifique se média e variância ainda flutuam.",
                                    "Calcule ACF e PACF da diff1 com statsmodels.tsa.stattools.acf() e pacf().",
                                    "Plote ACF/PACF para detectar autocorrelação persistente.",
                                    "Se ACF decai lentamente, aplique diff2 = diff1.diff().dropna().",
                                    "Compare estatísticas móveis de diff1 e diff2."
                                  ],
                                  "verification": "Gráficos de ACF/PACF plotados e decisão justificada sobre 2ª diferenciação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "statsmodels instalado",
                                    "Código das diffs anteriores"
                                  ],
                                  "tips": [
                                    "Limite lags em ACF/PACF para 20-30 para clareza.",
                                    "Use plt.stem() para ACF/PACF mais legível."
                                  ],
                                  "learningObjective": "Diagnosticar estacionariedade parcial via inspeção visual e ACF/PACF.",
                                  "commonMistakes": [
                                    "Interpretar ACF sem barras de confiança (95%).",
                                    "Diferenciar desnecessariamente se diff1 já estacionária.",
                                    "Não padronizar lags nos plots."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Plotar série diferenciada final e diagnosticar ordem de integração",
                                  "subSteps": [
                                    "Se aplicável, plote diff2 ao lado de diff1 e original em um subplot triplo.",
                                    "Calcule estatísticas finais: média, variância constante da série diferenciada.",
                                    "Documente a ordem de integração (I(1) se diff1 estacionária, I(2) se diff2).",
                                    "Salve gráfico final como 'serie_diferenciada_final.png'.",
                                    "Escreva um resumo: 'Ordem de integração: d=1/2' baseado na estabilização."
                                  ],
                                  "verification": "Gráfico final salvo com diagnóstico explícito da ordem de integração.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Todos os códigos anteriores",
                                    "Notebook Jupyter para consolidação"
                                  ],
                                  "tips": [
                                    "Use sharex=True em subplots para alinhar eixos X.",
                                    "Anote ordem no título do gráfico."
                                  ],
                                  "learningObjective": "Concluir análise gráfica diagnosticando ordem de integração via estabilização de média/variância.",
                                  "commonMistakes": [
                                    "Diagnosticar prematuramente sem 2ª diff se necessário.",
                                    "Não salvar gráficos com resoluções altas (dpi=300).",
                                    "Ignorar variância crescente na diff."
                                  ]
                                }
                              ],
                              "practicalExample": "Usando o dataset clássico AirPassengers (passageiros aéreos mensais de 1949-1960): aplique diff(1) para remover tendência sazonal anual, observe estabilização da média; diff(2) estabiliza variância heteroscédastica. Diagnóstico: I(2). Plote todos para relatório de previsão de demanda aérea.",
                              "finalVerifications": [
                                "Série diferenciada final exibe média constante (sem tendência).",
                                "Variância estabilizada (sem heteroscedasticidade crescente).",
                                "Gráficos salvos comparam original, diff1 e diff2 claramente.",
                                "Ordem de integração explicitamente declarada (ex: d=1).",
                                "ACF/PACF da final decai rapidamente dentro de bandas de confiança.",
                                "Estatísticas móveis confirmam estacionariedade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na aplicação de diff() (sem NaNs residuais).",
                                "Qualidade visual dos plots (rótulos, legendas, escalas alinhadas).",
                                "Correta interpretação de estabilização de média/variância.",
                                "Diagnóstico justificado de ordem de integração.",
                                "Uso apropriado de ACF/PACF para validação.",
                                "Eficiência temporal (código limpo, sem loops desnecessários)."
                              ],
                              "crossCurricularConnections": [
                                "Programação em Python/R para manipulação de dados (Pandas/ggplot2).",
                                "Estatística Inferencial: Testes formais como ADF após visual.",
                                "Econometria: Modelos ARIMA com ordem d determinada.",
                                "Visualização de Dados: Princípios de storytelling com gráficos.",
                                "Machine Learning: Pré-processamento para forecasting."
                              ],
                              "realWorldApplication": "Em finanças, diferenciar séries de preços de ações (ex: Bitcoin) para modelar retornos estacionários em ARIMA, permitindo previsões precisas de volatilidade e estratégias de trading; em meteorologia, estabilizar temperaturas para detectar mudanças climáticas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.1.3",
                            "name": "Realizar decomposição da série temporal",
                            "description": "Executar decomposição aditiva ou multiplicativa da série para separar e visualizar componentes de tendência, sazonalidade e resíduo, identificando fontes específicas de não-estacionariedade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e visualizar a série temporal original",
                                  "subSteps": [
                                    "Carregue o conjunto de dados da série temporal em um ambiente de análise (ex: Python com pandas).",
                                    "Converta os dados para um objeto de série temporal com índice de data/hora adequado.",
                                    "Plote a série temporal original para inspecionar visualmente tendência, sazonalidade e irregularidades.",
                                    "Calcule estatísticas descritivas básicas (média, variância) e teste estacionariedade preliminar (ex: ADF test).",
                                    "Identifique o período sazonal (ex: 12 para dados mensais)."
                                  ],
                                  "verification": "Série temporal plotada corretamente com eixo de tempo alinhado e sem erros de indexação; relatório de estatísticas gerado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python (pandas, matplotlib, statsmodels)",
                                    "Dataset de série temporal (ex: AirPassengers.csv)"
                                  ],
                                  "tips": [
                                    "Use freq='M' para mensais; sempre verifique missing values com df.isnull().sum()."
                                  ],
                                  "learningObjective": "Preparar dados de série temporal para decomposição, garantindo integridade e visualização inicial.",
                                  "commonMistakes": [
                                    "Ignorar missing values",
                                    "Índice de tempo incorreto",
                                    "Não plotar escala log se variância crescente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar o modelo de decomposição (aditivo ou multiplicativo)",
                                  "subSteps": [
                                    "Analise a variância: se constante, use aditivo; se crescente com nível, use multiplicativo.",
                                    "Examine o plot original: amplitude sazonal constante (aditivo) vs. proporcional (multiplicativo).",
                                    "Teste log-transformação se necessário para estabilizar variância.",
                                    "Defina parâmetros: período sazonal e janela de suavização (ex: seasonal=12, trend=25).",
                                    "Documente a justificativa da escolha com base em evidências visuais."
                                  ],
                                  "verification": "Relatório escrito justificando escolha do modelo com plots de suporte e critérios claros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Plots da série original",
                                    "Ferramentas de teste: log-transform via np.log()"
                                  ],
                                  "tips": [
                                    "Multiplicativo é comum em dados econômicos; teste ambos se incerto."
                                  ],
                                  "learningObjective": "Discriminar adequadamente entre decomposições aditiva e multiplicativa com base em propriedades da série.",
                                  "commonMistakes": [
                                    "Escolha errada por variância crescente",
                                    "Ignorar log-transform",
                                    "Período sazonal incorreto"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar a decomposição da série temporal",
                                  "subSteps": [
                                    "Importe a função de decomposição (ex: seasonal_decompose do statsmodels.tsa).",
                                    "Aplique a função com parâmetros escolhidos: decompose(series, model='additive', period=12).",
                                    "Extraia componentes: trend, seasonal, resid.",
                                    "Trate valores NA nos componentes suavizados (ex: fillna(method='bfill')).",
                                    "Salve os componentes em variáveis separadas para análise posterior."
                                  ],
                                  "verification": "Componentes extraídos sem erros; verifique shapes iguais à série original.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "statsmodels.tsa.seasonal.seasonal_decompose",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": [
                                    "Use model='multiplicative' se aplicável; inspecione resíduos imediatamente."
                                  ],
                                  "learningObjective": "Implementar corretamente a decomposição clássica para isolar componentes.",
                                  "commonMistakes": [
                                    "Parâmetros default inadequados",
                                    "Não tratar NA",
                                    "Confundir ordem dos componentes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Visualizar e interpretar os componentes",
                                  "subSteps": [
                                    "Plote os quatro painéis: observed, trend, seasonal, remainder.",
                                    "Analise tendência: direção, suavidade, pontos de mudança.",
                                    "Examine sazonalidade: amplitude, periodicidade, consistência.",
                                    "Inspecione resíduos: estacionariedade, autocorrelação (ACF plot).",
                                    "Identifique fontes de não-estacionariedade (ex: tendência linear nos resíduos)."
                                  ],
                                  "verification": "Gráficos de decomposição gerados com legendas e títulos; relatório de interpretação escrito.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "matplotlib.pyplot.subplot",
                                    "statsmodels.graphics.tsaplots.plot_acf"
                                  ],
                                  "tips": [
                                    "Use figsize=(12,8) para clareza; compare resíduos com original."
                                  ],
                                  "learningObjective": "Visualizar e interpretar componentes para diagnosticar não-estacionariedade.",
                                  "commonMistakes": [
                                    "Plots sobrepostos ilegíveis",
                                    "Interpretação errada de resíduos",
                                    "Ignorar escala nos plots"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar decomposição e propor correções",
                                  "subSteps": [
                                    "Teste estacionariedade dos resíduos (ADF test, p-value <0.05).",
                                    "Calcule métricas de ajuste (ex: RMSE entre observed e trend+seasonal+resid).",
                                    "Compare múltiplas decomposições (aditiva vs. multiplicativa).",
                                    "Documente fontes de não-estacionariedade identificadas.",
                                    "Sugira próximos passos (ex: diferenciação se resíduos não estacionários)."
                                  ],
                                  "verification": "Relatório de validação com testes estatísticos e métricas; resíduos aproximadamente estacionários.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "statsmodels.tsa.stattools.adfuller",
                                    "numpy para RMSE"
                                  ],
                                  "tips": [
                                    "p-value alto indica não-estacionariedade persistente; use STL para séries complexas."
                                  ],
                                  "learningObjective": "Validar a decomposição e diagnosticar fontes específicas de não-estacionariedade.",
                                  "commonMistakes": [
                                    "Testes sem correção múltipla",
                                    "Ignorar outliers nos resíduos",
                                    "Concluir sem métricas"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando o dataset AirPassengers (passageiros aéreos mensais de 1949-1960), aplique decomposição multiplicativa: visualize tendência crescente de ~100 para 600, sazonalidade anual com picos de verão, e resíduos aleatórios, identificando não-estacionariedade na tendência e variância.",
                              "finalVerifications": [
                                "Gráficos de decomposição mostram componentes claramente separados sem sobreposições.",
                                "Resíduos exibem média zero e variância constante (teste visual e ADF).",
                                "Escolha do modelo justificada por análise de variância.",
                                "Fontes de não-estacionariedade (tendência/sazonal) explicitamente identificadas.",
                                "Métricas de ajuste (RMSE < 10% do range original).",
                                "Relatório interpreta corretamente implicações para modelagem futura."
                              ],
                              "assessmentCriteria": [
                                "Precisão na preparação de dados (sem erros de indexação: 20%)",
                                "Justificativa correta do modelo aditivo/multiplicativo (25%)",
                                "Implementação sem erros e plots profissionais (20%)",
                                "Interpretação profunda dos componentes (20%)",
                                "Validação estatística rigorosa (15%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelos aditivos/multiplicativos e suavização (médias móveis).",
                                "Programação: Manipulação de dados em Python/R e visualização com bibliotecas.",
                                "Economia: Análise de séries em previsão de demanda e ciclos econômicos.",
                                "Machine Learning: Pré-processamento para modelos de forecasting (ARIMA, Prophet)."
                              ],
                              "realWorldApplication": "Em finanças, decompor séries de preços de ações para separar tendência de crescimento do ruído de mercado; em meteorologia, isolar sazonalidade climática de mudanças de longo prazo para alertas de eventos extremos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.5.2",
                        "name": "Análise de Funções de Autocorrelação",
                        "description": "Emprego das funções de autocorrelação (ACF) e autocorrelação parcial (PACF) para diagnosticar não-estacionariedade por meio de padrões de decaimento lento nas correlações.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.2.1",
                            "name": "Calcular e plotar ACF e PACF",
                            "description": "Computar e visualizar as funções ACF e PACF de uma série temporal usando software como R, observando o comportamento das barras de correlação em lags sucessivos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente R e carregar dados de série temporal",
                                  "subSteps": [
                                    "Instale o R e RStudio se ainda não tiver.",
                                    "Instale os pacotes necessários: install.packages(c('forecast', 'tseries'))",
                                    "Carregue as bibliotecas: library(forecast); library(tseries)",
                                    "Carregue um conjunto de dados de exemplo: data(AirPassengers); ts_data <- AirPassengers",
                                    "Visualize os dados iniciais: plot(ts_data); summary(ts_data)"
                                  ],
                                  "verification": "Os dados estão carregados corretamente e o gráfico inicial é exibido sem erros no console do R.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "R e RStudio instalados",
                                    "Conexão à internet para instalação de pacotes",
                                    "Conjunto de dados de série temporal (ex: AirPassengers)"
                                  ],
                                  "tips": [
                                    "Use RStudio para uma interface gráfica melhor",
                                    "Verifique a versão do R com R.version para compatibilidade"
                                  ],
                                  "learningObjective": "Configurar o ambiente de análise de séries temporais no R e preparar dados para funções ACF/PACF.",
                                  "commonMistakes": [
                                    "Esquecer de chamar library() após install.packages()",
                                    "Usar dados não estacionários sem pré-processamento inicial",
                                    "Ignorar warnings de instalação de pacotes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular e plotar a Função de Autocorrelação (ACF)",
                                  "subSteps": [
                                    "Execute a função básica: acf(ts_data)",
                                    "Salve o resultado em um objeto: acf_result <- acf(ts_data, lag.max=40)",
                                    "Gere o gráfico: plot(acf_result, main='ACF da Série Temporal')",
                                    "Adicione bandas de confiança: acf(ts_data, plot=TRUE, ci.type='ma')",
                                    "Anote lags significativos: identifique barras que ultrapassam as linhas tracejadas azuis"
                                  ],
                                  "verification": "Gráfico ACF é gerado com barras de autocorrelação visíveis e bandas de confiança, sem erros de sintaxe.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ambiente R preparado (Step 1)",
                                    "Dados de série temporal carregados"
                                  ],
                                  "tips": [
                                    "Aumente lag.max para séries longas para melhor visualização",
                                    "Use plot=FALSE para salvar objeto sem plotar"
                                  ],
                                  "learningObjective": "Computar a ACF e visualizar o decaimento das autocorrelações em lags sucessivos.",
                                  "commonMistakes": [
                                    "Não especificar lag.max adequado, resultando em poucos lags",
                                    "Confundir ACF com PACF",
                                    "Ignorar as bandas de confiança na interpretação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular e plotar a Função de Autocorrelação Parcial (PACF)",
                                  "subSteps": [
                                    "Execute a função PACF: pacf(ts_data)",
                                    "Salve o resultado: pacf_result <- pacf(ts_data, lag.max=40)",
                                    "Gere o gráfico: plot(pacf_result, main='PACF da Série Temporal')",
                                    "Compare com ACF: par(mfrow=c(2,1)); plot(acf_result); plot(pacf_result)",
                                    "Identifique corte abrupto nas barras significativas"
                                  ],
                                  "verification": "Gráfico PACF é exibido corretamente ao lado ou abaixo do ACF, destacando diferenças no comportamento.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Resultados ACF do Step 2",
                                    "Ambiente R"
                                  ],
                                  "tips": [
                                    "Use par(mfrow=c(2,1)) para plots lado a lado",
                                    "PACF corta abruptamente para AR(p), diferente do decaimento gradual da ACF"
                                  ],
                                  "learningObjective": "Distinguir PACF da ACF e plotá-la para análise de dependências parciais.",
                                  "commonMistakes": [
                                    "Usar acf() em vez de pacf()",
                                    "Não limitar lag.max, causando sobrecarga computacional",
                                    "Interpretar PACF como ACF"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e interpretar os gráficos ACF e PACF",
                                  "subSteps": [
                                    "Observe o decaimento lento na ACF para detectar não-estacionariedade",
                                    "Identifique lags significativos em ambos os gráficos",
                                    "Compare padrões: ACF decai gradualmente vs. PACF corta abruptamente",
                                    "Documente achados: crie um relatório com summary(acf_result) e summary(pacf_result)",
                                    "Salve os plots: png('acf_pacf.png'); plot(acf_result); dev.off()"
                                  ],
                                  "verification": "Relatório ou comentários no R script explicam padrões observados, como presença de tendência.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráficos ACF e PACF gerados",
                                    "Editor de script R"
                                  ],
                                  "tips": [
                                    "Para não-estacionárias, ACF mostra persistência; teste com diff(ts_data) se necessário",
                                    "Salve plots para portfólio"
                                  ],
                                  "learningObjective": "Interpretar comportamentos das barras em lags sucessivos para diagnosticar propriedades da série.",
                                  "commonMistakes": [
                                    "Concluir estacionariedade sem verificar múltiplos lags",
                                    "Não comparar ACF e PACF juntos",
                                    "Ignorar sazonalidade em dados reais"
                                  ]
                                }
                              ],
                              "practicalExample": "Carregue os dados AirPassengers (passageiros aéreos mensais de 1949-1960). Plote ACF e PACF: observe que a ACF decai lentamente devido à tendência linear, e a PACF mostra significância inicial mas corte posterior, indicando possível ARIMA não estacionária. Use lag.max=36 para capturar sazonalidade anual.",
                              "finalVerifications": [
                                "Gráficos ACF e PACF são gerados corretamente com lag.max adequado.",
                                "Lags significativos são identificados além das bandas de 95% de confiança.",
                                "Diferenças entre decaimento da ACF e corte da PACF são notadas.",
                                "Código R é executado sem erros e plots salvos.",
                                "Interpretação inicial de não-estacionariedade é documentada.",
                                "Dados de exemplo (ex: AirPassengers) mostram padrões esperados."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo e plotagem das funções ACF e PACF (100% das barras corretas).",
                                "Correta configuração de parâmetros como lag.max e bandas de confiança.",
                                "Interpretação qualitativa precisa dos padrões em lags sucessivos.",
                                "Uso eficiente de funções R (acf(), pacf(), plot()).",
                                "Documentação clara de achados e salvamento de outputs.",
                                "Identificação de não-estacionariedade baseada nos gráficos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estatística descritiva e correlação.",
                                "Programação: Manipulação de dados e visualização em R.",
                                "Economia: Análise de séries temporais financeiras.",
                                "Física: Modelagem de fenômenos temporais oscilatórios.",
                                "Ciência de Dados: Pré-processamento para modelagem preditiva."
                              ],
                              "realWorldApplication": "Em previsão de demanda de varejo, analise ACF/PACF de vendas diárias para detectar sazonalidade e tendência, ajustando modelos ARIMA para estoque otimizado; em finanças, identifique dependências em retornos de ações para estratégias de trading."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.2.2",
                            "name": "Interpretar decaimento lento na ACF",
                            "description": "Analisar o decaimento lento ou persistente das autocorrelações na ACF como indício de não-estacionariedade devido a tendência ou raiz unitária, diferenciando de processos estacionários.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Função de Autocorrelação (ACF) e Estacionariedade",
                                  "subSteps": [
                                    "Revise a definição de ACF: correlação entre a série e seus lags.",
                                    "Estude a estacionariedade: média, variância e covariância constantes ao longo do tempo.",
                                    "Identifique que processos estacionários têm ACF que decai rapidamente para zero.",
                                    "Discuta causas de não-estacionariedade: tendência, sazonalidade ou raiz unitária.",
                                    "Pratique plotando ACF de uma série estacionária simulada (ex: ruído branco)."
                                  ],
                                  "verification": "Plotar ACF de uma série estacionária e confirmar decaimento rápido visualmente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software R ou Python (pacotes forecast ou statsmodels)",
                                    "Tutoriais online sobre ACF (ex: Hyndman ou Statsmodels docs)"
                                  ],
                                  "tips": "Sempre normalize a série antes de calcular ACF para evitar confusões com variância.",
                                  "learningObjective": "Entender como a ACF reflete propriedades de estacionariedade em séries temporais.",
                                  "commonMistakes": [
                                    "Confundir ACF com PACF",
                                    "Ignorar a significância das barras de confiança",
                                    "Não diferenciar decaimento exponencial de sinusoidal"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Padrões de Decaimento Lento na ACF",
                                  "subSteps": [
                                    "Gere ou carregue uma série não-estacionária com tendência (ex: random walk).",
                                    "Calcule e plote a ACF da série.",
                                    "Observe o decaimento lento: autocorrelações permanecem altas por muitos lags.",
                                    "Compare com barras de confiança: autocorrelações fora das bandas indicam significância.",
                                    "Registre lags onde ACF > 0.05 em módulo."
                                  ],
                                  "verification": "Identificar pelo menos 10 lags consecutivos com ACF significativa em uma plotagem.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Dados simulados (função rnorm em R ou np.random em Python)",
                                    "Jupyter Notebook ou RStudio"
                                  ],
                                  "tips": "Use lags até 50 para visualizar o padrão lento claramente.",
                                  "learningObjective": "Reconhecer visualmente o decaimento lento como sinal de não-estacionariedade.",
                                  "commonMistakes": [
                                    "Interpretar decaimento lento como sazonalidade sem verificar PACF",
                                    "Usar poucos lags no plot",
                                    "Confundir com AR(1) estacionário"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar Decaimento Lento de Processos Estacionários",
                                  "subSteps": [
                                    "Simule séries estacionárias (ARMA) e compare suas ACFs com não-estacionárias.",
                                    "Crie uma tabela comparativa: decaimento rápido vs lento.",
                                    "Aplique teste de Dickey-Fuller em ambas para validar.",
                                    "Analise impacto de tendência vs raiz unitária na ACF.",
                                    "Documente diferenças qualitativas e quantitativas."
                                  ],
                                  "verification": "Criar uma comparação escrita ou tabela distinguindo 3 exemplos de cada tipo.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Funções adf.test() em R ou adfuller() em Python",
                                    "Datasets de exemplo (ex: AirPassengers)"
                                  ],
                                  "tips": "Remova tendência manualmente (diferenciação) e re-plote ACF para confirmar.",
                                  "learningObjective": "Diferenciar com precisão indícios de não-estacionariedade via ACF.",
                                  "commonMistakes": [
                                    "Não testar significância estatística",
                                    "Confundir variância crescente com decaimento lento",
                                    "Ignorar efeitos de amostra finita"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e Diagnosticar Não-Estacionariedade",
                                  "subSteps": [
                                    "Analise uma série real com decaimento lento (ex: PIB ou preços de ações).",
                                    "Conclua sobre tendência ou raiz unitária baseado no padrão ACF.",
                                    "Recomende próximos passos: diferenciação, teste unit root ou detrending.",
                                    "Valide interpretação com transformação da série e re-análise ACF.",
                                    "Escreva um relatório curto de diagnóstico."
                                  ],
                                  "verification": "Produzir um relatório que corretamente diagnostique não-estacionariedade e sugira correção.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Datasets públicos (ex: FRED para PIB, Yahoo Finance para ações)",
                                    "Relatórios modelo de análise de séries"
                                  ],
                                  "tips": "Combine ACF com plot da série original para contexto visual.",
                                  "learningObjective": "Aplicar interpretação de decaimento lento para diagnóstico prático.",
                                  "commonMistakes": [
                                    "Atribuir causalidade sem testes adicionais",
                                    "Não considerar heterocedasticidade",
                                    "Superestimar estacionariedade pós-um lag alto"
                                  ]
                                }
                              ],
                              "practicalExample": "Ao analisar a série temporal de preços diários do Bitcoin (2020-2023), plote a ACF e observe autocorrelações acima de 0.8 por mais de 20 lags, indicando decaimento lento devido a raiz unitária. Diferencie uma vez e confirme que a ACF da série diferenciada decai rapidamente, validando não-estacionariedade.",
                              "finalVerifications": [
                                "Pode plotar ACF e identificar decaimento lento em dados novos.",
                                "Explica corretamente ligação com tendência/raiz unitária.",
                                "Diferencia ACF de processos estacionários em comparação.",
                                "Aplica diferenciação e verifica melhora na ACF.",
                                "Realiza teste ADF para corroborar interpretação.",
                                "Documenta diagnóstico em relatório conciso."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação visual de decaimento lento (80%+ lags corretos).",
                                "Explicação causal clara (tendência vs raiz unitária).",
                                "Comparação adequada com estacionários (qualitativa e quantitativa).",
                                "Uso correto de testes complementares (ADF).",
                                "Relatório lógico com plots e conclusões acionáveis.",
                                "Ausência de erros comuns como confusão com sazonalidade."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Processos estocásticos e raízes unitárias em álgebra linear.",
                                "Economia: Modelagem de séries financeiras e previsão macroeconômica.",
                                "Física: Análise de sinais em sistemas dinâmicos com tendências.",
                                "Ciência de Dados: Pré-processamento em machine learning para séries temporais."
                              ],
                              "realWorldApplication": "Em finanças, detectar decaimento lento na ACF de retornos de ações sinaliza necessidade de modelagem ARIMA com diferenciação, melhorando previsões de risco e portfólios; em meteorologia, identifica tendências climáticas em temperaturas para projeções de longo prazo."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.2.3",
                            "name": "Comparar ACF/PACF antes e após diferenciação",
                            "description": "Avaliar as mudanças nas funções ACF e PACF após diferenciação para confirmar a remoção de não-estacionariedade e identificar a estrutura apropriada para modelagem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e Visualizar ACF/PACF Antes da Diferenciação",
                                  "subSteps": [
                                    "Carregue o conjunto de dados de série temporal não estacionária (ex: dados de PIB trimestral).",
                                    "Verifique estacionariedade inicial com teste ADF e plote a série temporal.",
                                    "Gere e plote as funções ACF e PACF originais usando biblioteca como statsmodels em Python.",
                                    "Identifique padrões: ACF decaindo lentamente indica não-estacionariedade.",
                                    "Salve os gráficos para comparação posterior."
                                  ],
                                  "verification": "Gráficos ACF/PACF originais gerados e salvos, com ACF mostrando decaimento lento.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python/R com statsmodels/forecast",
                                    "Dataset não estacionário (ex: AirPassengers)"
                                  ],
                                  "tips": "Use lags até 20-30 para visualização clara; normalize os dados se necessário.",
                                  "learningObjective": "Compreender a aparência de ACF/PACF em séries não estacionárias.",
                                  "commonMistakes": [
                                    "Ignorar lags insuficientes",
                                    "Não testar estacionariedade inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar Diferenciação na Série Temporal",
                                  "subSteps": [
                                    "Decida o ordem de diferenciação (geralmente 1 para tendência; teste com ADF).",
                                    "Aplique diff() ou diferenciação de primeira ordem na série.",
                                    "Plote a série diferenciada para confirmar remoção de tendência.",
                                    "Re-teste estacionariedade com ADF na série diferenciada.",
                                    "Documente o número de diferenciações aplicadas."
                                  ],
                                  "verification": "Série diferenciada plotada e teste ADF indica p-value < 0.05 (estacionária).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Mesmo ambiente de programação",
                                    "Funções diff() ou adfuller()"
                                  ],
                                  "tips": "Comece com diferenciação de 1; evite overdifferencing verificando PACF pós-diff.",
                                  "learningObjective": "Executar diferenciação corretamente para induzir estacionariedade.",
                                  "commonMistakes": [
                                    "Diferenciação excessiva levando a série invertível",
                                    "Não plotar série diferenciada"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar e Visualizar ACF/PACF Após Diferenciação",
                                  "subSteps": [
                                    "Calcule e plote ACF/PACF na série diferenciada.",
                                    "Observe mudanças: ACF deve cortar para zero após lag 1-2.",
                                    "Compare visualmente com gráficos originais lado a lado.",
                                    "Identifique picos significativos em PACF para ordem AR.",
                                    "Salve gráficos pós-diferenciação."
                                  ],
                                  "verification": "Gráficos ACF/PACF pós-diff gerados, mostrando ACF rápida para zero.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Bibliotecas de plotagem (matplotlib/ggplot)",
                                    "Gráficos originais salvos"
                                  ],
                                  "tips": "Use subplots para comparação direta; confie em bandas de confiança de 95%.",
                                  "learningObjective": "Visualizar impacto da diferenciação em autocorrelações.",
                                  "commonMistakes": [
                                    "Comparação sem alinhamento de lags",
                                    "Ignorar bandas de confiança"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e Comparar Mudanças para Modelagem",
                                  "subSteps": [
                                    "Analise redução na persistência da ACF (de lento para rápido decaimento).",
                                    "Identifique estrutura ARIMA: PACF pós-diff sugere ordem p; ACF sugere q.",
                                    "Confirme remoção de não-estacionariedade via padrões ACF/PACF.",
                                    "Documente conclusões: ex: 'D=1, agora AR(1) via PACF'.",
                                    "Planeje próximo passo: ajuste modelo ARIMA."
                                  ],
                                  "verification": "Relatório escrito comparando antes/depois e sugerindo parâmetros ARIMA.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráficos comparativos",
                                    "Notebook Jupyter para documentação"
                                  ],
                                  "tips": "Procure 'corte' em ACF para MA(q); spikes em PACF para AR(p).",
                                  "learningObjective": "Interpretar mudanças para seleção de modelo ARIMA.",
                                  "commonMistakes": [
                                    "Confundir ACF com PACF",
                                    "Não ligar padrões a parâmetros d,p,q"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dataset AirPassengers (passageiros aéreos mensais): Antes diff, ACF decai lentamente; após 1 diff, ACF corta após lag 1, PACF spike em lag 1 → sugere ARIMA(1,1,1).",
                              "finalVerifications": [
                                "ACF original decai lentamente; pós-diff, cai dentro de bandas após poucos lags.",
                                "PACF pós-diff mostra spikes claros para identificação de ordem AR.",
                                "Teste ADF confirma estacionariedade após diff (p<0.05).",
                                "Gráficos lado a lado documentam mudanças visuais.",
                                "Conclusões levam a parâmetros ARIMA válidos.",
                                "Nenhuma overdifferencing (PACF não negativo/invertível)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de não-estacionariedade via ACF pré-diff.",
                                "Correta aplicação e verificação de diferenciação.",
                                "Interpretação precisa das mudanças em ACF/PACF.",
                                "Seleção lógica de parâmetros p,d,q baseada em padrões.",
                                "Documentação clara com gráficos comparativos.",
                                "Ausência de erros comuns como overdifferencing."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Uso de Python/R para statsmodels e visualização.",
                                "Estatística Inferencial: Testes de estacionariedade (ADF).",
                                "Visualização de Dados: Interpretação de gráficos ACF/PACF.",
                                "Matemática Aplicada: Transformadas diferenciais em funções autorregressivas."
                              ],
                              "realWorldApplication": "Em finanças, comparar ACF/PACF de retornos de ações antes/depois diff para modelar volatilidade e prever crashes; em meteorologia, analisar temperaturas para remover sazonalidade e forecastar eventos climáticos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.5.3",
                        "name": "Testes Estatísticos de Estacionariedade",
                        "description": "Aplicação de testes formais como ADF e KPSS para confirmar estatisticamente a presença de componentes não estacionários na série temporal.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.3.1",
                            "name": "Executar o teste Augmented Dickey-Fuller (ADF)",
                            "description": "Implementar o teste ADF em software estatístico para testar a hipótese nula de raiz unitária (não-estacionariedade), especificando lags e tipo de teste (com constante, tendência).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e os dados da série temporal",
                                  "subSteps": [
                                    "Carregue a biblioteca pandas para manipulação de dados e statsmodels para o teste ADF.",
                                    "Importe o conjunto de dados de série temporal (ex: de um arquivo CSV com datas e valores).",
                                    "Converta a coluna de datas em índice datetime e defina a frequência da série.",
                                    "Visualize a série com plot() para inspecionar padrões iniciais de não-estacionariedade.",
                                    "Verifique valores ausentes com isna().sum() e trate-os se necessário (ex: interpolação)."
                                  ],
                                  "verification": "Confirme que os dados estão carregados corretamente sem erros e o plot mostra uma série temporal válida.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python com pandas e statsmodels instalados",
                                    "Arquivo CSV de exemplo de série temporal (ex: PIB trimestral)"
                                  ],
                                  "tips": "Use pd.read_csv(parse_dates=['date'], index_col='date') para eficiência.",
                                  "learningObjective": "Configurar corretamente um ambiente Python para análise de séries temporais.",
                                  "commonMistakes": [
                                    "Ignorar a indexação datetime levando a erros no teste",
                                    "Não tratar NaNs causando falha no ADF"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Especificar parâmetros do teste ADF",
                                  "subSteps": [
                                    "Decida o número de lags usando critérios como AIC ou BIC (ex: adfuller com maxlag=None para auto-seleção).",
                                    "Escolha o tipo de teste: 'c' para constante, 'ct' para constante e tendência, 'ctt' para constante, tendência e quadrático, ou 'nc' para nenhum.",
                                    "Considere a hipótese nula: presença de raiz unitária (não-estacionariedade).",
                                    "Defina alpha de significância (geralmente 0,05).",
                                    "Documente as escolhas em um dicionário para reproducibilidade."
                                  ],
                                  "verification": "Crie um dicionário com lags, regression_type e alpha, e imprima para confirmação.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Documentação statsmodels.tsa.stattools.adfuller",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Comece com 'ct' para séries com tendência aparente no plot.",
                                  "learningObjective": "Entender e selecionar parâmetros apropriados para o teste ADF.",
                                  "commonMistakes": [
                                    "Escolher lags excessivos levando a perda de graus de liberdade",
                                    "Confundir tipos de regressão com hipóteses"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar o teste Augmented Dickey-Fuller",
                                  "subSteps": [
                                    "Chame a função: from statsmodels.tsa.stattools import adfuller; result = adfuller(data, maxlag=lags, regression=type_test).",
                                    "Extraia estatísticas chave: statistic, pvalue, usedlag, nobs, critical_values, icbest.",
                                    "Imprima o resultado completo com print(result).",
                                    "Compare p-value com alpha: se p > alpha, não rejeitar H0 (não-estacionária).",
                                    "Salve o resultado em um DataFrame para análise posterior."
                                  ],
                                  "verification": "Execute o código e confirme que p-value e estatística são gerados sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "statsmodels instalado via pip install statsmodels"
                                  ],
                                  "tips": "Use autolag='AIC' para seleção automática de lags.",
                                  "learningObjective": "Implementar o teste ADF corretamente em Python.",
                                  "commonMistakes": [
                                    "Passar dados não univariados",
                                    "Interpretar statistic como p-value"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados e concluir sobre estacionariedade",
                                  "subSteps": [
                                    "Compare a estatística ADF com valores críticos em diferentes níveis (1%, 5%, 10%).",
                                    "Decida: rejeitar H0 se statistic < critical value ou p < alpha.",
                                    "Se não estacionária, sugira diferenciação ou transformações.",
                                    "Crie um relatório resumido: 'Série é não-estacionária (p-value: X)'.",
                                    "Plote resíduos ou ACF/PACF para validação adicional."
                                  ],
                                  "verification": "Gere um relatório escrito confirmando a decisão com evidências numéricas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Gráficos matplotlib ou seaborn para resíduos"
                                  ],
                                  "tips": "Sempre cheque usedlag para confirmar lags selecionados.",
                                  "learningObjective": "Interpretar corretamente os outputs do ADF para decisões analíticas.",
                                  "commonMistakes": [
                                    "Rejeitar H0 incorretamente invertendo comparações",
                                    "Ignorar valores críticos personalizados"
                                  ]
                                }
                              ],
                              "practicalExample": "Carregue dados de preços diários de ações da AAPL (Apple) de 2020-2023. Execute ADF com regression='ct' e maxlag=12. Resultado típico: p-value > 0.05 indica não-estacionariedade; aplique diff() e re-teste.",
                              "finalVerifications": [
                                "Código roda sem erros e produz statistic, pvalue e critical_values.",
                                "Interpretação correta: série estacionária se p < 0.05.",
                                "Parâmetros (lags, tipo) justificados com base em visualização.",
                                "Relatório inclui decisão clara sobre raiz unitária.",
                                "Teste repetido após diferenciação se necessário confirma estacionariedade.",
                                "Gráficos de suporte (série original vs. diferenciada) gerados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na implementação: código reproduz resultados idênticos.",
                                "Seleção adequada de parâmetros: lags e tipo alinhados com dados.",
                                "Interpretação estatística correta: uso de p-value e critical values.",
                                "Documentação completa: comentários e relatório explicativos.",
                                "Eficiência computacional: lags não excessivos.",
                                "Validação: verificação com múltiplos tipos de teste."
                              ],
                              "crossCurricularConnections": [
                                "Econometria: Aplicação em modelagem ARIMA para previsões econômicas.",
                                "Programação: Uso avançado de pandas e statsmodels em Python.",
                                "Finanças: Teste de estacionariedade em retornos de ativos.",
                                "Matemática: Compreensão de processos estocásticos e raízes unitárias.",
                                "Machine Learning: Pré-processamento de séries para modelos de forecasting."
                              ],
                              "realWorldApplication": "Em finanças, bancos centrais usam ADF para testar estacionariedade de taxas de juros ou PIB antes de modelar inflação; em marketing, analisa vendas sazonais para campanhas otimizadas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.3.2",
                            "name": "Interpretar resultados do teste ADF",
                            "description": "Analisar estatística do teste, valor p e estatísticas críticas do ADF para rejeitar ou não a hipótese nula de não-estacionariedade, considerando tamanho da amostra e poder do teste.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os componentes principais do output do teste ADF",
                                  "subSteps": [
                                    "Identifique a hipótese nula (H0: a série tem raiz unitária, i.e., não estacionária) e a alternativa (H1: estacionária).",
                                    "Localize a estatística do teste ADF (t-statistic).",
                                    "Anote os valores críticos (1%, 5%, 10%) para o modelo apropriado (com ou sem constante/drift/tendência).",
                                    "Registre o valor p (p-value) associado.",
                                    "Verifique o número de lags selecionados e o tamanho da amostra (n)."
                                  ],
                                  "verification": "Liste todos os componentes extraídos do output em um documento ou notebook, confirmando presença de estatística ADF, p-value, valores críticos e n.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Output do teste ADF (de R, Python statsmodels ou EViews), calculadora ou software de estatística.",
                                  "tips": "Sempre copie o output completo para referência; use tabelas formatadas para organização.",
                                  "learningObjective": "Compreender e extrair corretamente todos os elementos chave do relatório do teste ADF.",
                                  "commonMistakes": "Confundir estatística ADF com outras estatísticas; ignorar o tipo de modelo (sem constante, com constante, etc.)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Comparar a estatística ADF com valores críticos",
                                  "subSteps": [
                                    "Selecione o nível de significância desejado (ex: 5%).",
                                    "Compare a estatística ADF com o valor crítico correspondente no nível escolhido.",
                                    "Se |ADF stat| > |valor crítico|, rejeite H0 (estacionária); caso contrário, não rejeite.",
                                    "Considere o sinal: ADF stat deve ser mais negativa que o crítico para rejeição.",
                                    "Documente a comparação em uma tabela simples."
                                  ],
                                  "verification": "Crie uma tabela mostrando ADF stat vs. críticos e indique rejeição ou não.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Tabela de valores críticos ADF (Dickey-Fuller table), output do teste.",
                                  "tips": "Lembre-se: valores críticos são negativos; foco no módulo absoluto para comparação.",
                                  "learningObjective": "Aplicar corretamente a regra de decisão baseada em valores críticos.",
                                  "commonMistakes": "Ignorar o sinal da estatística; usar valor crítico errado para o modelo ou nível de significância."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar o valor p e integrar com a decisão",
                                  "subSteps": [
                                    "Compare p-value com α (ex: 0.05): se p < α, rejeite H0.",
                                    "Confirme consistência entre p-value e comparação de críticos.",
                                    "Interprete: p baixo indica forte evidência contra não-estacionariedade.",
                                    "Registre a decisão final baseada em p-value como primária.",
                                    "Anote qualquer discrepância potencial (rara, mas possível em amostras pequenas)."
                                  ],
                                  "verification": "Escreva uma frase conclusiva: 'Rejeitar H0 pois p=0.03 < 0.05' ou similar.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Output do teste, tabela de decisão.",
                                  "tips": "p-value é mais robusto; use como critério principal em softwares modernos.",
                                  "learningObjective": "Usar p-value para uma interpretação probabilística da evidência.",
                                  "commonMistakes": "Confundir p-value com probabilidade de H0 ser verdadeira; ignorar múltiplos testes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ajustar interpretação pelo tamanho da amostra e poder do teste",
                                  "subSteps": [
                                    "Avalie n: para n<100, teste tem baixo poder; resultados inconclusivos precisam de cautela.",
                                    "Estime poder aproximado (use tabelas ou software como pwr em R).",
                                    "Se não rejeitar H0 em n pequeno, considere testes alternativos (KPSS).",
                                    "Conclua com qualificadores: 'Evidência fraca devido a n=50'.",
                                    "Recomende próximos passos (diferenciação se não estacionária)."
                                  ],
                                  "verification": "Inclua parágrafo qualificando a conclusão com n e poder estimado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Tabelas de poder ADF, calculadora de poder (online ou R/Python).",
                                  "tips": "Poder aumenta com n; sempre reporte n na conclusão.",
                                  "learningObjective": "Contextualizar resultados considerando limitações estatísticas.",
                                  "commonMistakes": "Ignorar baixo poder em amostras pequenas, levando a falsos negativos."
                                }
                              ],
                              "practicalExample": "Em Python com statsmodels: Para série de preços de Bitcoin (n=200), output mostra ADF stat=-3.45, crítico 5%=-2.89, p=0.01. Conclusão: Rejeitar H0 (estacionária em 5%, poder alto devido a n>100). Plote a série e ACF para confirmar visualmente.",
                              "finalVerifications": [
                                "Estatística ADF corretamente comparada a críticos apropriados.",
                                "p-value leva à decisão consistente (rejeitar/não rejeitar H0).",
                                "Conclusão qualificada por tamanho da amostra (n reportado).",
                                "Poder do teste considerado (comentário sobre força da evidência).",
                                "Decisão final clara: 'Série é estacionária' ou 'Não estacionária'.",
                                "Próximos passos sugeridos (ex: modelar ou diferenciar)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na extração e comparação de estatística ADF e críticos (30%).",
                                "Correta interpretação de p-value e consistência com decisão (25%).",
                                "Adequada qualificação por n e poder (20%).",
                                "Clareza e documentação da conclusão (15%).",
                                "Identificação de erros potenciais e dicas (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Econometria: Aplicação em testes de cointegração (Johansen).",
                                "Programação: Implementação em Python/R (statsmodels, urca package).",
                                "Finanças: Análise de retornos de ativos para modelagem ARIMA.",
                                "Matemática: Probabilidade e inferência estatística (distribuição Dickey-Fuller)."
                              ],
                              "realWorldApplication": "Em finanças, interpretar ADF em retornos diários de ações para decidir se usar ARIMA (estacionária) ou diferenciar; evita modelos inválidos em previsões de mercado, como na BlackRock ou hedge funds."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.3.3",
                            "name": "Aplicar teste KPSS complementar",
                            "description": "Realizar o teste KPSS para testar estacionariedade em torno de uma tendência (hipótese nula de estacionariedade), usando-o em conjunto com ADF para diagnóstico robusto.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e os dados para o teste KPSS",
                                  "subSteps": [
                                    "Instale as bibliotecas necessárias: pip install statsmodels pandas matplotlib numpy",
                                    "Carregue o conjunto de dados de série temporal em um DataFrame do pandas (ex: dados de PIB trimestral)",
                                    "Converta a coluna de dados para um array NumPy ou Series do pandas",
                                    "Visualize a série temporal com plot() para identificar possíveis tendências lineares",
                                    "Verifique estatísticas descritivas básicas (média, variância, autocorrelação inicial)"
                                  ],
                                  "verification": "Confirme que o gráfico da série mostra uma tendência clara e que não há erros de importação ou NaN nos dados",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "Bibliotecas: statsmodels, pandas, matplotlib, numpy",
                                    "Dataset de série temporal (ex: CSV de PIB)"
                                  ],
                                  "tips": "Sempre diferencie os dados se suspeitar de tendência antes do teste, mas para KPSS teste a original",
                                  "learningObjective": "Configurar um ambiente computacional pronto para aplicar testes de estacionariedade",
                                  "commonMistakes": [
                                    "Ignorar valores ausentes (NaN)",
                                    "Não plotar a série inicialmente",
                                    "Usar dados não numéricos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar o teste KPSS com regressão de tendência",
                                  "subSteps": [
                                    "Importe a função: from statsmodels.tsa.stattools import kpss",
                                    "Defina o tipo de regressão como 'ct' (constante + tendência): kpss(data, regression='ct', nlags='auto')",
                                    "Armazene o resultado em uma variável: result = kpss(...)",
                                    "Extraia estatísticas chave: statistic, pvalue, lags, critical_values = result",
                                    "Registre os lags usados e valores críticos para diferentes níveis de significância",
                                    "Execute com diferentes nlags se necessário para robustez (ex: 'legacy' ou número fixo)"
                                  ],
                                  "verification": "O teste retorna p-valor, estatística KPSS e valores críticos sem erros de convergência",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Código Python pronto",
                                    "Dataset preparado do Step 1"
                                  ],
                                  "tips": "Use regression='ct' para testar estacionariedade em torno de tendência; 'c' para sem tendência",
                                  "learningObjective": "Aplicar corretamente a função KPSS com parâmetros adequados para séries com tendência",
                                  "commonMistakes": [
                                    "Usar regression='c' em séries com tendência óbvia",
                                    "Ignorar lags automáticos",
                                    "Confundir com adfuller"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar os resultados do teste KPSS",
                                  "subSteps": [
                                    "Lembre a hipótese nula (H0): a série é estacionária em torno de uma tendência determinística",
                                    "Compare p-valor com 0.05: se p < 0.05, rejeite H0 (não estacionária, possível raiz unitária)",
                                    "Analise a estatística KPSS vs. valores críticos (ex: rejeita se > crítico a 5%)",
                                    "Compare com teste ADF prévio: ADF rejeita não-estacionariedade + KPSS rejeita estacionariedade confirma não-estacionariedade",
                                    "Documente conclusão em um relatório curto: 'KPSS p=0.01 <0.05, rejeita H0'",
                                    "Plote resíduos ou resíduos detrendizados para validação visual"
                                  ],
                                  "verification": "Escreva uma interpretação clara: H0 rejeitada ou não, com justificativa baseada em p-valor",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Resultados do Step 2",
                                    "Resultados ADF prévios"
                                  ],
                                  "tips": "KPSS é complementar a ADF: use ambos para evitar falsos positivos",
                                  "learningObjective": "Interpretar corretamente hipóteses e resultados do KPSS em contexto de tendência",
                                  "commonMistakes": [
                                    "Confundir H0 com ADF (ADF H0=unit root)",
                                    "Ignorar comparação com ADF",
                                    "Não considerar tamanho da amostra"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar KPSS com ADF e concluir diagnóstico robusto",
                                  "subSteps": [
                                    "Execute ADF complementar se não feito: from statsmodels.tsa.stattools import adfuller",
                                    "Compare tabelas de resultados: crie DataFrame com p-values de ambos",
                                    "Decida ação: se ambos indicam não-estacionariedade, diferencie a série",
                                    "Teste KPSS nos dados diferenciados para confirmar estacionariedade",
                                    "Gere relatório final com tabelas, gráficos e recomendação (ex: 'Diferencie 1x')",
                                    "Salve resultados em arquivo (ex: pickle ou CSV) para reprodutibilidade"
                                  ],
                                  "verification": "Relatório final mostra consistência entre KPSS e ADF, com recomendação acionável",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Códigos dos steps anteriores",
                                    "Função adfuller"
                                  ],
                                  "tips": "Sempre teste pós-diferenciação com ambos para ciclo completo",
                                  "learningObjective": "Realizar diagnóstico robusto combinando testes complementares para séries temporais",
                                  "commonMistakes": [
                                    "Não retestar após diferenciação",
                                    "Interpretar testes isoladamente",
                                    "Sobrediferenciação sem verificação"
                                  ]
                                }
                              ],
                              "practicalExample": "Em dados trimestrais de PIB do Brasil (1980-2023), plote a série mostrando tendência crescente. Aplique KPSS com regression='ct': obtém p-valor=0.008 <0.05, rejeitando H0 de estacionariedade em tendência. ADF confirma unit root (p=0.85). Diferencie 1x e reteste: KPSS p=0.45 >0.05, confirma estacionariedade pós-diferenciação.",
                              "finalVerifications": [
                                "KPSS executado com regression='ct' e resultados armazenados corretamente",
                                "Interpretação precisa da H0 e p-valor (rejeição se <0.05)",
                                "Comparação explícita com ADF para diagnóstico consistente",
                                "Teste pós-diferenciação realizado se necessário",
                                "Relatório visual e tabular gerado",
                                "Reprodutibilidade confirmada rodando script novamente"
                              ],
                              "assessmentCriteria": [
                                "Formulação correta das hipóteses nula e alternativa do KPSS",
                                "Seleção adequada de parâmetros (regression, lags) justificada",
                                "Interpretação precisa e integração com ADF sem contradições",
                                "Tratamento robusto de dados (plots, descritivos, diferenciação)",
                                "Relatório claro, acionável e com evidências computacionais",
                                "Identificação e correção de erros comuns demonstrada"
                              ],
                              "crossCurricularConnections": [
                                "Econometria: Modelagem ARIMA e cointegration",
                                "Análise Financeira: Testes em retornos de ativos",
                                "Machine Learning: Pré-processamento para forecasting com LSTM",
                                "Economia: Análise de ciclos econômicos e tendências macro",
                                "Programação Estatística: Uso avançado de statsmodels em Python/R"
                              ],
                              "realWorldApplication": "Em bancos centrais ou consultorias econômicas, o teste KPSS complementar ao ADF é essencial para validar não-estacionariedade em séries como inflação, PIB ou câmbio antes de modelar forecasts, evitando modelos espúrios e melhorando precisão em políticas monetárias."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.6",
                "name": "Séries Temporais Sazonais",
                "description": "Análise de padrões sazonais e métodos de previsão específicos para essas séries.",
                "totalSkills": 49,
                "atomicTopics": [
                  {
                    "id": "10.1.6.1",
                    "name": "Definição e Identificação de Sazonalidade",
                    "description": "Características das séries temporais sazonais e métodos para detectar padrões sazonais repetitivos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.1.1",
                        "name": "Definição de Séries Temporais Sazonais",
                        "description": "Compreensão conceitual do que caracteriza uma série temporal sazonal, incluindo a presença de padrões repetitivos ao longo de ciclos fixos.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.1.1",
                            "name": "Definir sazonalidade em séries temporais",
                            "description": "Explicar a sazonalidade como flutuações regulares e previsíveis em uma série temporal que se repetem em intervalos fixos, como meses ou trimestres, independentes de tendências de longo prazo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito Básico de Séries Temporais",
                                  "subSteps": [
                                    "Defina série temporal como uma sequência de dados coletados ao longo do tempo em intervalos regulares.",
                                    "Identifique exemplos comuns, como vendas mensais ou temperaturas diárias.",
                                    "Explique a importância de analisar séries temporais para previsão e compreensão de padrões.",
                                    "Visualize uma série temporal simples usando um gráfico de linha.",
                                    "Discuta como o tempo é a variável independente chave."
                                  ],
                                  "verification": "Crie um gráfico de linha de uma série temporal de exemplo e descreva o que observa.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis ou software como Excel/Python",
                                    "Dados de exemplo de vendas mensais"
                                  ],
                                  "tips": "Sempre comece plotando os dados para ganhar intuição visual antes de análises complexas.",
                                  "learningObjective": "Entender o que constitui uma série temporal e sua representação visual básica.",
                                  "commonMistakes": [
                                    "Confundir séries temporais com dados cruzados sem ordem temporal.",
                                    "Ignorar a frequência dos intervalos de tempo."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar os Componentes de Decomposição de Séries Temporais",
                                  "subSteps": [
                                    "Liste os principais componentes: tendência, sazonalidade, cíclico e irregular (resíduo).",
                                    "Descreva a tendência como a direção de longo prazo (crescente, decrescente ou estável).",
                                    "Explique o componente cíclico como flutuações de longo prazo não fixas.",
                                    "Defina o resíduo como variações aleatórias não explicadas pelos outros componentes.",
                                    "Discuta modelos aditivos vs. multiplicativos para decomposição."
                                  ],
                                  "verification": "Decomponha verbalmente uma série temporal hipotética em seus componentes principais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráficos de decomposição de exemplo",
                                    "Ferramenta como R ou Python (statsmodels)"
                                  ],
                                  "tips": "Use modelos aditivos para séries com variações constantes e multiplicativos para proporções variáveis.",
                                  "learningObjective": "Identificar e diferenciar os quatro componentes principais de uma série temporal.",
                                  "commonMistakes": [
                                    "Confundir sazonalidade com tendência.",
                                    "Omitir o componente resíduo na decomposição."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Sazonalidade com Precisão",
                                  "subSteps": [
                                    "Defina sazonalidade como flutuações regulares e previsíveis que se repetem em intervalos fixos (ex.: mensal, trimestral).",
                                    "Explique que a sazonalidade é independente da tendência de longo prazo.",
                                    "Descreva o período sazonal (ex.: 12 para dados mensais anuais).",
                                    "Diferencie sazonalidade de ciclos (fixo vs. variável em duração).",
                                    "Forneça a fórmula conceitual: Y_t = Tendência + Sazonalidade + Ciclo + Resíduo."
                                  ],
                                  "verification": "Escreva uma definição de sazonalidade em suas próprias palavras e cite um intervalo fixo de exemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de aula ou vídeo explicativo sobre decomposição STL",
                                    "Quadro branco para equações"
                                  ],
                                  "tips": "Lembre-se: sazonalidade volta ao mesmo padrão todo período, como estações do ano.",
                                  "learningObjective": "Formular uma definição precisa de sazonalidade e seu papel na decomposição.",
                                  "commonMistakes": [
                                    "Assumir que sazonalidade afeta a tendência.",
                                    "Confundir período sazonal com frequência de dados."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar Sazonalidade em Dados Reais",
                                  "subSteps": [
                                    "Plote múltiplos ciclos de uma série temporal para observar repetições.",
                                    "Use médias móveis sazonais para suavizar e destacar padrões.",
                                    "Aplique testes como o de Dickey-Fuller ajustado para sazonalidade.",
                                    "Crie variáveis dummy sazonais para modelagem (ex.: mês do ano).",
                                    "Compare com série dessazonalizada para validar remoção do efeito."
                                  ],
                                  "verification": "Analise um gráfico de dados mensais e aponte o padrão sazonal com evidências visuais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Dataset real como vendas de varejo (Kaggle)",
                                    "Software: Excel, Python (pandas, matplotlib)"
                                  ],
                                  "tips": "Sobreponha anos em um gráfico para visualizar repetições sazonais claramente.",
                                  "learningObjective": "Reconhecer sazonalidade visual e quantitativamente em séries temporais reais.",
                                  "commonMistakes": [
                                    "Interpretar ruído como sazonalidade.",
                                    "Não verificar múltiplos períodos para confirmação."
                                  ]
                                }
                              ],
                              "practicalExample": "Em dados de vendas de roupas de inverno, observa-se um pico consistente em dezembro-janeiro todos os anos, repetindo-se anualmente independentemente do crescimento geral das vendas da loja.",
                              "finalVerifications": [
                                "Explique sazonalidade em suas próprias palavras sem erros conceituais.",
                                "Diferencie sazonalidade de tendência com um exemplo.",
                                "Identifique o período sazonal em um gráfico fornecido.",
                                "Descreva como remover sazonalidade de uma série.",
                                "Forneça dois exemplos reais de sazonalidade de domínios diferentes.",
                                "Confirme independência da tendência via decomposição verbal."
                              ],
                              "assessmentCriteria": [
                                "Precisão da definição de sazonalidade (clareza e completude).",
                                "Capacidade de diferenciar componentes corretamente.",
                                "Uso correto de termos como 'período fixo' e 'previsível'.",
                                "Qualidade de exemplos práticos e relevância.",
                                "Demonstração de identificação visual em gráficos.",
                                "Compreensão de independência em relação à tendência."
                              ],
                              "crossCurricularConnections": [
                                "Economia: Análise de ciclos sazonais no PIB trimestral.",
                                "Meteorologia: Padrões sazonais de precipitação e temperatura.",
                                "Finanças: Efeito janeiro em retornos de ações.",
                                "Biologia: Ciclos sazonais em populações de migração animal.",
                                "Marketing: Vendas sazonais em e-commerce por feriados."
                              ],
                              "realWorldApplication": "Em empresas de varejo, definir sazonalidade permite ajustar estoques para picos de Natal, otimizando custos e evitando rupturas, melhorando previsões de demanda com modelos como ARIMA sazonal."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.1.2",
                            "name": "Diferenciar sazonalidade de outros componentes",
                            "description": "Distinguir sazonalidade de tendência (mudança gradual de longo prazo), ciclo (flutuações irregulares) e ruído aleatório em séries temporais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Componentes Básicos de Séries Temporais",
                                  "subSteps": [
                                    "Estude a definição de série temporal como uma sequência de observações coletadas em intervalos regulares de tempo.",
                                    "Aprenda sobre tendência: componente de mudança gradual e consistente ao longo de um período longo.",
                                    "Defina sazonalidade: padrão repetitivo e previsível que ocorre em intervalos fixos, como mensal ou anual.",
                                    "Entenda ciclos: flutuações de longo prazo, mas irregulares em timing e amplitude, como ciclos econômicos.",
                                    "Identifique ruído (ou irregular): variações aleatórias e imprevisíveis sem padrão discernível."
                                  ],
                                  "verification": "Escreva um resumo de 1-2 frases para cada componente em suas próprias palavras e compartilhe com um colega para validação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Slides ou capítulo de livro sobre componentes de séries temporais (ex: 'Forecasting: Principles and Practice' de Hyndman)",
                                    "Vídeo introdutório no Khan Academy ou YouTube sobre decomposição de séries temporais"
                                  ],
                                  "tips": "Use analogias cotidianas: tendência como envelhecimento populacional, sazonalidade como estações do ano, ciclos como booms econômicos e ruído como erro de medição.",
                                  "learningObjective": "Dominar as definições conceituais e diferenças qualitativas entre os quatro componentes principais de uma série temporal.",
                                  "commonMistakes": [
                                    "Confundir sazonalidade com ciclos, ignorando a regularidade fixa da sazonalidade.",
                                    "Achar que ruído tem algum padrão sutil quando é puramente aleatório."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Reconhecer Padrões Visuais em Gráficos de Séries Temporais",
                                  "subSteps": [
                                    "Colete 5-10 gráficos de séries temporais de fontes confiáveis, cada um destacando um componente dominante.",
                                    "Analise gráficos com tendência forte: procure linhas suaves subindo ou descendo consistentemente.",
                                    "Identifique sazonalidade: observe picos e vales repetindo no mesmo período (ex: todo mês de dezembro).",
                                    "Diferencie ciclos: note oscilações mais longas e variáveis em amplitude/timing.",
                                    "Marque ruído: destaque variações pequenas e erráticas sem repetição.",
                                    "Compare gráficos misturados, rotulando cada componente visível."
                                  ],
                                  "verification": "Rotule corretamente os componentes principais em 3 gráficos fornecidos ou desenhados, justificando cada escolha.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Gráficos de exemplo online (ex: tutoriais de statsmodels ou sites como Towards Data Science)",
                                    "Ferramenta de desenho como Draw.io ou papel e caneta para anotações"
                                  ],
                                  "tips": "Suavize visualmente a série (imagine uma média móvel) para isolar tendência; amplie para ver repetições sazonais.",
                                  "learningObjective": "Desenvolver intuição visual para identificar e diferenciar componentes por meio de inspeção gráfica.",
                                  "commonMistakes": [
                                    "Interpretar ruído aleatório como sazonalidade fraca devido a coincidências.",
                                    "Confundir tendência de curto prazo com um ciclo."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Técnicas de Decomposição Quantitativa",
                                  "subSteps": [
                                    "Revise o modelo aditivo clássico: Y_t = T_t + S_t + C_t + I_t (Tendência + Sazonal + Ciclo + Irregular).",
                                    "Calcule tendência usando médias móveis simples (ex: janela de 12 meses para dados mensais).",
                                    "Estime sazonalidade subtraindo tendência e calculando médias por período sazonal.",
                                    "Identifique ciclos e ruído nos resíduos restantes após remover tendência e sazonalidade.",
                                    "Pratique decomposição em software: use funções prontas como decompose() no R ou seasonal_decompose() no Python."
                                  ],
                                  "verification": "Decomponha uma série temporal de exemplo (ex: AirPassengers) e produza os 4 gráficos de componentes isolados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com bibliotecas pandas e statsmodels, ou R com forecast package",
                                    "Dataset clássico: AirPassengers (disponível em bibliotecas ou Kaggle)"
                                  ],
                                  "tips": "Sempre centre os fatores sazonais para somar zero; comece com modelo aditivo e verifique resíduos para multiplicatividade.",
                                  "learningObjective": "Executar decomposição quantitativa para separar e validar componentes de uma série temporal.",
                                  "commonMistakes": [
                                    "Não remover tendência antes de estimar sazonalidade, distorcendo os fatores.",
                                    "Assumir ausência de ciclo quando resíduos mostram padrões longos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Diferenciação em Datasets Reais e Sintéticos",
                                  "subSteps": [
                                    "Baixe ou crie um dataset real sazonal (ex: vendas de varejo mensal).",
                                    "Plote a série original e decomponha, identificando cada componente.",
                                    "Gere uma série sintética misturando componentes controlados e pratique isolamento.",
                                    "Compare com um dataset sem sazonalidade forte (ex: retornos diários de ações).",
                                    "Escreva um relatório curto explicando por que certos padrões são sazonalidade vs. outros componentes."
                                  ],
                                  "verification": "Submeta decomposições de 2 datasets com explicações corretas de diferenciação (acertos >90%).",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Datasets do Kaggle (ex: 'Retail Sales', 'Monthly Temperatures')",
                                    "Jupyter Notebook ou Google Colab para análise interativa"
                                  ],
                                  "tips": "Verifique ACF (função de autocorrelação) para confirmar periodicidade sazonal; use domínio dos dados para validar.",
                                  "learningObjective": "Aplicar integralmente o conhecimento para diferenciar componentes em contextos reais variados.",
                                  "commonMistakes": [
                                    "Sobreinterpretar ruído como ciclo fraco sem evidência estatística.",
                                    "Ignorar não-estacionaridade, confundindo tendência com outros componentes."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere vendas mensais de sorvetes de 2010-2020: tendência crescente devido a expansão de mercado; sazonalidade com picos todo verão (julho-agosto); ciclo de 5 anos ligado a recessões econômicas; ruído de variações semanais agregadas ou promoções isoladas. Decomponha para isolar e confirmar cada um.",
                              "finalVerifications": [
                                "Explica com precisão as diferenças qualitativas entre sazonalidade (regular, curta), tendência (gradual), ciclo (irregular, longa) e ruído (aleatório).",
                                "Identifica corretamente componentes em gráficos não vistos anteriormente.",
                                "Realiza decomposição aditiva básica sem erros conceituais.",
                                "Distingue sazonalidade de ciclo avaliando regularidade e período.",
                                "Reconhece quando ruído domina e não força padrões inexistentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições 100% corretas em quiz.",
                                "Habilidade visual: >90% acerto em rotulagem de 10 gráficos.",
                                "Qualidade de decomposição: resíduos plausíveis (sem autocorrelação forte).",
                                "Clareza explicativa: usa terminologia precisa em relatórios.",
                                "Aplicação contextual: relaciona corretamente a pelo menos 2 cenários reais."
                              ],
                              "crossCurricularConnections": [
                                "Economia/Business: previsão de demanda sazonal em varejo e planejamento de estoques.",
                                "Meteorologia/Ambiental: modelagem de temperaturas e precipitação com ciclos climáticos.",
                                "Finanças: análise de séries de preços de ações (tendência vs. ruído de mercado).",
                                "Biologia/Ecologia: populações de espécies com sazonalidade reprodutiva.",
                                "Engenharia: demanda de energia elétrica com picos diários/semanais."
                              ],
                              "realWorldApplication": "Em análise de vendas para e-commerce, diferenciar sazonalidade (Natal) de tendência (crescimento orgânico) e ruído (eventos únicos) permite previsões precisas, otimizando estoques e reduzindo custos em até 20%."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.1.3",
                            "name": "Exemplificar séries sazonais reais",
                            "description": "Identificar e citar exemplos práticos de séries sazonais, como vendas de varejo no Natal ou consumo de energia no verão/inverno.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o conceito de sazonalidade em séries temporais",
                                  "subSteps": [
                                    "Ler a definição de séries temporais sazonais e componentes (tendência, ciclo, sazonalidade, irregular).",
                                    "Identificar características da sazonalidade: padrões repetitivos em intervalos fixos (mensal, trimestral, anual).",
                                    "Estudar fórmulas básicas de decomposição de séries temporais.",
                                    "Visualizar gráficos de exemplo com sazonalidade destacada.",
                                    "Anotar diferenças entre sazonalidade e tendência."
                                  ],
                                  "verification": "Criar um resumo de 5 pontos chave sobre sazonalidade e compará-lo com uma referência padrão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Material didático sobre séries temporais, gráficos de exemplo (Excel ou Python).",
                                  "tips": "Use cores diferentes nos gráficos para destacar a sazonalidade.",
                                  "learningObjective": "Compreender os fundamentos teóricos da sazonalidade para identificar em dados reais.",
                                  "commonMistakes": "Confundir sazonalidade com tendência de longo prazo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar exemplos clássicos de séries sazonais",
                                  "subSteps": [
                                    "Examinar dados de vendas de varejo no Natal: plotar série temporal e observar picos em dezembro.",
                                    "Analisar consumo de energia: identificar aumentos no verão (ar-condicionado) e inverno (aquecimento).",
                                    "Estudar turismo: picos em férias escolares e feriados.",
                                    "Decompor uma série usando método multiplicativo ou aditivo em software.",
                                    "Calcular médias sazonais para cada período."
                                  ],
                                  "verification": "Produzir um gráfico anotado de pelo menos dois exemplos com sazonalidade marcada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Datasets públicos (ex: Kaggle - vendas varejo, consumo energia), Excel ou Google Sheets.",
                                  "tips": "Escolha séries com pelo menos 3 anos de dados para ver repetição.",
                                  "learningObjective": "Reconhecer padrões sazonais em dados conhecidos.",
                                  "commonMistakes": "Ignorar o efeito de eventos não sazonais como pandemias."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Pesquisar e coletar exemplos reais adicionais",
                                  "subSteps": [
                                    "Buscar datasets online de séries sazonais (agricultura, vendas online, tráfego aéreo).",
                                    "Selecionar 3 exemplos de setores diferentes (varejo, energia, saúde).",
                                    "Plotar e analisar os dados para confirmar periodicidade sazonal.",
                                    "Documentar fontes e razões da sazonalidade (fatores climáticos, culturais).",
                                    "Comparar com exemplos clássicos."
                                  ],
                                  "verification": "Compilar uma tabela com 3 exemplos, incluindo gráfico, período sazonal e causa.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Internet (Kaggle, IBGE, World Bank), ferramentas de visualização (Tableau Public, Python Matplotlib).",
                                  "tips": "Use palavras-chave como 'seasonal time series datasets' na busca.",
                                  "learningObjective": "Desenvolver habilidade de pesquisa autônoma de exemplos práticos.",
                                  "commonMistakes": "Escolher séries sem dados suficientes para provar repetição."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Exemplificar e explicar séries sazonais em contexto",
                                  "subSteps": [
                                    "Escolher um exemplo pessoal ou local (ex: vendas de roupas de inverno na sua região).",
                                    "Criar uma apresentação curta explicando a sazonalidade detectada.",
                                    "Relacionar com impactos econômicos ou previsões.",
                                    "Simular remoção da sazonalidade e comparar.",
                                    "Preparar citações para uso em relatórios."
                                  ],
                                  "verification": "Elaborar um parágrafo exemplificando uma série com dados e interpretação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Ferramentas de edição (Google Slides, Word), datasets pessoais.",
                                  "tips": "Inclua 'por quê' da sazonalidade para enriquecer a explicação.",
                                  "learningObjective": "Aplicar o conhecimento para citar exemplos de forma clara e contextualizada.",
                                  "commonMistakes": "Dar exemplos vagos sem dados ou gráficos de suporte."
                                }
                              ],
                              "practicalExample": "Analisar as vendas de sorvetes em uma rede de lojas: os dados mensais mostram picos consistentes de dezembro a fevereiro no hemisfério sul devido ao verão, com queda acentuada nos meses frios, confirmando sazonalidade anual ligada ao clima.",
                              "finalVerifications": [
                                "Citar corretamente 3 exemplos reais de séries sazonais com causas específicas.",
                                "Plotar e interpretar gráficos de pelo menos 2 séries com sazonalidade destacada.",
                                "Explicar decomposição sazonal em um exemplo prático.",
                                "Diferenciar sazonalidade de outros componentes em uma série dada.",
                                "Pesquisar e validar um novo exemplo independente.",
                                "Relacionar exemplo a impacto real (ex: planejamento de estoque)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de padrões sazonais (repetição e periodicidade).",
                                "Uso de dados reais e fontes confiáveis.",
                                "Qualidade dos gráficos e visualizações (clareza, anotações).",
                                "Explicação contextual das causas sazonais (climáticas, culturais, econômicas).",
                                "Capacidade de generalizar para novos exemplos.",
                                "Ausência de confusão com tendência ou ruído."
                              ],
                              "crossCurricularConnections": [
                                "Economia: Previsão de demanda sazonal em negócios.",
                                "Geografia: Influência climática regional na sazonalidade.",
                                "Biologia: Ciclos sazonais em populações animais ou agricultura.",
                                "Marketing: Campanhas sazonais baseadas em séries temporais."
                              ],
                              "realWorldApplication": "Em empresas de varejo, exemplificar séries sazonais de vendas natalinas permite otimizar estoques e previsões, reduzindo custos e aumentando lucros; em utilities, prever picos de energia no verão evita blecautes."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.1.2",
                        "name": "Características das Séries Temporais Sazonais",
                        "description": "Análise das propriedades fundamentais que definem o comportamento sazonal em dados temporais.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.2.1",
                            "name": "Identificar periodicidade sazonal",
                            "description": "Reconhecer a periodicidade fixa da sazonalidade, como 12 períodos para dados mensais ou 4 para trimestrais, e sua repetição consistente ao longo do tempo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de periodicidade sazonal",
                                  "subSteps": [
                                    "Defina sazonalidade como padrões repetitivos em intervalos fixos.",
                                    "Explique que periodicidade é o número de períodos em um ciclo completo (ex: 12 para mensal).",
                                    "Diferencie sazonalidade de tendências ou ciclos irregulares.",
                                    "Estude exemplos: 4 para trimestral, 12 para mensal, 52 para semanal.",
                                    "Anote a importância da repetição consistente ao longo do tempo."
                                  ],
                                  "verification": "Resuma o conceito em suas próprias palavras e liste 3 exemplos de periodicidades comuns.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro-texto de séries temporais",
                                    "Vídeo tutorial sobre sazonalidade (ex: Khan Academy)"
                                  ],
                                  "tips": "Use analogias como estações do ano para fixar o conceito.",
                                  "learningObjective": "Entender a definição e exemplos de periodicidade sazonal.",
                                  "commonMistakes": [
                                    "Confundir com tendência linear",
                                    "Ignorar a repetição fixa"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Determinar o intervalo temporal dos dados",
                                  "subSteps": [
                                    "Examine os rótulos dos dados (mensal, trimestral, etc.).",
                                    "Conte o número de observações por ano para inferir periodicidade.",
                                    "Verifique se os dados cobrem múltiplos anos para observar repetição.",
                                    "Registre o intervalo: diário (365), semanal (52), mensal (12), trimestral (4).",
                                    "Confirme consistência no espaçamento temporal."
                                  ],
                                  "verification": "Identifique e documente o intervalo temporal de um conjunto de dados fornecido.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Conjunto de dados de exemplo (ex: vendas mensais CSV)",
                                    "Planilha Excel ou Google Sheets"
                                  ],
                                  "tips": "Sempre verifique o eixo temporal primeiro para evitar suposições erradas.",
                                  "learningObjective": "Classificar corretamente o intervalo de tempo de uma série temporal.",
                                  "commonMistakes": [
                                    "Assumir mensal sem verificar rótulos",
                                    "Contar observações sem considerar anos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Visualizar padrões repetitivos na série temporal",
                                  "subSteps": [
                                    "Plote a série temporal como gráfico de linha.",
                                    "Procure picos e vales que se repetem em intervalos fixos.",
                                    "Sobreponha múltiplos ciclos para destacar repetição.",
                                    "Use zoom em um ciclo para medir a periodicidade.",
                                    "Anote posições de padrões sazonais (ex: pico no mês 12)."
                                  ],
                                  "verification": "Crie um gráfico mostrando padrões repetitivos e marque um ciclo completo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de plotagem (Python Matplotlib, R ggplot, Excel)",
                                    "Dados sazonais de exemplo"
                                  ],
                                  "tips": "Aumente a transparência das linhas para sobrepor ciclos facilmente.",
                                  "learningObjective": "Detectar visualmente a repetição sazonal em gráficos.",
                                  "commonMistakes": [
                                    "Ignorar escala do eixo x",
                                    "Confundir ruído com sazonalidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Confirmar e quantificar a periodicidade sazonal",
                                  "subSteps": [
                                    "Conte o número de períodos entre picos idênticos repetidos.",
                                    "Calcule a média de distâncias entre padrões sazonais.",
                                    "Teste se o padrão se repete consistentemente em 3+ ciclos.",
                                    "Compare com intervalos conhecidos (12 mensal, 4 trimestral).",
                                    "Documente evidências numéricas e visuais da periodicidade."
                                  ],
                                  "verification": "Escreva um relatório curto confirmando a periodicidade com contagem e gráfico.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramentas de análise (Python Pandas, Excel)",
                                    "Gráficos gerados no step 3"
                                  ],
                                  "tips": "Use autocorrelação básica se disponível para suporte visual.",
                                  "learningObjective": "Quantificar com precisão a periodicidade sazonal.",
                                  "commonMistakes": [
                                    "Contar ciclos incompletos",
                                    "Não verificar múltiplos anos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em dados mensais de vendas de sorvetes, observe picos todo verão (julho/agosto) repetindo a cada 12 meses por 5 anos, confirmando periodicidade de 12.",
                              "finalVerifications": [
                                "Identifica corretamente periodicidade de 12 em dados mensais.",
                                "Detecta 4 períodos em dados trimestrais com repetição consistente.",
                                "Apresenta gráfico com ciclos marcados.",
                                "Explica por que o padrão é sazonal e não aleatório.",
                                "Conta ciclos em pelo menos 3 anos de dados.",
                                "Diferencia de outros componentes como tendência."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação do número de períodos (100% correto).",
                                "Uso de evidências visuais e numéricas claras.",
                                "Explicação coerente da repetição consistente.",
                                "Ausência de confusão com outros padrões temporais.",
                                "Documentação completa com gráficos e contagens.",
                                "Aplicação correta a diferentes intervalos temporais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de funções periódicas e trigonometria.",
                                "Economia: Sazonalidade em vendas e PIB trimestral.",
                                "Geografia: Ciclos climáticos e estações do ano.",
                                "Biologia: Ciclos sazonais em populações animais.",
                                "Física: Ondas e periodicidade em sinais."
                              ],
                              "realWorldApplication": "Em previsão de demanda para varejistas, identificar periodicidade mensal de 12 permite ajustar estoques para picos sazonais como Black Friday, otimizando custos e vendas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.6.1.2.2",
                            "name": "Descrever impacto da sazonalidade na estacionariedade",
                            "description": "Explicar como a sazonalidade introduz não-estacionariedade em séries temporais, afetando médias e variâncias em diferentes períodos sazonais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Estacionariedade e Sazonalidade",
                                  "subSteps": [
                                    "Defina estacionariedade: média, variância e covariância constantes ao longo do tempo.",
                                    "Explique sazonalidade como padrões repetitivos em intervalos fixos (ex: mensal, anual).",
                                    "Identifique componentes de séries temporais: tendência, sazonalidade, ciclo e irregular.",
                                    "Discuta por que estacionariedade é crucial para modelagem (ex: ARIMA requer estacionariedade).",
                                    "Examine gráficos de séries temporais estacionárias vs. não-estacionárias."
                                  ],
                                  "verification": "Crie um diagrama comparativo de série estacionária e sazonal, rotulando propriedades violadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Gráficos de séries temporais exemplo (ex: dados de temperatura mensal), software como Python (matplotlib) ou Excel.",
                                  "tips": "Use analogias como 'equilíbrio' para estacionariedade e 'estações do ano' para sazonalidade.",
                                  "learningObjective": "Compreender definições precisas e relação inicial entre sazonalidade e estacionariedade.",
                                  "commonMistakes": "Confundir sazonalidade com tendência; assumir que toda variação é não-estacionariedade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Impacto da Sazonalidade na Média Condicional",
                                  "subSteps": [
                                    "Calcule médias móveis por período sazonal (ex: média de vendas por mês).",
                                    "Plote médias sazonais e observe variações sistemáticas (ex: médias mais altas no verão).",
                                    "Explique violação da estacionariedade: E[X_t] ≠ E[X_{t+s}] para lag sazonal.",
                                    "Compare com série sem sazonalidade usando testes como Augmented Dickey-Fuller (pré e pós-ajuste).",
                                    "Documente como isso impede suposições de processos estacionários."
                                  ],
                                  "verification": "Gere um gráfico de médias sazonais mostrando variação > 10% entre períodos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Dados sazonais reais (ex: dataset AirPassengers em R/Python), calculadora ou Jupyter Notebook.",
                                  "tips": "Desagregue dados por fator sazonal primeiro para isolar efeito na média.",
                                  "learningObjective": "Identificar e quantificar como sazonalidade torna a média não-constante.",
                                  "commonMistakes": "Ignorar diferenças estatisticamente significativas; tratar flutuações aleatórias como sazonais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Investigar Impacto da Sazonalidade na Variância Condicional",
                                  "subSteps": [
                                    "Calcule variâncias por período sazonal (ex: std dev de vendas por mês).",
                                    "Plote variâncias sazonais e detecte heteroscedasticidade (ex: maior variação no inverno).",
                                    "Explique violação: Var(X_t) ≠ Var(X_{t+s}), introduzindo não-estacionariedade condicional.",
                                    "Aplique testes de variância (ex: Levene's test) entre períodos sazonais.",
                                    "Discuta implicações para modelos: necessidade de transformações log ou diferenciação sazonal."
                                  ],
                                  "verification": "Produza tabela de variâncias sazonais com teste estatístico rejeitando homoscedasticidade (p<0.05).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Mesmo dataset do step 2, bibliotecas statsmodels ou scipy em Python.",
                                  "tips": "Log-transforme dados se variâncias aumentarem com a média (efeito multiplicativo).",
                                  "learningObjective": "Demonstrar como sazonalidade causa variância não-constante ao longo do tempo.",
                                  "commonMistakes": "Focar só em média e ignorar variância; confundir com autocorrelação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar Impacto Geral e Estratégias de Correção",
                                  "subSteps": [
                                    "Resuma impactos: sazonalidade viola média e variância constantes, induzindo dependência serial.",
                                    "Descreva detecção integrada: decomposição STL, ACF/PACF com lags sazonais.",
                                    "Explique correções: diferenciação sazonal, ajuste SARIMA, remoção sazonal.",
                                    "Aplique em exemplo: torne série sazonal estacionária e valide com testes.",
                                    "Reflita sobre consequências em previsões sem correção (viés, ineficiência)."
                                  ],
                                  "verification": "Escreva parágrafo explicando impacto em 100 palavras, com gráfico antes/depois da correção.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software de séries temporais (R: forecast, Python: statsmodels), exemplos de código.",
                                  "tips": "Sempre valide estacionariedade pós-ajuste com múltiplos testes (KPSS + ADF).",
                                  "learningObjective": "Integrar conhecimentos para descrever impacto completo e soluções.",
                                  "commonMistakes": "Subestimar necessidade de correção; achar que tendência sozinha causa não-estacionariedade."
                                }
                              ],
                              "practicalExample": "Em dados de vendas de sorvetes mensais: médias sobem no verão (Julho: 500un vs. Janeiro: 100un), variâncias maiores no verão devido a picos imprevisíveis de calor. Sem ajuste, modelo ARIMA falha; após diferenciação sazonal (lag 12), torna-se estacionária.",
                              "finalVerifications": [
                                "Explicar verbalmente como sazonalidade viola E[X_t | s] constante.",
                                "Identificar padrões sazonais em gráfico fornecido em <1min.",
                                "Calcular corretamente médias/variâncias sazonais em dataset simples.",
                                "Propor ajuste sazonal apropriado para dado exemplo.",
                                "Passar teste ADF pré/pós-ajuste mostrando melhora na estacionariedade.",
                                "Discutir implicações em previsão sem correção."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas de estacionariedade/sazonalidade (30%).",
                                "Análise quantitativa: cálculos e testes estatísticos precisos (25%).",
                                "Visualizações claras: gráficos rotulados mostrando violações (20%).",
                                "Explicação integrada: ligação clara entre média, variância e modelagem (15%).",
                                "Soluções práticas: sugestões de correção viáveis (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Economia: Ciclos sazonais em vendas/retail afetam PIB trimestral.",
                                "Meteorologia: Temperatura sazonal impacta consumo de energia.",
                                "Biologia: Populações animais com padrões reprodutivos sazonais.",
                                "Finanças: Retornos de ações com volatilidade sazonal (ex: 'January effect')."
                              ],
                              "realWorldApplication": "Em previsão de demanda para varejo (ex: Amazon ajusta estoque para Black Friday sazonal), bancos centrais modelam inflação sazonal para políticas monetárias, ou empresas de energia preveem picos de consumo no verão/inverno após remover sazonalidade para tendências de longo prazo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.6.1.2.3",
                            "name": "Analisar amplitude e fase sazonal",
                            "description": "Descrever a amplitude (intensidade das flutuações sazonais) e a fase (deslocamento temporal dos picos e vales) em séries sazonais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de amplitude e fase sazonal",
                                  "subSteps": [
                                    "Ler a definição de amplitude como a intensidade das flutuações sazonais (metade da diferença entre pico e vale).",
                                    "Estudar fase como o deslocamento temporal dos picos e vales em relação a um ciclo de referência (ex: ano calendário).",
                                    "Analisar diagramas de ondas senoidais para visualizar amplitude e fase.",
                                    "Comparar com exemplos não sazonais para diferenciar.",
                                    "Anotar diferenças entre amplitude e variância total da série."
                                  ],
                                  "verification": "Explicar em 2-3 frases o que são amplitude e fase, com um desenho simples de uma onda.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro ou PDF sobre séries temporais",
                                    "Vídeo tutorial no YouTube sobre sazonalidade",
                                    "Papel e caneta para esboços"
                                  ],
                                  "tips": "Use analogias com marés ou estações do ano para fixar os conceitos.",
                                  "learningObjective": "Dominar as definições teóricas de amplitude e fase em contextos sazonais.",
                                  "commonMistakes": "Confundir amplitude com a amplitude total (pico-vale) em vez de meia-amplitude; ignorar que fase é relativa a um referencial."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar e visualizar a série temporal sazonal",
                                  "subSteps": [
                                    "Carregar os dados da série temporal em software de análise.",
                                    "Plotar o gráfico temporal para identificar padrões repetitivos.",
                                    "Aplicar decomposição sazonal básica (se disponível) ou suavização móvel para destacar componente sazonal.",
                                    "Marcar visualmente picos e vales em pelo menos 3 ciclos sazonais.",
                                    "Ajustar escalas do gráfico para melhor visualização das flutuações."
                                  ],
                                  "verification": "Gerar um gráfico com picos e vales anotados, confirmando periodicidade sazonal.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Python com pandas e matplotlib ou R",
                                    "Dataset de exemplo (ex: temperaturas mensais)",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Escolha datasets reais como AirPassengers ou temperaturas para prática autêntica.",
                                  "learningObjective": "Visualizar e isolar o componente sazonal da série temporal.",
                                  "commonMistakes": "Não remover tendência antes, o que mascara a sazonalidade; usar escalas inadequadas que distorcem flutuações."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a amplitude sazonal",
                                  "subSteps": [
                                    "Identificar valores médios de picos e vales ao longo de múltiplos ciclos.",
                                    "Calcular amplitude como (média_picos - média_vales)/2.",
                                    "Verificar consistência calculando para diferentes ciclos.",
                                    "Expressar amplitude em unidades da série (ex: graus Celsius).",
                                    "Plotar a amplitude ao longo do tempo para detectar variações."
                                  ],
                                  "verification": "Obter um valor numérico de amplitude com fórmula e cálculos mostrados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Excel ou código Python/R para cálculos",
                                    "Gráficos do passo anterior"
                                  ],
                                  "tips": "Use funções como seasonal_decompose no statsmodels para automação inicial.",
                                  "learningObjective": "Quantificar matematicamente a intensidade das flutuações sazonais.",
                                  "commonMistakes": "Usar apenas um ciclo (instável); confundir com desvio padrão da série inteira."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Determinar a fase sazonal",
                                  "subSteps": [
                                    "Definir referencial temporal (ex: mês 1 = janeiro).",
                                    "Medir o deslocamento do pico médio em relação ao referencial (em fração de ciclo ou meses).",
                                    "Calcular fase para vales também e comparar.",
                                    "Ajustar por lag se necessário, usando correlação com senoide de referência.",
                                    "Descrever qualitativamente (ex: 'pico adiantado 1 mês')."
                                  ],
                                  "verification": "Reportar fase como 'pico em julho (deslocamento +2 meses de junho esperado)' com evidências.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Código para ajuste de fase (ex: scipy.optimize)",
                                    "Gráficos anotados"
                                  ],
                                  "tips": "Represente fase em graus (0-360) para ciclos anuais: 0° = início do ciclo.",
                                  "learningObjective": "Quantificar e interpretar o timing das flutuações sazonais.",
                                  "commonMistakes": "Não especificar referencial, levando a ambiguidades; ignorar variações entre ciclos."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar e descrever amplitude e fase",
                                  "subSteps": [
                                    "Redigir descrição completa: 'Amplitude de X unidades, fase com pico em Mês Y'.",
                                    "Discutir implicações (ex: flutuações fortes indicam sazonalidade dominante).",
                                    "Comparar com séries semelhantes.",
                                    "Prever próximo ciclo baseado na fase.",
                                    "Documentar relatório com gráficos e cálculos."
                                  ],
                                  "verification": "Produzir um parágrafo descritivo com valores exatos e interpretação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Relatório template em Word ou Markdown",
                                    "Resultados dos passos anteriores"
                                  ],
                                  "tips": "Inclua frases como 'Isso sugere...' para mostrar insight.",
                                  "learningObjective": "Sintetizar análise em descrição acionável e interpretativa.",
                                  "commonMistakes": "Descrever só números sem contexto; omitir unidades ou referencial."
                                }
                              ],
                              "practicalExample": "Em dados de vendas mensais de sorvetes (jan:100, fev:150, ..., jul:500, ago:450, ..., dez:120), a amplitude é (500-100)/2 = 200 unidades, indicando forte flutuação sazonal. A fase mostra pico em julho (deslocamento +1 mês do verão esperado), confirmando influência climática.",
                              "finalVerifications": [
                                "Amplitude calculada corretamente com fórmula e múltiplos ciclos.",
                                "Fase quantificada com referencial claro e evidência gráfica.",
                                "Descrição escrita cobre intensidade, timing e implicações.",
                                "Gráficos mostram picos/vales anotados e componente sazonal.",
                                "Cálculos reproduzíveis em código ou planilha.",
                                "Interpretação liga análise a contexto da série."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de amplitude e fase (90%+ correção).",
                                "Clareza visual nos gráficos e anotações.",
                                "Profundidade da descrição e interpretação.",
                                "Uso adequado de múltiplos ciclos para robustez.",
                                "Identificação correta de erros comuns evitados.",
                                "Relatório completo e bem estruturado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelos trigonométricos (senóide para sazonalidade).",
                                "Geografia: Padrões climáticos e ciclos ambientais.",
                                "Economia: Análise de ciclos sazonais em vendas e demandas.",
                                "Física: Ondas e oscilações harmônicas."
                              ],
                              "realWorldApplication": "Em meteorologia para modelar variações de temperatura e precipitação; no varejo para prever picos de vendas sazonais e otimizar estoque; em energia para planejar demanda elétrica no verão/inverno."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.1.3",
                        "name": "Métodos para Identificação de Sazonalidade",
                        "description": "Técnicas práticas para detectar e confirmar a presença de padrões sazonais repetitivos em séries temporais.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.3.1",
                            "name": "Usar gráficos para detectar sazonalidade",
                            "description": "Construir e interpretar gráficos de séries temporais, gráficos sazonais (seasonal plots) e boxplots por período sazonal para visualizar padrões repetitivos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o Conjunto de Dados para Análise Sazonal",
                                  "subSteps": [
                                    "Obtenha um dataset de série temporal com pelo menos 3-5 anos de dados, como vendas mensais ou passageiros aéreos.",
                                    "Carregue os dados em uma ferramenta de análise (Python com pandas ou R).",
                                    "Converta a coluna de data para formato datetime e defina como índice.",
                                    "Identifique e crie uma coluna para o período sazonal (ex: mês = df['date'].dt.month).",
                                    "Limpe os dados: remova ou interpule valores ausentes e verifique duplicatas."
                                  ],
                                  "verification": "Dataset carregado com colunas 'date', 'value' e 'seasonal_period' sem erros ou missing values.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Dataset CSV exemplo (ex: air_passengers.csv)",
                                    "Python (pandas, matplotlib)",
                                    "Jupyter Notebook ou RStudio"
                                  ],
                                  "tips": "Use freq='M' para dados mensais ao definir o índice para facilitar agrupamentos sazonais.",
                                  "learningObjective": "Dominar a preparação de dados temporais para detecção de padrões sazonais.",
                                  "commonMistakes": [
                                    "Não converter datas corretamente levando a erros de indexação.",
                                    "Ignorar valores ausentes que distorcem visualizações.",
                                    "Confundir período sazonal (ex: usar dia em vez de mês)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir Gráfico de Série Temporal Completo",
                                  "subSteps": [
                                    "Plote a série temporal completa com eixo x como tempo e y como valores.",
                                    "Adicione linhas de tendência ou médias móveis para destacar oscilações.",
                                    "Rotule eixos claramente (ex: 'Data' e 'Vendas') e adicione título 'Série Temporal de Vendas'.",
                                    "Ajuste escalas e grid para melhor visualização de padrões repetitivos.",
                                    "Salve o gráfico e observe visualmente possíveis ciclos anuais."
                                  ],
                                  "verification": "Gráfico gerado mostrando oscilações ao longo do tempo, com rótulos e escalas adequadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código Python: import matplotlib.pyplot as plt; df.plot()",
                                    "Mesmo dataset preparado"
                                  ],
                                  "tips": "Use zoom em períodos específicos para inspecionar repetições.",
                                  "learningObjective": "Visualizar a série temporal para identificar indícios iniciais de sazonalidade.",
                                  "commonMistakes": [
                                    "Eixos não rotulados causando confusão.",
                                    "Escala inadequada escondendo padrões.",
                                    "Não usar médias móveis para suavizar ruído."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Criar Gráficos Sazonais (Seasonal Plots)",
                                  "subSteps": [
                                    "Agrupe dados por período sazonal (ex: por mês) e plote múltiplas linhas sobrepostas.",
                                    "Use cores diferentes ou transparência para cada ciclo anual.",
                                    "Alinhe todos os períodos sazonais no mesmo eixo x (ex: meses 1-12).",
                                    "Adicione legenda para identificar anos e título 'Seasonal Plot por Mês'.",
                                    "Analise sobreposições para padrões consistentes."
                                  ],
                                  "verification": "Múltiplas curvas alinhadas revelando similaridades sazonais, com legenda clara.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código: for month in range(1,13): plt.plot(df[df.month==month])",
                                    "Bibliotecas: seaborn para facetas opcionais"
                                  ],
                                  "tips": "Normalize as curvas se escalas variam muito entre anos.",
                                  "learningObjective": "Construir visualizações que isolam o componente sazonal de séries temporais.",
                                  "commonMistakes": [
                                    "Não alinhar corretamente os períodos, causando desalinhamento.",
                                    "Muitas linhas sem transparência tornando o plot ilegível.",
                                    "Omitir legenda para anos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Criar Boxplots por Período Sazonal",
                                  "subSteps": [
                                    "Agrupe valores por período sazonal (ex: boxplot de vendas por mês).",
                                    "Gere boxplot com eixo x como períodos sazonais e y como valores.",
                                    "Adicione estatísticas (mediana, quartis) e outliers visíveis.",
                                    "Rotule eixos e título 'Boxplots Sazonais de Vendas por Mês'.",
                                    "Compare medianas e spreads entre períodos."
                                  ],
                                  "verification": "Boxplots gerados mostrando distribuições por período, com outliers marcados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código: df.boxplot(column='value', by='month')",
                                    "Seaborn: sns.boxplot(x='month', y='value', data=df)"
                                  ],
                                  "tips": "Ordene os boxes pelo período sazonal para facilitar leitura sequencial.",
                                  "learningObjective": "Usar boxplots para resumir e comparar variabilidade sazonal.",
                                  "commonMistakes": [
                                    "Não ordenar categorias no eixo x.",
                                    "Ignorar outliers que indicam eventos sazonais extremos.",
                                    "Escala y inadequada comprimindo diferenças."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar Gráficos e Detectar Sazonalidade",
                                  "subSteps": [
                                    "Compare série temporal com seasonal plots para confirmar repetições.",
                                    "Analise boxplots para identificar meses com valores consistentemente altos/baixos.",
                                    "Documente padrões: ex: 'Picos em dezembro e julho'.",
                                    "Quantifique: calcule média por período e plote.",
                                    "Conclua se sazonalidade está presente e seu período."
                                  ],
                                  "verification": "Relatório escrito identificando padrões sazonais com evidências dos gráficos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Todos os gráficos gerados",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Procure consistência em pelo menos 70% dos ciclos para confirmar sazonalidade.",
                                  "learningObjective": "Interpretar visualizações para detectar e descrever sazonalidade de forma precisa.",
                                  "commonMistakes": [
                                    "Confundir tendência de longo prazo com sazonalidade.",
                                    "Ignorar variabilidade em boxplots.",
                                    "Sobre-generalizar de poucos ciclos."
                                  ]
                                }
                              ],
                              "practicalExample": "Usando o dataset clássico 'AirPassengers' (passageiros aéreos mensais de 1949-1960), construa os gráficos para detectar picos sazonais no verão (julho-setembro) com seasonal plots mostrando curvas sobrepostas e boxplots revelando maior variância e mediana alta nesses meses.",
                              "finalVerifications": [
                                "Série temporal exibe oscilações regulares anuais.",
                                "Seasonal plots mostram alinhamento consistente de curvas por período.",
                                "Boxplots por mês destacam períodos de alta/baixa mediana.",
                                "Relatório descreve padrões sazonais com evidências visuais.",
                                "Período sazonal (ex: 12 meses) corretamente identificado.",
                                "Gráficos salvos com rótulos profissionais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na preparação e limpeza dos dados (sem erros de data).",
                                "Qualidade visual dos gráficos (rótulos, escalas, legenda).",
                                "Correta implementação de seasonal plots e boxplots.",
                                "Interpretação precisa de padrões sazonais com justificativa.",
                                "Uso eficiente de ferramentas e código limpo.",
                                "Identificação correta de pelo menos 3 padrões sazonais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estatística descritiva e medidas de tendência central.",
                                "Informática: Programação em Python/R para visualização de dados.",
                                "Economia/Negócios: Análise de vendas e previsão de demanda.",
                                "Ciência Ambiental: Detecção de padrões climáticos sazonais.",
                                "Machine Learning: Pré-processamento para decomposição de séries temporais."
                              ],
                              "realWorldApplication": "No varejo, detectar sazonalidade em vendas para otimizar estoque (ex: mais roupas de inverno em dezembro); em meteorologia, identificar ciclos de precipitação para agricultura; em finanças, modelar retornos de ações sazonais para investimentos estratégicos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.6.1.3.2",
                            "name": "Aplicar decomposição sazonal",
                            "description": "Realizar decomposição aditiva ou multiplicativa de uma série temporal em tendência, sazonalidade e resíduo usando métodos clássicos ou em softwares como R.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e Explorar a Série Temporal",
                                  "subSteps": [
                                    "Coletar dados de série temporal com pelo menos 2-3 ciclos sazonais completos.",
                                    "Verificar e tratar valores ausentes ou outliers.",
                                    "Plotar o gráfico da série temporal original para visualização.",
                                    "Realizar testes preliminares de sazonalidade (ex: ACF/PACF ou inspeção visual).",
                                    "Determinar o período sazonal (ex: 12 para mensal)."
                                  ],
                                  "verification": "Gráfico da série plotado corretamente, sem valores ausentes, e período sazonal identificado.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Planilha Excel ou CSV com dados",
                                    "Software R ou Python (ggplot2 ou matplotlib)"
                                  ],
                                  "tips": "Sempre use dados reais ou simulados com sazonalidade conhecida para prática.",
                                  "learningObjective": "Compreender a importância da preparação de dados para decomposição precisa.",
                                  "commonMistakes": [
                                    "Ignorar valores ausentes",
                                    "Não plotar múltiplos ciclos",
                                    "Confundir período sazonal"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escolher o Modelo de Decomposição (Aditivo ou Multiplicativo)",
                                  "subSteps": [
                                    "Analisar variância: se constante, usar aditivo; se crescente, multiplicativo.",
                                    "Calcular proporção de variância sazonal vs tendência.",
                                    "Testar visualmente com gráficos de resíduos preliminares.",
                                    "Documentar a escolha com justificativa baseada em características da série.",
                                    "Preparar fórmulas: Aditivo Yt = Tt + St + Rt; Multiplicativo Yt = Tt * St * Rt."
                                  ],
                                  "verification": "Justificativa escrita e escolha do modelo alinhada com análise da variância.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Gráficos da série",
                                    "Documentação em notebook Jupyter ou R Markdown"
                                  ],
                                  "tips": "Use o teste de variância relativa: se sazonalidade varia proporcionalmente, prefira multiplicativo.",
                                  "learningObjective": "Saber diferenciar e justificar modelos aditivo vs multiplicativo.",
                                  "commonMistakes": [
                                    "Escolher aditivo para séries com variância crescente",
                                    "Não testar visualmente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Decomposição Usando Métodos Clássicos ou em R",
                                  "subSteps": [
                                    "Para método clássico aditivo: Calcular médias móveis para tendência, subtrair para obter sazonal e resíduo.",
                                    "Para multiplicativo: Usar médias móveis geométricas ou normalização.",
                                    "Em R: Usar função decompose() ou stl() no pacote stats.",
                                    "Gerar gráficos dos componentes: tendência, sazonalidade e resíduo.",
                                    "Salvar componentes em data frame para análise posterior."
                                  ],
                                  "verification": "Componentes (tendência, sazonal, resíduo) extraídos e plotados corretamente; soma/reconstrução da série original.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "RStudio",
                                    "Pacotes: forecast, ggplot2",
                                    "Dados preparados"
                                  ],
                                  "tips": "Comece com decompose() para simplicidade; valide com plot() automático.",
                                  "learningObjective": "Executar decomposição prática manual e automatizada em software.",
                                  "commonMistakes": [
                                    "Médias móveis com janela errada",
                                    "Não centralizar sazonalidade para soma zero",
                                    "Erro em escala para multiplicativo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Componentes e Validar Resultados",
                                  "subSteps": [
                                    "Analisar tendência: direção, aceleração e breakpoints.",
                                    "Examinar sazonalidade: amplitude, padrão cíclico e consistência entre ciclos.",
                                    "Verificar resíduos: ausência de autocorrelação (teste Ljung-Box), normalidade e homocedasticidade.",
                                    "Reconstruir série original e comparar com dados reais.",
                                    "Documentar insights e sugestões para modelagem avançada (ex: ARIMA nos resíduos)."
                                  ],
                                  "verification": "Relatório com interpretação escrita, testes nos resíduos aprovados e reconstrução precisa (>95% fit).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "R com pacotes tseries para testes",
                                    "Gráficos e relatório"
                                  ],
                                  "tips": "Resíduos brancos ideais: média zero, variância constante, sem padrões.",
                                  "learningObjective": "Interpretar componentes e validar decomposição para insights acionáveis.",
                                  "commonMistakes": [
                                    "Ignorar resíduos correlacionados",
                                    "Não verificar reconstrução",
                                    "Sobreinterpretar ruído como sinal"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar e Documentar para Casos Reais",
                                  "subSteps": [
                                    "Aplicar decomposição a um dataset real (ex: AirPassengers).",
                                    "Comparar aditivo vs multiplicativo via AIC ou fit.",
                                    "Gerar relatório com gráficos, tabelas e conclusões.",
                                    "Explorar extensões: descomposição STL para não-lineares.",
                                    "Compartilhar código em GitHub para revisão."
                                  ],
                                  "verification": "Relatório completo com código reproduzível e insights validados.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Dataset público (ex: AirPassengers no R)",
                                    "GitHub"
                                  ],
                                  "tips": "Use STL() para séries robustas a outliers.",
                                  "learningObjective": "Integrar decomposição em workflow analítico completo.",
                                  "commonMistakes": [
                                    "Não comparar modelos",
                                    "Relatório sem código",
                                    "Ignorar contexto do domínio"
                                  ]
                                }
                              ],
                              "practicalExample": "Decompor a série temporal clássica AirPassengers (passageiros aéreos mensais de 1949-1960) usando decompose() no R: identificar tendência crescente, sazonalidade anual com picos de verão e resíduos aleatórios.",
                              "finalVerifications": [
                                "Gráficos dos três componentes (tendência, sazonal, resíduo) gerados e corretos.",
                                "Reconstrução da série original com erro mínimo (<5%).",
                                "Resíduos sem autocorrelação significativa (p-value Ljung-Box >0.05).",
                                "Escolha de modelo justificada por análise de variância.",
                                "Código R reproduzível e documentado.",
                                "Insights sobre sazonalidade documentados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na preparação e escolha do modelo (30%).",
                                "Correta implementação da decomposição (25%).",
                                "Qualidade da interpretação e validação (20%).",
                                "Uso adequado de software e visualizações (15%).",
                                "Relatório claro e acionável (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Economia: Previsão de vendas sazonais em varejo.",
                                "Finanças: Análise de retornos de ações com ciclos.",
                                "Meteorologia: Modelagem de temperaturas sazonais.",
                                "Saúde Pública: Picos epidêmicos anuais.",
                                "Engenharia: Manutenção preditiva com padrões cíclicos."
                              ],
                              "realWorldApplication": "Empresas de varejo usam decomposição sazonal para ajustar estoques antes de feriados, reduzindo custos em 20-30%; bancos preveem saques sazonais para gerenciamento de liquidez."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.1.1",
                              "10.1.6.1.2.2"
                            ]
                          },
                          {
                            "id": "10.1.6.1.3.3",
                            "name": "Realizar testes estatísticos de sazonalidade",
                            "description": "Aplicar testes como o teste de Kwiatkowski-Phillips-Schmidt-Shin (KPSS) sazonal ou análise de autocorrelação sazonal (SACF) para confirmar presença de sazonalidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar dados e selecionar testes apropriados",
                                  "subSteps": [
                                    "Carregue a série temporal usando pandas em Python.",
                                    "Verifique e transforme os dados para formato adequado (ex: frequência mensal = 12).",
                                    "Defina hipóteses nulas: KPSS sazonal (H0: série é sazonalmente estacionária), SACF (H0: ausência de autocorrelação sazonal).",
                                    "Escolha lags sazonais baseados na periodicidade (ex: lag 12 para mensal).",
                                    "Instale bibliotecas necessárias: pip install statsmodels pandas"
                                  ],
                                  "verification": "Dados carregados corretamente, periodicidade identificada e hipóteses claras documentadas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python com pandas e statsmodels",
                                    "Dataset de série temporal (ex: AirPassengers.csv)"
                                  ],
                                  "tips": "Sempre plotar a série e ACF inicial para visual inspeção antes de testes formais.",
                                  "learningObjective": "Compreender pré-requisitos e setup para testes de sazonalidade.",
                                  "commonMistakes": [
                                    "Ignorar transformação de frequência",
                                    "Não definir lags corretos",
                                    "Usar dados não estacionários sem diferenciar"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar teste KPSS sazonal",
                                  "subSteps": [
                                    "Importe kpss de statsmodels.tsa.stattools.",
                                    "Aplique kpss(data, regression='c', nlags='auto', seasonal=True).",
                                    "Extraia estatística do teste, valor-p e lags usados.",
                                    "Compare valor-p com nível de significância (ex: 0.05).",
                                    "Documente resultados em tabela ou relatório."
                                  ],
                                  "verification": "Resultado do teste gerado com valor-p < 0.05 indicando rejeição de H0 (presença de sazonalidade).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código Python/Jupyter Notebook",
                                    "statsmodels library"
                                  ],
                                  "tips": "Use regression='ct' se tendência presente; teste sensibilidade a nlags.",
                                  "learningObjective": "Executar e interpretar teste KPSS para sazonalidade.",
                                  "commonMistakes": [
                                    "Confundir H0 (estacionariedade vs não-sazonal)",
                                    "Não especificar seasonal=True",
                                    "Ignorar autocorrelação nos resíduos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar análise de autocorrelação sazonal (SACF)",
                                  "subSteps": [
                                    "Gere ACF plot com lags sazonais usando plot_acf(data, lags=40).",
                                    "Calcule correlações em lags múltiplos da sazonalidade (ex: 12,24).",
                                    "Teste significância das autocorrelações sazonais (limites de confiança).",
                                    "Identifique picos significativos em lags sazonais.",
                                    "Compare com ACF não-sazonal para confirmação."
                                  ],
                                  "verification": "Picos significativos em lags sazonais (ex: lag 12 > limite de confiança).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python com statsmodels.graphics.tsaplots",
                                    "Jupyter para plots"
                                  ],
                                  "tips": "Ajuste lags para cobrir múltiplos ciclos; use log-scale para variância heterogênea.",
                                  "learningObjective": "Detectar padrões sazonais via função de autocorrelação.",
                                  "commonMistakes": [
                                    "Focar só em lags baixos ignorando sazonais",
                                    "Não plotar barras de confiança",
                                    "Interpretar ruído como sazonalidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados e concluir sobre sazonalidade",
                                  "subSteps": [
                                    "Combine evidências: KPSS rejeita H0 E SACF mostra picos.",
                                    "Reporte conclusão: 'Sazonalidade confirmada' ou 'Não detectada'.",
                                    "Discuta limitações (ex: poder do teste em amostras pequenas).",
                                    "Sugira próximos passos (ex: modelagem SARIMA).",
                                    "Salve relatório com plots e tabelas."
                                  ],
                                  "verification": "Conclusão coerente com resultados quantitativos e qualitativos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Relatório Markdown/PDF",
                                    "Plots salvos"
                                  ],
                                  "tips": "Use tabelas para resumir testes; valide com decomposição sazonal.",
                                  "learningObjective": "Integrar múltiplos testes para decisão robusta.",
                                  "commonMistakes": [
                                    "Concluir baseado em um teste só",
                                    "Ignorar tamanho da amostra",
                                    "Não contextualizar com domínio"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dados mensais de passageiros aéreos (AirPassengers dataset), aplique KPSS sazonal (p-valor ~0.01 rejeita H0) e SACF (picos significativos em lags 12,24), confirmando sazonalidade anual forte.",
                              "finalVerifications": [
                                "KPSS sazonal rejeita H0 de estacionariedade sazonal (p < 0.05)?",
                                "SACF exibe picos significativos em lags sazonais?",
                                "Resultados consistentes entre testes?",
                                "Plots de ACF e série suportam conclusão?",
                                "Conclusão documentada com evidências?",
                                "Limitações discutidas?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na implementação dos testes (código correto).",
                                "Interpretação adequada de p-valores e significância.",
                                "Integração coerente de múltiplas evidências.",
                                "Qualidade dos plots e relatórios.",
                                "Identificação correta de erros comuns evitados.",
                                "Robustez da conclusão (sensibilidade testada)."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: Hipóteses e testes.",
                                "Programação: Manipulação de dados em Python/R.",
                                "Economia/Negócios: Previsão de demanda sazonal.",
                                "Matemática: Funções de autocorrelação e processos estocásticos."
                              ],
                              "realWorldApplication": "Em varejo, detectar sazonalidade em vendas de Natal para otimizar estoque; em meteorologia, confirmar ciclos anuais de temperatura para modelos climáticos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.3.1"
                            ]
                          },
                          {
                            "id": "10.1.6.1.3.4",
                            "name": "Interpretar autocorrelações sazonais",
                            "description": "Analisar a função de autocorrelação (ACF) em lags sazonais (ex: lag 12 para dados mensais) para identificar picos significativos indicativos de sazonalidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de ACF e Lags Sazonais",
                                  "subSteps": [
                                    "Defina a Função de Autocorrelação (ACF) como a correlação entre a série temporal e suas versões defasadas.",
                                    "Explique lags regulares versus lags sazonais (ex: lag 12 para dados mensais representa um ano).",
                                    "Descreva como picos em lags sazonais indicam padrões repetitivos periódicos.",
                                    "Revise limites de significância (faixas azuis em plots ACF) para distinguir correlações reais de ruído.",
                                    "Estude exemplos de séries com e sem sazonalidade."
                                  ],
                                  "verification": "Explique em suas palavras a diferença entre lag 1 e lag 12 em dados mensais, e por que o último sugere sazonalidade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação statsmodels.tsa.stattools.acf",
                                    "Notebook Jupyter com exemplos de séries temporais",
                                    "Gráficos de ACF de séries conhecidas (ex: AirPassengers dataset)"
                                  ],
                                  "tips": "Sempre relacione lags sazonais ao período da série (mensal=12, trimestral=4).",
                                  "learningObjective": "Dominar os fundamentos teóricos da ACF para análise sazonal.",
                                  "commonMistakes": [
                                    "Confundir ACF com PACF",
                                    "Ignorar o contexto temporal da série ao escolher lags sazonais",
                                    "Desconsiderar limites de significância"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar e Gerar Plot de ACF para Série Temporal Sazonal",
                                  "subSteps": [
                                    "Carregue um dataset sazonal (ex: vendas mensais ou temperaturas).",
                                    "Verifique estacionariedade básica e plote a série original.",
                                    "Compute e plote a ACF usando biblioteca como statsmodels (plot_acf).",
                                    "Identifique visualmente lags sazonais candidatos (ex: 12, 24).",
                                    "Ajuste parâmetros como nlags para cobrir múltiplos períodos sazonais."
                                  ],
                                  "verification": "Gere um plot ACF com picos visíveis em lags sazonais e anote os lags principais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python com pandas, statsmodels, matplotlib",
                                    "Dataset exemplo: dados mensais de vendas de varejo",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Use plot_acf com alpha=0.05 para limites de significância automáticos.",
                                  "learningObjective": "Adquirir proficiência prática na geração de plots ACF.",
                                  "commonMistakes": [
                                    "Plotar ACF sem verificar a série original",
                                    "Usar lags insuficientes (nlags muito baixo)",
                                    "Não padronizar a série antes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e Analisar Picos Significativos em Lags Sazonais",
                                  "subSteps": [
                                    "Localize picos acima das faixas de significância em lags sazonais (ex: lag 12, 24).",
                                    "Meça a altura do pico (valor da correlação) e compare com lags não sazonais.",
                                    "Observe decaimento: picos sazonais fortes em múltiplos (12,24) sugerem sazonalidade persistente.",
                                    "Registre lags com picos negativos, indicando sazonalidade invertida.",
                                    "Compare com ACF de série não sazonal para contrastar."
                                  ],
                                  "verification": "Liste 3 lags sazonais com picos significativos e seus valores de correlação do seu plot.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Plot ACF gerado no step anterior",
                                    "Ferramentas de zoom em plots (matplotlib)",
                                    "Dataset comparativo não sazonal"
                                  ],
                                  "tips": "Picos alternados (12 positivo, 24 negativo) podem indicar semi-períodos.",
                                  "learningObjective": "Desenvolver habilidade em detectar padrões sazonais via inspeção visual e quantitativa.",
                                  "commonMistakes": [
                                    "Considerar picos dentro da faixa de significância como reais",
                                    "Focar apenas no lag sazonal primário ignorando harmônicos",
                                    "Confundir ruído com sazonalidade fraca"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Resultados e Concluir sobre Sazonalidade",
                                  "subSteps": [
                                    "Sintetize achados: 'Picos significativos em lag 12 e 24 indicam sazonalidade anual forte'.",
                                    "Avalie força da sazonalidade pela magnitude dos picos.",
                                    "Discuta implicações para modelagem (ex: necessidade de SARIMA).",
                                    "Teste robustez removendo tendência e re-plotando ACF.",
                                    "Documente relatório com plot, lags chave e conclusão."
                                  ],
                                  "verification": "Escreva um parágrafo interpretando o ACF, confirmando presença/ausência de sazonalidade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Relatório template em Markdown",
                                    "Funções de diferenciação sazonal (statsmodels)",
                                    "Plots ACF originais e diferenciados"
                                  ],
                                  "tips": "Sempre valide com múltiplos plots (ACF raw vs. diferenciada).",
                                  "learningObjective": "Capacitar interpretação holística e comunicação de insights sazonais.",
                                  "commonMistakes": [
                                    "Superestimar sazonalidade fraca (picos marginais)",
                                    "Não considerar contexto do domínio da série",
                                    "Omitir recomendações para próximos passos de modelagem"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dados mensais de passageiros aéreos (AirPassengers dataset), plote o ACF e identifique picos significativos em lags 12, 24 e 36, confirmando sazonalidade anual forte com correlações acima de 0.7, guiando o uso de modelos SARIMA(0,1,1)x(1,1,1)12.",
                              "finalVerifications": [
                                "Correta identificação de lags sazonais apropriados ao período da série.",
                                "Reconhecimento preciso de picos acima da faixa de significância.",
                                "Interpretação correta da força e persistência da sazonalidade.",
                                "Geração de plots ACF claros com anotações.",
                                "Conclusão alinhada com evidências visuais e quantitativas.",
                                "Sugestão válida de próximos passos em modelagem."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção de picos sazonais (90%+ acurácia).",
                                "Explicação clara da significância estatística.",
                                "Uso correto de ferramentas computacionais sem erros.",
                                "Profundidade na análise de múltiplos lags sazonais.",
                                "Qualidade da interpretação e relatório final.",
                                "Integração de dicas para evitar erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Economia: Identificar sazonalidade em vendas para previsão de demanda.",
                                "Meteorologia: Análise de padrões climáticos anuais em dados de temperatura.",
                                "Finanças: Detecção de ciclos sazonais em retornos de ações.",
                                "Epidemiologia: Sazonalidade em casos de doenças infecciosas."
                              ],
                              "realWorldApplication": "Em empresas de varejo, interpretar ACF sazonal em vendas mensais permite ajustar estoques para picos de fim de ano, otimizando logística e reduzindo custos em até 20% via modelos de previsão precisos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.2",
                    "name": "Análise Exploratória de Padrões Sazonais",
                    "description": "Técnicas gráficas e estatísticas para visualizar e analisar componentes sazonais.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.2.1",
                        "name": "Visualização Gráfica de Padrões Sazonais",
                        "description": "Técnicas gráficas para identificar e visualizar componentes sazonais em séries temporais, como gráficos de linha, sub-séries sazonais e autocorrelações.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.1.1",
                            "name": "Construir gráfico de linha de série temporal sazonal",
                            "description": "Criar e interpretar gráficos de linha para séries temporais sazonais, destacando ciclos repetitivos anuais, trimestrais ou mensais, utilizando ferramentas como R ou Python (ggplot2 ou matplotlib).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e Explorar o Conjunto de Dados Sazonal",
                                  "subSteps": [
                                    "Obtenha um dataset de série temporal com componente sazonal (ex: vendas mensais ou temperaturas).",
                                    "Carregue os dados usando pandas: pd.read_csv('dados.csv').",
                                    "Converta a coluna de data em índice datetime: df.set_index(pd.to_datetime(df['data'])).",
                                    "Inspecione os dados com df.head(), df.describe() e df.plot() para visualização inicial.",
                                    "Identifique a frequência sazonal (mensal, trimestral) usando df.resample()."
                                  ],
                                  "verification": "Dataset carregado sem erros, índice datetime confirmado via df.index.dtype, e plot inicial exibe tendência básica.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Python com pandas e matplotlib instalados",
                                    "Jupyter Notebook ou IDE",
                                    "Dataset CSV de série temporal sazonal (ex: AirPassengers ou vendas mensais)"
                                  ],
                                  "tips": "Use freq='M' para mensal ao converter; sempre verifique NaNs com df.isnull().sum().",
                                  "learningObjective": "Preparar dados temporais corretamente para análise sazonal.",
                                  "commonMistakes": [
                                    "Não converter data para datetime",
                                    "Ignorar valores ausentes",
                                    "Frequência errada no resample"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Ambiente e Importar Bibliotecas",
                                  "subSteps": [
                                    "Instale bibliotecas se necessário: pip install pandas matplotlib seaborn.",
                                    "Importe: import pandas as pd; import matplotlib.pyplot as plt; import numpy as np.",
                                    "Defina estilo do plot: plt.style.use('seaborn-v0_8').",
                                    "Crie figura: fig, ax = plt.subplots(figsize=(12,6)).",
                                    "Prepare dados agregados para sazonalidade: df_monthly = df.resample('M').mean()."
                                  ],
                                  "verification": "Imports sem erros, figura criada e dados agregados plotados corretamente.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Ambiente Python (Anaconda ou Google Colab)",
                                    "Bibliotecas: pandas, matplotlib, seaborn"
                                  ],
                                  "tips": "Use Google Colab para datasets públicos; teste imports em célula separada.",
                                  "learningObjective": "Configurar ferramentas de visualização para séries temporais.",
                                  "commonMistakes": [
                                    "Figsize muito pequeno",
                                    "Estilo não aplicado",
                                    "Resample sem mean/agg"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir e Customizar o Gráfico de Linha Sazonal",
                                  "subSteps": [
                                    "Plote a linha principal: ax.plot(df.index, df['valor'], linewidth=1.5, color='blue').",
                                    "Adicione média móvel para suavizar: df['media_movel'] = df['valor'].rolling(12).mean(); ax.plot(df.index, df['media_movel'], color='red').",
                                    "Destaque sazonalidade com shade: ax.fill_between(df.index, df['valor'], alpha=0.3).",
                                    "Rotule eixos: ax.set_xlabel('Tempo'); ax.set_ylabel('Valor'); ax.set_title('Gráfico de Linha Sazonal').",
                                    "Formate datas no eixo x: ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m'))."
                                  ],
                                  "verification": "Gráfico renderizado com linha principal, média móvel e ciclos sazonais visíveis; labels presentes.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Código Python pronto",
                                    "Dataset preparado do Step 1"
                                  ],
                                  "tips": "Use rolling(window=12) para anual; adicione grid com ax.grid(True, alpha=0.3).",
                                  "learningObjective": "Criar gráfico de linha que destaca padrões sazonais repetitivos.",
                                  "commonMistakes": [
                                    "Sem média móvel para clareza",
                                    "Eixos sem labels",
                                    "Datas não formatadas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Padrões Sazonais e Finalizar",
                                  "subSteps": [
                                    "Identifique ciclos: picos em meses específicos (ex: dezembro para vendas natalinas).",
                                    "Compare anos: sobreponha linhas por ano com df.groupby(df.index.month).mean().",
                                    "Salve o gráfico: plt.savefig('grafico_sazonal.png', dpi=300).",
                                    "Documente insights: anote amplitude sazonal e período (ex: 12 meses).",
                                    "Valide com decomposição: use seasonal_decompose de statsmodels para confirmar."
                                  ],
                                  "verification": "Relatório escrito com 3+ insights sazonais; gráfico salvo e visualmente claro.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "Biblioteca statsmodels opcional",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Zoom em períodos para detalhes; use plt.tight_layout() antes de salvar.",
                                  "learningObjective": "Interpretar visualmente ciclos sazonais em séries temporais.",
                                  "commonMistakes": [
                                    "Ignorar variações anuais",
                                    "Não salvar em alta resolução",
                                    "Interpretação sem evidência visual"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dataset AirPassengers (passageiros aéreos mensais 1949-1960), plote df['#Passengers'] vs tempo com média móvel de 12 meses: revela picos sazonais todo verão (julho-agosto), caindo no inverno, facilitando previsão de demanda.",
                              "finalVerifications": [
                                "Gráfico exibe linha temporal contínua sem gaps ou erros de escala.",
                                "Ciclos sazonais repetitivos (anual/trimestral) são claramente visíveis.",
                                "Média móvel ou shade destaca tendências sazonais.",
                                "Eixos, título e legenda estão rotulados corretamente.",
                                "Gráfico salvo em formato legível (PNG/PDF).",
                                "Interpretação escrita identifica pelo menos 2 padrões sazonais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na preparação de dados temporais (30%).",
                                "Qualidade visual e customização do gráfico (25%).",
                                "Evidência clara de padrões sazonais destacados (20%).",
                                "Correta interpretação com insights acionáveis (15%).",
                                "Código limpo, comentado e reproduzível (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelos de funções periódicas e decomposição aditiva.",
                                "Economia: Análise de demanda sazonal em varejo e finanças.",
                                "Geociências: Padrões climáticos e temperatura sazonal.",
                                "Programação: Manipulação de dados com pandas e visualização."
                              ],
                              "realWorldApplication": "Em meteorologia para prever chuvas sazonais; varejo para gerenciar estoque natalino; finanças para ajustar investimentos trimestrais baseados em ciclos econômicos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.1.2",
                            "name": "Gerar gráficos de sub-séries sazonais",
                            "description": "Separar a série temporal em sub-séries por período sazonal (ex: meses) e plotar médias ou boxplots para evidenciar variações sazonais claras.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a Série Temporal para Análise Sazonal",
                                  "subSteps": [
                                    "Carregue o dataset de série temporal usando pandas.read_csv() ou similar.",
                                    "Converta a coluna de datas para formato datetime com pd.to_datetime().",
                                    "Defina a coluna de datas como índice do DataFrame.",
                                    "Inspecione os dados com .head(), .describe() e .plot() para confirmar periodicidade.",
                                    "Trate valores ausentes com .fillna() ou interpolação se necessário."
                                  ],
                                  "verification": "Execute df.index.dtype == 'datetime64[ns]' e df.isnull().sum() para confirmar preparação.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python com pandas e matplotlib instalados",
                                    "Dataset exemplo como AirPassengers.csv"
                                  ],
                                  "tips": "Use parse_dates=True no read_csv para automação da conversão de datas.",
                                  "learningObjective": "Preparar dados temporais limpos e indexados corretamente para extração sazonal.",
                                  "commonMistakes": [
                                    "Esquecer de definir índice temporal",
                                    "Ignorar NaNs que distorcem médias",
                                    "Não inspecionar dados iniciais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Extrair Sub-séries Sazonais por Período",
                                  "subSteps": [
                                    "Crie uma coluna sazonal: df['season'] = df.index.month (para meses) ou df.index.quarter (para trimestres).",
                                    "Agrupe os dados: grouped = df.groupby('season')",
                                    "Calcule estatísticas por grupo: means = grouped['value'].mean(); stds = grouped['value'].std()",
                                    "Prepare listas para boxplots: box_data = [group['value'].values for name, group in grouped]",
                                    "Salve sub-séries em um dicionário para acesso fácil."
                                  ],
                                  "verification": "Imprima means e len(box_data) == 12 (para meses) para validar separação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Pandas DataFrame preparado do Step 1"
                                  ],
                                  "tips": "Use df.index.month_name() para rótulos legíveis em gráficos.",
                                  "learningObjective": "Separar série em sub-séries sazonais e computar métricas agregadas.",
                                  "commonMistakes": [
                                    "Agrupar incorretamente por data errada",
                                    "Usar mean() sem considerar outliers",
                                    "Perder ordem sazonal nos grupos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar Gráficos de Médias das Sub-séries",
                                  "subSteps": [
                                    "Importe matplotlib.pyplot as plt e configure plt.style.use('seaborn-v0_8').",
                                    "Plote barras de médias: plt.bar(means.index, means.values)",
                                    "Adicione rótulos: plt.xlabel('Mês'), plt.ylabel('Média do Valor'), plt.title('Médias Sazonais').",
                                    "Inclua barras de erro: plt.errorbar(means.index, means.values, yerr=stds.values)",
                                    "Salve o gráfico: plt.savefig('medias_sazonais.png')."
                                  ],
                                  "verification": "Visualize o gráfico e confirme que picos sazonais (ex: verão) são evidentes.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Métricas do Step 2",
                                    "Matplotlib/Seaborn"
                                  ],
                                  "tips": "Use plt.xticks(rotation=45) para rótulos longos como nomes de meses.",
                                  "learningObjective": "Criar visualizações de médias que destacam variações sazonais médias.",
                                  "commonMistakes": [
                                    "Escala inadequada nos eixos",
                                    "Omitir erros de desvio padrão",
                                    "Título genérico sem contexto sazonal"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Gerar Boxplots das Sub-séries Sazonais",
                                  "subSteps": [
                                    "Use plt.boxplot(box_data, labels=means.index.astype(str)) ou seaborn.boxplot().",
                                    "Customizar: plt.xlabel('Período Sazonal'), plt.ylabel('Valores Observados'), plt.title('Boxplots Sazonais').",
                                    "Adicione grid e rotação: plt.grid(True, alpha=0.3); plt.xticks(rotation=45).",
                                    "Compare com gráfico de médias no mesmo subplot usando subplots(1,2).",
                                    "Salve e exiba: plt.tight_layout(); plt.savefig('boxplots_sazonais.png'); plt.show()."
                                  ],
                                  "verification": "Confirme que boxplots mostram mediana, quartis e outliers por período sazonal.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "box_data do Step 2",
                                    "Matplotlib/Seaborn"
                                  ],
                                  "tips": "Seaborn é mais elegante: import seaborn as sns; sns.boxplot(data=df, x='season', y='value').",
                                  "learningObjective": "Visualizar dispersão e distribuição sazonal com boxplots para insights robustos.",
                                  "commonMistakes": [
                                    "Boxplot sem rótulos claros",
                                    "Ignorar outliers que indicam eventos reais",
                                    "Não alinhar escalas entre gráficos"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando o dataset AirPassengers (passageiros aéreos mensais de 1949-1960), extraia sub-séries por mês, plote médias mostrando picos em julho/agosto (~300 passageiros) e boxplots revelando maior variabilidade no verão.",
                              "finalVerifications": [
                                "Gráficos de médias exibem variações sazonais claras com picos e vales identificáveis.",
                                "Boxplots mostram distribuições por período, incluindo mediana e outliers.",
                                "Todos os gráficos têm títulos, labels e legendas adequados.",
                                "Arquivos PNG salvos sem erros e visualizáveis.",
                                "Comparação entre médias e boxplots confirma padrões sazonais.",
                                "Código roda sem warnings de depreciação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na separação sazonal (agrupamento correto por mês/trimestre).",
                                "Qualidade visual dos gráficos (legibilidade, escalas apropriadas, erro bars).",
                                "Uso de múltiplas visualizações (médias + boxplots) para evidenciar padrões.",
                                "Tratamento de dados (sem NaNs impactantes, índice temporal correto).",
                                "Customizações que facilitam interpretação (grids, rotações, títulos descritivos).",
                                "Eficiência do código (uso de groupby vetorizado)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estatística descritiva e medidas de tendência central/dispersão.",
                                "Geografia: Análise de padrões climáticos e ambientais sazonais.",
                                "Economia: Previsão de demanda sazonal em vendas e turismo.",
                                "Biologia: Ciclos fenológicos e padrões populacionais sazonais.",
                                "Computação: Manipulação de dados com pandas e visualização com matplotlib."
                              ],
                              "realWorldApplication": "Em meteorologia para visualizar temperaturas sazonais e prever eventos climáticos; no varejo para analisar vendas por estação e otimizar estoque; em finanças para detectar sazonalidades em retornos de ações e melhorar modelos de previsão."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.1.3",
                            "name": "Interpretar funções de autocorrelação (ACF) para sazonalidade",
                            "description": "Calcular e plotar a função de autocorrelação (ACF) para detectar picos significativos em lags sazonais, identificando a periodicidade sazonal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e carregar a série temporal",
                                  "subSteps": [
                                    "Instalar bibliotecas necessárias: pandas, numpy, statsmodels e matplotlib via pip.",
                                    "Importar as bibliotecas no Jupyter Notebook ou script Python.",
                                    "Carregar um dataset exemplo com sazonalidade, como vendas mensais de varejo.",
                                    "Converter os dados em objeto pd.Series com index de datas e definir frequência (ex: 'M' para mensal).",
                                    "Visualizar a série temporal original com plot() para confirmar sazonalidade visual."
                                  ],
                                  "verification": "Dados carregados corretamente, série temporal plotada sem erros e frequência definida.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Jupyter Notebook ou Python IDE",
                                    "Bibliotecas: pandas, numpy, statsmodels, matplotlib",
                                    "Dataset CSV com série temporal sazonal (ex: airpassengers.csv)"
                                  ],
                                  "tips": "Escolha datasets públicos como AirPassengers para prática inicial; verifique missing values com isnull().sum().",
                                  "learningObjective": "Configurar ambiente de análise e preparar dados limpos para cálculo de ACF.",
                                  "commonMistakes": [
                                    "Não definir a frequência da série temporal",
                                    "Ignorar valores ausentes ou outliers",
                                    "Usar index numérico em vez de datetime"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a função de autocorrelação (ACF)",
                                  "subSteps": [
                                    "Importar função acf de statsmodels.tsa.stattools.",
                                    "Calcular ACF com acf(série, nlags=40, alpha=0.05) para incluir bandas de confiança.",
                                    "Armazenar resultados em variáveis: acf_values, confint.",
                                    "Verificar comprimento do array e valores entre -1 e 1.",
                                    "Plotar ACF parcial (PACF) opcionalmente para comparação."
                                  ],
                                  "verification": "Array acf_values gerado com 40 lags e bandas de confiança calculadas sem erros.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Bibliotecas statsmodels e numpy já importadas",
                                    "Série temporal preparada do step anterior"
                                  ],
                                  "tips": "Defina nlags maior que o período sazonal suspeito (ex: 2x12=24 para mensal).",
                                  "learningObjective": "Executar cálculo preciso da ACF com lags suficientes para detectar sazonalidade.",
                                  "commonMistakes": [
                                    "nlags insuficiente para capturar sazonalidade longa",
                                    "Não especificar alpha=0.05 para bandas de 95%",
                                    "Confundir ACF com PACF"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Plotar e visualizar o gráfico de ACF",
                                  "subSteps": [
                                    "Usar from statsmodels.graphics.tsaplots import plot_acf.",
                                    "Executar plot_acf(série, lags=40, ax=plt.subplots()[1]) para plot customizado.",
                                    "Adicionar bandas de confiança e título 'ACF para Detecção de Sazonalidade'.",
                                    "Customizar eixos: xlabel('Lags'), ylabel('Autocorrelação'), adicionar grid.",
                                    "Exibir ou salvar o gráfico com plt.show() ou plt.savefig()."
                                  ],
                                  "verification": "Gráfico ACF plotado com barras azuis, linha azul tracejada para confiança e picos visíveis.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Biblioteca matplotlib",
                                    "Resultados ACF do step anterior"
                                  ],
                                  "tips": "Use lags=40 para séries mensais; zoom em lags iniciais para tendências.",
                                  "learningObjective": "Gerar visualização clara da ACF destacando padrões sazonais.",
                                  "commonMistakes": [
                                    "Não incluir bandas de confiança",
                                    "Escala inadequada nos eixos",
                                    "Plotar lags excessivos sem zoom"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar picos para identificar periodicidade sazonal",
                                  "subSteps": [
                                    "Identificar picos acima da banda superior de confiança (ex: lag 12 forte).",
                                    "Medir distância entre picos consecutivos para periodicidade (ex: 12 lags = anual).",
                                    "Verificar picos harmônicos (ex: lag 24, 36) confirmando sazonalidade.",
                                    "Documentar em relatório: 'Sazonalidade de 12 períodos detectada'.",
                                    "Comparar com plot da série original para validação visual."
                                  ],
                                  "verification": "Relatório escrito identificando lags sazonais e periodicidade com justificativa.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Gráfico ACF do step 3",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Picos negativos indicam sazonalidade alternada; ignore lags iniciais por tendência.",
                                  "learningObjective": "Interpretar visualmente ACF para extrair insights sobre sazonalidade.",
                                  "commonMistakes": [
                                    "Confundir picos insignificantes com sazonalidade",
                                    "Ignorar harmônicos",
                                    "Não validar com série original"
                                  ]
                                }
                              ],
                              "practicalExample": "Ao analisar dados mensais de passageiros aéreos (AirPassengers dataset), o gráfico ACF mostra picos significativos em lags 12, 24 e 36, indicando sazonalidade anual de 12 meses, útil para modelagem SARIMA.",
                              "finalVerifications": [
                                "Calcula ACF corretamente com lags adequados e plot sem erros.",
                                "Identifica pelo menos 3 picos significativos acima da banda de confiança.",
                                "Determina periodicidade sazonal pela distância entre picos.",
                                "Valida interpretação comparando com visual da série original.",
                                "Documenta achados em relatório claro e conciso.",
                                "Aplica em dataset novo com sazonalidade conhecida."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo e plot da ACF (sem erros técnicos).",
                                "Correta identificação de picos significativos vs. ruído.",
                                "Exatidão na determinação da periodicidade sazonal.",
                                "Qualidade da documentação e justificativas.",
                                "Capacidade de generalizar para novos datasets.",
                                "Integração com análise exploratória prévia."
                              ],
                              "crossCurricularConnections": [
                                "Economia: Detecção de ciclos sazonais em vendas para previsão de demanda.",
                                "Meteorologia: Análise de padrões climáticos anuais em temperaturas.",
                                "Finanças: Identificação de sazonalidade em retornos de ações ou câmbio.",
                                "Epidemiologia: Picos sazonais em casos de doenças infecciosas."
                              ],
                              "realWorldApplication": "Em empresas de varejo, interpretar ACF de vendas mensais revela sazonalidade anual (picos em dezembro), permitindo otimizar estoque e campanhas de marketing com antecedência de 6-12 meses."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.2.2",
                        "name": "Decomposição de Componentes Sazonais",
                        "description": "Métodos de decomposição para separar a série temporal em tendência, sazonalidade, ciclo e resíduo, focando no componente sazonal.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.2.1",
                            "name": "Realizar decomposição aditiva de série sazonal",
                            "description": "Aplicar decomposição aditiva (Y_t = T_t + S_t + C_t + R_t) usando funções como decompose() no R, interpretando o componente sazonal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente R e carregar dados sazonais",
                                  "subSteps": [
                                    "Instale e carregue pacotes necessários: forecast e ggplot2.",
                                    "Carregue um dataset sazonal exemplo, como data(AirPassengers).",
                                    "Converta os dados em objeto ts() com frequência sazonal (ex: frequency=12 para mensal).",
                                    "Inspecione os dados com plot() e summary() para confirmar sazonalidade.",
                                    "Crie uma cópia dos dados originais para referência."
                                  ],
                                  "verification": "Confirme que o plot inicial mostra padrão sazonal claro e summary() exibe estatísticas básicas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "R e RStudio instalados",
                                    "Pacotes: forecast, ggplot2",
                                    "Dataset: AirPassengers (built-in)"
                                  ],
                                  "tips": "Sempre defina a frequência corretamente para evitar erros na decomposição.",
                                  "learningObjective": "Configurar ambiente R pronto para análise de séries temporais sazonais.",
                                  "commonMistakes": [
                                    "Esquecer de carregar pacotes",
                                    "Definir frequência errada (ex: 12 para dados mensais)",
                                    "Não inspecionar dados iniciais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar pré-requisitos da série temporal para decomposição aditiva",
                                  "subSteps": [
                                    "Aplique teste de sazonalidade com ggseasonplot() ou Monthplot().",
                                    "Verifique estacionariedade da tendência com diff() ou plot da série diferenciada.",
                                    "Confirme que a série não tem outliers extremos com boxplot().",
                                    "Calcule autocorrelação com acf() para evidenciar periodicidade sazonal.",
                                    "Documente observações sobre amplitude e fase da sazonalidade."
                                  ],
                                  "verification": "Gráficos mostram padrão sazonal repetitivo e ACF com picos significativos em lags sazonais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Pacote forecast para ggseasonplot()",
                                    "Funções base R: acf(), boxplot()"
                                  ],
                                  "tips": "Use log() se variância aumentar com o tempo para estabilizar.",
                                  "learningObjective": "Identificar se a série atende aos pressupostos da decomposição aditiva (sazonalidade aditiva).",
                                  "commonMistakes": [
                                    "Ignorar variância não constante",
                                    "Confundir sazonalidade com tendência",
                                    "Não testar múltiplos lags"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar decomposição aditiva com a função decompose()",
                                  "subSteps": [
                                    "Execute decomp <- decompose(AirPassengers, type='additive').",
                                    "Extraia componentes: trend = decomp$trend, seasonal = decomp$seasonal, etc.",
                                    "Some os componentes para verificar: sum(decomp) deve aproximar Y_t.",
                                    "Trate NAs nos componentes de tendência inicial/final.",
                                    "Salve os componentes em data.frame para análise posterior."
                                  ],
                                  "verification": "Autoplot(decomp) ou plot(decomp) exibe os quatro componentes: observed, trend, seasonal, random.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Função decompose() do pacote stats",
                                    "Dataset ts preparado"
                                  ],
                                  "tips": "Use type='additive' explicitamente; verifique se seasonal soma a zero por ciclo.",
                                  "learningObjective": "Executar decomposição Y_t = T_t + S_t + C_t + R_t corretamente no R.",
                                  "commonMistakes": [
                                    "Usar type='multiplicative' por engano",
                                    "Não lidar com NAs",
                                    "Frequência incompatível"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar o componente sazonal e validar a decomposição",
                                  "subSteps": [
                                    "Plote apenas o componente seasonal com plot(decomp$seasonal).",
                                    "Descreva amplitude (máx-mín), fase (picos/vales) e periodicidade.",
                                    "Compare resíduos (random) com acf() para ruído branco.",
                                    "Reconstrua série: Y_recon = trend + seasonal + random e compare com original.",
                                    "Gere relatório com ggplot2 para visualização aprimorada."
                                  ],
                                  "verification": "Resíduos têm média zero, variância constante e sem autocorrelação significativa.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "ggplot2 para plots customizados",
                                    "Funções: acf(), autoplot() do forecast"
                                  ],
                                  "tips": "Foque na interpretação: 'Sazonalidade positiva no verão indica aumento de 20%'.",
                                  "learningObjective": "Interpretar e validar o componente sazonal na decomposição aditiva.",
                                  "commonMistakes": [
                                    "Interpretar random como sinal",
                                    "Ignorar que seasonal deve somar zero",
                                    "Não validar resíduos"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando o dataset AirPassengers (passageiros aéreos mensais 1949-1960), aplique decompose(AirPassengers, type='additive'). O componente sazonal revela picos no verão (julho) com amplitude ~40 passageiros, confirmando sazonalidade de viagens de férias.",
                              "finalVerifications": [
                                "Plot da decomposição mostra tendência crescente, sazonalidade cíclica, ciclo ausente e resíduos aleatórios.",
                                "Componente sazonal soma zero em cada período completo.",
                                "Resíduos passam em teste de Ljung-Box para independência.",
                                "Reconstrução da série original tem erro mínimo (MSE < 5%).",
                                "Interpretação escrita identifica fase e amplitude corretas.",
                                "Código R reproduzível gera os mesmos resultados."
                              ],
                              "assessmentCriteria": [
                                "Correta configuração de ts() com frequência sazonal.",
                                "Aplicação precisa de decompose() com type='additive'.",
                                "Interpretação detalhada do componente sazonal (amplitude, fase).",
                                "Validação adequada dos resíduos (plots e testes).",
                                "Visualizações claras e código comentado.",
                                "Relatório conecta decomposição a insights práticos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelos lineares e análise de resíduos.",
                                "Economia: Previsão de demanda sazonal em varejo.",
                                "Ciência de Dados: Pré-processamento para machine learning em séries temporais.",
                                "Geografia: Análise de padrões climáticos sazonais.",
                                "Negócios: Planejamento de estoque baseado em sazonalidade."
                              ],
                              "realWorldApplication": "Em empresas de varejo, decompor vendas mensais de roupas de inverno revela picos sazonais em dezembro, permitindo otimizar estoque e campanhas de marketing, reduzindo custos em 15-20%."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.2.2",
                            "name": "Executar decomposição multiplicativa",
                            "description": "Aplicar decomposição multiplicativa (Y_t = T_t * S_t * C_t * R_t) para séries com variância crescente, comparando com a aditiva.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos de decomposição aditiva e multiplicativa",
                                  "subSteps": [
                                    "Estude a fórmula da decomposição aditiva: Y_t = T_t + S_t + C_t + R_t",
                                    "Estude a fórmula da decomposição multiplicativa: Y_t = T_t * S_t * C_t * R_t",
                                    "Identifique as diferenças: aditiva para variância constante, multiplicativa para variância crescente",
                                    "Revise componentes: Tendência (T_t), Sazonalidade (S_t), Cíclico (C_t), Resíduo (R_t)",
                                    "Analise gráficos de exemplo para visualizar variância crescente"
                                  ],
                                  "verification": "Explique verbalmente ou por escrito as diferenças entre os modelos e forneça um exemplo de quando usar cada um",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação de séries temporais (ex: livro 'Forecasting: Principles and Practice'), gráficos de exemplos em Python/R"
                                  ],
                                  "tips": "Use logaritmo da série para transformar multiplicativa em aditiva e facilitar visualização",
                                  "learningObjective": "Diferenciar modelos de decomposição e identificar pré-requisitos para multiplicativa",
                                  "commonMistakes": [
                                    "Confundir variância crescente com heterocedasticidade simples",
                                    "Ignorar normalização dos componentes sazonais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Avaliar a série temporal para aplicação da decomposição multiplicativa",
                                  "subSteps": [
                                    "Carregue a série temporal em software (R: ts(), Python: pandas Series)",
                                    "Plote a série e verifique visualmente se a variância aumenta com o tempo",
                                    "Calcule e plote a variância em janelas móveis para confirmação quantitativa",
                                    "Teste estacionariedade (ex: teste de Dickey-Fuller) e aplique log se necessário",
                                    "Confirme presença de sazonalidade via ACF/PACF ou decomposição preliminar"
                                  ],
                                  "verification": "Gere gráficos mostrando variância crescente e justifique por que multiplicativa é apropriada",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software R (pacote forecast) ou Python (statsmodels), conjunto de dados exemplo com variância crescente (ex: AirPassengers)"
                                  ],
                                  "tips": "Sempre plote log(Y_t) para séries com tendência exponencial",
                                  "learningObjective": "Diagnosticar adequadamente quando usar decomposição multiplicativa",
                                  "commonMistakes": [
                                    "Aplicar multiplicativa em séries com variância constante",
                                    "Não tratar missing values antes da análise"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar a decomposição multiplicativa",
                                  "subSteps": [
                                    "Prepare a série como objeto temporal com frequência sazonal correta",
                                    "Aplique a função de decomposição multiplicativa (R: decompose(ts, type='multiplicative'), Python: seasonal_decompose(multiplicative=True))",
                                    "Extraia e plote os componentes: tendência, sazonal, cíclico e resíduos",
                                    "Normalize o componente sazonal para somar zero ou média 1",
                                    "Reconstrua a série: multiplique os componentes e compare com original"
                                  ],
                                  "verification": "Os componentes multiplicados devem reconstruir a série original com erro mínimo (MSE < 5%)",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "RStudio ou Jupyter Notebook, dataset AirPassengers ou similar"
                                  ],
                                  "tips": "Use type='multiplicative' explicitamente; ajuste frequência se dados forem semanais/trimestrais",
                                  "learningObjective": "Implementar corretamente a decomposição multiplicativa em software",
                                  "commonMistakes": [
                                    "Esquecer de especificar tipo multiplicativo",
                                    "Interpretar resíduos não estacionários como aleatórios"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar com decomposição aditiva e validar resultados",
                                  "subSteps": [
                                    "Execute decomposição aditiva na mesma série para comparação",
                                    "Compare gráficos de componentes e resíduos entre os dois modelos",
                                    "Calcule métricas: MSE, MAE para ambos e escolha o melhor ajuste",
                                    "Analise resíduos: teste normalidade (Shapiro-Wilk) e autocorrelação (Ljung-Box)",
                                    "Interprete economicamente os componentes e sugira ajustes ou forecasting"
                                  ],
                                  "verification": "Relatório comparativo mostrando superioridade da multiplicativa via métricas e gráficos",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Mesmos datasets e software do Step 3, funções de métricas (mean(), rmse())"
                                  ],
                                  "tips": "Multiplicativa geralmente supera aditiva em séries econômicas com crescimento",
                                  "learningObjective": "Avaliar e validar a decomposição escolhida comparativamente",
                                  "commonMistakes": [
                                    "Não comparar modelos",
                                    "Ignorar heteroscedasticidade nos resíduos"
                                  ]
                                }
                              ],
                              "practicalExample": "Use o dataset AirPassengers (passageiros aéreos mensais 1949-1960): variância cresce com tempo. Aplique decomposição multiplicativa, observe sazonalidade crescente e compare com aditiva, onde resíduos multiplicativos são mais estacionários.",
                              "finalVerifications": [
                                "Explicar fórmula Y_t = T_t * S_t * C_t * R_t e condições de uso",
                                "Identificar variância crescente em gráfico fornecido",
                                "Executar decomposição em novo dataset com código correto",
                                "Comparar MSE aditiva vs multiplicativa",
                                "Interpretar componentes sazonais em contexto real",
                                "Validar resíduos como ruído branco"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de variância crescente (visual e quantitativa)",
                                "Correção na implementação da decomposição multiplicativa (código e fórmulas)",
                                "Qualidade da comparação com modelo aditivo (métricas e gráficos)",
                                "Profundidade na interpretação de componentes",
                                "Validação adequada de resíduos",
                                "Clareza no relatório final"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelos multiplicativos e logaritmos",
                                "Programação: Manipulação de dados em R/Python (pandas, forecast)",
                                "Economia: Análise de tendências em vendas e PIB",
                                "Finanças: Modelagem de volatilidade em séries financeiras",
                                "Ciência de Dados: Diagnóstico de séries temporais"
                              ],
                              "realWorldApplication": "Em empresas de varejo para decompor vendas sazonais com crescimento (ex: Black Friday), prevendo demanda futura; em finanças para modelar retornos de ações com volatilidade crescente, melhorando forecasts de risco."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.2.3",
                            "name": "Extrair e analisar o componente sazonal isolado",
                            "description": "Isolar o fator sazonal da decomposição e plotá-lo para validar padrões repetitivos, calculando índices sazonais médios.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Extrair o Componente Sazonal da Decomposição",
                                  "subSteps": [
                                    "Carregue o resultado da decomposição da série temporal (ex: objeto 'result' de statsmodels.tsa.seasonal.STL ou decompose).",
                                    "Acesse especificamente o atributo do componente sazonal (ex: result.seasonal para STL ou result.seasonal para decomposição clássica).",
                                    "Converta o componente extraído em um pandas.Series com índice temporal alinhado à série original.",
                                    "Inspecione os primeiros e últimos valores para confirmar extração correta (use .head() e .tail()).",
                                    "Salve o componente sazonal em uma variável dedicada para análise isolada."
                                  ],
                                  "verification": "Execute print(seasonal_component.head()) e confirme que os valores representam apenas variações sazonais sem tendência ou ruído.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Notebook Jupyter, bibliotecas pandas e statsmodels instaladas, dados da série temporal já decomposta.",
                                  "tips": "Use o método .copy() ao extrair para evitar modificações acidentais no objeto original.",
                                  "learningObjective": "Dominar a extração precisa do componente sazonal de resultados de decomposição para análise independente.",
                                  "commonMistakes": "Confundir o componente sazonal com trend ou resid; extrair dados não alinhados temporalmente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Plotar o Componente Sazonal Isolado",
                                  "subSteps": [
                                    "Configure o ambiente de plotagem com matplotlib.pyplot ou seaborn para visualização clara.",
                                    "Crie um gráfico de linha do componente sazonal ao longo do tempo, destacando múltiplos ciclos sazonais.",
                                    "Adicione rótulos aos eixos (tempo no x, valores sazonais no y), título e grade para legibilidade.",
                                    "Sobreponha linhas médias ou médias móveis para realçar padrões repetitivos.",
                                    "Salve ou exiba o plot para revisão inicial."
                                  ],
                                  "verification": "O gráfico deve mostrar oscilações repetitivas claras ao longo dos períodos sazonais sem elementos de tendência.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Bibliotecas matplotlib e pandas, componente sazonal extraído do step anterior.",
                                  "tips": "Use figsize=(12,6) para melhor visualização de séries longas e plt.xticks(rotation=45) para datas.",
                                  "learningObjective": "Visualizar o componente sazonal de forma eficaz para identificar padrões iniciais.",
                                  "commonMistakes": "Escala inadequada que mascara padrões; plotar sem alinhamento temporal correto."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Validar Padrões Repetitivos no Componente Sazonal",
                                  "subSteps": [
                                    "Divida o componente em períodos sazonais individuais (ex: agrupar por mês para sazonalidade anual).",
                                    "Compare visualmente ou numericamente os ciclos sazonais ao longo do tempo para consistência.",
                                    "Calcule estatísticas descritivas por período (média, desvio padrão) para quantificar repetitividade.",
                                    "Identifique anomalias ou desvios em ciclos específicos e documente observações.",
                                    "Crie um subplot comparando 3-5 ciclos selecionados para validação qualitativa."
                                  ],
                                  "verification": "Padrões repetitivos são validados se correlações entre ciclos forem >0.8 e visualmente sobrepostos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "pandas para groupby, matplotlib para subplots, componente sazonal plotado.",
                                  "tips": "Use resample('M').mean() para agregação mensal em séries diárias.",
                                  "learningObjective": "Desenvolver habilidades para validar consistência e repetitividade em componentes sazonais.",
                                  "commonMistakes": "Ignorar outliers que distorcem padrões; não comparar múltiplos ciclos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular Índices Sazonais Médios",
                                  "subSteps": [
                                    "Agrupe os valores sazonais por período sazonal (ex: médias mensais para todos os anos).",
                                    "Calcule a média de cada grupo sazonal (ex: df.groupby(df.index.month).mean()).",
                                    "Normalice os índices para que a soma seja 12 (anual) ou média 1, dependendo do modelo multiplicativo/aditivo.",
                                    "Crie um DataFrame ou Series com os índices médios e plote um gráfico de barras.",
                                    "Interprete os índices: valores >1 indicam picos sazonais."
                                  ],
                                  "verification": "Soma dos índices sazonais médios deve ser aproximadamente 12 (multiplicativo anual) e plot deve refletir padrões observados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "pandas para groupby e mean, matplotlib para gráfico de barras.",
                                  "tips": "Para modelo multiplicativo: índice = média_sazonal / média_global; verifique soma==12.",
                                  "learningObjective": "Computar e interpretar índices sazonais médios para quantificação de sazonalidade.",
                                  "commonMistakes": "Esquecer normalização; usar soma em vez de média para índices."
                                }
                              ],
                              "practicalExample": "Em dados de vendas mensais de um supermercado (2015-2020), extraia o componente sazonal via STL, plote mostrando picos em dezembro (Natal) e julho (férias), valide repetição em 6 anos com correlação 0.92, calcule índices médios como 1.5 para dezembro e 0.8 para fevereiro.",
                              "finalVerifications": [
                                "Plot do componente sazonal exibe padrões repetitivos claros em múltiplos ciclos.",
                                "Índices sazonais médios foram calculados e normalizados corretamente (soma ≈12).",
                                "Anomalias em padrões foram identificadas e explicadas.",
                                "Gráficos incluem rótulos, títulos e escalas adequadas.",
                                "Validação quantitativa confirma consistência (ex: correlação >0.8 entre ciclos).",
                                "Componente isolado não contém resíduos ou tendência visíveis."
                              ],
                              "assessmentCriteria": [
                                "Precisão na extração e isolamento do componente sazonal (sem contaminação).",
                                "Qualidade visual e interpretativa dos plots (legibilidade e insights corretos).",
                                "Correção matemática nos cálculos de índices médios e normalização.",
                                "Profundidade na validação de padrões repetitivos (qualitativa e quantitativa).",
                                "Documentação clara de observações, erros evitados e interpretações.",
                                "Eficiência no uso de ferramentas (tempo dentro do estimado)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estatística descritiva e análise de ciclos periódicos.",
                                "Programação: Manipulação de dados temporais em Python (pandas).",
                                "Economia/Negócios: Previsão de demanda sazonal em varejo.",
                                "Ciência Ambiental: Modelagem de padrões climáticos sazonais."
                              ],
                              "realWorldApplication": "Em empresas de varejo para ajustar estoques sazonais (ex: mais produtos de Natal baseado em índices 1.5); em meteorologia para prever chuvas sazonais; em finanças para modelar retornos de ações com ciclos anuais."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.2.3",
                        "name": "Técnicas Estatísticas para Confirmação de Sazonalidade",
                        "description": "Testes e medidas estatísticas para quantificar e testar a presença de padrões sazonais além da visualização.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.3.1",
                            "name": "Calcular médias e desvios sazonais",
                            "description": "Computar médias móveis sazonais e desvios padrão por período sazonal, testando diferenças significativas com ANOVA ou testes não paramétricos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e agrupar os dados por períodos sazonais",
                                  "subSteps": [
                                    "Identifique o período sazonal (ex.: 12 para dados mensais, 4 para trimestrais).",
                                    "Crie uma coluna no dataset indicando o período sazonal (ex.: mês ou trimestre).",
                                    "Agrupar os dados usando groupby no Python (pandas) ou aggregate no R.",
                                    "Verifique a integridade dos dados, removendo valores ausentes ou outliers iniciais.",
                                    "Salve o dataset agrupado para uso posterior."
                                  ],
                                  "verification": "Confira se o agrupamento resultou em grupos com pelo menos 5-10 observações cada e sem erros de indexação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software Python (pandas, numpy) ou R (dplyr), dataset de série temporal (ex.: CSV com datas e valores).",
                                  "tips": "Use funções como pd.to_datetime() para garantir formatação correta de datas.",
                                  "learningObjective": "Dominar a extração e agrupamento de componentes sazonais em séries temporais.",
                                  "commonMistakes": "Ignorar valores ausentes, levando a médias enviesadas; confundir frequência de dados com período sazonal."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular as médias sazonais móveis por período",
                                  "subSteps": [
                                    "Aplique a função mean() ou .mean() em cada grupo sazonal.",
                                    "Para médias móveis sazonais, use rolling window alinhado ao período (ex.: window=12 para mensal).",
                                    "Calcule a média simples por grupo se não for móvel.",
                                    "Armazene os resultados em um novo DataFrame ou vetor nomeado.",
                                    "Visualize as médias com um gráfico de linha ou boxplot por período."
                                  ],
                                  "verification": "Compare manualmente 2-3 grupos com cálculo manual para validar os resultados automatizados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python (pandas rolling()), R (zoo::rollmean()), planilha para validação manual.",
                                  "tips": "Alinhe a janela móvel corretamente para evitar vazamento de dados futuros.",
                                  "learningObjective": "Computar médias sazonais de forma precisa, diferenciando médias simples e móveis.",
                                  "commonMistakes": "Usar janela errada no rolling(), resultando em suavização inadequada; não centralizar a janela."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular desvios padrão sazonais por período",
                                  "subSteps": [
                                    "Aplique std() ou .std() em cada grupo sazonal nos dados originais.",
                                    "Para desvios móveis, use rolling std() com a mesma janela das médias.",
                                    "Registre os desvios em um DataFrame paralelo às médias.",
                                    "Calcule coeficiente de variação (desvio/média) para normalizar.",
                                    "Plote desvios ao lado das médias para inspeção visual."
                                  ],
                                  "verification": "Verifique se desvios são positivos e consistentes com a dispersão visual dos dados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Mesmo software do step 1, bibliotecas matplotlib/ggplot para plots.",
                                  "tips": "Use ddof=1 para desvio amostral em datasets pequenos.",
                                  "learningObjective": "Quantificar a variabilidade sazonal através de desvios padrão.",
                                  "commonMistakes": "Confundir desvio populacional (ddof=0) com amostral; ignorar grupos com poucas observações."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar diferenças significativas com ANOVA ou testes não paramétricos",
                                  "subSteps": [
                                    "Verifique normalidade por grupo (Shapiro-Wilk ou QQ-plot).",
                                    "Se normal, aplique ANOVA one-way (scipy.stats.f_oneway ou aov() no R).",
                                    "Se não normal, use Kruskal-Wallis (scipy.stats.kruskal).",
                                    "Interprete p-value (<0.05 indica diferenças significativas).",
                                    "Execute post-hoc tests (Tukey ou Dunn) se ANOVA significativo."
                                  ],
                                  "verification": "Confira se p-value é reportado corretamente e hipóteses nulas definidas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Python (scipy.stats), R (stats package), dados agrupados dos steps anteriores.",
                                  "tips": "Sempre teste normalidade primeiro para escolher o teste adequado.",
                                  "learningObjective": "Aplicar testes estatísticos apropriados para confirmar sazonalidade.",
                                  "commonMistakes": "Aplicar ANOVA sem verificar normalidade; não ajustar múltiplos testes."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar resultados e gerar relatório",
                                  "subSteps": [
                                    "Resuma médias, desvios e resultados de testes em tabela.",
                                    "Discuta implicações da sazonalidade detectada.",
                                    "Crie visualizações finais (série com médias sazonais sobrepostas).",
                                    "Documente suposições e limitações do análise.",
                                    "Exporte relatório em PDF ou Jupyter notebook."
                                  ],
                                  "verification": "O relatório deve incluir todos os valores chave e conclusões lógicas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Ferramentas de visualização (matplotlib, seaborn), exportadores (nbconvert).",
                                  "tips": "Use temas consistentes em plots para profissionalismo.",
                                  "learningObjective": "Sintetizar análise sazonal em insights acionáveis.",
                                  "commonMistakes": "Superinterpretar p-values baixos sem contexto prático; omitir limitações."
                                }
                              ],
                              "practicalExample": "Em um dataset de vendas mensais de varejo (60 meses), agrupe por mês (1-12). Calcule média de vendas para Janeiro (R$10k), desvio (R$2k), etc. ANOVA revela p<0.01, confirmando sazonalidade com picos em dezembro.",
                              "finalVerifications": [
                                "Médias e desvios calculados coincidem com validação manual em pelo menos 80% dos períodos.",
                                "Teste estatístico executado corretamente com p-value reportado.",
                                "Visualizações mostram padrões sazonais claros.",
                                "Relatório inclui interpretação e limitações.",
                                "Coeficientes de variação indicam estabilidade sazonal.",
                                "Post-hoc identifica períodos mais variáveis."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos (erro <1% em médias/desvios).",
                                "Escolha correta de teste estatístico baseada em normalidade.",
                                "Qualidade das visualizações (legendas, eixos claros).",
                                "Interpretação coerente dos resultados estatísticos.",
                                "Completude do relatório com todas as métricas.",
                                "Eficiência temporal (dentro do estimado total)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Manipulação de dados em Python/R.",
                                "Matemática: Estatística inferencial e probabilidade.",
                                "Economia: Análise de ciclos econômicos sazonais.",
                                "Visualização de Dados: Criação de gráficos informativos."
                              ],
                              "realWorldApplication": "Em previsão de demanda para varejo, identificando picos sazonais (ex.: Natal) para otimizar estoque; ou em meteorologia, confirmando variações mensais de temperatura para modelos climáticos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.3.2",
                            "name": "Aplicar testes estatísticos de sazonalidade",
                            "description": "Realizar testes como o de Kruskal-Wallis para diferenças sazonais ou análise de resíduos pós-decomposição para estacionariedade sazonal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os dados da série temporal para análise sazonal",
                                  "subSteps": [
                                    "Carregue o dataset da série temporal em um ambiente de programação como Python (usando pandas) ou R.",
                                    "Converta a coluna de datas para formato datetime e defina o índice temporal.",
                                    "Agrupe os dados por períodos sazonais (ex: meses, trimestres) e verifique valores ausentes ou outliers.",
                                    "Realize plotagens iniciais (série temporal, boxplots por estação) para visual inspeção.",
                                    "Trate valores ausentes por interpolação ou remoção, se necessário."
                                  ],
                                  "verification": "Dados carregados corretamente, índice temporal definido, plots gerados sem erros e dados limpos confirmados por sumário estatístico.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python com pandas, matplotlib/seaborn; ou R com tidyverse; dataset de série temporal (ex: AirPassengers)."
                                  ],
                                  "tips": "Sempre use freq='M' para dados mensais no pandas para alinhar sazonalidade.",
                                  "learningObjective": "Dominar a preparação de dados temporais para testes sazonais.",
                                  "commonMistakes": [
                                    "Ignorar frequência temporal levando a erros de indexação; não tratar outliers que distorcem testes."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar decomposição da série temporal e análise inicial de resíduos",
                                  "subSteps": [
                                    "Aplique decomposição aditiva ou multiplicativa usando statsmodels.tsa.seasonal_decompose em Python ou decompose() em R.",
                                    "Extraia os resíduos da decomposição e plote-os para inspeção visual.",
                                    "Teste estacionariedade dos resíduos originais e sazonalmente ajustados usando Augmented Dickey-Fuller (ADF).",
                                    "Compare resíduos antes e após ajuste sazonal para evidência preliminar.",
                                    "Salve os resíduos em um DataFrame para testes subsequentes."
                                  ],
                                  "verification": "Decomposição plotada com componentes claros (tendência, sazonal, residual); teste ADF executado com p-valor reportado.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python: statsmodels; R: forecast package; dataset preparado do Step 1."
                                  ],
                                  "tips": "Use model='additive' para séries sem variância crescente; inspecione plots de resíduos para autocorrelação.",
                                  "learningObjective": "Compreender decomposição e identificar resíduos para testes de sazonalidade.",
                                  "commonMistakes": [
                                    "Escolher modelo errado de decomposição (additive vs multiplicative); ignorar não-estacionariedade nos resíduos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar teste Kruskal-Wallis para detectar diferenças sazonais",
                                  "subSteps": [
                                    "Agrupe os dados ou resíduos por grupos sazonais (ex: 12 meses).",
                                    "Execute o teste Kruskal-Wallis usando scipy.stats.kruskal em Python ou kruskal.test em R.",
                                    "Calcule estatística do teste, p-valor e interprete (p < 0.05 indica diferenças sazonais).",
                                    "Realize testes post-hoc (ex: Dunn's test) se significativo, para pares específicos.",
                                    "Gere boxplots por grupo para suporte visual."
                                  ],
                                  "verification": "Resultado do teste reportado com estatística H, p-valor e interpretação; post-hoc se aplicável.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python: scipy.stats; R: stats, PMCMRplus; resíduos do Step 2."
                                  ],
                                  "tips": "Kruskal-Wallis é não-paramétrico, ideal para dados não-normais comuns em séries temporais.",
                                  "learningObjective": "Executar e interpretar teste não-paramétrico para sazonalidade entre grupos.",
                                  "commonMistakes": [
                                    "Não verificar normalidade antes (mas Kruskal é robusto); ignorar múltiplos testes sem correção."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados e validar confirmação de sazonalidade",
                                  "subSteps": [
                                    "Integre resultados: Kruskal-Wallis significativo + resíduos estacionários pós-ajuste indicam sazonalidade.",
                                    "Calcule efeito tamanho (eta-squared) para magnitude das diferenças.",
                                    "Compare com critérios alternativos (ex: ACF/PACF para autocorrelação sazonal).",
                                    "Documente conclusões em relatório com tabelas e plots.",
                                    "Teste sensibilidade removendo outliers ou sub-períodos."
                                  ],
                                  "verification": "Relatório gerado com interpretação unificada, plots e recomendações; validação cruzada realizada.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Resultados dos steps anteriores; Jupyter Notebook ou R Markdown para relatório."
                                  ],
                                  "tips": "Sempre contextualize p-valor com tamanho da amostra e poder estatístico.",
                                  "learningObjective": "Sintetizar evidências múltiplas para confirmação robusta de sazonalidade.",
                                  "commonMistakes": [
                                    "Sobreinterpretar p-valor baixo sem contexto prático; negligenciar validação cruzada."
                                  ]
                                }
                              ],
                              "practicalExample": "Analise dados mensais de passageiros aéreos (dataset AirPassengers). Decomponha a série, aplique Kruskal-Wallis nos valores mensais para detectar picos sazonais de verão (p < 0.05 confirmado), e verifique resíduos ADF para estacionariedade pós-ajuste.",
                              "finalVerifications": [
                                "Testes executados sem erros de código e resultados reproduzíveis.",
                                "p-valores e estatísticas corretamente calculados e reportados.",
                                "Interpretação consistente: sazonalidade confirmada ou refutada com evidências.",
                                "Plots e relatórios visuais claros e profissionais.",
                                "Validação com método alternativo (ex: ACF) alinhada.",
                                "Sensibilidade testada e robustez confirmada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na preparação e decomposição de dados (sem erros de indexação).",
                                "Correta aplicação e interpretação de Kruskal-Wallis (p-valor < 0.05 detectado adequadamente).",
                                "Análise de resíduos com ADF mostrando estacionariedade pós-sazonal.",
                                "Relatório integrado com conclusões lógicas e suporte visual.",
                                "Uso eficiente de ferramentas e código limpo/commentado.",
                                "Identificação de limitações (ex: tamanho amostral) e sugestões futuras."
                              ],
                              "crossCurricularConnections": [
                                "Economia: Previsão de demanda sazonal em varejo.",
                                "Biologia: Padrões sazonais em populações ecológicas.",
                                "Climatologia: Detecção de ciclos sazonais em dados meteorológicos.",
                                "Finanças: Análise de retornos sazonais em ações.",
                                "Saúde Pública: Sazonalidade em incidência de doenças infecciosas."
                              ],
                              "realWorldApplication": "Em empresas de varejo, aplicar esses testes para confirmar sazonalidade em vendas de produtos como roupas de inverno, otimizando estoque e campanhas de marketing com previsões precisas baseadas em evidências estatísticas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.3",
                    "name": "Decomposição de Séries Temporais Sazonais",
                    "description": "Métodos aditivos e multiplicativos para separar tendência, sazonalidade e resíduos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.3.1",
                        "name": "Componentes da Decomposição de Séries Temporais Sazonais",
                        "description": "Identificação e compreensão dos componentes principais: tendência, sazonalidade e resíduos, que formam a estrutura de uma série temporal sazonal.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.1.1",
                            "name": "Identificar a componente de tendência",
                            "description": "Reconhecer e descrever a tendência como o componente de longo prazo que representa a direção geral da série temporal, utilizando gráficos e métodos de suavização como médias móveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Componente de Tendência",
                                  "subSteps": [
                                    "Defina tendência como o componente de longo prazo que captura a direção geral da série temporal, ignorando flutuações sazonais e irregulares.",
                                    "Estude exemplos de séries temporais com tendências crescentes, decrescentes e estacionárias.",
                                    "Compare tendência com outros componentes: sazonal (padrões repetitivos) e residual (ruído).",
                                    "Revise a fórmula matemática básica: Y_t = Tendência_t + Sazonal_t + Residual_t.",
                                    "Anote diferenças entre tendência determinística (suave) e estocástica (com variação aleatória)."
                                  ],
                                  "verification": "Escreva uma definição precisa da tendência em suas próprias palavras e identifique corretamente em 3 exemplos fornecidos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro-texto de séries temporais, vídeo introdutório (ex: Khan Academy), caderno de anotações.",
                                  "tips": "Use analogias como 'tendência é a linha reta que a série segue ao longo do tempo, filtrando ruídos'.",
                                  "learningObjective": "Explicar verbalmente o papel da tendência na decomposição de séries temporais.",
                                  "commonMistakes": "Confundir tendência com sazonalidade (ex: achar que picos anuais são tendência)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Visualizar a Série Temporal em Gráficos",
                                  "subSteps": [
                                    "Colete ou baixe um conjunto de dados de série temporal sazonal (ex: vendas mensais).",
                                    "Plote o gráfico de linha da série original usando software como Excel, Python (Matplotlib) ou R.",
                                    "Identifique visualmente padrões de longo prazo: crescimento, declínio ou estabilidade.",
                                    "Marque pontos suspeitos de tendência em um overlay manual no gráfico.",
                                    "Ajuste escalas e adicione títulos/legendas para clareza."
                                  ],
                                  "verification": "O gráfico plotado mostra claramente a direção geral da série, com tendência discernível a olho nu.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de plotagem (Excel/Python/R), dataset exemplo (ex: AirPassengers do R).",
                                  "tips": "Use gráficos de linha conectados para séries temporais; evite barras que mascaram tendências suaves.",
                                  "learningObjective": "Interpretar graficamente a direção geral de uma série temporal antes de qualquer processamento.",
                                  "commonMistakes": "Ignorar outliers que distorcem a percepção visual da tendência."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Métodos de Suavização para Extrair a Tendência",
                                  "subSteps": [
                                    "Calcule médias móveis simples (ex: janela de 12 períodos para dados mensais).",
                                    "Implemente em software: use função moving_average no Pandas (Python) ou ma() no R.",
                                    "Plote a média móvel sobre a série original para visualizar a tendência isolada.",
                                    "Teste diferentes janelas de suavização (ex: 6, 12, 24) e compare resultados.",
                                    "Ajuste para tendência multiplicativa se a série for não-estacionária (Y_t * Tendência_t)."
                                  ],
                                  "verification": "A curva de tendência suavizada alinha-se com a direção visual da série original sem capturar sazonalidade.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python (Pandas/Matplotlib), R, ou Excel com fórmulas de média móvel; dataset da série temporal.",
                                  "tips": "Escolha janela ímpar para centralizar a média móvel e reduzir viés.",
                                  "learningObjective": "Executar e validar extração de tendência via suavização em dados reais.",
                                  "commonMistakes": "Usar janela muito pequena (captura sazonalidade) ou muito grande (perde tendência real)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Descrever e Interpretar a Componente de Tendência",
                                  "subSteps": [
                                    "Descreva a forma da tendência: linear crescente, exponencial, etc.",
                                    "Quantifique: calcule inclinação via regressão linear simples na tendência suavizada.",
                                    "Compare com série original: explique como remove sazonalidade.",
                                    "Preveja próximo período baseado na tendência (extrapole linearmente).",
                                    "Documente em relatório: gráfico + descrição narrativa."
                                  ],
                                  "verification": "Relatório escrito descreve corretamente a tendência e inclui gráfico com overlay.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Gráficos gerados anteriormente, ferramenta de regressão (lm() no R ou scipy.stats.linregress).",
                                  "tips": "Use termos precisos: 'tendência ascendente de 2% ao mês' em vez de 'aumentando'.",
                                  "learningObjective": "Articular insights acionáveis da componente de tendência extraída.",
                                  "commonMistakes": "Atribuir causalidade à tendência sem evidência (ex: 'devido a marketing')."
                                }
                              ],
                              "practicalExample": "Usando dados de passageiros aéreos mensais (1949-1960): plote a série, aplique média móvel de 12 meses, observe tendência crescente exponencial de ~5% ao ano, ignorando picos sazonais de verão.",
                              "finalVerifications": [
                                "Gráfico da tendência suavizada alinha-se com direção de longo prazo da série original.",
                                "Descrição escrita identifica corretamente crescente/decrescente/estacionária.",
                                "Método de suavização escolhido justificado pela periodicidade sazonal.",
                                "Previsão simples baseada na tendência é coerente.",
                                "Diferenças entre tendência e sazonalidade explicadas.",
                                "Nenhum resíduo sazonal visível na tendência extraída."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definição correta da tendência (30%).",
                                "Qualidade da visualização: gráficos claros e informativos (20%).",
                                "Correção técnica: suavização aplicada adequadamente (25%).",
                                "Interpretação profunda: descrição quantitativa e qualitativa (15%).",
                                "Documentação: relatório completo e bem estruturado (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Regressão linear para modelar tendência.",
                                "Economia: Análise de crescimento econômico em séries de PIB.",
                                "Computação: Programação em Python/R para análise de dados.",
                                "Física: Modelagem de tendências em dados climáticos de temperatura."
                              ],
                              "realWorldApplication": "Em empresas de varejo, identificar tendência em vendas mensais para planejar estoques e prever demanda futura, ajustando estratégias de longo prazo apesar de sazonalidades como Black Friday."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.1.2",
                            "name": "Identificar a componente sazonal",
                            "description": "Detectar padrões repetitivos sazonais em intervalos fixos (mensal, trimestral), calculando índices sazonais médios a partir de dados históricos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e Explorar os Dados Históricos da Série Temporal",
                                  "subSteps": [
                                    "Colete dados históricos de uma série temporal com pelo menos 3-5 anos de observações (ex: vendas mensais).",
                                    "Identifique o intervalo sazonal (mensal, trimestral) e verifique periodicidade fixa.",
                                    "Calcule a média geral da série (média de todos os valores).",
                                    "Plote a série temporal para visualizar padrões repetitivos sazonais.",
                                    "Remova outliers iniciais se necessário, documentando ajustes."
                                  ],
                                  "verification": "Gráfico da série temporal mostra padrões repetitivos claros em intervalos fixos; média geral calculada corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Planilha Excel ou software R/Python (pandas, matplotlib)",
                                    "Dados históricos em CSV"
                                  ],
                                  "tips": "Use gráficos de linha com marcações sazonais para facilitar a visualização.",
                                  "learningObjective": "Compreender a estrutura dos dados e identificar evidências visuais de sazonalidade.",
                                  "commonMistakes": "Ignorar dados incompletos ou assumir periodicidade sem verificação visual."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Médias Sazonais por Período",
                                  "subSteps": [
                                    "Agrupe os dados por período sazonal (ex: média de janeiro de todos os anos).",
                                    "Calcule a média aritmética para cada período sazonal (S_t para t=1 a 12 em dados mensais).",
                                    "Registre as médias em uma tabela organizada por período.",
                                    "Compare as médias sazonais com a média geral para detectar desvios.",
                                    "Salve a tabela de médias sazonais para uso posterior."
                                  ],
                                  "verification": "Tabela completa com médias sazonais calculadas; desvios visíveis em relação à média geral.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Excel ou script Python/R",
                                    "Tabela de dados preparada do Step 1"
                                  ],
                                  "tips": "Use funções como AVERAGEIF no Excel para agrupamentos rápidos.",
                                  "learningObjective": "Dominar o cálculo de componentes sazonais locais a partir de agrupamentos temporais.",
                                  "commonMistakes": "Confundir ordem dos períodos ou incluir anos incompletos nas médias."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Índices Sazonais Individuais",
                                  "subSteps": [
                                    "Para cada observação, calcule o índice sazonal: I_t = Y_t / média geral, onde Y_t é o valor observado.",
                                    "Ajuste para cada período: índice relativo = média sazonal / média geral.",
                                    "Crie uma coluna de índices para toda a série.",
                                    "Verifique se os índices capturam picos e vales sazonais.",
                                    "Plote os índices contra os períodos para inspeção visual."
                                  ],
                                  "verification": "Coluna de índices gerada; gráfico mostra variação sazonal sem tendência.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Software de análise (Excel, R, Python)",
                                    "Dados e médias do Step 2"
                                  ],
                                  "tips": "Normalize dividindo pela média móvel se tendência forte, mas foque em sazonal puro aqui.",
                                  "learningObjective": "Aplicar fórmula de índice sazonal para quantificar desvios periódicos.",
                                  "commonMistakes": "Usar divisão errada (ex: por média sazonal em vez de geral) ou ignorar normalização."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Computar Índices Sazonais Médios e Validar",
                                  "subSteps": [
                                    "Média dos índices sazonais para cada período ao longo dos anos (média de todos os I_jan, etc.).",
                                    "Ajuste os índices médios para somarem exatamente o número de períodos (ex: 12 para mensal).",
                                    "Plote a componente sazonal suavizada.",
                                    "Teste estatístico simples: verifique se variância sazonal é significativa.",
                                    "Documente a componente sazonal final em tabela e gráfico."
                                  ],
                                  "verification": "Índices médios somam ao número de períodos; gráfico reproduz padrões observados.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Ferramentas de cálculo",
                                    "Índices individuais do Step 3"
                                  ],
                                  "tips": "Ajuste multiplicativo: multiplique por (k / soma dos índices), onde k é número de períodos.",
                                  "learningObjective": "Finalizar a extração da componente sazonal média e garantir consistência.",
                                  "commonMistakes": "Não normalizar a soma dos índices, levando a distorções na decomposição."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e Refinar a Componente Sazonal",
                                  "subSteps": [
                                    "Reconstrua a série multiplicando tendência por componente sazonal e compare com original.",
                                    "Calcule resíduos e verifique ausência de padrões sazonais nos resíduos.",
                                    "Aplique suavização (média móvel) se índices voláteis.",
                                    "Documente suposições (multiplicativo vs aditivo) e resultados.",
                                    "Salve relatório com gráficos e tabelas finais."
                                  ],
                                  "verification": "Resíduos sem sazonalidade residual; reconstrução se alinha ao original.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráficos comparativos",
                                    "Componentes finais"
                                  ],
                                  "tips": "Use modelo aditivo se variância constante, multiplicativo se proporcional.",
                                  "learningObjective": "Validar robustez da componente sazonal extraída.",
                                  "commonMistakes": "Aceitar índices sem checagem de soma ou resíduos."
                                }
                              ],
                              "practicalExample": "Em dados de vendas mensais de sorvetes (2018-2022), calcule índices sazonais: pico em julho (índice médio 1.8), vale em janeiro (0.6), somando 12. Use para prever demanda futura ajustada por sazonalidade.",
                              "finalVerifications": [
                                "Índices sazonais médios somam exatamente ao número de períodos (ex: 12 para mensal).",
                                "Gráfico da componente sazonal reproduz fielmente os padrões repetitivos da série original.",
                                "Resíduos da decomposição preliminar não exibem sazonalidade visual.",
                                "Médias sazonais mostram desvios consistentes da média geral.",
                                "Todos cálculos documentados em tabela rastreável.",
                                "Validação cruzada: aplique em subconjunto de dados e compare."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos cálculos de médias e índices (erro <1%).",
                                "Visualizações claras e interpretáveis (gráficos rotulados).",
                                "Normalização correta dos índices médios.",
                                "Identificação adequada de padrões sazonais vs ruído.",
                                "Documentação completa de passos e suposições.",
                                "Aplicação consistente do modelo (aditivo/multiplicativo)."
                              ],
                              "crossCurricularConnections": [
                                "Economia: Análise de ciclos econômicos sazonais em PIB trimestral.",
                                "Meteorologia: Decomposição de temperaturas médias mensais.",
                                "Biologia: Padrões sazonais em populações de espécies migratórias.",
                                "Finanças: Ajuste sazonal em retornos de ações setoriais."
                              ],
                              "realWorldApplication": "Empresas de varejo usam índices sazonais para estoque otimizado (ex: mais sorvetes no verão), bancos ajustam empréstimos por sazonalidade agrícola, e governos planejam energia baseada em picos de consumo sazonal."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.1.3",
                            "name": "Identificar a componente de resíduos",
                            "description": "Analisar os resíduos como a parte aleatória e não explicada após remoção de tendência e sazonalidade, verificando estacionariedade e ausência de autocorrelação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a decomposição da série temporal",
                                  "subSteps": [
                                    "Obtenha a série temporal já decomposta em tendência, sazonalidade e resíduos.",
                                    "Confirme que a decomposição foi realizada corretamente (ex: multiplicativa ou aditiva).",
                                    "Plote as componentes individuais para visual inspeção.",
                                    "Calcule a série original como soma das componentes para validação.",
                                    "Documente os parâmetros usados na decomposição (ex: período sazonal)."
                                  ],
                                  "verification": "A soma das componentes reconstrói a série original com erro mínimo (RMSE < 5%).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Software de análise (Python com statsmodels ou R)",
                                    "Jupyter Notebook ou RStudio",
                                    "Dados da série temporal"
                                  ],
                                  "tips": "Use decomposição STL para séries complexas; visualize múltiplos plots em uma grade.",
                                  "learningObjective": "Compreender como os resíduos surgem após remoção de tendência e sazonalidade.",
                                  "commonMistakes": [
                                    "Ignorar o tipo de decomposição (aditiva vs. multiplicativa)",
                                    "Não validar a reconstrução da série original"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Extrair e visualizar a componente de resíduos",
                                  "subSteps": [
                                    "Extraia o vetor de resíduos da decomposição.",
                                    "Gere um gráfico de linha dos resíduos ao longo do tempo.",
                                    "Plote o histograma dos resíduos para checar normalidade.",
                                    "Calcule estatísticas descritivas: média, variância e desvio padrão.",
                                    "Verifique visualmente se os resíduos oscilam aleatoriamente ao redor de zero."
                                  ],
                                  "verification": "Média dos resíduos próxima de zero (abs(média) < 0.01) e variância estável.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Bibliotecas: statsmodels, matplotlib/seaborn (Python) ou ggplot2 (R)",
                                    "Dados decompostos"
                                  ],
                                  "tips": "Padronize os resíduos dividindo pela média para melhor visualização.",
                                  "learningObjective": "Identificar visualmente os resíduos como ruído aleatório não explicado.",
                                  "commonMistakes": [
                                    "Confundir resíduos com outra componente",
                                    "Escalas inadequadas nos plots"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Testar estacionariedade dos resíduos",
                                  "subSteps": [
                                    "Aplique o teste Augmented Dickey-Fuller (ADF).",
                                    "Interprete o p-valor: deve ser < 0.05 para rejeitar não-estacionariedade.",
                                    "Execute teste KPSS como complemento (p-valor > 0.05 indica estacionariedade).",
                                    "Plote resíduos diferenciados se necessário.",
                                    "Registre estatísticas: estatística ADF, p-valor e lags usados."
                                  ],
                                  "verification": "Teste ADF: p-valor < 0.05 e KPSS: p-valor > 0.05.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "statsmodels.tsa.stattools.adfuller (Python) ou ur.df (R)",
                                    "Notebook de código"
                                  ],
                                  "tips": "Use lags automáticos ('auto') no ADF para robustez.",
                                  "learningObjective": "Verificar se resíduos não possuem tendência ou variância não constante.",
                                  "commonMistakes": [
                                    "Interpretar errado o p-valor do ADF",
                                    "Não testar múltiplos lags"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar ausência de autocorrelação nos resíduos",
                                  "subSteps": [
                                    "Calcule a função de autocorrelação (ACF) até 20 lags.",
                                    "Plote o gráfico ACF: barras dentro das bandas de confiança.",
                                    "Aplique teste Ljung-Box: p-valor > 0.05 indica ausência de autocorrelação.",
                                    "Verifique PACF para confirmação.",
                                    "Conclua se resíduos são ruído branco (independentes e identicamente distribuídos)."
                                  ],
                                  "verification": "Gráfico ACF sem picos significativos e Ljung-Box p-valor > 0.05.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "statsmodels.tsa.stattools.acf e statsmodels.stats.diagnostic.acorr_ljungbox (Python)",
                                    "Correlogramas"
                                  ],
                                  "tips": "Foque nos primeiros 10 lags, comuns em séries sazonais.",
                                  "learningObjective": "Confirmar que resíduos não retêm estrutura temporal explicável pelo modelo.",
                                  "commonMistakes": [
                                    "Ignorar bandas de confiança no ACF",
                                    "Usar poucos lags no teste"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma série de vendas mensais de varejo (ex: dados de supermercado), após decompor com statsmodels em Python, extraia resíduos, plote ACF mostrando ausência de picos, e confirme ADF p-valor=0.01, indicando ruído branco adequado para forecasting.",
                              "finalVerifications": [
                                "Resíduos têm média zero e variância constante.",
                                "Teste ADF confirma estacionariedade (p<0.05).",
                                "ACF e Ljung-Box mostram ausência de autocorrelação.",
                                "Reconstrução da série original é precisa.",
                                "Não há padrões visuais nos plots de resíduos.",
                                "Resíduos são independentes e normalmente distribuídos."
                              ],
                              "assessmentCriteria": [
                                "Correta extração e visualização dos resíduos (plots claros).",
                                "Aplicação precisa de testes estatísticos com interpretação correta.",
                                "Documentação completa de resultados (p-valores, gráficos).",
                                "Identificação de resíduos como componente aleatória não explicada.",
                                "Conclusão sobre adequação da decomposição.",
                                "Uso apropriado de software e validação cruzada."
                              ],
                              "crossCurricularConnections": [
                                "Estatística Inferencial (testes de hipóteses ADF, Ljung-Box).",
                                "Programação e Ciência de Dados (Python/R para séries temporais).",
                                "Economia e Finanças (previsão de séries econômicas).",
                                "Matemática Aplicada (funções de autocorrelação).",
                                "Machine Learning (validação de resíduos em modelos preditivos)."
                              ],
                              "realWorldApplication": "Em empresas de e-commerce, identificar resíduos em séries de vendas valida modelos de forecasting, permitindo previsões confiáveis de estoque e reduzindo perdas por sobre ou subestoque."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.3.2",
                        "name": "Decomposição Aditiva",
                        "description": "Método que assume soma dos componentes (tendência + sazonalidade + resíduos), adequado para séries com variações constantes.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.2.1",
                            "name": "Entender o modelo aditivo",
                            "description": "Compreender a equação Y_t = T_t + S_t + R_t, onde Y_t é o valor observado, T_t tendência, S_t sazonalidade e R_t resíduo, e suas premissas de variância constante.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e Definir os Componentes Básicos da Série Temporal",
                                  "subSteps": [
                                    "Estude a definição de Y_t como o valor observado na série temporal em tempo t.",
                                    "Aprenda T_t como a tendência de longo prazo, representando a direção geral dos dados.",
                                    "Compreenda S_t como o componente sazonal, padrões repetitivos em intervalos fixos.",
                                    "Defina R_t como o resíduo ou irregular, variações aleatórias não explicadas pelos outros componentes.",
                                    "Revise exemplos visuais de cada componente em gráficos de séries temporais."
                                  ],
                                  "verification": "Liste e defina corretamente cada componente com um exemplo breve para cada um.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Gráficos de séries temporais de exemplo (ex: dados de vendas mensais)",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use desenhos simples para visualizar cada componente separadamente antes de combiná-los.",
                                  "learningObjective": "Dominar as definições precisas de Y_t, T_t, S_t e R_t.",
                                  "commonMistakes": [
                                    "Confundir sazonalidade com tendência cíclica",
                                    "Ignorar que resíduos capturam ruído aleatório"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender a Equação Aditiva Y_t = T_t + S_t + R_t",
                                  "subSteps": [
                                    "Escreva a equação e explique como a soma aditiva modela a série observada.",
                                    "Simule a equação com números simples: escolha valores para T, S, R e calcule Y.",
                                    "Compare com decomposição multiplicativa para destacar diferenças (aditiva assume variância constante).",
                                    "Pratique reescrevendo Y_t isolando cada componente: T_t = Y_t - S_t - R_t, etc.",
                                    "Crie um fluxograma mostrando como os componentes se somam para formar Y_t."
                                  ],
                                  "verification": "Calcule Y_t a partir de valores dados de T_t, S_t e R_t, e isole um componente corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora ou planilha Excel/Google Sheets",
                                    "Dataset simples de 12 períodos"
                                  ],
                                  "tips": "Sempre normalize sazonalidade para somar zero em um ciclo completo.",
                                  "learningObjective": "Aplicar a equação aditiva para decompor e recompor uma série temporal.",
                                  "commonMistakes": [
                                    "Assumir multiplicação em vez de soma",
                                    "Não centralizar a sazonalidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar as Premissas do Modelo Aditivo",
                                  "subSteps": [
                                    "Identifique a premissa chave: variância constante (homocedasticidade) dos resíduos ao longo do tempo.",
                                    "Discuta additividade: componentes independentes e soma linear.",
                                    "Aprenda sobre estacionariedade dos resíduos após decomposição.",
                                    "Teste premissas com gráficos: plot de resíduos vs. tempo para checar variância constante.",
                                    "Compare cenários onde o modelo aditivo falha (ex: variância crescente → use multiplicativo)."
                                  ],
                                  "verification": "Explique por que variância constante é crucial e dê um exemplo de violação.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Software gratuito como Python (statsmodels) ou R",
                                    "Gráficos de resíduos de exemplo"
                                  ],
                                  "tips": "Verifique premissas visualmente antes de modelar; use testes estatísticos como Breusch-Pagan se avançado.",
                                  "learningObjective": "Avaliar quando o modelo aditivo é apropriado baseado em suas premissas.",
                                  "commonMistakes": [
                                    "Aplicar aditivo a séries com variância heterogênea",
                                    "Confundir resíduos com erros de previsão"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Visualizar e Interpretar uma Decomposição Aditiva",
                                  "subSteps": [
                                    "Colete um dataset sazonal simples e plote a série original.",
                                    "Estime componentes usando médias móveis para tendência e sazonalidade.",
                                    "Gere gráficos de decomposição: painéis para Y_t, T_t, S_t e R_t.",
                                    "Interprete: identifique padrões na tendência, ciclos sazonais e ruído nos resíduos.",
                                    "Valide: some os componentes e verifique se reconstrói Y_t aproximadamente."
                                  ],
                                  "verification": "Produza um gráfico de decomposição e rotule corretamente cada componente.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Python com pandas/matplotlib ou Excel",
                                    "Dataset público como AirPassengers ou vendas sazonais"
                                  ],
                                  "tips": "Use janela de média móvel compatível com o período sazonal (ex: 12 para mensal).",
                                  "learningObjective": "Interpretar visualmente uma decomposição aditiva completa.",
                                  "commonMistakes": [
                                    "Sobre-suavizar tendência removendo sazonalidade",
                                    "Ignorar outliers nos resíduos"
                                  ]
                                }
                              ],
                              "practicalExample": "Decomponha dados mensais de vendas de sorvetes: T_t mostra crescimento anual devido a expansão de lojas; S_t captura picos no verão (julho/agosto); R_t reflete variações climáticas inesperadas ou promoções; some para reconstruir Y_t com variância estável.",
                              "finalVerifications": [
                                "Explique verbalmente a equação Y_t = T_t + S_t + R_t com exemplos numéricos.",
                                "Identifique componentes em um gráfico de série temporal fornecido.",
                                "Diferencie modelo aditivo de multiplicativo com base em variância.",
                                "Gere uma decomposição simples de um dataset curto.",
                                "Liste 3 premissas e como violá-las afeta o modelo.",
                                "Reconstrua Y_t a partir de componentes estimados com erro <5%."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e equação (100% correto).",
                                "Capacidade de aplicar em exemplo prático com cálculos exatos.",
                                "Compreensão clara das premissas, especialmente variância constante.",
                                "Qualidade da visualização e interpretação de gráficos.",
                                "Identificação correta de erros comuns e como evitá-los.",
                                "Criatividade em conexões reais e verificações finais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear e funções aditivas.",
                                "Economia: Previsão de demanda e análise de ciclos econômicos.",
                                "Ciência de Dados: Modelagem em machine learning para forecasting.",
                                "Estatística: Testes de estacionariedade e análise de resíduos.",
                                "Negócios: Planejamento de estoque sazonal."
                              ],
                              "realWorldApplication": "Em empresas de varejo, o modelo aditivo decompõe vendas sazonais para prever estoque de produtos como roupas de inverno, ajustando tendência de crescimento pelo market share e removendo ruído de eventos aleatórios para decisões precisas de supply chain."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.2.2",
                            "name": "Aplicar decomposição aditiva manualmente",
                            "description": "Calcular tendência por médias móveis, índices sazonais por médias ajustadas e resíduos por subtração, usando planilhas ou código simples em R.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os dados da série temporal",
                                  "subSteps": [
                                    "Colete uma série temporal sazonal com pelo menos 3-4 períodos completos (ex: 36 meses).",
                                    "Organize os dados em uma coluna de tempo (ex: datas) e outra de valores observados em uma planilha ou vetor em R.",
                                    "Identifique o período sazonal (ex: 12 para mensal).",
                                    "Visualize os dados com um gráfico de linha para confirmar sazonalidade.",
                                    "Trate valores ausentes ou outliers, se houver."
                                  ],
                                  "verification": "Dados organizados em tabela ou vetor com gráfico plotado mostrando padrão sazonal claro.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Planilha (Excel/Google Sheets) ou R/RStudio com pacote ggplot2 ou base plot(); conjunto de dados exemplo (ex: vendas mensais).",
                                  "tips": "Use datas como fator para médias móveis; comece com dados reais ou simulados para prática.",
                                  "learningObjective": "Entender a estrutura de uma série temporal sazonal e prepará-la para decomposição.",
                                  "commonMistakes": "Ignorar o comprimento do período sazonal; não visualizar dados inicialmente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a tendência usando médias móveis",
                                  "subSteps": [
                                    "Calcule a média móvel simples (MMS) com janela igual ao período sazonal (ex: média de 12 meses).",
                                    "Em planilha: use função MÉDIA em janela deslizante; em R: use filter() do pacote forecast ou loop manual.",
                                    "Centralize a MMS se necessário (média das MMS adjacentes para pontos centrais).",
                                    "Plote a MMS sobre a série original para visualizar a tendência suave.",
                                    "Salve a coluna de tendência para próximos passos."
                                  ],
                                  "verification": "MMS calculada corretamente com valores suaves e plotada alinhada à tendência geral dos dados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilhas com fórmulas DESLOC ou PROCV; R com dplyr ou zoo para rollmean().",
                                  "tips": "Para janela ímpar, centralize naturalmente; teste com dados pequenos primeiro.",
                                  "learningObjective": "Dominar o cálculo de tendência via suavização por médias móveis.",
                                  "commonMistakes": "Usar janela errada (não igual ao período); não centralizar MMS para séries pares."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular os índices sazonais por médias ajustadas",
                                  "subSteps": [
                                    "Divida os valores observados pela tendência para obter série sazonal+resíduo.",
                                    "Agrupe por período sazonal (ex: médias por mês) e calcule médias sazonais.",
                                    "Ajuste multiplicativamente pela média geral para índices somarem 1 (ou 100%).",
                                    "Em planilha: use MÉDIA.SE; em R: aggregate() ou dplyr group_by().",
                                    "Repita o índice para todo período e plote."
                                  ],
                                  "verification": "Índices sazonais calculados, somando aproximadamente 1 por período, plotados mostrando picos/vales sazonais.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Planilhas com fórmulas MÉDIA.SE e SE; R com dplyr::group_by() e summarise().",
                                  "tips": "Normalize dividindo pela média dos índices; use 1.00 como alvo para soma.",
                                  "learningObjective": "Isolar e quantificar o componente sazonal ajustado pela tendência.",
                                  "commonMistakes": "Não normalizar índices; confundir divisão com subtração (aditiva usa subtração para resíduos)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular resíduos e validar a decomposição",
                                  "subSteps": [
                                    "Subtraia tendência + (média * índice sazonal) dos valores observados para obter resíduos.",
                                    "Em planilha: fórmula = Observado - Tendência - (Média * Índice); em R: vetor subtração.",
                                    "Plote resíduos: devem ser estacionários (sem tendência/sazonalidade).",
                                    "Reconstrua a série: Tendência + (Média * Índice) e compare com original.",
                                    "Calcule métricas como MSE para resíduos."
                                  ],
                                  "verification": "Resíduos plotados sem padrões; reconstrução soma próxima aos originais (erro <5%).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilhas para fórmulas; R para plot() e summary() de resíduos.",
                                  "tips": "Use média geral da série para componente sazonal; verifique soma de resíduos ~0.",
                                  "learningObjective": "Completar decomposição aditiva e validar componentes.",
                                  "commonMistakes": "Esquecer multiplicar índice pela média; não plotar resíduos para diagnóstico."
                                }
                              ],
                              "practicalExample": "Usando dados de vendas mensais de sorvetes (36 meses): Janeiro sempre alto (verão). Calcule MMS-12 para tendência crescente; índices ~1.2 verão/0.8 inverno; resíduos aleatórios ~N(0,σ). Em Excel: colunas A(tempo),B(vendas),C(MMS),D(sazonal),E(resíduos). Em R: tsdata %>% mutate(trend=rollmean(obs,12), ...).",
                              "finalVerifications": [
                                "Série reconstruída (Tendência + Sazonal) coincide com original (diferença <5%).",
                                "Resíduos sem autocorrelação significativa (ACF próximo de zero).",
                                "Índices sazonais somam 1.00 por ciclo completo.",
                                "Tendência suave e monotonicamente crescente/decrescente onde esperado.",
                                "Gráficos de componentes isolados mostram padrões corretos.",
                                "MSE dos resíduos baixo comparado à variância original."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de MMS, índices e resíduos (erro <1% em exemplos numéricos).",
                                "Correta identificação e plotagem de componentes (tendência suave, sazonal cíclico).",
                                "Uso adequado de ferramentas (planilha/R sem erros de sintaxe).",
                                "Explicação conceitual da decomposição aditiva vs multiplicativa.",
                                "Diagnóstico de resíduos estacionários via plot/ACF.",
                                "Aplicação a dados reais com interpretação prática."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de médias móveis e normalização estatística.",
                                "Programação: Manipulação de dados em R/dplyr e visualização com ggplot2.",
                                "Economia/Negócios: Previsão de demanda sazonal para estoques.",
                                "Ciência de Dados: Diagnóstico de séries temporais e modelagem.",
                                "Finanças: Análise de retornos sazonais em ações."
                              ],
                              "realWorldApplication": "Em varejo, decompor vendas sazonais para planejar estoques (ex: Natal/Páscoa); em meteorologia, separar tendência climática de ciclos anuais para previsões; em finanças, ajustar retornos de ações por sazonalidade para estratégias de trading."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.6.3.2.3",
                            "name": "Interpretar resultados da decomposição aditiva",
                            "description": "Avaliar gráficos de componentes extraídos, diagnosticar adequação do modelo por análise de resíduos e ajustar se necessário.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Examinar os Gráficos dos Componentes Extraídos",
                                  "subSteps": [
                                    "Plotar os gráficos da série original, tendência, sazonalidade e resíduos usando ferramentas como Python (statsmodels) ou R.",
                                    "Analisar a tendência: identificar se é crescente, decrescente, estacionária ou com mudanças abruptas.",
                                    "Examinar a componente sazonal: verificar periodicidade, amplitude e consistência ao longo do tempo.",
                                    "Observar os resíduos: procurar por padrões não aleatórios, como ciclos ou heterocedasticidade.",
                                    "Comparar a soma da tendência + sazonalidade + resíduos com a série original para validar a decomposição."
                                  ],
                                  "verification": "Gráficos gerados com legendas claras e relatório escrito descrevendo padrões observados em cada componente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software: Python (pandas, matplotlib, statsmodels) ou R (forecast package)",
                                    "Dados de exemplo: série temporal sazonal (ex: vendas mensais)"
                                  ],
                                  "tips": [
                                    "Use subplots para visualizar todos os componentes lado a lado.",
                                    "Ajuste escalas logarítmicas se a variância aumentar com o tempo."
                                  ],
                                  "learningObjective": "Visualizar e descrever qualitativamente os componentes da decomposição aditiva.",
                                  "commonMistakes": [
                                    "Ignorar discrepâncias na soma dos componentes.",
                                    "Confundir flutuações aleatórias na sazonalidade."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar os Resíduos para Adequação",
                                  "subSteps": [
                                    "Calcular estatísticas descritivas dos resíduos: média próxima de zero, variância constante.",
                                    "Gerar ACF (função de autocorrelação) e PACF dos resíduos para detectar autocorrelação residual.",
                                    "Testar normalidade dos resíduos (teste Shapiro-Wilk ou QQ-plot).",
                                    "Verificar homocedasticidade com plot de resíduos vs. tempo ou fitted values.",
                                    "Aplicar teste Ljung-Box para independência dos resíduos."
                                  ],
                                  "verification": "Relatório com resultados de testes (p-values) e plots de diagnóstico anexados.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Bibliotecas: statsmodels.tsa.stattools (Python) ou acf() em R",
                                    "Jupyter Notebook ou R Markdown para documentação"
                                  ],
                                  "tips": [
                                    "Resíduos ideais devem se comportar como ruído branco: média zero, variância constante, sem autocorrelação.",
                                    "Interprete p-values: <0.05 indica problema."
                                  ],
                                  "learningObjective": "Aplicar testes estatísticos para validar a adequação dos resíduos na decomposição.",
                                  "commonMistakes": [
                                    "Não testar múltiplos aspectos (só visual).",
                                    "Confundir autocorrelação sazonal com residual."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diagnosticar Problemas de Adequação do Modelo",
                                  "subSteps": [
                                    "Classificar problemas: heterocedasticidade (variância crescente), autocorrelação persistente, não-normalidade.",
                                    "Comparar com critérios de modelo aditivo: apropriado se variância constante; senão, considerar multiplicativo.",
                                    "Identificar causas potenciais: outliers, não-estacionariedade não capturada, frequência sazonal errada.",
                                    "Documentar evidências de cada diagnóstico com referências aos plots e testes.",
                                    "Priorizar problemas: autocorrelação > heterocedasticidade > normalidade."
                                  ],
                                  "verification": "Tabela de diagnóstico listando problemas detectados, evidências e severidade.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Planilha ou Markdown para tabela de diagnóstico",
                                    "Referências: livros como 'Forecasting: Principles and Practice' (Hyndman)"
                                  ],
                                  "tips": [
                                    "Use checklist: ruído branco? → Sim/Não e por quê.",
                                    "Considere transformações (log) antes de multiplicativo."
                                  ],
                                  "learningObjective": "Interpretar resultados de diagnóstico para identificar falhas no modelo aditivo.",
                                  "commonMistakes": [
                                    "Diagnosticar sem evidência estatística.",
                                    "Ignorar heterocedasticidade em séries com tendência crescente."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ajustar o Modelo e Reavaliar",
                                  "subSteps": [
                                    "Aplicar ajustes: switch para decomposição multiplicativa se heterocedasticidade; suavização para outliers.",
                                    "Reexecutar decomposição com parâmetros ajustados (ex: frequência sazonal).",
                                    "Reanalisar resíduos do modelo ajustado com os mesmos testes do Step 2.",
                                    "Comparar métricas: AIC, RMSE entre original e ajustado.",
                                    "Documentar mudanças e razões, salvando versões do modelo."
                                  ],
                                  "verification": "Modelo ajustado com resíduos melhorados (p-values >0.05) e relatório de comparação.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código iterativo em Python/R",
                                    "Versão controlada de dados (Git)"
                                  ],
                                  "tips": [
                                    "Sempre valide ajustes com hold-out set.",
                                    "Mantenha aditivo se possível por simplicidade interpretativa."
                                  ],
                                  "learningObjective": "Implementar e validar ajustes iterativos no modelo de decomposição.",
                                  "commonMistakes": [
                                    "Ajustar excessivamente (overfitting).",
                                    "Não retestar resíduos após ajuste."
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dados mensais de passageiros aéreos (AirPassengers dataset), realize a decomposição aditiva: note tendência crescente, sazonalidade anual e resíduos com variância crescente. Diagnostique heterocedasticidade via plot e teste Breusch-Pagan, ajuste para multiplicativo via log-transform e reavalie resíduos agora adequados.",
                              "finalVerifications": [
                                "Gráficos de componentes interpretados com descrições precisas.",
                                "Testes de resíduos mostram p-values >0.05 ou melhorados.",
                                "Diagnóstico documentado com evidências.",
                                "Ajustes aplicados e comparados via métricas (RMSE/AIC).",
                                "Relatório final com conclusões acionáveis.",
                                "Código reproduzível salvo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de padrões nos componentes (80%+ acurácia).",
                                "Correta interpretação e aplicação de testes diagnósticos.",
                                "Justificativa lógica e evidenciada para diagnósticos e ajustes.",
                                "Melhoria mensurável nos resíduos pós-ajuste.",
                                "Clareza e completude do relatório.",
                                "Eficiência no tempo e uso de recursos."
                              ],
                              "crossCurricularConnections": [
                                "Visualização de Dados: criação e interpretação de gráficos múltiplos.",
                                "Programação Computacional: scripts em Python/R para análise automatizada.",
                                "Economia/Gestão: aplicação em previsão de demanda sazonal.",
                                "Matemática: conceitos de autocorrelação e testes de hipóteses.",
                                "Ciência de Dados: validação de modelos iterativos."
                              ],
                              "realWorldApplication": "Em varejo, interpretar decomposição aditiva de vendas sazonais para diagnosticar se o modelo captura feriados corretamente, ajustando para evitar erros em previsões de estoque e otimizar compras."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.3.3",
                        "name": "Decomposição Multiplicativa",
                        "description": "Método que assume produto dos componentes (tendência × sazonalidade × resíduos), adequado para séries com variância crescente.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.3.1",
                            "name": "Entender o modelo multiplicativo",
                            "description": "Compreender a equação Y_t = T_t × S_t × R_t, suas premissas de variância proporcional à média e transformação logarítmica para linearização.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os componentes do modelo multiplicativo",
                                  "subSteps": [
                                    "Identificar Y_t como o valor observado da série temporal no tempo t.",
                                    "Explicar T_t como o componente de tendência, representando a direção geral da série.",
                                    "Descrever S_t como o componente sazonal, capturando padrões repetitivos em intervalos fixos.",
                                    "Definir R_t como o resíduo ou irregular, contendo variações aleatórias não explicadas.",
                                    "Escrever e interpretar a equação Y_t = T_t × S_t × R_t."
                                  ],
                                  "verification": "Listar e descrever corretamente cada componente com exemplos simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Gráficos de séries temporais sazonais, planilha Excel ou Python (pandas e matplotlib).",
                                  "tips": "Desenhe um gráfico de uma série temporal e rotule os componentes visualmente.",
                                  "learningObjective": "Reconhecer e diferenciar os três componentes principais do modelo multiplicativo.",
                                  "commonMistakes": "Confundir sazonalidade (padrões cíclicos fixos) com tendência (mudança gradual)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a premissa de variância proporcional à média",
                                  "subSteps": [
                                    "Comparar modelo aditivo (variância constante) com multiplicativo (variância crescente com a média).",
                                    "Explicar que em dados com heteroscedasticidade, a variância de Y_t aumenta proporcionalmente ao nível da série.",
                                    "Analisar um gráfico onde flutuações sazonais são maiores em níveis altos da série.",
                                    "Calcular variância em subperíodos de uma série para verificar proporcionalidade.",
                                    "Discutir quando usar multiplicativo: séries com variância não constante."
                                  ],
                                  "verification": "Identificar corretamente em um gráfico se a variância é proporcional à média.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Dados de exemplo (vendas sazonais), software R ou Python para plotar variâncias.",
                                  "tips": "Use boxplots por estação para visualizar a dispersão crescente.",
                                  "learningObjective": "Justificar o uso do modelo multiplicativo baseado na estrutura de variância dos dados.",
                                  "commonMistakes": "Assumir variância constante em séries com amplitude sazonal crescente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compreender a transformação logarítmica para linearização",
                                  "subSteps": [
                                    "Derivar a transformação: log(Y_t) = log(T_t) + log(S_t) + log(R_t).",
                                    "Explicar como a multiplicação vira adição no espaço logarítmico, permitindo decomposição aditiva.",
                                    "Aplicar logaritmo natural ou base 10 em uma série de dados reais.",
                                    "Plotar a série original vs log-transformada para observar linearização.",
                                    "Discutir limitações: dados com zeros ou negativos não aplicáveis."
                                  ],
                                  "verification": "Transformar uma série e confirmar que se torna aproximadamente aditiva.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Calculadora científica, Jupyter Notebook com numpy e matplotlib.",
                                  "tips": "Adicione uma constante pequena (ex: 1) se houver zeros nos dados.",
                                  "learningObjective": "Aplicar e interpretar a transformação logarítmica para análise aditiva.",
                                  "commonMistakes": "Aplicar log sem verificar valores não positivos, causando erros matemáticos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e verificar o modelo multiplicativo completo",
                                  "subSteps": [
                                    "Combinar componentes, premissa de variância e transformação em um fluxo de análise.",
                                    "Decompor uma série usando método clássico (médias móveis para T e S).",
                                    "Calcular resíduos e verificar se são aproximadamente estacionários.",
                                    "Comparar com modelo aditivo para validar escolha multiplicativa.",
                                    "Interpretar resultados: forças e fraquezas do modelo."
                                  ],
                                  "verification": "Decompor uma série fornecida e explicar premissas atendidas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Biblioteca statsmodels em Python ou forecast em R, dados de série temporal.",
                                  "tips": "Use funções prontas como seasonal_decompose no Python para prática inicial.",
                                  "learningObjective": "Integrar todos os elementos para analisar séries sazonais multiplicativas.",
                                  "commonMistakes": "Ignorar resíduos não aleatórios, indicando modelo inadequado."
                                }
                              ],
                              "practicalExample": "Analise dados mensais de vendas de sorvetes (1953-1961, AirPassengers dataset adaptado): aplique decomposição multiplicativa, observe variância crescente no verão, transforme em log para linearizar e extraia tendência crescente, sazonalidade anual e resíduos.",
                              "finalVerifications": [
                                "Explicar verbalmente a equação Y_t = T_t × S_t × R_t com exemplo.",
                                "Identificar em gráfico se variância é proporcional à média.",
                                "Aplicar log-transformação e plotar antes/depois.",
                                "Decompor uma série simples e interpretar componentes.",
                                "Diferenciar quando usar multiplicativo vs aditivo.",
                                "Verificar resíduos para aleatoriedade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição dos componentes T, S e R (90% correto).",
                                "Correta identificação da premissa de variância proporcional.",
                                "Execução bem-sucedida da transformação logarítmica sem erros.",
                                "Decomposição coerente com interpretação válida.",
                                "Uso apropriado de gráficos para suporte visual.",
                                "Reconhecimento de limitações do modelo."
                              ],
                              "crossCurricularConnections": [
                                "Economia: Previsão de demanda sazonal em varejo.",
                                "Finanças: Análise de retornos de ações com volatilidade crescente.",
                                "Meteorologia: Modelagem de temperaturas ou precipitações sazonais.",
                                "Biologia: Ciclos populacionais com variância proporcional."
                              ],
                              "realWorldApplication": "Em empresas de e-commerce para prever picos de vendas natalinos, onde flutuações sazonais crescem com o volume total, permitindo estoques otimizados e redução de perdas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.3.2",
                            "name": "Aplicar decomposição multiplicativa",
                            "description": "Calcular tendência e sazonalidade via razões e médias geométricas, ou via logaritmo para aditividade, implementando em software como R com função decompose().",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender conceitos fundamentais da decomposição multiplicativa",
                                  "subSteps": [
                                    "Revise o modelo multiplicativo: Y_t = T_t * S_t * R_t, onde T é tendência, S sazonalidade e R resíduo.",
                                    "Identifique quando usar multiplicativa (vs aditiva): quando variação aumenta com nível da série.",
                                    "Aprenda cálculo de tendência via média móvel centrada (período sazonal k=12 para mensal).",
                                    "Estude normalização de fatores sazonais: razões Y_t / T_t, média por estação, ajuste para média geométrica 1.",
                                    "Compreenda transformação log(Y_t) para aditividade: log(Y) = log(T) + log(S) + log(R)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o modelo multiplicativo e dê um exemplo numérico simples.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação de séries temporais (ex: Hyndman livro online)",
                                    "Notebook para anotações",
                                    "Gráficos de exemplo de séries sazonais"
                                  ],
                                  "tips": [
                                    "Use gráficos para visualizar sazonalidade antes de cálculos.",
                                    "Comece com séries mensais simples (k=12)."
                                  ],
                                  "learningObjective": "Compreender o modelo multiplicativo e suas diferenças com aditivo, preparando para cálculos manuais.",
                                  "commonMistakes": [
                                    "Confundir multiplicativa com aditiva sem verificar variância.",
                                    "Ignorar normalização de fatores sazonais."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar decomposição multiplicativa manualmente",
                                  "subSteps": [
                                    "Prepare uma série temporal sazonal pequena (ex: 36 observações mensais).",
                                    "Calcule tendência T_t usando média móvel de período 12 (centrada).",
                                    "Compute razões sazonais: D_t = Y_t / T_t.",
                                    "Calcule médias sazonais por mês: média de D_t para cada estação.",
                                    "Normalize: divida cada média sazonal pela média geométrica de todas as médias sazonais para somar 1.",
                                    "Estime resíduos: R_t = Y_t / (T_t * S_t)."
                                  ],
                                  "verification": "Reconstrua a série original: T_t * S_t * R_t ≈ Y_t para a maioria dos pontos (erro <5%).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets",
                                    "Dados exemplo: vendas mensais fictícias",
                                    "Calculadora científica"
                                  ],
                                  "tips": [
                                    "Use funções GEOMEAN no Excel para média geométrica.",
                                    "Verifique suavidade da tendência plotando."
                                  ],
                                  "learningObjective": "Executar decomposição manual para internalizar o processo algorítmico.",
                                  "commonMistakes": [
                                    "Média móvel não centrada corretamente.",
                                    "Normalização aritmética em vez de geométrica para multiplicativa."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar transformação logarítmica para decomposição aditiva",
                                  "subSteps": [
                                    "Verifique se dados são positivos (Y_t >0); aplique log(Y_t).",
                                    "Decomponha log(Y) como aditiva: log(Y_t) = log(T_t) + log(S_t) + log(R_t).",
                                    "Use método aditivo padrão na série log: média móvel para tendência, desvios para sazonalidade (normalizar média=0).",
                                    "Exponentie componentes: T_t = exp(log(T_t)), etc.",
                                    "Compare decomposição original vs log para validar escolha do modelo."
                                  ],
                                  "verification": "Plot lado a lado: decomposição multiplicativa direta vs via log; verifique adequação visual.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Excel com funções LOG e EXP",
                                    "Mesmos dados do Step 2",
                                    "Software de plotagem como Desmos ou Python/Matplotlib básico"
                                  ],
                                  "tips": [
                                    "Logaritmo natural (ln) é padrão; evita problemas com zeros aproximando se necessário."
                                  ],
                                  "learningObjective": "Dominar abordagem log para séries com variância proporcional, alternativa robusta.",
                                  "commonMistakes": [
                                    "Aplicar log em dados com zeros ou negativos.",
                                    "Esquecer de exponentiar de volta os componentes."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar decomposição em R usando função decompose()",
                                  "subSteps": [
                                    "Instale/carregue pacotes: ts, forecast (se necessário).",
                                    "Crie objeto ts: ts(data, frequency=12).",
                                    "Execute: decomp <- decompose(serie, type='multiplicative').",
                                    "Plote: plot(decomp); extraia componentes: decomp$trend, etc.",
                                    "Valide: autoplot(decomp); compare com cálculo manual.",
                                    "Preveja próximos períodos multiplicando componentes suavizados."
                                  ],
                                  "verification": "Código roda sem erros; plot mostra tendência crescente, sazonalidade cíclica e resíduos aleatórios.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "R e RStudio instalados",
                                    "Dados exemplo em CSV",
                                    "Script R pronto com dados AirPassengers built-in"
                                  ],
                                  "tips": [
                                    "Use dados AirPassengers como teste inicial: decompose(AirPassengers, type='multi').",
                                    "frequency=12 para mensal."
                                  ],
                                  "learningObjective": "Automatizar decomposição em software para análise eficiente de séries reais.",
                                  "commonMistakes": [
                                    "Esquecer frequency no ts().",
                                    "Usar type='additive' por engano."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar resultados e realizar verificações finais",
                                  "subSteps": [
                                    "Analise tendência: direção, aceleração.",
                                    "Examine sazonalidade: picos/vales, amplitude.",
                                    "Verifique resíduos: plot ACF, teste Ljung-Box para independência.",
                                    "Reconstrua série e calcule MAPE: mean(abs((Y - reconstr)/Y))*100.",
                                    "Compare modelos multiplicativo vs log para melhor ajuste (menor MAPE)."
                                  ],
                                  "verification": "Relatório curto (1 página) com plots, interpretações e métricas (MAPE <10%).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "R script do Step 4",
                                    "Funções forecast::accuracy()",
                                    "Templates de relatório"
                                  ],
                                  "tips": [
                                    "Resíduos brancos ideais: sem padrão, média zero, variância constante."
                                  ],
                                  "learningObjective": "Extrair insights acionáveis e validar robustez da decomposição.",
                                  "commonMistakes": [
                                    "Ignorar resíduos correlacionados (indício de modelo inadequado).",
                                    "Sobreinterpretar ruído como sinal."
                                  ]
                                }
                              ],
                              "practicalExample": "Decomponha a série temporal clássica de passageiros aéreos (AirPassengers em R): dados mensais de 1949-1960. Identifique tendência crescente, sazonalidade anual (pico verão), e use decompose() para plotar componentes. Calcule manualmente para primeiros 12 meses e compare.",
                              "finalVerifications": [
                                "Decomposição manual reconstrói >95% da série original.",
                                "Função decompose() em R produz plots coerentes com manual.",
                                "Transformação log reduz variância heteroscédastica visivelmente.",
                                "Resíduos passam teste de independência (ACF próximo de zero).",
                                "Interpretação correta: ex. 'Sazonalidade pico em julho ~1.3x tendência'.",
                                "MAPE de reconstrução <8%."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos manuais (erros <1% em componentes).",
                                "Código R executável e comentado adequadamente.",
                                "Escolha correta entre multiplicativa direta vs log (baseada em plots).",
                                "Interpretação qualitativa e quantitativa dos componentes.",
                                "Validação com métricas (MAPE, ACF resíduos).",
                                "Relatório claro com visualizações profissionais."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Manipulação de dados em R (ts objects, plotting).",
                                "Matemática: Médias móveis, logaritmos, geometria (médias geométricas).",
                                "Economia/Negócios: Previsão de demanda sazonal em varejo.",
                                "Ciência de Dados: Modelagem de séries temporais (pré-STL, ARIMA).",
                                "Estatística: Diagnóstico de resíduos e testes de adequação."
                              ],
                              "realWorldApplication": "Em varejo para prever vendas sazonais de produtos como roupas de inverno (Amazon), em energia para carga elétrica diária (utilities), em finanças para retornos ajustados por calendário (ações), ou turismo para reservas hoteleiras, permitindo alocação eficiente de recursos e estoques."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.1.2"
                            ]
                          },
                          {
                            "id": "10.1.6.3.3.3",
                            "name": "Escolher entre decomposição aditiva e multiplicativa",
                            "description": "Comparar modelos por testes de variância de resíduos, gráficos de resíduos e critérios como AIC, decidindo com base na estacionariedade dos resíduos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar dados e realizar decomposições aditiva e multiplicativa",
                                  "subSteps": [
                                    "Carregar conjunto de dados de série temporal sazonal (ex: vendas mensais).",
                                    "Verificar presença de sazonalidade e tendência usando gráficos preliminares (ACF, PACF).",
                                    "Aplicar decomposição aditiva usando função seasonal_decompose (aditivo=True).",
                                    "Aplicar decomposição multiplicativa usando seasonal_decompose (multiplicative=True).",
                                    "Extrair componentes: tendência, sazonal e resíduos para ambos os modelos."
                                  ],
                                  "verification": "Confirmar que ambos os modelos foram executados sem erros e resíduos extraídos via plotagem rápida.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python (statsmodels.tsa.seasonal), Jupyter Notebook, dataset sazonal (ex: AirPassengers.csv)",
                                  "tips": "Use freq='M' para dados mensais para garantir alinhamento sazonal correto.",
                                  "learningObjective": "Entender e implementar as duas formas de decomposição em séries temporais sazonais.",
                                  "commonMistakes": "Ignorar verificação de sazonalidade inicial, levando a decomposições inválidas; não especificar período sazonal correto."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar resíduos do modelo aditivo",
                                  "subSteps": [
                                    "Plotar resíduos aditivos no tempo e histograma para visualização.",
                                    "Calcular variância dos resíduos usando np.var(residuos_aditivos).",
                                    "Realizar teste de estacionariedade (ADF) nos resíduos aditivos.",
                                    "Gerar gráficos QQ para normalidade e ACF para autocorrelação.",
                                    "Calcular AIC do modelo aditivo."
                                  ],
                                  "verification": "Resíduos plotados mostram ausência clara de tendência/padrão e teste ADF p-value < 0.05.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python (statsmodels.tsa.stattools.adfuller, matplotlib, scipy.stats.probplot)",
                                  "tips": "Padronize resíduos (z-score) antes de QQ plot para melhor interpretação.",
                                  "learningObjective": "Avaliar propriedades dos resíduos aditivos para validar o modelo.",
                                  "commonMistakes": "Não diferenciar resíduos de ruído vs heterocedasticidade; ignorar múltiplos lags no ADF."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar resíduos do modelo multiplicativo",
                                  "subSteps": [
                                    "Plotar resíduos multiplicativos no tempo e histograma.",
                                    "Calcular variância dos resíduos multiplicativos.",
                                    "Aplicar teste ADF de estacionariedade nos resíduos multiplicativos.",
                                    "Gerar QQ plot e ACF dos resíduos multiplicativos.",
                                    "Calcular AIC do modelo multiplicativo."
                                  ],
                                  "verification": "Gráficos e testes mostram comparação direta com aditivo; anotar valores numéricos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Mesmos do step 2: statsmodels, matplotlib",
                                  "tips": "Para multiplicativo, transforme dados em log se necessário para estabilizar variância.",
                                  "learningObjective": "Comparar rigorosamente resíduos multiplicativos com aditivos.",
                                  "commonMistakes": "Confundir resíduos multiplicativos (não somados) com aditivos; pular normalização para logs."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar modelos e decidir o melhor",
                                  "subSteps": [
                                    "Comparar variâncias: modelo com menor variância é preferível.",
                                    "Comparar AIC: menor AIC indica melhor ajuste.",
                                    "Avaliar gráficos: preferir resíduos sem padrões, estacionários (ADF p<0.05).",
                                    "Decidir baseado em: variância baixa + estacionariedade + AIC baixo.",
                                    "Documentar justificativa escrita com métricas numéricas."
                                  ],
                                  "verification": "Relatório final com tabela comparativa e escolha justificada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Pandas para tabela comparativa, Markdown para relatório",
                                  "tips": "Crie uma tabela Pandas com colunas: Modelo, Variância, AIC, ADF_pvalue.",
                                  "learningObjective": "Sintetizar análises para seleção informada de modelo.",
                                  "commonMistakes": "Priorizar apenas AIC ignorando gráficos; não considerar contexto de variância crescente (favorece multiplicativo)."
                                }
                              ],
                              "practicalExample": "Usando dados de passageiros aéreos mensais (AirPassengers.csv): Decomponha aditiva (variância alta em picos) vs multiplicativa (melhor para variância crescente), escolha multiplicativa por AIC=320 vs 350 e resíduos estacionários (ADF p=0.01).",
                              "finalVerifications": [
                                "Resíduos do modelo escolhido passam no teste ADF de estacionariedade (p<0.05).",
                                "Gráficos de resíduos sem tendências ou padrões sazonais visíveis.",
                                "Variância dos resíduos < 10% da variância original da série.",
                                "AIC do modelo escolhido é o menor entre os dois.",
                                "Tabela comparativa documenta todas as métricas.",
                                "Justificativa escrita explica escolha com evidências."
                              ],
                              "assessmentCriteria": [
                                "Precisão na implementação das decomposições (sem erros de código).",
                                "Correta interpretação de testes (ADF, variância, AIC).",
                                "Qualidade dos gráficos: claros, rotulados e comparativos.",
                                "Decisão lógica baseada em múltiplos critérios, não subjetiva.",
                                "Relatório completo com tabela e justificativa.",
                                "Identificação correta de erros comuns nos resíduos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Testes estatísticos de hipóteses (ADF, normalidade).",
                                "Programação: Manipulação de dados em Python/R (pandas, statsmodels).",
                                "Economia: Modelagem de séries temporais para previsão de demanda.",
                                "Computação Científica: Visualização de dados e análise exploratória."
                              ],
                              "realWorldApplication": "Em finanças, escolher decomposição multiplicativa para ações com volatilidade crescente (ex: previsão de preços de criptomoedas); em varejo, aditiva para vendas estáveis, otimizando estoque e planejamento sazonal."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.2.3",
                              "10.1.6.3.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.4",
                    "name": "Modelos ARIMA Sazonais (SARIMA)",
                    "description": "Adaptação de modelos ARIMA para capturar efeitos sazonais na previsão.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.4.1",
                        "name": "Notação e Componentes do Modelo SARIMA",
                        "description": "Compreensão da extensão do modelo ARIMA para incluir padrões sazonais, incluindo a notação padrão SARIMA(p,d,q)(P,D,Q)s e os componentes não sazonais e sazonais.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.1.1",
                            "name": "Diferenciar ARIMA de SARIMA",
                            "description": "Explicar como o modelo SARIMA adapta o ARIMA clássico para capturar sazonalidade, identificando os parâmetros adicionais (P, D, Q) e o período sazonal s.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Modelo ARIMA Clássico",
                                  "subSteps": [
                                    "Estude a estrutura ARIMA(p,d,q): AR(p) para autocorrelação, I(d) para diferenciação, MA(q) para média móvel.",
                                    "Analise exemplos de séries temporais não sazonais, como preços diários sem padrões repetitivos anuais.",
                                    "Pratique identificando parâmetros p, d, q usando gráficos ACF/PACF.",
                                    "Simule uma série ARIMA simples em software como Python (statsmodels).",
                                    "Compare com modelos mais simples como AR ou MA."
                                  ],
                                  "verification": "Crie um gráfico ACF/PACF de uma série ARIMA e identifique corretamente p, d, q.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação statsmodels ARIMA",
                                    "Jupyter Notebook",
                                    "Dados de série temporal não sazonal (ex: airpassengers sem sazonal)"
                                  ],
                                  "tips": "Sempre comece com plot da série e resíduos para validar o modelo.",
                                  "learningObjective": "Compreender os componentes fundamentais do ARIMA para séries estacionárias não sazonais.",
                                  "commonMistakes": [
                                    "Confundir ACF com PACF",
                                    "Sobrediferenciar (d alto demais)",
                                    "Ignorar testes de estacionariedade como ADF"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Sazonalidade em Séries Temporais",
                                  "subSteps": [
                                    "Plote séries temporais reais com padrões sazonais (ex: vendas mensais de varejo).",
                                    "Use decomposição sazonal (STL ou clássica) para separar tendência, sazonal e residual.",
                                    "Calcule o período sazonal s (ex: 12 para dados mensais anuais).",
                                    "Aplique testes como OCSB para detectar sazonalidade.",
                                    "Diferencie uma série sazonal vs não sazonal visualmente."
                                  ],
                                  "verification": "Decomponha uma série sazonal e identifique o período s corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Biblioteca Python seasonal_decompose",
                                    "Dados sazonais (ex: airpassengers.csv)"
                                  ],
                                  "tips": "Procure picos repetitivos no mesmo mês todo ano para estimar s.",
                                  "learningObjective": "Reconhecer quando o ARIMA padrão falha devido a sazonalidade.",
                                  "commonMistakes": [
                                    "Assumir s=1 para dados mensais",
                                    "Ignorar múltiplos ciclos sazonais",
                                    "Confundir tendência com sazonalidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Entender os Componentes Sazonais do SARIMA",
                                  "subSteps": [
                                    "Aprenda a notação SARIMA(p,d,q)(P,D,Q)s: componentes não sazonais + sazonais.",
                                    "Explique P (AR sazonal), D (diferenciação sazonal), Q (MA sazonal).",
                                    "Estude como s define o lag sazonal (ex: lag 12 para mensal).",
                                    "Pratique identificando parâmetros sazonais via ACF/PACF em lags múltiplos de s.",
                                    "Implemente um modelo SARIMA(0,1,1)(1,1,1)12 em código."
                                  ],
                                  "verification": "Escreva a equação de um SARIMA(1,1,1)(1,1,1)12 e explique cada termo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Tutoriais statsmodels SARIMA",
                                    "Jupyter Notebook",
                                    "Documentação Hyndman sobre SARIMA"
                                  ],
                                  "tips": "ACF em lags s, 2s mostram padrões sazonais para guiar P,D,Q.",
                                  "learningObjective": "Dominar a extensão sazonal do ARIMA com parâmetros adicionais.",
                                  "commonMistakes": [
                                    "Confundir (p,d,q) com (P,D,Q)",
                                    "Escolher s errado",
                                    "Não verificar sobreajuste com AIC"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar e Diferenciar ARIMA de SARIMA",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: ARIMA vs SARIMA (parâmetros, quando usar, limitações).",
                                    "Ajuste ARIMA e SARIMA na mesma série sazonal e compare resíduos.",
                                    "Avalie melhorias: SARIMA deve remover autocorrelação sazonal nos resíduos.",
                                    "Discuta cenários: use ARIMA se sem sazonalidade; SARIMA caso contrário.",
                                    "Teste com validação cruzada temporal para prever futuro."
                                  ],
                                  "verification": "Ajuste modelos em dados reais e prove que SARIMA é superior via Ljung-Box em resíduos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código Python comparativo",
                                    "Dados airpassengers ou electricity demand"
                                  ],
                                  "tips": "Sempre compare AIC/BIC e plots de resíduos para decisão.",
                                  "learningObjective": "Diferenciar claramente os modelos e saber quando aplicar cada um.",
                                  "commonMistakes": [
                                    "Usar SARIMA em dados não sazonais (overkill)",
                                    "Ignorar ordem de diferenciação",
                                    "Não transformar dados (log para variância constante)"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dados de passageiros aéreos mensais (airpassengers.csv): ajuste ARIMA(2,1,2) que falha nos resíduos sazonais, então SARIMA(1,1,1)(1,1,1)12 que captura o pico anual de verão, melhorando previsões em 20-30%.",
                              "finalVerifications": [
                                "Explicar verbalmente a diferença em notação e propósito.",
                                "Identificar parâmetros corretos em ACF/PACF de uma série sazonal.",
                                "Ajustar SARIMA em código e interpretar saída.",
                                "Comparar resíduos de ARIMA vs SARIMA.",
                                "Escolher modelo correto para uma série dada.",
                                "Prever próximo período e validar."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação SARIMA(p,d,q)(P,D,Q)s.",
                                "Correta identificação de sazonalidade via decomposição.",
                                "Seleção adequada de parâmetros baseada em diagnósticos.",
                                "Comparação quantitativa (AIC, resíduos).",
                                "Aplicação prática em código sem erros.",
                                "Explicação clara de quando usar cada modelo."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python/R (statsmodels, forecast).",
                                "Economia: Previsão de PIB sazonalmente ajustado.",
                                "Machine Learning: Extensão para Prophet ou LSTM híbridos.",
                                "Matemática: Equações de processos estocásticos e operadores de diferença."
                              ],
                              "realWorldApplication": "Em finanças, prever vendas de varejo natalinas com SARIMA para otimizar estoque; em meteorologia, modelar temperaturas mensais sazonais para alertas climáticos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.1.2",
                            "name": "Interpretar a notação SARIMA(p,d,q)(P,D,Q)s",
                            "description": "Decodificar cada parâmetro na notação SARIMA, como p (ordem autoregressiva não sazonal), d (diferenciação não sazonal), q (média móvel não sazonal), P, D, Q (componentes sazonais) e s (período sazonal).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura geral da notação SARIMA(p,d,q)(P,D,Q)s",
                                  "subSteps": [
                                    "Identificar a parte não sazonal: (p,d,q)",
                                    "Reconhecer a parte sazonal: (P,D,Q)s",
                                    "Entender que SARIMA estende ARIMA para capturar sazonalidade",
                                    "Notar que s representa o período sazonal (ex: 12 para dados mensais anuais)",
                                    "Diferenciar SARIMA de ARIMA simples pela presença da parte sazonal"
                                  ],
                                  "verification": "Escrever a estrutura geral e rotular cada componente corretamente em um diagrama",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de SARIMA (ex: statsmodels ou forecast em R)",
                                    "Papel e caneta para diagrama"
                                  ],
                                  "tips": "Visualize a notação como dois ARIMA: um não sazonal e um sazonal multiplicados",
                                  "learningObjective": "Dominar a divisão da notação em componentes não sazonal e sazonal",
                                  "commonMistakes": [
                                    "Confundir s com um parâmetro de ordem",
                                    "Ignorar parênteses que separam partes não sazonal e sazonal"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Decodificar os parâmetros não sazonais (p, d, q)",
                                  "subSteps": [
                                    "Explicar p: ordem do componente autoregressivo (AR) não sazonal (número de lags autoregressivos)",
                                    "Definir d: grau de diferenciação não sazonal para estacionariedade",
                                    "Descrever q: ordem do componente média móvel (MA) não sazonal",
                                    "Relacionar com o modelo ARIMA(p,d,q): Y_t = AR(p) + MA(q) após d diferenciações",
                                    "Exemplificar: em (1,1,1), p=1 (um lag AR), d=1 (uma diferenciação), q=1 (um lag MA)"
                                  ],
                                  "verification": "Listar definições de p, d, q e aplicar a um exemplo como (2,0,1)",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tutorial ARIMA (ex: Hyndman livro 'Forecasting: Principles and Practice')",
                                    "Exemplos de código Python/R"
                                  ],
                                  "tips": "Lembre-se: p e q são ordens de polinômios, d é para remover tendência",
                                  "learningObjective": "Interpretar precisamente os parâmetros não sazonais e seu papel na modelagem",
                                  "commonMistakes": [
                                    "Confundir p com q (AR vs MA)",
                                    "Achar que d é sazonal"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Decodificar os parâmetros sazonais (P, D, Q, s)",
                                  "subSteps": [
                                    "Definir P: ordem AR sazonal (lags no período s)",
                                    "Explicar D: grau de diferenciação sazonal para remover sazonalidade",
                                    "Descrever Q: ordem MA sazonal",
                                    "Identificar s: comprimento do ciclo sazonal (ex: 4 trimestral, 12 mensal anual)",
                                    "Entender interação: sazonal opera em lags múltiplos de s"
                                  ],
                                  "verification": "Traduzir (1,1,1)12 explicando cada um: P=1 (AR sazonal lag 12), etc.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráficos de séries sazonais (ex: AirPassengers dataset)",
                                    "Referência: Box-Jenkins methodology"
                                  ],
                                  "tips": "Pense em sazonal como ARIMA aplicado aos resíduos sazonais",
                                  "learningObjective": "Diferenciar e explicar componentes sazonais em relação aos não sazonais",
                                  "commonMistakes": [
                                    "Misturar maiúsculas (P,D,Q) com minúsculas",
                                    "Confundir s com frequência amostragem"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar uma notação SARIMA completa e validar",
                                  "subSteps": [
                                    "Combinar partes: SARIMA(p,d,q)(P,D,Q)s integra não sazonal + sazonal",
                                    "Analisar exemplo: SARIMA(1,1,1)(1,1,1)12 para dados mensais de passageiros aéreos",
                                    "Verificar estacionariedade implícita: d+D diferenciações totais",
                                    "Discutir como parâmetros afetam o modelo (ex: alto P para forte sazonalidade)",
                                    "Testar interpretação escrevendo equação conceitual"
                                  ],
                                  "verification": "Interpretar corretamente SARIMA(2,1,0)(0,1,1)4 e justificar escolhas",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software como Python (statsmodels.tsa.SARIMAX)",
                                    "Dataset sazonal exemplo"
                                  ],
                                  "tips": "Use ACF/PACF plots para intuir valores de p,q,P,Q",
                                  "learningObjective": "Aplicar interpretação completa a uma notação real e contextualizar",
                                  "commonMistakes": [
                                    "Ignorar impacto de s no modelo",
                                    "Sobrestimar complexidade sem dados"
                                  ]
                                }
                              ],
                              "practicalExample": "Para SARIMA(1,1,1)(1,1,1)12 em dados mensais de vendas: p=1 (tendência curta), d=1 (remove tendência), q=1 (ruído curto); P=1 (sazonal anual AR), D=1 (remove sazonal anual), Q=1 (sazonal MA), s=12 (mensal). Isso modela vendas com tendência e pico anual de Natal.",
                              "finalVerifications": [
                                "Explicar todos os 7 parâmetros sem erros",
                                "Diferenciar corretamente não sazonal vs sazonal",
                                "Aplicar notação a um exemplo real com diagrama",
                                "Identificar s baseado no contexto temporal",
                                "Descrever como parâmetros afetam estacionariedade",
                                "Traduzir notação para componentes AR/MA/I"
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições de cada parâmetro (100%)",
                                "Correta distinção entre componentes não sazonal e sazonal",
                                "Uso apropriado de exemplos contextuais",
                                "Compreensão do papel de s no período sazonal",
                                "Capacidade de interpretar notações variadas",
                                "Integração conceitual com ARIMA base"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Polinômios autoregressivos e séries infinitas",
                                "Programação: Implementação em Python/R (statsmodels, forecast)",
                                "Economia: Modelagem de séries econômicas sazonais",
                                "Física: Análise de sinais periódicos",
                                "Machine Learning: Extensão para modelos de previsão avançados"
                              ],
                              "realWorldApplication": "Em previsão de demanda varejista, interpretar SARIMA(1,1,1)(1,1,1)12 permite ajustar estoques para picos sazonais como Black Friday, otimizando supply chain e reduzindo custos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.1.3",
                            "name": "Identificar exemplos de períodos sazonais comuns",
                            "description": "Reconhecer períodos sazonais típicos como s=12 para dados mensais, s=4 para trimestrais e s=7 para semanais, relacionando com aplicações em finanças e marketing.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito de sazonalidade e o parâmetro 's' no modelo SARIMA",
                                  "subSteps": [
                                    "Defina sazonalidade como padrões repetitivos em intervalos fixos em séries temporais.",
                                    "Explique que no SARIMA, 's' representa o comprimento do período sazonal.",
                                    "Diferencie sazonalidade de tendência e ruído aleatório.",
                                    "Revise a notação SARIMA(p,d,q)(P,D,Q)s.",
                                    "Identifique que 's' é crucial para modelar ciclos repetitivos."
                                  ],
                                  "verification": "Resuma em uma frase o papel de 's' e dê um exemplo simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação SARIMA (ex: Statsmodels ou forecast package), vídeo introdutório sobre séries temporais.",
                                  "tips": "Use diagramas de séries temporais reais para visualizar ciclos.",
                                  "learningObjective": "Compreender o significado fundamental do parâmetro sazonal 's'.",
                                  "commonMistakes": "Confundir 's' com o número de observações totais ou ignorar sua relação com a frequência dos dados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Memorizar e exemplificar períodos sazonais comuns",
                                  "subSteps": [
                                    "Aprenda s=12 para dados mensais (ciclos anuais).",
                                    "Identifique s=4 para dados trimestrais (ciclos anuais divididos em 4).",
                                    "Reconheça s=7 para dados semanais (ciclos semanais).",
                                    "Liste outros comuns: s=24 para horários diários, s=52 para semanais anuais.",
                                    "Crie uma tabela relacionando frequência de dados com 's'."
                                  ],
                                  "verification": "Crie uma tabela com 5 exemplos de 's' e suas frequências correspondentes.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Tabela de referência de períodos sazonais, planilha Excel ou Google Sheets.",
                                  "tips": "Associe números a contextos reais, como '12 meses no ano'.",
                                  "learningObjective": "Reconhecer padrões numéricos padrão para diferentes granularidades temporais.",
                                  "commonMistakes": "Usar s=12 para dados diários ou confundir trimestral (4) com mensal (12)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Relacionar períodos sazonais com aplicações em finanças e marketing",
                                  "subSteps": [
                                    "Em finanças: Use s=12 para vendas de varejo mensal afetadas por feriados.",
                                    "Em marketing: s=7 para tráfego de site semanal com picos de fim de semana.",
                                    "Em finanças: s=4 para relatórios trimestrais de lucros corporativos.",
                                    "Discuta como escolher 's' errado leva a modelos ruins.",
                                    "Analise um gráfico real de dados sazonais nessas áreas."
                                  ],
                                  "verification": "Descreva um exemplo de finanças e um de marketing com o 's' apropriado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Gráficos de séries temporais de ações (Yahoo Finance), dados de vendas (Kaggle datasets).",
                                  "tips": "Busque dados reais no Kaggle para prática visual.",
                                  "learningObjective": "Aplicar conhecimento de 's' a cenários profissionais reais.",
                                  "commonMistakes": "Ignorar contexto setorial, como sazonalidade de Natal em marketing."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação de períodos sazonais em dados simulados",
                                  "subSteps": [
                                    "Gere ou baixe dados mensais e identifique s=12.",
                                    "Analise dados trimestrais e confirme s=4.",
                                    "Examine dados semanais e aplique s=7.",
                                    "Use plot de autocorrelação (ACF) para validar 's'.",
                                    "Teste com dados mistos e justifique escolhas."
                                  ],
                                  "verification": "Identifique 's' corretamente em 3 conjuntos de dados diferentes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python/R com bibliotecas (pandas, matplotlib, statsmodels), datasets de séries temporais.",
                                  "tips": "Plote ACF em lags múltiplos de 's' para confirmação visual.",
                                  "learningObjective": "Desenvolver habilidade prática de detecção de sazonalidade.",
                                  "commonMistakes": "Escolher 's' baseado apenas em visual, sem ACF ou conhecimento de frequência."
                                }
                              ],
                              "practicalExample": "Em um dataset de vendas mensais de roupas, observe picos todo dezembro (Natal); defina s=12 para capturar o ciclo anual no modelo SARIMA, melhorando previsões para estoque.",
                              "finalVerifications": [
                                "Lista corretamente s=12, s=4 e s=7 com explicações.",
                                "Relaciona cada 's' a uma frequência de dados.",
                                "Fornece exemplos de finanças e marketing.",
                                "Identifica 's' em um gráfico de série temporal fornecido.",
                                "Explica impacto de 's' errado em modelagem SARIMA.",
                                "Valida com ACF em pelo menos um exemplo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de valores comuns de 's' (90%+ correto).",
                                "Qualidade das explicações relacionando frequência e aplicações.",
                                "Uso correto de ferramentas como ACF para verificação.",
                                "Criatividade em exemplos reais de finanças/marketing.",
                                "Completude da tabela ou lista de exemplos.",
                                "Ausência de erros comuns como confusão de granularidades."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estatística descritiva e análise de autocorrelação.",
                                "Economia: Modelagem de ciclos econômicos sazonais.",
                                "Negócios: Previsão de demanda em marketing e finanças.",
                                "Programação: Manipulação de dados temporais em Python/R."
                              ],
                              "realWorldApplication": "Em finanças, usar s=4 para prever lucros trimestrais de empresas; em marketing, s=7 para otimizar campanhas semanais baseadas em tráfego sazonal, aumentando ROI em 15-20% com SARIMA preciso."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.4.2",
                        "name": "Identificação de Modelos SARIMA",
                        "description": "Processo de seleção dos parâmetros do modelo SARIMA por meio de análise exploratória de autocorrelações sazonais e não sazonais.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.2.1",
                            "name": "Analisar gráficos ACF e PACF sazonais",
                            "description": "Interpretar os gráficos de autocorrelação (ACF) e autocorrelação parcial (PACF) para componentes sazonais, identificando picos significativos em lags múltiplos de s para determinar ordens P, Q.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de ACF e PACF sazonais",
                                  "subSteps": [
                                    "Estude a definição de autocorrelação (ACF) como correlação entre a série e seus lags sazonais (múltiplos de s).",
                                    "Entenda a autocorrelação parcial (PACF) como correlação direta entre lags sazonais, removendo efeitos intermediários.",
                                    "Identifique o papel no SARIMA: ACF sazonal indica ordem Q (MA), PACF sazonal indica ordem P (AR).",
                                    "Revise o parâmetro s (período sazonal, ex: 12 para mensal).",
                                    "Examine exemplos de gráficos com picos significativos em lags s, 2s, etc."
                                  ],
                                  "verification": "Resuma em 3 frases os papéis de ACF e PACF sazonais e forneça um exemplo de pico significativo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Documentação statsmodels ou forecast em R",
                                    "Notas de aula sobre SARIMA"
                                  ],
                                  "tips": "Use diagramas visuais para memorizar: decaimento sinusoidal em ACF para MA, corte em PACF para AR.",
                                  "learningObjective": "Compreender as diferenças e interpretações de ACF e PACF para componentes sazonais.",
                                  "commonMistakes": [
                                    "Confundir ACF sazonal com não sazonal",
                                    "Ignorar bandas de confiança (95%)",
                                    "Não considerar s correto"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar e gerar gráficos ACF e PACF sazonais",
                                  "subSteps": [
                                    "Carregue dados de série temporal sazonal em Python (pandas) ou R.",
                                    "Aplique diferenciação sazonal se necessário: diff(data, lag=s).",
                                    "Gere ACF sazonal: plot_acf(residuals, lags=2*s, seasonal=True) em statsmodels.",
                                    "Gere PACF sazonal: plot_pacf(residuals, lags=2*s, seasonal=True).",
                                    "Ajuste lags para visualizar múltiplos de s (ex: lags=40 para s=12)."
                                  ],
                                  "verification": "Confirme que os gráficos mostram barras em lags múltiplos de s e salve as figuras.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python com statsmodels, pandas, matplotlib",
                                    "Dataset sazonal exemplo (ex: AirPassengers)"
                                  ],
                                  "tips": "Sempre plote após diferenciação para estacionariedade; use alpha=0.05 para bandas.",
                                  "learningObjective": "Gerar visualizações corretas de ACF e PACF sazonais para análise.",
                                  "commonMistakes": [
                                    "Não diferenciar adequadamente",
                                    "Escolher lags insuficientes",
                                    "Ignorar zoom em lags sazonais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar gráfico ACF sazonal para determinar ordem Q",
                                  "subSteps": [
                                    "Identifique picos significativos (acima da banda azul) em lags s, 2s, 3s, etc.",
                                    "Conte o número de picos consecutivos significativos: Q = número de picos.",
                                    "Observe padrão: decaimento lento ou sinusoidal indica MA sazonal forte.",
                                    "Ignore picos em lags não múltiplos de s (ruído).",
                                    "Registre Q candidato (ex: Q=1 se pico só em s)."
                                  ],
                                  "verification": "Anotar Q proposto com justificativa baseada em picos observados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Gráficos gerados no step 2",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Foque apenas em lags sazonais; picos isolados em ks sugerem Q=k.",
                                  "learningObjective": "Identificar e quantificar ordem sazonal MA (Q) via ACF.",
                                  "commonMistakes": [
                                    "Contar picos não sazonais",
                                    "Considerar picos dentro da banda como significativos",
                                    "Confundir com PACF"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar gráfico PACF sazonal para determinar ordem P e integrar",
                                  "subSteps": [
                                    "Identifique picos em lags s, 2s: número de picos consecutivos = P.",
                                    "Padrão de corte após lag Ps indica AR sazonal.",
                                    "Compare com ACF: valide consistência (ex: PACF corta para P=1).",
                                    "Proponha ordens sazonais finais (P, Q).",
                                    "Documente razões e lags específicos."
                                  ],
                                  "verification": "Escreva notação SARIMA(P,D,Q,s) parcial com justificativa.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Gráficos ACF e PACF",
                                    "Tabela de resumo P/Q"
                                  ],
                                  "tips": "Picos em ambos gráficos em mesmo lag sugerem modelo misto; teste com poucos lags primeiro.",
                                  "learningObjective": "Determinar ordem sazonal AR (P) e combinar com Q para modelo SARIMA.",
                                  "commonMistakes": [
                                    "Usar ACF para P",
                                    "Sobrestimar ordens altas sem evidência",
                                    "Não validar com bandas de confiança"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dados mensais de passageiros aéreos (AirPassengers, s=12): Após diferenciação sazonal, ACF mostra picos significativos em lag 12 e 24 (Q=2); PACF pico em lag 12 (P=1), sugerindo SARIMA(1,1,1)(1,1,2,12).",
                              "finalVerifications": [
                                "Picos sazonais identificados corretamente em múltiplos de s.",
                                "Ordens P e Q propostas com lags exatos citados.",
                                "Bandas de confiança consideradas para significância.",
                                "Consistência entre ACF (Q) e PACF (P) verificada.",
                                "Notação SARIMA sazonal completa e justificada.",
                                "Gráficos salvos com anotações de picos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de picos significativos (80% acerto).",
                                "Justificativa clara e baseada em lags sazonais.",
                                "Correta atribuição: ACF para Q, PACF para P.",
                                "Uso adequado de diferenciação e lags.",
                                "Proposta de ordens coerente com padrões teóricos.",
                                "Documentação completa e organizada."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Uso de bibliotecas statsmodels em Python ou forecast em R.",
                                "Estatística: Conceitos de estacionariedade e testes de significância.",
                                "Matemática: Correlações e funções de autocovariância.",
                                "Ciência de Dados: Integração com modelagem preditiva e validação.",
                                "Economia: Aplicação em séries financeiras sazonais."
                              ],
                              "realWorldApplication": "Em previsão de demanda sazonal para varejo (ex: vendas de Natal), análise de padrões climáticos mensais ou planejamento de energia elétrica com picos sazonais, permitindo modelos SARIMA precisos para forecasts confiáveis."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.2.2",
                            "name": "Aplicar diferenciação sazonal",
                            "description": "Realizar e interpretar diferenciação sazonal (operador Δ^s) em séries com sazonalidade não estacionária, verificando estacionariedade via teste de Dickey-Fuller.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Verificar estacionariedade sazonal da série temporal original",
                                  "subSteps": [
                                    "Carregar a série temporal sazonal usando Python (statsmodels ou pandas).",
                                    "Plotar a série, ACF e PACF para visualizar padrões sazonais persistentes.",
                                    "Executar teste de Dickey-Fuller Aumentado (ADF) na série original.",
                                    "Analisar p-value do teste ADF (esperado >0.05 indicando não-estacionariedade sazonal).",
                                    "Confirmar presença de sazonalidade não estacionária via gráficos de autocorrelação sazonal."
                                  ],
                                  "verification": "p-value do teste ADF >0.05 e ACF mostra picos sazonais significativos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python com bibliotecas statsmodels, pandas, matplotlib",
                                    "Dataset sazonal exemplo (ex: vendas mensais)"
                                  ],
                                  "tips": "Sempre plote os gráficos primeiro para intuição visual antes do teste formal.",
                                  "learningObjective": "Identificar corretamente sazonalidade não estacionária usando testes e visualizações.",
                                  "commonMistakes": [
                                    "Ignorar gráficos ACF/PACF e confiar só no teste",
                                    "Usar teste ADF sem lags adequados",
                                    "Confundir não-estacionariedade de tendência com sazonal"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Determinar o período sazonal s",
                                  "subSteps": [
                                    "Analisar o período da sazonalidade via picos no ACF (ex: lag 12 para mensal-anual).",
                                    "Confirmar s com base no contexto dos dados (mensal=12, trimestral=4).",
                                    "Plotar sub-série sazonal (ex: médias por estação) para validar.",
                                    "Testar estabilidade do período s em sub-períodos da série.",
                                    "Documentar escolha de s com justificativa gráfica/estatística."
                                  ],
                                  "verification": "Picos ACF consistentes no lag s e validação contextual confirmada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python statsmodels.tsa.stattools.plot_acf",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Para dados mensais, comece assumindo s=12; ajuste se houver múltiplos ciclos.",
                                  "learningObjective": "Selecionar o lag sazonal apropriado baseado em evidências empíricas.",
                                  "commonMistakes": [
                                    "Escolher s arbitrário sem ACF",
                                    "Confundir s com ordem de ARIMA",
                                    "Ignorar mudanças no período ao longo do tempo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar diferenciação sazonal Δ^s",
                                  "subSteps": [
                                    "Implementar operador Δ^s = (1 - B^s) onde B é o operador lag, usando diff() no pandas.",
                                    "Aplicar Δ^s na série original: serie_sazonal_diff = serie.diff(s).dropna().",
                                    "Plotar a série diferenciada sazonalmente para inspecionar remoção visual da sazonalidade.",
                                    "Calcular e plotar ACF/PACF da série Δ^s para confirmar atenuação de picos sazonais.",
                                    "Verificar perda de observações iniciais e ajustar índices se necessário."
                                  ],
                                  "verification": "Gráficos mostram ausência de padrões sazonais persistentes pós-diferenciação.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Pandas para .diff(s)",
                                    "Statsmodels para plots ACF/PACF"
                                  ],
                                  "tips": "Use seasonal_decompose() do statsmodels para decompor e validar antes.",
                                  "learningObjective": "Executar matematicamente e computacionalmente a diferenciação sazonal.",
                                  "commonMistakes": [
                                    "Aplicar diff(1) em vez de diff(s)",
                                    "Não remover NaNs após diff",
                                    "Sobrediferenciar levando a sobre-diferenciação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar estacionariedade pós-diferenciação e interpretar resultados",
                                  "subSteps": [
                                    "Executar teste ADF na série Δ^s (esperado p-value <0.05).",
                                    "Comparar ACF/PACF pré e pós para confirmar remoção da sazonalidade.",
                                    "Interpretar: Δ^s torna a série adequada para modelagem SARIMA sem sazonalidade residual.",
                                    "Se ainda não estacionária, considerar diferenciação regular Δ^d adicional.",
                                    "Documentar relatório com plots, p-values e conclusão para identificação SARIMA."
                                  ],
                                  "verification": "p-value ADF <0.05 na Δ^s e ACF sem picos sazonais significativos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "statsmodels.tsa.stattools.adfuller",
                                    "Relatório em Markdown/Jupyter"
                                  ],
                                  "tips": "Salve todos os plots em uma figura comparativa para relatório claro.",
                                  "learningObjective": "Interpretar impacto da Δ^s na estacionariedade e preparar para SARIMA.",
                                  "commonMistakes": [
                                    "Não testar ADF pós-dif",
                                    "Ignorar resíduos sazonais fracos",
                                    "Concluir sem comparação pré/pós"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma série de vendas mensais de varejo (s=12), aplique Δ^12: vendas_diff = vendas.diff(12).dropna(). Teste ADF original (p=0.85, não-estacionária), pós-Δ^12 (p=0.01, estacionária). ACF pré mostra picos em lag 12, pós não.",
                              "finalVerifications": [
                                "Teste ADF confirma não-estacionariedade original (p>0.05).",
                                "Δ^s aplicada corretamente sem erros de indexação.",
                                "ACF/PACF pós-Δ^s sem picos sazonais significativos.",
                                "p-value ADF pós-Δ^s <0.05 indicando estacionariedade.",
                                "Relatório inclui plots comparativos e interpretação.",
                                "Série pronta para identificação de parâmetros SARIMA (p,d,q)(P,D,Q)s."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção de sazonalidade via testes e gráficos.",
                                "Implementação correta do operador Δ^s em código.",
                                "Validação estatística rigorosa (ADF pré/pós).",
                                "Interpretação clara dos resultados para modelagem.",
                                "Documentação completa com visualizações.",
                                "Eficiência: evita sobrediferenciação desnecessária."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python/R (statsmodels, forecast).",
                                "Econometria: Aplicação em séries financeiras sazonais.",
                                "Ciência de Dados: Pré-processamento para ML em time series.",
                                "Matemática: Operadores de lag e polinômios em processos estocásticos.",
                                "Negócios: Previsão de demanda sazonal."
                              ],
                              "realWorldApplication": "Em finanças, modelar retornos de ações com sazonalidade (ex: efeito janeiro); no varejo, prever vendas natalinas removendo Δ^12; em energia, forecast de consumo elétrico sazonal para planejamento de rede."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.2.3",
                            "name": "Selecionar ordens iniciais do modelo",
                            "description": "Usar regras empíricas baseadas em ACF/PACF para propor ordens candidatas de (p,d,q)(P,D,Q)s, considerando parcimônia.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Determinar ordens de diferenciação não-sazonal (d) e sazonal (D)",
                                  "subSteps": [
                                    "Visualize o gráfico da série temporal original para identificar tendências e sazonalidade.",
                                    "Aplique diferenciação de primeira ordem (não-sazonal) e verifique se a série se torna estacionária via teste ADF ou inspeção visual.",
                                    "Identifique o período sazonal (ex: 12 para dados mensais) e aplique diferenciação sazonal (D=1) se houver picos sazonais persistentes no ACF.",
                                    "Combine diferenciações até que a série seja estacionária (ACF sem decaimento lento).",
                                    "Registre valores de d (0-2) e D (0-1 tipicamente) baseados na mínima ordem necessária."
                                  ],
                                  "verification": "A série diferenciada deve passar no teste de estacionariedade (p-value ADF < 0.05) e ACF/PACF sem padrões de tendência/sazonalidade forte.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": "Série temporal dados (CSV), Python/R com bibliotecas statsmodels/forecast, gráficos ACF/PACF.",
                                  "tips": "Comece com d=1 e D=1; evite overdifferencing que cria ruído.",
                                  "learningObjective": "Compreender como diferenciação remove não-estacionaridade para preparar ACF/PACF análise.",
                                  "commonMistakes": "Ignorar teste formal de estacionariedade; overdifferencing levando a séries com variância excessiva."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar ACF da série diferenciada para ordens MA (q) e SMA (Q)",
                                  "subSteps": [
                                    "Plote o ACF da série após diferenciações d e D.",
                                    "Conte o número de lags significativos após o primeiro antes do decaimento exponencial para q (não-sazonal).",
                                    "Identifique picos sazonais significativos nos lags múltiplos de s (período sazonal) para Q.",
                                    "Defina q como o lag onde ACF corta para zero; Q similar para sazonal.",
                                    "Anotar candidatos iniciais: q=0-2, Q=0-1 priorizando parcimônia."
                                  ],
                                  "verification": "ACF deve mostrar corte significativo após lag q/Q, com barras dentro das bandas de confiança para lags maiores.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": "Gráficos ACF gerados em Python/R (funções acf() ou plot_acf()).",
                                  "tips": "Use bandas de confiança 95%; ignore lags iniciais afetados por diferenciação.",
                                  "learningObjective": "Interpretar ACF para capturar dependências de média móvel em componentes não-sazonal e sazonal.",
                                  "commonMistakes": "Confundir decaimento sinusoidal com MA; selecionar q alto sem parcimônia."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar PACF da série diferenciada para ordens AR (p) e SAR (P)",
                                  "subSteps": [
                                    "Plote o PACF da série diferenciada.",
                                    "Conte lags significativos com decaimento exponencial para p (não-sazonal AR).",
                                    "Verifique picos isolados nos lags sazonais (múltiplos de s) para P.",
                                    "Defina p pelo número de lags significativos antes do corte; P tipicamente 0 ou 1.",
                                    "Liste candidatos: p=0-2, P=0-1."
                                  ],
                                  "verification": "PACF corta após lag p/P, com insignificância subsequente.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": "Gráficos PACF em Python/R (pacf() ou plot_pacf()).",
                                  "tips": "PACF é mais útil para AR; combine com ACF para confirmação.",
                                  "learningObjective": "Usar PACF para identificar ordens autoregressivas em contextos sazonais.",
                                  "commonMistakes": "Interpretar decaimento lento como alta ordem p; ignorar sazonalidade em PACF."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Propor ordens candidatas finais considerando parcimônia e validação inicial",
                                  "subSteps": [
                                    "Combine sugestões: proponha 3-5 modelos (p,d,q)(P,D,Q)s com menor número de parâmetros.",
                                    "Priorize modelos onde ACF/PACF se alinham perfeitamente (ex: PACF corta em p, ACF em q).",
                                    "Ajuste SARIMA preliminar para cada candidato e compare AIC/BIC (menor é melhor).",
                                    "Elimine modelos overdiferenciados ou com muitos parâmetros sem ganho de fit.",
                                    "Documente a lista final de candidatos para estimação posterior."
                                  ],
                                  "verification": "Lista de 3-5 candidatos com AIC/BIC calculados; padrões ACF/PACF residual devem ser ruído branco.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": "Funções SARIMAX em statsmodels ou auto.arima em R.",
                                  "tips": "Regra de parcimônia: prefira (0,1,1)(0,1,1)12 sobre modelos complexos.",
                                  "learningObjective": "Aplicar princípios de parcimônia para seleção robusta de ordens SARIMA.",
                                  "commonMistakes": "Selecionar único modelo sem candidatos; ignorar critérios de informação como AIC."
                                }
                              ],
                              "practicalExample": "Para dados mensais de passageiros aéreos (AirPassengers dataset): Após d=1, D=1, s=12, ACF mostra pico em lag 1 (q=1), PACF pico em lag 1 não-sazonal (p=1) e lag 12 (P=1, mas parcimônia sugere P=0). Candidatos: (1,1,1)(0,1,1)12 e (0,1,1)(0,1,1)12; AIC seleciona o primeiro.",
                              "finalVerifications": [
                                "Série diferenciada é estacionária (ADF p<0.05).",
                                "ACF corta após q/Q lags significativos.",
                                "PACF corta após p/P lags significativos.",
                                "Candidatos têm AIC/BIC baixos e parcimonia (≤5 parâmetros).",
                                "Resíduos preliminares do modelo candidato são ruído branco (Ljung-Box p>0.05).",
                                "Gráficos ACF/PACF dos resíduos sem padrões restantes."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de d/D baseada em estacionariedade.",
                                "Interpretação correta de padrões ACF/PACF para q/Q e p/P.",
                                "Aplicação consistente de regras empíricas (Box-Jenkins).",
                                "Seleção parcimoniosa com múltiplos candidatos e comparação AIC.",
                                "Documentação clara de justificativas e gráficos.",
                                "Validação inicial via fit preliminar e diagnósticos de resíduos."
                              ],
                              "crossCurricularConnections": [
                                "Estatística Inferencial: Testes de estacionariedade (ADF) e diagnósticos de resíduos (Ljung-Box).",
                                "Programação Computacional: Uso de Python/R para plots ACF/PACF e modelagem SARIMA.",
                                "Matemática Aplicada: Compreensão de processos estocásticos e funções de autocorrelação.",
                                "Análise de Dados Exploratória: Visualização e interpretação de gráficos temporais."
                              ],
                              "realWorldApplication": "Em previsão de demanda sazonal para varejo (ex: vendas de Natal), finanças (retornos de ações com ciclos) ou epidemiologia (casos de doenças sazonais), onde ordens iniciais corretas levam a previsões precisas, otimizando estoque, investimentos ou alocação de recursos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.4.3",
                        "name": "Estimação, Diagnóstico e Previsão com SARIMA",
                        "description": "Etapas de ajuste do modelo SARIMA, validação dos resíduos e geração de previsões, incluindo implementação prática.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.3.1",
                            "name": "Estimar parâmetros do modelo SARIMA",
                            "description": "Ajustar o modelo SARIMA usando máxima verossimilhança em software como R (função arima()), interpretando coeficientes e significância estatística.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os dados e especificar as ordens do modelo SARIMA",
                                  "subSteps": [
                                    "Carregar os dados de série temporal sazonal em R usando read.csv() ou ts().",
                                    "Verificar estacionariedade com testes como ADF e KPSS, aplicando diferenciação se necessário.",
                                    "Identificar ordens não sazonais (p,d,q) via ACF/PACF dos resíduos.",
                                    "Identificar ordens sazonais (P,D,Q) e período sazonal (s) via ACF/PACF sazonal.",
                                    "Especificar o modelo SARIMA(p,d,q)(P,D,Q)s com base nas análises."
                                  ],
                                  "verification": "Gráficos de ACF/PACF mostram identificação clara das ordens e resíduos aproximadamente brancos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "R e RStudio instalados",
                                    "Pacotes: forecast, tseries",
                                    "Dados de série temporal sazonal (ex: AirPassengers)"
                                  ],
                                  "tips": "Comece com modelos simples e use auto.arima() para sugestões iniciais, mas entenda o processo manual.",
                                  "learningObjective": "Identificar corretamente as ordens p,d,q,P,D,Q,s para um modelo SARIMA.",
                                  "commonMistakes": [
                                    "Ignorar sazonalidade ao analisar ACF/PACF",
                                    "Sobrediferenciação levando a resíduos não estacionários",
                                    "Não transformar dados (log) para estabilizar variância"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Ajustar o modelo SARIMA usando máxima verossimilhança",
                                  "subSteps": [
                                    "Definir o objeto ts com frequência sazonal (ex: frequency=12 para mensal).",
                                    "Usar função arima() com ordem=c(p,d,q), seasonal=c(P,D,Q,s) e method='ML'.",
                                    "Capturar o output do modelo em uma variável (ex: sarima_model <- arima(data, order=..., seasonal=...)).",
                                    "Verificar convergência do algoritmo de otimização.",
                                    "Salvar coeficientes iniciais com coef(sarima_model)."
                                  ],
                                  "verification": "Modelo ajustado sem warnings de não-convergência e log-likelihood finito.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "R com pacotes stats e forecast",
                                    "Script R preparado do Step 1"
                                  ],
                                  "tips": "Use include.mean=FALSE se tendência for capturada por diferenciação; monitore iterações com trace=TRUE.",
                                  "learningObjective": "Ajustar um modelo SARIMA via máxima verossimilhança no R.",
                                  "commonMistakes": [
                                    "Especificar ordens erradas levando a não-convergência",
                                    "Não definir frequência correta no ts()",
                                    "Ignorar warnings de otimização"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar os coeficientes estimados do modelo",
                                  "subSteps": [
                                    "Extrair coeficientes com summary(sarima_model) ou coef().",
                                    "Interpretar AR/MA não sazonais: impacto de lags passados/futuros nos resíduos.",
                                    "Interpretar SAR/SMA sazonais: impacto de lags sazonais (ex: ano anterior).",
                                    "Analisar o intercepto ou mean se incluído.",
                                    "Comparar com teoria: coeficientes AR <1 em módulo para estacionariedade."
                                  ],
                                  "verification": "Relatório escrito explicando o significado de cada coeficiente no contexto da série.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Modelo ajustado do Step 2",
                                    "Documentação arima() no R help()"
                                  ],
                                  "tips": "Visualize impulse response com arma.roots() para entender dinâmica.",
                                  "learningObjective": "Explicar o papel de cada coeficiente no modelo SARIMA.",
                                  "commonMistakes": [
                                    "Confundir AR com MA",
                                    "Interpretar coeficientes sem considerar sazonalidade",
                                    "Ignorar sinais e magnitudes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar a significância estatística dos parâmetros",
                                  "subSteps": [
                                    "Usar summary() para obter p-values dos testes t.",
                                    "Verificar se |t-ratio| > 2 ou p-value < 0.05 para significância.",
                                    "Analisar intervalos de confiança com confint(sarima_model).",
                                    "Testar hipóteses nulas de coeficiente=0.",
                                    "Documentar parâmetros insignificantes para simplificação futura."
                                  ],
                                  "verification": "Tabela de summary com todos p-values <0.05 para coeficientes mantidos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Modelo ajustado",
                                    "Pacote broom para tidy(summary()) opcional"
                                  ],
                                  "tips": "Remova termos insignificantes iterativamente com step() ou auto.arima().",
                                  "learningObjective": "Determinar quais parâmetros são estatisticamente significativos.",
                                  "commonMistakes": [
                                    "Confundir t-ratio com p-value",
                                    "Não ajustar por múltiplos testes",
                                    "Manter termos insignificantes inflando variância"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando o dataset AirPassengers (passageiros aéreos mensais), especifique SARIMA(0,1,1)(0,1,1)12, ajuste com arima(AirPassengers, order=c(0,1,1), seasonal=c(0,1,1,12)), interprete coef ma1 e sma1, e verifique p-values <0.05.",
                              "finalVerifications": [
                                "Ajusta modelo SARIMA convergente sem erros.",
                                "Interpreta corretamente todos coeficientes AR/MA/SAR/SMA.",
                                "Identifica parâmetros significativos via p-values.",
                                "Gera summary() com log-likelihood e AIC comparáveis.",
                                "Aplica em dataset novo com sucesso.",
                                "Explica impacto de parâmetros na previsão."
                              ],
                              "assessmentCriteria": [
                                "Precisão na especificação de ordens (ACF/PACF correto): 25%.",
                                "Convergência e ajuste ML sem warnings: 20%.",
                                "Interpretação qualitativa/quantitativa de coefs: 25%.",
                                "Análise de significância com p-values e confint: 20%.",
                                "Relatório claro com código reproduzível: 10%."
                              ],
                              "crossCurricularConnections": [
                                "Estatística Inferencial (testes de hipóteses t).",
                                "Programação em R (manipulação de ts e modelagem).",
                                "Análise de Séries Temporais Não Sazonais (base ARIMA).",
                                "Econometria (modelos para dados econômicos sazonais).",
                                "Machine Learning (previsão com modelos lineares)"
                              ],
                              "realWorldApplication": "Em previsão de vendas sazonais para varejo (ex: Natal), análise de dados climáticos mensais para agricultura, ou séries financeiras trimestrais como PIB para políticas econômicas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.3.2",
                            "name": "Diagnosticar resíduos do modelo",
                            "description": "Verificar resíduos para ausência de autocorrelação (Ljung-Box), normalidade e homocedasticidade, ajustando o modelo se necessário.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Extrair e visualizar resíduos do modelo SARIMA",
                                  "subSteps": [
                                    "Ajuste o modelo SARIMA aos dados usando statsmodels em Python.",
                                    "Extraia os resíduos com model.resid.",
                                    "Crie plots básicos: resíduos vs tempo, histograma e QQ plot.",
                                    "Gere ACF/PACF dos resíduos para inspeção visual inicial.",
                                    "Salve os plots para análise posterior."
                                  ],
                                  "verification": "Verifique se os plots mostram ausência óbvia de padrões nos resíduos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python (statsmodels, matplotlib, seaborn), dados de série temporal sazonal (ex: airpassengers).",
                                  "tips": "Use scale=1 no QQ plot para melhor visualização de desvios nas caudas.",
                                  "learningObjective": "Compreender a extração e visualização inicial de resíduos para diagnóstico.",
                                  "commonMistakes": "Esquecer de diferenciar a série adequadamente antes do ajuste, levando a resíduos não estacionários."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Testar ausência de autocorrelação com Ljung-Box",
                                  "subSteps": [
                                    "Importe acorr_ljungbox de statsmodels.stats.diagnostic.",
                                    "Aplique o teste: acorr_ljungbox(resid, lags=10, return_df=True).",
                                    "Interprete p-valores: p > 0.05 indica ausência de autocorrelação.",
                                    "Teste múltiplos lags (ex: 10-20) para robustez.",
                                    "Registre os resultados em um DataFrame para relatório."
                                  ],
                                  "verification": "P-valores consistentemente acima de 0.05 para lags relevantes.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Python (statsmodels.stats.diagnostic), notebook Jupyter.",
                                  "tips": "Use boxpierce=True para teste adicional de Box-Pierce como confirmação.",
                                  "learningObjective": "Aplicar e interpretar o teste Ljung-Box para validar independência dos resíduos.",
                                  "commonMistakes": "Ignorar lags altos, onde autocorrelação sazonal pode persistir."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar normalidade dos resíduos",
                                  "subSteps": [
                                    "Use shapiro de scipy.stats para teste formal (shapiro(resid)).",
                                    "Crie QQ plot com statsmodels.qqplot(resid).",
                                    "Gere histograma com KDE overlay para inspeção visual.",
                                    "Calcule estatísticas descritivas: skew e kurtosis com scipy.stats.",
                                    "Compare com distribuição normal teórica."
                                  ],
                                  "verification": "p-value > 0.05 no Shapiro-Wilk e QQ plot alinhado na reta diagonal.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Python (scipy.stats, statsmodels.graphics), matplotlib.",
                                  "tips": "Para amostras grandes, prefira QQ plot sobre teste Shapiro, que é sensível a tamanho.",
                                  "learningObjective": "Avaliar se resíduos seguem distribuição normal usando testes e gráficos.",
                                  "commonMistakes": "Aplicar Shapiro-Wilk em >5000 observações, onde rejeita normalidade mesmo se ok."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar homocedasticidade dos resíduos",
                                  "subSteps": [
                                    "Gere fitted values com model.fittedvalues.",
                                    "Crie scatter plot: resíduos vs fitted values.",
                                    "Aplique teste Breusch-Pagan: het_breuschpagan(resid, model.model.exog).",
                                    "Inspecione plot de resíduos ordenados vs quantis teóricos.",
                                    "Documente variância condicional se detectada."
                                  ],
                                  "verification": "Scatter plot sem padrão de funil e p-value > 0.05 no Breusch-Pagan.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python (statsmodels.stats.diagnostic.het_breuschpagan), seaborn para plots.",
                                  "tips": "Padronize resíduos (resid / std) para melhor visualização.",
                                  "learningObjective": "Detectar heteroscedasticidade e interpretar impactos no modelo.",
                                  "commonMistakes": "Confundir heteroscedasticidade com autocorrelação nos plots."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar resultados e ajustar o modelo SARIMA",
                                  "subSteps": [
                                    "Revise todos os testes: identifique falhas (ex: autocorr em lag sazonal).",
                                    "Ajuste parâmetros: aumente ordens MA/SMA se autocorr; adicione transformações se heteroscedasticidade.",
                                    "Reajuste o modelo e re-teste resíduos iterativamente.",
                                    "Compare AIC/BIC antes/depois para validar melhoria.",
                                    "Documente mudanças em um relatório final."
                                  ],
                                  "verification": "Todos testes passam após ajustes; AIC reduzido.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Código do modelo anterior, notebook para iterações.",
                                  "tips": "Mantenha grid search limitado para evitar overfitting.",
                                  "learningObjective": "Iterar ajustes baseados em diagnóstico para otimizar SARIMA.",
                                  "commonMistakes": "Ajustar excessivamente sem validação out-of-sample."
                                }
                              ],
                              "practicalExample": "Usando dados de passageiros aéreos (airpassengers dataset), ajuste SARIMA(1,1,1)(1,1,1)12, extraia resíduos, aplique Ljung-Box (p=0.45), Shapiro (p=0.12), Breusch-Pagan (p=0.67). Como autocorr persiste em lag 12, ajuste para SARIMA(1,1,1)(1,1,2)12, reteste e confirme melhorias.",
                              "finalVerifications": [
                                "Ljung-Box p-values > 0.05 para lags 1-20.",
                                "QQ plot linear sem desvios nas caudas.",
                                "Scatter resíduos vs fitted sem padrão de dispersão crescente.",
                                "Skewness e kurtosis próximos de 0 e 3.",
                                "AIC/BIC melhorado após ajustes.",
                                "ACF resíduos dentro de bandas de confiança."
                              ],
                              "assessmentCriteria": [
                                "Correta extração e plotting de resíduos (visual sem padrões).",
                                "Interpretação precisa de p-values em testes (Ljung-Box, Shapiro, Breusch-Pagan).",
                                "Identificação de violações e propostas de ajustes específicos (ex: ordem MA).",
                                "Iteração efetiva com re-teste e comparação de métricas de modelo.",
                                "Relatório claro documentando passos e conclusões.",
                                "Código reproduzível e comentado."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Manipulação de dados em Python/R com pandas/statsmodels.",
                                "Machine Learning: Validação de resíduos similar a diagnósticos em regressão/ML.",
                                "Econometria: Aplicação em previsão econômica sazonal.",
                                "Visualização de Dados: Uso de plots para comunicação de resultados estatísticos."
                              ],
                              "realWorldApplication": "Em previsão de demanda sazonal para varejo (ex: vendas de Natal), diagnosticar resíduos garante previsões confiáveis, evitando subestimação de picos e otimizando estoque, reduzindo custos em milhões para empresas como Amazon."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.3.3",
                            "name": "Gerar previsões com SARIMA",
                            "description": "Produzir previsões pontuais e intervalos de confiança usando forecast(), avaliando precisão com métricas como MAE e RMSE em dados de validação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o modelo SARIMA ajustado e definir parâmetros de previsão",
                                  "subSteps": [
                                    "Carregue o modelo SARIMA previamente ajustado usando statsmodels.",
                                    "Defina o horizonte de previsão (h) com base no contexto, ex: h=12 para dados mensais.",
                                    "Separe os dados em treino e validação, garantindo que a validação cubra o período de teste.",
                                    "Verifique a estacionariedade residual do modelo com Ljung-Box test.",
                                    "Salve os dados de validação reais para comparação futura."
                                  ],
                                  "verification": "Execute model_fit.summary() e confirme ausência de erros; verifique len(forecast) == h.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python com statsmodels e pandas",
                                    "Notebook Jupyter",
                                    "Dados de série temporal (ex: AirPassengers)"
                                  ],
                                  "tips": "Sempre use o mesmo seed para reprodutibilidade com np.random.seed(42).",
                                  "learningObjective": "Configurar corretamente o ambiente para geração de previsões confiáveis.",
                                  "commonMistakes": [
                                    "Não definir h adequadamente",
                                    "Usar dados de treino como validação",
                                    "Ignorar diagnóstico prévio do modelo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar previsões pontuais usando forecast()",
                                  "subSteps": [
                                    "Chame forecast(modelo_ajustado, steps=h) para obter as previsões pontuais.",
                                    "Armazene o resultado em uma variável, ex: previsoes = modelo_ajustado.forecast(steps=h).",
                                    "Converta para DataFrame com index de datas futuras usando pd.date_range.",
                                    "Plote as previsões sobre a série histórica para inspeção visual inicial.",
                                    "Registre os valores pontuais em uma lista ou array para cálculos posteriores."
                                  ],
                                  "verification": "Verifique se previsoes.shape[0] == h e plote para confirmar continuidade com dados históricos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "statsmodels.tsa.statespace.sarimax.SARIMAXResults",
                                    "matplotlib.pyplot"
                                  ],
                                  "tips": "Use alpha=0.05 para intervalos de 95% de confiança por padrão.",
                                  "learningObjective": "Dominar a função forecast() para previsões pontuais em SARIMA.",
                                  "commonMistakes": [
                                    "Confundir forecast() com predict()",
                                    "Esquecer de especificar steps=h",
                                    "Não alinhar índices de tempo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular intervalos de confiança para as previsões",
                                  "subSteps": [
                                    "Use get_forecast(steps=h) para obter objeto com intervalos.",
                                    "Extraia lower e upper bounds: conf_int = previsao_get.conf_int(alpha=0.05).",
                                    "Calcule a largura média dos intervalos para avaliar incerteza.",
                                    "Visualize os intervalos sombreados no gráfico com fill_between().",
                                    "Compare largura dos intervalos com a variância histórica da série."
                                  ],
                                  "verification": "Confirme que conf_int tem colunas 'lower' e 'upper' e que upper > point forecast > lower.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "statsmodels forecast object",
                                    "pandas DataFrame"
                                  ],
                                  "tips": "Ajuste alpha para intervalos mais largos (ex: 0.1 para 90%) se necessário.",
                                  "learningObjective": "Entender e aplicar intervalos de confiança em previsões SARIMA.",
                                  "commonMistakes": [
                                    "Usar forecast() em vez de get_forecast() para intervalos",
                                    "Ignorar alpha",
                                    "Não plotar para visualização"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar precisão das previsões com MAE e RMSE em dados de validação",
                                  "subSteps": [
                                    "Calcule erros: erros = abs(dados_validacao - previsoes_pontuais).",
                                    "Compute MAE: mae = np.mean(erros).",
                                    "Compute RMSE: rmse = np.sqrt(np.mean(erros**2)).",
                                    "Compare com baseline (ex: média histórica) usando métricas normalizadas.",
                                    "Registre resultados em um relatório com thresholds de aceitabilidade."
                                  ],
                                  "verification": "Execute cálculos e confirme MAE e RMSE numéricos finitos e lógicos (ex: MAE < 20% da média).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "numpy",
                                    "sklearn.metrics (mean_absolute_error, mean_squared_error)"
                                  ],
                                  "tips": "Use train_test_split para validação cruzada temporal se possível.",
                                  "learningObjective": "Aplicar métricas padrão para validar qualidade de previsões.",
                                  "commonMistakes": [
                                    "Usar todos os dados como treino",
                                    "Não alinhar séries temporalmente",
                                    "Confundir MAE com MSE"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar resultados e gerar relatório final",
                                  "subSteps": [
                                    "Analise se intervalos capturam dados reais de validação.",
                                    "Discuta implicações: precisão alta indica bom modelo sazonal.",
                                    "Crie dashboard com plots, métricas e tabela de previsões.",
                                    "Sugira melhorias: refit com mais dados ou tune hiperparâmetros.",
                                    "Exporte resultados para CSV ou PDF para compartilhamento."
                                  ],
                                  "verification": "Gere relatório com plots legíveis e métricas < thresholds definidos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "matplotlib/seaborn",
                                    "pandas to_csv()"
                                  ],
                                  "tips": "Inclua legenda clara nos gráficos para stakeholders não técnicos.",
                                  "learningObjective": "Interpretar e comunicar resultados de previsões SARIMA.",
                                  "commonMistakes": [
                                    "Ignorar incerteza nos intervalos",
                                    "Não comparar com baseline",
                                    "Relatórios sem visualizações"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando o dataset clássico AirPassengers (passageiros aéreos mensais com sazonalidade), ajuste um SARIMA(1,1,1)(1,1,1)12, gere previsões para 12 meses à frente, calcule intervalos de 95% e avalie MAE/RMSE contra dados reais de validação, visualizando tudo em um gráfico com faixas de confiança.",
                              "finalVerifications": [
                                "Previsões pontuais geradas com forecast(steps=h) sem erros.",
                                "Intervalos de confiança extraídos corretamente via get_forecast().",
                                "MAE e RMSE calculados e inferiores a baselines históricos.",
                                "Gráficos mostram sobreposição adequada entre previsões e validação.",
                                "Relatório inclui interpretação de incerteza e recomendações.",
                                "Código é reprodutível com dados e seed fixos."
                              ],
                              "assessmentCriteria": [
                                "MAE < 10% da média da série de validação.",
                                "RMSE indica baixa variância nos erros residuais.",
                                "95% dos dados de validação dentro dos intervalos de confiança.",
                                "Visualizações claras e profissionais.",
                                "Código comentado e modular.",
                                "Interpretação conecta resultados a contexto sazonal."
                              ],
                              "crossCurricularConnections": [
                                "Estatística Inferencial: construção e interpretação de intervalos de confiança.",
                                "Programação em Python: manipulação de séries temporais com pandas e statsmodels.",
                                "Machine Learning: avaliação de modelos com métricas de regressão.",
                                "Gestão e Economia: previsão de demanda sazonal para planejamento.",
                                "Visualização de Dados: criação de gráficos informativos com matplotlib."
                              ],
                              "realWorldApplication": "Em varejo para prever vendas sazonais de produtos (ex: Natal), otimizando estoque e logística; em finanças para forecasting de ações com padrões sazonais; ou em energia para antecipar consumo mensal e gerenciar redes elétricas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.3.4",
                            "name": "Aplicar SARIMA em contextos reais",
                            "description": "Implementar SARIMA em séries sazonais de finanças (ex: ações), marketing (vendas mensais) ou operações, usando bibliotecas R como forecast.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparação e Exploração dos Dados",
                                  "subSteps": [
                                    "Carregar os dados sazonais em R usando read.csv() ou similares.",
                                    "Visualizar a série temporal com plot() e identificar padrões sazonais.",
                                    "Testar estacionariedade com testes como Augmented Dickey-Fuller (adf.test do pacote tseries).",
                                    "Diferenciar a série se necessário e decompor com stl() para confirmar sazonalidade.",
                                    "Dividir os dados em treino e teste (ex: 80/20)."
                                  ],
                                  "verification": "Gráficos mostram sazonalidade clara e testes confirmam não-estacionariedade resolvida.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "R/RStudio",
                                    "Pacotes: forecast, tseries, ggplot2",
                                    "Dataset sazonal (ex: AirPassengers ou dados de vendas mensais)"
                                  ],
                                  "tips": "Sempre plote múltiplas visualizações (ACF, PACF) para intuição inicial.",
                                  "learningObjective": "Preparar dados reais para modelagem SARIMA, identificando componentes sazonais.",
                                  "commonMistakes": [
                                    "Ignorar missing values",
                                    "Não testar estacionariedade antes",
                                    "Usar dados não sazonais como exemplo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificação e Especificação do Modelo SARIMA",
                                  "subSteps": [
                                    "Analisar gráficos ACF e PACF da série diferenciada para determinar ordens p, d, q.",
                                    "Identificar período sazonal (P, D, Q) via ACF sazonal.",
                                    "Usar auto.arima() do pacote forecast para sugestão automática de parâmetros.",
                                    "Especificar modelo manualmente com Sarima() ou auto.arima() com seasonal=TRUE.",
                                    "Comparar múltiplas especificações com AIC/BIC."
                                  ],
                                  "verification": "Parâmetros selecionados minimizam AIC e gráficos ACF/PACF mostram corte claro.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Pacotes: forecast",
                                    "Série temporal preparada do Step 1"
                                  ],
                                  "tips": "Comece com auto.arima() para baseline, depois refine manualmente.",
                                  "learningObjective": "Selecionar ordens ótimas de SARIMA baseadas em evidências gráficas e estatísticas.",
                                  "commonMistakes": [
                                    "Confundir ordens não-sazonais com sazonais",
                                    "Ignorar sobre-diferenciação",
                                    "Não validar com critérios de informação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estimação do Modelo SARIMA",
                                  "subSteps": [
                                    "Ajustar o modelo com Arima() ou sarima() especificando ordem (p,d,q)(P,D,Q)s.",
                                    "Verificar convergência e sumarizar coeficientes com summary().",
                                    "Inspecionar intervalos de confiança dos parâmetros.",
                                    "Salvar o modelo ajustado para uso posterior.",
                                    "Testar estabilidade com checkresiduals() preliminar."
                                  ],
                                  "verification": "Modelo convergeu (sem warnings de não-convergência) e coeficientes significativos.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Pacotes: forecast",
                                    "Modelo especificado do Step 2"
                                  ],
                                  "tips": "Aumente maxiter em Arima() se não convergir.",
                                  "learningObjective": "Estimar parâmetros SARIMA de forma robusta em dados reais.",
                                  "commonMistakes": [
                                    "Usar dados insuficientes para estimação",
                                    "Ignorar multicolinearidade em parâmetros",
                                    "Não checar significância"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diagnóstico e Validação do Modelo",
                                  "subSteps": [
                                    "Analisar resíduos com checkresiduals() ou Ljung-Box test.",
                                    "Verificar normalidade com qqnorm() e teste Shapiro-Wilk.",
                                    "Plotar resíduos vs fitted e histogram para homocedasticidade.",
                                    "Testar white noise nos resíduos (ACF/PACF deve ser insignificante).",
                                    "Comparar com baselines como naive ou ETS via accuracy()."
                                  ],
                                  "verification": "Resíduos passam em testes de white noise e normalidade (p-value > 0.05).",
                                  "estimatedTime": "45 minutos-1 hora",
                                  "materials": [
                                    "Pacotes: forecast, tseries",
                                    "Modelo estimado do Step 3"
                                  ],
                                  "tips": "Se resíduos correlacionados, rever ordens do modelo.",
                                  "learningObjective": "Diagnosticar adequação do SARIMA garantindo resíduos adequados.",
                                  "commonMistakes": [
                                    "Aceitar modelo sem diagnóstico completo",
                                    "Confundir heterocedasticidade com autocorrelação",
                                    "Ignorar outliers nos resíduos"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Previsão e Aplicação Prática",
                                  "subSteps": [
                                    "Gerar previsões com forecast() para horizonte desejado (ex: 12 meses).",
                                    "Calcular intervalos de predição e plotar com autoplot().",
                                    "Validar em conjunto de teste com MAE, RMSE via accuracy().",
                                    "Interpretar resultados no contexto real (ex: impacto sazonal).",
                                    "Exportar previsões e relatório."
                                  ],
                                  "verification": "Previsões batem com teste (RMSE < baseline) e plots coerentes.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Pacotes: forecast",
                                    "Dados de teste",
                                    "Modelo validado"
                                  ],
                                  "tips": "Use h=período sazonal para testes realistas.",
                                  "learningObjective": "Aplicar SARIMA para previsões acionáveis em cenários reais.",
                                  "commonMistakes": [
                                    "Horizonte de previsão muito longo sem validação",
                                    "Não reportar incertezas",
                                    "Ignorar contexto de negócio"
                                  ]
                                }
                              ],
                              "practicalExample": "Implementar SARIMA para prever vendas mensais sazonais de uma rede de varejo (dados de 2015-2023), identificando pico de Natal (s=12), ajustando (1,1,1)(1,1,1)12, diagnosticando resíduos e prevendo 2024 com RMSE validado em 15%.",
                              "finalVerifications": [
                                "Modelo SARIMA ajustado converge e AIC otimizado.",
                                "Resíduos são white noise (Ljung-Box p>0.05).",
                                "Previsões em teste têm precisão superior a baselines.",
                                "Gráficos ACF/PACF confirmam especificação.",
                                "Aplicação contextualizada com interpretação de sazonalidade.",
                                "Código R reproduzível e documentado."
                              ],
                              "assessmentCriteria": [
                                "Precisão das previsões (RMSE < 20% do baseline).",
                                "Qualidade do diagnóstico de resíduos (todos testes passados).",
                                "Correta identificação de parâmetros sazonais.",
                                "Uso apropriado de bibliotecas forecast.",
                                "Relatório claro com visualizações e interpretações.",
                                "Tratamento robusto de dados reais (missing, outliers)."
                              ],
                              "crossCurricularConnections": [
                                "Finanças: Previsão de séries de ações ou câmbio sazonal.",
                                "Marketing: Análise de vendas e demanda sazonal para campanhas.",
                                "Operações: Otimização de estoque e supply chain com previsões.",
                                "Economia: Modelagem de indicadores macroeconômicos sazonais.",
                                "Machine Learning: Integração SARIMA com redes neurais para híbridos."
                              ],
                              "realWorldApplication": "Em finanças, prever retornos sazonais de ações para portfólios; em marketing, otimizar promoções baseadas em vendas mensais; em operações, gerenciar inventário para picos sazonais como Black Friday, reduzindo custos em até 20% via forecast preciso."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.5",
                    "name": "Métodos de Previsão Específicos para Séries Sazonais",
                    "description": "Técnicas e algoritmos automáticos apropriados para previsão de séries com sazonalidade.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.5.1",
                        "name": "Descomposição de Séries Temporais Sazonais",
                        "description": "Técnica para separar uma série temporal sazonal em componentes de tendência, sazonalidade e resíduo, permitindo previsões baseadas em cada parte.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.1.1",
                            "name": "Identificar componentes sazonais em uma série temporal",
                            "description": "Analisar gráficos e estatísticas para detectar padrões sazonais, como ciclos anuais ou mensais, e escolher entre decomposição aditiva ou multiplicativa com base na variância.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e Visualizar a Série Temporal",
                                  "subSteps": [
                                    "Carregue o dataset da série temporal usando ferramentas como pandas em Python.",
                                    "Converta a coluna de data para formato datetime e defina como índice.",
                                    "Plote o gráfico da série temporal com matplotlib ou seaborn para inspeção inicial.",
                                    "Aplique suavização móvel (ex: média móvel de 12 meses) para destacar tendências.",
                                    "Salve o gráfico e anote observações iniciais sobre possíveis padrões."
                                  ],
                                  "verification": "Gráfico plotado corretamente mostrando a série e suavização, com anotações salvas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python (pandas, matplotlib)",
                                    "Dataset de série temporal exemplo (ex: AirPassengers.csv)"
                                  ],
                                  "tips": [
                                    "Use log escala se variância aumentar com o tempo.",
                                    "Escolha período de suavização baseado no ciclo suspeito (ex: 12 para mensal)."
                                  ],
                                  "learningObjective": "Preparar dados para análise visual clara de componentes.",
                                  "commonMistakes": [
                                    "Ignorar formato de data incorreto.",
                                    "Não aplicar suavização, confundindo ruído com sazonalidade."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Padrões Sazonais Visualmente",
                                  "subSteps": [
                                    "Examine o gráfico por repetições regulares (ex: picos anuais em dezembro).",
                                    "Meça amplitude e período dos ciclos (anual=12 meses, semanal=7).",
                                    "Compare múltiplos anos para confirmar consistência sazonal.",
                                    "Anote o período sazonal estimado e exemplos de picos/vales.",
                                    "Crie subgráficos de médias sazonais por mês/trimestre."
                                  ],
                                  "verification": "Relatório escrito com período sazonal identificado e exemplos visuais destacados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Gráficos gerados no Step 1",
                                    "Ferramentas de plotagem avançada (plotly para interatividade)"
                                  ],
                                  "tips": [
                                    "Procure por 'ondas' regulares sobrepostas à tendência.",
                                    "Use zoom em períodos específicos para detalhes."
                                  ],
                                  "learningObjective": "Detectar ciclos sazonais por inspeção gráfica intuitiva.",
                                  "commonMistakes": [
                                    "Confundir tendência de longo prazo com sazonalidade.",
                                    "Ignorar variações em amplitude ao longo do tempo."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar Análise Estatística de Sazonalidade",
                                  "subSteps": [
                                    "Calcule a Função de Autocorrelação (ACF) para lags múltiplos do período suspeito.",
                                    "Analise o gráfico PACF para confirmação de sazonalidade.",
                                    "Teste estatístico como Kruskal-Wallis para diferenças sazonais significativas.",
                                    "Compute médias e desvios por temporada e plote boxplots.",
                                    "Registre p-valores e lags significativos."
                                  ],
                                  "verification": "Gráficos ACF/PACF e testes estatísticos produzidos com interpretações.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Biblioteca statsmodels ou R (forecast)",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": [
                                    "Picos em ACF no lag=12 confirmam sazonalidade anual.",
                                    "Ajuste lags para dados diários (ex: 365)."
                                  ],
                                  "learningObjective": "Quantificar sazonalidade com ferramentas estatísticas robustas.",
                                  "commonMistakes": [
                                    "Interpretar ruído como sinal sem significância estatística.",
                                    "Usar lags errados para o período."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Escolher Decomposição Aditiva ou Multiplicativa",
                                  "subSteps": [
                                    "Avalie variância residual após remoção de tendência: constante=aditiva, crescente=Multiplicativa.",
                                    "Plote log da série: se variância estabiliza, prefira multiplicativa.",
                                    "Compare resíduos de ambos modelos via AIC ou visualmente.",
                                    "Aplique decomposição preliminar com statsmodels.tsa.seasonal_decompose.",
                                    "Documente a escolha com evidências de variância."
                                  ],
                                  "verification": "Decomposição executada e escolha justificada em relatório.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "statsmodels library",
                                    "Gráficos de resíduos"
                                  ],
                                  "tips": [
                                    "Multiplicativa para séries com variância proporcional ao nível.",
                                    "Sempre valide com plot de resíduos."
                                  ],
                                  "learningObjective": "Selecionar modelo apropriado baseado em propriedades da variância.",
                                  "commonMistakes": [
                                    "Escolher aditiva em séries com heteroscedasticidade.",
                                    "Não comparar ambos os modelos."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e Refinar Identificação Sazonal",
                                  "subSteps": [
                                    "Examine componentes extraídos: sazonal deve ser consistente.",
                                    "Teste remoção do componente sazonal: resíduos devem ser estacionários.",
                                    "Ajuste período se necessário e re-decompose.",
                                    "Gere relatório final com todos os gráficos e conclusões.",
                                    "Simule previsão curta para validar."
                                  ],
                                  "verification": "Relatório completo com decomposição validada e resíduos analisados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Decomposição do Step 4",
                                    "Testes de estacionariedade (ADF)"
                                  ],
                                  "tips": [
                                    "Resíduos brancos ideais: sem autocorrelação.",
                                    "Itere se sazonalidade não for clara."
                                  ],
                                  "learningObjective": "Confirmar robustez da identificação sazonal.",
                                  "commonMistakes": [
                                    "Aceitar decomposição sem checar resíduos.",
                                    "Sobreajustar período sazonal."
                                  ]
                                }
                              ],
                              "practicalExample": "Em dados mensais de vendas de varejo (ex: dataset de supermercado), observe picos consistentes em dezembro (Natal) e quedas em fevereiro. A variância aumenta com vendas totais, sugerindo decomposição multiplicativa. Plote ACF com pico em lag=12, confirme com decompose(model='multiplicative').",
                              "finalVerifications": [
                                "Identifica corretamente período sazonal no gráfico visual.",
                                "Gera ACF/PACF mostrando lags sazonais significativos.",
                                "Escolhe aditiva/multiplicativa com justificativa de variância.",
                                "Produz decomposição com componentes claros e resíduos adequados.",
                                "Valida com teste de estacionariedade nos resíduos.",
                                "Explica escolha em relatório conciso."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção visual: 90% de acerto em padrões reais.",
                                "Correção estatística: p-valores <0.05 em testes sazonais.",
                                "Escolha de modelo: Alinhada com análise de variância (80% casos).",
                                "Qualidade de decomposição: Resíduos estacionários (ADF p<0.05).",
                                "Relatório completo: Todos gráficos e justificativas presentes.",
                                "Tempo de execução: Dentro de estimados com eficiência."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estatística descritiva e testes de hipótese.",
                                "Economia: Previsão de demanda e ciclos econômicos.",
                                "Ciência Ambiental: Padrões climáticos sazonais em dados meteorológicos.",
                                "Ciência de Dados: Modelagem em Machine Learning para forecasting.",
                                "Negócios: Otimização de estoque e planejamento sazonal."
                              ],
                              "realWorldApplication": "Em indústrias como varejo ou turismo, identificar sazonalidade permite previsões precisas de demanda, ajustando estoques para picos (ex: Black Friday) e reduzindo desperdícios em baixas, economizando milhões em operações."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.1.2",
                            "name": "Aplicar decomposição aditiva e multiplicativa",
                            "description": "Implementar funções como decompose() no R para dividir a série em tendência, sazonal e irregular, interpretando os resultados para previsão simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a Série Temporal para Decomposição",
                                  "subSteps": [
                                    "Carregue o pacote necessário: library(forecast) ou base R.",
                                    "Importe ou crie uma série temporal com frequência sazonal (ex: monthly = 12).",
                                    "Visualize a série com plot() para confirmar tendência e sazonalidade.",
                                    "Verifique estacionariedade com testes como adf.test() se necessário.",
                                    "Trate valores ausentes com na.approx() ou imputação simples."
                                  ],
                                  "verification": "Série temporal plotada corretamente mostrando tendência e padrão sazonal; sem NAs restantes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "R e RStudio instalados",
                                    "Dataset exemplo como AirPassengers ou dados de vendas mensais (CSV)"
                                  ],
                                  "tips": "Sempre defina frequency corretamente (ex: 12 para mensal) para decomposição funcionar.",
                                  "learningObjective": "Preparar dados de série temporal adequadamente para análise de decomposição.",
                                  "commonMistakes": [
                                    "Esquecer de converter para ts()",
                                    "Ignorar frequência sazonal",
                                    "Não plotar inicialmente para inspeção visual"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar Decomposição Aditiva",
                                  "subSteps": [
                                    "Use decompose(ts_data, type='additive') e armazene em um objeto.",
                                    "Extraia componentes: trend, seasonal, random.",
                                    "Plote os componentes com plot(decomp_obj).",
                                    "Some os componentes para verificar: trend + seasonal + random ≈ original.",
                                    "Salve plots em PDF para documentação."
                                  ],
                                  "verification": "Plot mostra tendência suave, sazonalidade aditiva e resíduo irregular; soma reconstrói a série original.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Série temporal preparada do Step 1",
                                    "Funções: decompose(), plot()"
                                  ],
                                  "tips": "Use type='additive' explicitamente; funciona bem para séries sem variância crescente.",
                                  "learningObjective": "Implementar e visualizar decomposição aditiva em R.",
                                  "commonMistakes": [
                                    "Usar type='multiplicative' por engano",
                                    "Não verificar soma dos componentes",
                                    "Ignorar mensagens de aviso sobre NAs"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar Componentes da Decomposição Aditiva",
                                  "subSteps": [
                                    "Analise tendência: descreva direção e magnitude com summary() ou médias.",
                                    "Examine sazonalidade: identifique picos/vales e amplitude média.",
                                    "Avalie irregular: verifique autocorrelação com acf(residuals).",
                                    "Compare sazonalidade com múltiplos anos para consistência.",
                                    "Documente insights em um relatório Markdown."
                                  ],
                                  "verification": "Relatório escrito com descrições qualitativas e quantitativas de cada componente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Objeto de decomposição do Step 2",
                                    "Funções: summary(), acf()"
                                  ],
                                  "tips": "Sazonalidade deve somar zero em aditiva; foque em padrões repetitivos.",
                                  "learningObjective": "Interpretar componentes para insights sobre a série.",
                                  "commonMistakes": [
                                    "Confundir tendência com sazonalidade",
                                    "Não checar resíduo por padrões restantes",
                                    "Descrições vagas sem números"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Interpretar Decomposição Multiplicativa",
                                  "subSteps": [
                                    "Aplique decompose(ts_data, type='multiplicative').",
                                    "Plote e extraia componentes como no aditivo.",
                                    "Verifique multiplicação: trend * seasonal * random ≈ original.",
                                    "Compare plots aditivo vs. multiplicativo, notando diferenças em variância.",
                                    "Use para previsão simples: forecast trend + ajuste sazonal."
                                  ],
                                  "verification": "Plots mostram sazonalidade proporcional; produto reconstrói série; previsão básica gerada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Mesma série do Step 1",
                                    "Funções: decompose(type='multiplicative'), forecast()"
                                  ],
                                  "tips": "Ideal para séries com variância crescente; log-transforme se necessário.",
                                  "learningObjective": "Diferenciar e aplicar decomposição multiplicativa para séries não estacionárias.",
                                  "commonMistakes": [
                                    "Aplicar multiplicativa em séries com zeros/negativos",
                                    "Não logar dados antes",
                                    "Ignorar avisos de decomposição"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Comparar Decomposições e Realizar Previsão Simples",
                                  "subSteps": [
                                    "Compare tendências e sazonalidades lado a lado com par(mfrow=c(2,1)).",
                                    "Escolha modelo baseado em resíduo (AIC ou visual).",
                                    "Gere previsão: use stl() ou média sazonal + trend.",
                                    "Avalie com plot(forecast_obj) e MAE em holdout.",
                                    "Salve código e resultados em script R."
                                  ],
                                  "verification": "Previsão plotada com intervalos; escolha justificada; erro calculado.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Ambos objetos de decomposição",
                                    "Pacote forecast para previsão avançada"
                                  ],
                                  "tips": "Prefira multiplicativa se variância aumenta; valide com dados out-of-sample.",
                                  "learningObjective": "Selecionar decomposição apropriada e prever valores futuros.",
                                  "commonMistakes": [
                                    "Não comparar modelos",
                                    "Previsão sem validação",
                                    "Overfitting em tendência"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando o dataset AirPassengers (passageiros aéreos mensais 1949-1960): aplique decompose() aditiva/multiplicativa, interprete o pico sazonal de verão (julho) e preveja 12 meses à frente, comparando com dados reais.",
                              "finalVerifications": [
                                "Código roda sem erros e reconstrói série original.",
                                "Plots de ambos tipos mostram componentes claros e coerentes.",
                                "Interpretação escrita identifica padrões chave (ex: sazonalidade positiva).",
                                "Previsão simples gerada com plot e métrica de erro (MAE < 10%).",
                                "Relatório resume quando usar aditiva vs. multiplicativa.",
                                "Resíduos sem autocorrelação significativa (ACF próximo de zero)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na preparação e aplicação de decompose() (código correto).",
                                "Qualidade da interpretação: descrições quantitativas e qualitativas.",
                                "Correta verificação de soma/produto dos componentes.",
                                "Escolha justificada entre aditiva/multiplicativa baseada em características da série.",
                                "Previsão acionável com visualização e avaliação de erro.",
                                "Documentação completa com plots e insights.",
                                "Eficiência: tempo dentro do estimado, sem erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelos lineares e funções trigonométricas para sazonalidade.",
                                "Programação: Manipulação de dados em R (ts, forecast).",
                                "Economia/Negócios: Previsão de vendas ou demanda sazonal.",
                                "Ciência de Dados: Validação de modelos e resíduos.",
                                "Estatística: Testes de estacionariedade e autocorrelação."
                              ],
                              "realWorldApplication": "Em empresas de varejo, decompor vendas mensais para prever estoque sazonal (ex: Natal), ajustando por tendência de crescimento e picos promocionais, otimizando logística e reduzindo desperdícios."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.1.3",
                            "name": "Prever usando componentes decompostos",
                            "description": "Extrair previsões da tendência e sazonalidade combinadas, ajustando resíduos e validando com métricas como MAE ou RMSE.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Prever a componente de tendência",
                                  "subSteps": [
                                    "Identifique o modelo adequado para a tendência (ex: linear, polinomial ou exponencial).",
                                    "Ajuste o modelo aos dados históricos da tendência extraídos da decomposição.",
                                    "Gere previsões para o horizonte desejado (ex: próximos 12 meses).",
                                    "Visualize a tendência prevista sobreposta aos dados históricos.",
                                    "Salve as previsões em um array ou DataFrame separado."
                                  ],
                                  "verification": "Verifique se a previsão de tendência segue logicamente a tendência histórica sem saltos abruptos e plote o gráfico para inspeção visual.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python (pandas, statsmodels ou scikit-learn), Jupyter Notebook, dados de série temporal decomposta.",
                                  "tips": "Use modelos simples inicialmente; teste com validação cruzada temporal para evitar overfitting.",
                                  "learningObjective": "Dominar a modelagem e previsão isolada da componente de tendência em séries temporais.",
                                  "commonMistakes": "Ignorar a estacionariedade da tendência ou usar janelas de treino muito pequenas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Prever a componente sazonal",
                                  "subSteps": [
                                    "Analise o padrão sazonal dos dados históricos (ex: ciclo anual com 12 períodos).",
                                    "Estenda o padrão sazonal para o horizonte de previsão replicando os ciclos conhecidos.",
                                    "Ajuste se houver mudanças graduais no padrão sazonal (ex: média móvel suave).",
                                    "Gere as previsões sazonais alinhadas temporalmente com a tendência.",
                                    "Plote a sazonalidade prevista para confirmar repetição cíclica."
                                  ],
                                  "verification": "Confirme que os valores sazonais oscilam no mesmo intervalo e frequência dos históricos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python (pandas para indexação sazonal), gráficos com matplotlib ou seaborn.",
                                  "tips": "Para sazonalidade forte, use médias sazonais; evite modelagem complexa desnecessária.",
                                  "learningObjective": "Aprender a estender padrões sazonais de forma cíclica e precisa para previsões futuras.",
                                  "commonMistakes": "Desalinhar fases sazonais ou assumir sazonalidade onde não existe."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Combinar tendência e sazonalidade",
                                  "subSteps": [
                                    "Some as previsões de tendência e sazonalidade elemento a elemento para obter a previsão base.",
                                    "Alinhe os índices temporais das duas componentes corretamente.",
                                    "Plote a soma sobre os dados originais para inspeção inicial.",
                                    "Calcule resíduos preliminares subtraindo a previsão base dos dados reais.",
                                    "Registre a previsão combinada em uma série temporal unificada."
                                  ],
                                  "verification": "Verifique se a soma reproduz razoavelmente os picos e vales sazonais dos dados históricos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python (pandas Series.add()), ferramentas de plotagem.",
                                  "tips": "Use operações vetorizadas no pandas para eficiência; normalize escalas se necessário.",
                                  "learningObjective": "Entender a combinação aditiva clássica de componentes em decomposição STL ou similar.",
                                  "commonMistakes": "Erro de alinhamento temporal ou multiplicar em vez de somar componentes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ajustar resíduos e validar previsão",
                                  "subSteps": [
                                    "Analise os resíduos da previsão base (tendência + sazonal) para padrões restantes.",
                                    "Modele resíduos com ARIMA ou média se autocorrelação persistir; senão, use ruído branco.",
                                    "Adicione os resíduos ajustados à previsão base.",
                                    "Calcule métricas de validação: MAE, RMSE em conjunto de teste hold-out.",
                                    "Compare com baseline (ex: média sazonal) e ajuste hiperparâmetros se preciso."
                                  ],
                                  "verification": "Resíduos ajustados devem ser aproximadamente estacionários (teste Ljung-Box p-value > 0.05); métricas abaixo de thresholds definidos.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Python (statsmodels.tsa para ARIMA, sklearn.metrics para MAE/RMSE), conjunto de validação.",
                                  "tips": "Reserve 20% dos dados recentes para teste; foque em RMSE para erros quadráticos.",
                                  "learningObjective": "Aplicar modelagem de resíduos e validação rigorosa para refinar previsões de séries temporais.",
                                  "commonMistakes": "Não reservar dados de teste ou ignorar heterocedasticidade nos resíduos."
                                }
                              ],
                              "practicalExample": "Usando dados mensais de vendas de sorvete (trend crescente devido a expansão de lojas, sazonalidade pico no verão), decomponha com STL, preveja tendência linear, replique sazonalidade de julho alto, combine, ajuste resíduos AR(1), valide com RMSE < 500 unidades em hold-out de 6 meses.",
                              "finalVerifications": [
                                "Previsão combinada gerada para todo o horizonte sem erros de indexação.",
                                "Gráficos mostram alinhamento visual com dados históricos.",
                                "Resíduos finais são ruído branco (ACF próximo de zero).",
                                "Métricas MAE e RMSE calculadas e inferiores a baselines.",
                                "Código reproduzível gera os mesmos resultados.",
                                "Horizonte de previsão cobre pelo menos 12 períodos futuros."
                              ],
                              "assessmentCriteria": [
                                "Precisão: RMSE < 10% do desvio padrão dos dados históricos.",
                                "Cobertura completa: Todas componentes (tendência, sazonal, resíduos) integradas.",
                                "Validação robusta: Uso de hold-out e múltiplas métricas (MAE, RMSE, MAPE).",
                                "Eficiência: Tempo de computação < 5 minutos para 1000 observações.",
                                "Interpretação: Explicação clara de contribuições de cada componente.",
                                "Robustez: Previsão estável a pequenas perturbações nos dados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Regressão linear/polimonial e análise de resíduos.",
                                "Programação: Manipulação de séries temporais em Python/R.",
                                "Negócios: Previsão de demanda para planejamento de estoque.",
                                "Economia: Modelagem de ciclos econômicos sazonais."
                              ],
                              "realWorldApplication": "Empresas de varejo usam isso para prever vendas sazonais de produtos como roupas de inverno, otimizando estoque e logística; bancos preveem depósitos sazonais para gerenciar liquidez."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.5.2",
                        "name": "Método Holt-Winters",
                        "description": "Algoritmo de suavização exponencial que modela tendência e sazonalidade simultaneamente para previsões de curto e médio prazo.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.2.1",
                            "name": "Configurar parâmetros alfa, beta e gamma",
                            "description": "Ajustar os coeficientes de suavização para nível, tendência e sazonalidade usando otimização ou critérios como AIC.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Papel dos Parâmetros Alfa, Beta e Gamma no Holt-Winters",
                                  "subSteps": [
                                    "Revisar as fórmulas do método Holt-Winters (aditivo ou multiplicativo) para nível (L_t), tendência (B_t) e sazonalidade (S_t).",
                                    "Explicar que alfa (α) controla o peso dado aos dados observados vs. previsão anterior para o nível.",
                                    "Descrever beta (β) como o coeficiente de suavização para a tendência.",
                                    "Identificar gamma (γ) como o coeficiente para componentes sazonais.",
                                    "Analisar o impacto de valores de α, β, γ próximos de 0 (suavização forte) vs. 1 (alta responsividade)."
                                  ],
                                  "verification": "Resumir em um diagrama ou parágrafo o papel de cada parâmetro e fornecer exemplos de como variações afetam as previsões.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação oficial do Holt-Winters (ex: statsmodels ou forecast package)",
                                    "Gráficos de séries temporais de exemplo",
                                    "Notebook Jupyter ou R script"
                                  ],
                                  "tips": "Use animações ou plots interativos (ex: em Python com matplotlib) para visualizar o efeito de mudar α, β, γ em uma série simples.",
                                  "learningObjective": "Dominar intuitivamente como α, β e γ influenciam a suavização de componentes da série temporal.",
                                  "commonMistakes": [
                                    "Confundir α com β ou γ",
                                    "Assumir que valores >1 são válidos (devem estar em [0,1])",
                                    "Ignorar diferenças entre modelos aditivo e multiplicativo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar Valores Iniciais para os Parâmetros",
                                  "subSteps": [
                                    "Estimar valores iniciais para nível (L_0), tendência (B_0) e fatores sazonais (S_0) usando médias dos primeiros períodos.",
                                    "Definir α inicial como 0.3, β como 0.1 e γ como 0.3 (valores conservadores comuns).",
                                    "Implementar a função Holt-Winters em código com parâmetros iniciais.",
                                    "Gerar previsões iniciais e plotar contra dados observados.",
                                    "Calcular erro inicial (ex: MSE) para baseline."
                                  ],
                                  "verification": "Executar o modelo inicial e confirmar que as previsões são geradas sem erros e plotadas corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Biblioteca statsmodels (Python) ou forecast (R)",
                                    "Dataset de série sazonal (ex: AirPassengers)",
                                    "Ambiente de programação configurado"
                                  ],
                                  "tips": "Comece com decomposição clássica para estimativas iniciais de L_0, B_0, S_0 para maior precisão.",
                                  "learningObjective": "Configurar um modelo Holt-Winters funcional com parâmetros iniciais razoáveis.",
                                  "commonMistakes": [
                                    "Usar dados insuficientes para inicialização sazonal",
                                    "Não padronizar a série se necessário",
                                    "Ignorar período sazonal (ex: 12 para mensal)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Otimização dos Parâmetros",
                                  "subSteps": [
                                    "Definir função de perda (ex: soma de quadrados de erros - SSE).",
                                    "Usar grid search para testar combinações de α, β, γ em [0.001, 0.999] com passos de 0.05.",
                                    "Alternativamente, aplicar otimização numérica (ex: minimize() no scipy ou optim() no R).",
                                    "Executar a otimização e registrar os melhores parâmetros.",
                                    "Plotar superfície de erro para visualizar o espaço de parâmetros."
                                  ],
                                  "verification": "Identificar os parâmetros otimizados que minimizam SSE e confirmar convergência da otimização.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Funções de otimização: scipy.optimize ou nlminb",
                                    "Código template para Holt-Winters",
                                    "Hardware com capacidade para grid search (evite grids muito finos inicialmente)"
                                  ],
                                  "tips": "Limite o grid para evitar sobrecarga computacional; priorize α próximo de 1 se a série for ruidosa.",
                                  "learningObjective": "Aplicar técnicas de otimização para ajustar α, β, γ automaticamente.",
                                  "commonMistakes": [
                                    "Grid search muito amplo levando a lentidão",
                                    "Não restringir parâmetros a [0,1]",
                                    "Otimizar sem fixar período sazonal corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar e Selecionar Parâmetros Usando Critérios como AIC",
                                  "subSteps": [
                                    "Calcular AIC para o modelo otimizado: AIC = 2k - 2ln(L), onde k inclui α, β, γ.",
                                    "Comparar AIC de múltiplos modelos (diferentes grids ou seeds iniciais).",
                                    "Validar com hold-out set: calcular MAE/RMSE em dados de teste.",
                                    "Analisar resíduos para autocorrelação (ex: Ljung-Box test).",
                                    "Ajustar final se necessário e documentar escolhas."
                                  ],
                                  "verification": "Selecionar o conjunto de parâmetros com menor AIC e RMSE < threshold definido (ex: 10% do mean da série).",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Funções AIC em statsmodels ou manual",
                                    "Testes de resíduos (statsmodels.tsa.stattools)",
                                    "Dados de validação temporal"
                                  ],
                                  "tips": "Prefira AIC sobre SSE puro para penalizar overfitting; compare com modelo simples (média).",
                                  "learningObjective": "Usar métricas estatísticas para validar e escolher os melhores parâmetros.",
                                  "commonMistakes": [
                                    "Calcular AIC incorretamente (esquecer log-likelihood)",
                                    "Treinar/testar no mesmo set",
                                    "Ignorar resíduos não-brancos"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Aplicar o Modelo Configurado",
                                  "subSteps": [
                                    "Gerar previsões de h passos à frente com parâmetros finais.",
                                    "Plotar fit histórico, previsões e intervalos de confiança.",
                                    "Testar sensibilidade: variar ±10% nos parâmetros e observar impacto.",
                                    "Documentar processo em relatório com valores exatos de α, β, γ.",
                                    "Preparar para cenários reais exportando modelo."
                                  ],
                                  "verification": "Previsões plausíveis, resíduos estacionários e documentação completa.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramentas de plotagem avançada (plotly para interatividade)",
                                    "Template de relatório"
                                  ],
                                  "tips": "Use bootstrap para intervalos de confiança se possível.",
                                  "learningObjective": "Garantir que os parâmetros configurados produzem um modelo robusto e interpretável.",
                                  "commonMistakes": [
                                    "Sobreajuste a ruído (alta α)",
                                    "Não testar em out-of-sample",
                                    "Esquecer de escalar série se multiplicativa"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando o dataset AirPassengers (passageiros aéreos mensais de 1949-1960, sazonalidade 12): Inicialize α=0.3, β=0.1, γ=0.3; otimize via grid search no período 1949-1959; selecione parâmetros que minimizam AIC (ex: α≈0.45, β≈0.02, γ≈0.7); valide RMSE em 1960 < 25.",
                              "finalVerifications": [
                                "Parâmetros α, β, γ estão no intervalo [0,1].",
                                "AIC do modelo otimizado é menor que baselines (ex: Holt simples).",
                                "Resíduos passam no teste Ljung-Box (p-value >0.05).",
                                "RMSE em conjunto de teste < 15% da média da série.",
                                "Previsões capturam sazonalidade e tendência visivelmente.",
                                "Código reproduzível gera os mesmos parâmetros."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: explicação correta de α, β, γ (90%+).",
                                "Implementação: código executa sem erros e otimiza corretamente.",
                                "Otimização: usa método apropriado com convergência comprovada.",
                                "Avaliação: AIC e métricas calculadas e interpretadas adequadamente.",
                                "Validação: análise de resíduos e sensibilidade incluída.",
                                "Documentação: processo claro com plots e valores finais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização não-linear e funções de perda.",
                                "Programação: Implementação numérica em Python/R (scipy, statsmodels).",
                                "Economia/Negócios: Previsão de demanda sazonal em varejo ou finanças.",
                                "Machine Learning: Hiperparâmetro tuning similar a grid search em redes neurais.",
                                "Estatística: Modelos de séries temporais e seleção de modelos via AIC/BIC."
                              ],
                              "realWorldApplication": "Em varejo, configurar α, β, γ no Holt-Winters para prever vendas sazonais de produtos como roupas de inverno, otimizando estoque e reduzindo perdas por excesso/escassez em até 20%."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.2.2",
                            "name": "Implementar Holt-Winters aditivo e multiplicativo",
                            "description": "Usar a função HoltWinters() no R para séries com sazonalidade aditiva ou multiplicativa, gerando previsões e intervalos de confiança.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente R e carregar dados de série temporal sazonal",
                                  "subSteps": [
                                    "Instalar e carregar os pacotes necessários: install.packages('forecast'); library(forecast); library(datasets)",
                                    "Carregar um dataset exemplo com sazonalidade, como data(AirPassengers)",
                                    "Converter os dados para objeto ts com frequência sazonal: ts_data <- ts(AirPassengers, frequency=12)",
                                    "Visualizar os dados com plot(ts_data) para confirmar sazonalidade",
                                    "Verificar estrutura com summary(ts_data) e start/end"
                                  ],
                                  "verification": "O plot mostra padrão sazonal claro (picos anuais) e summary confirma frequency=12.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "RStudio ou R console",
                                    "Pacotes: forecast, datasets"
                                  ],
                                  "tips": [
                                    "Sempre especifique frequency corretamente (12 para mensal, 4 para trimestral).",
                                    "Use window() para subsetar dados se necessário."
                                  ],
                                  "learningObjective": "Configurar corretamente uma série temporal sazonal no R para análise Holt-Winters.",
                                  "commonMistakes": [
                                    "Esquecer de carregar pacotes",
                                    "Usar frequency incorreta levando a erro de sazonalidade",
                                    "Não converter para ts object"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar e analisar o modelo Holt-Winters Aditivo",
                                  "subSteps": [
                                    "Ajustar o modelo: fit_add <- HoltWinters(ts_data, seasonal='additive')",
                                    "Visualizar o ajuste: plot(fit_add)",
                                    "Extrair valores ajustados: fitted_add <- fitted(fit_add)",
                                    "Calcular resíduos: residuals_add <- ts_data - fitted_add",
                                    "Verificar adequação com plot(residuals_add) e acf(residuals_add)"
                                  ],
                                  "verification": "O plot do modelo mostra suavização de tendência, sazonalidade aditiva e resíduos aleatórios sem padrão.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "R script aberto",
                                    "Dataset ts_data do Step 1"
                                  ],
                                  "tips": [
                                    "Use seasonal='additive' apenas para sazonalidade constante (não crescente).",
                                    "Ajuste alpha, beta, gamma manualmente se necessário para otimização."
                                  ],
                                  "learningObjective": "Aplicar Holt-Winters aditivo e interpretar componentes (nível, tendência, sazonal).",
                                  "commonMistakes": [
                                    "Confundir com multiplicativo",
                                    "Ignorar resíduos correlacionados indicando mau ajuste",
                                    "Não plotar o modelo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e analisar o modelo Holt-Winters Multiplicativo",
                                  "subSteps": [
                                    "Ajustar o modelo: fit_mult <- HoltWinters(ts_data, seasonal='multiplicative')",
                                    "Visualizar o ajuste: plot(fit_mult)",
                                    "Extrair valores ajustados: fitted_mult <- fitted(fit_mult)",
                                    "Calcular resíduos: residuals_mult <- ts_data / fitted_mult - 1",
                                    "Verificar adequação com plot(residuals_mult) e acf(residuals_mult)"
                                  ],
                                  "verification": "O plot mostra suavização com sazonalidade proporcional à tendência e resíduos próximos de zero.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "R script",
                                    "Dataset ts_data"
                                  ],
                                  "tips": [
                                    "Use seasonal='multiplicative' para sazonalidade crescente com a tendência.",
                                    "Compare AIC(fit_add) e AIC(fit_mult) para melhor modelo."
                                  ],
                                  "learningObjective": "Aplicar Holt-Winters multiplicativo e diferenciar de aditivo baseado na natureza da sazonalidade.",
                                  "commonMistakes": [
                                    "Aplicar multiplicativo em dados com zeros ou negativos",
                                    "Não transformar resíduos corretamente para multiplicativo",
                                    "Esquecer de plotar"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Gerar previsões, intervalos de confiança e comparar modelos",
                                  "subSteps": [
                                    "Gerar previsões aditivas: forecast_add <- forecast(fit_add, h=12, level=95)",
                                    "Gerar previsões multiplicativas: forecast_mult <- forecast(fit_mult, h=12, level=95)",
                                    "Visualizar previsões: plot(forecast_add); plot(forecast_mult)",
                                    "Comparar precisão: accuracy(fit_add); accuracy(fit_mult)",
                                    "Selecionar melhor modelo baseado em MAE ou RMSE e documentar razões"
                                  ],
                                  "verification": "Previsões incluem intervalos de 95% CI sem erros e comparação mostra modelo ótimo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Modelos fit_add e fit_mult",
                                    "Função forecast()"
                                  ],
                                  "tips": [
                                    "Aumente h para horizontes longos, mas monitore widening de CI.",
                                    "Use autoplot() do ggplot2 para visualizações avançadas."
                                  ],
                                  "learningObjective": "Produzir previsões confiáveis com Holt-Winters e avaliar modelos comparativamente.",
                                  "commonMistakes": [
                                    "Esquecer level no forecast()",
                                    "Comparar incorretamente accuracy em dados brutos vs ajustados",
                                    "Ignorar widening dos intervalos em horizontes longos"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando o dataset AirPassengers (passageiros aéreos mensais 1949-1960), aplique Holt-Winters aditivo/multiplicativo para prever os próximos 12 meses. Compare RMSE: aditivo ~15.5, multiplicativo ~13.2 (melhor para sazonalidade crescente). Visualize previsões com CI mostrando faixa de 400-700 passageiros.",
                              "finalVerifications": [
                                "Código roda sem erros e produz plots de ajustes/previsões corretos",
                                "Modelos distinguem aditivo (sazonal constante) vs multiplicativo (proporcional)",
                                "Previsões h=12 incluem intervalos 95% CI plotados",
                                "Resíduos são aleatórios (ACF sem lags significativos)",
                                "Comparação de accuracy seleciona modelo ótimo com justificativa",
                                "Componentes (nível, tendência, sazonal) extraídos e interpretados"
                              ],
                              "assessmentCriteria": [
                                "Precisão do código: uso correto de HoltWinters() e forecast() (40%)",
                                "Interpretação: distinção aditivo/multiplicativo e análise resíduos (25%)",
                                "Visualizações: plots claros de ajuste, previsões e CI (20%)",
                                "Comparação: métricas accuracy e seleção de modelo (10%)",
                                "Documentação: comentários no código e conclusões (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Suavização exponencial e decomposição de séries",
                                "Programação: Scripting em R, manipulação de objetos ts",
                                "Estatística: Validação de modelos via resíduos e AIC",
                                "Negócios: Aplicações em forecasting de demanda",
                                "Visualização de Dados: Plots com forecast e ggplot2"
                              ],
                              "realWorldApplication": "Em varejo, prever vendas mensais sazonais de produtos (ex: sorvetes no verão) para otimizar estoque e logística, reduzindo custos em 20% via modelos Holt-Winters adaptados à sazonalidade multiplicativa crescente."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.2.3",
                            "name": "Avaliar precisão do modelo Holt-Winters",
                            "description": "Calcular erros de previsão em amostra de teste e comparar com benchmarks, ajustando hiperparâmetros para melhoria.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar Dados de Teste e Gerar Previsões do Modelo Holt-Winters",
                                  "subSteps": [
                                    "Carregue o conjunto de dados de série temporal sazonal.",
                                    "Divida os dados em conjunto de treinamento (80%) e teste (20%).",
                                    "Ajuste o modelo Holt-Winters treinado nos dados de treinamento.",
                                    "Gere previsões para o período de teste usando o modelo ajustado.",
                                    "Alinhe as previsões com os valores reais do conjunto de teste."
                                  ],
                                  "verification": "Verifique se as previsões têm o mesmo comprimento e índice temporal que os dados de teste reais.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python com bibliotecas pandas, statsmodels",
                                    "Dataset de série temporal sazonal (ex: vendas mensais)"
                                  ],
                                  "tips": "Garanta que a sazonalidade esteja corretamente especificada (alpha, beta, gamma) no modelo.",
                                  "learningObjective": "Preparar corretamente dados de teste e previsões para avaliação precisa.",
                                  "commonMistakes": [
                                    "Usar dados de treinamento como teste",
                                    "Ignorar desalinhamento temporal entre previsões e reais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Métricas de Erro de Previsão",
                                  "subSteps": [
                                    "Calcule o Erro Absoluto Médio (MAE) entre previsões e reais.",
                                    "Calcule o Erro Quadrático Médio (MSE) e a Raiz do Erro Quadrático Médio (RMSE).",
                                    "Calcule o Erro Percentual Absoluto Médio (MAPE) para interpretação relativa.",
                                    "Implemente ou use funções prontas das bibliotecas para automação.",
                                    "Registre todas as métricas em uma tabela comparativa."
                                  ],
                                  "verification": "Compare cálculos manuais com funções de biblioteca para validar resultados numéricos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python com numpy, sklearn.metrics",
                                    "Previsões e dados reais alinhados"
                                  ],
                                  "tips": "Normalize dados se houver escalas muito diferentes para evitar viés em métricas absolutas.",
                                  "learningObjective": "Dominar o cálculo e interpretação de métricas padrão de precisão em forecasting.",
                                  "commonMistakes": [
                                    "Esquecer de tratar valores zero ou negativos no MAPE",
                                    "Confundir RMSE com MAE"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Métricas com Benchmarks e Analisar Desempenho",
                                  "subSteps": [
                                    "Defina benchmarks relevantes (ex: RMSE de modelo naive ou média móvel).",
                                    "Compare numericamente as métricas do Holt-Winters com os benchmarks.",
                                    "Crie gráficos de resíduos (previsão - real) e previsão vs. real para visualização.",
                                    "Interprete resultados: identifique se o modelo supera benchmarks e por quê.",
                                    "Documente insights sobre viés, variância ou padrões sazonais residuais."
                                  ],
                                  "verification": "O modelo Holt-Winters deve mostrar RMSE menor que benchmark naive em pelo menos 80% dos casos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python com matplotlib, seaborn",
                                    "Tabela de métricas calculadas"
                                  ],
                                  "tips": "Use benchmarks contextuais, como erro de 10-20% para séries sazonais reais.",
                                  "learningObjective": "Avaliar criticamente o desempenho do modelo contra padrões de referência.",
                                  "commonMistakes": [
                                    "Escolher benchmarks irrelevantes",
                                    "Ignorar análise visual de resíduos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ajustar Hiperparâmetros e Reavaliar o Modelo",
                                  "subSteps": [
                                    "Identifique hiperparâmetros sensíveis (alpha, beta, gamma, período sazonal).",
                                    "Use grid search ou otimização para testar combinações.",
                                    "Re-treine o modelo com novos hiperparâmetros nos dados de treinamento.",
                                    "Re-calcule métricas no conjunto de teste e compare com iteração anterior.",
                                    "Selecione e salve a melhor configuração baseada na menor RMSE/MAPE."
                                  ],
                                  "verification": "A nova configuração deve melhorar pelo menos uma métrica principal em 5-10%.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com statsmodels, scipy.optimize",
                                    "Funções de otimização"
                                  ],
                                  "tips": "Limite o grid search a 20-50 combinações para eficiência computacional.",
                                  "learningObjective": "Otimizar modelos de forecasting iterativamente para máxima precisão.",
                                  "commonMistakes": [
                                    "Overfitting ao testar múltiplas vezes no mesmo conjunto de teste",
                                    "Não fixar seed para reprodutibilidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dados mensais de vendas de sorvete (com sazonalidade anual), treine Holt-Winters nos primeiros 36 meses, preveja os próximos 12, calcule RMSE=150 unidades (benchmark naive=250), ajuste gamma para capturar melhor sazonalidade, reduzindo RMSE para 120.",
                              "finalVerifications": [
                                "Todas métricas (MAE, RMSE, MAPE) calculadas corretamente e documentadas.",
                                "Comparação com benchmarks mostra superioridade do Holt-Winters otimizado.",
                                "Gráficos de previsão vs. real e resíduos sem padrões sistemáticos.",
                                "Hiperparâmetros ajustados levam a melhoria mensurável (ex: RMSE reduzido >5%).",
                                "Relatório final resume insights e recomendações.",
                                "Código é reprodutível com seeds fixas."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica das métricas (erro <1%).",
                                "Correta implementação e uso de bibliotecas especializadas.",
                                "Análise qualitativa e quantitativa integrada (gráficos + números).",
                                "Eficiência na otimização de hiperparâmetros.",
                                "Interpretação contextual dos resultados.",
                                "Documentação clara de passos e decisões."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Métricas de erro e análise de resíduos.",
                                "Programação: Manipulação de dados e otimização em Python.",
                                "Matemática: Modelos exponenciais suavizados.",
                                "Negócios: Aplicação em forecasting de demanda."
                              ],
                              "realWorldApplication": "Em varejo para prever vendas sazonais e otimizar estoque, reduzindo custos em 15-20%; em finanças para forecasting de ações com padrões sazonais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.5.3",
                        "name": "Modelos SARIMA",
                        "description": "Extensão do modelo ARIMA que incorpora termos sazonais para capturar periodicidades em séries não estacionárias.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.3.1",
                            "name": "Determinar ordens sazonais (P, D, Q, s)",
                            "description": "Usar gráficos ACF/PACF sazonais e testes de estacionariedade diferencial sazonal para identificar parâmetros sazonais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar o período sazonal (s)",
                                  "subSteps": [
                                    "Examinar os dados da série temporal para padrões repetitivos anuais, mensais ou trimestrais.",
                                    "Calcular o período sazonal usando análise de período (ex: FFT ou inspeção visual do gráfico da série).",
                                    "Confirmar s com o comprimento do ciclo sazonal (ex: s=12 para dados mensais, s=4 para trimestrais).",
                                    "Documentar o valor de s e plotar a série com marcações sazonais.",
                                    "Verificar consistência com conhecimento de domínio (ex: varejo tem s=12)."
                                  ],
                                  "verification": "Gráfico da série mostra ciclos claros de comprimento s e FFT confirma pico dominante em frequência 1/s.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Série temporal de dados (CSV ou Pandas DataFrame)",
                                    "Python com pandas, matplotlib e scipy",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": [
                                    "Comece com plot da série bruta em escala longa para visualizar ciclos.",
                                    "Use seasonal_decompose do statsmodels para decomposição inicial.",
                                    "Anote múltiplos candidatos para s se houver dúvida."
                                  ],
                                  "learningObjective": "Compreender e quantificar o período de repetição sazonal nos dados.",
                                  "commonMistakes": [
                                    "Confundir sazonalidade com tendência.",
                                    "Escolher s muito pequeno ignorando ciclos múltiplos.",
                                    "Não validar visualmente antes de prosseguir."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Testar estacionariedade sazonal e determinar D",
                                  "subSteps": [
                                    "Aplicar teste KPSS sazonal ou Augmented Dickey-Fuller sazonal na série original.",
                                    "Se não estacionária, plotar ACF sazonal para ver persistência em lags múltiplos de s.",
                                    "Aplicar diferenciação sazonal Δ_s = (1 - B^s) e repetir testes.",
                                    "Incrementar D até que o teste indique estacionariedade (geralmente D=0 ou 1).",
                                    "Registrar valor de D e plotar série diferenciada."
                                  ],
                                  "verification": "Teste KPSS sazonal p-value > 0.05 ou gráfico ACF sazonal decai rapidamente após lag s.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": [
                                    "Biblioteca statsmodels ou pmdarima em Python",
                                    "Funções de teste sazonal (nsdiff para D automático)"
                                  ],
                                  "tips": [
                                    "Use nsdiffs() do pmdarima para sugestão automática de D.",
                                    "Sempre plote antes e depois da diferenciação.",
                                    "D>1 é raro; pare em D=1 se possível."
                                  ],
                                  "learningObjective": "Avaliar e corrigir não-estacionariedade sazonal via diferenciação.",
                                  "commonMistakes": [
                                    "Sobre-diferenciar levando a sobrestacionariedade.",
                                    "Ignorar testes formais e confiar só em gráficos.",
                                    "Confundir D sazonal com d não-sazonal."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar e plotar gráficos ACF e PACF sazonais",
                                  "subSteps": [
                                    "Ajustar a série para diferenciação sazonal (D, s) e plotar ACF/PACF focando em lags múltiplos de s.",
                                    "Usar statsmodels.tsa.stattools.acf/pacf com nlags=2*s ou mais.",
                                    "Destacar barras sazonais (lags s, 2s, etc.) com cores ou anotações.",
                                    "Identificar número de picos significativos nas barras sazonais.",
                                    "Salvar plots com legendas claras para lags sazonais."
                                  ],
                                  "verification": "Gráficos ACF/PACF gerados mostram barras em lags múltiplos de s acima da linha de significância.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "statsmodels.tsa.stattools",
                                    "matplotlib para customização de plots"
                                  ],
                                  "tips": [
                                    "Zoom nos lags sazonais iniciais (s,2s,3s).",
                                    "Use plot_acf/pacf do statsmodels com alpha=0.05.",
                                    "Compare com não-sazonal para distinção."
                                  ],
                                  "learningObjective": "Visualizar correlações sazonais para informar P e Q.",
                                  "commonMistakes": [
                                    "Plotar ACF/PACF padrão sem filtro sazonal.",
                                    "Ignorar intervalos de confiança.",
                                    "Confundir ruído com picos sazonais fracos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar gráficos para determinar P e Q sazonais",
                                  "subSteps": [
                                    "Para PACF sazonal: Conte picos significativos em lags s, 2s,... para P (corta após P*s).",
                                    "Para ACF sazonal: Conte picos significativos em lags s, 2s,... para Q (corta após Q*s).",
                                    "Teste combinações iniciais (P=0-2, Q=0-2) ajustando SARIMA temporariamente.",
                                    "Escolha a menor ordem parsimoniosa com bom ajuste (AIC baixo).",
                                    "Documente justificativa baseada em padrões de corte."
                                  ],
                                  "verification": "P e Q selecionados correspondem a número de picos significativos nos gráficos sazonais.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": [
                                    "statsmodels.tsa.statespace.sarimax para ajuste rápido",
                                    "Tabela de AIC para comparação"
                                  ],
                                  "tips": [
                                    "Regra: PACF para P (AR sazonal), ACF para Q (MA sazonal).",
                                    "Comece com P=Q=1 se picos simples.",
                                    "Use auto_arima com seasonal=True para validação."
                                  ],
                                  "learningObjective": "Mapear padrões gráficos para parâmetros sazonais P e Q.",
                                  "commonMistakes": [
                                    "Atribuir P a ACF ou vice-versa.",
                                    "Overfitting com P/Q altos.",
                                    "Não considerar parsimônia."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e finalizar parâmetros sazonais (P, D, Q, s)",
                                  "subSteps": [
                                    "Ajustar modelo SARIMA(P,D,Q,s) completo e checar resíduos (ACF resíduos ~ branco).",
                                    "Comparar AIC/BIC com alternativas e Ljung-Box em resíduos.",
                                    "Simular previsões curtas e verificar plausibilidade sazonal.",
                                    "Documentar todos os parâmetros com evidências gráficas/testes.",
                                    "Ajustar se necessário baseado em diagnósticos."
                                  ],
                                  "verification": "Resíduos sem autocorrelação sazonal (Ljung-Box p>0.05) e AIC mínimo.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "SARIMAX do statsmodels",
                                    "Diagnósticos: plot_diagnostics()"
                                  ],
                                  "tips": [
                                    "Sempre cheque resíduos para confirmação.",
                                    "Prefira modelos com menos parâmetros.",
                                    "Salve relatório com plots e valores."
                                  ],
                                  "learningObjective": "Confirmar robustez dos parâmetros sazonais via diagnósticos.",
                                  "commonMistakes": [
                                    "Pular validação e confiar só em gráficos iniciais.",
                                    "Ignorar sobrestacionariedade nos resíduos.",
                                    "Não comparar múltiplas ordens."
                                  ]
                                }
                              ],
                              "practicalExample": "Usando o dataset clássico de passageiros aéreos mensais (AirPassengers, s=12): Testes indicam D=1 (não-estacionariedade sazonal). ACF sazonal mostra pico em lag 12 para Q=1; PACF sazonal em lag 12 para P=1. Modelo SARIMA(1,1,1)(1,1,1,12) ajusta bem com resíduos brancos.",
                              "finalVerifications": [
                                "Período s identificado corretamente via FFT ou decomposição.",
                                "D sazonal torna série estacionária (teste KPSS p>0.05).",
                                "Gráficos ACF/PACF sazonais mostram padrões claros para P/Q.",
                                "Modelo SARIMA ajustado tem resíduos sem autocorrelação sazonal.",
                                "AIC/BIC confirma ordem parsimoniosa.",
                                "Previsões iniciais capturam sazonalidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de s (100% match com domínio esperado).",
                                "Uso correto de testes gráficos para D (evidência documentada).",
                                "Interpretação precisa de picos ACF/PACF para P/Q (≤1 erro).",
                                "Validação via diagnósticos de modelo (resíduos OK).",
                                "Documentação completa com plots e justificativas.",
                                "Eficiência: tempo dentro do estimado e sem overfitting."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python/R com statsmodels/forecast.",
                                "Matemática: Processos ARMA estacionários e operadores diferenciais.",
                                "Economia/Negócios: Previsão de demanda sazonal em varejo/finanças.",
                                "Machine Learning: Extensão para modelos híbridos como Prophet ou LSTM sazonal.",
                                "Visualização de Dados: Interpretação avançada de gráficos ACF/PACF."
                              ],
                              "realWorldApplication": "Em supply chain, determinar ordens sazonais SARIMA para prever picos de vendas natalinas (s=12), otimizando estoque e reduzindo custos em 15-20% via previsões precisas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.3.2",
                            "name": "Ajustar e diagnosticar modelo SARIMA",
                            "description": "Implementar arima() no R com especificação sazonal, verificando resíduos com Ljung-Box e normalidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar dados e especificar parâmetros SARIMA",
                                  "subSteps": [
                                    "Carregue o conjunto de dados de série temporal sazonal no R (ex: dados AirPassengers).",
                                    "Verifique estacionariedade com testes ADF e diferencie se necessário (d e D).",
                                    "Analise gráficos ACF e PACF para identificar ordens p, q, P, Q e período sazonal s.",
                                    "Defina a ordem SARIMA(p,d,q)(P,D,Q)s com base nas análises.",
                                    "Crie um objeto ts com frequência sazonal apropriada."
                                  ],
                                  "verification": "Gráficos ACF/PACF mostram decaimento adequado e parâmetros anotados em um relatório.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "R e RStudio",
                                    "Pacotes: forecast, tseries",
                                    "Dados de exemplo: AirPassengers"
                                  ],
                                  "tips": "Comece com modelo simples e refine iterativamente; use auto.arima() para sugestão inicial.",
                                  "learningObjective": "Identificar e especificar corretamente os parâmetros de um modelo SARIMA.",
                                  "commonMistakes": [
                                    "Ignorar sazonalidade nos gráficos ACF/PACF",
                                    "Sobrediferenciação levando a não-estacionariedade excessiva",
                                    "Escolha errada de s (período sazonal)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Ajustar o modelo SARIMA usando arima()",
                                  "subSteps": [
                                    "Execute o comando arima(y, order = c(p, d, q), seasonal = c(P, D, Q, s)).",
                                    "Verifique o sumário do modelo (summary(fit)) para coeficientes e significância.",
                                    "Extraia resíduos com residuals(fit).",
                                    "Plote o modelo ajustado vs. dados originais com plot(forecast(fit)).",
                                    "Salve o modelo em uma variável para diagnósticos subsequentes."
                                  ],
                                  "verification": "Sumário do modelo mostra convergência e coeficientes significativos (p-valor < 0.05).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "R e RStudio",
                                    "Pacote: stats (base R)"
                                  ],
                                  "tips": "Use método='ML' para máxima verossimilhança; monitore warnings sobre convergência.",
                                  "learningObjective": "Implementar e ajustar um modelo SARIMA no R com especificação sazonal.",
                                  "commonMistakes": [
                                    "Especificação incorreta de order ou seasonal",
                                    "Não tratar missing values nos dados",
                                    "Ignorar warnings de otimização"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diagnosticar autocorrelação dos resíduos com teste Ljung-Box",
                                  "subSteps": [
                                    "Execute Box.test(residuals(fit), lag = 10, type = 'Ljung-Box').",
                                    "Interprete o p-valor: deve ser > 0.05 para ausência de autocorrelação.",
                                    "Plote ACF dos resíduos para visualização.",
                                    "Se p-valor baixo, refine o modelo (aumente ordens p,q,P,Q).",
                                    "Registre o resultado em um relatório com gráfico."
                                  ],
                                  "verification": "P-valor do Ljung-Box > 0.05 e ACF dos resíduos dentro das bandas de confiança.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "R e RStudio",
                                    "Pacote: stats"
                                  ],
                                  "tips": "Teste múltiplos lags (até 2* número de parâmetros); foque em lags relevantes.",
                                  "learningObjective": "Aplicar e interpretar o teste Ljung-Box para validar independência dos resíduos.",
                                  "commonMistakes": [
                                    "Usar lags inadequados",
                                    "Confundir p-valor baixo com problema grave sem verificar ACF",
                                    "Não transformar resíduos em estacionários"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar normalidade dos resíduos e avaliação final",
                                  "subSteps": [
                                    "Execute shapiro.test(residuals(fit)) ou qqnorm(residuals(fit)).",
                                    "Plote QQ-plot e histograma dos resíduos.",
                                    "Verifique p-valor > 0.05 para normalidade.",
                                    "Calcule AIC/BIC para comparar com outros modelos.",
                                    "Gere previsões e plote com intervalos de confiança."
                                  ],
                                  "verification": "P-valor Shapiro > 0.05, QQ-plot linear e AIC baixo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "R e RStudio",
                                    "Pacotes: stats, forecast"
                                  ],
                                  "tips": "Normalidade é assumida para inferência; use robustez para previsões.",
                                  "learningObjective": "Diagnosticar normalidade dos resíduos e avaliar adequação global do modelo SARIMA.",
                                  "commonMistakes": [
                                    "Ignorar heterocedasticidade nos resíduos",
                                    "Teste Shapiro em amostras grandes (poder alto)",
                                    "Não comparar AIC com modelo nulo"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dados AirPassengers (passageiros aéreos mensais), especifique SARIMA(0,1,1)(0,1,1)12, ajuste com arima(), verifique Ljung-Box (p>0.05) e normalidade via QQ-plot, prevendo passageiros para os próximos 12 meses.",
                              "finalVerifications": [
                                "Modelo converge sem erros ou warnings graves.",
                                "P-valor Ljung-Box > 0.05 para lags 1-20.",
                                "Resíduos normais (Shapiro p>0.05 ou QQ-plot linear).",
                                "AIC/BIC menor que modelo ARIMA não-sazonal.",
                                "Previsões plausíveis com intervalos de confiança razoáveis.",
                                "Gráficos de resíduos mostram aleatoriedade (sem padrões)."
                              ],
                              "assessmentCriteria": [
                                "Especificação correta de parâmetros SARIMA baseada em ACF/PACF.",
                                "Implementação precisa da função arima() com sazonalidade.",
                                "Interpretação adequada do teste Ljung-Box e normalidade.",
                                "Relatório com sumário, gráficos e conclusões claras.",
                                "Capacidade de refinar modelo se diagnósticos falharem.",
                                "Previsões geradas e avaliadas corretamente."
                              ],
                              "crossCurricularConnections": [
                                "Estatística Inferencial: Testes de hipóteses (Ljung-Box, Shapiro).",
                                "Programação Computacional: Manipulação de séries temporais em R.",
                                "Análise Exploratória de Dados: Gráficos ACF/PACF e resíduos.",
                                "Matemática Aplicada: Modelos estocásticos e processos ARIMA."
                              ],
                              "realWorldApplication": "Previsão de vendas sazonais em varejo (ex: Natal), demanda de energia elétrica por estação, análise de séries financeiras como ações com ciclos anuais, ou previsão meteorológica de temperaturas mensais."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.3.3",
                            "name": "Gerar previsões com SARIMA",
                            "description": "Produzir forecasts de múltiplos passos à frente, incluindo intervalos de predição, e validar em aplicações reais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a Série Temporal para Modelagem SARIMA",
                                  "subSteps": [
                                    "Carregar o dataset de série temporal sazonal usando pandas",
                                    "Inspecionar missing values, outliers e estrutura sazonal",
                                    "Aplicar transformações como log ou diferenciação para estacionariedade",
                                    "Dividir a série em conjunto de treino e teste (ex: 80/20)",
                                    "Visualizar a série, ACF e PACF para confirmar sazonalidade"
                                  ],
                                  "verification": "Série limpa, estacionária, dividida e plots gerados sem erros",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python (pandas, matplotlib, statsmodels); dataset sazonal como AirPassengers ou vendas mensais",
                                  "tips": "Plote sempre ACF/PACF sazonal para detectar período s",
                                  "learningObjective": "Preparar dados adequadamente para ajuste de SARIMA",
                                  "commonMistakes": "Não tratar não-estacionariedade ou ignorar sazonalidade"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Especificar e Identificar Parâmetros SARIMA",
                                  "subSteps": [
                                    "Analisar ACF/PACF não-sazonal para determinar p, d, q",
                                    "Analisar ACF/PACF sazonal para P, D, Q e período s",
                                    "Usar auto_arima (pmdarima) para sugestões automáticas de parâmetros",
                                    "Validar parâmetros com teste de Ljung-Box em resíduos",
                                    "Documentar justificativa para ordens escolhidas"
                                  ],
                                  "verification": "Parâmetros (p,d,q)(P,D,Q)s definidos com evidências de ACF/PACF e AIC baixo",
                                  "estimatedTime": "45 minutos",
                                  "materials": "pmdarima, statsmodels; gráficos ACF/PACF",
                                  "tips": "Prefira auto_arima para iniciantes, mas entenda os outputs",
                                  "learningObjective": "Selecionar parâmetros ótimos baseados em evidências diagnósticas",
                                  "commonMistakes": "Escolher ordens altas levando a sobreajuste"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Ajustar Modelo SARIMA e Gerar Previsões Multi-Step",
                                  "subSteps": [
                                    "Instanciar SARIMAX com parâmetros identificados",
                                    "Ajustar o modelo no conjunto de treino",
                                    "Gerar previsões para h=12 passos à frente",
                                    "Calcular intervalos de predição de 95% de confiança",
                                    "Plotar previsões, intervalos e dados reais"
                                  ],
                                  "verification": "Modelo ajustado, previsões e CIs plotados corretamente",
                                  "estimatedTime": "30 minutos",
                                  "materials": "statsmodels.tsa.statespace.sarimax.SARIMAX",
                                  "tips": "Defina order=(p,d,q), seasonal_order=(P,D,Q,s) explicitamente",
                                  "learningObjective": "Produzir forecasts multi-step com quantificação de incerteza",
                                  "commonMistakes": "Esquecer ordem sazonal ou usar h muito grande sem validação"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar Previsões em Aplicação Real",
                                  "subSteps": [
                                    "Comparar previsões com conjunto de teste out-of-sample",
                                    "Calcular métricas: MAE, RMSE, MAPE",
                                    "Verificar cobertura dos intervalos de predição",
                                    "Analisar resíduos para autocorrelação restante",
                                    "Gerar relatório com interpretações e sugestões"
                                  ],
                                  "verification": "Métricas calculadas, cobertura ~95%, resíduos ok pelo Ljung-Box",
                                  "estimatedTime": "30 minutos",
                                  "materials": "sklearn.metrics ou funções custom; teste Ljung-Box",
                                  "tips": "Sempre valide out-of-sample para evitar otimismo",
                                  "learningObjective": "Avaliar e interpretar qualidade das previsões SARIMA",
                                  "commonMistakes": "Validar in-sample ou ignorar largura excessiva de CIs"
                                }
                              ],
                              "practicalExample": "Usando o dataset AirPassengers (passageiros aéreos mensais), ajuste um SARIMA(1,1,1)(1,1,1)12, gere previsões para 12 meses à frente com 95% CI, plote contra holdout e valide com MAPE <15%.",
                              "finalVerifications": [
                                "Previsões multi-step geradas com sucesso",
                                "Intervalos de 95% CI incluídos e plotados",
                                "Comparação visual previsão vs. real",
                                "Métricas de erro (MAE, RMSE, MAPE) calculadas",
                                "Cobertura de CI próxima a 95%",
                                "Resíduos sem autocorrelação significativa"
                              ],
                              "assessmentCriteria": [
                                "Precisão das previsões (MAPE <10-15%)",
                                "Adequação e justificativa dos parâmetros SARIMA",
                                "Qualidade e interpretação dos intervalos de confiança",
                                "Visualizações claras e informativas",
                                "Validação robusta out-of-sample",
                                "Relatório com aplicações reais"
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Testes de estacionariedade e diagnósticos de resíduos",
                                "Programação: Manipulação de séries temporais em Python/R",
                                "Negócios/Economia: Previsão de demanda sazonal",
                                "Matemática: Processos estocásticos e ARIMA"
                              ],
                              "realWorldApplication": "Prever demanda sazonal em supply chain para otimizar estoque, forecast de vendas varejistas para planejamento, ou séries financeiras como consumo de energia com padrões anuais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.5.4",
                        "name": "Métodos Automáticos de Previsão Sazonal",
                        "description": "Algoritmos que selecionam e ajustam modelos sazonais automaticamente, como auto.arima ou ETS.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.4.1",
                            "name": "Usar auto.arima para detecção automática",
                            "description": "Aplicar a função auto.arima() no pacote forecast do R para identificar e ajustar SARIMA ótimo baseado em critérios de informação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambiente e preparar dados sazonais",
                                  "subSteps": [
                                    "Instalar e carregar os pacotes necessários: forecast e ggplot2.",
                                    "Carregar um dataset sazonal de exemplo, como AirPassengers.",
                                    "Converter os dados para ts() com frequência sazonal apropriada (ex: frequency=12 para mensal).",
                                    "Visualizar a série com plot() ou autoplot() para confirmar sazonalidade.",
                                    "Testar estacionariedade inicial com ndiffs() e nsdiffs()."
                                  ],
                                  "verification": "Dados carregados corretamente, plot mostra padrão sazonal claro, sem erros de pacote.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "R/RStudio, pacotes: forecast, ggplot2, dataset AirPassengers (built-in).",
                                  "tips": "Sempre especifique frequency corretamente para evitar detecção errada de sazonalidade.",
                                  "learningObjective": "Preparar ambiente e dados para análise de séries temporais sazonais.",
                                  "commonMistakes": "Esquecer de instalar forecast; não definir frequency; ignorar log-transformação para variância não constante."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar e pré-processar a série temporal",
                                  "subSteps": [
                                    "Aplicar ggtsplot() ou plot() para decomposição sazonal com stl().",
                                    "Verificar e corrigir não-estacionariedade com log() se necessário e diff().",
                                    "Usar forecast::findfrequency() se frequência incerta.",
                                    "Calcular estatísticas descritivas como mean(), var() em componentes sazonal e tendência.",
                                    "Documentar observações sobre sazonalidade e tendência."
                                  ],
                                  "verification": "Decomposição stl() produz componentes claros; não-estacionariedade corrigida (KPSS test p>0.05).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Pacotes forecast e ggplot2; funções stl(), Box.test().",
                                  "tips": "Use lambda=-1 para log em auto.arima se variância aumentar com tempo.",
                                  "learningObjective": "Identificar características sazonais e preparar dados para modelagem automática.",
                                  "commonMistakes": "Não detectar sazonalidade forte; aplicar diff() excessivo antes de auto.arima."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar auto.arima() para ajuste automático SARIMA",
                                  "subSteps": [
                                    "Executar fit <- auto.arima(ts_data, seasonal=TRUE, stepwise=FALSE, approximation=FALSE).",
                                    "Especificar critérios: ic='aicc' para seleção por AICc.",
                                    "Inspecionar summary(fit) para parâmetros p,d,q,P,D,Q e sigma^2.",
                                    "Comparar com auto.arima sem seasonal=FALSE para validar necessidade sazonal.",
                                    "Salvar o modelo e plotar resíduos com checkresiduals(fit)."
                                  ],
                                  "verification": "Modelo ajustado com seasonal=TRUE; resíduos brancos (Ljung-Box p>0.05); AICc reportado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Função auto.arima() do forecast; ts object preparado.",
                                  "tips": "Desative stepwise=TRUE para busca exaustiva em datasets pequenos; use trace=TRUE para ver iterações.",
                                  "learningObjective": "Executar detecção e ajuste automático de SARIMA ótimo.",
                                  "commonMistakes": "Esquecer seasonal=TRUE; ignorar warnings sobre convergência; usar ic='aic' em vez de 'aicc'."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diagnosticar, validar e gerar previsões",
                                  "subSteps": [
                                    "Analisar resíduos: checkresiduals(fit), acf(residuals(fit)), hist(residuals(fit)).",
                                    "Gerar previsões: forecast(fit, h=12) e plot com autolayer(confint).",
                                    "Validar com hold-out: split ts em train/test, refit e calcular MAE/RMSE.",
                                    "Comparar com benchmark como naive() ou snaive().",
                                    "Interpretar coeficientes e intervalos de confiança."
                                  ],
                                  "verification": "Resíduos randômicos (sem autocorrelação); previsões com IC 95%; erro < benchmark.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Funções forecast(), accuracy(), checkresiduals().",
                                  "tips": "Sempre valide com dados out-of-sample; ajuste maxiter=1000 se não convergir.",
                                  "learningObjective": "Avaliar qualidade do modelo SARIMA e gerar previsões confiáveis.",
                                  "commonMistakes": "Aceitar modelo sem checar resíduos; previsões h muito longo sem validação."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar e iterar o modelo",
                                  "subSteps": [
                                    "Exportar summary(fit) e plot para relatório.",
                                    "Testar sensibilidade: variar ic='aic' vs 'aicc', ou passo manual arima().",
                                    "Salvar modelo com saveRDS(fit, 'modelo_arima.rds').",
                                    "Discutir limitações: assume linearidade, sensível a outliers.",
                                    "Planejar refit periódico com novos dados."
                                  ],
                                  "verification": "Relatório completo com métricas, plots e código reproduzível salvo.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "saveRDS(), R Markdown para relatório.",
                                  "tips": "Use capture.output(summary(fit)) para texto em relatórios.",
                                  "learningObjective": "Documentar processo para reprodutibilidade e melhorias futuras.",
                                  "commonMistakes": "Não salvar modelo; ignorar necessidade de refit em séries evolutivas."
                                }
                              ],
                              "practicalExample": "Usando o dataset AirPassengers (passageiros aéreos mensais 1949-1960), aplique auto.arima(log(AirPassengers), seasonal=TRUE) para prever próximos 12 meses. O modelo ótimo ARIMA(0,1,1)(0,1,1)[12] terá AICc ~1460, com previsões crescendo sazonalmente e resíduos brancos.",
                              "finalVerifications": [
                                "auto.arima() executado sem erros e com seasonal=TRUE.",
                                "Resíduos passam em Ljung-Box (p>0.05) e normalidade (JB test).",
                                "AICc ou BIC menor que benchmarks como ETS.",
                                "Previsões com IC 80%/95% plausíveis e plotadas.",
                                "Modelo salvo e código reproduzível.",
                                "Validação out-of-sample com MAE < 10% do mean."
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração de auto.arima (parâmetros corretos: seasonal, ic).",
                                "Qualidade dos diagnósticos de resíduos (plots e testes estatísticos).",
                                "Interpretação correta de summary() e coeficientes SARIMA.",
                                "Geração e visualização de previsões com confiança.",
                                "Identificação de erros comuns e iterações sensíveis.",
                                "Documentação clara e reprodutível do processo."
                              ],
                              "crossCurricularConnections": [
                                "Programação em R: manipulação de dados com ts, dplyr.",
                                "Estatística: critérios de informação (AICc, BIC), testes de resíduos.",
                                "Machine Learning: automação de hiperparâmetros similar a grid search.",
                                "Visualização de Dados: ggplot2 para séries temporais.",
                                "Econometria: modelagem de séries financeiras sazonais."
                              ],
                              "realWorldApplication": "Em empresas de varejo, usar auto.arima em vendas mensais para prever demanda sazonal de produtos, otimizando estoque e reduzindo custos em 15-20%; em finanças, forecast de retornos sazonais de ações para portfólios."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.4.2",
                            "name": "Implementar modelo ETS automático",
                            "description": "Utilizar forecast() com método ETS para suavização exponencial, testando combinações de erro, tendência e sazonalidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e os dados da série temporal",
                                  "subSteps": [
                                    "Instale e carregue os pacotes necessários: forecast e ggplot2.",
                                    "Carregue um conjunto de dados sazonal, como AirPassengers, convertendo-o para objeto ts.",
                                    "Inspecione os dados com plot(), summary() e verifique sazonalidade com ggseasonplot().",
                                    "Trate valores ausentes ou outliers se necessário com tsclean().",
                                    "Defina a frequência sazonal (ex: frequency=12 para dados mensais)."
                                  ],
                                  "verification": "Os dados são plotados corretamente mostrando sazonalidade clara, sem erros de carregamento.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Pacote forecast",
                                    "Pacote ggplot2",
                                    "Dados AirPassengers ou similar"
                                  ],
                                  "tips": "Sempre defina a frequência correta para evitar erros no modelo ETS.",
                                  "learningObjective": "Configurar ambiente R pronto para modelagem ETS com dados sazonais limpos.",
                                  "commonMistakes": [
                                    "Esquecer de carregar pacotes",
                                    "Ignorar sazonalidade nos dados",
                                    "Não converter para ts()"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Ajustar o modelo ETS automático",
                                  "subSteps": [
                                    "Use a função ets() com método='A' para seleção automática: fit <- ets(ts_data).",
                                    "Examine o resumo do modelo com summary(fit) para ver componentes (erro, tendência, sazonalidade).",
                                    "Confirme os parâmetros selecionados (ex: 'AAA' para aditivo simples).",
                                    "Plote o modelo com plot(fit) para visualizar ajuste.",
                                    "Extraia resíduos com residuals(fit) e verifique autocorrelação."
                                  ],
                                  "verification": "summary(fit) mostra AICc baixo e componentes ETS identificados corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Função ets()",
                                    "Objeto ts_data preparado"
                                  ],
                                  "tips": "Use allow.model='all' se quiser testar modelos mais complexos.",
                                  "learningObjective": "Implementar ets() automático entendendo como ele testa combinações E/T/S.",
                                  "commonMistakes": [
                                    "Não especificar método='A'",
                                    "Ignorar warnings sobre convergência",
                                    "Confundir com auto.arima()"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar previsões com forecast()",
                                  "subSteps": [
                                    "Crie previsões: fc <- forecast(fit, h=12) para 12 períodos à frente.",
                                    "Plote as previsões com plot(fc) e autoplot(fc) para intervalos de confiança.",
                                    "Extraia valores previstos com as.numeric(fc$mean).",
                                    "Ajuste níveis de confiança: forecast(fit, h=12, level=c(80,95)).",
                                    "Compare previsões com dados reais se disponíveis."
                                  ],
                                  "verification": "Gráfico de forecast() mostra faixas de confiança e alinhamento com tendência sazonal.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Modelo fit ajustado",
                                    "Função forecast()"
                                  ],
                                  "tips": "Escolha h baseado no horizonte de previsão desejado.",
                                  "learningObjective": "Usar forecast() para gerar previsões ETS acionáveis com intervalos.",
                                  "commonMistakes": [
                                    "h muito grande sem dados suficientes",
                                    "Não plotar intervalos",
                                    "Interpretar mean como certeza absoluta"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar e refinar o modelo ETS",
                                  "subSteps": [
                                    "Calcule métricas de accuracy(fit, test_data) ou checkresiduals(fit).",
                                    "Teste manualmente combinações fixas: ets(ts_data, model='AAA') vs. automático.",
                                    "Compare AICc entre modelos para validar escolha automática.",
                                    "Visualize resíduos com ggtsdisplay(residuals(fit)).",
                                    "Documente o melhor modelo e exporte previsões para CSV."
                                  ],
                                  "verification": "Residuals() são white noise (Ljung-Box p-value >0.05) e accuracy() mostra RMSE baixo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Funções accuracy(), checkresiduals()",
                                    "Dados de teste opcionais"
                                  ],
                                  "tips": "Se automático falhar, force model='ZZZ' para testar todas combinações.",
                                  "learningObjective": "Avaliar qualidade do ETS e testar variações de componentes.",
                                  "commonMistakes": [
                                    "Não checar resíduos",
                                    "Ignorar overfitting em tendências",
                                    "Comparar apenas visualmente"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dados AirPassengers (passageiros aéreos mensais), ajuste ets(AirPassengers), gere forecast(h=24) e plote para prever demanda futura, comparando com picos sazonais de verão.",
                              "finalVerifications": [
                                "Modelo ETS ajustado sem erros, com componentes E/T/S identificados.",
                                "Previsões geradas com forecast() e plotadas com intervalos de 95%.",
                                "Residuals diagnosticados como white noise via checkresiduals().",
                                "AICc comparado entre pelo menos 2 combinações de modelo.",
                                "Previsões exportadas e interpretadas em contexto sazonal.",
                                "Código reproduzível em script R."
                              ],
                              "assessmentCriteria": [
                                "Precisão na preparação de dados ts sazonais (frequência correta).",
                                "Uso correto de ets(method='A') e interpretação de summary().",
                                "Qualidade das previsões com forecast() e visualizações adequadas.",
                                "Avaliação robusta com métricas de accuracy e resíduos.",
                                "Capacidade de testar e justificar combinações ETS manuais vs. automáticas.",
                                "Clareza na documentação e interpretação prática."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Testes de estacionariedade e diagnóstico de resíduos.",
                                "Programação: Manipulação de objetos ts no R e pacotes forecast.",
                                "Machine Learning: Modelos de previsão univariada vs. ARIMA.",
                                "Negócios: Aplicação em forecasting de demanda sazonal.",
                                "Visualização de Dados: Uso de ggplot2 para séries temporais."
                              ],
                              "realWorldApplication": "Em empresas de varejo, implementar ETS automático para prever vendas sazonais de produtos (ex: Natal), otimizando estoque e reduzindo custos de excesso ou falta."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.4.3",
                            "name": "Comparar métodos automáticos em cenários reais",
                            "description": "Avaliar desempenho de auto.arima vs. HoltWinters vs. SARIMA manual em dados de finanças ou marketing, usando validação cruzada temporal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e preparar dataset real de séries temporais sazonais",
                                  "subSteps": [
                                    "Escolher um dataset público de finanças (ex: preços de ações sazonais) ou marketing (ex: vendas mensais de varejo do Kaggle)",
                                    "Carregar os dados usando pandas e inspecionar estrutura temporal com plot de linha",
                                    "Verificar e decompor sazonalidade usando statsmodels.tsa.seasonal_decompose",
                                    "Tratar valores ausentes (interpolação linear) e outliers (método IQR)",
                                    "Dividir dataset em treino (80%) e teste preservando ordem temporal (sem shuffle)"
                                  ],
                                  "verification": "Plots de decomposição sazonal exibidos e divisão temporal confirmada sem sobreposição.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python 3.x",
                                    "pandas",
                                    "matplotlib",
                                    "statsmodels",
                                    "Dataset do Kaggle ou Yahoo Finance"
                                  ],
                                  "tips": "Sempre visualize os dados antes de qualquer modelagem para confirmar sazonalidade.",
                                  "learningObjective": "Preparar dados reais adequados para comparação de modelos de previsão sazonal.",
                                  "commonMistakes": [
                                    "Usar shuffle nos dados temporais",
                                    "Ignorar detecção de sazonalidade",
                                    "Não tratar outliers"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar os métodos de previsão: auto.arima, Holt-Winters e SARIMA manual",
                                  "subSteps": [
                                    "Instalar e usar pmdarima para auto.arima: auto_arima(dados_treino, seasonal=True, stepwise=True)",
                                    "Implementar Holt-Winters com statsmodels: ExponentialSmoothing com trend='add', seasonal='add', seasonal_periods=12",
                                    "Ajustar SARIMA manual: SARIMAX com parâmetros iniciais (1,1,1)(1,1,1,12) baseados em ACF/PACF",
                                    "Gerar previsões iniciais para o conjunto de treino e plotar resíduos",
                                    "Salvar modelos ajustados para uso posterior"
                                  ],
                                  "verification": "Três modelos ajustados com summaries impressos e plots de resíduos sem padrões evidentes.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "pmdarima",
                                    "statsmodels",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Use stepwise=True no auto.arima para eficiência; teste diferentes seasonal_periods se necessário.",
                                  "learningObjective": "Dominar a implementação prática dos três métodos em Python.",
                                  "commonMistakes": [
                                    "Esquecer parâmetro seasonal no auto.arima",
                                    "Configurar Holt-Winters sem sazonalidade",
                                    "Não inspecionar resíduos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar e executar validação cruzada temporal",
                                  "subSteps": [
                                    "Implementar TimeSeriesSplit do sklearn com n_splits=5, respeitando ordem temporal",
                                    "Para cada fold: re-treinar os três modelos no treino do fold e prever no validação",
                                    "Calcular métricas por fold: MAE, RMSE e MAPE usando funções personalizadas ou sklearn.metrics",
                                    "Média das métricas ao longo dos folds para cada método",
                                    "Plotar previsões vs. reais para visualização por fold"
                                  ],
                                  "verification": "Tabela de métricas médias por método gerada e plots de CV exibidos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "sklearn.model_selection.TimeSeriesSplit",
                                    "numpy",
                                    "sklearn.metrics"
                                  ],
                                  "tips": "Garanta que o gap entre treino e validação simule cenários reais de previsão.",
                                  "learningObjective": "Aplicar validação cruzada adequada para séries temporais.",
                                  "commonMistakes": [
                                    "Usar KFold padrão em vez de temporal",
                                    "Calcular métricas no treino",
                                    "Poucos splits"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar desempenhos e interpretar resultados",
                                  "subSteps": [
                                    "Criar tabela comparativa com métricas (MAE, RMSE, MAPE) e intervalos de confiança",
                                    "Analisar qual método supera os outros e em quais aspectos (ex: auto.arima em baixa sazonalidade)",
                                    "Plotar boxplots das métricas por método ao longo dos folds",
                                    "Testar significância com Diebold-Mariano test (opcional via statsmodels)",
                                    "Documentar insights: forças/fraquezas de cada método no dataset escolhido"
                                  ],
                                  "verification": "Relatório com tabela, plots e conclusão sobre o melhor método escrito.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "pandas para tabelas",
                                    "seaborn para boxplots",
                                    "statsmodels.stats.diagnostic"
                                  ],
                                  "tips": "Considere o custo computacional: auto.arima pode ser mais lento em grandes datasets.",
                                  "learningObjective": "Interpretar comparações quantitativas e qualitativas de modelos.",
                                  "commonMistakes": [
                                    "Ignorar variância entre folds",
                                    "Concluir sem evidência estatística",
                                    "Não contextualizar ao dataset"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar no conjunto de teste final e documentar lições aprendidas",
                                  "subSteps": [
                                    "Re-treinar melhores modelos no treino completo e prever no teste hold-out",
                                    "Calcular métricas finais e comparar com CV",
                                    "Gerar relatório em Markdown/PDF com código, resultados e recomendações",
                                    "Experimentar hiperparâmetros no melhor método para melhoria",
                                    "Refletir: quando usar cada método em cenários reais"
                                  ],
                                  "verification": "Relatório completo submetido com métricas de teste e lições.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Jupyter para relatório",
                                    "GitHub para versionamento"
                                  ],
                                  "tips": "Salve seeds para reprodutibilidade em experimentos.",
                                  "learningObjective": "Consolidar aprendizado com validação final e documentação.",
                                  "commonMistakes": [
                                    "Sobreajuste ao CV ignorando teste",
                                    "Relatório incompleto",
                                    "Não discutir limitações"
                                  ]
                                }
                              ],
                              "practicalExample": "Baixe o dataset 'Monthly Sales of Airline Passengers' ou 'Rossmann Store Sales' do Kaggle. Prepare os dados mensais, aplique auto.arima, Holt-Winters e SARIMA(1,1,1)(1,1,1,12), use TimeSeriesSplit com 5 folds para comparar MAE/RMSE em previsões de 12 meses à frente, concluindo que Holt-Winters é superior para sazonalidade forte.",
                              "finalVerifications": [
                                "Tabela de métricas CV e teste para os três métodos gerada corretamente",
                                "Plots de previsões vs. reais sem leakage temporal",
                                "Conclusão justificada sobre o método vencedor com razões estatísticas",
                                "Código reprodutível em notebook com comentários",
                                "Análise de resíduos estacionários para todos modelos",
                                "Relatório destacando aplicação ao contexto (finanças/marketing)"
                              ],
                              "assessmentCriteria": [
                                "Precisão na preparação e validação temporal (sem vazamento de dados)",
                                "Correção na implementação dos três métodos (parâmetros sazonais adequados)",
                                "Qualidade das métricas calculadas e visualizações comparativas",
                                "Profundidade da interpretação e ligação ao contexto real",
                                "Clareza e organização do relatório final",
                                "Eficiência computacional e reprodutibilidade do código"
                              ],
                              "crossCurricularConnections": [
                                "Programação em Python (manipulação de dados e modelagem)",
                                "Estatística Inferencial (testes de resíduos e significância)",
                                "Gestão de Negócios (previsão para finanças e marketing)",
                                "Machine Learning (validação cruzada e tuning de hiperparâmetros)"
                              ],
                              "realWorldApplication": "Em finanças, comparar métodos para prever retornos sazonais de commodities e otimizar portfólios; em marketing, selecionar o melhor para forecasting de vendas promocionais, reduzindo estoque excessivo e maximizando receita."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.7",
                "name": "Métodos Automáticos de Previsão",
                "description": "Abordagens automatizadas para modelagem e previsão de séries temporais.",
                "totalSkills": 51,
                "atomicTopics": [
                  {
                    "id": "10.1.7.1",
                    "name": "Auto-ARIMA",
                    "description": "Método automático para seleção de parâmetros e estimação de modelos ARIMA em séries temporais.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.1.1",
                        "name": "Princípios Fundamentais do Auto-ARIMA",
                        "description": "Conceitos básicos sobre o método Auto-ARIMA, incluindo sua definição como algoritmo automático para seleção de parâmetros (p, d, q) e estimação de modelos ARIMA, utilizando critérios de informação como AIC e BIC para otimizar a previsão em séries temporais.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.1.1.1",
                            "name": "Identificar a necessidade de automação em modelos ARIMA",
                            "description": "Compreender por que a seleção manual de parâmetros p, d e q é ineficiente e como o Auto-ARIMA automatiza esse processo para séries temporais estacionárias ou não estacionárias, reduzindo subjetividade e tempo de análise.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os Fundamentos da Seleção Manual de Parâmetros ARIMA",
                                  "subSteps": [
                                    "Explicar o que são os parâmetros p (ordem AR), d (diferenciação) e q (ordem MA) em modelos ARIMA.",
                                    "Demonstrar o uso de gráficos ACF e PACF para identificar p e q manualmente.",
                                    "Discutir a necessidade de testes de estacionariedade (como ADF test) para determinar d.",
                                    "Praticar com um dataset simples de série temporal estacionária para selecionar parâmetros manualmente.",
                                    "Comparar resultados de diferentes combinações de p, d, q usando AIC/BIC."
                                  ],
                                  "verification": "Gerar gráficos ACF/PACF corretos e justificar escolhas de p=1, d=0, q=1 para um exemplo dado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Jupyter Notebook",
                                    "Biblioteca statsmodels (Python)",
                                    "Dataset de série temporal exemplo (ex: AirPassengers)"
                                  ],
                                  "tips": "Sempre verifique estacionariedade primeiro; use log-transformação se necessário para estabilizar variância.",
                                  "learningObjective": "Compreender o processo manual de identificação de parâmetros ARIMA e suas dependências.",
                                  "commonMistakes": [
                                    "Ignorar testes de estacionariedade",
                                    "Confundir p com q nos gráficos PACF/ACF",
                                    "Não penalizar overfitting com AIC"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Limitações e Ineficiências da Abordagem Manual",
                                  "subSteps": [
                                    "Listar desafios: tempo extenso para grid search de p,d,q (ex: 5x2x5=50 modelos).",
                                    "Analisar subjetividade: interpretação de gráficos ACF/PACF varia por analista.",
                                    "Quantificar tempo: simular 1 hora para seleção manual vs minutos para auto.",
                                    "Discutir impacto em séries não estacionárias: necessidade de múltiplas diferenciações manuais.",
                                    "Avaliar erros humanos: risco de modelos subótimos devido a fadiga ou falta de expertise."
                                  ],
                                  "verification": "Criar uma tabela comparativa de tempo, precisão e subjetividade entre manual e hipotético auto.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha Excel ou Pandas DataFrame",
                                    "Exemplos de logs de análise manual",
                                    "Gráficos ACF/PACF de datasets reais"
                                  ],
                                  "tips": "Use cronômetro para medir tempo real de uma seleção manual em um dataset.",
                                  "learningObjective": "Reconhecer as ineficiências práticas da seleção manual de parâmetros ARIMA.",
                                  "commonMistakes": [
                                    "Subestimar tempo para validação cruzada",
                                    "Ignorar variabilidade entre analistas",
                                    "Confundir ineficiência com imprecisão inerente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir o Conceito e Processo do Auto-ARIMA",
                                  "subSteps": [
                                    "Explicar Auto-ARIMA: algoritmo que testa combinações exaustivas de p,d,q minimizando AIC.",
                                    "Descrever passos internos: teste ADF stepwise, grid search com limites (ex: p<=5), seleção por critério informativo.",
                                    "Cobrir suporte a estacionárias/não estacionárias via diferenciação automática e SARIMA opcional.",
                                    "Instalar e rodar exemplo básico com pmdarima.auto_arima().",
                                    "Interpretar saída: melhores p,d,q selecionados e métricas como AIC."
                                  ],
                                  "verification": "Executar Auto-ARIMA em um dataset e confirmar que seleciona parâmetros equivalentes ao manual em <5 minutos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Python com pmdarima instalada",
                                    "Jupyter Notebook",
                                    "Dataset não estacionário (ex: vendas sazonais)"
                                  ],
                                  "tips": "Defina max_p=3, max_q=3 para acelerar; ative stepwise=True para eficiência.",
                                  "learningObjective": "Entender como Auto-ARIMA automatiza a seleção, reduzindo subjetividade.",
                                  "commonMistakes": [
                                    "Não especificar seasonal=False para não-sazonal",
                                    "Ignorar warnings de convergência",
                                    "Confundir Auto-ARIMA com Prophet"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar e Avaliar Necessidade de Automação em Contextos Reais",
                                  "subSteps": [
                                    "Comparar resultados: precisão (RMSE), tempo e reprodutibilidade manual vs Auto-ARIMA.",
                                    "Identificar cenários ideais para automação: grandes volumes de séries, análises rotineiras.",
                                    "Discutir limitações do Auto: menos controle para domínios específicos, risco de local minima.",
                                    "Simular caso real: prever demanda onde manual falha por deadline apertado.",
                                    "Concluir quando optar por auto: >80% dos casos para eficiência."
                                  ],
                                  "verification": "Redigir um relatório de 200 palavras justificando automação para um caso dado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Resultados de Steps 1-3",
                                    "Templates de relatório",
                                    "Ferramentas de visualização (Matplotlib)"
                                  ],
                                  "tips": "Foque em métricas quantitativas como tempo economizado (ex: 90% redução).",
                                  "learningObjective": "Justificar a necessidade de automação baseada em evidências comparativas.",
                                  "commonMistakes": [
                                    "Superestimar controle manual",
                                    "Ignorar custo computacional do Auto em grids grandes",
                                    "Não considerar validação out-of-sample"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma empresa de varejo, analise manualmente uma série de vendas diárias (1000 pontos) usando ACF/PACF para ARIMA: leva 2 horas para testar 30 modelos. Com Auto-ARIMA (pmdarima), seleciona ARIMA(2,1,2) em 3 minutos com AIC=1250, RMSE=15% menor que manual, permitindo foco em interpretação de negócios.",
                              "finalVerifications": [
                                "Explicar com precisão por que grid search manual é ineficiente (tempo e combinações).",
                                "Demonstrar execução de Auto-ARIMA e interpretar saída (p,d,q, AIC).",
                                "Comparar tempos e métricas em um dataset real.",
                                "Identificar 3 cenários onde automação é essencial (ex: múltiplas séries).",
                                "Listar 2 limitações do Auto-ARIMA e quando voltar ao manual.",
                                "Gerar gráfico de forecasts comparando manual vs auto."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de ineficiências manuais (subjetividade, tempo >80% corretas).",
                                "Correta implementação e interpretação de Auto-ARIMA (código roda sem erros).",
                                "Análise comparativa quantitativa (tabelas com AIC/RMSE).",
                                "Justificativa contextual clara para automação (exemplos reais).",
                                "Profundidade nos substeps (mínimo 80% completos).",
                                "Ausência de erros comuns listados."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Uso de bibliotecas Python (statsmodels, pmdarima) para automação.",
                                "Machine Learning: Paralelo com AutoML para hiperparâmetros em regressão.",
                                "Gestão de Projetos: Otimização de tempo em análises de dados para deadlines.",
                                "Economia/Finanças: Aplicação em forecasting de ações ou PIB.",
                                "Estatística Inferencial: Critérios AIC/BIC como testes de modelagem."
                              ],
                              "realWorldApplication": "Em finanças, bancos usam Auto-ARIMA para prever demanda de crédito em milhares de séries regionais diariamente, reduzindo de dias para horas o tempo de modelagem, permitindo decisões ágeis em risco e alocação de capital sem depender de especialistas raros."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.1.2",
                            "name": "Explicar critérios de seleção de modelos no Auto-ARIMA",
                            "description": "Descrever o uso de critérios como AIC (Akaike Information Criterion) e BIC (Bayesian Information Criterion) para escolher o melhor modelo ARIMA, priorizando parcimônia e boa adequação aos dados da série temporal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de critérios de seleção de modelos",
                                  "subSteps": [
                                    "Definir o que são critérios de informação em modelagem estatística.",
                                    "Explicar a importância da parcimônia (simplicidade do modelo) versus adequação aos dados.",
                                    "Discutir o trade-off entre viés e variância em séries temporais.",
                                    "Identificar quando usar critérios automáticos como AIC e BIC em ARIMA.",
                                    "Revisar os pressupostos de estacionariedade em séries temporais."
                                  ],
                                  "verification": "Resumir em 3 frases os conceitos chave e dar um exemplo simples de trade-off.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notebook com Python",
                                    "Documentação do SciPy sobre critérios de informação"
                                  ],
                                  "tips": "Comece com analogias cotidianas, como escolher a roupa mais simples que serve bem.",
                                  "learningObjective": "Entender o papel dos critérios na seleção de modelos ARIMA.",
                                  "commonMistakes": [
                                    "Confundir parcimônia com modelo mais simples sempre melhor",
                                    "Ignorar a necessidade de validação cruzada"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar o critério AIC (Akaike Information Criterion)",
                                  "subSteps": [
                                    "Aprender a fórmula do AIC: AIC = -2*log(L) + 2*k, onde L é verossimilhança e k é número de parâmetros.",
                                    "Calcular AIC manualmente para dois modelos ARIMA hipotéticos.",
                                    "Interpretar valores menores de AIC como melhores ajustes penalizando complexidade.",
                                    "Comparar AIC com RSS (Residual Sum of Squares) em exemplos numéricos.",
                                    "Explorar limitações do AIC em amostras pequenas."
                                  ],
                                  "verification": "Calcular AIC para um modelo ARIMA(1,1,1) com log(L)=-100 e k=3.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com statsmodels",
                                    "Planilha Excel para cálculos manuais"
                                  ],
                                  "tips": "Use funções prontas como sm.tsa.ARIMA para testar valores reais.",
                                  "learningObjective": "Dominar o cálculo e interpretação do AIC.",
                                  "commonMistakes": [
                                    "Esquecer a penalização por parâmetros extras",
                                    "Interpretar AIC absoluto sem comparação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar o critério BIC (Bayesian Information Criterion)",
                                  "subSteps": [
                                    "Aprender a fórmula do BIC: BIC = -2*log(L) + k*log(n), onde n é o tamanho da amostra.",
                                    "Comparar BIC com AIC destacando a penalização mais forte para modelos complexos.",
                                    "Calcular BIC para os mesmos modelos do AIC e analisar diferenças.",
                                    "Discutir preferência por BIC em grandes amostras para parcimônia.",
                                    "Examinar cenários onde BIC seleciona modelos diferentes do AIC."
                                  ],
                                  "verification": "Comparar AIC e BIC para um modelo com n=100, log(L)=-100, k=3.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código Python com statsmodels",
                                    "Gráficos comparativos AIC vs BIC"
                                  ],
                                  "tips": "Visualize com plots para ver como BIC pune mais a complexidade.",
                                  "learningObjective": "Compreender e calcular o BIC em contexto de ARIMA.",
                                  "commonMistakes": [
                                    "Confundir BIC com critério bayesiano puro",
                                    "Ignorar o impacto de n no BIC"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar critérios AIC e BIC no Auto-ARIMA",
                                  "subSteps": [
                                    "Explicar como o Auto-ARIMA usa busca em grade para testar combinações (p,d,q,P,D,Q).",
                                    "Demonstrar seleção do modelo com menor AIC/BIC usando pmdarima.",
                                    "Interpretar saída do Auto-ARIMA: ordem selecionada e valores de critérios.",
                                    "Validar com diagnósticos de resíduos (Ljung-Box, normalidade).",
                                    "Comparar previsões de modelos top 3 por AIC/BIC."
                                  ],
                                  "verification": "Executar Auto-ARIMA em dados de exemplo e explicar por que um modelo foi escolhido.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Biblioteca pmdarima",
                                    "Dataset de série temporal (ex: AirPassengers)"
                                  ],
                                  "tips": "Use stepwise=True para acelerar a busca e compare com busca exaustiva.",
                                  "learningObjective": "Aplicar critérios na automação de seleção de modelos ARIMA.",
                                  "commonMistakes": [
                                    "Aceitar modelo sem checar resíduos",
                                    "Ignorar configuração ic='aic' ou 'bic'"
                                  ]
                                }
                              ],
                              "practicalExample": "Ao prever vendas mensais de uma loja com dados de 5 anos, o Auto-ARIMA testa ARIMA(2,1,2) com AIC=250 e ARIMA(1,1,1) com AIC=255, selecionando o primeiro por menor AIC, garantindo bom ajuste sem overfitting.",
                              "finalVerifications": [
                                "Calcular manualmente AIC e BIC para modelos simples.",
                                "Executar Auto-ARIMA e interpretar a saída de critérios.",
                                "Explicar diferença entre AIC e BIC em 2 cenários.",
                                "Identificar modelo ótimo em um output real.",
                                "Validar seleção com gráficos de resíduos.",
                                "Comparar resultados com modelo manual."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas fórmulas de AIC e BIC (100% correta).",
                                "Correta interpretação de valores menores como melhores.",
                                "Uso adequado de pmdarima com parâmetros ic.",
                                "Análise de trade-offs parcimônia vs ajuste.",
                                "Validação com diagnósticos de modelo.",
                                "Explicação clara de aplicações em Auto-ARIMA."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de verossimilhança e logaritmos.",
                                "Programação: Implementação em Python com statsmodels/pmdarima.",
                                "Economia: Previsão de séries temporais econômicas.",
                                "Probabilidade: Conceitos bayesianos no BIC.",
                                "Ciência de Dados: Validação de modelos e overfitting."
                              ],
                              "realWorldApplication": "Em finanças, bancos usam Auto-ARIMA com AIC/BIC para selecionar modelos de previsão de retornos de ações, otimizando portfólios e reduzindo riscos de modelos superajustados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.1.3",
                            "name": "Diferenciar Auto-ARIMA de ARIMA manual",
                            "description": "Comparar o processo automático do Auto-ARIMA com a especificação manual de parâmetros, destacando vantagens em cenários com múltiplas séries temporais ou dados limitados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Processo de ARIMA Manual",
                                  "subSteps": [
                                    "Examine os componentes do modelo ARIMA (p, d, q) e seu significado: p para autoregressão, d para diferenciação, q para média móvel.",
                                    "Aprenda a usar gráficos ACF e PACF para identificar valores iniciais de p, d e q.",
                                    "Implemente o modelo manualmente ajustando parâmetros e avaliando com critérios como AIC ou BIC.",
                                    "Teste o modelo com validação cruzada em séries temporais (ex: expanding window).",
                                    "Ajuste iterativamente os parâmetros com base em resíduos e diagnósticos."
                                  ],
                                  "verification": "Crie um modelo ARIMA manual em Python usando statsmodels e verifique se o AIC é calculado corretamente.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Python com statsmodels",
                                    "Dataset de série temporal (ex: AirPassengers)",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Sempre plote os resíduos para checar normalidade e ausência de autocorrelação.",
                                  "learningObjective": "Compreender e replicar o fluxo manual de especificação e ajuste de parâmetros ARIMA.",
                                  "commonMistakes": [
                                    "Ignorar estacionariedade e não diferenciar adequadamente",
                                    "Escolher p/d/q sem base em ACF/PACF",
                                    "Não validar com hold-out set"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar os Princípios do Auto-ARIMA",
                                  "subSteps": [
                                    "Instale e importe a biblioteca pmdarima para Auto-ARIMA.",
                                    "Entenda o algoritmo: busca stepwise (grid search) para p, d, q usando critérios como AICc.",
                                    "Configure parâmetros opcionais como seasonal=True para SARIMA, max_p, max_q, etc.",
                                    "Execute auto_arima() em um dataset e interprete o summary com os parâmetros selecionados.",
                                    "Compare o tempo de execução com o processo manual."
                                  ],
                                  "verification": "Rode auto_arima() em um dataset simples e confirme que retorna p, d, q otimizados com AIC baixo.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Python com pmdarima e statsmodels",
                                    "Dataset não sazonal (ex: sunspots)",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Use stepwise_mode='stepwise' para aceleração; monitore verbose=1 para ver iterações.",
                                  "learningObjective": "Dominar a automação de seleção de parâmetros via Auto-ARIMA e seus mecanismos internos.",
                                  "commonMistakes": [
                                    "Não especificar d_range corretamente levando a sobre-diferenciação",
                                    "Ignorar warnings de convergência",
                                    "Confundir com Prophet ou outros auto-forecasters"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Processos Passo a Passo",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: manual (iterativo, expertise requerida) vs Auto (automático, busca exaustiva).",
                                    "Meça métricas: tempo de computação, AIC final, RMSE em teste para ambos.",
                                    "Analise casos onde coincidem vs divergem (ex: dados ruidosos).",
                                    "Discuta trade-offs: interpretabilidade manual vs eficiência auto.",
                                    "Visualize previsões lado a lado com plot_forecast()."
                                  ],
                                  "verification": "Gere uma tabela Markdown ou DataFrame comparando resultados de ambos os métodos em um dataset.",
                                  "estimatedTime": "25-40 minutos",
                                  "materials": [
                                    "Python (pmdarima, statsmodels, pandas)",
                                    "Dataset misto (ex: co2 dataset)",
                                    "Matplotlib/Seaborn"
                                  ],
                                  "tips": "Use o mesmo seed e dados de treino/teste para comparação justa.",
                                  "learningObjective": "Identificar diferenças operacionais e de resultados entre Auto-ARIMA e ARIMA manual.",
                                  "commonMistakes": [
                                    "Comparar em datasets onde manual é otimizado manualmente",
                                    "Ignorar custo computacional em grandes grids",
                                    "Não normalizar escalas de métricas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Vantagens em Cenários Específicos",
                                  "subSteps": [
                                    "Teste com múltiplas séries temporais (loop auto_arima vs manual custom).",
                                    "Simule dados limitados (poucos pontos) e compare estabilidade.",
                                    "Avalie em cenários sazonais vs não-sazonais.",
                                    "Calcule speedup: tempo auto / tempo manual.",
                                    "Conclua com guidelines: use auto para prototipagem rápida."
                                  ],
                                  "verification": "Documente speedup >2x em 3 séries e explique por quê em dados limitados.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Múltiplos datasets (ex: Mcomp de pmdarima)",
                                    "Python scripting",
                                    "Timer (timeit)"
                                  ],
                                  "tips": "Para dados limitados, force maxiter baixo para evitar overfitting.",
                                  "learningObjective": "Aplicar a diferenciação em contextos reais, destacando quando Auto-ARIMA é superior.",
                                  "commonMistakes": [
                                    "Generalizar vantagens sem testes empíricos",
                                    "Subestimar expertise necessária para validar auto-resultados",
                                    "Não considerar paralelização"
                                  ]
                                }
                              ],
                              "practicalExample": "Carregue o dataset AirPassengers no Python. Implemente ARIMA manual (p=2,d=1,q=2 via ACF/PACF, ajuste com SARIMAX). Em seguida, use auto_arima(AirPassengers, seasonal=True, m=12). Compare AIC (manual: ~450, auto: otimizado), RMSE de previsão out-of-sample e tempo (manual: 10min iterativo vs auto: 30s). Plote ambas as previsões para visualizar similaridades.",
                              "finalVerifications": [
                                "Explicar em 3 frases o fluxo de busca do Auto-ARIMA vs iterações manuais.",
                                "Implementar ambos em novo dataset e reportar diferenças em AIC/RMSE.",
                                "Listar 2 cenários onde manual é preferível (ex: conhecimento domínio específico).",
                                "Demonstrar speedup em múltiplas séries.",
                                "Interpretar summary de auto_arima corretamente.",
                                "Identificar quando Auto-ARIMA falha (ex: não-estacionário extremo)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de p,d,q seleção (manual: visual; auto: algorítmica).",
                                "Correta implementação e comparação empírica com métricas quantitativas.",
                                "Análise contextual de vantagens (múltiplas séries/dados limitados).",
                                "Uso adequado de bibliotecas sem erros de sintaxe.",
                                "Clareza em tabelas/plots comparativos.",
                                "Profundidade em trade-offs (tempo vs interpretabilidade)."
                              ],
                              "crossCurricularConnections": [
                                "Programação em Python (statsmodels/pmdarima)",
                                "Machine Learning (automação de hiperparâmetros como grid search)",
                                "Estatística Inferencial (critérios AIC/BIC)",
                                "Gestão de Dados (pipelines de forecasting escaláveis)",
                                "Visualização de Dados (plots ACF/PACF/previsões)"
                              ],
                              "realWorldApplication": "Em finanças, Auto-ARIMA acelera prototipagem de previsões de ações para múltiplos tickers diários, permitindo data scientists focarem em features externas em vez de tuning manual, especialmente com dados limitados de alta frequência."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.1.2",
                        "name": "Algoritmo de Seleção Automática de Parâmetros",
                        "description": "Detalhamento do algoritmo stepwise utilizado pelo Auto-ARIMA para determinar a ordem de diferenciação (d) e os parâmetros AR (p) e MA (q), incluindo testes de estacionariedade.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.1.2.1",
                            "name": "Aplicar testes automáticos para determinação de d",
                            "description": "Executar testes unit root como ADF (Augmented Dickey-Fuller) e KPSS para selecionar automaticamente o número de diferenciações necessárias, garantindo estacionariedade na série temporal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar ambiente e dados para testes de raiz unitária",
                                  "subSteps": [
                                    "Instalar e importar bibliotecas necessárias: pandas, numpy e statsmodels.",
                                    "Carregar a série temporal de dados (ex: dados de vendas mensais).",
                                    "Visualizar a série com plot para identificar não-estacionariedade (tendência ou sazonalidade).",
                                    "Verificar propriedades básicas: média, variância e autocorrelação inicial.",
                                    "Definir função auxiliar para plotar ACF/PACF antes e após testes."
                                  ],
                                  "verification": "Ambiente configurado e dados carregados com plot inicial exibido sem erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "Bibliotecas: pandas, numpy, statsmodels, matplotlib"
                                  ],
                                  "tips": "Sempre padronize a escala dos dados para facilitar interpretação dos testes.",
                                  "learningObjective": "Configurar corretamente o ambiente computacional e preparar série temporal para análise de estacionariedade.",
                                  "commonMistakes": "Esquecer de tratar valores ausentes (NaN) que invalidam os testes; ignorar visualização inicial."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar teste ADF (Augmented Dickey-Fuller) iterativamente",
                                  "subSteps": [
                                    "Executar statsmodels.tsa.stattools.adfuller() na série original e registrar p-value.",
                                    "Se p-value > 0.05 (não rejeita H0 de raiz unitária), diferenciar a série (diff()) e repetir.",
                                    "Manter contador de diferenciações (d=0,1,2...) até p-value <= 0.05.",
                                    "Armazenar resultados em DataFrame: d, p-value ADF, estatística teste.",
                                    "Plotar série diferenciada e ACF para visual confirmação."
                                  ],
                                  "verification": "Loop executa até p-value ADF <=0.05 e d é registrado corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "statsmodels.tsa.stattools.adfuller",
                                    "pandas.Series.diff"
                                  ],
                                  "tips": "Use max_d=3 para evitar sobrediferenciação; inclua lags='auto' no ADF.",
                                  "learningObjective": "Aplicar ADF para detectar e quantificar diferenciações necessárias automaticamente.",
                                  "commonMistakes": "Não incluir lags suficientes causando autocorrelação residual; continuar diferenciando após estacionariedade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar teste KPSS para confirmação de estacionariedade",
                                  "subSteps": [
                                    "Executar statsmodels.tsa.stattools.kpss() na série após d diferenciações do ADF.",
                                    "Interpretar: p-value <=0.05 rejeita H0 de estacionariedade (confirma não-estacionária).",
                                    "Comparar resultados ADF vs KPSS: ADF detecta raiz unitária, KPSS confirma estacionariedade.",
                                    "Ajustar d se houver conflito (aumentar se KPSS indica tendência).",
                                    "Registrar p-values e plots comparativos."
                                  ],
                                  "verification": "KPSS confirma estacionariedade (p-value >0.05) na série diferenciada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "statsmodels.tsa.stattools.kpss"
                                  ],
                                  "tips": "KPSS é complementar ao ADF: use ambos para robustez na seleção de d.",
                                  "learningObjective": "Validar resultados do ADF com KPSS, resolvendo discrepâncias para d preciso.",
                                  "commonMistakes": "Confundir hipóteses nulas (ADF: H0=raiz unitária; KPSS: H0=estacionária); ignorar regressão='ct' para tendências."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Automatizar seleção de d e integrar em pipeline Auto-ARIMA",
                                  "subSteps": [
                                    "Criar função auto_d() que integra loops ADF+KPSS e retorna d ótimo.",
                                    "Testar função em série original e verificar estacionariedade final.",
                                    "Integrar d selecionado em modelo ARIMA(p,d,q) para auto-seleção.",
                                    "Avaliar resíduos do modelo com Ljung-Box para confirmação.",
                                    "Documentar processo com prints/logs de decisões."
                                  ],
                                  "verification": "Função retorna d correto, série final passa ambos testes e resíduos são brancos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Função customizada em Python",
                                    "statsmodels.tsa.arima.model.ARIMA"
                                  ],
                                  "tips": "Defina critérios combinados: min d onde ADF ok E KPSS ok.",
                                  "learningObjective": "Desenvolver script automatizado para determinação de d, pronto para Auto-ARIMA.",
                                  "commonMistakes": "Sobrediferenciação levando a série over-differentiated (ruído excessivo); não validar com ACF de resíduos."
                                }
                              ],
                              "practicalExample": "Em uma série temporal de preços de ações diários (ex: AAPL de 2020-2023), carregue via yfinance. ADF inicial: p=0.85 (não-estacionária). Diferencie 1x: p=0.12; 2x: p=0.001 (estacionária). KPSS confirma p=0.04 após 1 diff, mas ajuste para 2. Use d=2 no Auto-ARIMA para previsão precisa.",
                              "finalVerifications": [
                                "Série diferenciada d vezes passa ADF (p<=0.05) e KPSS (p>0.05).",
                                "ACF/PACF da série diferenciada decai rapidamente sem padrões.",
                                "Resíduos de ARIMA(d integrado) passam teste Ljung-Box (p>0.05).",
                                "Função auto_d() reproduz d manual em múltiplas séries teste.",
                                "Documentação inclui p-values, plots e justificativa de d.",
                                "Pipeline roda sem erros em dados reais."
                              ],
                              "assessmentCriteria": [
                                "Implementação correta de ADF e KPSS com interpretação precisa de p-values.",
                                "Loop iterativo para diferenciação funciona até convergência.",
                                "Resolução de conflitos entre testes com lógica clara.",
                                "Automação em função reutilizável com validações integradas.",
                                "Código limpo, comentado e com visualizações explicativas.",
                                "Aplicação bem-sucedida em exemplo prático com resultados coerentes."
                              ],
                              "crossCurricularConnections": [
                                "Estatística Inferencial (hipóteses nulas, p-values).",
                                "Programação em Python (loops, funções, bibliotecas statsmodels).",
                                "Análise de Dados Exploratória (plots ACF/PACF).",
                                "Machine Learning (pré-processamento para modelos de previsão).",
                                "Econometria (modelos de séries temporais estacionárias)."
                              ],
                              "realWorldApplication": "Em finanças, determinar d para modelar retornos de ações estacionários antes de ARIMA, melhorando previsões de risco; em supply chain, auto-selecionar d para demanda de produtos sazonais, otimizando estoque e reduzindo custos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.2.2",
                            "name": "Compreender a busca stepwise para p e q",
                            "description": "Explicar o processo de busca em grid ou stepwise (unidirecional, bidirecional) para encontrar os melhores p e q dentro de limites especificados, minimizando o AIC em modelos ARIMA.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os conceitos fundamentais de p, q em ARIMA e critério AIC",
                                  "subSteps": [
                                    "Revise a definição de parâmetros AR(p) e MA(q) em modelos ARIMA.",
                                    "Estude a fórmula do critério AIC: AIC = -2*log(L) + 2*(p + q + d + 1).",
                                    "Analise como AIC equilibra ajuste do modelo e complexidade (penalização por mais parâmetros).",
                                    "Identifique limites típicos: max_p (0-5), max_q (0-5).",
                                    "Compare AIC com BIC e entenda por que AIC é preferido em Auto-ARIMA."
                                  ],
                                  "verification": "Explique em suas palavras o papel de p, q e AIC, com um exemplo numérico simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação ARIMA (Wikipedia ou statsmodels docs), notebook Jupyter.",
                                  "tips": "Use diagramas para visualizar ordens AR e MA como filtros em séries temporais.",
                                  "learningObjective": "Compreender como p e q capturam dependências passadas e erros, e por que minimizar AIC é crucial.",
                                  "commonMistakes": "Confundir p (autoregressivo) com q (média móvel); ignorar penalização no AIC levando a overfitting."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender o algoritmo de busca stepwise unidirecional",
                                  "subSteps": [
                                    "Descreva o fluxo: Comece com p=0, q=0; fixe p e otimize q stepwise; depois fixe q e otimize p.",
                                    "Simule iterações: Teste q=0,1,2,... até max_q, escolha melhor AIC; repita para p.",
                                    "Implemente pseudocódigo: loop aninhado com fit ARIMA e cálculo AIC.",
                                    "Compare eficiência: Menos fits que grid search completo (max_p * max_q).",
                                    "Teste com dados sintéticos: Gere série AR(1) e veja convergência para p=1, q=0."
                                  ],
                                  "verification": "Escreva pseudocódigo funcional e rode em dados sintéticos, confirmando p,q ótimos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python com statsmodels/pmdarima, dados sintéticos (np.random).",
                                  "tips": "Monitore AIC em cada iteração com print/logs para visualizar progressão.",
                                  "learningObjective": "Dominar a lógica sequencial unidirecional que otimiza p e q alternadamente.",
                                  "commonMistakes": "Parar em mínimo local sem verificar convergência; confundir direção (p-first vs q-first)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar busca stepwise bidirecional e comparações",
                                  "subSteps": [
                                    "Defina bidirecional: Otimize p fixando q, depois q fixando p, alternando até convergência.",
                                    "Implemente critério de parada: ΔAIC < threshold ou max iterações.",
                                    "Compare unidirecional vs bidirecional vs grid: Rode os três em mesmo dataset.",
                                    "Analise trade-offs: Bidirecional mais preciso mas computacionalmente intensivo.",
                                    "Visualize caminhos de busca com gráficos de AIC vs (p,q)."
                                  ],
                                  "verification": "Gere tabela comparativa de AIC final e tempo para os três métodos em um dataset.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Jupyter notebook, pmdarima (stepwise_mode='narrow'/'wide'), matplotlib.",
                                  "tips": "Use heatmap para grid search AIC, destacando stepwise path.",
                                  "learningObjective": "Diferenciar variantes de stepwise e avaliar eficiência/precisão.",
                                  "commonMistakes": "Ignorar sazonalidade (P,Q); assumir convergência sempre global."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e validar busca stepwise em série temporal real",
                                  "subSteps": [
                                    "Carregue dataset real (ex: airpassengers).",
                                    "Execute auto_arima com stepwise=True, inspecione selected_order=(p,d,q).",
                                    "Reproduza manualmente: Fit modelos candidatos e confirme AIC mínimo.",
                                    "Teste sensibilidade: Varie max_p/max_q e observe estabilidade.",
                                    "Documente limitações: Não otimiza d ou sazonalidade aqui."
                                  ],
                                  "verification": "Compare AIC manual vs auto_arima; plote resíduos para validar ajuste.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Dataset airpassengers (R datasets ou Python), pmdarima/statsmodels.",
                                  "tips": "Log transforme dados não-estacionários antes.",
                                  "learningObjective": "Aplicar stepwise na prática e validar resultados.",
                                  "commonMistakes": "Não diferenciar/d; usar dados não-estacionários sem teste ADF."
                                }
                              ],
                              "practicalExample": "Usando dados de passageiros aéreos (airpassengers): Inicie com p=0,q=0 (AIC alto). Unidirecional: Otimize q→1 (melhor), fixe q=1 otimize p→2 (AIC=2010). Bidirecional refina para (2,1,1). Grid completo testa 6x6=36 fits; stepwise ~10 fits.",
                              "finalVerifications": [
                                "Explicar pseudocódigo de stepwise unidirecional sem olhar notas.",
                                "Identificar p,q ótimos em dataset teste com AIC correto.",
                                "Comparar AIC de stepwise vs grid em exemplo real.",
                                "Desenhar fluxograma bidirecional com critério de parada.",
                                "Discutir quando stepwise falha (ex: multimodais).",
                                "Reproduzir auto_arima stepwise em código Python."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de p,q e AIC (80%+ correto).",
                                "Pseudocódigo funcional e eficiente.",
                                "Análise comparativa quantitativa (AIC, tempo).",
                                "Visualizações claras de caminhos de busca.",
                                "Identificação correta de erros comuns e soluções.",
                                "Aplicação bem-sucedida em dataset real com validação."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python/R (loops, funções).",
                                "Otimização: Heurísticas vs exaustiva (grid search).",
                                "Matemática: Funções de perda, penalização L1/L2.",
                                "Ciência de Dados: Pipelines automáticos (AutoML)."
                              ],
                              "realWorldApplication": "Em previsão de demanda de varejo, stepwise seleciona p=1,q=1 rapidamente para ARIMA em vendas diárias, minimizando AIC para estoque eficiente, economizando horas vs grid em datasets grandes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.2.3",
                            "name": "Avaliar tratamento de sazonalidade no Auto-ARIMA",
                            "description": "Identificar opções para modelos SARIMA automáticos, como detecção de período sazonal e inclusão de parâmetros sazonais (P, D, Q) via busca expandida.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender sazonalidade e sua representação em modelos SARIMA",
                                  "subSteps": [
                                    "Estudar a definição de sazonalidade em séries temporais e exemplos comuns (diária, semanal, mensal, anual).",
                                    "Revisar a estrutura SARIMA: componentes sazonais (P, D, Q) e sua relação com ARIMA padrão (p, d, q).",
                                    "Analisar como Auto-ARIMA estende a busca para incluir parâmetros sazonais via grid search expandido.",
                                    "Examinar a diferença entre modelos ARIMA e SARIMA em dados sazonais.",
                                    "Identificar critérios para decidir quando usar tratamento sazonal."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito a diferença entre parâmetros sazonais (P, D, Q) e não sazonais, com um diagrama simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação pmdarima",
                                    "Tutoriais sobre SARIMA (ex: statsmodels)",
                                    "Notebook Jupyter vazio"
                                  ],
                                  "tips": "Use gráficos de séries temporais reais para visualizar sazonalidade antes de mergulhar em fórmulas.",
                                  "learningObjective": "Dominar os conceitos fundamentais de sazonalidade e parâmetros SARIMA para avaliação posterior.",
                                  "commonMistakes": [
                                    "Confundir sazonalidade com tendência",
                                    "Ignorar a necessidade de período sazonal conhecido",
                                    "Assumir que Auto-ARIMA sempre detecta sazonalidade automaticamente sem configuração"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Detectar o período sazonal nos dados",
                                  "subSteps": [
                                    "Carregar um dataset com potencial sazonalidade (ex: AirPassengers ou vendas mensais).",
                                    "Plotar a série temporal, ACF (Autocorrelation Function) e PACF para visualizar padrões sazonais.",
                                    "Testar diferentes períodos sazonais (m=12 para mensal, m=7 para semanal) usando decomposição sazonal.",
                                    "Usar testes estatísticos como STL ou canova_test para confirmar sazonalidade.",
                                    "Documentar o período sazonal detectado (ex: 12 para dados mensais)."
                                  ],
                                  "verification": "Gerar gráficos de ACF/PACF mostrando picos sazonais claros no período identificado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com pandas, matplotlib, statsmodels",
                                    "Dataset exemplo: AirPassengers do R ou equivalente em Python",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Aumente o número de lags no ACF para ver padrões sazonais longos; foque em picos repetitivos.",
                                  "learningObjective": "Adquirir habilidades para detectar empiricamente o período sazonal em séries temporais.",
                                  "commonMistakes": [
                                    "Escolher período errado baseado só em intuição",
                                    "Não diferenciar sazonalidade de ciclos longos",
                                    "Ignorar ruído nos dados iniciais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar Auto-ARIMA com opções de sazonalidade",
                                  "subSteps": [
                                    "Instalar e importar pmdarima ou equivalente (pmdarima.auto_arima).",
                                    "Executar Auto-ARIMA sem sazonalidade (seasonal=False) e registrar métricas (AIC, BIC).",
                                    "Executar com seasonal=True, especificando m (período sazonal) e stepwise=True para busca eficiente.",
                                    "Explorar parâmetros sazonais selecionados (P, D, Q) e comparar com busca manual limitada.",
                                    "Ajustar limites para P, D, Q (ex: max_P=2) para evitar overfitting."
                                  ],
                                  "verification": "Executar código e mostrar summary do modelo com parâmetros sazonais não nulos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Biblioteca pmdarima",
                                    "Dataset com sazonalidade conhecida",
                                    "Ambiente Python (Google Colab ou local)"
                                  ],
                                  "tips": "Comece com stepwise=True para agilizar; monitore warnings sobre convergência.",
                                  "learningObjective": "Configurar e executar Auto-ARIMA com detecção automática de componentes sazonais.",
                                  "commonMistakes": [
                                    "Definir m incorreto levando a modelo inválido",
                                    "Não comparar modelos com/sem sazonalidade",
                                    "Overfitting por não limitar ordem sazonal"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar e validar o tratamento de sazonalidade",
                                  "subSteps": [
                                    "Comparar métricas de ajuste (AIC, BIC, RMSE em validação cruzada temporal).",
                                    "Analisar resíduos: plotar e testar estacionariedade (ADF test) e ausência de autocorrelação.",
                                    "Gerar previsões out-of-sample e plotar com intervalos de confiança.",
                                    "Realizar backtesting com diferentes configurações sazonais.",
                                    "Documentar conclusões: se sazonalidade melhora o modelo ou não."
                                  ],
                                  "verification": "Relatório com tabelas de métricas e gráficos de resíduos/provisões mostrando melhoria com sazonalidade.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "pmdarima, statsmodels.tsa.stattools",
                                    "Dataset dividido em train/test"
                                  ],
                                  "tips": "Use validação cruzada temporal (TimeSeriesSplit) para robustez; priorize BIC para parcimônia.",
                                  "learningObjective": "Avaliar criticamente se o tratamento sazonal é necessário e eficaz no Auto-ARIMA.",
                                  "commonMistakes": [
                                    "Avaliar só em-sample ignorando generalização",
                                    "Não testar resíduos por autocorrelação restante",
                                    "Concluir sem comparar múltiplas runs"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um dataset de vendas mensais de sorvetes (com picos no verão), use Auto-ARIMA para detectar período sazonal m=12, incluir P=1, D=1, Q=1 e verificar se RMSE cai 20% comparado ao modelo sem sazonalidade.",
                              "finalVerifications": [
                                "Detectar corretamente período sazonal via ACF em dataset exemplo.",
                                "Executar Auto-ARIMA com seasonal=True e interpretar parâmetros P, D, Q.",
                                "Comparar AIC/BIC de modelos com/sem sazonalidade.",
                                "Validar resíduos como ruído branco (Ljung-Box test p-value >0.05).",
                                "Gerar previsões precisas para 12 períodos à frente.",
                                "Documentar trade-offs de complexidade vs. performance."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção de período sazonal (acurácia >90% em exemplos).",
                                "Correta configuração e execução de Auto-ARIMA sazonal.",
                                "Análise robusta de métricas (AIC, BIC, RMSE) com comparações claras.",
                                "Interpretação adequada de resíduos e diagnósticos.",
                                "Relatório estruturado com gráficos e conclusões acionáveis.",
                                "Identificação de overfitting ou subajuste sazonal."
                              ],
                              "crossCurricularConnections": [
                                "Estatística Descritiva: Análise ACF/PACF e decomposição.",
                                "Programação em Python: Manipulação de dados com pandas e modelagem.",
                                "Machine Learning: Seleção automática de hiperparâmetros e validação cruzada.",
                                "Análise Exploratória de Dados: Visualização de séries temporais.",
                                "Econometria: Aplicações em previsão econômica sazonal."
                              ],
                              "realWorldApplication": "Em varejo, prever demanda sazonal de produtos (ex: Natal ou Black Friday) para otimizar estoque e logística, reduzindo custos em até 15% via modelos SARIMA automáticos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.1.3",
                        "name": "Implementação e Aplicação Prática do Auto-ARIMA",
                        "description": "Procedimentos para implementação do Auto-ARIMA em softwares como R (pacote forecast) e Python (pmdarima), incluindo interpretação de resultados e aplicações em contextos reais.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.1.3.1",
                            "name": "Implementar Auto-ARIMA em R com a função auto.arima()",
                            "description": "Utilizar a função auto.arima() do pacote forecast no R para ajustar um modelo automático a uma série temporal, especificando limites de busca e opções de sazonalidade, e gerar previsões.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente R e carregar os dados da série temporal",
                                  "subSteps": [
                                    "Instale o R e RStudio se necessário.",
                                    "Crie um novo script R.",
                                    "Carregue um dataset de série temporal exemplo, como AirPassengers do pacote datasets.",
                                    "Converta os dados em objeto ts() com frequência apropriada (ex: frequency=12 para mensal).",
                                    "Visualize a série com plot() e verifique sazonalidade com ggseasonplot() do pacote feasts."
                                  ],
                                  "verification": "Execute o código sem erros e visualize o gráfico da série temporal corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "R e RStudio instalados",
                                    "Pacotes: datasets (base), forecast, ggplot2, feasts"
                                  ],
                                  "tips": "Sempre defina a frequência correta para evitar erros de sazonalidade.",
                                  "learningObjective": "Configurar corretamente um objeto de série temporal em R.",
                                  "commonMistakes": [
                                    "Esquecer de especificar frequency no ts()",
                                    "Não verificar sazonalidade inicial",
                                    "Usar dados não numéricos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Instalar e carregar os pacotes necessários",
                                  "subSteps": [
                                    "Execute install.packages('forecast') se não instalado.",
                                    "Execute library(forecast) para carregar.",
                                    "Opcionalmente, carregue library(ggplot2) para plots avançados.",
                                    "Verifique a versão do forecast com packageVersion('forecast').",
                                    "Teste uma função básica como auto.arima(AirPassengers) para validar instalação."
                                  ],
                                  "verification": "auto.arima() executa sem erros de pacote ausente.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Conexão à internet para instalação",
                                    "CRAN mirror configurado"
                                  ],
                                  "tips": "Use install.packages('forecast', dependencies=TRUE) para evitar problemas de dependências.",
                                  "learningObjective": "Gerenciar pacotes R essenciais para modelagem de séries temporais.",
                                  "commonMistakes": [
                                    "Não recarregar library() após instalação",
                                    "Ignorar dependências como fabletools",
                                    "Versões incompatíveis"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Ajustar o modelo Auto-ARIMA com opções de busca e sazonalidade",
                                  "subSteps": [
                                    "Defina parâmetros: auto.arima(ts_data, seasonal=TRUE, stepwise=FALSE, approximation=FALSE).",
                                    "Especifique limites: max.p=5, max.q=5, max.P=2, max.Q=2, max.order=10.",
                                    "Armazene o modelo: fit <- auto.arima(ts_data, ...).",
                                    "Inspecione o modelo com summary(fit) e coeficientes.",
                                    "Verifique critérios como AICc com fit$aic."
                                  ],
                                  "verification": "Modelo ajustado retorna ARIMA(p,d,q)(P,D,Q)[s] sem warnings críticos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Objeto ts() pronto do Step 1",
                                    "Documentação de auto.arima()"
                                  ],
                                  "tips": "Use stepwise=FALSE para busca exaustiva em datasets pequenos; seasonal=TRUE para dados sazonais.",
                                  "learningObjective": "Aplicar auto.arima() com customizações para otimização automática.",
                                  "commonMistakes": [
                                    "Não ativar seasonal para dados sazonais",
                                    "Limites muito restritivos causando underfitting",
                                    "Ignorar aproximações em dados grandes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Gerar previsões, avaliar e visualizar o modelo",
                                  "subSteps": [
                                    "Gere previsões: forecast(fit, h=12) para 12 períodos à frente.",
                                    "Calcule resíduos: checkresiduals(fit) para diagnóstico.",
                                    "Plote: plot(forecast(fit, h=12)) e autoplot() com ggplot.",
                                    "Avalie com accuracy(fit) para MAE, RMSE, etc.",
                                    "Compare com baseline como meanf() para validação."
                                  ],
                                  "verification": "Previsões plotadas com intervalos de confiança e resíduos Ljung-Box não significativos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Modelo fit do Step 3",
                                    "Pacote forecast carregado"
                                  ],
                                  "tips": "Sempre verifique resíduos para autocorrelação; ajuste d=1 se necessário.",
                                  "learningObjective": "Interpretar saídas de auto.arima() e validar previsões.",
                                  "commonMistakes": [
                                    "Não plotar intervalos de confiança",
                                    "Ignorar diagnóstico de resíduos",
                                    "h muito grande sem validação"
                                  ]
                                }
                              ],
                              "practicalExample": "Carregue dados AirPassengers (passageiros aéreos mensais 1949-1960). Aplique auto.arima(AirPassengers, seasonal=TRUE, max.P=1). Preveja h=12 meses, plote e verifique AICc < 500 com resíduos brancos.",
                              "finalVerifications": [
                                "Modelo auto.arima() ajustado sem erros e com ordem ARIMA identificada corretamente.",
                                "Previsões geradas para pelo menos 12 períodos com intervalos de 95%.",
                                "Resíduos passam no teste Ljung-Box (p-value > 0.05).",
                                "Gráficos mostram ajuste visual bom à série histórica.",
                                "Accuracy() reporta RMSE inferior a baseline.",
                                "Parâmetros como stepwise e seasonal corretamente especificados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na especificação de limites de busca (max.p, etc.).",
                                "Correta interpretação de summary() e AICc.",
                                "Diagnóstico completo de resíduos e normalidade.",
                                "Uso apropriado de opções sazonais para dados reais.",
                                "Visualizações claras e interpretáveis.",
                                "Comparação com métodos alternativos."
                              ],
                              "crossCurricularConnections": [
                                "Programação em R (fundamentos de scripting e pacotes).",
                                "Estatística inferencial (testes de resíduos, critérios de informação).",
                                "Machine Learning (modelos automatizados de forecasting).",
                                "Análise de Negócios (previsão de demanda e planejamento)."
                              ],
                              "realWorldApplication": "Em empresas de varejo para prever vendas sazonais e otimizar estoque; em finanças para forecasting de ações ou PIB; em saúde para projeções de epidemias baseadas em séries temporais históricas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.3.2",
                            "name": "Implementar Auto-ARIMA em Python com pmdarima",
                            "description": "Aplicar a biblioteca pmdarima no Python para executar auto_arima(), diagnosticar resíduos e validar o modelo com testes Ljung-Box e análise de resíduos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Instalar e Configurar a Biblioteca pmdarima",
                                  "subSteps": [
                                    "Criar ou ativar um ambiente virtual Python (ex: venv ou conda).",
                                    "Instalar pmdarima via pip: pip install pmdarima.",
                                    "Instalar dependências adicionais: pip install pandas numpy matplotlib statsmodels.",
                                    "Verificar instalação importando a biblioteca em um script Jupyter ou Python.",
                                    "Testar importação básica: from pmdarima import auto_arima."
                                  ],
                                  "verification": "Execução bem-sucedida de import pmdarima sem erros de módulo não encontrado.",
                                  "estimatedTime": "20 minutes",
                                  "materials": [
                                    "Python 3.8+, pip, ambiente virtual (venv/conda)",
                                    "Jupyter Notebook ou IDE como VS Code"
                                  ],
                                  "tips": "Use um ambiente virtual para evitar conflitos de dependências entre projetos.",
                                  "learningObjective": "Configurar o ambiente Python necessário para usar pmdarima de forma isolada e eficiente.",
                                  "commonMistakes": [
                                    "Instalar em ambiente global sem virtualenv",
                                    "Esquecer de instalar statsmodels",
                                    "Ignorar warnings de depreciação durante instalação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar e Carregar Dados de Série Temporal",
                                  "subSteps": [
                                    "Baixar ou carregar um dataset de série temporal (ex: AirPassengers.csv).",
                                    "Usar pandas para ler o arquivo: pd.read_csv() e converter índice para datetime.",
                                    "Verificar stationarity inicial com plot e teste ADF (from statsmodels.tsa.stattools import adfuller).",
                                    "Tratar missing values e transformar dados se necessário (log ou diff).",
                                    "Dividir dados em train/test (ex: 80/20 split)."
                                  ],
                                  "verification": "Dados carregados como pd.Series com índice datetime e plot visual sem gaps ou anomalias.",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "Dataset de série temporal (ex: AirPassengers de datasets R ou Kaggle)",
                                    "Bibliotecas: pandas, matplotlib"
                                  ],
                                  "tips": "Sempre plote os dados crus primeiro para identificar tendências e sazonalidade.",
                                  "learningObjective": "Preparar dados de série temporal adequadamente para modelagem Auto-ARIMA.",
                                  "commonMistakes": [
                                    "Índice não convertido para datetime",
                                    "Não tratar não-estacionariedade inicial",
                                    "Usar split aleatório em vez de temporal"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar auto_arima para Ajustar o Modelo",
                                  "subSteps": [
                                    "Definir parâmetros iniciais: seasonal=True se sazonal, start_p=0, max_p=3, etc.",
                                    "Executar: model = auto_arima(train_data, seasonal=True, m=12, trace=True).",
                                    "Capturar ordem ARIMA selecionada (model.order).",
                                    "Ajustar modelo final: model.fit(train_data).",
                                    "Visualizar summary do modelo com model.summary()."
                                  ],
                                  "verification": "Modelo ajustado com ordem ARIMA reportada e AIC/ BIC calculados sem erros de convergência.",
                                  "estimatedTime": "25 minutes",
                                  "materials": [
                                    "Dados preparados do Step 2",
                                    "pmdarima, statsmodels"
                                  ],
                                  "tips": "Use trace=True para monitorar o processo de busca e entender seleções.",
                                  "learningObjective": "Aplicar auto_arima para seleção automática de parâmetros ARIMA.",
                                  "commonMistakes": [
                                    "Definir m incorreto para sazonalidade",
                                    "Ignorar erro de convergência ajustando maxiter",
                                    "Não especificar seasonal quando aplicável"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diagnosticar Resíduos e Validar o Modelo",
                                  "subSteps": [
                                    "Gerar resíduos: residuals = model.resid().",
                                    "Plotar resíduos: QQ plot, histogram e ACF para independência.",
                                    "Executar teste Ljung-Box: from statsmodels.stats.diagnostic import acorr_ljungbox; lb_test = acorr_ljungbox(residuals).",
                                    "Verificar normalidade com Jarque-Bera ou Shapiro-Wilk.",
                                    "Prever em test set e calcular métricas como MAE/RMSE."
                                  ],
                                  "verification": "Resíduos brancos (Ljung-Box p-value > 0.05) e plots mostram ausência de autocorrelação.",
                                  "estimatedTime": "40 minutes",
                                  "materials": [
                                    "Modelo ajustado do Step 3",
                                    "statsmodels.stats.diagnostic"
                                  ],
                                  "tips": "Foco em p-value do Ljung-Box para lag=10-20; valores >0.05 indicam resíduos adequados.",
                                  "learningObjective": "Diagnosticar qualidade do modelo ARIMA via análise de resíduos e testes estatísticos.",
                                  "commonMistakes": [
                                    "Interpretar p-value <0.05 como bom (é ruim!)",
                                    "Não plotar múltiplos diagnósticos",
                                    "Testar em train em vez de OOS"
                                  ]
                                }
                              ],
                              "practicalExample": "Carregue o dataset AirPassengers (passageiros aéreos mensais 1949-1960), aplique auto_arima com seasonal=True e m=12, diagnostique resíduos com plots e Ljung-Box (deve selecionar ARIMA(0,1,1)(0,1,1)[12]), valide em hold-out de 1960 e preveja próximos 12 meses.",
                              "finalVerifications": [
                                "pmdarima instalada e auto_arima executa sem erros.",
                                "Modelo seleciona ordem ARIMA apropriada com trace=True.",
                                "Plots de resíduos mostram distribuição normal e sem autocorrelação.",
                                "Teste Ljung-Box retorna p-value > 0.05 para múltiplos lags.",
                                "Previsões em test set com RMSE < 10% do erro baseline (média).",
                                "Summary do modelo interpretado corretamente (AIC baixo)."
                              ],
                              "assessmentCriteria": [
                                "Código completo e executável sem erros de sintaxe ou importação.",
                                "Seleção automática de parâmetros justificada e trace logado.",
                                "Análise de resíduos inclui plots visuais e testes estatísticos com interpretação.",
                                "Validação usa hold-out set com métricas quantitativas (MAE, RMSE).",
                                "Relatório final resume ordem ARIMA, diagnósticos e qualidade do fit.",
                                "Eficiência: tempo de execução < 5min para dataset médio."
                              ],
                              "crossCurricularConnections": [
                                "Programação em Python (manipulação de dados com pandas).",
                                "Estatística Inferencial (testes de hipóteses como Ljung-Box e ADF).",
                                "Machine Learning (modelos de previsão automatizados).",
                                "Análise de Dados Exploratória (plots e diagnósticos).",
                                "Econometria (modelagem de séries temporais financeiras)."
                              ],
                              "realWorldApplication": "Previsão de demanda em varejo (ex: vendas sazonais Walmart), modelagem de séries financeiras (preços de ações ou cripto), planejamento de recursos em supply chain, ou monitoramento de indicadores econômicos como PIB ou inflação para políticas públicas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.3.3",
                            "name": "Interpretar e validar resultados do Auto-ARIMA",
                            "description": "Analisar saídas como ordem selecionada (p,d,q), coeficientes, resíduos e métricas de precisão (MAE, RMSE), além de verificar pressupostos como normalidade e ausência de autocorrelação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Examinar a ordem ARIMA selecionada e o resumo do modelo",
                                  "subSteps": [
                                    "Execute o Auto-ARIMA no conjunto de dados de treinamento usando pmdarima.auto_arima().",
                                    "Identifique os parâmetros selecionados: p (ordem AR), d (diferenciação), q (ordem MA).",
                                    "Revise o summary do modelo com model.summary() para AIC, BIC e log-likelihood.",
                                    "Compare com critérios de informação para avaliar adequação inicial.",
                                    "Anote a equação do modelo ARIMA(p,d,q)."
                                  ],
                                  "verification": "Confirme que o summary mostra parâmetros claros e valores de AIC/BIC finitos; gere um print do summary.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Python com pmdarima, statsmodels instalados",
                                    "Jupyter Notebook",
                                    "Dataset de séries temporais (ex: airpassengers)"
                                  ],
                                  "tips": "Comece com dados estacionários; use stepwise=False para iterações mais rápidas em testes iniciais.",
                                  "learningObjective": "Compreender como Auto-ARIMA seleciona a melhor ordem (p,d,q) baseada em critérios de informação.",
                                  "commonMistakes": [
                                    "Ignorar warnings de convergência",
                                    "Confundir p com q sem ler o summary",
                                    "Não plotar a série original vs. ajustada"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Interpretar coeficientes e significância estatística",
                                  "subSteps": [
                                    "Extraia os coeficientes do modelo com model.params().",
                                    "Analise os valores de p-value para cada coeficiente (AR, MA, intercepto).",
                                    "Verifique intervalos de confiança (95%) para significância.",
                                    "Identifique termos redundantes ou insignificantes (p-value > 0.05).",
                                    "Calcule coeficientes padronizados se necessário para comparação de magnitude."
                                  ],
                                  "verification": "Liste coeficientes com p-values < 0.05; explique por que um termo é significativo.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Mesmo ambiente Python",
                                    "Funções de statsmodels para coeficientes"
                                  ],
                                  "tips": "Use model.summary().tables[1] para tabela de coeficientes formatada.",
                                  "learningObjective": "Avaliar a significância estatística dos parâmetros do modelo ARIMA.",
                                  "commonMistakes": [
                                    "Interpretar coeficientes sem contexto de escala da série",
                                    "Ignorar multicolinearidade em termos AR/MA",
                                    "Confundir significância com importância prática"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Validar resíduos: normalidade e autocorrelação",
                                  "subSteps": [
                                    "Gere resíduos com residuals = model.resid().",
                                    "Teste normalidade com Shapiro-Wilk (statsmodels.stats.diagnostic.normaltest).",
                                    "Verifique autocorrelação com Ljung-Box test (pmdarima.stats.acorr_ljungbox).",
                                    "Plote ACF/PACF dos resíduos e QQ-plot para inspeção visual.",
                                    "Confirme homocedasticidade plotando resíduos vs. fitted values."
                                  ],
                                  "verification": "Ljung-Box p-value > 0.05 (sem autocorrelação) e Shapiro-Wilk p-value > 0.05 (normalidade); inclua plots.",
                                  "estimatedTime": "30-40 minutos",
                                  "materials": [
                                    "Bibliotecas: scipy.stats, matplotlib, seaborn"
                                  ],
                                  "tips": "Resíduos brancos ideais: média zero, variância constante, sem padrões.",
                                  "learningObjective": "Diagnosticar violações de pressupostos nos resíduos do modelo ARIMA.",
                                  "commonMistakes": [
                                    "Usar resíduos raw em vez de padronizados",
                                    "Interpretar p-values isolados sem plots",
                                    "Ignorar outliers nos resíduos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar métricas de precisão e validar o modelo overall",
                                  "subSteps": [
                                    "Calcule previsões out-of-sample com model.predict(n_periods).",
                                    "Compute métricas: MAE, RMSE, MAPE usando sklearn.metrics.mean_absolute_error etc.",
                                    "Compare com baseline (ex: média ingênua).",
                                    "Realize validação cruzada temporal com RollingForecastCV.",
                                    "Documente conclusões: modelo adequado? Sugira refit ou alternativas."
                                  ],
                                  "verification": "MAE/RMSE < baseline; relatório escrito com métricas e plots de previsão vs. real.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "sklearn.metrics",
                                    "Dataset de teste separado"
                                  ],
                                  "tips": "Divida dados 80/20 treino/teste; foque em erro em hold-out set.",
                                  "learningObjective": "Quantificar precisão preditiva e decidir sobre deployment do modelo.",
                                  "commonMistakes": [
                                    "Treinar e testar no mesmo set (overfitting)",
                                    "Ignorar escala nas métricas",
                                    "Não comparar com baselines simples"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dataset de passageiros aéreos (airpassengers), aplique auto_arima: seleciona ARIMA(2,1,1), coeficientes AR(1)=0.76 (p<0.01), resíduos passam Ljung-Box (p=0.45), RMSE=15.2 em teste, validando para previsão de demanda aérea.",
                              "finalVerifications": [
                                "Explicar verbalmente o significado de p,d,q no modelo selecionado.",
                                "Identificar e corrigir autocorrelação nos resíduos via plots e testes.",
                                "Calcular e interpretar MAE/RMSE comparando com baseline.",
                                "Listar 3 pressupostos ARIMA e como validá-los.",
                                "Gerar relatório de 1 página resumindo forças/fraquezas do modelo.",
                                "Prever próximos 12 meses e plotar com intervalo de confiança."
                              ],
                              "assessmentCriteria": [
                                "Precisão na interpretação de ordem (p,d,q) e critérios AIC/BIC (30%)",
                                "Correta análise de significância de coeficientes e resíduos (25%)",
                                "Validação rigorosa de pressupostos com testes estatísticos e visuals (20%)",
                                "Cálculo e comparação de métricas de precisão out-of-sample (15%)",
                                "Relatório claro com conclusões acionáveis (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Estatística Inferencial: Testes de hipóteses (p-values, Ljung-Box)",
                                "Programação em Python: Manipulação de dados com pandas/statsmodels",
                                "Machine Learning: Validação cruzada e métricas de regressão",
                                "Análise Exploratória de Dados: Plots ACF/PACF e diagnósticos",
                                "Gestão de Projetos: Documentação de modelos para stakeholders"
                              ],
                              "realWorldApplication": "Em finanças para prever retornos de ações e otimizar portfólios; em varejo para forecasting de vendas sazonais e gerenciamento de estoque; em saúde pública para modelar surtos epidêmicos e alocação de recursos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.3.4",
                            "name": "Aplicar Auto-ARIMA em cenários reais",
                            "description": "Demonstrar uso em finanças (previsão de retornos), marketing (vendas sazonais) e operações (demanda), comparando com métodos manuais conforme bibliografia de Enders e Ehlers.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e preparar datasets reais para os cenários",
                                  "subSteps": [
                                    "Identificar fontes de dados reais: Yahoo Finance para retornos financeiros, Kaggle para vendas sazonais e demanda operacional.",
                                    "Coletar e carregar dados usando pandas: baixar séries temporais com yfinance ou pd.read_csv.",
                                    "Realizar pré-processamento: tratar missing values, diferenciar para estacionariedade (ADF test), decompor sazonalidade com STL.",
                                    "Dividir dados em treino/teste (80/20) e visualizar com plots (ACF/PACF).",
                                    "Documentar características dos dados (frequência, sazonalidade)."
                                  ],
                                  "verification": "Datasets preparados estão estacionários (p-value ADF < 0.05) e visualizações confirmam ausência de tendências/sazonalidade residual.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Python (pandas, numpy, matplotlib, statsmodels), yfinance, datasets de Kaggle/Yahoo Finance"
                                  ],
                                  "tips": "Sempre teste estacionariedade antes; use log-transform para volatilidade em finanças.",
                                  "learningObjective": "Preparar séries temporais reais para modelagem Auto-ARIMA.",
                                  "commonMistakes": [
                                    "Ignorar sazonalidade, não tratar outliers, divisão inadequada treino/teste"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Auto-ARIMA para previsão financeira (retornos de ações)",
                                  "subSteps": [
                                    "Instalar e importar pmdarima: from pmdarima.arima import auto_arima.",
                                    "Ajustar modelo: auto_arima(y_treino, seasonal=True, stepwise=True, trace=True).",
                                    "Gerar previsões: model.predict(n_periodos) e calcular métricas (MAE, RMSE).",
                                    "Plotar fit e previsões vs. reais.",
                                    "Ajustar hiperparâmetros se necessário (m=12 para mensal)."
                                  ],
                                  "verification": "Modelo ajustado com AIC baixo e resíduos brancos (Ljung-Box test p>0.05).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "pmdarima library, Jupyter Notebook, dados de ações (ex: PETR4.SA)"
                                  ],
                                  "tips": "Use start_p=0, max_p=5 para eficiência; monitore trace para ordem selecionada.",
                                  "learningObjective": "Aplicar Auto-ARIMA em séries financeiras voláteis.",
                                  "commonMistakes": [
                                    "Não especificar seasonal=True, ignorar warnings de convergência, overfit com max_order alto"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Auto-ARIMA em marketing (vendas sazonais) e operações (demanda)",
                                  "subSteps": [
                                    "Preparar dados sazonais: vendas retail (Kaggle) e demanda estoque.",
                                    "Ajustar Auto-ARIMA para cada: auto_arima com seasonal=True, m=frequência (12 mensal).",
                                    "Prever horizons variados (1-12 passos) e avaliar com MAPE/RMSE.",
                                    "Comparar plots de resíduos e forecasts entre cenários.",
                                    "Salvar modelos com joblib para reutilização."
                                  ],
                                  "verification": "Previsões com erro <10% em hold-out set para ambos cenários.",
                                  "estimatedTime": "1-1.5 horas",
                                  "materials": [
                                    "Datasets Kaggle (Rossmann Sales, Walmart Demand), pmdarima, scikit-learn metrics"
                                  ],
                                  "tips": "Para sazonal forte, force m=12/52; valide com CV temporal.",
                                  "learningObjective": "Adaptar Auto-ARIMA a padrões sazonais em negócios.",
                                  "commonMistakes": [
                                    "m incorreto, não validar sazonalidade, forecasts muito longos sem validação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar com métodos manuais e interpretar resultados conforme Enders/Ehlers",
                                  "subSteps": [
                                    "Implementar ARIMA manual: selecionar p,d,q via ACF/PACF ou grid search.",
                                    "Comparar métricas: AIC, BIC, RMSE entre Auto-ARIMA e manual.",
                                    "Analisar resíduos: teste Ljung-Box, Q-Q plot para normalidade.",
                                    "Referenciar Enders (cap.5) para validação e Ehlers para finanças sazonais.",
                                    "Documentar insights: superioridade do Auto em tempo/precisão."
                                  ],
                                  "verification": "Tabela comparativa mostra Auto-ARIMA com RMSE <= manual em todos cenários.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livros: Enders 'Applied Econometric Time Series', Ehlers refs; statsmodels para manual"
                                  ],
                                  "tips": "Use suppress_warnings=True em auto_arima; foque em out-of-sample.",
                                  "learningObjective": "Avaliar Auto-ARIMA vs. tradicional per literatura.",
                                  "commonMistakes": [
                                    "Comparação in-sample only, ignorar custos computacionais, não citar bibliografia"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dados históricos de ações da Petrobras (PETR4.SA via yfinance, 2015-2023), prever retornos semanais; para marketing, dataset Rossmann Stores (Kaggle) prever vendas sazonais; para operações, Walmart Demand prever estoque mensal. Comparar Auto-ARIMA SARIMA(2,1,1)(1,1,1)[12] vs. manual ARIMA(1,1,1).",
                              "finalVerifications": [
                                "Auto-ARIMA selecionou ordens coerentes (p,d,q razoáveis) em todos cenários.",
                                "Resíduos são brancos e estacionários (tests passados).",
                                "Previsões out-of-sample com RMSE < baseline naive.",
                                "Comparação tabular com manual mostra ganhos em precisão/tempo.",
                                "Relatório inclui plots, métricas e referências bibliográficas.",
                                "Modelos salvos e reproduzíveis."
                              ],
                              "assessmentCriteria": [
                                "Precisão das previsões (MAPE <15% em test set).",
                                "Eficiência computacional (tempo <5min por modelo).",
                                "Validação estatística rigorosa (ADF, Ljung-Box).",
                                "Comparação quantitativa/qualitativa com manual.",
                                "Interpretação contextualizada aos cenários reais.",
                                "Código limpo, documentado e versionado."
                              ],
                              "crossCurricularConnections": [
                                "Finanças: Modelagem econométrica de ativos (Enders).",
                                "Marketing: Previsão de demanda sazonal.",
                                "Operações: Gestão de cadeia de suprimentos.",
                                "Econometria: Séries temporais avançadas (Ehlers).",
                                "Machine Learning: Automatização de hyperparameter tuning."
                              ],
                              "realWorldApplication": "Empresas usam Auto-ARIMA para forecasting automatizado em trading algorítmico (hedge funds), planejamento de vendas (retail como Amazon) e otimização de estoque (manufatura), reduzindo tempo de modelagem de dias para minutos e melhorando acurácia em 10-20% vs. manual."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.2",
                    "name": "Modelos ETS Automatizados",
                    "description": "Abordagens para seleção e ajuste automático de modelos de suavização exponencial com tendência e sazonalidade.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.2.1",
                        "name": "Componentes dos Modelos ETS",
                        "description": "Os modelos ETS (Error, Trend, Seasonality) são baseados em suavização exponencial e consideram três componentes principais: tipo de erro (aditivo ou multiplicativo), tendência (nenhuma, aditiva, multiplicativa ou amortecida) e sazonalidade (nenhuma, aditiva ou multiplicativa).",
                        "specificSkills": [
                          {
                            "id": "10.1.7.2.1.1",
                            "name": "Identificar tipos de erro em modelos ETS",
                            "description": "Diferenciar entre erro aditivo (adequado para séries com variância constante) e multiplicativo (para variância crescente), reconhecendo quando cada um é apropriado com base na análise exploratória da série temporal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Erro Aditivo e Multiplicativo",
                                  "subSteps": [
                                    "Defina erro aditivo: resíduo com variância constante ao longo do tempo, independente do nível da série.",
                                    "Defina erro multiplicativo: resíduo com variância proporcional ao nível da série, aumentando com valores maiores.",
                                    "Compare as equações: aditivo ε_t ~ N(0,σ²), multiplicativo ε_t ~ N(0,σ² * μ_t).",
                                    "Identifique cenários iniciais: aditivo para séries estáveis, multiplicativo para séries com heteroscedasticidade.",
                                    "Revise a estrutura ETS: Error, Trend, Seasonal."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre os dois tipos de erro com exemplos simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação ETS (ex: forecast package no R ou statsmodels no Python)",
                                    "Notas ou whiteboard para diagramas"
                                  ],
                                  "tips": "Use analogias: aditivo como ruído fixo em uma estrada reta; multiplicativo como eco em montanhas crescentes.",
                                  "learningObjective": "Diferenciar conceitualmente erro aditivo de multiplicativo e suas implicações na modelagem ETS.",
                                  "commonMistakes": [
                                    "Confundir variância com tendência",
                                    "Ignorar o impacto na previsão de intervalos de confiança"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar Análise Exploratória Visual da Variância",
                                  "subSteps": [
                                    "Plote a série temporal original e resíduos padronizados.",
                                    "Examine o gráfico de resíduos vs valores ajustados: procure por funil (multiplicativo) ou banda constante (aditivo).",
                                    "Crie plot de variância acumulada ou teste de Breusch-Pagan para heteroscedasticidade.",
                                    "Analise log-transformada: se variância se estabiliza, sugere multiplicativo.",
                                    "Documente observações qualitativas e quantitativas."
                                  ],
                                  "verification": "Gere plots e anote se a variância é constante ou crescente, justificando com evidências visuais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software: R (ggplot2, forecast) ou Python (matplotlib, statsmodels)",
                                    "Dataset de exemplo (ex: AirPassengers)"
                                  ],
                                  "tips": "Aumente a escala do eixo Y para detectar padrões sutis de variância.",
                                  "learningObjective": "Identificar padrões de variância na série temporal através de visualizações exploratórias.",
                                  "commonMistakes": [
                                    "Sobrepor plots sem padronizar resíduos",
                                    "Ignorar transformações logarítmicas iniciais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Identificação em Datasets de Exemplo",
                                  "subSteps": [
                                    "Carregue dataset com variância constante (ex: série sintética aditiva).",
                                    "Ajuste modelo ETS com erro aditivo e verifique resíduos.",
                                    "Repita com dataset de variância crescente (ex: vendas sazonais).",
                                    "Compare AIC/BIC e plots de resíduos para ambos os erros.",
                                    "Selecione o tipo apropriado baseado em diagnósticos."
                                  ],
                                  "verification": "Ajuste dois modelos ETS alternativos e demonstre qual tem resíduos melhores via Ljung-Box test.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Datasets: AirPassengers (multiplicativo), série estável sintética",
                                    "Código pronto em R/Python"
                                  ],
                                  "tips": "Sempre valide com teste de normalidade e autocorrelação pós-ajuste.",
                                  "learningObjective": "Aplicar análise exploratória para escolher o tipo de erro em dados reais.",
                                  "commonMistakes": [
                                    "Escolher baseado só em visual, sem métricas quantitativas",
                                    "Não considerar sazonalidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Decisão e Validação Final",
                                  "subSteps": [
                                    "Em um novo dataset desconhecido, realize passos 1-3.",
                                    "Justifique escolha de erro com relatório curto (plots + testes).",
                                    "Simule previsões e compare intervalos de confiança.",
                                    "Revise com modelo alternativo para confirmar.",
                                    "Registre lições aprendidas em um journal."
                                  ],
                                  "verification": "Produza um relatório de 1 página identificando o tipo de erro e justificando com evidências.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Novo dataset aleatório",
                                    "Template de relatório"
                                  ],
                                  "tips": "Use auto.arima() ou ETS() com allowmulti=FALSE para testes rápidos.",
                                  "learningObjective": "Tomar decisões informadas sobre tipo de erro com base em análise completa.",
                                  "commonMistakes": [
                                    "Forçar aditivo por simplicidade",
                                    "Não testar múltiplos cenários"
                                  ]
                                }
                              ],
                              "practicalExample": "Ao prever passageiros aéreos mensais (AirPassengers dataset), observe variância crescente nos resíduos vs fitted values (formato de funil). Escolha erro multiplicativo, ajuste ETS(M,A,M) e confirme com resíduos estáveis pós-log.",
                              "finalVerifications": [
                                "Explicar diferença entre erro aditivo e multiplicativo sem hesitação.",
                                "Identificar corretamente tipo de erro em 3 datasets de teste variados.",
                                "Gerar plots diagnósticos mostrando padrões de variância.",
                                "Justificar escolha com pelo menos 2 métricas (ex: AIC, teste de resíduos).",
                                "Aplicar em dataset novo com acurácia >90%.",
                                "Discutir impacto na previsão de intervalos de confiança."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas e distinção clara (30%).",
                                "Qualidade da análise exploratória: plots e testes apropriados (25%).",
                                "Decisão justificada: evidências quantitativas/qualitativas (20%).",
                                "Aplicação prática: modelos ajustados sem erros (15%).",
                                "Relatório claro e conciso (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelos estocásticos e heteroscedasticidade em regressão.",
                                "Programação: Manipulação de dados e visualização em R/Python.",
                                "Economia: Previsão de séries financeiras com variância volátil.",
                                "Ciência de Dados: Diagnóstico de modelos de ML em séries temporais."
                              ],
                              "realWorldApplication": "Em finanças, escolher erro multiplicativo para modelar retornos de ações com volatilidade crescente, melhorando previsões de risco e alocação de portfólio em bancos ou fundos de investimento."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.1.2",
                            "name": "Classificar tipos de tendência em ETS",
                            "description": "Reconhecer e descrever os tipos de tendência: nenhuma (N), aditiva (A), multiplicativa (M) ou amortecida (Ad), avaliando sua adequação para séries com crescimento linear, exponencial ou estabilizado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Tendências em Séries Temporais ETS",
                                  "subSteps": [
                                    "Estude a definição de tendência em séries temporais como a direção geral dos dados ao longo do tempo.",
                                    "Revise os componentes do modelo ETS: Erro, Tendência e Sazonalidade.",
                                    "Identifique quando a tendência é relevante: crescimento linear (aditiva), exponencial (multiplicativa), estabilizado (amortecida) ou ausente (nenhuma).",
                                    "Analise gráficos de séries temporais para visualizar padrões de tendência.",
                                    "Compare séries com e sem tendência para diferenciar."
                                  ],
                                  "verification": "Crie um diagrama resumindo os 4 tipos de tendência e explique verbalmente ou por escrito.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Gráficos de exemplo de séries temporais (vendas mensais, temperatura)",
                                    "Documentação ETS do R ou Python (função ets() no forecast package)"
                                  ],
                                  "tips": "Use logaritmo para transformar séries multiplicativas em aditivas para visualização.",
                                  "learningObjective": "Dominar os fundamentos teóricos dos tipos de tendência em ETS.",
                                  "commonMistakes": [
                                    "Confundir tendência com sazonalidade",
                                    "Ignorar a escala dos dados (linear vs log)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Caracterizar Cada Tipo de Tendência: N, A, M e Ad",
                                  "subSteps": [
                                    "Descreva 'Nenhuma (N)': Série estabilizada sem direção clara, flutuações aleatórias.",
                                    "Detalhe 'Aditiva (A)': Crescimento linear constante, diferenças de primeira ordem constantes.",
                                    "Explique 'Multiplicativa (M)': Crescimento exponencial, variância crescente com o nível.",
                                    "Defina 'Amortecida (Ad)': Tendência que enfraquece ao longo do tempo, aproximando-se de constante.",
                                    "Crie uma tabela comparativa com fórmulas e exemplos gráficos para cada."
                                  ],
                                  "verification": "Preencha uma tabela com definições, fórmulas e um exemplo gráfico para cada tipo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Tabela modelo em Excel ou Google Sheets",
                                    "Tutoriais ETS (Hyndman book ou forecast.io)"
                                  ],
                                  "tips": "Lembre-se: A e M afetam o nível; Ad adiciona damping factor α < 1.",
                                  "learningObjective": "Diferenciar precisamente as características matemáticas e visuais de cada tipo.",
                                  "commonMistakes": [
                                    "Confundir A com M em séries de longo prazo",
                                    "Aplicar Ad a séries puramente lineares"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Praticar Identificação e Classificação de Tendências",
                                  "subSteps": [
                                    "Colete 5 séries temporais de exemplo (ex: AirPassengers para M, vendas lineares para A).",
                                    "Plote os dados e compute diferenças de primeira e segunda ordem.",
                                    "Aplique teste visual e ACF/PACF para detectar tipo de tendência.",
                                    "Use software para fit inicial ETS e observe o componente de tendência selecionado.",
                                    "Classifique cada série justificando com evidências (gráficos, stats)."
                                  ],
                                  "verification": "Classifique corretamente 4/5 séries fornecidas, com relatório de 1 parágrafo por série.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Datasets: AirPassengers (R/Python)",
                                    "Software: R (forecast package) ou Python (statsmodels)"
                                  ],
                                  "tips": "Transforme em log se variância aumenta; teste estacionariedade com KPSS.",
                                  "learningObjective": "Aplicar métodos práticos para classificar tendências em dados reais.",
                                  "commonMistakes": [
                                    "Sobreajustar sem validação cruzada",
                                    "Ignorar decomposição inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Adequação de Tendências para Diferentes Padrões de Séries",
                                  "subSteps": [
                                    "Para crescimento linear: Prefira A ou Ad.",
                                    "Para exponencial: Escolha M ou Ad com damping.",
                                    "Para estabilizado: Use N ou Ad.",
                                    "Simule cenários e compare AICc de modelos ETS com diferentes tendências.",
                                    "Documente quando cada tipo é inadequado (ex: M em linear causa overfitting)."
                                  ],
                                  "verification": "Avalie adequação em 3 cenários simulados, selecionando o melhor modelo ETS.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Simulador ETS em R (simulate.ets())",
                                    "Critérios: AICc, RMSE out-of-sample"
                                  ],
                                  "tips": "Sempre valide com hold-out set para evitar bias.",
                                  "learningObjective": "Julgar a melhor tendência baseada em performance preditiva.",
                                  "commonMistakes": [
                                    "Escolher complexidade desnecessária",
                                    "Não considerar damping em tendências fortes"
                                  ]
                                }
                              ],
                              "practicalExample": "Em dados de passageiros aéreos (AirPassengers dataset), a variância aumenta com o tempo e o crescimento é exponencial: classifique como M. Plote, aplique log-transform e confirme com ETS(M,A,M) fit.",
                              "finalVerifications": [
                                "Classifica corretamente tendências em 8/10 séries de teste variadas.",
                                "Justifica escolhas com gráficos e métricas (AICc < threshold).",
                                "Distingue A vs M em 90% dos casos via análise de variância.",
                                "Identifica Ad em séries com plateau final.",
                                "Gera relatório com decomposição ETS para validação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na classificação (>85% acurácia em testes).",
                                "Qualidade da justificativa (evidências visuais/estatísticas).",
                                "Compreensão conceitual (explica fórmulas de tendência).",
                                "Eficiência na seleção (modelo parsimonioso com bom fit).",
                                "Aplicação prática (código reproduzível em R/Python)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelos exponenciais e log-transformações.",
                                "Economia: Previsão de demanda e ciclos econômicos.",
                                "Computação: Programação em R/Python para análise de dados.",
                                "Negócios: Planejamento de estoque baseado em tendências."
                              ],
                              "realWorldApplication": "Em empresas de varejo, classificar tendência multiplicativa em vendas de produtos sazonais permite previsões precisas de estoque, evitando overstock em crescimento exponencial ou faltas em estabilização amortecida."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.1.3",
                            "name": "Determinar tipos de sazonalidade em ETS",
                            "description": "Identificar sazonalidade nenhuma (N), aditiva (A) ou multiplicativa (M), analisando padrões repetitivos em séries temporais sazonais e sua interação com tendência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Sazonalidade em Modelos ETS",
                                  "subSteps": [
                                    "Defina sazonalidade como padrões repetitivos em intervalos fixos (ex: mensal, anual).",
                                    "Explique os tipos: Nenhuma (N) - sem padrão sazonal; Aditiva (A) - variação constante; Multiplicativa (M) - variação proporcional à tendência.",
                                    "Revise interação com tendência: em A, sazonalidade é somada; em M, multiplicada.",
                                    "Estude fórmulas: Y_t = Trend + Seasonal (A) vs Y_t = Trend * Seasonal (M).",
                                    "Compare com exemplos gráficos de séries com cada tipo."
                                  ],
                                  "verification": "Resuma em um parágrafo os três tipos e forneça um exemplo para cada.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação ETS do statsmodels (Python)",
                                    "Gráficos de exemplo de séries temporais sazonais"
                                  ],
                                  "tips": "Use diagramas Venn para visualizar diferenças entre A e M.",
                                  "learningObjective": "Diferenciar conceitualmente os tipos de sazonalidade N, A e M em ETS.",
                                  "commonMistakes": [
                                    "Confundir sazonalidade com ciclicidade",
                                    "Ignorar amplitude crescente como sinal de M"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar e Visualizar a Série Temporal para Detecção de Sazonalidade",
                                  "subSteps": [
                                    "Carregue dados de série temporal (ex: Pandas no Python).",
                                    "Plote a série bruta para observar padrões repetitivos.",
                                    "Crie gráficos de autocorrelação (ACF) para lags sazonais (ex: lag 12 para mensal).",
                                    "Aplique decomposição STL ou clássica para separar componentes.",
                                    "Identifique picos/troughs consistentes em lags sazonais."
                                  ],
                                  "verification": "Gere plots e anote evidências visuais de padrões repetitivos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python: pandas, matplotlib, statsmodels",
                                    "Dataset exemplo: AirPassengers ou vendas sazonais"
                                  ],
                                  "tips": "Ajuste frequência da série com pd.to_seasonal para análise precisa.",
                                  "learningObjective": "Visualmente detectar presença de sazonalidade na série.",
                                  "commonMistakes": [
                                    "Não stationarizar antes da visualização",
                                    "Escolha errada de lag sazonal"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Amplitude da Sazonalidade para Classificar A vs M",
                                  "subSteps": [
                                    "Examine resíduos sazonais da decomposição: constantes → A; proporcionais → M.",
                                    "Plote componente sazonal vs tendência: variação estável → A; crescente → M.",
                                    "Calcule razão sazonal (max/min por período): > constante → M.",
                                    "Aplique teste de Canova-Hansen ou similar para tipo não-linear.",
                                    "Compare log(Y) vs Y: se sazonalidade lineariza no log → M."
                                  ],
                                  "verification": "Classifique um conjunto de dados como A ou M com justificativa quantitativa.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python: statsmodels.tsa.seasonal.STL",
                                    "R: forecast package para auto.arima ETS"
                                  ],
                                  "tips": "Use boxplots por estação para comparar amplitudes.",
                                  "learningObjective": "Distinguir aditiva de multiplicativa baseado em amplitude relativa.",
                                  "commonMistakes": [
                                    "Assumir A por default sem checar proporção",
                                    "Confundir tendência com sazonalidade crescente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Confirmar Ausência de Sazonalidade e Validar Classificação",
                                  "subSteps": [
                                    "Teste estatístico: Ljung-Box em resíduos após remoção sazonal para N.",
                                    "Execute modelo ETS automático (ex: statsmodels ETS) e verifique seleção de sazonal.",
                                    "Compare AIC/BIC de modelos N vs A vs M.",
                                    "Valide com hold-out: previsão sazonal deve capturar padrões corretos.",
                                    "Documente classificação final: N, A ou M com evidências."
                                  ],
                                  "verification": "Produza relatório com testes e plots confirmando a classificação.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python: statsmodels.tsa.exponential_smoothing.ets",
                                    "Datasets de teste variados"
                                  ],
                                  "tips": "Sempre teste múltiplos períodos sazonais se incerto.",
                                  "learningObjective": "Validar robustamente a classificação de sazonalidade em ETS.",
                                  "commonMistakes": [
                                    "Ignorar overfitting em testes",
                                    "Não validar com dados out-of-sample"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um dataset de vendas mensais de varejo (2015-2023), plote a série mostrando picos em dezembro (Natal). Decomponha: amplitude sazonal cresce com tendência → classifique como M. Confirme com ETS(M,A,M) tendo menor AIC.",
                              "finalVerifications": [
                                "Classifique corretamente 3 séries de teste como N, A ou M com >90% acurácia.",
                                "Explique decomposição gráfica para um colega.",
                                "Ajuste modelo ETS e compare previsões A vs M.",
                                "Identifique erros comuns em uma série ambígua.",
                                "Documente processo em relatório de 1 página."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção visual e estatística de sazonalidade (30%)",
                                "Correta distinção A vs M baseada em evidências quantitativas (25%)",
                                "Uso adequado de ferramentas e testes (20%)",
                                "Clareza na documentação e justificativas (15%)",
                                "Aplicação em exemplo prático com validação (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Economia: Previsão de demanda sazonal em mercados.",
                                "Negócios: Otimização de estoque para picos sazonais.",
                                "Programação: Implementação de algoritmos de forecasting em Python/R.",
                                "Matemática: Modelos aditivos vs multiplicativos em funções."
                              ],
                              "realWorldApplication": "Em empresas de e-commerce como Amazon, determinar sazonalidade multiplicativa em vendas permite modelos ETS precisos para Black Friday, otimizando estoque e reduzindo custos em milhões."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.2.2",
                        "name": "Seleção Automática de Modelos ETS",
                        "description": "Abordagens automatizadas para escolher a melhor combinação de componentes ETS, utilizando critérios como AICc e algoritmos de busca stepwise ou exaustiva.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.2.2.1",
                            "name": "Compreender critérios de seleção como AICc",
                            "description": "Explicar o uso do Critério de Informação de Akaike corrigido (AICc) para penalizar modelos complexos e selecionar o ETS ótimo entre as 30 combinações possíveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os fundamentos do Critério de Informação de Akaike (AIC)",
                                  "subSteps": [
                                    "Revise a fórmula básica do AIC: AIC = -2 * log(L) + 2 * k, onde L é a verossimilhança e k o número de parâmetros.",
                                    "Explique o trade-off: boa adequação (log(L)) vs. penalidade por complexidade (2*k).",
                                    "Discuta limitações do AIC em amostras pequenas (n < 40), onde subestima a penalidade.",
                                    "Compare com BIC e outros critérios para contextualizar.",
                                    "Identifique quando usar AIC em seleção de modelos."
                                  ],
                                  "verification": "Calcule manualmente o AIC para um modelo simples com dados fornecidos e interprete o resultado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Notebook com fórmulas de AIC, dataset de exemplo (ex: série temporal de AirPassengers em R), calculadora ou Python/R.",
                                  "tips": "Sempre normalize log(L) para comparações relativas entre modelos.",
                                  "learningObjective": "Compreender o propósito e fórmula básica do AIC como base para AICc.",
                                  "commonMistakes": "Confundir AIC com medidas de erro absoluto como RMSE; ignorar que AIC é relativo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender a fórmula e interpretação do AICc corrigido",
                                  "subSteps": [
                                    "Estude a fórmula AICc = AIC + (2*k*(k+1))/(n - k - 1), onde n é o tamanho da amostra.",
                                    "Explique a correção: termo extra penaliza mais modelos complexos em amostras pequenas.",
                                    "Calcule AICc para dois modelos hipotéticos com n=30, k=2 e k=5.",
                                    "Interprete valores: menor AICc indica melhor modelo balanceado.",
                                    "Visualize graficamente o impacto da correção em diferentes tamanhos de n."
                                  ],
                                  "verification": "Derivar e calcular AICc para um modelo dado, mostrando a diferença com AIC.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Planilha Excel ou Jupyter Notebook com funções para AIC/AICc, exemplos numéricos.",
                                  "tips": "Use funções prontas em R (AICcmodavg) ou Python (statsmodels) para validar cálculos manuais.",
                                  "learningObjective": "Dominar a fórmula AICc e sua vantagem sobre AIC em séries temporais curtas.",
                                  "commonMistakes": "Esquecer o denominador (n - k - 1) levando a divisão por zero; aplicar AICc em amostras grandes onde AIC basta."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar AICc na seleção de modelos ETS automatizados",
                                  "subSteps": [
                                    "Revise os 30 modelos ETS: combinações de erro (A/M), tendência (N/A/M/Ad), sazonalidade (N/A/M).",
                                    "Explique como ETSauto() em R usa AICc para selecionar o melhor entre os 30 fits.",
                                    "Execute um fit ETS em dados reais e extraia AICc para top 3 modelos.",
                                    "Analise por que um modelo complexo pode ter AICc pior que simples.",
                                    "Compare AICc com outros critérios como AIC ou BIC no contexto ETS."
                                  ],
                                  "verification": "Ajuste ETS a uma série temporal e identifique o modelo ótimo pelo menor AICc, justificando a escolha.",
                                  "estimatedTime": "1 hora 30 minutos",
                                  "materials": "R com pacote forecast, dataset série temporal (ex: vendas mensais), script de exemplo.",
                                  "tips": "Sempre cheque resíduos para validar o modelo selecionado por AICc.",
                                  "learningObjective": "Aplicar AICc para selecionar o ETS ótimo entre 30 combinações.",
                                  "commonMistakes": "Ignorar pressupostos de estacionariedade; selecionar só pelo menor AICc sem contexto de negócio."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar e interpretar resultados de seleção com AICc",
                                  "subSteps": [
                                    "Gere previsões com o modelo ETS selecionado e compare AICc de alternativas.",
                                    "Crie uma tabela comparativa de AICc para 5 modelos ETS em um dataset.",
                                    "Discuta cenários onde AICc falha (ex: não estacionariedade).",
                                    "Implemente função customizada para calcular delta-AICc (AICc - min(AICc)).",
                                    "Avalie trade-offs: simplicidade vs. precisão em previsão."
                                  ],
                                  "verification": "Produza relatório com tabela de AICc, modelo selecionado e razões para 2 datasets diferentes.",
                                  "estimatedTime": "1 hora",
                                  "materials": "R/Python scripts, datasets múltiplos (ex: UKgas, sunspots), visualizações com ggplot.",
                                  "tips": "Delta-AICc < 2 indica modelos equivalentes; priorize o mais simples.",
                                  "learningObjective": "Interpretar e usar AICc para decisões robustas em modelagem ETS.",
                                  "commonMistakes": "Overfitting ao modelo com menor AICc sem validação out-of-sample."
                                }
                              ],
                              "practicalExample": "Usando dados mensais de passageiros aéreos (AirPassengers no R), ajuste os 30 modelos ETS com forecast::ets(). O modelo ETS(M,A,M) é selecionado com AICc=533.2, menor que ETS(A,N,N) com AICc=545.1, penalizando adequadamente a complexidade sazonal em n=144 observações.",
                              "finalVerifications": [
                                "Calcular corretamente AICc manualmente para um modelo dado.",
                                "Explicar verbalmente o papel da penalidade em AICc para modelos ETS complexos.",
                                "Identificar o modelo ETS ótimo em um output de software usando AICc.",
                                "Comparar AICc entre dois modelos e justificar a escolha.",
                                "Reconhecer quando AICc é preferível ao AIC (amostras pequenas).",
                                "Aplicar delta-AICc para ranquear modelos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação e cálculo da fórmula AICc (90% correto).",
                                "Compreensão clara do trade-off adequação-complexidade em explicações.",
                                "Aplicação correta em software para seleção ETS (modelo ótimo matches referência).",
                                "Interpretação qualitativa e quantitativa de resultados AICc.",
                                "Identificação de limitações e erros comuns em cenários reais.",
                                "Relatório estruturado com tabelas e justificativas lógicas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estatística inferencial e verossimilhança máxima.",
                                "Programação: Implementação em R/Python para automação de modelagem.",
                                "Economia/Negócios: Previsão de demanda e otimização de estoques.",
                                "Ciência de Dados: Validação de modelos em machine learning."
                              ],
                              "realWorldApplication": "Em empresas de varejo, AICc seleciona o melhor modelo ETS para prever vendas sazonais de produtos, evitando overfitting em dados limitados (ex: 24 meses), otimizando estoque e reduzindo custos em 10-20%."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.2.2",
                            "name": "Aplicar algoritmo stepwise de seleção ETS",
                            "description": "Descrever o processo stepwise que inicia com um modelo simples e adiciona componentes de tendência e sazonalidade iterativamente, testando melhorias no AICc.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os dados e configurar o ambiente",
                                  "subSteps": [
                                    "Carregar a biblioteca forecast em R (ou equivalente em Python com statsmodels).",
                                    "Importar e visualizar a série temporal de dados (plot, summary).",
                                    "Definir parâmetros iniciais: modelo base ETS(A,N,N), limite de sazonalidade e critérios de parada (melhoria em AICc).",
                                    "Verificar estacionariedade e remover outliers se necessário.",
                                    "Dividir dados em treino e teste para validação futura."
                                  ],
                                  "verification": "Dados carregados corretamente, visualização mostra estrutura temporal clara e parâmetros iniciais definidos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "R ou Python instalado",
                                    "Pacote forecast (R) ou statsmodels/pmdarima (Python)",
                                    "Dataset de série temporal (ex: AirPassengers.csv)"
                                  ],
                                  "tips": "Sempre visualize a série antes de modelar para identificar padrões óbvios de tendência ou sazonalidade.",
                                  "learningObjective": "Configurar ambiente e preparar dados para aplicação do algoritmo ETS stepwise.",
                                  "commonMistakes": [
                                    "Ignorar missing values",
                                    "Não definir sazonalidade corretamente",
                                    "Usar dados não estacionários sem transformação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Ajustar o modelo ETS inicial simples",
                                  "subSteps": [
                                    "Ajustar o modelo base ETS(A,N,N) usando a função ets() com método stepwise=FALSE inicialmente.",
                                    "Calcular AICc do modelo inicial.",
                                    "Registrar especificação do modelo (erro, tendência, sazonalidade).",
                                    "Visualizar resíduos e ajuste do modelo.",
                                    "Comparar com baseline simples (média)."
                                  ],
                                  "verification": "Modelo ajustado com AICc calculado e resíduos aproximadamente brancos (Ljung-Box test p>0.05).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Função ets() do pacote forecast",
                                    "Dados preparados do step 1"
                                  ],
                                  "tips": "Use damped=TRUE se tendência for esperada para evitar explosões.",
                                  "learningObjective": "Implementar e avaliar o modelo ETS mais simples como ponto de partida.",
                                  "commonMistakes": [
                                    "Não checar resíduos",
                                    "Confundir AIC com AICc",
                                    "Ignorar overdispersion"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar iterações stepwise para adicionar componentes",
                                  "subSteps": [
                                    "Testar adição de tendência: ajuste ETS(A,A,N), ETS(A,Ad,N), ETS(A,M,N) e selecione o com menor AICc.",
                                    "Testar adição de sazonalidade: ETS(A,N,A), ETS(A,N,M) combinado com melhor tendência.",
                                    "Iterar: adicionar o componente que mais reduz AICc (delta > threshold, ex: 2).",
                                    "Repetir até não haver melhoria (parar quando AICc não diminui).",
                                    "Registrar histórico de AICc em cada iteração."
                                  ],
                                  "verification": "Cada iteração mostra redução em AICc e especificação atualizada (ex: de ANN para AAA).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Função ets() com stepwise=TRUE ou loop manual",
                                    "Planilha para rastrear AICc"
                                  ],
                                  "tips": "Limite iterações a 5 para evitar overfitting; priorize delta AICc >2.",
                                  "learningObjective": "Aplicar lógica iterativa stepwise para otimizar componentes ETS.",
                                  "commonMistakes": [
                                    "Testar todos componentes simultaneamente",
                                    "Continuar iterações sem melhoria",
                                    "Ignorar multiplicativo vs aditivo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e selecionar o modelo final",
                                  "subSteps": [
                                    "Ajustar modelo final com todos dados de treino.",
                                    "Prever em dados de teste e calcular erros (MAE, RMSE).",
                                    "Verificar diagnósticos: resíduos independentes, sem autocorrelação.",
                                    "Comparar AICc final com inicial e alternativas.",
                                    "Documentar especificação final (ex: ETS(A,A,M))."
                                  ],
                                  "verification": "Modelo final tem melhor performance em teste que baseline e diagnósticos aprovados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Função forecast() e accuracy()",
                                    "Dados de teste"
                                  ],
                                  "tips": "Use cross-validation se dataset grande para robustez.",
                                  "learningObjective": "Finalizar seleção ETS com validação rigorosa.",
                                  "commonMistakes": [
                                    "Overfitting ao treino",
                                    "Não testar em hold-out",
                                    "Esquecer de reportar AICc final"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dados de passageiros aéreos (AirPassengers), inicie com ETS(A,N,N) AICc=609. Teste tendência: ETS(A,A,N) AICc=550. Adicione sazonalidade: ETS(A,A,A) AICc=320. Pare em ETS(A,A,A) como modelo final otimizado.",
                              "finalVerifications": [
                                "AICc diminui monotonicamente em cada iteração stepwise.",
                                "Especificação final reflete componentes otimizados (E,T,S).",
                                "Resíduos do modelo final são brancos (ACF próximo de zero).",
                                "Previsões em teste têm erro <10% do baseline.",
                                "Histórico de iterações documentado com deltas AICc.",
                                "Modelo selecionado é parsimonioso (não adiciona componentes desnecessários)."
                              ],
                              "assessmentCriteria": [
                                "Implementação correta do loop stepwise com testes de AICc.",
                                "Seleção precisa de componentes baseada em delta AICc >2.",
                                "Diagnósticos de resíduos válidos (Ljung-Box p>0.05).",
                                "Documentação completa do processo iterativo.",
                                "Performance superior em validação cruzada.",
                                "Código reproduzível e comentado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Critérios de informação (AIC/AICc) e otimização.",
                                "Programação: Algoritmos iterativos e automação em R/Python.",
                                "Negócios: Previsão de demanda e planejamento estratégico.",
                                "Machine Learning: Seleção automática de modelos hiperparâmetros.",
                                "Economia: Análise de séries temporais econômicas."
                              ],
                              "realWorldApplication": "Em supply chain de varejo, otimizar previsão de vendas sazonais para reduzir estoque excessivo em 20%, ou em finanças para modelar retornos de ações com tendência e ciclos."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.2.3",
                            "name": "Comparar métodos de seleção global vs. restrita",
                            "description": "Diferenciar seleção global (todas combinações) de restrita (limitada a modelos plausíveis), avaliando trade-offs em termos de precisão e tempo computacional.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de Seleção Global em Modelos ETS",
                                  "subSteps": [
                                    "Defina seleção global: processo que testa todas as combinações possíveis de componentes ETS (erro, tendência e sazonalidade, totalizando 15 modelos).",
                                    "Explique os critérios de seleção, como AIC, BIC ou AICc, usados para escolher o melhor modelo.",
                                    "Discuta as vantagens: garante o ótimo global em termos do critério escolhido.",
                                    "Identifique cenários ideais: séries temporais curtas ou quando precisão máxima é prioritária.",
                                    "Revise a implementação básica em R com a função ets(model='AAA') ou auto.arima para ETS."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras explicando seleção global e liste as 15 combinações ETS.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação do pacote forecast em R; notebook Jupyter ou RStudio.",
                                  "tips": "Use diagramas para visualizar as 15 combinações (E/T/S x None/Add/Mult).",
                                  "learningObjective": "Dominar a definição e mecânica da seleção global em ETS.",
                                  "commonMistakes": "Confundir com busca local; ignorar que testa todas combinações independentemente de plausibilidade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o conceito de Seleção Restrita em Modelos ETS",
                                  "subSteps": [
                                    "Defina seleção restrita: limita testes a subconjuntos plausíveis baseados em características da série (ex: ausência de tendência se não detectada).",
                                    "Descreva heurísticas usadas: análise inicial de ACF/PACF, testes de estacionariedade ou regras empíricas.",
                                    "Explique critérios semelhantes (AIC/BIC), mas em espaço reduzido.",
                                    "Discuta vantagens: reduz tempo computacional sem perda significativa de precisão.",
                                    "Compare com global: restrita é mais rápida para séries longas ou complexas."
                                  ],
                                  "verification": "Crie uma tabela comparando regras de restrição para tendência e sazonalidade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação forecast; exemplos de código de ets() com diferentes configurações.",
                                  "tips": "Lembre-se: restrição usa conhecimento domínio para pruning inteligente.",
                                  "learningObjective": "Entender como e por quê a seleção restrita otimiza o processo.",
                                  "commonMistakes": "Achar que restrita sempre perde precisão; não considerar dependência de dados."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e Executar Seleção Global e Restrita",
                                  "subSteps": [
                                    "Carregue dataset AirPassengers e prepare (log-transform se necessário).",
                                    "Implemente seleção global: ets(AirPassengers, ic='AIC').",
                                    "Implemente seleção restrita: configure modelo com restrições (ex: model='ANN' se sem tendência).",
                                    "Meça tempo de execução com system.time() para cada método.",
                                    "Gere previsões e resuma modelos selecionados."
                                  ],
                                  "verification": "Execute código e capture outputs: modelo escolhido, tempo e AIC.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "R com pacotes forecast e ggplot2; dataset AirPassengers.",
                                  "tips": "Use set.seed() para reprodutibilidade em simulações.",
                                  "learningObjective": "Aplicar ambos métodos em dados reais e coletar métricas básicas.",
                                  "commonMistakes": "Não transformar dados (log para multiplicativo); ignorar warnings de convergência."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Trade-offs em Precisão",
                                  "subSteps": [
                                    "Divida dados em treino/teste (ex: 80/20).",
                                    "Calcule métricas de precisão: MAE, RMSE, MAPE para previsões de ambos métodos.",
                                    "Compare AIC/BIC entre modelos selecionados.",
                                    "Teste em múltiplos datasets (ex: adicionar ruído ou séries sintéticas).",
                                    "Analise se global sempre supera restrita em precisão."
                                  ],
                                  "verification": "Crie gráfico de boxplot comparando erros em 5 runs.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "R com forecast, dplyr; datasets adicionais como USAccDeaths.",
                                  "tips": "Use accuracy() do forecast para métricas automáticas.",
                                  "learningObjective": "Quantificar impacto na precisão dos dois métodos.",
                                  "commonMistakes": "Usar todo dataset para fit; não considerar horizonte de previsão."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Avaliar Trade-offs em Tempo Computacional e Decidir Uso",
                                  "subSteps": [
                                    "Meça tempo escalando tamanho da série (duplique dados).",
                                    "Compare ratios tempo global/restrita.",
                                    "Discuta trade-offs: global para precisão (custo alto), restrita para eficiência.",
                                    "Defina regras de decisão: use restrita se n>100 ou tempo crítico.",
                                    "Documente relatório com tabelas e conclusões."
                                  ],
                                  "verification": "Escreva parágrafo recomendando método para cenários específicos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "RStudio; scripts dos steps anteriores.",
                                  "tips": "Profile com profvis para bottlenecks.",
                                  "learningObjective": "Sintetizar trade-offs e formular guidelines práticas.",
                                  "commonMistakes": "Ignorar overhead fixo; generalizar de um dataset."
                                }
                              ],
                              "practicalExample": "No dataset AirPassengers (1949-1960), aplique seleção global com ets(ic='AIC') (testa 15 modelos, ~0.5s, seleciona ETS(M,A,M), AIC=105.3) vs. restrita limitando a modelos com tendência aditiva (3 modelos, ~0.1s, mesmo modelo). Em hold-out, RMSE global=12.1 vs. restrita=12.3, mostrando trade-off mínimo.",
                              "finalVerifications": [
                                "Explica corretamente as 15 combinações ETS e critérios de seleção.",
                                "Implementa código funcional para ambos métodos com medição de tempo.",
                                "Compara precisão com métricas numéricas em dataset real.",
                                "Identifica trade-offs quantitativos (ex: tempo x2-10, precisão similar).",
                                "Recomenda método baseado em contexto (ex: global para pesquisa, restrita para produção).",
                                "Cria visualizações comparativas claras."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: diferencia global (exaustiva) vs. restrita (heurística).",
                                "Implementação correta: código roda sem erros, usa funções apropriadas.",
                                "Análise quantitativa: compara tempo e precisão com evidências numéricas.",
                                "Profundidade de trade-offs: discute cenários de uso e limitações.",
                                "Clareza de comunicação: relatórios e gráficos profissionais.",
                                "Criatividade: testa em datasets variados."
                              ],
                              "crossCurricularConnections": [
                                "Programação: otimização de algoritmos de busca (grid search vs. pruning).",
                                "Matemática: teoria de informação (AIC/BIC como critérios bayesianos).",
                                "Machine Learning: seleção de hiperparâmetros (exhaustive vs. Bayesian opt).",
                                "Computação: complexidade algorítmica (O(n) vs. O(1))."
                              ],
                              "realWorldApplication": "Em previsão de demanda para e-commerce (ex: Amazon), seleção restrita acelera pipelines diários processando milhões de SKUs, sacrificando <1% precisão; global usada em R&D para validar baselines em séries críticas como estoque perecível."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.2.3",
                        "name": "Ajuste e Previsão com ETS Automatizados",
                        "description": "Processo de ajuste automático de parâmetros via máxima verossimilhança e geração de previsões com intervalos de confiança para séries com tendência e sazonalidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.2.3.1",
                            "name": "Ajustar modelo ETS usando função ets() no R",
                            "description": "Implementar a função ets() do pacote forecast no R para seleção e ajuste automático, especificando parâmetros como model='ZZZ' para seleção completa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente R e instalar pacotes necessários",
                                  "subSteps": [
                                    "Abra o R ou RStudio.",
                                    "Instale o pacote forecast executando: install.packages('forecast').",
                                    "Carregue o pacote com library(forecast).",
                                    "Verifique a instalação com ?ets para abrir a documentação.",
                                    "Importe um conjunto de dados de exemplo, como data(AirPassengers)."
                                  ],
                                  "verification": "Execute library(forecast) sem erros e confirme com sessionInfo() que o pacote está carregado.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "R ou RStudio instalado",
                                    "Conexão à internet para instalação de pacotes"
                                  ],
                                  "tips": "Sempre atualize os pacotes com update.packages() antes de começar para evitar conflitos de versão.",
                                  "learningObjective": "Preparar o ambiente de R para o uso da função ets() do pacote forecast.",
                                  "commonMistakes": [
                                    "Esquecer de instalar o pacote antes de carregar",
                                    "Não verificar dependências como zoo ou tseries",
                                    "Usar R antigo sem compatibilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar os dados como objeto de série temporal",
                                  "subSteps": [
                                    "Carregue os dados com data() ou leia de um arquivo CSV usando read.csv().",
                                    "Converta para ts() se necessário: ts(dados, start=c(ano, mes), frequency=12) para dados mensais.",
                                    "Explore os dados com plot(), summary() e Box.test() para estacionariedade.",
                                    "Trate valores ausentes com na.approx() do pacote zoo, se aplicável.",
                                    "Divida em treino e teste: treino <- window(ts_dados, end=c(ano_fim_treino))."
                                  ],
                                  "verification": "Plote a série temporal e confirme que não há NAs e a estrutura está correta com str(ts_objeto).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Conjunto de dados de série temporal (ex: AirPassengers)",
                                    "Pacote forecast carregado"
                                  ],
                                  "tips": "Use frequency=12 para mensais ou 52 para semanais para capturar sazonalidade corretamente.",
                                  "learningObjective": "Transformar dados brutos em um objeto ts adequado para modelagem ETS.",
                                  "commonMistakes": [
                                    "Definir frequência errada levando a sazonalidade incorreta",
                                    "Ignorar NAs causando falha no ajuste",
                                    "Não plotar dados iniciais para inspeção visual"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Ajustar o modelo ETS usando a função ets()",
                                  "subSteps": [
                                    "Execute o ajuste: modelo <- ets(treino, model='ZZZ').",
                                    "Especifique parâmetros opcionais: ets(treino, model='ZZZ', damped=NULL, alpha=0.8).",
                                    "Inspecione o modelo com summary(modelo) e autoplot(modelo).",
                                    "Verifique critérios de informação: modelo$aic, modelo$aicc, modelo$bic.",
                                    "Ajuste manual se necessário: model='ANA' para aditivo não sazonal."
                                  ],
                                  "verification": "O objeto modelo deve ter componentes como $states e $fitted sem erros de convergência.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Objeto ts de treino preparado",
                                    "Documentação de ets() aberta"
                                  ],
                                  "tips": "Use model='ZZZ' para seleção automática completa; monitore mensagens de aviso sobre convergência.",
                                  "learningObjective": "Implementar e customizar o ajuste automático de modelos ETS com ets().",
                                  "commonMistakes": [
                                    "Especificar model incorreto como 'ZZZ' em dados não sazonais",
                                    "Não checar damped para tendências amortecidas",
                                    "Ignorar avisos de otimização falha"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar o modelo e gerar previsões",
                                  "subSteps": [
                                    "Gere previsões: previsoes <- forecast(modelo, h=12).",
                                    "Plote com autoplot(previsoes) + autolayer(teste).",
                                    "Calcule acurácia: accuracy(modelo, teste).",
                                    "Compare com baseline: accuracy(naive(treino), teste).",
                                    "Salve o modelo com saveRDS(modelo, 'meu_modelo_ets.rds')."
                                  ],
                                  "verification": "As métricas de accuracy mostram RMSE/MAPE menores que baselines e plot sem discrepâncias óbvias.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Modelo ajustado",
                                    "Dados de teste"
                                  ],
                                  "tips": "Use h= número de períodos futuros; sempre valide com hold-out set.",
                                  "learningObjective": "Validar o modelo ETS e aplicar para previsões práticas.",
                                  "commonMistakes": [
                                    "Prever sem conjunto de teste",
                                    "Interpretar MAPE sem contexto de escala",
                                    "Não salvar o modelo para reutilização"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando os dados AirPassengers (passageiros aéreos mensais de 1949-1960): modelo <- ets(AirPassengers, model='ZZZ'); fc <- forecast(modelo, h=12); autoplot(fc). Isso ajusta automaticamente um modelo ETS com sazonalidade e gera previsões para 1961.",
                              "finalVerifications": [
                                "Modelo ajustado sem erros de convergência e com AICc finito.",
                                "Plot do modelo mostra ajuste visual bom aos dados de treino.",
                                "Previsões com intervalos de confiança plausíveis.",
                                "Métricas de accuracy (RMSE, MAE) calculadas e comparadas.",
                                "Capacidade de salvar/carregar o modelo com saveRDS() e readRDS().",
                                "Interpretação correta dos componentes error, trend e seasonal."
                              ],
                              "assessmentCriteria": [
                                "Uso correto de model='ZZZ' para seleção automática.",
                                "Preparação adequada de ts com frequency correta.",
                                "Interpretação precisa de summary(modelo) e componentes.",
                                "Avaliação robusta com accuracy() em conjunto de teste.",
                                "Visualizações claras com autoplot() e customizações.",
                                "Tratamento de edge cases como dados curtos ou não sazonais."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Compreensão de componentes multiplicativos/aditivos em séries temporais.",
                                "Programação: Manipulação de objetos ts e funções do pacote forecast em R.",
                                "Análise de Dados: Integração com ggplot2 para visualizações avançadas.",
                                "Machine Learning: Comparação com ARIMA auto.arima() para seleção de modelos.",
                                "Negócios: Aplicação em forecasting para planejamento estratégico."
                              ],
                              "realWorldApplication": "Em empresas de varejo, ajustar ETS para prever vendas mensais de produtos sazonais, otimizando estoque e reduzindo custos; em energia, prever consumo para gerenciamento de rede; em finanças, forecast de séries econômicas como PIB para decisões de investimento."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.3.2",
                            "name": "Gerar e interpretar previsões ETS",
                            "description": "Usar forecast() para obter previsões pontuais, intervalos de predição e decomposição dos componentes, interpretando-os em contextos como finanças ou marketing.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o modelo ETS ajustado e gerar previsões com forecast()",
                                  "subSteps": [
                                    "Carregue os pacotes necessários: fable, tsibble e feasts.",
                                    "Prepare o objeto tsibble com a série temporal histórica.",
                                    "Ajuste o modelo ETS automatizado usando model() e fit().",
                                    "Defina o horizonte de previsão (h) com base no contexto (ex: 12 para meses).",
                                    "Execute forecast(fitted_model, h = h) para gerar o objeto de previsão."
                                  ],
                                  "verification": "Verifique se o objeto forecast contém colunas como .model, point forecast, lo95 e hi95 usando glimpse() ou head().",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ambiente R/RStudio",
                                    "Pacotes: fable, tsibble, feasts",
                                    "Dados de série temporal em formato tsibble"
                                  ],
                                  "tips": "Sempre confirme que o modelo foi ajustado corretamente com report() antes de forecast().",
                                  "learningObjective": "Compreender e aplicar a função forecast() para gerar previsões ETS pontuais e intervalos.",
                                  "commonMistakes": [
                                    "Esquecer de converter dados para tsibble",
                                    "Definir h muito grande sem validação",
                                    "Usar modelo não ajustado"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Extrair e visualizar previsões pontuais e intervalos de predição",
                                  "subSteps": [
                                    "Extraia as previsões pontuais com as_fable(forecast_obj).",
                                    "Acesse intervalos de predição (ex: 80% e 95%) usando hilo(forecast_obj, 80, 95).",
                                    "Crie um gráfico de previsão com autoplot(forecast_obj) + theme_minimal().",
                                    "Adicione elementos como bandas de confiança e dados históricos no plot.",
                                    "Salve o gráfico para análise posterior com ggsave()."
                                  ],
                                  "verification": "O gráfico mostra linha histórica, previsão pontual e faixas de intervalo sem erros de plotting.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Pacotes: fable, ggplot2",
                                    "Objeto forecast gerado no step anterior"
                                  ],
                                  "tips": "Use hilo() para intervalos personalizados; ajuste cores para melhor visualização.",
                                  "learningObjective": "Visualizar e extrair componentes básicos das previsões ETS.",
                                  "commonMistakes": [
                                    "Ignorar discrepâncias entre histórico e previsão",
                                    "Não incluir bandas de confiança no plot",
                                    "Confundir lo80 com lo95"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Obter e decompor componentes das previsões ETS",
                                  "subSteps": [
                                    "Gere a decomposição dos componentes com components(forecast_obj).",
                                    "Examine colunas como trend, season e remainder na decomposição.",
                                    "Visualize a decomposição com autoplot(components(forecast_obj)).",
                                    "Compare componentes observados vs. previstos para validar.",
                                    "Exporte a tabela de componentes para análise detalhada."
                                  ],
                                  "verification": "A tabela components() mostra trend, seasonal e error sem valores NA inesperados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Pacotes: fable, feasts",
                                    "Objeto forecast do step 1"
                                  ],
                                  "tips": "Para modelos multiplicativos, foque em proporções sazonais; use facet_wrap() para múltiplos componentes.",
                                  "learningObjective": "Analisar a contribuição de cada componente (tendência, sazonalidade, erro) nas previsões.",
                                  "commonMistakes": [
                                    "Aplicar components() em objeto não-ETS",
                                    "Interpretar remainder como ruído sem contexto",
                                    "Ignorar modelo aditivo vs. multiplicativo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar previsões e componentes em contextos aplicados",
                                  "subSteps": [
                                    "Analise previsões pontuais: identifique tendências crescentes/decrescentes.",
                                    "Interprete intervalos: discuta incertezas (ex: faixa ampla indica alta variância).",
                                    "Relacione componentes ao domínio (ex: sazonalidade em vendas de varejo).",
                                    "Gere relatório narrativo com insights acionáveis.",
                                    "Valide interpretações com métricas como accuracy() em dados de teste."
                                  ],
                                  "verification": "Produza um parágrafo de interpretação coerente e contextualizado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Gráficos e tabelas dos steps anteriores",
                                    "Conhecimento de domínio (finanças/marketing)"
                                  ],
                                  "tips": "Sempre relacione números a impactos reais, como 'previsão de +10% nas vendas'.",
                                  "learningObjective": "Desenvolver habilidades de interpretação crítica de previsões ETS.",
                                  "commonMistakes": [
                                    "Focar só em pontual ignorando intervalos",
                                    "Generalizar componentes sem contexto",
                                    "Superestimar precisão de previsões longas"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dados mensais de vendas de uma rede de varejo (tsibble com 60 observações), ajuste um modelo ETS(A,A,A), gere forecast(h=12), visualize com intervalos 95%, decomponha componentes e interprete: 'Tendência crescente de 5% ao mês sugere expansão de estoque; sazonalidade de pico em dezembro indica reforço promocional'.",
                              "finalVerifications": [
                                "Geração bem-sucedida de forecast() com previsões pontuais e intervalos.",
                                "Visualização clara de histórico, previsão e bandas de confiança.",
                                "Decomposição correta dos componentes ETS (trend, season, remainder).",
                                "Interpretação contextualizada sem erros conceituais.",
                                "Relatório com insights acionáveis e validação básica.",
                                "Ausência de erros em código ou dados NA."
                              ],
                              "assessmentCriteria": [
                                "Precisão na aplicação de forecast() e components() (sem erros sintáticos).",
                                "Qualidade da visualização: legível, com todos elementos chave.",
                                "Profundidade da interpretação: relaciona componentes a cenários reais.",
                                "Correta distinção entre pontual, intervalos e decomposição.",
                                "Uso adequado de h e níveis de confiança.",
                                "Clareza e concisão no relatório final."
                              ],
                              "crossCurricularConnections": [
                                "Finanças: Previsão de séries de preços de ações ou câmbio.",
                                "Marketing: Previsão de demanda de produtos sazonais.",
                                "Economia: Análise de indicadores macroeconômicos como PIB.",
                                "Operações: Otimização de cadeia de suprimentos com previsões de vendas.",
                                "Machine Learning: Integração ETS com modelos híbridos."
                              ],
                              "realWorldApplication": "Em finanças, bancos usam previsões ETS para modelar retornos de portfólios e gerenciar riscos; em marketing, empresas como Amazon preveem demanda sazonal para otimizar estoque e campanhas, reduzindo custos em até 20% via decisões baseadas em intervalos de confiança e decomposições."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.3.3",
                            "name": "Avaliar precisão de modelos ETS automatizados",
                            "description": "Calcular métricas como MAPE, MAE e RMSE para validar previsões ETS, comparando com benchmarks e diagnosticando resíduos para estacionariedade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar dados de treino, teste e previsões ETS",
                                  "subSteps": [
                                    "Carregue o conjunto de dados de série temporal usando pandas.",
                                    "Divida os dados em treino e teste (ex: 80/20).",
                                    "Ajuste o modelo ETS automatizado no conjunto de treino usando statsmodels ou similar.",
                                    "Gere previsões para o conjunto de teste.",
                                    "Alinhe as previsões com os valores reais do teste em um DataFrame."
                                  ],
                                  "verification": "Verifique se o DataFrame contém colunas 'real' e 'previsao' sem valores NaN usando df.info() e df.isnull().sum().",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python, bibliotecas: pandas, statsmodels.tsa.exponential_smoothing.ets.ETSModel",
                                  "tips": "Use seed para reproducibilidade: np.random.seed(42).",
                                  "learningObjective": "Preparar dados alinhados para cálculo de métricas de precisão.",
                                  "commonMistakes": "Não alinhar índices de tempo entre reais e previsões, levando a comparações erradas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular métricas de precisão: MAE, RMSE e MAPE",
                                  "subSteps": [
                                    "Calcule MAE: média absoluta dos erros (abs(real - previsao)).mean().",
                                    "Calcule RMSE: raiz quadrada da média dos erros quadrados (np.sqrt((real - previsao)**2.mean())).",
                                    "Calcule MAPE: média dos erros percentuais absolutos ((abs((real - previsao)/real)*100).mean()).",
                                    "Armazene os resultados em um dicionário ou DataFrame para visualização.",
                                    "Plote os valores reais vs. previstos com matplotlib para inspeção visual."
                                  ],
                                  "verification": "Execute print(mae, rmse, mape) e confirme valores numéricos finitos e razoáveis (ex: MAPE < 20%).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Python, numpy, matplotlib",
                                  "tips": "Trate divisões por zero em MAPE com np.where(real == 0, 0, ...).",
                                  "learningObjective": "Dominar o cálculo manual de métricas de erro para validação de previsões ETS.",
                                  "commonMistakes": "Usar valores reais zero no denominador do MAPE sem tratamento, resultando em NaN."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar métricas com benchmarks e padrões da indústria",
                                  "subSteps": [
                                    "Pesquise benchmarks para o domínio (ex: MAPE < 10% para vendas retail).",
                                    "Compare suas métricas com baselines como média ingênua ou ARIMA simples.",
                                    "Calcule baseline ingênua: previsões iguais à última observação de treino.",
                                    "Crie uma tabela comparativa com pandas DataFrame.",
                                    "Interprete: classifique precisão como 'boa', 'média' ou 'ruim' baseada em thresholds."
                                  ],
                                  "verification": "Tabela comparativa mostra seu modelo superando baseline em pelo menos uma métrica.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Pandas para tabelas, internet para benchmarks",
                                  "tips": "Use hierarchical benchmarks: RMSE para escala, MAPE para interpretabilidade.",
                                  "learningObjective": "Contextualizar precisão relativa a padrões e baselines.",
                                  "commonMistakes": "Ignorar escala dos dados, comparando RMSE de séries com magnitudes diferentes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diagnosticar resíduos para estacionariedade e melhorias",
                                  "subSteps": [
                                    "Calcule resíduos: real - previsao.",
                                    "Teste estacionariedade com Augmented Dickey-Fuller (ADF) usando statsmodels.tsa.stattools.adfuller.",
                                    "Plote resíduos, ACF e PACF para padrões.",
                                    "Verifique heterocedasticidade com plot de resíduos vs. tempo.",
                                    "Recomende ajustes ETS (ex: adicionar sazonalidade se resíduos não estacionários)."
                                  ],
                                  "verification": "ADF p-value < 0.05 confirma estacionariedade; plots sem padrões óbvios.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Statsmodels.tsa.stattools, matplotlib",
                                  "tips": "Diferencie resíduos se necessário antes do teste ADF.",
                                  "learningObjective": "Diagnosticar falhas no modelo via análise de resíduos.",
                                  "commonMistakes": "Não transformar resíduos em série estacionária antes do teste, invalidando resultados."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar avaliação e propor ações",
                                  "subSteps": [
                                    "Resuma métricas, comparações e diagnóstico em relatório curto.",
                                    "Decida: aceitar modelo, refinar parâmetros ETS ou tentar outro método.",
                                    "Documente thresholds falhados e razões.",
                                    "Salve relatório como Markdown ou Jupyter notebook.",
                                    "Teste sensibilidade variando hold-out size."
                                  ],
                                  "verification": "Relatório completo explica se modelo é viável e próximas ações.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Jupyter Notebook ou Markdown",
                                  "tips": "Use templates de relatório para consistência.",
                                  "learningObjective": "Integrar todos os aspectos em uma avaliação holística acionável.",
                                  "commonMistakes": "Focar só em métricas baixas ignorando diagnóstico de resíduos."
                                }
                              ],
                              "practicalExample": "Usando dataset AirPassengers (passageiros aéreos mensais 1949-1960): ajuste ETS automatizado, preveja últimos 12 meses, calcule MAPE=8.5%, RMSE=25.3, compare com naive (MAPE=12%), teste resíduos ADF (p=0.01, estacionário), conclua modelo bom para previsão de demanda aérea.",
                              "finalVerifications": [
                                "Métricas calculadas corretamente sem NaN.",
                                "Comparação com benchmark mostra performance relativa.",
                                "Teste ADF em resíduos confirma estacionariedade (p<0.05).",
                                "Plots de resíduos sem autocorrelação visível.",
                                "Relatório sintetiza achados e recomendações.",
                                "Código reproduzível gera mesmos resultados."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas fórmulas de MAE/RMSE/MAPE (100% match com função pronta).",
                                "Interpretação correta de benchmarks e thresholds.",
                                "Aplicação adequada de teste ADF e diagnóstico de resíduos.",
                                "Qualidade dos plots e tabela comparativa.",
                                "Relatório lógico e acionável.",
                                "Tratamento de edge cases como zeros em MAPE."
                              ],
                              "crossCurricularConnections": [
                                "Estatística Inferencial: Testes de hipóteses como ADF.",
                                "Programação: Manipulação de dados com Pandas/NumPy.",
                                "Machine Learning: Validação de modelos de previsão.",
                                "Visualização de Dados: Plots de resíduos e comparações."
                              ],
                              "realWorldApplication": "Em e-commerce, avaliar modelo ETS para prever demanda de produtos sazonais, otimizando estoque e reduzindo overstock em 15-20%; em finanças, validar previsões de séries de retornos para estratégias de trading automatizadas."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.3.4",
                            "name": "Aplicar ETS em séries reais não estacionárias",
                            "description": "Transformar séries não estacionárias (log ou diferenciação) e aplicar ETS automatizado, considerando referências como Hyndman et al. para aplicações práticas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Avaliar Estacionariedade da Série Temporal",
                                  "subSteps": [
                                    "Carregue os dados da série temporal real usando bibliotecas como readr em R ou pandas em Python.",
                                    "Plote a série temporal para visualizar tendências, sazonalidade e não-estacionariedade.",
                                    "Aplique testes estatísticos como Augmented Dickey-Fuller (ADF) ou KPSS para confirmar não-estacionariedade.",
                                    "Examine ACF e PACF plots para identificar padrões de autocorrelação.",
                                    "Registre métricas iniciais como média móvel e variância para comparação posterior."
                                  ],
                                  "verification": "O teste ADF rejeita a hipótese nula de unidade raiz (p-valor < 0.05) ou plots mostram clara não-estacionariedade.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Dados reais (ex: série de vendas mensais), R com forecast e tseries, ou Python com statsmodels e pandas"
                                  ],
                                  "tips": "Sempre plote primeiro: visualizações revelam problemas que testes podem perder.",
                                  "learningObjective": "Identificar características de não-estacionariedade em séries temporais reais.",
                                  "commonMistakes": [
                                    "Ignorar sazonalidade ao interpretar testes",
                                    "Usar dados insuficientes para testes robustos",
                                    "Confundir tendência com sazonalidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar Transformações para Estacionariedade",
                                  "subSteps": [
                                    "Escolha transformação baseada na análise: logaritmo para variância crescente, diferenciação para tendência.",
                                    "Aplique log(ts) se variância aumentar com o tempo; diff(ts) ou diff(log(ts)) para remover tendência.",
                                    "Ajuste para sazonalidade com diff(ts, lag=12) para dados mensais.",
                                    "Re-teste estacionariedade com ADF/KPSS após cada transformação.",
                                    "Itere transformações até passar nos testes (mantenha registro das tentativas)."
                                  ],
                                  "verification": "Série transformada passa no teste ADF (p-valor < 0.05) e plots ACF mostram decaimento rápido.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Funções log() e diff() em R/Python, gráficos ACF/PACF"
                                  ],
                                  "tips": "Comece com log se houver heterocedasticidade; combine com diff para tendência persistente.",
                                  "learningObjective": "Dominar transformações Box-Cox, log e diferenciação para estabilizar séries.",
                                  "commonMistakes": [
                                    "Sobre-diferenciação levando a séries superestacionárias",
                                    "Ignorar sazonalidade nas diferenças",
                                    "Não retestar após transformação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Ajustar Modelo ETS Automatizado",
                                  "subSteps": [
                                    "Use função auto.arima() ou ets() do pacote forecast de Hyndman em R, especificando modelo ETS.",
                                    "Defina parâmetros: allowdrift=TRUE para tendência, lambda para transformações automáticas.",
                                    "Ajuste o modelo na série transformada: fit <- ets(transformed_ts, model='AAA').",
                                    "Examine resumo do modelo (AIC, parâmetros A/T/S estimados).",
                                    "Gere previsões iniciais com h=12 para validação."
                                  ],
                                  "verification": "Modelo converge sem erros e AIC é baixo comparado a baselines como média móvel.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Pacote forecast (R) ou pmdarima/statsmodels (Python), Hyndman et al. referências"
                                  ],
                                  "tips": "Use model='ZZZ' para seleção automática completa, mas inspecione manualmente.",
                                  "learningObjective": "Aplicar ETS automatizado de Hyndman em séries transformadas.",
                                  "commonMistakes": [
                                    "Não especificar transformações manuais quando auto falha",
                                    "Ignorar warnings de convergência",
                                    "Usar série original sem transformação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar Modelo e Gerar Previsões Finais",
                                  "subSteps": [
                                    "Divida dados em treino/teste (ex: 80/20).",
                                    "Calcule métricas: MAE, RMSE, MAPE em conjunto de teste.",
                                    "Plote previsões vs. observados, incluindo intervalos de confiança.",
                                    "Compare com baselines (naive, média sazonal).",
                                    "Ajuste hiperparâmetros se necessário e finalize relatório."
                                  ],
                                  "verification": "RMSE < baseline e resíduos passam em teste Ljung-Box (p>0.05).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Funções accuracy() em R, métricas scikit-learn em Python"
                                  ],
                                  "tips": "Sempre use validação cruzada temporal para séries reais.",
                                  "learningObjective": "Avaliar e refinar modelos ETS para precisão preditiva.",
                                  "commonMistakes": [
                                    "Vazamento de dados no teste",
                                    "Ignorar intervalos de confiança",
                                    "Selecionar por AIC sem validação out-of-sample"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dados reais de vendas mensais de energia elétrica (com tendência crescente e sazonalidade anual): aplique log para estabilizar variância, diff(lag=12) para sazonalidade, ajuste ets(model='AAN') e preveja próximos 12 meses, alcançando MAPE < 10%.",
                              "finalVerifications": [
                                "Série transformada é estacionária (ADF p<0.05).",
                                "Modelo ETS ajusta com AIC otimizado.",
                                "Previsões em teste têm RMSE inferior a baselines.",
                                "Resíduos são white noise (Ljung-Box p>0.05).",
                                "Intervalos de confiança são realistas (largura < 20% da previsão).",
                                "Transformações são reversíveis para previsões em escala original."
                              ],
                              "assessmentCriteria": [
                                "Precisão das previsões (MAPE < 15%).",
                                "Correta identificação e correção de não-estacionariedade.",
                                "Uso apropriado de auto.ets com referências Hyndman.",
                                "Análise robusta de resíduos e diagnósticos.",
                                "Relatório claro com plots e interpretações.",
                                "Eficiência computacional (tempo de ajuste < 1 min)."
                              ],
                              "crossCurricularConnections": [
                                "Economia: Previsão de PIB ou inflação.",
                                "Finanças: Modelagem de retornos de ações voláteis.",
                                "Engenharia: Manutenção preditiva em sensores IoT.",
                                "Saúde: Previsão de epidemias sazonais.",
                                "Meio Ambiente: Séries climáticas não-estacionárias."
                              ],
                              "realWorldApplication": "Em supply chain, transformar vendas não-estacionárias de varejo com log-diff, aplicar ETS para otimizar estoque, reduzindo overstock em 20% e melhorando previsões de demanda sazonal."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.3",
                    "name": "Critérios de Informação para Seleção Automática",
                    "description": "Uso de AIC, BIC e outros critérios para escolha do melhor modelo de previsão automaticamente.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.3.1",
                        "name": "Critério de Informação de Akaike (AIC)",
                        "description": "O Critério de Informação de Akaike (AIC) é uma medida que equilibra a bondade de ajuste do modelo com o número de parâmetros, penalizando modelos mais complexos para evitar overfitting em séries temporais.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.3.1.1",
                            "name": "Definir a fórmula do AIC",
                            "description": "Explicar a fórmula do AIC como AIC = -2 * log(L) + 2 * k, onde L é a verossimilhança máxima e k o número de parâmetros, e sua aplicação na avaliação de modelos ARIMA para previsão de séries temporais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais da Verossimilhança e Parâmetros",
                                  "subSteps": [
                                    "Revise o conceito de verossimilhança máxima (L): função que mede quão bem o modelo ajusta os dados observados.",
                                    "Identifique k como o número total de parâmetros estimáveis no modelo, incluindo constantes.",
                                    "Diferencie verossimilhança de erro quadrático médio, focando em sua base probabilística.",
                                    "Calcule L manualmente para um modelo simples de regressão linear com dados fictícios.",
                                    "Liste exemplos de parâmetros em modelos ARIMA (p, d, q, intercepto)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que L e k representam, com um exemplo numérico simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de estatística inferencial, calculadora científica, planilha Excel ou Google Sheets.",
                                  "tips": "Use logaritmo natural para simplificar cálculos manuais de log(L).",
                                  "learningObjective": "Dominar os termos L e k na fórmula AIC, entendendo sua interpretação estatística.",
                                  "commonMistakes": "Confundir k com o número de observações (n) ou ignorar parâmetros de intercepto."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Memorizar e Derivar a Fórmula do AIC",
                                  "subSteps": [
                                    "Memorize a fórmula base: AIC = -2 * log(L) + 2 * k.",
                                    "Derive intuitivamente: o primeiro termo penaliza falta de ajuste, o segundo penaliza complexidade.",
                                    "Escreva a fórmula 10 vezes, variando os valores de L e k para observar impactos.",
                                    "Compare com BIC para destacar a diferença no coeficiente de k (2 vs log(n)).",
                                    "Teste a fórmula com um modelo ARIMA(1,0,0) em dados simulados."
                                  ],
                                  "verification": "Recite a fórmula corretamente e compute AIC para um exemplo dado sem consultar notas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e caneta, software R (pacote forecast) ou Python (statsmodels).",
                                  "tips": "Associe -2*log(L) a 'goodness of fit' e 2*k a 'Occam's razor'.",
                                  "learningObjective": "Internalizar a fórmula exata do AIC e sua estrutura penalizadora.",
                                  "commonMistakes": "Esquecer o sinal negativo em -2*log(L) ou usar log base 10 em vez de natural."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar o Valor do AIC na Seleção de Modelos",
                                  "subSteps": [
                                    "Calcule AIC para dois modelos ARIMA competidores em uma série temporal real.",
                                    "Interprete: menor AIC indica melhor equilíbrio entre ajuste e parcimônia.",
                                    "Discuta trade-off: modelos complexos podem ter AIC menor inicialmente, mas penalizados.",
                                    "Plote AIC vs ordem (p,q) para um conjunto de dados de séries temporais.",
                                    "Explique por que AIC favorece modelos mais simples que BIC em amostras grandes."
                                  ],
                                  "verification": "Compare AIC de dois modelos e justifique qual selecionar, com cálculos mostrados.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Dados de série temporal (ex: AirPassengers no R), Jupyter Notebook ou RStudio.",
                                  "tips": "Sempre normalize AIC por número de observações para séries longas (AICc).",
                                  "learningObjective": "Aplicar AIC para comparar e selecionar modelos ARIMA.",
                                  "commonMistakes": "Selecionar modelo só pelo menor AIC sem verificar resíduos ou estacionariedade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar AIC em Previsão de Séries Temporais com ARIMA",
                                  "subSteps": [
                                    "Ajuste múltiplos modelos ARIMA a uma série temporal real usando auto.arima() ou grid search.",
                                    "Selecione o modelo com menor AIC e gere previsões.",
                                    "Valide o modelo selecionado com testes de resíduos (Ljung-Box).",
                                    "Compare previsões do modelo AIC-otimizado com outro critério (ex: BIC).",
                                    "Documente o processo em um relatório curto."
                                  ],
                                  "verification": "Produza um relatório com código, AIC calculado e previsão justificada.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Dataset real (ex: vendas mensais), Python/R, bibliotecas statsmodels/forecast.",
                                  "tips": "Use funções automáticas como auto.arima() para eficiência inicial.",
                                  "learningObjective": "Integrar AIC na pipeline completa de modelagem ARIMA para previsão.",
                                  "commonMistakes": "Ignorar differencing (d) inadequado, levando a AIC enviesado."
                                }
                              ],
                              "practicalExample": "Usando dados de passageiros aéreos (AirPassengers), ajuste ARIMA(2,1,2) e ARIMA(1,1,1). Calcule AIC: ARIMA(2,1,2) AIC=553.4, ARIMA(1,1,1) AIC=558.2. Selecione ARIMA(2,1,2) por menor AIC e use para prever próximos 12 meses.",
                              "finalVerifications": [
                                "Recitar corretamente a fórmula AIC com definições de L e k.",
                                "Calcular AIC manualmente para um modelo com L=0.5 e k=3.",
                                "Comparar AIC de dois modelos ARIMA e justificar escolha.",
                                "Explicar aplicação de AIC em seleção automática de ARIMA.",
                                "Identificar erro comum: confundir AIC com RMSE.",
                                "Demonstrar uso de AIC em software (R/Python)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na recitação e derivação da fórmula (20%)",
                                "Correção nos cálculos de AIC para exemplos dados (30%)",
                                "Interpretação adequada do trade-off ajuste vs complexidade (20%)",
                                "Aplicação prática em ARIMA com código funcional (20%)",
                                "Clareza na explicação de L, k e contexto de séries temporais (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Logaritmos e otimização via máxima verossimilhança.",
                                "Programação: Implementação em R/Python para automação de modelos.",
                                "Economia: Seleção de modelos para previsão de PIB ou inflação.",
                                "Ciência de Dados: Integração com machine learning (ex: penalidades L1/L2)."
                              ],
                              "realWorldApplication": "Em finanças, bancos usam AIC para selecionar ARIMA na previsão de retornos de ações, otimizando portfólios; em meteorologia, para modelar séries de temperatura e melhorar alertas climáticos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.3.1.2",
                            "name": "Calcular o AIC manualmente",
                            "description": "Realizar o cálculo passo a passo do AIC para um modelo ARIMA ajustado a uma série temporal estacionária, utilizando resíduos e verossimilhança.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os dados e componentes do modelo ARIMA ajustado",
                                  "subSteps": [
                                    "Obtenha a série temporal estacionária utilizada para ajustar o modelo ARIMA.",
                                    "Extraia os resíduos (ε_t) do modelo ajustado.",
                                    "Identifique e conte o número de parâmetros estimados (k), incluindo coeficientes AR, MA, diferencial e variância.",
                                    "Registre o número de observações efetivas (n) após ajustes como diferenciação.",
                                    "Verifique se os resíduos são aproximadamente normais usando histograma ou teste QQ."
                                  ],
                                  "verification": "Lista de resíduos extraída e k e n confirmados; resíduos plotados sem padrões evidentes.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Série temporal em CSV ou array; software como R (função residuals(arima())) ou Python (statsmodels).",
                                  "tips": "Use n como o comprimento da série após remoção de warm-up para MA.",
                                  "learningObjective": "Compreender os insumos necessários para o cálculo do AIC em ARIMA.",
                                  "commonMistakes": "Contar incorretamente k (esquecer variância σ² ou constantes de intercepto)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a soma dos quadrados dos resíduos (RSS)",
                                  "subSteps": [
                                    "Some os quadrados de todos os resíduos: RSS = Σ ε_t² para t=1 a n.",
                                    "Use fórmula manual ou função soma em planilha/software.",
                                    "Confirme o cálculo dividindo RSS por n para uma estimativa inicial de variância.",
                                    "Registre o valor de RSS com precisão decimal.",
                                    "Compare com output de software para validação parcial."
                                  ],
                                  "verification": "RSS calculado manualmente coincide com soma( residuals^2 ) no software.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Lista de resíduos; calculadora, Excel ou Python (numpy.sum(residuals**2)).",
                                  "tips": "Arredonde resíduos para 4 casas decimais antes de quadrado para evitar erros de precisão.",
                                  "learningObjective": "Dominar o cálculo da RSS como base para variância e likelihood.",
                                  "commonMistakes": "Incluir resíduos de warm-up inicial ou usar soma absoluta em vez de quadrados."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a log-verossimilhança (log L) assumindo normalidade",
                                  "subSteps": [
                                    "Calcule a variância dos resíduos: σ² = RSS / n.",
                                    "Compute log L = - (n/2) * log(2π σ²) - (n/2).",
                                    "Use log natural (ln) para todos os logs.",
                                    "Verifique se σ² > 0 e log definido.",
                                    "Salve o valor intermediário de log L."
                                  ],
                                  "verification": "log L calculado bate com fórmula em software como logLik() no R.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Valores de RSS e n; calculadora científica ou Python (scipy.log).",
                                  "tips": "Use approx. log(2π) ≈ 1.8379 para aceleração manual.",
                                  "learningObjective": "Aplicar a fórmula de likelihood gaussiana para resíduos de ARIMA.",
                                  "commonMistakes": "Usar σ em vez de σ² no log ou esquecer o fator -n/2."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a fórmula final do AIC",
                                  "subSteps": [
                                    "Calcule AIC = -2 * log L + 2 * k.",
                                    "Arredonde para 2 casas decimais conforme convenção.",
                                    "Compare com AIC reportado pelo software de ajuste ARIMA.",
                                    "Documente todos os valores intermediários para auditoria.",
                                    "Interprete: menor AIC indica melhor ajuste penalizado."
                                  ],
                                  "verification": "AIC manual igual ao AIC do modelo em software (ex: summary(arima_model)$aic).",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Valores de log L e k; papel para anotações.",
                                  "tips": "Memorize AIC = n log(2π σ²) + n + 2k como forma equivalente para verificação rápida.",
                                  "learningObjective": "Executar o cálculo completo do AIC e interpretá-lo.",
                                  "commonMistakes": "Esquecer o sinal negativo em -2 log L ou usar k incorreto."
                                }
                              ],
                              "practicalExample": "Para um modelo ARIMA(1,0,0) ajustado a série de temperaturas mensais (n=50, resíduos médios 0, RSS=120.5, σ²=2.41, k=2): log L ≈ - (50/2)*log(2π*2.41) -25 ≈ -92.3; AIC = -2*(-92.3) + 4 ≈ 180.6. Verifique com R: arima(data, order=c(1,0,0))$aic.",
                              "finalVerifications": [
                                "AIC manual coincide com output de software até 0.01 de diferença.",
                                "Todos os intermediários (RSS, σ², log L) documentados e corretos.",
                                "k contado precisamente incluindo variância.",
                                "Resíduos usados são os condicionais corretos para ARIMA.",
                                "Interpretação: AIC usado para comparar com outro modelo."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de RSS e σ² (erro <1%).",
                                "Correta aplicação da fórmula de log L gaussiana.",
                                "Contagem exata de k e aplicação em AIC.",
                                "Validação cruzada com software.",
                                "Documentação clara de passos e valores.",
                                "Interpretação contextual em séries temporais."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em Python/R para automação.",
                                "Matemática: Logaritmos e distribuições normais.",
                                "Machine Learning: Seleção de hiperparâmetros em modelos de previsão.",
                                "Economia: Modelagem de séries financeiras como PIB."
                              ],
                              "realWorldApplication": "Em previsão de demanda de produtos, calcular AIC manualmente para validar software e selecionar o melhor ARIMA entre candidatos, otimizando estoque e reduzindo custos em supply chain."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.3.1.3",
                            "name": "Interpretar valores de AIC",
                            "description": "Analisar e comparar valores de AIC entre diferentes ordens de modelos (p,d,q) para selecionar o que minimiza o critério em contextos de previsão automática.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito e a Fórmula do AIC",
                                  "subSteps": [
                                    "Estude a fórmula do AIC: AIC = -2 * log(L) + 2 * k, onde L é a verossimilhança e k o número de parâmetros.",
                                    "Identifique os componentes: penalização pela complexidade do modelo (2k) e ajuste aos dados (-2 log L).",
                                    "Explique verbalmente por que AIC equilibra goodness-of-fit e parcimônia.",
                                    "Compare conceitualmente AIC com critérios semelhantes como BIC.",
                                    "Resuma em suas palavras o objetivo: selecionar o modelo preditivo mais eficiente."
                                  ],
                                  "verification": "Escreva a fórmula do AIC e explique cada termo em uma frase curta.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de ARIMA no R/Python",
                                    "Artigo introdutório sobre AIC (ex: Wikipedia ou tutorial Statsmodels)"
                                  ],
                                  "tips": "Visualize a trade-off com um gráfico conceitual: eixo X complexidade, Y erro de ajuste.",
                                  "learningObjective": "Compreender matematicamente como o AIC penaliza modelos sobreparametrizados.",
                                  "commonMistakes": [
                                    "Confundir AIC com erro quadrático médio (MSE)",
                                    "Ignorar a penalização por parâmetros extras"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Obter Valores de AIC para Diferentes Ordens de Modelos (p,d,q)",
                                  "subSteps": [
                                    "Prepare um dataset de série temporal (ex: AirPassengers no R).",
                                    "Ajuste múltiplos modelos ARIMA com variações de p (0-3), d (0-2), q (0-3) usando auto.arima ou grid search.",
                                    "Extraia o valor de AIC de cada modelo ajustado (summary(modelo)$aic no R).",
                                    "Registre em uma tabela: p, d, q, AIC, número de parâmetros.",
                                    "Verifique se os modelos convergiram sem warnings."
                                  ],
                                  "verification": "Crie uma tabela com pelo menos 6 modelos e seus AICs calculados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "R ou Python com pacotes forecast/statsmodels",
                                    "Dataset exemplo: AirPassengers ou vendas mensais"
                                  ],
                                  "tips": "Use loops ou funções como expand.grid para automatizar o fitting e evitar trabalho manual.",
                                  "learningObjective": "Extrair e registrar AICs de forma sistemática para múltiplos candidatos de modelo.",
                                  "commonMistakes": [
                                    "Ajustar modelos inválidos (d>2)",
                                    "Ignorar stationarity antes do fitting"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar e Ordenar Valores de AIC",
                                  "subSteps": [
                                    "Ordene a tabela de modelos em ordem crescente de AIC.",
                                    "Calcule diferenças de AIC em relação ao menor (ΔAIC = AIC_i - min(AIC)).",
                                    "Interprete: modelos com ΔAIC < 2 são substancialmente similares; 4-7 moderadamente diferentes; >10 improváveis.",
                                    "Discuta trade-offs: modelo com AIC menor mas mais parâmetros pode ser preferível se ΔAIC pequeno.",
                                    "Plote AIC vs. complexidade (k) para visualização."
                                  ],
                                  "verification": "Identifique o top 3 modelos e justifique com ΔAIC.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha Excel/Google Sheets ou pandas DataFrame",
                                    "Biblioteca ggplot2/matplotlib para plot"
                                  ],
                                  "tips": "Regra prática: priorize o menor AIC, mas valide com resíduos.",
                                  "learningObjective": "Aplicar regras empíricas para ranking de modelos baseado em AIC.",
                                  "commonMistakes": [
                                    "Selecionar apenas pelo menor AIC sem considerar ΔAIC",
                                    "Confundir ranking crescente/decrescente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar a Seleção e Considerar Limitações",
                                  "subSteps": [
                                    "Selecione o modelo com menor AIC e refaça o forecast para validação.",
                                    "Analise resíduos do modelo selecionado (plots de ACF, Ljung-Box test).",
                                    "Discuta limitações: AIC assume normalidade gaussiana, amostras grandes.",
                                    "Compare previsão out-of-sample se dados disponíveis.",
                                    "Documente decisão em relatório curto: 'Modelo ARIMA(p,d,q) selecionado por AIC=valor'."
                                  ],
                                  "verification": "Escreva um parágrafo justificando a escolha final com evidências.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código de forecast e checkresiduals",
                                    "Templates de relatório"
                                  ],
                                  "tips": "Sempre valide com BIC ou CV para robustez.",
                                  "learningObjective": "Interpretar AIC no contexto completo de seleção de modelo e previsão.",
                                  "commonMistakes": [
                                    "Overfitting ao menor AIC sem validação",
                                    "Ignorar suposições do AIC"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando o dataset AirPassengers (passageiros aéreos mensais 1949-1960), ajuste ARIMA(0,1,1), ARIMA(1,1,1), ARIMA(2,1,2). AICs: 579.2, 578.5, 582.1. Selecione ARIMA(1,1,1) por menor AIC, interprete ΔAIC=0.7 e 3.6 como suporte à escolha, e gere previsões para 1961.",
                              "finalVerifications": [
                                "Ordena corretamente modelos por AIC crescente.",
                                "Calcula e interpreta ΔAIC para top 3 modelos.",
                                "Explica trade-off entre ajuste e complexidade.",
                                "Valida seleção com análise de resíduos.",
                                "Justifica escolha em contexto de previsão automática.",
                                "Identifica limitações do AIC em cenários reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na extração e cálculo de AIC (100% correto).",
                                "Qualidade da comparação quantitativa (ΔAIC e ranking).",
                                "Profundidade da interpretação (trade-offs e limitações).",
                                "Uso adequado de visualizações e validações.",
                                "Clareza no relatório final de seleção.",
                                "Aplicação correta em exemplo prático."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização e funções de verossimilhança.",
                                "Programação: Automação de grid search em R/Python.",
                                "Economia/Negócios: Previsão de demanda e séries financeiras.",
                                "Ciência de Dados: Validação de modelos e feature selection.",
                                "Estatística Inferencial: Testes de hipóteses em resíduos."
                              ],
                              "realWorldApplication": "Em empresas de varejo, selecionar o melhor modelo ARIMA para prever vendas futuras minimizando AIC, otimizando estoque e reduzindo custos operacionais em cenários de previsão automática de demanda sazonal."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.3.1.4",
                            "name": "Implementar AIC em R",
                            "description": "Usar a função AIC() no pacote forecast ou stats em R para calcular e comparar AIC em modelos ARIMA ajustados a dados reais de séries temporais financeiras.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambiente R e carregar dados de séries temporais financeiras",
                                  "subSteps": [
                                    "Instale e carregue os pacotes necessários: forecast e stats.",
                                    "Baixe um dataset real de séries temporais financeiras, como preços diários de ações do Yahoo Finance via quantmod.",
                                    "Converta os dados em objeto ts() com frequência apropriada (ex: daily = 252).",
                                    "Visualize a série com plot() e ggtsdisplay() para entender padrões.",
                                    "Verifique estacionariedade com testes como ADF (pacote tseries)."
                                  ],
                                  "verification": "Ambiente configurado se pacotes carregados sem erros e plot da série exibido corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "R e RStudio",
                                    "Pacotes: forecast, stats, quantmod, tseries",
                                    "Dataset: ex: ^GSPC (S&P500)"
                                  ],
                                  "tips": "Use getSymbols() para dados automáticos; defina Sys.setenv(TZ='UTC') para evitar warnings de timezone.",
                                  "learningObjective": "Preparar ambiente e dados reais para análise ARIMA.",
                                  "commonMistakes": [
                                    "Esquecer de converter para ts()",
                                    "Usar frequência errada (ex: monthly em dados diários)",
                                    "Ignorar missing values com na.omit()"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar e preparar dados para modelagem ARIMA",
                                  "subSteps": [
                                    "Aplique log() ou diff() para estabilizar variância se necessário.",
                                    "Identifique ordens p, d, q provisórias via ACF/PACF plots.",
                                    "Use auto.arima() uma vez para baseline, mas evite para foco manual.",
                                    "Divida dados em treino/teste (ex: 80/20).",
                                    "Salve dados preparados em variáveis claras como train_ts."
                                  ],
                                  "verification": "Dados preparados se ACF/PACF mostram decaimento rápido e sem missing values.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Funções: ACF(), PACF(), log(), diff()",
                                    "Gráficos: autoplot() do ggfortify"
                                  ],
                                  "tips": "Sempre plote resíduos residuais iniciais para guiar ordens.",
                                  "learningObjective": "Preparar série temporal financeira para ajuste ARIMA manual.",
                                  "commonMistakes": [
                                    "Não diferenciar o suficiente (d alto)",
                                    "Ignorar sazonalidade em finanças (SARIMA se weekly)",
                                    "Sobreajuste precoce"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Ajustar múltiplos modelos ARIMA",
                                  "subSteps": [
                                    "Ajuste ARIMA(1,1,1) com arima(train_ts, order=c(1,1,1)).",
                                    "Ajuste ARIMA(2,1,2) e outro como ARIMA(0,1,1) para comparação.",
                                    "Use método 'ML' para máxima verossimilhança.",
                                    "Extraia summary() de cada modelo e verifique coeficientes significativos.",
                                    "Armazene modelos em lista: models <- list(model1, model2)."
                                  ],
                                  "verification": "Modelos ajustados se summary() mostra convergência e resíduos brancos (Ljung-Box test).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Função arima()",
                                    "Parâmetros order=c(p,d,q)"
                                  ],
                                  "tips": "Comece com ordens baixas; use stepwise=FALSE em auto.arima para inspiração.",
                                  "learningObjective": "Ajustar ARIMA variados para comparação via AIC.",
                                  "commonMistakes": [
                                    "Especificar ordens inválidas (p+d+q >10)",
                                    "Não checar sigma^2",
                                    "Ignorar warnings de não-convergência"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular AIC usando funções AIC()",
                                  "subSteps": [
                                    "Calcule AIC(model1) e AIC(model2) diretamente.",
                                    "Compare valores: menor AIC indica melhor modelo penalizado.",
                                    "Use deltaAIC = AIC(model) - min(AIC) para ranking.",
                                    "Extraia com attributes(AIC(model))$df para graus de liberdade.",
                                    "Crie tabela com modelo, AIC, BIC para visualização."
                                  ],
                                  "verification": "AIC calculados se valores numéricos finitos e ordenados corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Função AIC() do stats",
                                    "cbind() para tabela"
                                  ],
                                  "tips": "AIC() funciona em qualquer lm/arima; prefira forecast::AIC para consistência.",
                                  "learningObjective": "Aplicar AIC() para quantificar qualidade de modelos.",
                                  "commonMistakes": [
                                    "Confundir AIC com logLik()",
                                    "Interpretar AIC absoluto sem comparação",
                                    "Usar AICc sem n pequeno"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Comparar AICs, selecionar e validar modelo",
                                  "subSteps": [
                                    "Selecione modelo com menor AIC.",
                                    "Gere forecasts() no teste e plote com confiança.",
                                    "Calcule MAE/RMSE no teste para validar.",
                                    "Interprete: ΔAIC <2 similar, 4-7 moderado, >10 diferente.",
                                    "Documente escolha em relatório com tabela AIC."
                                  ],
                                  "verification": "Modelo selecionado se forecast no teste com RMSE razoável (<5% erro médio).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "forecast()",
                                    "accuracy()",
                                    "plot()"
                                  ],
                                  "tips": "Combine AIC com BIC para robustez; cheque overfitting com CV.",
                                  "learningObjective": "Usar AIC para seleção final e aplicação prática.",
                                  "commonMistakes": [
                                    "Selecionar só por AIC sem validação out-of-sample",
                                    "Ignorar multicolinearidade em ARIMA",
                                    "Não reportar incertezas"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dados diários do S&P500 (^GSPC) de 2020-2023: ajuste ARIMA(1,1,1), ARIMA(2,1,1), ARIMA(1,1,2); calcule AICs (ex: 2450.2, 2448.5, 2452.1); selecione ARIMA(2,1,1) com menor AIC para prever retornos semanais.",
                              "finalVerifications": [
                                "AIC calculado corretamente para todos modelos sem NA.",
                                "Modelo com menor AIC selecionado e justificado.",
                                "Tabela comparativa criada com AIC e deltaAIC.",
                                "Forecasts gerados e plotados com intervalos de confiança.",
                                "Validação com accuracy() no conjunto de teste.",
                                "Relatório breve com interpretação de ΔAIC."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo AIC (erro <0.1).",
                                "Número adequado de modelos comparados (≥3).",
                                "Interpretação correta de AIC (menor=melhor, penaliza complexidade).",
                                "Código R reproduzível e comentado.",
                                "Validação out-of-sample com métricas.",
                                "Visualizações claras (plots de AIC, forecasts)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Inferência em séries temporais (ARIMA).",
                                "Programação: Manipulação de dados em R (tidyverse/forecast).",
                                "Finanças: Previsão de ativos e risco (VaR via ARIMA).",
                                "Matemática: Otimização e critérios de informação (MLE).",
                                "Machine Learning: Seleção de modelos (análoga a CV)."
                              ],
                              "realWorldApplication": "Em bancos de investimento, AIC seleciona ARIMA ótimo para prever volatilidade de ações, otimizando portfólios e hedges; ex: Goldman Sachs usa critérios semelhantes para trading algorítmico em séries financeiras."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.3.2",
                        "name": "Critério de Informação Bayesiano (BIC)",
                        "description": "O Critério de Informação Bayesiano (BIC), também conhecido como SBC, impõe uma penalidade mais forte por parâmetros extras do que o AIC, favorecendo modelos mais parcimoniosos em grandes amostras de séries temporais.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.3.2.1",
                            "name": "Definir a fórmula do BIC",
                            "description": "Descrever a fórmula BIC = -2 * log(L) + k * log(n), destacando a dependência do tamanho da amostra n e sua vantagem sobre AIC para seleção em séries temporais longas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais da Verossimilhança e Parâmetros",
                                  "subSteps": [
                                    "Defina verossimilhança (L) como a probabilidade dos dados observados dado o modelo.",
                                    "Identifique k como o número de parâmetros estimáveis no modelo.",
                                    "Explique n como o tamanho da amostra (número de observações).",
                                    "Discuta como n afeta a complexidade do modelo em grandes datasets.",
                                    "Esboce um exemplo simples de L para uma distribuição normal."
                                  ],
                                  "verification": "Escreva definições curtas para L, k e n, e calcule n para um dataset de 100 observações.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, tabela de dados de exemplo (ex: série temporal de temperaturas).",
                                  "tips": "Use analogias: L é quão 'bem o modelo explica os dados', k conta 'ingredientes livres'.",
                                  "learningObjective": "Compreender os componentes L, k e n na fórmula de critérios de informação.",
                                  "commonMistakes": "Confundir L com probabilidade simples; esquecer que k inclui intercepto em regressões."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender o Critério AIC e Suas Limitações",
                                  "subSteps": [
                                    "Recite a fórmula AIC = -2 log(L) + 2k.",
                                    "Compare com BIC: note a penalidade fixa (2k) vs. crescente (log(n)).",
                                    "Simule com n pequeno (ex: 50): AIC favorece modelos complexos.",
                                    "Simule com n grande (ex: 1000): AIC ainda subestima complexidade.",
                                    "Discuta viés em séries temporais longas onde n é alto."
                                  ],
                                  "verification": "Calcule AIC para um modelo com L=-100, k=3 e compare penalidades.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora ou planilha Excel/Google Sheets.",
                                  "tips": "AIC é como 'penalidade por quarto extra na casa', mas BIC ajusta pelo 'tamanho da casa' (n).",
                                  "learningObjective": "Identificar limitações do AIC para justificar a necessidade do BIC.",
                                  "commonMistakes": "Esquecer o fator -2 em log(L); achar que AIC é sempre melhor."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Memorizar e Derivar a Fórmula do BIC",
                                  "subSteps": [
                                    "Escreva BIC = -2 log(L) + k log(n).",
                                    "Derive intuitivamente: penalidade cresce com log(n) pela aproximação bayesiana.",
                                    "Pratique recitando: destaque dependência de n.",
                                    "Calcule log(n) para n=100 (≈4.605), n=1000 (≈6.908).",
                                    "Explique vantagem em séries temporais longas: penaliza mais overfit."
                                  ],
                                  "verification": "Recite a fórmula de cor e compute BIC para L=-100, k=3, n=100.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel, calculadora científica para log natural.",
                                  "tips": "Mnemonic: BIC = 'Bayes Ian Criterion' com log(n) para 'amostras grandes'.",
                                  "learningObjective": "Dominar a fórmula exata do BIC e sua derivação conceitual.",
                                  "commonMistakes": "Usar log10 em vez de ln; inverter sinal de log(L)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar BIC vs. AIC em Exemplo Prático",
                                  "subSteps": [
                                    "Gere dataset simples de série temporal (ex: AR(1) vs. AR(2)).",
                                    "Calcule L, k para ambos modelos.",
                                    "Compute AIC e BIC para n=500.",
                                    "Observe: BIC seleciona modelo mais simples que AIC.",
                                    "Conclua vantagem BIC para n grande em previsões."
                                  ],
                                  "verification": "Tabela comparativa com valores numéricos mostrando BIC > AIC em penalidade.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software R/Python (pacote forecast ou statsmodels), dataset exemplo.",
                                  "tips": "Use funções prontas como BIC() em R para validar cálculos manuais.",
                                  "learningObjective": "Aplicar fórmula BIC para demonstrar superioridade sobre AIC.",
                                  "commonMistakes": "Ignorar dependência de autocorrelação em séries temporais."
                                }
                              ],
                              "practicalExample": "Em uma série temporal de vendas mensais (n=120 observações), compare ARIMA(1,1,1) (k=2, log(L)=-500) vs. ARIMA(2,1,1) (k=3, log(L)=-495). AIC favorece o segundo (AIC1=1004, AIC2=1002), mas BIC penaliza mais (BIC1=1013, BIC2=1014), selecionando o primeiro para evitar overfit em dados longos.",
                              "finalVerifications": [
                                "Recitar corretamente BIC = -2 log(L) + k log(n).",
                                "Explicar dependência de n em 1 frase.",
                                "Calcular BIC manualmente para valores dados (erro <1%).",
                                "Comparar BIC vs. AIC para n=1000.",
                                "Identificar vantagem em séries temporais longas.",
                                "Aplicar em exemplo com k=4, n=200."
                              ],
                              "assessmentCriteria": [
                                "Precisão na fórmula (100% exata).",
                                "Compreensão conceitual de L, k, n (explicação clara).",
                                "Cálculo correto com log natural.",
                                "Comparação qualitativa/quantitativa com AIC.",
                                "Reconhecimento de viés em n grande.",
                                "Aplicação contextual em séries temporais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Logaritmos naturais e aproximações assintóticas.",
                                "Programação: Implementação em R (BIC()) ou Python (statsmodels).",
                                "Economia: Seleção de modelos para previsão de PIB ou ações.",
                                "Física: Análise de séries temporais em dados climáticos."
                              ],
                              "realWorldApplication": "Em bancos centrais, BIC seleciona modelos ARIMA para previsão de inflação em séries longas (n>500), evitando overfit e melhorando precisão de políticas monetárias."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.3.2.2",
                            "name": "Calcular o BIC para modelos ARIMA",
                            "description": "Computar BIC manualmente para diferentes especificações de modelos ARIMA em séries não estacionárias diferenciadas, comparando com AIC.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a Série Temporal e Verificar Estacionariedade",
                                  "subSteps": [
                                    "Carregue um dataset de série temporal não estacionária (ex: AirPassengers em Python com statsmodels).",
                                    "Realize o teste de Dickey-Fuller Aumentado (ADF) para confirmar não estacionariedade.",
                                    "Aplique diferenciação de primeira ou segunda ordem até que o teste ADF rejeite a hipótese nula (p-value < 0.05).",
                                    "Plote a série original e diferenciada para visual inspeção.",
                                    "Salve a série diferenciada como variável para modelagem."
                                  ],
                                  "verification": "Teste ADF na série diferenciada mostra p-value < 0.05 e gráfico sem tendência clara.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python com bibliotecas pandas, statsmodels.tsa e matplotlib",
                                    "Dataset exemplo: AirPassengers ou série similar"
                                  ],
                                  "tips": [
                                    "Comece com uma diferenciação; evite overdifferencing checando resíduos.",
                                    "Use auto_arima para inspiração inicial, mas ajuste manualmente."
                                  ],
                                  "learningObjective": "Preparar corretamente séries não estacionárias para ajuste de modelos ARIMA.",
                                  "commonMistakes": [
                                    "Ignorar testes de estacionariedade.",
                                    "Diferenciar excessivamente, criando não estacionariedade nos resíduos.",
                                    "Não plotar para validação visual."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Especificar e Ajustar Modelos ARIMA Candidatos",
                                  "subSteps": [
                                    "Defina um grid de especificações: ARIMA(p,d,q) com p=0-2, d=1 (pré-diferenciado), q=0-2.",
                                    "Ajuste cada modelo usando SARIMAX ou ARIMA do statsmodels, fixando d=0 na função pois já diferenciou.",
                                    "Extraia para cada modelo: log-likelihood (logL), número de parâmetros (k = p + q + 1 para constante).",
                                    "Registre o número de observações efetivas (n = len(série_diferenciada) - warm-up).",
                                    "Salve outputs em uma tabela comparativa."
                                  ],
                                  "verification": "Todos modelos ajustados sem erros de convergência; logL e k extraídos corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python statsmodels.tsa.arima.model.ARIMA",
                                    "Jupyter Notebook para tabelas"
                                  ],
                                  "tips": [
                                    "Inclua intercepto se necessário; monitore warnings de convergência.",
                                    "Use loop for para grid search eficiente."
                                  ],
                                  "learningObjective": "Ajustar múltiplas especificações ARIMA e extrair métricas essenciais para critérios de informação.",
                                  "commonMistakes": [
                                    "Esquecer de contar k corretamente (inclui sigma^2).",
                                    "Usar n incorreto (ignorar perdas por diferenciação).",
                                    "Ajustar em série não diferenciada."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular BIC e AIC Manualmente para Cada Modelo",
                                  "subSteps": [
                                    "Lembre a fórmula BIC: BIC = -2 * logL + k * log(n).",
                                    "Calcule AIC para comparação: AIC = -2 * logL + 2 * k.",
                                    "Compute valores numéricos para cada modelo usando logL, k e n extraídos.",
                                    "Compare com valores automáticos do modelo.summary() para validação.",
                                    "Registre todos os valores em uma tabela com modelo, AIC, BIC."
                                  ],
                                  "verification": "Cálculos manuais coincidem com outputs do software (diferença < 0.01).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou Python numpy.log para log(n)",
                                    "Tabela Excel ou pandas DataFrame"
                                  ],
                                  "tips": [
                                    "Use np.log(n) no Python para precisão.",
                                    "Arredonde para 2 casas decimais para comparação."
                                  ],
                                  "learningObjective": "Aplicar fórmulas exatas de BIC e AIC manualmente a partir de outputs de ajuste.",
                                  "commonMistakes": [
                                    "Confundir logL máximo com RSS.",
                                    "Usar log(n-1) em vez de log(n).",
                                    "Esquecer penalização log(n) no BIC."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Critérios e Selecionar o Melhor Modelo",
                                  "subSteps": [
                                    "Identifique o modelo com menor BIC (penaliza mais complexidade que AIC).",
                                    "Compare BIC vs AIC: BIC favorece modelos mais parcimoniosos em amostras finitas.",
                                    "Valide seleção plotando resíduos do modelo escolhido (Ljung-Box test p>0.05).",
                                    "Documente razões para escolha (ex: BIC menor em 10 unidades indica superioridade forte).",
                                    "Teste previsões curtas para confirmação prática."
                                  ],
                                  "verification": "Modelo selecionado tem menor BIC; resíduos brancos (ACF próximo de zero).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "statsmodels diagnostics para resíduos",
                                    "Gráficos ACF/PACF"
                                  ],
                                  "tips": [
                                    "Diferença BIC > 10 é evidência forte; <2 é fraca.",
                                    "Sempre cheque resíduos pós-seleção."
                                  ],
                                  "learningObjective": "Interpretar e usar BIC para seleção automática de modelos ARIMA, comparando com AIC.",
                                  "commonMistakes": [
                                    "Selecionar por AIC ignorando BIC para amostras pequenas.",
                                    "Não validar resíduos do modelo escolhido.",
                                    "Ignorar diferenças significativas entre critérios."
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dataset AirPassengers (n=132 após diff=1), ajuste ARIMA(1,1,1): logL ≈ -335.5, k=3; BIC = -2*(-335.5) + 3*log(131) ≈ 689.2. ARIMA(2,1,1): logL ≈ -332.1, k=4; BIC ≈ 692.5. BIC menor seleciona ARIMA(1,1,1). AIC seria 671.0 vs 674.2, similar mas BIC penaliza mais o (2,1,1).",
                              "finalVerifications": [
                                "BIC calculado manualmente coincide com software para todos modelos.",
                                "Modelo com menor BIC identificado corretamente.",
                                "Comparação BIC vs AIC documentada com interpretações.",
                                "Resíduos do modelo selecionado passam em testes de brancura.",
                                "Tabela comparativa completa com logL, k, n, AIC, BIC.",
                                "Seleção consistente com melhores práticas para séries diferenciadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de BIC/AIC (erro absoluto < 0.01).",
                                "Correta extração e contagem de k (parâmetros + variância).",
                                "Validação de estacionariedade e resíduos adequada.",
                                "Interpretação qualitativa da comparação BIC/AIC.",
                                "Eficiência no grid search (cobertura relevante sem excesso).",
                                "Documentação clara da tabela comparativa."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python/R com statsmodels/forecast.",
                                "Matemática: Estatística assintótica, log-likelihood e penalizações.",
                                "Econometria: Seleção de modelos em séries financeiras.",
                                "Machine Learning: Critérios de informação em autoML para time series.",
                                "Negócios: Forecasting em vendas e demanda."
                              ],
                              "realWorldApplication": "Em finanças, calcular BIC para selecionar ARIMA ótimo em previsões de retornos de ações, evitando overfitting em dados limitados; em supply chain, otimizar modelos para demanda sazonal diferenciada, melhorando estoque e reduzindo custos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.3.2.3",
                            "name": "Interpretar BIC em seleção de modelos",
                            "description": "Avaliar quando BIC seleciona modelos mais simples que AIC, ilustrando com exemplos de previsão em séries sazonais de marketing.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar fórmulas e diferenças entre AIC e BIC",
                                  "subSteps": [
                                    "Estude a fórmula do AIC: AIC = -2 * log(L) + 2 * k, onde L é a verossimilhança e k o número de parâmetros.",
                                    "Estude a fórmula do BIC: BIC = -2 * log(L) + k * log(n), onde n é o tamanho da amostra.",
                                    "Compare as penalizações: AIC penaliza linearmente com k, BIC com k * log(n), favorecendo modelos mais simples em amostras grandes.",
                                    "Identifique que BIC é mais conservador que AIC em datasets grandes.",
                                    "Anote exemplos numéricos simples para ilustrar diferenças."
                                  ],
                                  "verification": "Escreva as fórmulas corretas e explique em 2-3 frases por que BIC penaliza mais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação de AIC/BIC (ex: Wikipedia ou stats textbooks), caderno de notas.",
                                  "tips": "Use um simulador online de critérios de informação para visualizar penalizações.",
                                  "learningObjective": "Compreender matematicamente por que BIC seleciona modelos mais parcimoniosos.",
                                  "commonMistakes": "Confundir log(L) com RSS; ignorar o papel de n no BIC."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar dataset de séries sazonais de marketing",
                                  "subSteps": [
                                    "Carregue um dataset sazonal de vendas de marketing (ex: vendas mensais de sorvete com picos de verão).",
                                    "Visualize a série temporal com plots de linha e decomposição sazonal usando Python/R.",
                                    "Teste estacionariedade com testes como ADF e identifique componentes sazonais.",
                                    "Divida em treino/teste (80/20).",
                                    "Gere modelos candidatos: ARIMA simples vs. com sazonalidade (SARIMA)."
                                  ],
                                  "verification": "Crie gráficos da série e relatório de testes de estacionariedade com p-valores.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python (statsmodels, pandas), R, dataset público (ex: Kaggle AirPassengers adaptado para marketing).",
                                  "tips": "Use `seasonal_decompose` no statsmodels para visualizar tendências/sazonalidade rapidamente.",
                                  "learningObjective": "Preparar dados reais para demonstrar seleção de modelos em contextos sazonais.",
                                  "commonMistakes": "Não diferenciar tendência de sazonalidade; usar dataset não sazonal."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Ajustar modelos e calcular AIC/BIC",
                                  "subSteps": [
                                    "Ajuste 3-5 modelos: ARIMA(1,1,1), SARIMA(1,1,1)(1,1,1)12, modelo mais complexo com mais lags.",
                                    "Calcule AIC e BIC para cada modelo usando funções built-in (ex: model.aic, model.bic).",
                                    "Registre valores em uma tabela comparativa.",
                                    "Selecione o melhor modelo por AIC e por BIC separadamente.",
                                    "Observe se BIC escolhe modelo mais simples (menos parâmetros)."
                                  ],
                                  "verification": "Tabela com AIC/BIC para cada modelo e modelos selecionados por cada critério.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Jupyter Notebook ou R script, bibliotecas statsmodels/forecast.",
                                  "tips": "Automatize com loop sobre grids de parâmetros para eficiência.",
                                  "learningObjective": "Aplicar critérios para seleção automática em séries sazonais.",
                                  "commonMistakes": "Ajustar overfitting sem penalização; ignorar convergência do modelo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados e ilustrar diferenças",
                                  "subSteps": [
                                    "Compare previsões in-sample/out-of-sample dos modelos selecionados por AIC vs. BIC.",
                                    "Explique por que BIC prefere simplicidade: penalização log(n) em n grande favorece menos k.",
                                    "Ilustre com plot de previsões e resíduos.",
                                    "Discuta trade-off: AIC pode overfit, BIC underfit mas generaliza melhor.",
                                    "Conclua com quando usar cada um em marketing sazonal."
                                  ],
                                  "verification": "Relatório escrito com explicação, plots e conclusão sobre seleção BIC vs. AIC.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Mesmo notebook, matplotlib/ggplot para plots.",
                                  "tips": "Foque em RMSE de previsão para validar interpretações.",
                                  "learningObjective": "Interpretar BIC escolhendo modelos simples em cenários reais de marketing.",
                                  "commonMistakes": "Atribuir diferenças só a fórmulas sem contexto de n; generalizar sem dados."
                                }
                              ],
                              "practicalExample": "Em uma campanha de marketing para vendas sazonais de sorvetes (picos no verão), ajuste ARIMA e SARIMA em dados mensais de 5 anos (n=60). AIC seleciona SARIMA complexa (p=2,d=1,q=2)(1,1,1)12 com AIC=250, mas BIC escolhe ARIMA simples (1,1,1) com BIC=260, evitando overfitting em sazonalidade ruidosa.",
                              "finalVerifications": [
                                "Fórmulas de AIC e BIC recitadas corretamente.",
                                "Tabela de AIC/BIC para múltiplos modelos gerada.",
                                "BIC seleciona modelo com menos parâmetros que AIC no exemplo.",
                                "Plots de série, decomposição e previsões produzidos.",
                                "Explicação escrita da preferência do BIC por parcimônia.",
                                "Previsões comparadas com métricas como RMSE."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação matemática das diferenças AIC/BIC (30%).",
                                "Qualidade da preparação e visualização do dataset sazonal (20%).",
                                "Correção nos cálculos de critérios e seleções (25%).",
                                "Profundidade da interpretação com exemplos concretos (15%).",
                                "Clareza em relatórios, plots e conclusões (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Marketing: Previsão de demanda sazonal para campanhas.",
                                "Programação: Uso de Python/R para automação de modelagem.",
                                "Econometria: Seleção de modelos em forecasting econômico.",
                                "Matemática: Otimização e critérios de informação bayesianos."
                              ],
                              "realWorldApplication": "Em equipes de marketing digital, use BIC para selecionar modelos simples de previsão de tráfego sazonal em e-commerces, evitando overfitting em dados ruidosos de cliques/vendas, melhorando alocação de budgets publicitários."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.3.2.4",
                            "name": "Usar BIC em funções automáticas no R",
                            "description": "Aplicar BIC() ou auto.arima() com BIC na função forecast para seleção automática de melhores modelos em dados de operações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente R e carregar pacotes necessários",
                                  "subSteps": [
                                    "Instale o pacote 'forecast' executando install.packages('forecast') se não estiver instalado.",
                                    "Carregue a biblioteca com library(forecast).",
                                    "Carregue dados de exemplo de série temporal, como airpassengers ou crie um conjunto simulado de dados de operações (ex: vendas diárias).",
                                    "Converta os dados para objeto ts() com frequência apropriada (ex: ts(vendas, frequency=7) para dados semanais).",
                                    "Visualize a série com plot() para entender o padrão."
                                  ],
                                  "verification": "Confirme que o pacote forecast está carregado sem erros e a série temporal é plotada corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "R e RStudio instalados",
                                    "Pacote forecast",
                                    "Dados de série temporal (ex: dataset airpassengers)"
                                  ],
                                  "tips": "Sempre verifique a frequência dos dados para evitar erros em auto.arima().",
                                  "learningObjective": "Configurar ambiente R pronto para análise de séries temporais com forecast.",
                                  "commonMistakes": [
                                    "Esquecer de instalar o pacote antes de carregar",
                                    "Usar frequência incorreta no ts()",
                                    "Não visualizar os dados inicialmente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar auto.arima() com critério BIC para seleção automática de modelo",
                                  "subSteps": [
                                    "Execute fit <- auto.arima(ts_data, ic='bic') para selecionar o melhor modelo ARIMA baseado em BIC.",
                                    "Inspecione o modelo com summary(fit) para ver parâmetros selecionados e valor BIC.",
                                    "Compare com ic='aic' para entender diferenças: fit_aic <- auto.arima(ts_data, ic='aic').",
                                    "Verifique resíduos com checkresiduals(fit) para validar pressupostos.",
                                    "Extraia o valor BIC com fit$aic (adaptado para BIC via logLik e k)."
                                  ],
                                  "verification": "O summary() mostra um modelo ARIMA com p, d, q definidos e BIC reportado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Objeto ts_data preparado",
                                    "Função auto.arima() do pacote forecast"
                                  ],
                                  "tips": "BIC penaliza mais modelos complexos que AIC, favorecendo parcimônia em dados de operações.",
                                  "learningObjective": "Selecionar automaticamente o melhor modelo ARIMA usando BIC como critério.",
                                  "commonMistakes": [
                                    "Confundir ic='aic' com 'bic'",
                                    "Ignorar diagnóstico de resíduos",
                                    "Não especificar stepwise=FALSE para exploração manual"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar previsões com forecast() usando o modelo selecionado por BIC",
                                  "subSteps": [
                                    "Gere previsões: fc <- forecast(fit, h=12) para 12 períodos à frente.",
                                    "Plote as previsões com plot(fc) incluindo intervalos de confiança.",
                                    "Acesse componentes: fc$mean para valores previstos, fc$lower/upper para IC.",
                                    "Compare previsões BIC vs AIC plotando ambos.",
                                    "Calcule acurácia com accuracy(fc, test_data) se houver dados de teste."
                                  ],
                                  "verification": "Gráfico de forecast() exibe série original, previsões e intervalos sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Modelo fit de auto.arima()",
                                    "Função forecast()"
                                  ],
                                  "tips": "Ajuste h= para horizonte relevante em operações (ex: 30 dias de estoque).",
                                  "learningObjective": "Produzir previsões confiáveis a partir de modelo ARIMA otimizado por BIC.",
                                  "commonMistakes": [
                                    "Esquecer de especificar h=",
                                    "Interpretar IC como determinístico",
                                    "Não plotar para validação visual"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar e interpretar resultados com foco em BIC",
                                  "subSteps": [
                                    "Compare BIC de múltiplos modelos: menor BIC indica melhor ajuste penalizado.",
                                    "Calcule BIC manualmente: -2*logLik(fit) + log(n)*k onde n=length(ts_data), k=parametros.",
                                    "Teste estacionariedade com ndiffs(ts_data) e valide com Ljung-Box em resíduos.",
                                    "Documente trade-off: BIC vs performance em hold-out set.",
                                    "Salve resultados: write.csv(as.data.frame(fc), 'previsoes_BIC.csv')."
                                  ],
                                  "verification": "Relatório mostra BIC do modelo < BIC de alternativas e resíduos ok.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Modelo fit",
                                    "Funções summary(), checkresiduals()",
                                    "Dados de teste opcionais"
                                  ],
                                  "tips": "BIC é ideal para dados de operações com risco de overfitting em amostras finitas.",
                                  "learningObjective": "Interpretar BIC para validar seleção de modelo e previsões.",
                                  "commonMistakes": [
                                    "Confundir BIC com acurácia de previsão",
                                    "Ignorar tamanho da amostra em interpretação",
                                    "Não testar resíduos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma fábrica, use dados diários de produção (ts(producao, frequency=365)) de 2020-2023. Aplique auto.arima com BIC para prever produção dos próximos 30 dias, ajustando estoque e turnos com base em fc$mean.",
                              "finalVerifications": [
                                "auto.arima() seleciona modelo com BIC reportado e summary() sem erros.",
                                "forecast() gera previsões plotadas com IC 95%.",
                                "Resíduos passam em checkresiduals() (p-value >0.05).",
                                "BIC do modelo é menor que de um ARIMA manual (p=2,d=1,q=1).",
                                "Previsões salvas e interpretadas em contexto operacional.",
                                "Comparação AIC vs BIC mostra diferença lógica."
                              ],
                              "assessmentCriteria": [
                                "Correta configuração de ts() e auto.arima(ic='bic').",
                                "Interpretação precisa de BIC como critério de parcimônia.",
                                "Geração e plot de forecast() com h adequado.",
                                "Validação via resíduos e acurácia.",
                                "Aplicação prática em dados reais sem erros de código.",
                                "Documentação clara de passos e resultados."
                              ],
                              "crossCurricularConnections": [
                                "Programação em R (sintaxe, pacotes, debugging).",
                                "Estatística (modelos ARIMA, critérios de informação).",
                                "Gestão de Operações (previsão de demanda/estoque).",
                                "Matemática Aplicada (log-verossimilhança, penalização).",
                                "Análise de Dados (diagnóstico de modelos)."
                              ],
                              "realWorldApplication": "Em supply chain de varejo, usar BIC com auto.arima para prever vendas semanais, otimizando pedidos e reduzindo estoque ocioso em 15-20%, evitando overfitting comum em dados sazonais de operações."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.3.3",
                        "name": "Aplicação de Critérios na Seleção Automática",
                        "description": "Uso integrado de AIC, BIC e outros critérios (como HQIC) em algoritmos automáticos para escolher o melhor modelo de previsão sem intervenção manual, considerando estacionariedade e sazonalidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.3.3.1",
                            "name": "Comparar AIC, BIC e HQIC",
                            "description": "Explicar diferenças entre AIC, BIC e Hannan-Quinn (HQIC = -2*log(L) + 2k*log(log(n))), e quando cada um é preferível em séries temporais financeiras.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Componentes Comuns e Fórmulas dos Critérios",
                                  "subSteps": [
                                    "Defina os termos chave: L (log-verossimilhança máxima), k (número de parâmetros), n (tamanho da amostra).",
                                    "Escreva a fórmula exata do AIC: AIC = -2*log(L) + 2k.",
                                    "Escreva a fórmula do BIC: BIC = -2*log(L) + k*log(n).",
                                    "Escreva a fórmula do HQIC: HQIC = -2*log(L) + 2k*log(log(n)).",
                                    "Identifique o termo comum (-2*log(L)) e isole os termos de penalidade."
                                  ],
                                  "verification": "Liste corretamente as três fórmulas e seus componentes em um papel ou documento.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Calculadora",
                                    "Referência: Livro de séries temporais como 'Time Series Analysis' de Hamilton"
                                  ],
                                  "tips": "Sempre isole o termo de penalidade para visualizar diferenças; memorize AIC como 'leve', BIC como 'pesado com n'.",
                                  "learningObjective": "Dominar as fórmulas exatas e componentes compartilhados dos critérios AIC, BIC e HQIC.",
                                  "commonMistakes": [
                                    "Confundir log(n) com ln(n) no BIC (use ln(n))",
                                    "Esquecer o fator 2 no AIC e HQIC",
                                    "Ignorar que n deve ser > e^e ≈15.15 para HQIC definido"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar as Diferenças nas Penalidades de Complexidade",
                                  "subSteps": [
                                    "Compare as penalidades: AIC (2k fixa), BIC (k*ln(n) crescente com n), HQIC (2k*ln(ln(n)) crescente mais lento que BIC).",
                                    "Plote ou calcule numericamente as penalidades para k=1, n=50,100,500 (ex: AIC=2, BIC≈3.9/4.6/6.2, HQIC≈2.8/3.3/4.1).",
                                    "Discuta implicações: AIC penaliza menos complexidade, favorecendo modelos maiores; BIC/HQIC mais conservadores em amostras grandes.",
                                    "Calcule para um exemplo simples: L=-100, k=3, n=100; compare valores AIC/BIC/HQIC.",
                                    "Explique como penalidades afetam seleção: menor valor indica melhor trade-off."
                                  ],
                                  "verification": "Crie uma tabela comparativa de penalidades para diferentes n e k, confirmando que BIC > HQIC > AIC para n grande.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Planilha Excel/Google Sheets ou Python (numpy, matplotlib)",
                                    "Código simples: import numpy as np; pen_aic=2*k; pen_bic=k*np.log(n); etc."
                                  ],
                                  "tips": "Use gráficos de penalidade vs log(n) para visualização intuitiva; foque em n>100 típico em finanças.",
                                  "learningObjective": "Compreender quantitativamente como as penalidades diferem e evoluem com o tamanho da amostra.",
                                  "commonMistakes": [
                                    "Pensar que AIC é sempre melhor (ignora overfitting)",
                                    "Confundir ordem de magnitude: BIC cresce mais rápido",
                                    "Usar log10 em vez de ln (log natural)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Propriedades Teóricas e Comportamento Assintótico",
                                  "subSteps": [
                                    "Estude consistência: AIC não é consistente (selecionar ordem verdadeira assintoticamente), BIC é consistente.",
                                    "Analise HQIC: intermediário, consistente mais rápido que BIC em alguns casos, bom para ordens verdadeiras baixas.",
                                    "Discuta viés: AIC tende a underfit em n pequeno, overfit em n grande; BIC evita overfit em finanças voláteis.",
                                    "Revise literatura breve: AIC (Akaike 1974), BIC (Schwarz 1978), HQIC (Hannan-Quinn 1979).",
                                    "Compare em termos de risco: AIC minimiza erro de previsão médio; BIC minimiza probabilidade de modelo errado."
                                  ],
                                  "verification": "Resuma em bullet points as propriedades únicas de cada critério e cite uma referência para cada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Artigos originais (PDFs ou resumos online)",
                                    "Notebook Jupyter para simulações simples de consistência"
                                  ],
                                  "tips": "Pense em 'AIC para previsão, BIC para verdade'; simule Monte Carlo rápido se possível.",
                                  "learningObjective": "Diferenciar propriedades teóricas e quando cada critério é estatisticamente preferível.",
                                  "commonMistakes": [
                                    "Achar BIC sempre superior (não em n muito pequeno)",
                                    "Ignorar que HQIC é útil em dados com estrutura intermediária",
                                    "Confundir consistência com minimização de MSE"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Comparar em Contextos de Séries Temporais Financeiras",
                                  "subSteps": [
                                    "Identifique cenários: AIC para dados curtos/voláteis (ex: intraday trading); BIC para n grande (diários longos); HQIC como compromisso.",
                                    "Discuta finanças: Alta autocorrelação -> BIC para parcimônia; previsão de retornos -> AIC para flexibilidade.",
                                    "Calcule em dados reais: Use statsmodels em Python para ARIMA em retornos S&P500, compare critérios.",
                                    "Avalie trade-offs: BIC pode underfit volatilidade; AIC overfit ruído; HQIC balanceia.",
                                    "Conclua guidelines: Use BIC padrão em finanças; AIC para out-of-sample; HQIC em n médio."
                                  ],
                                  "verification": "Aplique a um dataset pequeno e justifique qual critério escolheria e por quê.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python/R com statsmodels/forecast",
                                    "Dataset: yfinance para '^GSPC' retornos diários últimos 5 anos"
                                  ],
                                  "tips": "Sempre valide com CV out-of-sample além de critérios; priorize BIC em finanças por conservadorismo.",
                                  "learningObjective": "Saber quando preferir cada critério em aplicações financeiras práticas.",
                                  "commonMistakes": [
                                    "Aplicar BIC em n<50 (penalidade excessiva)",
                                    "Ignorar estacionariedade prévia",
                                    "Escolher só pelo menor valor sem contexto"
                                  ]
                                }
                              ],
                              "practicalExample": "Baixe dados diários de retornos do S&P500 (yfinance). Fit ARIMA(1,0,0), ARIMA(2,0,0), ARIMA(3,0,0) com statsmodels.tsa.arima.model.ARIMA. Calcule AIC, BIC, HQIC para cada. Selecione o de menor BIC (ex: ARIMA(1,0,0) com BIC= -4500 vs ARIMA(3,0,0)= -4490), valide previsão 1-step ahead.",
                              "finalVerifications": [
                                "Escreva e compare corretamente as três fórmulas.",
                                "Explique por que BIC penaliza mais em n grande.",
                                "Dê um exemplo financeiro onde AIC seria preferido sobre BIC.",
                                "Calcule penalidades para n=200, k=4.",
                                "Justifique uso de HQIC como alternativa.",
                                "Descreva consistência de cada critério."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas fórmulas e cálculos (100% correto).",
                                "Correta interpretação de diferenças nas penalidades.",
                                "Adequada aplicação contextual em séries temporais financeiras.",
                                "Uso de exemplos práticos com código ou cálculos.",
                                "Identificação clara de trade-offs e preferências.",
                                "Conexão com propriedades teóricas.",
                                "Clareza na comunicação de quando usar cada um."
                              ],
                              "crossCurricularConnections": [
                                "Econometria: Seleção de lags em VAR/ARIMA.",
                                "Machine Learning: Analogia com regularização L1/L2 em modelagem preditiva.",
                                "Estatística Bayesiana: BIC como aproximação Bayesiana.",
                                "Finanças Quantitativas: Otimização de portfólios via previsão de covariâncias.",
                                "Computação Científica: Implementação em bibliotecas como statsmodels ou rugarch."
                              ],
                              "realWorldApplication": "Em trading algorítmico, use BIC para selecionar ordem ARIMA em séries de volatilidade GARCH de ações, evitando overfit em dados de alta frequência e melhorando precisão de Value-at-Risk (VaR) em bancos de investimento."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.3.3.2",
                            "name": "Implementar seleção automática com critérios",
                            "description": "Configurar funções como auto.arima() no R, especificando IC='aic' ou 'bic', e avaliar resultados em séries temporais reais de finanças e marketing.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente R e carregar dados de séries temporais reais",
                                  "subSteps": [
                                    "Instalar e carregar o pacote 'forecast' com install.packages('forecast') e library(forecast).",
                                    "Obter um dataset real de finanças (ex: preços de ações via quantmod) ou marketing (ex: vendas mensais).",
                                    "Converter os dados para objeto de série temporal (ts) usando ts() com frequência apropriada (12 para mensal).",
                                    "Visualizar a série com plot() e autoplot() para identificar tendências e sazonalidade.",
                                    "Verificar estacionariedade inicial com ndiffs() ou adf.test()."
                                  ],
                                  "verification": "Os dados estão carregados como objeto ts, plotados corretamente e estacionariedade básica verificada sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "RStudio ou R console",
                                    "Pacote 'forecast'",
                                    "Pacote 'quantmod' para dados financeiros",
                                    "Dataset exemplo: AirPassengers ou dados de ações reais"
                                  ],
                                  "tips": "Use dados reais baixados de Yahoo Finance para maior relevância; sempre defina start e frequency no ts().",
                                  "learningObjective": "Configurar um ambiente R pronto para análise automática de séries temporais com dados autênticos.",
                                  "commonMistakes": "Esquecer de instalar pacotes; definir frequência errada (ex: 12 para mensal); ignorar NA values nos dados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar auto.arima com critério AIC",
                                  "subSteps": [
                                    "Executar auto.arima(ts_data, ic='aic') para seleção automática baseada em AIC.",
                                    "Capturar o modelo resultante em uma variável: fit_aic <- auto.arima(...).",
                                    "Examinar summary(fit_aic) para ordens ARIMA selecionadas (p,d,q) e valor AIC.",
                                    "Gerar previsões com forecast(fit_aic, h=12) e plotar.",
                                    "Analisar resíduos com checkresiduals(fit_aic) para validar pressupostos."
                                  ],
                                  "verification": "Modelo ARIMA ajustado com AIC reportado, previsões plotadas e resíduos sem autocorrelação significativa (Ljung-Box p-value > 0.05).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "RStudio",
                                    "Objeto ts_data do step 1",
                                    "Pacote 'forecast'"
                                  ],
                                  "tips": "Especifique seasonal=TRUE se sazonalidade for esperada; use trace=TRUE para ver iterações.",
                                  "learningObjective": "Aplicar auto.arima com AIC para seleção automática de modelo ARIMA em séries temporais.",
                                  "commonMistakes": "Confundir ic='aic' com 'AIC' maiúsculo; não verificar resíduos; ignorar warnings sobre convergência."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar auto.arima com critério BIC e comparar resultados",
                                  "subSteps": [
                                    "Executar auto.arima(ts_data, ic='bic') e capturar em fit_bic <- auto.arima(...).",
                                    "Comparar summary(fit_aic) e summary(fit_bic), focando em ordens e valores de IC.",
                                    "Calcular previsões para ambos e comparar com accuracy(fit_aic) vs accuracy(fit_bic).",
                                    "Plotar previsões lado a lado usando autoplot com múltiplos modelos.",
                                    "Decidir o melhor modelo baseado no menor IC e métricas de precisão (MAE, RMSE)."
                                  ],
                                  "verification": "Ambos modelos executados, ICs comparados e tabela de accuracy gerada mostrando diferenças.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "RStudio",
                                    "Modelos do step anterior",
                                    "Pacote 'forecast'"
                                  ],
                                  "tips": "BIC penaliza mais complexidade que AIC; use aproximação='AICc' para amostras pequenas.",
                                  "learningObjective": "Comparar seleções automáticas usando AIC vs BIC e interpretar trade-offs.",
                                  "commonMistakes": "Usar o mesmo modelo sem reexecutar; confundir AIC menor com sempre melhor (considere BIC para parcimônia)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar e validar o modelo selecionado em contexto real",
                                  "subSteps": [
                                    "Aplicar o melhor modelo (ex: fit_aic) em dados de finanças/marketing reais.",
                                    "Gerar previsões de longo prazo (h=24) e intervalos de confiança.",
                                    "Testar out-of-sample: divida dados em train/test e compare previsões reais.",
                                    "Documentar insights: como o critério impactou a escolha do modelo.",
                                    "Exportar resultados com write.csv para relatório."
                                  ],
                                  "verification": "Previsões validadas out-of-sample com RMSE baixo, relatório gerado e insights documentados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "RStudio",
                                    "Modelos selecionados",
                                    "Dados train/test divididos"
                                  ],
                                  "tips": "Use window() para dividir séries; foque em aplicações práticas como previsão de vendas.",
                                  "learningObjective": "Validar seleção automática em cenários reais e comunicar resultados efetivamente.",
                                  "commonMistakes": "Não validar out-of-sample; superestimar precisão sem intervalos de confiança."
                                }
                              ],
                              "practicalExample": "Em um dataset de vendas mensais de produtos de marketing (ex: shampoo de AirPassengers adaptado), execute auto.arima com AIC para selecionar ARIMA(2,1,1)(1,1,1)[12], gere previsões para os próximos 12 meses e compare com BIC que seleciona um modelo mais parcimonioso, validando RMSE em hold-out set.",
                              "finalVerifications": [
                                "auto.arima executado corretamente com ic='aic' e 'bic' sem erros.",
                                "Ordens ARIMA, valores de IC e métricas de precisão reportados.",
                                "Previsões plotadas com resíduos brancos.",
                                "Comparação entre critérios mostra trade-off complexidade vs ajuste.",
                                "Validação out-of-sample com dados reais de finanças/marketing.",
                                "Relatório exportado com insights acionáveis."
                              ],
                              "assessmentCriteria": [
                                "Uso correto de parâmetros ic='aic'/'bic' em auto.arima (100%).",
                                "Interpretação precisa de summaries e resíduos (90%).",
                                "Comparação quantitativa de modelos (AIC, BIC, accuracy).",
                                "Aplicação em dados reais com validação out-of-sample.",
                                "Documentação clara de passos e decisões.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Programação em R (Ciência da Computação).",
                                "Estatística Inferencial e Testes de Hipóteses.",
                                "Finanças Quantitativas e Modelagem Econômica.",
                                "Análise de Marketing e Previsão de Demanda.",
                                "Machine Learning (seleção de hiperparâmetros automáticos)."
                              ],
                              "realWorldApplication": "Em finanças, automatizar previsão de retornos de ações para portfólios; em marketing, forecast de vendas sazonais para otimizar estoque e campanhas, reduzindo custos em 10-20% via modelos parcimoniosos selecionados por BIC."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.3.3.3",
                            "name": "Avaliar robustez da seleção automática",
                            "description": "Testar sensibilidade dos critérios a outliers e não-estacionariedade, validando previsões com hold-out em aplicações de operações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o Dataset com Outliers e Não-Estacionariedade",
                                  "subSteps": [
                                    "Selecionar uma série temporal real de aplicações operacionais, como demanda de estoque.",
                                    "Introduzir outliers artificialmente (ex: adicionar picos 3x maiores em 5% dos pontos).",
                                    "Induzir não-estacionariedade simulando quebras de tendência ou mudanças sazonais abruptas.",
                                    "Dividir o dataset em treino (80%) e hold-out (20%).",
                                    "Visualizar a série com gráficos de linha, boxplots e testes ACF para confirmar problemas."
                                  ],
                                  "verification": "Gráficos e testes estatísticos (ex: Augmented Dickey-Fuller) confirmam presença de outliers e não-estacionariedade.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software R ou Python",
                                    "Pacotes: forecast (R), statsmodels/pandas (Python)",
                                    "Dataset exemplo: AirPassengers ou Mcomp"
                                  ],
                                  "tips": [
                                    "Use seed para reproducibilidade nas simulações.",
                                    "Comece com poucos outliers para isolar efeitos."
                                  ],
                                  "learningObjective": "Compreender como preparar dados realistas com ruídos comuns em séries temporais operacionais.",
                                  "commonMistakes": [
                                    "Ignorar sazonalidade inerente da série original.",
                                    "Exagerar outliers, tornando-os irrealistas.",
                                    "Não documentar as modificações aplicadas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar Critérios de Informação para Seleção Automática",
                                  "subSteps": [
                                    "Implementar funções de seleção automática como auto.arima() ou stepwise AIC/BIC.",
                                    "Treinar múltiplos modelos candidatos (ARIMA, ETS) no conjunto de treino.",
                                    "Calcular critérios de informação (AIC, BIC, AICc) para ranquear modelos.",
                                    "Selecionar os top 3-5 modelos baseados nos critérios.",
                                    "Registrar valores dos critérios para baseline."
                                  ],
                                  "verification": "Lista de modelos selecionados com valores de AIC/BIC gerados e salvos em tabela.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "R: pacote forecast",
                                    "Python: pmdarima ou statsmodels",
                                    "Jupyter Notebook para tracking"
                                  ],
                                  "tips": [
                                    "Defina limites razoáveis para ordem de ARIMA para evitar overfitting.",
                                    "Compare AIC vs BIC para trade-off viés-variância."
                                  ],
                                  "learningObjective": "Dominar a aplicação prática de critérios de informação em seleção automática de modelos.",
                                  "commonMistakes": [
                                    "Usar todo o dataset para seleção, contaminando hold-out.",
                                    "Ignorar penalização do BIC em séries longas.",
                                    "Não testar convergência dos modelos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Testar Sensibilidade dos Critérios a Perturbações",
                                  "subSteps": [
                                    "Criar variações do dataset: remover/add outliers, aplicar filtros suavizantes.",
                                    "Reaplicar seleção automática em cada variação e comparar rankings de modelos.",
                                    "Medir mudança nos critérios (ex: variação % em AIC) e estabilidade do modelo selecionado.",
                                    "Simular cenários de não-estacionariedade (ex: detrending parcial).",
                                    "Plotar gráficos de sensibilidade (ex: heatmap de mudanças por perturbação)."
                                  ],
                                  "verification": "Tabelas e gráficos mostram variação quantitativa nos critérios (>20% indica baixa robustez).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Scripts de simulação em R/Python",
                                    "Pacotes: dplyr/pandas para manipulação",
                                    "ggplot2/matplotlib para visualizações"
                                  ],
                                  "tips": [
                                    "Use loops para automatizar múltiplas perturbações.",
                                    "Foque em perturbações pequenas para testar sensibilidade real."
                                  ],
                                  "learningObjective": "Avaliar como outliers e não-estacionariedade afetam a estabilidade dos critérios.",
                                  "commonMistakes": [
                                    "Testar apenas uma perturbação, perdendo visão geral.",
                                    "Confundir sensibilidade com precisão de previsão.",
                                    "Não quantificar mudanças nos critérios."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar Previsões com Hold-Out e Analisar Robustez",
                                  "subSteps": [
                                    "Gerar previsões out-of-sample com modelos selecionados no hold-out.",
                                    "Calcular métricas de erro (MAE, RMSE, MAPE) para cada cenário perturbado.",
                                    "Comparar performance entre baseline e cenários sensíveis.",
                                    "Realizar validação cruzada temporal (rolling window) para confirmação.",
                                    "Concluir sobre robustez: critérios estáveis se erros variam <15%."
                                  ],
                                  "verification": "Relatório com métricas de erro e conclusão sobre robustez (ex: 'robusto' ou 'sensível').",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Funções de avaliação: accuracy() em forecast",
                                    "Python: scikit-learn metrics"
                                  ],
                                  "tips": [
                                    "Use hold-out não contaminado para validação imparcial.",
                                    "Priorize MAPE para séries com escala variável."
                                  ],
                                  "learningObjective": "Integrar testes de sensibilidade com validação prática de previsões.",
                                  "commonMistakes": [
                                    "Vazar dados do hold-out na seleção.",
                                    "Ignorar intervalos de confiança nas previsões.",
                                    "Sobrepor interpretações de erro sem contexto operacional."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar e Recomendar Melhorias para Robustez",
                                  "subSteps": [
                                    "Compilar resultados em relatório: tabelas, gráficos e insights.",
                                    "Propor robustecimentos (ex: pré-processamento de outliers, ensemble de critérios).",
                                    "Testar uma melhoria sugerida (ex: winsorização de outliers).",
                                    "Avaliar impacto da melhoria nas métricas finais.",
                                    "Resumir lições para aplicações operacionais."
                                  ],
                                  "verification": "Relatório completo com recomendações acionáveis e evidências.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Markdown/Jupyter para relatório",
                                    "Ferramentas de export PDF"
                                  ],
                                  "tips": [
                                    "Estruture relatório: problema, método, resultados, conclusões.",
                                    "Inclua código reproduzível."
                                  ],
                                  "learningObjective": "Sintetizar análises em recomendações práticas para cenários reais.",
                                  "commonMistakes": [
                                    "Focar só em números sem narrativa.",
                                    "Não propor soluções concretas.",
                                    "Omitir limitações do estudo."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma fábrica de manufatura, prever demanda mensal de peças usando auto.arima com dados históricos. Introduza outliers (greves simuladas) e quebras (mudança de fornecedor). Teste se AIC/BIC seleciona modelos estáveis e valida com hold-out para evitar erros em planejamento de produção.",
                              "finalVerifications": [
                                "Capacidade de gerar datasets perturbados com controle preciso.",
                                "Cálculo correto de critérios de informação em múltiplos cenários.",
                                "Gráficos de sensibilidade mostram impactos quantificáveis.",
                                "Métricas de previsão no hold-out variam <15% em testes robustos.",
                                "Relatório identifica fraquezas e propõe fixes operacionais.",
                                "Reproduzibilidade total via código e seeds."
                              ],
                              "assessmentCriteria": [
                                "Precisão na simulação de outliers/não-estacionariedade (visual e estatística).",
                                "Estabilidade demonstrada nos rankings de modelos (mudança <20% em critérios).",
                                "Qualidade das métricas de validação (MAPE <10% em baseline).",
                                "Profundidade da análise de sensibilidade (≥5 perturbações testadas).",
                                "Clareza e completude do relatório com visualizações.",
                                "Criatividade nas recomendações de robustecimento."
                              ],
                              "crossCurricularConnections": [
                                "Programação Estatística (R/Python para automação).",
                                "Gestão de Operações (previsão de demanda e estoque).",
                                "Machine Learning (validação cruzada e ensembles).",
                                "Econometria (testes de estacionariedade e robustez).",
                                "Visualização de Dados (gráficos de sensibilidade)."
                              ],
                              "realWorldApplication": "Em supply chain de e-commerce, avaliar se critérios automáticos resistem a picos de Black Friday (outliers) ou mudanças regulatórias (não-estacionariedade), garantindo previsões confiáveis para evitar rupturas de estoque ou excessos custosos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.3.3.4",
                            "name": "Interpretar resultados em contexto prático",
                            "description": "Analisar saídas de critérios para justificar escolha de modelo em relatórios de previsão, citando bibliografia como Enders e Ehlers.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar critérios de informação e suas saídas numéricas",
                                  "subSteps": [
                                    "Liste os critérios relevantes (AIC, BIC, HQIC) e suas fórmulas básicas.",
                                    "Execute o modelo em software e extraia os valores de cada critério para múltiplos modelos candidatos.",
                                    "Registre os valores em uma tabela comparativa.",
                                    "Identifique o modelo com o menor valor em cada critério.",
                                    "Anote o que valores menores indicam (melhor ajuste penalizado por complexidade)."
                                  ],
                                  "verification": "Tabela comparativa preenchida corretamente com valores extraídos dos outputs do software.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software R (pacote forecast) ou Python (statsmodels); conjunto de dados de séries temporais exemplo (ex: AirPassengers).",
                                  "tips": "Sempre compare pelo menos 3-5 modelos para contexto robusto.",
                                  "learningObjective": "Compreender o significado matemático e interpretativo dos critérios de informação.",
                                  "commonMistakes": "Confundir AIC com BIC sem considerar penalidades diferentes por parâmetros."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Comparar e analisar valores dos critérios entre modelos",
                                  "subSteps": [
                                    "Calcule diferenças relativas (ΔAIC = AIC_i - AIC_min) para todos os modelos.",
                                    "Classifique modelos: Δ < 2 (forte suporte), 4-7 (suporte substancial), >10 (pouco suporte).",
                                    "Avalie trade-offs: modelo simples vs complexo com valores próximos.",
                                    "Visualize com gráfico de barras dos critérios.",
                                    "Discuta inconsistências entre critérios (ex: AIC favorece complexidade mais que BIC)."
                                  ],
                                  "verification": "Gráfico e tabela de ΔAIC/BIC gerados, com classificação explícita de suporte.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software com plotting (ggplot2 em R ou matplotlib em Python); referências Enders (2014).",
                                  "tips": "Use Δ para normalizar; valores absolutos podem enganar em escalas diferentes.",
                                  "learningObjective": "Desenvolver habilidade em comparação relativa e hierarquização de modelos.",
                                  "commonMistakes": "Ignorar diferenças pequenas como insignificantes sem contexto de tamanho da amostra."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Contextualizar resultados no problema prático de previsão",
                                  "subSteps": [
                                    "Relacione o melhor modelo ao objetivo da previsão (ex: curto vs longo prazo).",
                                    "Avalie resíduos e forecasts out-of-sample para validar ajuste prático.",
                                    "Considere custos computacionais e interpretabilidade do modelo selecionado.",
                                    "Simule cenários: como o critério impacta precisão em dados reais.",
                                    "Documente limitações (ex: estacionariedade assumida)."
                                  ],
                                  "verification": "Parágrafo escrito conectando critérios ao contexto do dataset e objetivos.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Dados reais de exemplo (ex: séries econômicas); Ehlers (2012) para contextos práticos.",
                                  "tips": "Pergunte: 'Esse modelo é útil para o tomador de decisão?' antes de finalizar.",
                                  "learningObjective": "Integrar análise estatística com necessidades práticas de previsão.",
                                  "commonMistakes": "Focar só em números baixos sem verificar performance preditiva real."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Redigir relatório com justificativa e citações bibliográficas",
                                  "subSteps": [
                                    "Estruture o relatório: introdução, tabela de critérios, análise, escolha justificada.",
                                    "Inclua frases como: 'O modelo ARIMA(1,1,1) foi selecionado pelo menor AIC (125.3), conforme Enders (2014, p. 234).'",
                                    "Cite fontes: Enders para teoria AIC/BIC; Ehlers para aplicações em séries.",
                                    "Adicione visualizações e recomendações futuras.",
                                    "Revise por clareza e precisão técnica."
                                  ],
                                  "verification": "Relatório completo (1-2 páginas) com tabela, gráfico, justificativa e pelo menos 2 citações.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Editor de texto (LaTeX ou Word); livros Enders 'Applied Econometric Time Series' e Ehlers 'Real-Time Dynamic Systems'.",
                                  "tips": "Use templates de relatório para eficiência; cite páginas específicas.",
                                  "learningObjective": "Comunicar análises técnicas de forma acessível e fundamentada.",
                                  "commonMistakes": "Citar fontes genéricas sem ligação direta aos critérios usados."
                                }
                              ],
                              "practicalExample": "Usando dados mensais de passageiros aéreos (AirPassengers), compare ARIMA(0,1,1), ETS(A,N,N) e TBATS. AIC: 620.5, 615.2, 630.1. Selecione ETS pelo menor AIC, justificando menor risco de overfitting em previsões de 12 meses, citando Enders para penalidade por parâmetros.",
                              "finalVerifications": [
                                "Pode explicar por que BIC penaliza mais que AIC em modelos complexos?",
                                "Tabela de critérios mostra corretamente o modelo vencedor?",
                                "Relatório inclui ΔAIC e implicações práticas?",
                                "Citações de Enders/Ehlers estão integradas à justificativa?",
                                "Visualizações suportam a escolha do modelo?",
                                "Limitações do critério (ex: amostras pequenas) são mencionadas?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na extração e comparação de critérios (30%)",
                                "Profundidade da análise contextual e trade-offs (25%)",
                                "Clareza e estrutura do relatório escrito (20%)",
                                "Uso correto de citações bibliográficas relevantes (15%)",
                                "Inclusão de visualizações e verificações práticas (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Economia: Aplicação em previsão de PIB ou inflação.",
                                "Programação: Implementação em Python/R para automação.",
                                "Comunicação: Redação de relatórios técnicos persuasivos.",
                                "Matemática: Compreensão de otimização e funções de perda."
                              ],
                              "realWorldApplication": "Em finanças, bancos usam AIC/BIC para selecionar modelos SARIMA em previsão de demanda de crédito, justificando relatórios regulatórios ao BACEN; meteorologistas aplicam em séries de temperatura para alertas climáticos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.4",
                    "name": "Previsão Automática em Pacotes Computacionais",
                    "description": "Implementação prática de métodos automáticos em ferramentas como o pacote forecast no R.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.4.1",
                        "name": "Instalação e Configuração do Pacote Forecast no R",
                        "description": "Configuração inicial do ambiente computacional para utilizar o pacote forecast, incluindo instalação de dependências e verificação de funcionalidades básicas.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.4.1.1",
                            "name": "Instalar o pacote forecast e dependências",
                            "description": "Executar comandos no R para instalar o pacote forecast a partir do CRAN, incluindo pacotes auxiliares como ggplot2 e fpp3, e resolver possíveis conflitos de versão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente R e verificar pré-requisitos",
                                  "subSteps": [
                                    "Abra o console do R ou RStudio.",
                                    "Execute sessionInfo() para verificar a versão do R (deve ser >= 4.0).",
                                    "Execute .packages() para listar pacotes instalados.",
                                    "Atualize todos os pacotes com update.packages(ask = FALSE, checkBuilt = TRUE).",
                                    "Reinicie a sessão do R com .rs.restartR() no RStudio ou quit() e reinicie."
                                  ],
                                  "verification": "Versão do R >= 4.0 confirmada e atualização completa sem erros críticos.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "R ou RStudio instalado, conexão à internet estável",
                                  "tips": "Use RStudio para uma interface mais amigável e detecção automática de erros.",
                                  "learningObjective": "Garantir que o ambiente R esteja atualizado e compatível com pacotes modernos.",
                                  "commonMistakes": "Ignorar atualizações de pacotes base, levando a incompatibilidades; não reiniciar sessão após updates."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar repositório CRAN e instalar dependências básicas como ggplot2",
                                  "subSteps": [
                                    "Execute chooseCRANmirror() e selecione um mirror próximo (ex: RStudio CRAN).",
                                    "Ou defina manualmente: options(repos = c(CRAN = 'https://cran.rstudio.com/')).",
                                    "Instale ggplot2: install.packages('ggplot2').",
                                    "Verifique instalação: library(ggplot2); packageVersion('ggplot2').",
                                    "Instale outras dependências comuns se necessário: install.packages(c('zoo', 'tseries'))."
                                  ],
                                  "verification": "ggplot2 carrega sem erros e versão exibida corretamente.",
                                  "estimatedTime": "5 minutos",
                                  "materials": "Conexão à internet, console R",
                                  "tips": "Escolha um mirror geográficamente próximo para downloads mais rápidos.",
                                  "learningObjective": "Configurar fontes confiáveis de pacotes e instalar visualização básica para séries temporais.",
                                  "commonMistakes": "Usar mirror lento ou inválido, causando timeouts; pular verificação de library()."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Instalar o pacote forecast do CRAN",
                                  "subSteps": [
                                    "Execute install.packages('forecast', dependencies = TRUE).",
                                    "Aguarde download e compilação (pode demorar em dependências como Rcpp).",
                                    "Verifique instalação: library(forecast); packageVersion('forecast').",
                                    "Teste função básica: forecast::auto.arima() sem erro.",
                                    "Se erro de compilação, instale Rtools (Windows) ou Xcode (Mac) previamente."
                                  ],
                                  "verification": "library(forecast) executa sem warnings de dependências ausentes.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Rtools/Xcode se necessário para compilação, internet",
                                  "tips": "Use dependencies = TRUE para instalar tudo automaticamente.",
                                  "learningObjective": "Instalar o pacote principal para previsão automática de séries temporais.",
                                  "commonMistakes": "Não instalar dependências = TRUE, causando erros em funções; ignorar ferramentas de build."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Instalar fpp3 e resolver conflitos de versão",
                                  "subSteps": [
                                    "Instale fpp3: install.packages('fpp3').",
                                    "Carregue: library(fpp3); vignette('forecasting-principles').",
                                    "Verifique conflitos: conflicts() após library(forecast, fpp3).",
                                    "Resolva conflitos atualizando pacotes: update.packages(c('tsibble', 'fable')).",
                                    "Teste integração: data(pigiron); fit <- fable(pigiron) |> model(arima = ARIMA(Count))."
                                  ],
                                  "verification": "Ambos pacotes carregam juntos sem conflitos e exemplo de fable executa.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Internet, pacotes forecast instalados",
                                  "tips": "fpp3 usa tidyverts; priorize-o sobre forecast legado para novos projetos.",
                                  "learningObjective": "Completar setup com pacote educacional e gerenciar compatibilidades.",
                                  "commonMistakes": "Conflitos entre forecast e fable não resolvidos; versões desatualizadas de tsibble."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar instalação completa e testar funcionalidades",
                                  "subSteps": [
                                    "Execute sessionInfo() para listar todos pacotes relevantes.",
                                    "Crie script teste: library(forecast); library(fpp3); auto.arima(AirPassengers).",
                                    "Salve script como teste_forecast.R e execute source('teste_forecast.R').",
                                    "Gere plot básico: autoplot(forecast(auto.arima(AirPassengers))).",
                                    "Documente versões em um arquivo README para reprodutibilidade."
                                  ],
                                  "verification": "Todos testes rodam sem erros e plots gerados corretamente.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Editor de texto ou RStudio",
                                  "tips": "Sempre teste com dados built-in como AirPassengers para validação rápida.",
                                  "learningObjective": "Confirmar usabilidade prática dos pacotes instalados.",
                                  "commonMistakes": "Não testar carregamento conjunto; assumir sucesso sem verificação."
                                }
                              ],
                              "practicalExample": "Para analisar séries temporais de vendas de uma loja online, instale forecast para auto.arima() em dados mensais, ggplot2 para visualizações e fpp3 para tutoriais interativos, resolvendo conflitos para um fluxo suave de modelagem até previsão.",
                              "finalVerifications": [
                                "library(forecast) e library(fpp3) carregam sem erros ou warnings.",
                                "packageVersion('forecast'), packageVersion('ggplot2') e packageVersion('fpp3') mostram versões recentes.",
                                "Função auto.arima(AirPassengers) executa e retorna modelo válido.",
                                "autoplot(forecast(auto.arima(AirPassengers))) gera gráfico sem falhas.",
                                "sessionInfo() confirma ausência de conflitos de namespace.",
                                "Script de teste roda de ponta a ponta em nova sessão R."
                              ],
                              "assessmentCriteria": [
                                "Instalação completa sem erros fatais ou timeouts.",
                                "Todas dependências resolvidas automaticamente ou manualmente.",
                                "Pacotes carregam e funções básicas executam corretamente.",
                                "Conflitos de versão identificados e mitigados.",
                                "Testes práticos com dados reais confirmam funcionalidade.",
                                "Ambiente documentado para reprodutibilidade."
                              ],
                              "crossCurricularConnections": [
                                "Programação Computacional: Gerenciamento de pacotes e dependências em R.",
                                "Estatística Aplicada: Preparação para modelagem de séries temporais.",
                                "Engenharia de Software: Resolução de conflitos e boas práticas de setup.",
                                "Análise de Dados: Integração com visualização (ggplot2).",
                                "Educação Computacional: Uso de vignettes e dados de exemplo."
                              ],
                              "realWorldApplication": "Analistas de dados em empresas como Amazon ou bancos instalam forecast e fpp3 para prever demanda de produtos ou flutuações financeiras, automatizando ARIMA e integrando com dashboards para decisões baseadas em previsões precisas de séries temporais reais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.1.2",
                            "name": "Carregar e verificar bibliotecas",
                            "description": "Usar library() para carregar forecast e testar funções básicas como ts() e autoplot() para confirmar que o ambiente está pronto para análise de séries temporais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente R",
                                  "subSteps": [
                                    "Abra o RStudio ou console R.",
                                    "Crie um novo script R (File > New File > R Script).",
                                    "Salve o script com nome como 'verificar_forecast.R'.",
                                    "Verifique se o pacote forecast está instalado executando install.packages('forecast') se necessário.",
                                    "Limpe o ambiente com rm(list=ls()) para evitar conflitos."
                                  ],
                                  "verification": "Console mostra '>' prompt pronto e nenhum erro de instalação.",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "RStudio ou R console",
                                    "Conexão à internet (se instalação necessária)"
                                  ],
                                  "tips": "Sempre use RStudio para melhor visualização de plots e console.",
                                  "learningObjective": "Configurar um ambiente limpo e pronto para carregar pacotes.",
                                  "commonMistakes": [
                                    "Esquecer de instalar forecast previamente",
                                    "Não limpar variáveis antigas que possam interferir"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Carregar a biblioteca forecast",
                                  "subSteps": [
                                    "Digite library(forecast) no script.",
                                    "Execute a linha com Ctrl+Enter (Windows) ou Cmd+Enter (Mac).",
                                    "Observe a saída no console.",
                                    "Se não houver mensagens de erro, prossiga.",
                                    "Anote qualquer warning para troubleshooting futuro."
                                  ],
                                  "verification": "Console não exibe erros como 'there is no package called forecast'; funções do pacote ficam disponíveis.",
                                  "estimatedTime": "3 minutos",
                                  "materials": [
                                    "Script R preparado"
                                  ],
                                  "tips": "Use library() em vez de require() para carregar pacotes, pois library() para em caso de erro.",
                                  "learningObjective": "Carregar pacotes essenciais sem erros para análise de séries temporais.",
                                  "commonMistakes": [
                                    "Digitar 'Library(forecast)' com L maiúsculo",
                                    "Não salvar o script antes de executar"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Testar funções básicas ts() e autoplot()",
                                  "subSteps": [
                                    "Crie uma série temporal simples: my_ts <- ts(1:10).",
                                    "Execute e verifique se my_ts é criada sem erro.",
                                    "Execute autoplot(my_ts) para plotar.",
                                    "Confirme que o gráfico aparece na aba Plots.",
                                    "Teste summary(my_ts) para mais verificações."
                                  ],
                                  "verification": "Gráfico de linha simples é exibido corretamente e summary() mostra estatísticas da série.",
                                  "estimatedTime": "7 minutos",
                                  "materials": [
                                    "Biblioteca forecast carregada"
                                  ],
                                  "tips": "autoplot() requer ggplot2, que é dependência automática do forecast.",
                                  "learningObjective": "Validar que funções core para séries temporais estão operacionais.",
                                  "commonMistakes": [
                                    "Usar ts() sem dados numéricos",
                                    "Esquecer de carregar forecast antes de autoplot()"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Confirmar readiness do ambiente",
                                  "subSteps": [
                                    "Execute sessionInfo() para listar pacotes carregados.",
                                    "Verifique se 'forecast' aparece na lista.",
                                    "Salve o script com marcação de sucesso: # Ambiente pronto para forecast.",
                                    "Teste uma função avançada como forecast() com dados dummy se desejar.",
                                    "Documente qualquer issue em um comentário no script."
                                  ],
                                  "verification": "sessionInfo() confirma forecast carregado e todas funções testadas sem erros.",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Script com testes anteriores"
                                  ],
                                  "tips": "Sempre documente o setup em scripts para reprodutibilidade.",
                                  "learningObjective": "Estabelecer um checklist para verificar ambiente pronto para modelagem.",
                                  "commonMistakes": [
                                    "Ignorar warnings de dependências como ggplot2",
                                    "Não testar múltiplas funções"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um script R, execute: library(forecast); mydata <- ts(AirPassengers); autoplot(mydata). O gráfico da série AirPassengers deve aparecer confirmando que forecast e funções ts/autoplot estão prontas para previsões automáticas.",
                              "finalVerifications": [
                                "library(forecast) executa sem erros.",
                                "ts(1:10) cria objeto de classe 'ts'.",
                                "autoplot(my_ts) gera gráfico sem falhas.",
                                "sessionInfo() lista forecast como carregado.",
                                "Nenhum warning ou error relacionado a dependências.",
                                "Script salvo e reproduzível."
                              ],
                              "assessmentCriteria": [
                                "Execução bem-sucedida de library() sem intervenção manual.",
                                "Criação e plot de ts() com dados reais ou dummy.",
                                "Interpretação correta de saídas do console e plots.",
                                "Identificação e resolução de erros comuns.",
                                "Documentação clara do processo no script.",
                                "Tempo total dentro de 20 minutos."
                              ],
                              "crossCurricularConnections": [
                                "Programação em R: Conceitos de pacotes e dependências.",
                                "Estatística: Introdução a objetos de séries temporais (ts()).",
                                "Visualização de dados: Uso de ggplot2 via autoplot().",
                                "Gestão de projetos: Reprodutibilidade de ambientes computacionais."
                              ],
                              "realWorldApplication": "Em empresas de varejo, carregar forecast permite prever vendas sazonais rapidamente, confirmando setup antes de análises críticas para estoque e planejamento financeiro."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.4.2",
                        "name": "Preparação de Dados para Previsão Automática",
                        "description": "Transformação e estruturação de dados em objetos de séries temporais compatíveis com o pacote forecast, garantindo adequação para métodos automáticos.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.4.2.1",
                            "name": "Importar e converter dados em objetos ts",
                            "description": "Ler dados de arquivos CSV ou Excel e convertê-los em objetos de classe ts() ou tsibble(), especificando frequência (diária, mensal, etc.) para análise de séries temporais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente R e carregar pacotes necessários",
                                  "subSteps": [
                                    "Instale os pacotes readr, readxl, tsibble e lubridate se não estiverem instalados usando install.packages().",
                                    "Carregue os pacotes com library(readr), library(readxl), library(tsibble) e library(lubridate).",
                                    "Defina o diretório de trabalho com setwd() para acessar o arquivo de dados.",
                                    "Crie uma pasta de projeto para organizar scripts e dados.",
                                    "Verifique a versão do R com R.version para compatibilidade."
                                  ],
                                  "verification": "Execute library() para confirmar que os pacotes estão carregados sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "RStudio, acesso à internet para instalação de pacotes",
                                  "tips": "Use renv ou packrat para gerenciar dependências em projetos colaborativos.",
                                  "learningObjective": "Preparar um ambiente reprodutível para manipulação de séries temporais.",
                                  "commonMistakes": "Esquecer de recarregar pacotes após reiniciar o R; instalar pacotes desnecessários."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Importar dados de arquivos CSV ou Excel",
                                  "subSteps": [
                                    "Identifique o caminho do arquivo CSV ou Excel e leia com read_csv() ou read_excel().",
                                    "Atribua os dados a uma variável como dados_brutos <- read_csv('vendas.csv').",
                                    "Inspecione a estrutura com glimpse(dados_brutos) ou View(dados_brutos).",
                                    "Renomeie colunas para padronizar (ex: data para date, valor para value).",
                                    "Converta a coluna de data para formato Date com as.Date() ou ymd()."
                                  ],
                                  "verification": "Confirme que os dados foram importados corretamente com nrow() e colnames().",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Arquivo de exemplo CSV/Excel com colunas de data e valores",
                                  "tips": "Use read_csv() com col_types para evitar inferência automática de tipos errados.",
                                  "learningObjective": "Ler dados tabulares de fontes comuns de forma eficiente e sem erros de tipo.",
                                  "commonMistakes": "Ignorar encoding UTF-8 em CSV; não tratar datas em formato não padrão."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar e preparar os dados para conversão",
                                  "subSteps": [
                                    "Verifique valores ausentes com summary() ou is.na().",
                                    "Trate missing values com fill() ou imputação simples como mean().",
                                    "Ordene os dados por data com arrange(date).",
                                    "Filtre dados fora do período relevante com filter(date >= '2020-01-01').",
                                    "Crie uma coluna de índice temporal se necessário com row_number()."
                                  ],
                                  "verification": "Execute summary(preparados) para confirmar ausência de NAs e ordem cronológica.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Dados importados do step anterior",
                                  "tips": "Visualize com plot(value ~ date) para detectar anomalias.",
                                  "learningObjective": "Limpar dados para garantir integridade em análises de séries temporais.",
                                  "commonMistakes": "Não ordenar por data; imputar incorretamente valores extremos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Converter dados para objetos ts() ou tsibble() com frequência especificada",
                                  "subSteps": [
                                    "Para ts(): Use ts(preparados$value, start = c(2020,1), frequency = 12) para mensal.",
                                    "Para tsibble(): Use as_tsibble(preparados, index = date, regular = TRUE).",
                                    "Especifique frequência: monthly = 12, daily = 365.25, etc.",
                                    "Valide regularidade com is_regular() para tsibble.",
                                    "Salve o objeto como serie_ts <- ... para uso posterior."
                                  ],
                                  "verification": "Use class(serie_ts) e plot(serie_ts) para confirmar tipo e visualização.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Dados preparados",
                                  "tips": "Prefira tsibble() para dados com múltiplas séries; ts() para univariadas simples.",
                                  "learningObjective": "Transformar data frames em estruturas otimizadas para séries temporais.",
                                  "commonMistakes": "Frequência errada (ex: daily como 7); start incorreto."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e testar a conversão final",
                                  "subSteps": [
                                    "Plote a série com autoplot(serie_ts) ou plot().",
                                    "Extraia componentes com frequency(serie_ts) e start(serie_ts).",
                                    "Teste forecast simulado com forecast(serie_ts, h=12).",
                                    "Compare com dados originais via head() e tail().",
                                    "Documente o código em um script .Rmd."
                                  ],
                                  "verification": "Confirme que plot exibe série temporal contínua sem gaps.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Objeto ts/tsibble criado",
                                  "tips": "Use gg_season() do feasts para decompor e validar sazonalidade.",
                                  "learningObjective": "Garantir que o objeto ts/tsibble esteja pronto para modelagem.",
                                  "commonMistakes": "Não testar regularidade; ignorar warnings de duplicatas."
                                }
                              ],
                              "practicalExample": "Baixe um CSV de vendas mensais de produtos de 2020-2023 (colunas: date, sales). Importe com read_csv(), limpe NAs, converta para tsibble(index=date, regular=TRUE) com frequency mensal implícita, e plote para visualizar tendência crescente.",
                              "finalVerifications": [
                                "O objeto é da classe 'ts' ou 'tsibble' via class().",
                                "Frequência correta confirmada com frequency() ou intervals().",
                                "Plot exibe eixo temporal alinhado sem interrupções.",
                                "Nenhum NA restante em summary().",
                                "Dados originais e convertidos têm o mesmo número de observações.",
                                "Teste de forecast roda sem erros."
                              ],
                              "assessmentCriteria": [
                                "Código é reprodutível e comentado adequadamente.",
                                "Tratamento correto de tipos de data e frequência.",
                                "Ausência de erros comuns como gaps temporais.",
                                "Eficiência: tempo de execução < 1s para datasets médios.",
                                "Validação visual e numérica completa.",
                                "Documentação inclui frequência e período coberto."
                              ],
                              "crossCurricularConnections": [
                                "Programação em R: Manipulação de dados com tidyverse.",
                                "Estatística: Conceitos de sazonalidade e tendência.",
                                "Ciência de Dados: Pipelines de ETL para séries temporais.",
                                "Matemática: Modelos univariados e frequência angular."
                              ],
                              "realWorldApplication": "Em empresas de varejo, importar vendas diárias de Excel para tsibble() permite previsões automáticas de estoque, otimizando logística e reduzindo custos em até 20%."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.2.2",
                            "name": "Realizar análise exploratória básica",
                            "description": "Aplicar funções como gg_tsdisplay() ou plot() para identificar sazonalidade, tendência e estacionariedade, preparando os dados para seleção automática de modelos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e carregar os dados da série temporal",
                                  "subSteps": [
                                    "Instalar e carregar pacotes necessários como tidyverse, feasts e fabletools.",
                                    "Importar o conjunto de dados em formato tsibble ou ts.",
                                    "Converter os dados para o formato tsibble se necessário, definindo a chave temporal.",
                                    "Inspecionar estrutura básica dos dados com funções como glimpse() ou head().",
                                    "Verificar presença de valores ausentes ou outliers iniciais."
                                  ],
                                  "verification": "Dados carregados corretamente e visualizados sem erros; tsibble válido confirmado com is_tsibble().",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "RStudio ou Jupyter com R",
                                    "Pacotes: tidyverse, feasts, fabletools",
                                    "Dataset de exemplo (e.g., us_employment de fabletools)"
                                  ],
                                  "tips": "Use library(fabletools) para acessar gg_tsdisplay; sempre defina index e key no tsibble.",
                                  "learningObjective": "Configurar ambiente R para análise de séries temporais e preparar dados em formato adequado.",
                                  "commonMistakes": [
                                    "Esquecer de especificar o index temporal",
                                    "Não converter para tsibble",
                                    "Ignorar valores NA"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Visualizar a série temporal básica com gg_tsdisplay() ou plot()",
                                  "subSteps": [
                                    "Aplicar gg_tsdisplay(tsibble_objeto) para gerar painéis de visualização múltipla.",
                                    "Alternativamente, usar autoplot(tsibble_objeto) para gráfico simples.",
                                    "Observar o painel de série temporal para visão geral.",
                                    "Interpretar o ACF (função de autocorrelação) para padrões iniciais.",
                                    "Salvar o gráfico para relatório com ggsave()."
                                  ],
                                  "verification": "Gráficos gerados mostram série temporal, FAC e PAC sem erros de plotting.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ambiente R preparado do Step 1",
                                    "Função gg_tsdisplay() do feasts"
                                  ],
                                  "tips": "gg_tsdisplay() é ideal para séries temporais tidy; ajuste theme para melhor legibilidade.",
                                  "learningObjective": "Gerar visualizações padrão de séries temporais para inspeção inicial.",
                                  "commonMistakes": [
                                    "Usar plot() sem formato ts",
                                    "Ignorar painéis ACF/PAC",
                                    "Escala inadequada no eixo tempo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar tendência e sazonalidade nos gráficos",
                                  "subSteps": [
                                    "Analisar o painel da série para detectar tendência ascendente/descendente ou estável.",
                                    "Examinar oscilações regulares no gráfico para sazonalidade (e.g., picos anuais).",
                                    "Usar gg_tsdisplay() com decomposição STL se disponível para separar componentes.",
                                    "Documentar observações em um relatório ou anotação no código.",
                                    "Comparar múltiplas séries se aplicável para padrões comuns."
                                  ],
                                  "verification": "Relatório escrito identifica presença/ausência de tendência e sazonalidade com evidências gráficas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráficos do Step 2",
                                    "Funções features() do feasts para extração automática"
                                  ],
                                  "tips": "Procure ciclos em múltiplos períodos; use features() para quantificar sazonalidade.",
                                  "learningObjective": "Interpretar visualizações para detectar componentes chave: tendência e sazonalidade.",
                                  "commonMistakes": [
                                    "Confundir ruído com sazonalidade",
                                    "Ignorar escala logarítmica para tendências",
                                    "Subjetividade sem evidência gráfica"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar estacionariedade preliminar e preparar para modelagem",
                                  "subSteps": [
                                    "Aplicar teste unit root como unitroot_kpss() ou unitroot_adf() do feasts.",
                                    "Observar decaimento lento no ACF para indício de não-estacionariedade.",
                                    "Se não estacionária, anotar necessidade de diferenciação ou transformação.",
                                    "Gerar resumo com features() para trend_strength e seasonal_strength.",
                                    "Salvar insights para seleção de modelo automático (e.g., ARIMA)."
                                  ],
                                  "verification": "Testes executados e resultados interpretados; forças de tendência/sazonalidade quantificadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Pacote feasts",
                                    "Funções unitroot_* e features()"
                                  ],
                                  "tips": "KPSS testa H0: estacionária; valores altos em trend_strength indicam tendência forte.",
                                  "learningObjective": "Avaliar estacionariedade e quantificar componentes para preparar dados em previsão automática.",
                                  "commonMistakes": [
                                    "Não testar formalmente estacionariedade",
                                    "Ignorar força fraca como ausência",
                                    "Confundir estacionariedade com ausência de tendência"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando o dataset us_employment do fabletools, carregue os dados mensais de emprego nos EUA de 1990-2020. Aplique gg_tsdisplay() para visualizar: identifique tendência de crescimento pós-recessão, sazonalidade trimestral e teste estacionariedade mostrando necessidade de diferenciação para modelo ARIMA automático.",
                              "finalVerifications": [
                                "Gráficos gg_tsdisplay() ou plot() gerados e interpretados corretamente.",
                                "Tendência identificada com evidência visual e features_trend_strength() > 0.5.",
                                "Sazonalidade detectada via oscilações regulares e seasonal_strength() > 0.3.",
                                "Testes de estacionariedade aplicados com interpretação (e.g., p-value KPSS).",
                                "Relatório resumido preparado para próxima etapa de modelagem.",
                                "Nenhum erro em tsibble ou plotting."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de tendência (correta em 90% dos casos).",
                                "Detecção correta de sazonalidade baseada em múltiplos ciclos.",
                                "Interpretação adequada de testes de estacionariedade.",
                                "Uso correto de funções feasts/fabletools sem erros.",
                                "Documentação clara de insights com gráficos salvos.",
                                "Preparação lógica para seleção automática de modelos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Decomposição aditiva/multiplicativa de séries temporais.",
                                "Programação: Manipulação de dados tidyverse e visualização ggplot2.",
                                "Estatística: Testes de hipóteses (unit root) e autocorrelação.",
                                "Negócios: Aplicação em forecasting para planejamento econômico."
                              ],
                              "realWorldApplication": "Em empresas de varejo, analise vendas mensais para detectar sazonalidade de Natal e tendência de crescimento, ajustando estoque e preparando modelos automáticos para previsões de demanda precisas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.4.3",
                        "name": "Aplicação de Funções Automáticas de Previsão",
                        "description": "Implementação de algoritmos automáticos para seleção e ajuste de modelos de previsão diretamente no pacote forecast.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.4.3.1",
                            "name": "Usar auto.arima() para modelos ARIMA automáticos",
                            "description": "Aplicar a função auto.arima() em uma série temporal para seleção automática de parâmetros p, d, q, considerando critérios como AICc, e gerar previsões iniciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente R e carregar a série temporal",
                                  "subSteps": [
                                    "Instale o pacote forecast executando install.packages('forecast') se necessário.",
                                    "Carregue as bibliotecas com library(forecast) e library(ggplot2) para visualizações.",
                                    "Carregue um dataset de série temporal exemplo, como data(AirPassengers); ts_data <- AirPassengers.",
                                    "Visualize a série com plot(ts_data) para entender o comportamento inicial.",
                                    "Verifique a estrutura com summary(ts_data) e class(ts_data) para confirmar formato ts."
                                  ],
                                  "verification": "Execute os comandos sem erros e visualize o gráfico da série temporal corretamente plotado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "R ou RStudio",
                                    "Pacote forecast",
                                    "Dataset AirPassengers (built-in)"
                                  ],
                                  "tips": [
                                    "Use RStudio para facilitar a depuração e visualizações.",
                                    "Sempre verifique se os pacotes estão atualizados com update.packages()."
                                  ],
                                  "learningObjective": "Preparar o ambiente de programação R e carregar dados de série temporal no formato adequado.",
                                  "commonMistakes": [
                                    "Esquecer de carregar library(forecast)",
                                    "Não converter dados para classe ts",
                                    "Ignorar verificação inicial da estrutura dos dados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar e preparar a série temporal para modelagem",
                                  "subSteps": [
                                    "Teste estacionariedade com o teste de Kwiatkowski-Phillips-Schmidt-Shin (KPSS) usando kpss.test(ts_data).",
                                    "Aplique diferenciação se necessário: ts_data_diff <- diff(ts_data, differences=1) e teste novamente.",
                                    "Identifique sazonalidade com ggtsdisplay(ts_data, lags=12) do pacote forecast.",
                                    "Documente as propriedades observadas (tendência, sazonalidade, estacionariedade).",
                                    "Defina parâmetros iniciais como ic='aicc' para critério de informação corrigido."
                                  ],
                                  "verification": "Registre resultados dos testes de estacionariedade e visualize decomposição sazonal sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "RStudio",
                                    "Pacote forecast",
                                    "Funções kpss.test e ggtsdisplay"
                                  ],
                                  "tips": [
                                    "Diferencie apenas o necessário para evitar sobrediferenciação.",
                                    "Use lags apropriados baseados na frequência da série (ex: 12 para mensal)."
                                  ],
                                  "learningObjective": "Diagnosticar propriedades da série temporal para otimizar a seleção automática de parâmetros ARIMA.",
                                  "commonMistakes": [
                                    "Não testar estacionariedade antes de modelar",
                                    "Aplicar diferenciação excessiva",
                                    "Ignorar sazonalidade evidente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a função auto.arima() para seleção automática de parâmetros",
                                  "subSteps": [
                                    "Execute model <- auto.arima(ts_data, ic='aicc', stepwise=FALSE, approximation=FALSE, seasonal=TRUE).",
                                    "Inspecione o modelo com summary(model) para verificar p, d, q, P, D, Q selecionados e AICc.",
                                    "Compare com critérios alternativos rodando auto.arima(ts_data, ic='aic') se desejado.",
                                    "Verifique resíduos com checkresiduals(model) para acurácia diagnóstica.",
                                    "Ajuste parâmetros adicionais como allowdrift=TRUE se apropriado para a série."
                                  ],
                                  "verification": "Obtenha um modelo ARIMA com parâmetros p,d,q selecionados automaticamente e resíduos brancos (p-value > 0.05 no Ljung-Box).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Pacote forecast",
                                    "Série temporal preparada"
                                  ],
                                  "tips": [
                                    "Use stepwise=FALSE para busca exaustiva em séries pequenas.",
                                    "Priorize AICc para amostras finitas para evitar overfitting."
                                  ],
                                  "learningObjective": "Utilizar auto.arima() para seleção automática de ordens ARIMA baseada em AICc.",
                                  "commonMistakes": [
                                    "Não especificar ic='aicc'",
                                    "Ignorar diagnóstico de resíduos",
                                    "Desabilitar busca sazonal em séries sazonais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Gerar previsões, visualizar e interpretar resultados",
                                  "subSteps": [
                                    "Gere previsões com fc <- forecast(model, h=12, level=c(80,95)).",
                                    "Plote as previsões com autoplot(fc) + theme_minimal().",
                                    "Calcule métricas de precisão com accuracy(fc, ts_data).",
                                    "Interprete intervalos de confiança e compare com dados reais se disponível.",
                                    "Salve o modelo e previsões com saveRDS(model, 'arima_model.rds')."
                                  ],
                                  "verification": "Visualize gráfico de previsões com intervalos e métricas de accuracy abaixo de thresholds aceitáveis (ex: RMSE < 10%).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Pacote forecast e ggplot2",
                                    "Modelo auto.arima ajustado"
                                  ],
                                  "tips": [
                                    "Escolha h baseado no horizonte de previsão desejado.",
                                    "Use level=c(80,95) para intervalos múltiplos."
                                  ],
                                  "learningObjective": "Produzir previsões confiáveis a partir do modelo ARIMA automático e avaliá-las visual e numericamente.",
                                  "commonMistakes": [
                                    "Horizonte h muito longo sem validação",
                                    "Não plotar intervalos de confiança",
                                    "Ignorar métricas de accuracy"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando o dataset AirPassengers (passageiros aéreos mensais de 1949-1960), aplique auto.arima() para selecionar um modelo ARIMA sazonal (ex: ARIMA(0,1,1)(0,1,1)[12]) via AICc, gere previsões para 12 meses futuros e visualize com intervalos de 95% de confiança, interpretando o aumento sazonal esperado.",
                              "finalVerifications": [
                                "Modelo ARIMA ajustado com parâmetros p,d,q selecionados automaticamente via AICc.",
                                "Teste de resíduos passa no Ljung-Box (p-value > 0.05).",
                                "Previsões geradas para horizonte h=12 com intervalos de confiança.",
                                "Gráfico autoplot mostra ajuste bom aos dados históricos.",
                                "Métricas accuracy (RMSE, MAE) calculadas e razoáveis.",
                                "Modelo salvo e reproduzível."
                              ],
                              "assessmentCriteria": [
                                "Correta configuração de auto.arima() com ic='aicc' e opções sazonais.",
                                "Diagnóstico adequado de estacionariedade e resíduos.",
                                "Interpretação precisa de parâmetros selecionados e AICc.",
                                "Previsões visualizadas com intervalos e métricas de avaliação.",
                                "Código limpo, comentado e sem erros de execução.",
                                "Aplicação contextualizada à série temporal exemplo."
                              ],
                              "crossCurricularConnections": [
                                "Estatística Inferencial: Testes de estacionariedade e diagnóstico de resíduos.",
                                "Programação em R: Manipulação de pacotes e objetos ts.",
                                "Visualização de Dados: Uso de ggplot2 e autoplot para séries temporais.",
                                "Machine Learning: Seleção automática de hiperparâmetros em modelos preditivos.",
                                "Análise Exploratória de Dados: Decomposição sazonal e tendências."
                              ],
                              "realWorldApplication": "Em finanças, para previsão automática de preços de ações ou demanda de produtos; em meteorologia, para modelar temperaturas sazonais; em varejo, para forecasting de vendas mensais otimizando estoque sem expertise manual em ARIMA."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.3.2",
                            "name": "Usar ets() para modelos exponenciais suavizados",
                            "description": "Executar ets() para detecção automática de componentes erro, tendência e sazonalidade em modelos ETS, ajustando e prevendo para séries sazonais ou não estacionárias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e carregar os dados",
                                  "subSteps": [
                                    "Instalar e carregar os pacotes necessários: forecast e ggplot2.",
                                    "Importar o conjunto de dados de série temporal (ex: AirPassengers).",
                                    "Converter os dados para objeto ts() com frequência apropriada (ex: frequency=12 para mensal).",
                                    "Visualizar inicialmente a série com plot() para identificar padrões.",
                                    "Verificar propriedades básicas como start(), end() e frequência."
                                  ],
                                  "verification": "Ambiente pronto se plot() exibe a série sem erros e ts() retorna objeto válido.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "R e RStudio instalados",
                                    "Pacotes: forecast, ggplot2",
                                    "Dados exemplo: AirPassengers (disponível no R)"
                                  ],
                                  "tips": "Use library(forecast) uma vez por sessão; prefira dados built-in para testes iniciais.",
                                  "learningObjective": "Configurar corretamente o ambiente R para análise de séries temporais com ETS.",
                                  "commonMistakes": [
                                    "Esquecer de definir frequency no ts()",
                                    "Não carregar pacotes antes do uso",
                                    "Usar dados não estacionários sem transformação inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar e preparar a série temporal",
                                  "subSteps": [
                                    "Plotar a série com autoplot() ou plot() para observar tendência e sazonalidade.",
                                    "Decompor a série com decompose() ou stl() para identificar componentes.",
                                    "Testar estacionariedade com ndiffs() ou adf.test() do pacote forecast.",
                                    "Aplicar transformações se necessário: log() para variância não constante ou diff() para não-estacionariedade.",
                                    "Documentar observações sobre erro, tendência e sazonalidade manualmente."
                                  ],
                                  "verification": "Relatório de decomposição gerado e insights anotados sobre componentes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Pacote forecast carregado",
                                    "Série temporal ts() pronta"
                                  ],
                                  "tips": "Use ggseasonplot() para sazonalidade; anote achados em um script R.",
                                  "learningObjective": "Identificar componentes (erro, tendência, sazonalidade) para informar o modelo ETS.",
                                  "commonMistakes": [
                                    "Ignorar sazonalidade óbvia",
                                    "Não testar estacionariedade antes do modelo",
                                    "Plotar sem rótulos claros"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Ajustar o modelo ETS com ets()",
                                  "subSteps": [
                                    "Executar ets(série) com parâmetros padrão para detecção automática.",
                                    "Interpretar saída: componentes selecionados (ex: ETS(M,A,M) para multiplicativo erro-aditivo-sazonal).",
                                    "Comparar modelos com forecast::ets() usando AICc ou summary().",
                                    "Ajustar manualmente se necessário: ets(série, model='AAA') para testar específicos.",
                                    "Armazenar o modelo em objeto: fit <- ets(série)."
                                  ],
                                  "verification": "Modelo ajustado com summary(fit) mostrando componentes e AICc válidos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Série ts() preparada",
                                    "Pacote forecast"
                                  ],
                                  "tips": "Deixe model=NULL para auto-detecção; verifique residuos com checkresiduals(fit).",
                                  "learningObjective": "Usar ets() para ajuste automático de modelos exponenciais suavizados.",
                                  "commonMistakes": [
                                    "Não verificar resíduos para autocorrelação",
                                    "Forçar modelo sem base na exploração",
                                    "Ignorar warnings sobre convergência"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Realizar previsões e avaliar o modelo",
                                  "subSteps": [
                                    "Gerar previsões: forecast(fit, h=12) para 12 períodos à frente.",
                                    "Plotar previsões com plot(forecast(fit)) ou autoplot().",
                                    "Calcular métricas de precisão: accuracy(fit) para treino e teste.",
                                    "Validar com hold-out: dividir série em treino/teste e comparar.",
                                    "Interpretar intervalos de confiança e incertezas nas previsões."
                                  ],
                                  "verification": "Gráficos de previsão gerados e accuracy() com RMSE/MAPE abaixo de thresholds razoáveis.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Modelo fit ajustado"
                                  ],
                                  "tips": "Use h= para horizonte; compare com naive() para benchmark.",
                                  "learningObjective": "Gerar e avaliar previsões de séries temporais com ETS.",
                                  "commonMistakes": [
                                    "Prever sem validação out-of-sample",
                                    "Interpretar IC como probabilidades absolutas",
                                    "Não plotar para visual inspeção"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dados AirPassengers (passageiros aéreos mensais 1949-1960), aplicar ets() para detectar ETS(M,A,M), prever 12 meses à frente e plotar com intervalos de confiança, alcançando MAPE <10%.",
                              "finalVerifications": [
                                "Executa ets() sem erros em série sazonal.",
                                "Interpreta corretamente componentes ETS na saída.",
                                "Gera previsões plotadas com accuracy() reportada.",
                                "Identifica e corrige problemas como não-convergência.",
                                "Compara ETS com baseline como média móvel.",
                                "Documenta script completo reproduzível."
                              ],
                              "assessmentCriteria": [
                                "Precisão do modelo: AICc baixo e resíduos brancos.",
                                "Correta detecção automática de componentes.",
                                "Qualidade das previsões: MAPE/RMSE em hold-out <15%.",
                                "Interpretação: Explicação clara de erro/tendência/sazonalidade.",
                                "Código limpo: Comentado e reproduzível.",
                                "Visualizações: Plots informativos com legendas."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Testes de estacionariedade e decomposição.",
                                "Programação: Manipulação de dados em R com ts() e forecast.",
                                "Machine Learning: Modelos de previsão automatizados vs. ARIMA.",
                                "Economia/Negócios: Previsão de demanda e vendas.",
                                "Visualização de Dados: ggplot2 para séries temporais."
                              ],
                              "realWorldApplication": "Previsão de vendas sazonais em varejo (ex: Black Friday), demanda de energia elétrica, tráfego de sites ou séries financeiras para planejamento estratégico em empresas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.3.3",
                            "name": "Gerar previsões com forecast()",
                            "description": "Utilizar forecast() em modelos auto.arima() ou ets() para produzir previsões pontuais, intervalos de confiança e horizontes de previsão variáveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e o modelo ajustado",
                                  "subSteps": [
                                    "Instalar e carregar o pacote 'forecast' com library(forecast).",
                                    "Carregar os dados de série temporal (ex: ts_data <- AirPassengers).",
                                    "Ajustar o modelo automático com auto.arima(ts_data) ou ets(ts_data) e armazenar em uma variável (ex: fit <- auto.arima(ts_data)).",
                                    "Verificar o resumo do modelo com summary(fit) para confirmar adequação."
                                  ],
                                  "verification": "O objeto 'fit' é da classe 'arfima' ou 'ets' e summary(fit) exibe métricas como AIC.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "R ou RStudio, pacote 'forecast' instalado, conjunto de dados de série temporal (ex: AirPassengers).",
                                  "tips": "Sempre verifique stationarity com checkresiduals(fit) antes de prosseguir.",
                                  "learningObjective": "Preparar um modelo de série temporal ajustado pronto para geração de previsões.",
                                  "commonMistakes": "Esquecer de converter dados para classe 'ts' ou usar dados não estacionários sem transformação."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar parâmetros da função forecast()",
                                  "subSteps": [
                                    "Definir o horizonte de previsão 'h' (ex: h=12 para 12 períodos à frente).",
                                    "Especificar nível de confiança para intervalos (ex: level=c(80,95)).",
                                    "Opcionalmente, definir biasadj=TRUE para ajuste de viés.",
                                    "Armazenar a chamada em uma variável (ex: fc <- forecast(fit, h=12, level=c(80,95)))."
                                  ],
                                  "verification": "A chamada forecast() é executada sem erros e fc é da classe 'forecast'.",
                                  "estimatedTime": "8 minutos",
                                  "materials": "Objeto 'fit' do passo anterior, documentação da função forecast().",
                                  "tips": "Comece com h pequeno para testes rápidos e aumente gradualmente.",
                                  "learningObjective": "Dominar os parâmetros principais de forecast() para controle preciso das previsões.",
                                  "commonMistakes": "Definir h maior que o tamanho dos dados ou ignorar level, resultando em intervalos padrão de 95%."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Extrair e interpretar componentes das previsões",
                                  "subSteps": [
                                    "Acessar previsões pontuais com fc$mean.",
                                    "Extrair intervalos de confiança com fc$lower e fc$upper.",
                                    "Obter informações residuais e precisão com accuracy(fc).",
                                    "Interpretar: comparar point forecast com intervalos para avaliar incerteza."
                                  ],
                                  "verification": "Vetores mean, lower e upper têm comprimento igual a h e accuracy() retorna tabela de métricas.",
                                  "estimatedTime": "12 minutos",
                                  "materials": "Objeto 'fc' gerado, funções como head() e tail() para inspeção.",
                                  "tips": "Use cbind(fc$mean, fc$lower, fc$upper) para visualizar em tabela.",
                                  "learningObjective": "Extrair e compreender elementos chave das saídas de forecast() como previsões pontuais e intervalos.",
                                  "commonMistakes": "Confundir fc$mean com fc$point (não existe) ou interpretar intervalos como determinísticos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Visualizar e validar as previsões",
                                  "subSteps": [
                                    "Plotar as previsões com plot(fc) para gráfico automático.",
                                    "Personalizar com autoplot(fc) do pacote ggplot2 se disponível.",
                                    "Adicionar histórico com plot(fc, include=24) para mais contexto.",
                                    "Validar visualmente sobreposição com dados reais e largura de intervalos."
                                  ],
                                  "verification": "Gráfico exibe série histórica, previsões pontuais e faixas de confiança sem warnings.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Pacote 'forecast' ou 'ggfortify' para ggplot2, tela de visualização.",
                                  "tips": "Ajuste include para mostrar mais histórico se a série for longa.",
                                  "learningObjective": "Visualizar previsões para comunicação eficaz e validação intuitiva.",
                                  "commonMistakes": "Não incluir histórico (include=0 por default em alguns casos) ou ignorar warnings de plot."
                                }
                              ],
                              "practicalExample": "Usando dados AirPassengers: library(forecast); fit <- auto.arima(AirPassengers); fc <- forecast(fit, h=12, level=c(80,95)); plot(fc); point_forecast <- fc$mean; print(head(point_forecast)). Isso gera previsões de passageiros aéreos para os próximos 12 meses com intervalos de 80% e 95%.",
                              "finalVerifications": [
                                "forecast() executado sem erros e objeto fc criado.",
                                "Previsões pontuais (fc$mean) com valores numéricos coerentes.",
                                "Intervalos de confiança extraídos corretamente (fc$lower e fc$upper).",
                                "Gráfico plot(fc) mostra histórico, linha pontual e faixas de confiança.",
                                "Métricas de accuracy(fc) incluem RMSE e MASE abaixo de thresholds razoáveis.",
                                "Horizonte h variável testado (ex: h=5 e h=12) com resultados consistentes."
                              ],
                              "assessmentCriteria": [
                                "Correta aplicação de forecast() em modelo auto.arima() ou ets().",
                                "Parâmetros h e level especificados e justificados adequadamente.",
                                "Extração precisa de point forecast, CI e métricas de precisão.",
                                "Visualização clara com plot() incluindo histórico relevante.",
                                "Interpretação correta de incerteza via intervalos de confiança.",
                                "Capacidade de variar h e analisar impacto no horizonte de previsão."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Cálculo de intervalos de confiança e métricas de erro como RMSE.",
                                "Programação: Manipulação de objetos S3 em R e extração de slots ($mean).",
                                "Matemática Aplicada: Modelos ARIMA/ETS e suavização exponencial.",
                                "Visualização de Dados: Uso de plot() e ggplot2 para comunicação científica.",
                                "Negócios: Aplicação em forecasting para planejamento estratégico."
                              ],
                              "realWorldApplication": "Em empresas de varejo para prever demanda de produtos e otimizar estoque; em finanças para projeções de séries de preços de ações; em saúde pública para antecipar surtos epidêmicos baseados em dados temporais semanais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.4.4",
                        "name": "Avaliação e Visualização de Resultados",
                        "description": "Técnicas para validar a qualidade das previsões automáticas e apresentar resultados de forma clara usando ferramentas do pacote.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.4.4.1",
                            "name": "Calcular métricas de acurácia",
                            "description": "Aplicar accuracy() para computar erros como ME, RMSE, MAE e MAPE em conjuntos de validação, comparando diferentes modelos automáticos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e carregar dados de séries temporais",
                                  "subSteps": [
                                    "Instalar e carregar pacotes necessários como forecast, ggplot2 e dplyr.",
                                    "Carregar o conjunto de dados de treinamento e validação (ex: série temporal de vendas).",
                                    "Dividir os dados em treino e teste usando window() ou ts() para validação.",
                                    "Explorar os dados com plot() e summary() para identificar tendências e sazonalidade.",
                                    "Preparar objetos ts para treino e validação."
                                  ],
                                  "verification": "Verificar se os objetos ts de treino e validação foram criados corretamente com str() e plot().",
                                  "estimatedTime": "15 minutos",
                                  "materials": "R/RStudio, pacote forecast, dados de exemplo (ex: AirPassengers ou arquivo CSV de séries temporais).",
                                  "tips": "Sempre defina a frequência correta da série temporal (ex: frequency=12 para mensal).",
                                  "learningObjective": "Configurar ambiente computacional e preparar dados para avaliação de modelos de previsão.",
                                  "commonMistakes": "Esquecer de converter para classe ts; usar dados não estacionários sem pré-processamento."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar previsões com diferentes modelos automáticos",
                                  "subSteps": [
                                    "Ajustar modelo ARIMA automático com auto.arima() no conjunto de treino.",
                                    "Ajustar modelo ETS automático com ets() no conjunto de treino.",
                                    "Gerar previsões para o período de validação com forecast() para cada modelo.",
                                    "Armazenar as previsões em objetos separados (ex: fc_arima, fc_ets).",
                                    "Visualizar previsões vs. dados reais com autoplot() para inspeção inicial."
                                  ],
                                  "verification": "Confirmar que previsões têm o mesmo comprimento do conjunto de validação com length(fc_arima$mean == length(test)).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Pacotes forecast e ggplot2, objetos ts de treino.",
                                  "tips": "Use h=length(test) em forecast() para matching exato do horizonte de validação.",
                                  "learningObjective": "Aplicar funções automáticas de modelagem e gerar previsões comparáveis.",
                                  "commonMistakes": "Ajustar modelo no conjunto completo em vez de só treino; ignorar intervalos de confiança."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular métricas de acurácia com accuracy()",
                                  "subSteps": [
                                    "Aplicar accuracy(fc_arima, test) para obter ME, RMSE, MAE, MPE e MAPE do modelo ARIMA.",
                                    "Aplicar accuracy(fc_ets, test) para o modelo ETS.",
                                    "Extrair métricas específicas com funções como accuracy(fc, test)[\"RMSE\"] ou data.frames.",
                                    "Criar um data.frame comparativo com métricas de todos os modelos usando rbind().",
                                    "Interpretar: menor RMSE indica melhor precisão geral."
                                  ],
                                  "verification": "Verificar se as métricas foram calculadas sem NA ou erros com summary(df_metrics).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Função accuracy() do pacote forecast, previsões e dados de teste.",
                                  "tips": "accuracy() computa automaticamente em escala; prefira RMSE para erros quadráticos.",
                                  "learningObjective": "Usar accuracy() para quantificar erros de previsão de forma padronizada.",
                                  "commonMistakes": "Passar treino em vez de test; confundir mean com fitted values."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar modelos e visualizar métricas",
                                  "subSteps": [
                                    "Criar tabela comparativa com colunas para modelo e métricas chave (ME, RMSE, MAE, MAPE).",
                                    "Plotar barras comparativas de RMSE e MAE com ggplot2.",
                                    "Realizar teste estatístico como Diebold-Mariano para superioridade de modelos.",
                                    "Documentar o melhor modelo baseado em múltiplas métricas.",
                                    "Salvar resultados em CSV para relatório."
                                  ],
                                  "verification": "Tabela mostra RMSE_ARIMA < RMSE_ETS (ou vice-versa) e gráficos gerados sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "ggplot2, dplyr para manipulação; data.frame de métricas.",
                                  "tips": "Combine critérios: RMSE para precisão, MAPE para interpretabilidade em %.",
                                  "learningObjective": "Interpretar e comparar desempenho de modelos usando métricas múltiplas.",
                                  "commonMistakes": "Focar só em uma métrica; ignorar viés (ME ≠ 0 indica subestimação)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar resultados e planejar melhorias",
                                  "subSteps": [
                                    "Analisar padrões nos resíduos com checkresiduals() para cada modelo.",
                                    "Discutir implicações: ex. alto MAPE em zeros sugere problema com não-estacionariedade.",
                                    "Sugerir tuning: ex. adicionar regressores exógenos se RMSE alto.",
                                    "Redigir relatório resumindo melhor modelo e razões.",
                                    "Testar em novo conjunto de validação out-of-sample."
                                  ],
                                  "verification": "Relatório escrito identifica melhor modelo com justificativa baseada em ≥2 métricas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Função checkresiduals(), editor de texto ou R Markdown.",
                                  "tips": "Resíduos brancos (Ljung-Box p>0.05) confirmam bom ajuste além de acurácia.",
                                  "learningObjective": "Conectar métricas numéricas a decisões práticas de modelagem.",
                                  "commonMistakes": "Aceitar baixo RMSE sem checar resíduos; generalizar de um dataset."
                                }
                              ],
                              "practicalExample": "Usando dados AirPassengers (1949-1960), treine auto.arima() e ets() até 1958, preveja 1959-1960, compute accuracy() e compare: ARIMA pode ter RMSE=25.3 vs ETS=24.8, escolhendo ETS por menor MAE em passageiros mensais.",
                              "finalVerifications": [
                                "Todas métricas (ME, RMSE, MAE, MAPE) calculadas corretamente para ≥2 modelos.",
                                "Tabela comparativa gerada e salva.",
                                "Gráficos de métricas e resíduos produzidos.",
                                "Melhor modelo identificado com justificativa.",
                                "Resíduos checados sem autocorrelação significativa.",
                                "Relatório breve escrito."
                              ],
                              "assessmentCriteria": [
                                "Correta aplicação de accuracy() com test set (sem erros de índice).",
                                "Comparação quantitativa precisa entre modelos.",
                                "Interpretação contextual das métricas (ex: RMSE vs MAPE).",
                                "Visualizações claras e informativas.",
                                "Identificação de limitações e sugestões de melhoria.",
                                "Código reproduzível e comentado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Compreensão de funções de perda quadrática (RMSE) e absoluta (MAE).",
                                "Programação: Manipulação de data.frames e plotting em R.",
                                "Negócios: Aplicação em forecasting de demanda e estoque.",
                                "Estatística: Testes de resíduos e validação cruzada temporal."
                              ],
                              "realWorldApplication": "Em finanças, calcular RMSE de modelos ARIMA vs Prophet para previsão de preços de ações, selecionando o melhor para alertas de trading automatizados; ou em supply chain, usar MAPE para otimizar estoques sazonais reduzindo custos em 10-20%."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.4.2",
                            "name": "Visualizar previsões com autoplot()",
                            "description": "Gerar gráficos automáticos de previsões, incluindo séries observadas, ajustadas e intervalos de confiança, usando autoplot() e ggplot2 para relatórios.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e carregar bibliotecas necessárias",
                                  "subSteps": [
                                    "Instale os pacotes forecast e ggplot2 se não estiverem instalados: install.packages(c('forecast', 'ggplot2'))",
                                    "Carregue as bibliotecas: library(forecast); library(ggplot2)",
                                    "Prepare um objeto de série temporal de exemplo: data <- ts(rnorm(100), frequency=12)",
                                    "Ajuste um modelo simples: fit <- auto.arima(data)",
                                    "Gere previsões: fc <- forecast(fit, h=12)"
                                  ],
                                  "verification": "Verifique se as bibliotecas foram carregadas sem erros e se o objeto 'fc' é da classe 'forecast' usando class(fc)",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "R ou RStudio instalado",
                                    "Pacotes forecast e ggplot2",
                                    "Conexão à internet para instalação inicial"
                                  ],
                                  "tips": "Use library() em vez de require() para mensagens de erro claras",
                                  "learningObjective": "Configurar corretamente o ambiente para visualização de previsões em séries temporais",
                                  "commonMistakes": [
                                    "Esquecer de instalar pacotes antes de carregar",
                                    "Não definir frequency na série temporal",
                                    "Usar dados não-ts em auto.arima()"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar a função autoplot() ao objeto de previsão",
                                  "subSteps": [
                                    "Execute autoplot(fc) diretamente no console",
                                    "Observe o gráfico gerado com séries observadas (preto), ajustadas (azul) e previsões com intervalos de confiança (sombra)",
                                    "Ajuste parâmetros básicos se necessário: autoplot(fc, series='Minha Série')",
                                    "Adicione títulos: autoplot(fc) + ggtitle('Previsões de Temperatura')",
                                    "Salve o gráfico: ggsave('previsoes.png', width=10, height=6)"
                                  ],
                                  "verification": "O gráfico deve exibir automaticamente as linhas observadas, fitted e as faixas de confiança sem erros",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Objeto forecast 'fc' do passo anterior",
                                    "RStudio para visualização interativa"
                                  ],
                                  "tips": "autoplot() usa ggplot2 internamente, então você pode encadear + theme() para customizações rápidas",
                                  "learningObjective": "Gerar e customizar visualizações automáticas de previsões usando autoplot()",
                                  "commonMistakes": [
                                    "Passar objeto incorreto (não forecast)",
                                    "Esquecer de carregar ggplot2",
                                    "Não especificar h= no forecast()"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar os elementos do gráfico gerado",
                                  "subSteps": [
                                    "Identifique a linha preta: representa os valores observados da série",
                                    "Identifique a linha azul: valores ajustados pelo modelo (fitted)",
                                    "Analise as áreas sombreadas: intervalos de confiança (ex: 80% e 95%) para as previsões",
                                    "Verifique a legenda e eixos: tempo no x, valores no y",
                                    "Compare previsões com observados para avaliar precisão visual"
                                  ],
                                  "verification": "Descreva verbalmente ou anote os componentes principais do gráfico para confirmar compreensão",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Gráfico gerado do passo 2"
                                  ],
                                  "tips": "Faixas mais largas indicam maior incerteza; foque nisso para relatórios",
                                  "learningObjective": "Interpretar corretamente os componentes visuais de previsões em séries temporais",
                                  "commonMistakes": [
                                    "Confundir fitted com previsões futuras",
                                    "Ignorar intervalos de confiança",
                                    "Interpretar sombras como erros absolutos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Personalizar e integrar o gráfico em relatórios",
                                  "subSteps": [
                                    "Adicione camadas ggplot: autoplot(fc) + xlab('Tempo') + ylab('Valor') + theme_minimal()",
                                    "Inclua resíduos se relevante: autoplot(residuals(fit))",
                                    "Combine múltiplos gráficos: gridExtra::grid.arrange(autoplot(fc), autoplot(residuals(fit)))",
                                    "Exporte para PDF: ggsave('relatorio_previsoes.pdf', device='pdf')",
                                    "Inclua em um relatório RMarkdown: ```{r} autoplot(fc) ```"
                                  ],
                                  "verification": "Gere um gráfico customizado salvo sem erros e visualize em um viewer",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Pacote gridExtra (instale se necessário)",
                                    "RMarkdown para relatório opcional"
                                  ],
                                  "tips": "Use + para encadear funções ggplot2; theme_bw() para relatórios profissionais",
                                  "learningObjective": "Adaptar visualizações de autoplot() para uso em relatórios profissionais",
                                  "commonMistakes": [
                                    "Sobrecarregar com temas desnecessários",
                                    "Esquecer de instalar gridExtra",
                                    "Não ajustar dimensões na exportação"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dados de AirPassengers (embutidos no R), ajuste auto.arima(AirPassengers), gere forecast(h=12) e use autoplot() para visualizar o aumento sazonal de passageiros aéreos com intervalos de confiança, ideal para relatório de turismo.",
                              "finalVerifications": [
                                "Gráfico exibe linha observada (preta), fitted (azul) e previsões com sombras de CI",
                                "Legenda identifica corretamente 'observed', 'fitted' e níveis de confiança",
                                "Eixos estão rotulados adequadamente (tempo e valores)",
                                "Nenhum erro de classe de objeto ao executar autoplot()",
                                "Gráfico pode ser salvo e aberto externamente sem perda de qualidade",
                                "Interpretação escrita menciona incerteza nas previsões"
                              ],
                              "assessmentCriteria": [
                                "Aplicação correta de autoplot() em objeto forecast sem erros",
                                "Identificação precisa de todos os componentes visuais (observed, fitted, CI)",
                                "Customização básica do gráfico usando ggplot2 (títulos, labels)",
                                "Interpretação coerente da incerteza representada pelas faixas",
                                "Integração em relatório ou exportação funcional",
                                "Tempo de execução dentro do estimado com eficiência"
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Interpretação de intervalos de confiança",
                                "Programação: Manipulação de objetos em R e ggplot2",
                                "Design de Dados: Princípios de visualização clara (Tufte)",
                                "Comunicação: Criação de relatórios visuais persuasivos",
                                "Matemática: Modelos de séries temporais ARIMA"
                              ],
                              "realWorldApplication": "Em empresas de varejo, autoplot() é usado para visualizar previsões de vendas sazonais em dashboards, auxiliando decisões de estoque e marketing com evidências visuais de incerteza."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.5",
                    "name": "Avaliação de Previsões Automáticas",
                    "description": "Métricas e validação de modelos gerados por métodos automáticos de previsão.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.5.1",
                        "name": "Métricas de Erro para Avaliação de Previsões",
                        "description": "Conjunto de métricas quantitativas usadas para medir a precisão das previsões geradas por métodos automáticos em séries temporais, incluindo erros absolutos, quadráticos e percentuais.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.5.1.1",
                            "name": "Calcular o Erro Absoluto Médio (MAE)",
                            "description": "Computar o MAE como a média dos valores absolutos das diferenças entre valores previstos e observados, aplicando-o a previsões automáticas de séries temporais para avaliar a magnitude média dos erros.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito e a Fórmula do MAE",
                                  "subSteps": [
                                    "Defina MAE como a média dos erros absolutos entre valores previstos (ŷ) e observados (y).",
                                    "Estude a fórmula: MAE = (1/n) * Σ |y_i - ŷ_i| para i=1 a n.",
                                    "Compare com outras métricas como MSE para entender diferenças (MAE é menos sensível a outliers).",
                                    "Revise exemplos simples de séries temporais, como previsões de temperatura.",
                                    "Anote a importância do MAE em avaliações de previsões automáticas."
                                  ],
                                  "verification": "Explique a fórmula do MAE em suas próprias palavras e dê um exemplo numérico simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Folha de papel, calculadora, documento com fórmula MAE.",
                                  "tips": "Visualize com um gráfico de resíduos para intuitivamente entender erros absolutos.",
                                  "learningObjective": "Entender o que é MAE e sua fórmula matemática aplicada a séries temporais.",
                                  "commonMistakes": "Confundir com RMSE (que usa raiz quadrada) ou esquecer o valor absoluto."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Coletar e Organizar Dados de Valores Observados e Previstos",
                                  "subSteps": [
                                    "Obtenha um conjunto de dados de série temporal (ex: 10 valores observados e correspondentes previstos).",
                                    "Crie uma tabela com colunas: Tempo, Observado (y), Previsto (ŷ).",
                                    "Verifique consistência: mesmo número de observações e alinhamento temporal.",
                                    "Limpe dados ausentes ou inconsistentes.",
                                    "Escolha dados reais ou simulados de previsões automáticas (ex: ARIMA ou Prophet)."
                                  ],
                                  "verification": "Tabela organizada com pelo menos 5 pares de dados observados/previsos sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Planilha Excel/Google Sheets ou Jupyter Notebook com Python/Pandas.",
                                  "tips": "Use índices temporais corretos para evitar desalinhamentos em séries temporais.",
                                  "learningObjective": "Preparar dados reais de previsões para cálculo de MAE.",
                                  "commonMistakes": "Ignorar valores ausentes ou desalinhar séries temporais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular as Diferenças Absolutas e a Média",
                                  "subSteps": [
                                    "Para cada par, calcule a diferença: |y_i - ŷ_i|.",
                                    "Some todas as diferenças absolutas.",
                                    "Divida a soma pelo número de observações (n).",
                                    "Implemente manualmente primeiro, depois automatize em ferramenta.",
                                    "Registre o valor final do MAE com precisão decimal adequada (ex: 2 casas)."
                                  ],
                                  "verification": "Cálculo manual coincide com resultado em software (erro < 0.01).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora, planilha ou código Python (numpy.abs e mean).",
                                  "tips": "Use função ABS() no Excel ou np.abs() no Python para eficiência.",
                                  "learningObjective": "Executar o cálculo passo a passo do MAE.",
                                  "commonMistakes": "Esquecer o valor absoluto (resultando em erros negativos) ou dividir incorretamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar o Resultado e Verificar a Avaliação",
                                  "subSteps": [
                                    "Compare o MAE com baselines (ex: média histórica).",
                                    "Analise se o MAE indica bom ajuste (menor é melhor).",
                                    "Visualize erros com gráfico de linha (observado vs previsto).",
                                    "Teste sensibilidade removendo outliers.",
                                    "Documente insights para melhoria de modelos automáticos."
                                  ],
                                  "verification": "Relatório curto com interpretação do MAE e gráfico gerado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Gráfico em Excel/Matplotlib, relatório em texto.",
                                  "tips": "Sempre contextualize: MAE=5 em vendas de R$1000 é aceitável?",
                                  "learningObjective": "Interpretar MAE no contexto de avaliação de previsões de séries temporais.",
                                  "commonMistakes": "Interpretar MAE isolado sem comparação ou escala dos dados."
                                }
                              ],
                              "practicalExample": "Em uma série temporal de vendas mensais de uma loja (observados: [100, 120, 110, 130, 140]; previstos: [105, 118, 112, 128, 142]), calcule MAE: diferenças absolutas [5,2,2,2,2], soma=13, MAE=13/5=2.6. Isso indica erros médios de 2.6 unidades, bom para planejamento de estoque.",
                              "finalVerifications": [
                                "Calcula MAE corretamente para um novo conjunto de 10 dados.",
                                "Implementa MAE em Python ou Excel sem erros.",
                                "Interpreta se MAE<5 é aceitável para dados de temperatura diária.",
                                "Compara MAE com MSE em um exemplo.",
                                "Identifica outliers impactando MAE.",
                                "Gera gráfico de resíduos para visualização."
                              ],
                              "assessmentCriteria": [
                                "Precisão do cálculo (erro <0.01).",
                                "Correta aplicação da fórmula com valores absolutos.",
                                "Organização clara de dados em tabela.",
                                "Interpretação contextualizada do resultado.",
                                "Uso de ferramentas para automação.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Médias e valores absolutos.",
                                "Programação: Implementação em Python/R para análise de dados.",
                                "Negócios: Avaliação de modelos de previsão para estoque e finanças.",
                                "Ciência de Dados: Métricas em machine learning para séries temporais."
                              ],
                              "realWorldApplication": "Em empresas de e-commerce, calcular MAE avalia precisão de previsões automáticas de demanda (ex: Prophet), otimizando estoque e reduzindo custos em 10-20%; em meteorologia, mede erros médios de temperatura prevista."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.1.2",
                            "name": "Calcular o Erro Quadrático Médio (MSE) e Raiz do Erro Quadrático Médio (RMSE)",
                            "description": "Determinar o MSE como a média dos quadrados das diferenças entre previsões e observações reais, e extrair sua raiz quadrada para obter o RMSE, destacando erros maiores em métodos automáticos de previsão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos de MSE e RMSE",
                                  "subSteps": [
                                    "Defina MSE como a média dos quadrados das diferenças (erros) entre valores previstos e reais: MSE = (1/n) * Σ(y_i - ŷ_i)^2",
                                    "Explique que RMSE é a raiz quadrada do MSE: RMSE = √MSE, penalizando mais erros grandes",
                                    "Discuta por que quadrado é usado: torna erros positivos e enfatiza magnitudes maiores",
                                    "Compare com MAE: MSE/RMSE sensíveis a outliers",
                                    "Anote fórmulas em um papel para referência visual"
                                  ],
                                  "verification": "Escreva as fórmulas corretas de MSE e RMSE de memória e explique a diferença em uma frase",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora",
                                    "Acesso a um tutorial online sobre métricas de regressão"
                                  ],
                                  "tips": "Visualize com um gráfico: erros pequenos vs. grandes para ver o impacto do quadrado",
                                  "learningObjective": "Dominar as definições matemáticas e intuitivas de MSE e RMSE",
                                  "commonMistakes": [
                                    "Confundir MSE com média simples de erros",
                                    "Esquecer que RMSE é em unidades originais dos dados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar os Dados de Previsão e Observação",
                                  "subSteps": [
                                    "Colete ou crie um conjunto de dados com n pares: valores reais (y_i) e previstos (ŷ_i)",
                                    "Liste os dados em uma tabela: ex. reais: [10, 20, 30]; previstos: [12, 18, 32]",
                                    "Verifique que n >= 3 para média significativa",
                                    "Calcule diferenças brutas (y_i - ŷ_i) para cada par",
                                    "Registre unidades dos dados para interpretação posterior"
                                  ],
                                  "verification": "Crie uma tabela com pelo menos 5 pares de dados reais vs. previstos, sem erros de transcrição",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets",
                                    "Papel quadriculado"
                                  ],
                                  "tips": "Use dados reais de séries temporais, como vendas mensais, para relevância",
                                  "learningObjective": "Preparar dados limpos e organizados para cálculo preciso",
                                  "commonMistakes": [
                                    "Inverter reais e previstos",
                                    "Ignorar valores ausentes ou outliers iniciais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o MSE Passo a Passo",
                                  "subSteps": [
                                    "Para cada par, calcule o erro: e_i = y_i - ŷ_i",
                                    "Eleve cada erro ao quadrado: e_i^2",
                                    "Some todos os e_i^2: soma_total",
                                    "Divida pela quantidade de observações: MSE = soma_total / n",
                                    "Arredonde para 2 casas decimais e anote o resultado"
                                  ],
                                  "verification": "Reproduza o MSE manualmente e confirme com calculadora: deve bater exatamente",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Planilha para somas automáticas"
                                  ],
                                  "tips": "Faça cálculos em colunas separadas na planilha para rastrear erros",
                                  "learningObjective": "Executar o cálculo completo do MSE com precisão aritmética",
                                  "commonMistakes": [
                                    "Usar módulo |e_i| em vez de quadrado",
                                    "Dividir por n-1 em vez de n (reservado para variância amostral)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular o RMSE e Interpretar Resultados",
                                  "subSteps": [
                                    "Aplique a raiz quadrada ao MSE: RMSE = √MSE",
                                    "Compare RMSE com a escala dos dados originais (ex.: se y em dólares, RMSE indica erro médio em dólares)",
                                    "Interprete: RMSE baixo indica bom modelo; calcule % de erro relativo se possível",
                                    "Teste sensibilidade: altere um dado e recalcule para ver impacto",
                                    "Registre ambos MSE e RMSE com interpretação em contexto de previsão"
                                  ],
                                  "verification": "Calcule RMSE corretamente e explique se o erro é aceitável para o domínio (ex.: <10% da média y)",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora com função raiz",
                                    "Gráfico de resíduos opcional"
                                  ],
                                  "tips": "Use função SQRT no Excel para automação rápida após manual",
                                  "learningObjective": "Finalizar cálculo de RMSE e ganhar insights interpretativos",
                                  "commonMistakes": [
                                    "Esquecer raiz quadrada",
                                    "Interpretar MSE diretamente sem raiz (unidades erradas)"
                                  ]
                                }
                              ],
                              "practicalExample": "Dados de previsão de vendas: Reais: [100, 150, 200, 120]; Previstos: [105, 145, 210, 115]. Erros: [5,5,-10,5]; Quadrados: [25,25,100,25]; Soma: 175; n=4; MSE=43.75; RMSE=√43.75≈6.61. Interpretação: Erro médio de ~6.6 unidades, aceitável para vendas.",
                              "finalVerifications": [
                                "Cálculo manual de MSE e RMSE bate com ferramenta automatizada (Excel/Python)",
                                "Explicação correta da penalização de erros grandes pelo quadrado",
                                "Interpretação em unidades originais e comparação com escala dos dados",
                                "Identificação de impacto de outliers no RMSE",
                                "Reprodução do processo com novo dataset sem erros",
                                "Discussão de quando usar RMSE vs. outras métricas"
                              ],
                              "assessmentCriteria": [
                                "Precisão aritmética nos cálculos (erro <0.01)",
                                "Completude de todos substeps em cada step",
                                "Interpretação qualitativa correta de resultados",
                                "Uso adequado de fórmulas e unidades",
                                "Capacidade de aplicar a conjuntos de dados variados",
                                "Identificação e correção de erros comuns demonstrada"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra (potências, raízes) e estatística descritiva",
                                "Programação: Implementar em Python (numpy.mean((y - y_pred)**2)) ou R",
                                "Análise de Dados: Integração com visualizações de resíduos",
                                "Machine Learning: Avaliação de modelos de regressão",
                                "Finanças/Economia: Previsão de séries temporais econômicas"
                              ],
                              "realWorldApplication": "Em empresas de e-commerce, calcular RMSE de modelos de previsão de demanda para otimizar estoque; em meteorologia, avaliar precisão de forecasts de temperatura, onde RMSE <2°C é padrão aceitável para decisões operacionais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.1.3",
                            "name": "Aplicar o Erro Percentual Absoluto Médio (MAPE)",
                            "description": "Calcular o MAPE somando os erros percentuais absolutos divididos pelo valor observado e dividindo pelo número de observações, útil para séries temporais com escalas variáveis em previsões automáticas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Fórmula e Componentes do MAPE",
                                  "subSteps": [
                                    "Estude a fórmula do MAPE: MAPE = (1/n) * Σ (| (y_i - ŷ_i) / y_i | * 100%), onde y_i são valores observados, ŷ_i previstos e n o número de observações.",
                                    "Identifique os componentes chave: erro absoluto percentual para cada observação (|erro| / observado * 100%), soma dos erros percentuais e divisão por n.",
                                    "Revise pré-requisitos: divisão, módulo (valor absoluto), soma e média.",
                                    "Discuta limitações: MAPE é sensível a valores observados próximos de zero e não funciona bem com zeros.",
                                    "Anote exemplos simples manualmente para fixar o conceito."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a fórmula e dê um exemplo com n=2 observações.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta ou editor de texto; acesso a documentação de métricas de forecasting (ex: Wikipedia ou Khan Academy).",
                                  "tips": "Visualize com uma tabela: colunas para observado, previsto, erro abs, % erro.",
                                  "learningObjective": "Dominar a definição exata e limitações do MAPE para aplicação precisa.",
                                  "commonMistakes": "Confundir com MAE (não percentual); esquecer o *100% ou o valor absoluto."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar e Organizar os Dados de Entrada",
                                  "subSteps": [
                                    "Colete pares de dados: valores observados (y_i) e previstos (ŷ_i) para uma série temporal (ex: 10-20 observações).",
                                    "Crie uma tabela ou planilha com colunas: Observado, Previsto, garantindo ausência de zeros em observados.",
                                    "Valide dados: verifique se n >= 2, sem valores observados zero ou negativos (ajuste se necessário).",
                                    "Calcule diferenças iniciais (y_i - ŷ_i) para inspeção visual.",
                                    "Salve em formato editável como CSV ou Excel para cálculos subsequentes."
                                  ],
                                  "verification": "Tabela completa com dados válidos e resumo estatístico (média observada/prevista).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Planilha (Excel/Google Sheets) ou Jupyter Notebook; conjunto de dados de exemplo de séries temporais.",
                                  "tips": "Use funções como AVERAGE para resumos rápidos; filtre zeros antecipadamente.",
                                  "learningObjective": "Preparar dados limpos e estruturados essenciais para cálculos precisos de erro.",
                                  "commonMistakes": "Incluir zeros em observados (causa divisão por zero); dados inconsistentes em unidades."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Erros Percentuais Absolutos Individuais",
                                  "subSteps": [
                                    "Para cada par, calcule erro absoluto: |y_i - ŷ_i|.",
                                    "Divida pelo observado: |y_i - ŷ_i| / y_i.",
                                    "Multiplique por 100 para percentual: (|y_i - ŷ_i| / y_i) * 100%.",
                                    "Some todos os erros percentuais absolutos em uma nova coluna ou célula.",
                                    "Verifique cálculos individuais contra um exemplo manual para precisão."
                                  ],
                                  "verification": "Lista de erros % para todas observações, com soma total anotada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Planilha com fórmulas (ex: =ABS((B2-A2)/A2)*100 em Excel); calculadora para verificação.",
                                  "tips": "Copie fórmulas para todas linhas; use formatação condicional para erros >10%.",
                                  "learningObjective": "Executar cálculos per-observação com precisão aritmética.",
                                  "commonMistakes": "Esquecer valor absoluto (erros negativos); dividir errado (previsto/observado em vez de erro/observado)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Agregue o MAPE Final e Interprete os Resultados",
                                  "subSteps": [
                                    "Divida a soma dos erros % pelo número de observações: soma / n.",
                                    "Interprete: MAPE <10% excelente; 10-20% bom; >20% ruim.",
                                    "Compare com outras métricas (ex: MAE) se disponível.",
                                    "Documente o MAPE final e insights (ex: subperíodos com alto erro).",
                                    "Teste sensibilidade removendo outliers e recalculando."
                                  ],
                                  "verification": "Valor final de MAPE calculado e interpretado em parágrafo curto.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Planilha final; gráfico de erros % vs tempo para visualização.",
                                  "tips": "Use =SUM(coluna)/CONT.VALORES para automação; arredonde para 2 casas decimais.",
                                  "learningObjective": "Finalizar o cálculo agregado e extrair insights acionáveis.",
                                  "commonMistakes": "Esquecer dividir por n; interpretar sem contexto (ex: ignorar escala da série)."
                                }
                              ],
                              "practicalExample": "Em uma série temporal de vendas mensais de smartphones: Observados: [100, 120, 110, 130]; Previstos: [105, 115, 112, 125]. Calcule: Erros %: 5%, 4.17%, 1.82%, 3.85%. Soma=14.84%, MAPE=14.84%/4=3.71%. Indica previsão boa.",
                              "finalVerifications": [
                                "MAPE calculado bate com verificação manual em pelo menos 3 exemplos independentes.",
                                "Tabela de dados inclui todos erros % individuais sem divisão por zero.",
                                "Interpretação classifica precisão corretamente (<10% excelente, etc.).",
                                "Gráfico de resíduos mostra padrões não sistemáticos.",
                                "Recálculo com subconjunto de dados confirma consistência.",
                                "Documentação explica cada passo da fórmula aplicada."
                              ],
                              "assessmentCriteria": [
                                "Precisão aritmética: erros <0.1% de diferença em verificação.",
                                "Manipulação correta de dados: sem zeros ou inválidos processados.",
                                "Uso adequado da fórmula: valor absoluto e *100% aplicados.",
                                "Interpretação contextual: liga MAPE à qualidade da previsão.",
                                "Eficiência: automação via fórmulas onde possível.",
                                "Documentação clara: passos reproduzíveis por terceiros."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra básica (módulo, médias) e estatística descritiva.",
                                "Programação: Implementação em Python (pandas/numpy) ou R para automação.",
                                "Negócios: Análise de forecasting em supply chain e finanças.",
                                "Visualização de Dados: Gráficos de resíduos em ferramentas como Tableau."
                              ],
                              "realWorldApplication": "Em e-commerce, calcular MAPE para avaliar modelos de previsão de demanda de produtos, otimizando estoque e reduzindo custos em 15-20% ao identificar previsões ruins em picos sazonais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.1.4",
                            "name": "Interpretar métricas de erro em contexto de séries temporais",
                            "description": "Analisar o significado relativo de MAE, RMSE e MAPE em previsões automáticas, considerando estacionariedade e sazonalidade das séries para seleção do modelo mais apropriado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as definições e fórmulas das métricas MAE, RMSE e MAPE",
                                  "subSteps": [
                                    "Calcule MAE como a média dos valores absolutos dos erros residuais.",
                                    "Calcule RMSE como a raiz quadrada da média dos quadrados dos erros residuais.",
                                    "Calcule MAPE como a média dos erros percentuais absolutos.",
                                    "Compare visualmente as fórmulas em um quadro comparativo.",
                                    "Implemente as funções em Python usando NumPy para um conjunto de dados simples."
                                  ],
                                  "verification": "Crie um script Python que compute as três métricas para um vetor de erros de exemplo e exiba os resultados corretos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python com NumPy e Pandas; conjunto de dados de exemplo com valores reais e previstos.",
                                  "tips": "Lembre-se de que RMSE penaliza mais erros grandes devido ao quadrado.",
                                  "learningObjective": "Dominar as fórmulas matemáticas e diferenças intuitivas entre MAE, RMSE e MAPE.",
                                  "commonMistakes": "Confundir RMSE com desvio padrão sem considerar direção dos erros; ignorar divisão por zero em MAPE."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o impacto da estacionariedade nas métricas de erro",
                                  "subSteps": [
                                    "Teste estacionariedade usando teste ADF (Augmented Dickey-Fuller) em uma série não estacionária.",
                                    "Transforme a série para estacionariedade via diferenciação e recalcule métricas.",
                                    "Compare MAE, RMSE e MAPE antes e após a transformação.",
                                    "Observe como RMSE amplifica variâncias em séries com tendências fortes.",
                                    "Plote resíduos para visualizar padrões em séries estacionárias vs. não estacionárias."
                                  ],
                                  "verification": "Gere gráficos comparativos mostrando redução relativa nas métricas após tornar a série estacionária.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com statsmodels para teste ADF; dados de série temporal com tendência (ex: PIB simulado).",
                                  "tips": "Sempre verifique estacionariedade primeiro, pois afeta a interpretabilidade das métricas.",
                                  "learningObjective": "Entender como não-estacionariedade distorce métricas e favorece certos modelos.",
                                  "commonMistakes": "Assumir estacionariedade sem teste estatístico; usar MAPE em séries com zeros."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar o efeito da sazonalidade nas métricas de erro",
                                  "subSteps": [
                                    "Identifique sazonalidade via decomposição STL ou ACF/PACF.",
                                    "Aplique remoção sazonal e compare métricas em dados sazonais vs. dessazonalizados.",
                                    "Analise como MAPE é sensível a variações percentuais em picos sazonais.",
                                    "Teste modelos que capturam sazonalidade (ex: SARIMA) vs. simples e compare métricas.",
                                    "Documente trade-offs: RMSE sensível a erros em picos, MAE mais robusto."
                                  ],
                                  "verification": "Produza uma tabela comparativa de métricas para dados com e sem sazonalidade ajustada.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Python com statsmodels.tsa para decomposição STL; dados sazonais (ex: vendas mensais de varejo).",
                                  "tips": "Use MAPE para séries com magnitude variável, mas ajuste para sazonalidade forte.",
                                  "learningObjective": "Reconhecer como sazonalidade influencia a escolha relativa de métricas.",
                                  "commonMistakes": "Ignorar sazonalidade levando a subestimação de RMSE em picos; sobreajuste em dessazonalização."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar métricas e selecionar o modelo apropriado",
                                  "subSteps": [
                                    "Treine múltiplos modelos automáticos (ex: AutoARIMA, Prophet) em uma série real.",
                                    "Calcule e ranqueie MAE, RMSE, MAPE considerando contexto da série.",
                                    "Decida baseado em: MAE para erros absolutos uniformes, RMSE para penalizar outliers, MAPE para escalas variáveis.",
                                    "Valide com validação cruzada temporal (time series split).",
                                    "Justifique seleção em relatório curto."
                                  ],
                                  "verification": "Escreva um parágrafo justificando o modelo escolhido com evidências das métricas ajustadas ao contexto.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Python com pmdarima para AutoARIMA, Prophet; dataset público como AirPassengers.",
                                  "tips": "Combine métricas: use RMSE para precisão geral, MAPE para interpretabilidade relativa.",
                                  "learningObjective": "Aplicar análise relativa de métricas para decisão de modelagem em séries temporais.",
                                  "commonMistakes": "Selecionar apenas pelo menor valor absoluto sem contexto; leak de dados futuros."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e praticar interpretação integrada",
                                  "subSteps": [
                                    "Revise casos: série estacionária sem sazonalidade (priorize RMSE), com sazonalidade (MAPE).",
                                    "Simule cenários variados e interprete trade-offs.",
                                    "Crie um checklist para interpretação futura.",
                                    "Aplique a um novo dataset e documente insights.",
                                    "Discuta limitações das métricas (ex: MAPE em baixos valores)."
                                  ],
                                  "verification": "Complete um checklist de interpretação para um dataset inédito com conclusões coerentes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Datasets variados (ex: M4 competition); checklist template.",
                                  "tips": "Sempre contextualize: 'bom' depende do domínio e custo de erros.",
                                  "learningObjective": "Integrar todos os conceitos para interpretação holística e seleção robusta.",
                                  "commonMistakes": "Focar em uma métrica isolada; negligenciar custo negócio dos erros."
                                }
                              ],
                              "practicalExample": "Em um dataset de vendas semanais de uma loja de eletrônicos com sazonalidade anual (picos em dezembro), treine AutoARIMA e Prophet. MAE=150 unidades (erros absolutos moderados), RMSE=250 (penaliza estoque extra em picos), MAPE=12% (aceitável para planejamento). Selecione Prophet por melhor captura sazonal, apesar de RMSE ligeiramente maior.",
                              "finalVerifications": [
                                "Pode calcular e interpretar MAE, RMSE e MAPE corretamente em código.",
                                "Identifica corretamente estacionariedade e sazonalidade impactando métricas.",
                                "Justifica seleção de modelo com trade-offs relativos das métricas.",
                                "Produz gráficos e tabelas comparativas claras.",
                                "Aplica checklist em novo dataset com insights contextuais.",
                                "Reconhece limitações como sensibilidade de MAPE a zeros."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas fórmulas e cálculos das métricas (30%).",
                                "Análise contextual de estacionariedade/sazonalidade (25%).",
                                "Qualidade da comparação e justificativa de seleção (20%).",
                                "Uso adequado de ferramentas e visualizações (15%).",
                                "Profundidade de substeps e avoidance de erros comuns (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra e estatística descritiva para fórmulas de erro.",
                                "Programação: Implementação em Python/R para automação de análises.",
                                "Negócios: Aplicação em previsão de demanda e gestão de estoque.",
                                "Machine Learning: Validação cruzada e seleção de hiperparâmetros."
                              ],
                              "realWorldApplication": "Em finanças, interpretar RMSE alto em previsão de ações voláteis para ajustar risco; em supply chain, usar MAPE para otimizar inventário sazonal, evitando overstock em picos e faltas em vales, economizando milhões em custos operacionais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.5.2",
                        "name": "Técnicas de Validação de Modelos Automáticos",
                        "description": "Métodos específicos para validar a robustez e generalização de modelos de previsão automática em séries temporais, evitando vazamento de dados e respeitando a ordem temporal.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.5.2.1",
                            "name": "Implementar Validação Cruzada Temporal (Time Series Cross-Validation)",
                            "description": "Dividir a série temporal em janelas expansivas ou deslizantes para treinar e testar modelos automáticos, garantindo que previsões usem apenas dados passados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o Dataset de Série Temporal",
                                  "subSteps": [
                                    "Carregue o dataset de série temporal em um DataFrame do Pandas.",
                                    "Verifique a indexação temporal e defina-a como DatetimeIndex se necessário.",
                                    "Trate valores ausentes usando interpolação ou forward-fill adequado para séries temporais.",
                                    "Defina a variável alvo (target) e features, garantindo ordem cronológica.",
                                    "Visualize a série para identificar tendências, sazonalidade e anomalias."
                                  ],
                                  "verification": "Dataset carregado com index temporal correto, sem NaNs e plotado corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python, Pandas, Matplotlib/Seaborn",
                                  "tips": "Sempre use pd.to_datetime() para garantir formatação correta do índice.",
                                  "learningObjective": "Preparar dados temporais limpos e indexados corretamente para evitar erros em splits.",
                                  "commonMistakes": "Ignorar a ordem temporal ou tratar dados como independentes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Parâmetros da Validação Cruzada Temporal",
                                  "subSteps": [
                                    "Escolha o tipo: expanding window (janela expansiva) ou rolling window (janela deslizante).",
                                    "Defina o número de folds (ex: 5) e o tamanho inicial da janela de treino.",
                                    "Calcule o tamanho da janela de teste (ex: próximo período equivalente ao horizonte de previsão).",
                                    "Use TimeSeriesSplit do scikit-learn para parametrizar n_splits e test_size.",
                                    "Documente os parâmetros em um dicionário para reproducibilidade."
                                  ],
                                  "verification": "Parâmetros definidos e TimeSeriesSplit instanciado com atributos corretos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "scikit-learn (TimeSeriesSplit)",
                                  "tips": "Para previsões longas, prefira expanding; para robustez, use rolling.",
                                  "learningObjective": "Configurar CV temporal que respeite causalidade (apenas dados passados para treino).",
                                  "commonMistakes": "Usar KFold padrão em vez de TimeSeriesSplit, causando data leakage."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Divisão dos Dados em Folds Temporais",
                                  "subSteps": [
                                    "Instancie o modelo base (ex: RandomForestRegressor ou AutoARIMA).",
                                    "Gere os splits usando tscv.split(X, y) do TimeSeriesSplit.",
                                    "Para cada fold, extraia X_train, X_test, y_train, y_test mantendo ordem temporal.",
                                    "Armazene splits em uma lista de dicionários para iteração posterior.",
                                    "Verifique visualmente os splits plotando séries de treino/teste por fold."
                                  ],
                                  "verification": "Splits gerados sem sobreposição futura e visualizados corretamente.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "scikit-learn, Pandas",
                                  "tips": "Imprima shapes de cada split para confirmar tamanhos esperados.",
                                  "learningObjective": "Criar folds que simulam cenários reais de previsão out-of-sample.",
                                  "commonMistakes": "Invertendo treino/teste ou permitindo dados futuros no treino."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar Treinamento e Avaliação em Cada Fold",
                                  "subSteps": [
                                    "Inicialize listas para armazenar métricas (MSE, MAE, R2) por fold.",
                                    "Para cada split: treine o modelo em train, prediga em test, calcule métricas.",
                                    "Colete previsões e valores reais para análise posterior.",
                                    "Aplique scaling se necessário (ex: StandardScaler fit apenas no treino).",
                                    "Registre tempo de treino por fold para eficiência."
                                  ],
                                  "verification": "Métricas calculadas para todos folds sem erros de shape mismatch.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "scikit-learn (metrics), modelo de ML",
                                  "tips": "Use cross_val_score para automação inicial, mas customize para séries.",
                                  "learningObjective": "Avaliar performance média evitando overfitting temporal.",
                                  "commonMistakes": "Refitting scaler em test ou vazamento de features futuras."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Agregar Resultados e Analisar Desempenho",
                                  "subSteps": [
                                    "Calcule médias e desvios padrão das métricas across folds.",
                                    "Plote previsões vs reais para todos folds em um gráfico único.",
                                    "Compare com baseline (ex: média histórica ou naive forecast).",
                                    "Analise variância entre folds para detectar instabilidade.",
                                    "Salve resultados em CSV e modelo final treinado em todos dados passados."
                                  ],
                                  "verification": "Relatório com métricas agregadas, plots e comparação baseline gerados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Matplotlib, NumPy",
                                  "tips": "Use boxplots para variância de métricas entre folds.",
                                  "learningObjective": "Interpretar CV temporal para decisões confiáveis de modelagem.",
                                  "commonMistakes": "Média simples sem std, ignorando variabilidade."
                                }
                              ],
                              "practicalExample": "Usando dados mensais de vendas de uma loja (1980-2020), implemente TimeSeriesSplit com 5 folds expanding para prever vendas do próximo mês com RandomForestRegressor. Treine em dados até 2016 para primeiro fold, expandindo até 2019, avaliando MSE médio de 1500 unidades.",
                              "finalVerifications": [
                                "Nenhum dado futuro usado no treino de qualquer fold (verificar timestamps).",
                                "Métricas agregadas calculadas com std < 20% da média.",
                                "Plots mostram previsões respeitando ordem temporal sem leakage.",
                                "Comparação com naive forecast mostra melhoria >10%.",
                                "Código reproduzível com seed fixo produz mesmos splits.",
                                "Tempo total de CV < 5 minutos para dataset de 500 pontos."
                              ],
                              "assessmentCriteria": [
                                "Correção temporal: 100% dos splits usam apenas dados passados (obrigatório).",
                                "Qualidade das métricas: MSE médio < baseline e std baixa.",
                                "Robustez: Funciona com diferentes tamanhos de janela e folds.",
                                "Eficiência: Otimização de hiperparâmetros via CV temporal.",
                                "Documentação: Código comentado e parâmetros explicados.",
                                "Visualizações: Plots claros de folds e agregados."
                              ],
                              "crossCurricularConnections": [
                                "Machine Learning: Integração com validação cruzada em sklearn pipelines.",
                                "Estatística: Métricas de erro e análise de variância em previsões.",
                                "Programação: Manipulação avançada de Pandas e loops em Python.",
                                "Finanças/Economia: Aplicação em forecasting de mercado.",
                                "Visualização de Dados: Plots temporais com Matplotlib/Plotly."
                              ],
                              "realWorldApplication": "Em empresas de energia, usar CV temporal para validar modelos de previsão de demanda, evitando overfitting e garantindo que políticas de preço baseadas em forecasts sejam confiáveis, reduzindo custos operacionais em 15%."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.2.2",
                            "name": "Realizar Backtesting ou Walk-Forward Validation",
                            "description": "Simular previsões em tempo real retreinando o modelo automático periodicamente com dados históricos e avaliando em períodos out-of-sample subsequentes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o conjunto de dados históricos",
                                  "subSteps": [
                                    "Carregue os dados de série temporal em um formato pandas DataFrame.",
                                    "Verifique e trate valores ausentes, outliers e estacionariedade.",
                                    "Defina a variável alvo (ex: valor futuro da série) e features.",
                                    "Divida os dados em ordem cronológica, preservando a sequência temporal.",
                                    "Salve uma cópia limpa dos dados para reproducibilidade."
                                  ],
                                  "verification": "DataFrame limpo com índice temporal, sem NaNs e plotado corretamente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python com pandas, numpy",
                                    "Dados históricos (ex: CSV de preços de ações)",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Sempre use indexação temporal com pd.to_datetime para evitar erros de ordem.",
                                  "learningObjective": "Entender a importância da preparação de dados em séries temporais para validação robusta.",
                                  "commonMistakes": [
                                    "Ignorar a ordem temporal ao embaralhar dados",
                                    "Não tratar sazonalidade inicial",
                                    "Usar dados futuros para treinar períodos passados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir parâmetros do Walk-Forward Validation",
                                  "subSteps": [
                                    "Escolha o tamanho inicial da janela de treino (ex: 252 dias para anual).",
                                    "Defina o passo de avanço (ex: 1 dia para previsões diárias).",
                                    "Determine o horizonte de previsão (ex: 1 passo à frente).",
                                    "Calcule o número de iterações possível com os dados disponíveis.",
                                    "Documente os parâmetros em um dicionário para fácil ajuste."
                                  ],
                                  "verification": "Parâmetros documentados e número de folds calculado corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python",
                                    "Cálculo manual ou script para estimar folds"
                                  ],
                                  "tips": "Comece com janelas maiores para estabilidade, mas ajuste para cobrir todo o período out-of-sample.",
                                  "learningObjective": "Selecionar hiperparâmetros que simulem condições reais de deployment.",
                                  "commonMistakes": [
                                    "Janela de treino muito pequena levando a overfitting",
                                    "Passo maior que o horizonte causando gaps",
                                    "Não considerar dados suficientes para out-of-sample"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o loop de retreinamento e previsão",
                                  "subSteps": [
                                    "Inicialize listas para armazenar previsões e reais.",
                                    "Em um loop for, selecione janela de treino atual.",
                                    "Treine o modelo automático (ex: AutoARIMA ou Prophet) nos dados de treino.",
                                    "Gere previsões para o próximo período out-of-sample.",
                                    "Atualize a janela adicionando o período testado e avance."
                                  ],
                                  "verification": "Loop completa sem erros, com previsões coletadas para todos os folds.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Bibliotecas: pmdarima (AutoARIMA), prophet ou sktime",
                                    "Dados preparados do Step 1"
                                  ],
                                  "tips": "Use try-except no loop para pular folds com problemas de convergência.",
                                  "learningObjective": "Simular o processo dinâmico de retreinamento em produção.",
                                  "commonMistakes": [
                                    "Vazar dados futuros na janela de treino",
                                    "Não resetar o modelo a cada iteração",
                                    "Ignorar warnings de convergência"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular e coletar métricas de performance",
                                  "subSteps": [
                                    "Compile séries de valores reais e previstos em um DataFrame.",
                                    "Calcule métricas agregadas: MAE, RMSE, MAPE, MASE.",
                                    "Compute métricas rolling (ex: média móvel de erros).",
                                    "Compare com baseline (ex: naive forecast).",
                                    "Salve métricas em um relatório JSON ou CSV."
                                  ],
                                  "verification": "Métricas calculadas e comparadas com baseline, valores razoáveis.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python com scikit-learn.metrics ou statsmodels",
                                    "Previsões do Step 3"
                                  ],
                                  "tips": "Use MASE para séries com tendência/sazonalidade, pois é scale-independent.",
                                  "learningObjective": "Avaliar performance de forma agregada e temporalmente sensível.",
                                  "commonMistakes": [
                                    "Calcular métricas em todo período em vez de out-of-sample",
                                    "Esquecer baseline para contexto",
                                    "Dividir por zero em MAPE"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Visualizar e interpretar os resultados",
                                  "subSteps": [
                                    "Plote a série original com bandas de previsão e reais.",
                                    "Crie gráficos de resíduos e ACF de erros.",
                                    "Analise drift de performance ao longo do tempo.",
                                    "Interprete implicações para o modelo (ex: necessidade de retrain mais frequente).",
                                    "Gere um relatório com insights acionáveis."
                                  ],
                                  "verification": "Gráficos gerados e relatório com conclusões claras.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Matplotlib, seaborn ou plotly"
                                  ],
                                  "tips": "Foque em visualizações que destaquem mismatches temporais, como zoom em períodos ruins.",
                                  "learningObjective": "Diagnosticar fraquezas do modelo via validação walk-forward.",
                                  "commonMistakes": [
                                    "Overfitting visual (zoom seletivo)",
                                    "Ignorar heteroscedasticidade nos resíduos",
                                    "Concluir sem comparar com baselines"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dados diários de preços de fechamento da ação AAPL (2015-2023), configure um AutoARIMA com janela inicial de 252 dias de treino, avançando 1 dia por vez para prever o preço do dia seguinte em 5 anos out-of-sample. Calcule RMSE final e plote para identificar degradação de performance pós-2020.",
                              "finalVerifications": [
                                "Loop de walk-forward executa para >80% dos dados out-of-sample sem erros.",
                                "Métricas (MAE, RMSE, MAPE) calculadas corretamente e inferiores ao baseline naive.",
                                "Gráficos mostram alinhamento temporal entre reais e previstos.",
                                "Relatório identifica padrões de drift ou instabilidade.",
                                "Código é reproduzível com seed e parâmetros documentados.",
                                "Interpretação discute limitações como mudanças de regime no mercado."
                              ],
                              "assessmentCriteria": [
                                "Precisão das implementações: código roda sem erros e produz resultados consistentes.",
                                "Qualidade das métricas: valores coerentes e comparados adequadamente.",
                                "Profundidade da análise: identifica pelo menos 2 insights acionáveis.",
                                "Visualizações: claras, legíveis e informativas.",
                                "Documentação: passos e parâmetros bem explicados.",
                                "Eficiência: tempo de execução razoável (<10min para dataset médio)."
                              ],
                              "crossCurricularConnections": [
                                "Programação em Python (loops, vetores, bibliotecas de ML).",
                                "Estatística Inferencial (testes de resíduos, métricas de erro).",
                                "Machine Learning (validação cruzada temporal).",
                                "Finanças e Economia (previsão de ativos, risk management).",
                                "Gestão de Projetos (reprodutibilidade e relatórios)."
                              ],
                              "realWorldApplication": "Em trading algorítmico, fundos de hedge usam walk-forward para validar modelos de previsão de retornos antes de alocar capital real, evitando overfitting e simulando condições de mercado ao vivo em plataformas como QuantConnect ou backtrader."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.2.3",
                            "name": "Avaliar Overfitting em Modelos Automáticos",
                            "description": "Comparar desempenho in-sample e out-of-sample usando métricas de erro para detectar sobreajuste em métodos automáticos de previsão de séries temporais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Overfitting",
                                  "subSteps": [
                                    "Defina overfitting como a discrepância entre bom desempenho in-sample (treino) e ruim out-of-sample (teste/validação).",
                                    "Explique in-sample error: métrica calculada nos dados de treino usados para ajustar o modelo.",
                                    "Explique out-of-sample error: métrica em dados não vistos durante o treino.",
                                    "Liste métricas comuns para séries temporais: MAE, RMSE, MAPE.",
                                    "Discuta por que métodos automáticos (ex: auto.arima) são propensos a overfitting devido à seleção automática de parâmetros."
                                  ],
                                  "verification": "Resuma em suas palavras os conceitos e dê um exemplo simples de overfitting em uma regressão linear.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Documentação de auto.arima (pmdarima)",
                                    "Artigos sobre overfitting em séries temporais",
                                    "Notebook Jupyter vazio"
                                  ],
                                  "tips": [
                                    "Use diagramas visuais para diferenciar in-sample vs out-of-sample.",
                                    "Relacione com viés-variância tradeoff."
                                  ],
                                  "learningObjective": "Identificar e explicar overfitting em contextos de previsão automática de séries temporais.",
                                  "commonMistakes": [
                                    "Confundir in-sample com validação cruzada.",
                                    "Ignorar autocorrelação em erros out-of-sample."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar e Dividir o Dataset de Séries Temporais",
                                  "subSteps": [
                                    "Carregue um dataset de séries temporais (ex: AirPassengers do R ou Python).",
                                    "Verifique estacionariedade e realize transformações se necessário (log, diferenciação).",
                                    "Divida em treino (80%) e teste (20%), preservando ordem temporal.",
                                    "Implemente funções para calcular métricas de erro: MAE, RMSE.",
                                    "Visualize séries de treino e teste para confirmar divisão adequada."
                                  ],
                                  "verification": "Plote as séries de treino e teste; confirme que não há vazamento de dados futuros para o treino.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": [
                                    "Python com pandas, numpy, matplotlib",
                                    "Dataset AirPassengers (disponível em datasets R ou statsmodels)",
                                    "Biblioteca pmdarima"
                                  ],
                                  "tips": [
                                    "Use train_test_split com shuffle=False para séries temporais.",
                                    "Reserve pelo menos 20% para teste out-of-sample."
                                  ],
                                  "learningObjective": "Preparar dados temporais corretamente para avaliação de overfitting.",
                                  "commonMistakes": [
                                    "Shuffle aleatório nos dados temporais.",
                                    "Divisão muito pequena para teste, levando a estimativas instáveis."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Treinar Modelo Automático e Calcular Erros",
                                  "subSteps": [
                                    "Ajuste um modelo automático como auto.arima() nos dados de treino.",
                                    "Calcule erros in-sample: previsões no conjunto de treino vs valores reais.",
                                    "Gere previsões out-of-sample no conjunto de teste.",
                                    "Calcule erros out-of-sample usando as mesmas métricas.",
                                    "Registre valores numéricos de erros para comparação."
                                  ],
                                  "verification": "Obtenha valores concretos: ex. RMSE in-sample = 10, out-of-sample = 25.",
                                  "estimatedTime": "60-90 minutos",
                                  "materials": [
                                    "pmdarima ou statsforecast",
                                    "Jupyter Notebook com código reproduzível",
                                    "Funções personalizadas para métricas"
                                  ],
                                  "tips": [
                                    "Use stepwise=False em auto.arima para exploração mais ampla.",
                                    "Padronize métricas para comparação direta."
                                  ],
                                  "learningObjective": "Implementar fitting e scoring in/out-of-sample em métodos automáticos.",
                                  "commonMistakes": [
                                    "Treinar no conjunto completo, contaminando out-of-sample.",
                                    "Usar métricas inconsistentes entre in/out."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Erros e Diagnosticar Overfitting",
                                  "subSteps": [
                                    "Compare quantitativamente: se out-of-sample >> in-sample (ex: RMSE_test > 1.5 * RMSE_train), detecte overfitting.",
                                    "Visualize resíduos e previsões para padrões (ex: plot de previsão vs real).",
                                    "Aplique testes adicionais: ACF de resíduos out-of-sample para autocorrelação.",
                                    "Interprete: alto gap indica overfitting; sugira regularização ou simplificação.",
                                    "Documente diagnóstico em relatório curto."
                                  ],
                                  "verification": "Crie tabela comparativa de erros e gráfico de resíduos sem padrões evidentes.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": [
                                    "Bibliotecas de plot: seaborn/matplotlib",
                                    "statsmodels para testes de resíduos"
                                  ],
                                  "tips": [
                                    "Defina threshold: gap > 20-50% sugere overfitting.",
                                    "Combine com CV temporal para robustez."
                                  ],
                                  "learningObjective": "Diagnosticar e quantificar overfitting comparando métricas de erro.",
                                  "commonMistakes": [
                                    "Ignorar escala das métricas ao comparar.",
                                    "Concluir sem visualizações de suporte."
                                  ]
                                }
                              ],
                              "practicalExample": "Usando o dataset AirPassengers (passageiros aéreos mensais 1949-1960): Divida em treino (até 1958) e teste (1959-1960). Ajuste auto.arima, calcule RMSE in-sample ~15 e out-of-sample ~50, detectando overfitting devido à complexidade do modelo ARIMA(2,1,2). Simplifique para ARIMA(0,1,1) e reavalie.",
                              "finalVerifications": [
                                "Detecta corretamente overfitting quando RMSE out-of-sample excede 1.5x in-sample.",
                                "Calcula MAE, RMSE e MAPE consistentemente para ambos os conjuntos.",
                                "Visualiza previsões e resíduos sem vazamento temporal.",
                                "Sugere ações corretivas baseadas no diagnóstico (ex: reduzir ordem do modelo).",
                                "Reproduz análise em novo dataset com resultados coerentes.",
                                "Explica impacto do overfitting em previsões reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção e cálculo de erros in/out-of-sample (90%+ acurácia).",
                                "Uso correto de divisão temporal sem shuffle.",
                                "Interpretação qualitativa e quantitativa do gap de performance.",
                                "Qualidade das visualizações e testes de resíduos.",
                                "Capacidade de aplicar em modelo automático diferente (ex: ETS).",
                                "Relatório claro com thresholds e recomendações."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python/R para automação de métricas.",
                                "Machine Learning: Conceitos de viés-variância e validação cruzada temporal.",
                                "Estatística: Testes de hipóteses em resíduos (Ljung-Box).",
                                "Negócios: Aplicação em forecasting para decisões estratégicas.",
                                "Visualização de Dados: Plots de séries e erros para comunicação."
                              ],
                              "realWorldApplication": "Em finanças, detectar overfitting em modelos auto.arima para previsão de retornos de ações evita estratégias falhas que performam bem historicamente mas falham em cenários reais, economizando milhões em trading automatizado."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.5.3",
                        "name": "Seleção e Comparação de Modelos Automáticos",
                        "description": "Processo de escolha do melhor modelo entre opções geradas automaticamente com base em métricas de avaliação e validação em séries temporais.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.5.3.1",
                            "name": "Comparar múltiplos modelos automáticos por métricas",
                            "description": "Rankear modelos de previsão automática (ex.: ARIMA auto, ETS auto) usando tabelas de MAE, RMSE e MAPE de validações cruzadas temporais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar dados e treinar múltiplos modelos automáticos",
                                  "subSteps": [
                                    "Carregar e pré-processar a série temporal (remover missing values, testar estacionariedade)",
                                    "Dividir dados em treino e teste respeitando ordem temporal",
                                    "Treinar pelo menos 3 modelos automáticos (ex.: auto.arima, auto.ets, thetaf)",
                                    "Gerar previsões iniciais para validação",
                                    "Salvar objetos de modelos para reutilização"
                                  ],
                                  "verification": "Verificar se todos os modelos foram treinados sem erros e previsões iniciais geradas",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Biblioteca forecast (R) ou pmdarima/sklearn (Python)",
                                    "Dataset de série temporal (ex.: AirPassengers)"
                                  ],
                                  "tips": "Use funções automáticas para evitar overfitting manual; sempre preserve a ordem temporal",
                                  "learningObjective": "Dominar treinamento automatizado de modelos de séries temporais",
                                  "commonMistakes": [
                                    "Ignorar sazonalidade nos dados",
                                    "Usar divisão aleatória em vez de temporal",
                                    "Treinar apenas um modelo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar validação cruzada temporal e calcular métricas",
                                  "subSteps": [
                                    "Configurar validação cruzada temporal (ex.: tsCV no R ou TimeSeriesSplit no Python)",
                                    "Gerar previsões out-of-sample para cada modelo em múltiplos folds",
                                    "Calcular MAE, RMSE e MAPE para cada fold e modelo",
                                    "Média das métricas por modelo",
                                    "Visualizar resíduos e previsões para diagnóstico"
                                  ],
                                  "verification": "Tabela com métricas calculadas para cada modelo e fold sem valores NaN",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Funções tsCV/accuracy (R) ou cross_val_score (Python)",
                                    "Gráficos de resíduos"
                                  ],
                                  "tips": "Use horizonte de previsão fixo (ex.: h=12); priorize MAPE para escalas variáveis",
                                  "learningObjective": "Aplicar validação cruzada adequada para séries temporais",
                                  "commonMistakes": [
                                    "Usar CV padrão em vez de temporal",
                                    "Calcular métricas em treino",
                                    "Ignorar bias em folds iniciais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compilar e organizar resultados em tabela comparativa",
                                  "subSteps": [
                                    "Criar DataFrame/tabela com colunas: Modelo, MAE, RMSE, MAPE (médias e desvios)",
                                    "Ordenar tabela por métrica principal (ex.: MAPE crescente)",
                                    "Adicionar ranking relativo (1 melhor, N pior)",
                                    "Formatar tabela para clareza (arredondar decimais, destacar melhor)",
                                    "Exportar como CSV ou imagem para relatório"
                                  ],
                                  "verification": "Tabela legível com rankings e todas métricas preenchidas corretamente",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Pandas (Python) ou data.frame (R)",
                                    "Ferramentas de formatação como knitr ou matplotlib"
                                  ],
                                  "tips": "Inclua intervalos de confiança nas métricas para robustez",
                                  "learningObjective": "Estruturar comparações de forma visual e tabular eficiente",
                                  "commonMistakes": [
                                    "Esquecer desvios padrão",
                                    "Rankear sem normalizar escalas",
                                    "Tabela desorganizada"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar, rankear e selecionar o melhor modelo",
                                  "subSteps": [
                                    "Interpretar métricas: RMSE para erros absolutos, MAPE para relativos",
                                    "Rankear por múltiplas métricas (ex.: média ponderada)",
                                    "Testar significância (ex.: Diebold-Mariano test)",
                                    "Selecionar modelo vencedor e justificar",
                                    "Documentar trade-offs (ex.: complexidade vs performance)"
                                  ],
                                  "verification": "Relatório com ranking final, justificativa e teste estatístico",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Teste DMtest (R) ou dm_test (Python)",
                                    "Relatório Markdown"
                                  ],
                                  "learningObjective": "Realizar análise comparativa estatisticamente robusta",
                                  "commonMistakes": [
                                    "Rankear apenas por uma métrica",
                                    "Ignorar custo computacional",
                                    "Sem testes de significância"
                                  ],
                                  "tips": [
                                    "Utilize métricas normalizadas ou escalonadas quando combinar RMSE e MAPE em ranking ponderado",
                                    "Aplicar o teste Diebold-Mariano com horizonte de previsão adequado ao contexto do problema",
                                    "Considerar a curva de aprendizado do modelo para evitar viés de overfitting na seleção",
                                    "Incluir métricas de custo computacional (tempo de treino/inferência) no ranking final",
                                    "Documentar sensibilidade do ranking a diferentes pesos nas métricas para análise de robustez",
                                    "Verificar se a diferença de desempenho é estatisticamente significativa antes de declarar um vencedor"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dataset de vendas mensais de lojas (ex.: Walmart), treine auto.arima, auto.ets e TBATS; realize CV temporal com h=6; compile tabela mostrando ETS com MAPE=8.2% (rank 1), ARIMA=9.5% (rank 2); selecione ETS para previsão de demanda.",
                              "finalVerifications": [
                                "Tabela comparativa completa com MAE, RMSE, MAPE e rankings",
                                "Validação cruzada temporal executada corretamente sem leakage",
                                "Modelo selecionado justificado por múltiplas métricas",
                                "Teste estatístico confirma superioridade",
                                "Previsões plotadas com intervalos para o modelo vencedor",
                                "Relatório exportado e reproduzível"
                              ],
                              "assessmentCriteria": [
                                "Precisão nas métricas calculadas (erro <1%)",
                                "Correta implementação de CV temporal",
                                "Tabela clara e rankeada logicamente",
                                "Interpretação contextual das métricas",
                                "Uso de testes estatísticos para comparação",
                                "Documentação completa e reproduzível"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Manipulação de dados com Pandas/R (Ciência da Computação)",
                                "Estatística Inferencial: Testes de hipóteses como Diebold-Mariano",
                                "Visualização de Dados: Gráficos de previsões e resíduos",
                                "Gestão de Projetos: Seleção de modelos por trade-offs",
                                "Machine Learning: Ensemble e hyperparameter tuning automático"
                              ],
                              "realWorldApplication": "Em finanças, comparar modelos para previsão de ações (ex.: rankear ARIMA vs Prophet para retornos diários, minimizando perdas em portfólios); em supply chain, selecionar melhor forecaster para estoque, reduzindo overstock em 15% via menor MAPE."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.3.2",
                            "name": "Selecionar modelo ótimo considerando contexto da aplicação",
                            "description": "Escolher o modelo automático ideal integrando métricas de erro, validação temporal e domínios como finanças ou marketing, priorizando interpretabilidade e precisão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar o contexto da aplicação e requisitos específicos",
                                  "subSteps": [
                                    "Identifique o domínio da aplicação (ex.: finanças, marketing).",
                                    "Defina os objetivos principais (previsão de curto/longo prazo, precisão vs velocidade).",
                                    "Examine as características dos dados (sazonalidade, tendência, ruído).",
                                    "Liste restrições como interpretabilidade necessária ou recursos computacionais.",
                                    "Documente prioridades: precisão, interpretabilidade ou escalabilidade."
                                  ],
                                  "verification": "Crie um relatório de contexto com pelo menos 5 pontos chave documentados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Dataset de séries temporais (ex.: dados de vendas ou ações), notebook Jupyter ou RStudio.",
                                  "tips": "Use mind maps para visualizar trade-offs iniciais.",
                                  "learningObjective": "Compreender como o contexto influencia a escolha do modelo.",
                                  "commonMistakes": "Ignorar sazonalidade ou assumir universalidade de métricas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Avaliar métricas de erro e validação temporal",
                                  "subSteps": [
                                    "Calcule métricas como MAE, RMSE, MAPE em validação cruzada temporal.",
                                    "Aplique validação walk-forward para simular previsão real.",
                                    "Compare performance em subperíodos (treinamento, teste out-of-sample).",
                                    "Analise resíduos para detectar padrões não capturados.",
                                    "Pondere métricas pelo contexto (ex.: penalizar erros em picos para finanças)."
                                  ],
                                  "verification": "Gere tabelas comparativas de métricas para pelo menos 3 modelos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Bibliotecas Python (scikit-learn, statsmodels) ou R (forecast), dataset limpo.",
                                  "tips": "Sempre use split temporal, nunca shuffle aleatório.",
                                  "learningObjective": "Dominar avaliação quantitativa adaptada a séries temporais.",
                                  "commonMistakes": "Usar validação k-fold padrão em vez de temporal."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar modelos considerando interpretabilidade e trade-offs",
                                  "subSteps": [
                                    "Liste candidatos: ARIMA, Prophet, LSTM, XGBoost para séries temporais.",
                                    "Avalie interpretabilidade (ex.: coeficientes ARIMA vs black-box neural nets).",
                                    "Pontue trade-offs: precisão vs tempo de treino vs explicabilidade.",
                                    "Considere robustez a outliers ou mudanças de regime.",
                                    "Crie matriz de decisão com pesos para cada critério contextual."
                                  ],
                                  "verification": "Elabore uma matriz de comparação com scores normalizados.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Ferramentas de visualização (Matplotlib/ggplot), modelos pré-treinados.",
                                  "tips": "Atribua pesos subjetivos baseados no contexto (ex.: 40% interpretabilidade em marketing).",
                                  "learningObjective": "Integrar fatores qualitativos e quantitativos na comparação.",
                                  "commonMistakes": "Priorizar apenas precisão sem contexto."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Selecionar e justificar o modelo ótimo",
                                  "subSteps": [
                                    "Escolha o modelo com melhor score ponderado.",
                                    "Justifique com evidências de métricas, contexto e trade-offs.",
                                    "Teste sensibilidade alterando pesos ou cenários.",
                                    "Documente alternativas rejeitadas e razões.",
                                    "Prepare recomendação acionável com hiperparâmetros finais."
                                  ],
                                  "verification": "Escreva um parágrafo de justificativa com referências a análises anteriores.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Template de relatório, software de modelagem.",
                                  "tips": "Use ranking multi-critério como TOPSIS para objetividade.",
                                  "learningObjective": "Tomar decisões informadas e defensáveis.",
                                  "commonMistakes": "Selecionar por viés de performance em-sample apenas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar seleção com simulação de deployment",
                                  "subSteps": [
                                    "Simule atualizações em tempo real com novos dados.",
                                    "Monitore drift de performance pós-seleção.",
                                    "Compare com baseline simples (média móvel).",
                                    "Colete feedback qualitativo de stakeholders.",
                                    "Planeje retrain e monitoramento contínuo."
                                  ],
                                  "verification": "Execute simulação e gere relatório de estabilidade.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Pipeline de MLflow ou similar para tracking.",
                                  "tips": "Inclua buffer para incertezas em aplicações críticas.",
                                  "learningObjective": "Garantir robustez da seleção no mundo real.",
                                  "commonMistakes": "Parar na avaliação estática sem simulação dinâmica."
                                }
                              ],
                              "practicalExample": "Em marketing, para prever vendas semanais de um produto sazonal: analise contexto (picos em feriados), avalie Prophet (alta interpretabilidade) vs LSTM (alta precisão), selecione Prophet por necessidade de explicar drivers de vendas a gerentes, validando com walk-forward em dados de 2 anos.",
                              "finalVerifications": [
                                "Modelo selecionado supera baselines em métricas contextuais.",
                                "Justificativa escrita cobre métricas, trade-offs e domínio.",
                                "Matriz de decisão completa e ponderada.",
                                "Simulação de deployment sem drift significativo.",
                                "Documentação inclui alternativas rejeitadas.",
                                "Stakeholders confirmam alinhamento com necessidades."
                              ],
                              "assessmentCriteria": [
                                "Precisão da análise contextual (30%).",
                                "Correta aplicação de métricas temporais (25%).",
                                "Equilíbrio de trade-offs demonstrado (20%).",
                                "Justificativa clara e evidenciada (15%).",
                                "Validação robusta e simulação (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python/R para automação.",
                                "Negócios: Alinhamento com KPIs de finanças/marketing.",
                                "Matemática: Compreensão de otimização multi-objetivo.",
                                "Ética: Consideração de viés em modelos black-box."
                              ],
                              "realWorldApplication": "Em bancos, selecionar modelo para previsão de demanda de crédito, priorizando interpretabilidade para relatórios regulatórios; em e-commerce, escolher para estoque, balanceando precisão e velocidade para milhões de SKUs."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.3.3",
                            "name": "Gerar relatórios de avaliação de previsões",
                            "description": "Produzir resumos visuais e tabulares com gráficos de resíduos, previsões vs. reais e métricas para documentar a avaliação de métodos automáticos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Coletar e Preparar Dados de Previsões e Valores Reais",
                                  "subSteps": [
                                    "Identifique os dados de séries temporais com valores observados e previsões geradas por modelos automáticos.",
                                    "Alinhe os timestamps para garantir correspondência entre previsões e reais.",
                                    "Calcule resíduos iniciais (real - previsão) e organize em um DataFrame ou estrutura tabular.",
                                    "Trate valores ausentes ou outliers que possam distorcer a análise.",
                                    "Salve os dados preparados em um formato acessível como CSV ou Pandas DataFrame."
                                  ],
                                  "verification": "Verifique se o DataFrame contém colunas 'data', 'real', 'previsao' e 'residuo' sem valores NaN.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python com pandas e numpy",
                                    "Dados de séries temporais de exemplo",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Use pd.merge() para alinhar séries por timestamp e visualize com df.head() para inspeção rápida.",
                                  "learningObjective": "Preparar dados limpos e alinhados para análise de previsões.",
                                  "commonMistakes": [
                                    "Ignorar desalinhamento de datas",
                                    "Não tratar NaNs",
                                    "Confundir previsão com real"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Métricas de Avaliação Quantitativas",
                                  "subSteps": [
                                    "Implemente funções para MAE, RMSE, MAPE e MASE usando fórmulas padrão.",
                                    "Aplique as métricas aos dados preparados.",
                                    "Compare métricas entre múltiplos modelos automáticos se disponível.",
                                    "Arredonde resultados para 4 casas decimais e crie um dicionário ou tabela de resumo.",
                                    "Teste as funções com dados sintéticos para validar cálculos."
                                  ],
                                  "verification": "Execute print(metrics_dict) e confirme valores coerentes (ex: RMSE > 0).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Bibliotecas scikit-learn ou fórmulas customizadas em Python",
                                    "Código de métricas pré-definido"
                                  ],
                                  "tips": "Use numpy.mean() e abs() para eficiência; valide com casos conhecidos.",
                                  "learningObjective": "Dominar cálculo e interpretação de métricas de previsão.",
                                  "commonMistakes": [
                                    "Dividir por zero em MAPE",
                                    "Usar escala errada em MASE",
                                    "Esquecer normalização"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar Visualizações de Resíduos e Previsões vs. Reais",
                                  "subSteps": [
                                    "Crie gráfico de linha para previsões vs. reais ao longo do tempo.",
                                    "Gere scatter plot de previsões vs. reais com linha de referência y=x.",
                                    "Plote resíduos em gráfico de linha e histograma para checar normalidade.",
                                    "Adicione títulos, labels e legendas profissionais usando matplotlib ou seaborn.",
                                    "Salve figuras em alta resolução como PNG ou PDF."
                                  ],
                                  "verification": "Visualize os plots e confirme legibilidade, escalas corretas e ausência de sobreposições.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Matplotlib, seaborn",
                                    "Dados preparados do Step 1"
                                  ],
                                  "tips": "Use plt.figure(figsize=(10,6)) para tamanhos adequados; seaborn para estilos modernos.",
                                  "learningObjective": "Criar visualizações diagnósticas claras para avaliação de modelos.",
                                  "commonMistakes": [
                                    "Escalas logarítmicas desnecessárias",
                                    "Falta de labels",
                                    "Plots muito densos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Compilar Relatório Tabular e Visual Integrado",
                                  "subSteps": [
                                    "Crie tabela Markdown ou HTML com métricas lado a lado para modelos.",
                                    "Incorpore gráficos salvos na tabela usando subplots ou relatório em PDF.",
                                    "Adicione seções de interpretação: forças, fraquezas e recomendações.",
                                    "Gere relatório final via Jupyter nbconvert ou reportlab para PDF.",
                                    "Revise e exporte com timestamp e título descritivo."
                                  ],
                                  "verification": "Abra o relatório gerado e confirme inclusão de todos elementos: tabelas, gráficos e texto.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Jupyter Notebook ou Streamlit para dashboard",
                                    "Bibliotecas reportlab ou weasyprint"
                                  ],
                                  "tips": "Use pandas.to_markdown() para tabelas rápidas; teste exportação em diferentes formatos.",
                                  "learningObjective": "Produzir relatórios profissionais e acionáveis.",
                                  "commonMistakes": [
                                    "Gráficos não incorporados",
                                    "Tabelas sem formatação",
                                    "Falta de conclusões"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dados de vendas mensais de uma loja online (série temporal de 3 anos), gere previsões com Prophet e AutoARIMA, calcule métricas (MAE=150, RMSE=220), plote resíduos mostrando heteroscedasticidade e compile um PDF relatório recomendando Prophet para produção.",
                              "finalVerifications": [
                                "Relatório inclui tabela com MAE, RMSE, MAPE e MASE para todos modelos.",
                                "Gráficos de previsões vs. reais e resíduos estão presentes e legíveis.",
                                "Interpretação qualitativa das métricas e visualizações é incluída.",
                                "Arquivo final é exportado em PDF ou HTML interativo.",
                                "Comparação entre modelos destaca o melhor performer.",
                                "Timestamp e metadados do dataset estão documentados."
                              ],
                              "assessmentCriteria": [
                                "Precisão das métricas calculadas (erro <1% em validação sintética).",
                                "Clareza e profissionalismo dos gráficos (labels, cores, resolução).",
                                "Completude do relatório (todos elementos visuais e tabulares).",
                                "Interpretação correta de padrões em resíduos (ex: autocorrelação).",
                                "Eficiência do código (modular e reutilizável).",
                                "Aplicação de melhores práticas de visualização (ex: gridlines, anotações)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Uso de Python para automação de relatórios.",
                                "Visualização de Dados: Técnicas de storytelling com gráficos.",
                                "Comunicação: Estruturação de relatórios para stakeholders.",
                                "Matemática: Compreensão de estatística inferencial em resíduos."
                              ],
                              "realWorldApplication": "Em empresas de e-commerce, gerar relatórios mensais de forecasting de demanda para otimizar estoque e planejamento de supply chain, permitindo decisões baseadas em evidências como selecionar o modelo com menor RMSE para produção."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.8",
                "name": "Aplicações de Séries Temporais",
                "description": "Utilizações práticas em finanças, marketing e operações.",
                "totalSkills": 29,
                "atomicTopics": [
                  {
                    "id": "10.1.8.1",
                    "name": "Aplicações em Finanças",
                    "description": "Utilização de séries temporais para previsão de preços de ativos, modelagem de volatilidade e avaliação de riscos financeiros.",
                    "individualConcepts": [
                      {
                        "id": "10.1.8.1.1",
                        "name": "Previsão de Preços de Ativos",
                        "description": "Aplicação de modelos de séries temporais para prever preços futuros de ativos financeiros, como ações e moedas, utilizando técnicas de análise exploratória e modelos de previsão apropriados para séries financeiras.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.1.1.1",
                            "name": "Obter e preparar dados de preços de ativos",
                            "description": "Importar dados históricos de preços de ativos financeiros de fontes como Yahoo Finance ou APIs, realizar transformações como cálculo de retornos logarítmicos e lidar com dados ausentes ou feriados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e acessar fontes de dados de preços de ativos",
                                  "subSteps": [
                                    "Identifique ativos relevantes (ex: AAPL, BTC-USD) e período histórico desejado (ex: últimos 5 anos).",
                                    "Escolha fontes confiáveis como Yahoo Finance via biblioteca yfinance ou Alpha Vantage API.",
                                    "Instale bibliotecas necessárias: pip install yfinance pandas numpy.",
                                    "Registre-se para APIs pagas se necessário e obtenha chaves de API.",
                                    "Teste conectividade com uma consulta simples para um ativo."
                                  ],
                                  "verification": "Confirme que consegue baixar dados de amostra sem erros de conexão ou autenticação.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python 3.8+, bibliotecas yfinance, pandas, numpy",
                                    "Acesso à internet",
                                    "Chave API se aplicável"
                                  ],
                                  "tips": "Comece com Yahoo Finance por ser gratuito e fácil; evite horários de alta carga nos servidores.",
                                  "learningObjective": "Compreender fontes de dados financeiros e configurar acesso programático.",
                                  "commonMistakes": [
                                    "Usar tickers incorretos (ex: 'Apple' em vez de 'AAPL')",
                                    "Ignorar fusos horários ou mercados fechados",
                                    "Não verificar limites de taxa da API"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Importar e inspecionar dados brutos",
                                  "subSteps": [
                                    "Use yf.download('AAPL', start='2020-01-01', end='2023-01-01') para baixar dados OHLCV.",
                                    "Carregue em um DataFrame do pandas e exiba shape, head() e tail().",
                                    "Verifique estatísticas descritivas com describe() e info().",
                                    "Plote séries temporais básicas com matplotlib para visualização inicial.",
                                    "Identifique padrões iniciais de dados ausentes ou anomalias."
                                  ],
                                  "verification": "DataFrame contém colunas Date, Open, High, Low, Close, Volume sem erros de parsing.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Jupyter Notebook ou IDE Python",
                                    "Bibliotecas pandas, matplotlib, yfinance"
                                  ],
                                  "tips": "Defina índice como datetime com pd.to_datetime para facilitar manipulações.",
                                  "learningObjective": "Carregar e explorar dados de séries temporais financeiras de forma eficiente.",
                                  "commonMistakes": [
                                    "Não converter índice para datetime",
                                    "Ignorar dados ajustados por splits/dividendos",
                                    "Plotar sem labels claros"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Limpar e tratar dados ausentes ou feriados",
                                  "subSteps": [
                                    "Preencha dados ausentes (NaNs) com ffill() ou interpolate() para feriados.",
                                    "Remova outliers extremos usando z-score ou IQR method.",
                                    "Ajuste para feriados detectando gaps >1 dia e interpolando linearmente.",
                                    "Crie flags para dias úteis vs feriados usando pandas.date_range().",
                                    "Valide limpeza comparando com dados originais."
                                  ],
                                  "verification": "DataFrame limpo tem zero NaNs, gaps preenchidos logicamente e sem outliers detectados.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Pandas, numpy",
                                    "Documentação de calendários de mercado (ex: NYSE holidays)"
                                  ],
                                  "tips": "Use market calendars de pandas_market_calendars para precisão em feriados.",
                                  "learningObjective": "Aplicar técnicas de imputação e detecção de anomalias em séries temporais financeiras.",
                                  "commonMistakes": [
                                    "Preencher todos NaNs com zero (distorce retornos)",
                                    "Ignorar splits de ações",
                                    "Sobre-interpolar gaps longos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular transformações como retornos logarítmicos",
                                  "subSteps": [
                                    "Calcule retornos simples: df['Return'] = df['Close'].pct_change().",
                                    "Calcule retornos logarítmicos: df['LogReturn'] = np.log(df['Close'] / df['Close'].shift(1)).",
                                    "Gere indicadores adicionais: volatilidade rolling (ewm.std), médias móveis.",
                                    "Padronize dados se necessário (z-score nos retornos).",
                                    "Exporte DataFrame preparado para CSV ou pickle."
                                  ],
                                  "verification": "Retornos logarítmicos somam corretamente ao log do preço final e são estacionários (teste ADF opcional).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Numpy, pandas",
                                    "Biblioteca statsmodels para testes opcionais"
                                  ],
                                  "tips": "Use shift(1) para evitar look-ahead bias; teste estacionariedade com ADF test.",
                                  "learningObjective": "Transformar preços em retornos logarítmicos e derivados para modelagem.",
                                  "commonMistakes": [
                                    "Calcular retornos em preços não ajustados",
                                    "Usar retornos simples para longos horizontes",
                                    "Não lidar com NaNs pós-transformação"
                                  ]
                                }
                              ],
                              "practicalExample": "Baixe dados diários do AAPL de 01/01/2018 a 31/12/2023 via yfinance. Limpe NaNs de feriados com ffill(), remova outliers >3 desvios padrão, calcule LogReturn e volatilidade de 20 dias. Plote preços vs retornos para validar.",
                              "finalVerifications": [
                                "Dados importados cobrem período exato sem gaps injustificados.",
                                "Limpeza removeu todos NaNs e outliers detectados.",
                                "Retornos logarítmicos são computados corretamente (soma ≈ log(preço final/inicial)).",
                                "DataFrame exportado é legível e reproduzível.",
                                "Visualizações confirmam ausência de anomalias.",
                                "Teste de estacionariedade (ADF) passa para retornos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na importação: 100% dos dados esperados carregados.",
                                "Qualidade da limpeza: <1% de dados alterados indevidamente.",
                                "Correção dos retornos: Erro <0.01% na soma cumulativa.",
                                "Eficiência do código: Executa em <5 min para 5 anos de dados.",
                                "Documentação: Código comentado e reproduzível.",
                                "Robustez: Lida com erros de API ou tickers inválidos."
                              ],
                              "crossCurricularConnections": [
                                "Programação em Python (pandas para manipulação de dados).",
                                "Estatística (testes de estacionariedade, distribuições de retornos).",
                                "Finanças (conceitos de adjusted close, volatilidade).",
                                "Matemática (logaritmos, séries temporais).",
                                "Economia (calendários de mercado, feriados impactando preços)."
                              ],
                              "realWorldApplication": "Em fundos de investimento ou trading algorítmico, preparar dados limpos de múltiplos ativos é essencial para backtesting estratégias, previsão de preços com ARIMA/GARCH e gerenciamento de portfólios, evitando biases que levam a perdas financeiras."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.1.1.2",
                            "name": "Realizar análise exploratória de séries de preços",
                            "description": "Aplicar testes de estacionariedade (ADF, KPSS), decomposição em tendência/sazonalidade e visualização de autocorrelações para identificar padrões em séries de preços de ativos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Aquisição e Preparação Inicial dos Dados",
                                  "subSteps": [
                                    "Obtenha dados de séries de preços de ativos usando bibliotecas como yfinance ou pandas_datareader.",
                                    "Carregue os dados em um DataFrame do pandas e defina o índice temporal como DatetimeIndex.",
                                    "Selecione a coluna de preços de fechamento (Close) e verifique valores ausentes ou outliers iniciais.",
                                    "Converta a série para log-retornos se necessário para estabilizar variância.",
                                    "Plote a série temporal bruta para inspeção visual inicial."
                                  ],
                                  "verification": "DataFrame carregado corretamente com índice temporal e gráfico inicial gerado sem erros.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python 3.x",
                                    "Bibliotecas: pandas, yfinance, matplotlib",
                                    "Acesso à internet para dados"
                                  ],
                                  "tips": "Sempre use freq='D' ou apropriada ao definir o índice para evitar problemas em decomposições.",
                                  "learningObjective": "Preparar uma série temporal de preços limpa e indexada corretamente para análises subsequentes.",
                                  "commonMistakes": [
                                    "Ignorar NaNs levando a erros em testes",
                                    "Não converter índice para datetime",
                                    "Usar preços nominais sem log em séries voláteis"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Visualização Inicial e Decomposição da Série",
                                  "subSteps": [
                                    "Gere gráficos de linha da série de preços ao longo do tempo.",
                                    "Aplique decomposição sazonal usando seasonal_decompose do statsmodels.",
                                    "Identifique componentes: tendência, sazonalidade e resíduo nos gráficos.",
                                    "Plote cada componente separadamente para análise qualitativa.",
                                    "Ajuste parâmetros como período sazonal (ex: 252 para dias úteis anuais)."
                                  ],
                                  "verification": "Gráficos de decomposição gerados mostrando tendência, sazonalidade e resíduo claramente.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python: statsmodels.tsa.seasonal",
                                    "matplotlib, seaborn para plots avançados"
                                  ],
                                  "tips": "Use model='additive' para séries estáveis ou 'multiplicative' para séries com variância crescente.",
                                  "learningObjective": "Decompor a série temporal para visualizar padrões subjacentes de tendência e sazonalidade.",
                                  "commonMistakes": [
                                    "Período sazonal incorreto causando decomposição distorcida",
                                    "Não plotar resíduo para checar ruído",
                                    "Ignorar tendência forte antes de testes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicação de Testes de Estacionariedade",
                                  "subSteps": [
                                    "Implemente o teste Augmented Dickey-Fuller (ADF) usando adfuller do statsmodels.",
                                    "Execute o teste Kwiatkowski-Phillips-Schmidt-Shin (KPSS) para complementar o ADF.",
                                    "Interprete p-values: ADF p<0.05 indica estacionariedade; KPSS p>0.05 confirma.",
                                    "Reporte estatísticas: valor crítico, estatística do teste e conclusão.",
                                    "Se não estacionária, sugira diferenciação e re-teste."
                                  ],
                                  "verification": "Relatório com p-values de ADF e KPSS gerado, com conclusões explícitas sobre estacionariedade.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "statsmodels.tsa.stattools: adfuller, kpss"
                                  ],
                                  "tips": "Inclua lags='auto' no ADF para seleção automática; teste em níveis e diferenças.",
                                  "learningObjective": "Avaliar formalmente a estacionariedade da série usando testes complementares.",
                                  "commonMistakes": [
                                    "Confundir hipóteses nulas (ADF: não-estacionária; KPSS: estacionária)",
                                    "Não reportar lags usados",
                                    "Ignorar resultados contraditórios entre testes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Visualização de Autocorrelações e Identificação de Padrões",
                                  "subSteps": [
                                    "Gere gráficos ACF (Autocorrelation Function) e PACF (Partial ACF) usando plot_acf e plot_pacf.",
                                    "Analise decaimento: lento indica não-estacionariedade; picos sazonais mostram periodicidade.",
                                    "Defina lags até 40 ou 10% do tamanho da série para visualização.",
                                    "Identifique padrões como ciclos, sazonalidade ou dependência serial.",
                                    "Resuma insights: ex. 'forte autocorrelação em lag 5 sugere sazonalidade semanal'."
                                  ],
                                  "verification": "Gráficos ACF/PACF plotados com bandas de confiança e resumo de padrões escrito.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "statsmodels.graphics.tsaplots: plot_acf, plot_pacf"
                                  ],
                                  "tips": "Use alpha=0.05 para bandas; foque em lags significativos além do zero.",
                                  "learningObjective": "Detectar dependências temporais e padrões através de funções de autocorrelação.",
                                  "commonMistakes": [
                                    "Interpretar todos os lags como significativos ignorando bandas",
                                    "Não diferenciar ACF de PACF",
                                    "Lags insuficientes em séries longas"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Síntese e Relatório de Padrões Identificados",
                                  "subSteps": [
                                    "Compile todos os resultados: decomposição, testes e autocorrelações em um relatório.",
                                    "Descreva padrões principais: tendência ascendente, sazonalidade diária, etc.",
                                    "Recomende próximos passos como modelagem ARIMA se não estacionária.",
                                    "Crie um dashboard ou notebook Jupyter com todos os visuals e métricas.",
                                    "Valide consistência entre visualizações e testes estatísticos."
                                  ],
                                  "verification": "Relatório consolidado gerado com insights acionáveis e recomendações.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Jupyter Notebook para relatório interativo"
                                  ],
                                  "tips": "Use markdown cells para narrar achados; inclua código reproduzível.",
                                  "learningObjective": "Integrar análises para uma visão holística da série temporal.",
                                  "commonMistakes": [
                                    "Relatório desconexo sem ligar evidências",
                                    "Omitir recomendações práticas",
                                    "Ignorar inconsistências nos resultados"
                                  ]
                                }
                              ],
                              "practicalExample": "Baixe dados diários de preços de fechamento da ação AAPL dos últimos 5 anos via yfinance. Plote a série, decompõe com período 252, testa estacionariedade (esperado: não-estacionária nos níveis), e analisa ACF mostrando autocorrelações persistentes indicando necessidade de diferenciação.",
                              "finalVerifications": [
                                "Série de preços carregada e visualizada corretamente.",
                                "Decomposição STL gerada com componentes claros.",
                                "Testes ADF e KPSS executados com p-values reportados e interpretados.",
                                "Gráficos ACF/PACF mostram padrões de autocorrelação.",
                                "Relatório final resume padrões como tendência e sazonalidade detectados.",
                                "Código reproduzível sem erros em ambiente padrão."
                              ],
                              "assessmentCriteria": [
                                "Precisão na preparação e indexação temporal (20%)",
                                "Qualidade e interpretação correta da decomposição (20%)",
                                "Execução e interpretação precisa dos testes de estacionariedade (25%)",
                                "Análise detalhada de ACF/PACF com identificação de padrões (20%)",
                                "Relatório coeso e acionável (15%)"
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Hipóteses de testes e interpretação de p-values.",
                                "Programação: Manipulação de dados com pandas e visualização com matplotlib.",
                                "Finanças: Compreensão de dinâmica de preços de ativos e volatilidade.",
                                "Matemática: Funções de autocorrelação e decomposição aditiva/multiplicativa.",
                                "Economia: Identificação de tendências macroeconômicas em séries financeiras."
                              ],
                              "realWorldApplication": "Analistas financeiros e traders usam essa análise para detectar padrões em preços de ações, commodities ou criptomoedas, informando estratégias de trading, hedging e modelos de previsão como ARIMA ou machine learning, reduzindo riscos em portfólios de investimento."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.1.1.3",
                            "name": "Aplicar modelos ARIMA para previsão de preços",
                            "description": "Diferenciar séries não estacionárias, identificar parâmetros p, d, q via ACF/PACF e ajustar modelo ARIMA para gerar previsões de preços de ativos com intervalos de confiança.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Verificar e corrigir estacionariedade da série temporal",
                                  "subSteps": [
                                    "Carregar dados de preços de ativos (ex: preços diários de ações via yfinance)",
                                    "Plotar a série temporal original e realizar teste de estacionariedade (ADF test)",
                                    "Aplicar diferenciação (d=1 ou d=2) até que a série seja estacionária",
                                    "Confirmar estacionariedade com plot atualizado e novo teste ADF",
                                    "Documentar o valor de d escolhido"
                                  ],
                                  "verification": "Teste ADF rejeita H0 (p-value < 0.05) e plot mostra ausência de tendência",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Python com pandas, statsmodels, matplotlib",
                                    "Dados históricos de preços (ex: AAPL via yfinance)"
                                  ],
                                  "tips": "Sempre plote os dados primeiro para visual inspeção; use log-retornos se apropriado para preços financeiros",
                                  "learningObjective": "Diferenciar séries não estacionárias e determinar o parâmetro d corretamente",
                                  "commonMistakes": [
                                    "Ignorar visualização e confiar só no teste",
                                    "Sobrediferenciação levando a perda de informação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar parâmetros p e q via análise ACF e PACF",
                                  "subSteps": [
                                    "Calcular e plotar gráficos ACF e PACF da série diferenciada",
                                    "Identificar lags significativos no ACF para parâmetro q (decay exponencial)",
                                    "Identificar lags significativos no PACF para parâmetro p (corte abrupto)",
                                    "Testar combinações iniciais de (p,q) com base nos plots",
                                    "Anotar possíveis modelos ARIMA(p,d,q)"
                                  ],
                                  "verification": "Gráficos ACF/PACF mostram padrões claros com barras dentro das bandas de confiança para lags > p/q",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "statsmodels.tsa.stattools.acf, pacf",
                                    "matplotlib para plots"
                                  ],
                                  "tips": "Use bandas de confiança de 95%; ignore lags muito altos para evitar overfitting",
                                  "learningObjective": "Interpretar ACF/PACF para seleção precisa de p e q",
                                  "commonMistakes": [
                                    "Confundir ACF com PACF",
                                    "Selecionar p/q baseados em lags não significativos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Ajustar e validar o modelo ARIMA",
                                  "subSteps": [
                                    "Ajustar modelo ARIMA(p,d,q) usando statsmodels SARIMAX ou ARIMA",
                                    "Verificar resíduos: plot Q-Q, teste Ljung-Box para autocorrelação",
                                    "Comparar AIC/BIC entre modelos candidatos para seleção final",
                                    "Garantir resíduos são ruído branco (normalidade e independência)",
                                    "Salvar summary do modelo ajustado"
                                  ],
                                  "verification": "Resíduos passam em testes (Ljung-Box p>0.05, Q-Q próximo à reta)",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "statsmodels.tsa.arima.model.ARIMA",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Comece com modelos simples; use auto_arima para sugestões iniciais mas valide manualmente",
                                  "learningObjective": "Ajustar modelo ARIMA robusto e validar adequação diagnóstica",
                                  "commonMistakes": [
                                    "Não checar resíduos",
                                    "Escolher modelo com menor AIC sem validação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Gerar previsões com intervalos de confiança",
                                  "subSteps": [
                                    "Prever h passos à frente (ex: 30 dias) com get_forecast()",
                                    "Extrair valores previstos, intervalos de confiança (95%) e plotar",
                                    "Calcular métricas de erro em dados de teste (MSE, MAE)",
                                    "Interpretar intervalos: largura indica incerteza",
                                    "Exportar previsões para relatório ou dashboard"
                                  ],
                                  "verification": "Previsões plotadas com bandas de confiança; métricas de erro reportadas",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "statsmodels forecast métodos",
                                    "pandas para export"
                                  ],
                                  "tips": "Use dados out-of-sample para validação real; ajuste alpha para IC diferentes",
                                  "learningObjective": "Produzir previsões ARIMA acionáveis com quantificação de incerteza",
                                  "commonMistakes": [
                                    "Ignorar intervalos de confiança",
                                    "Prever muitos passos sem validar horizonte"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dados diários de preços da ação AAPL de 2020-2023, determine d=1 por ADF, identifique p=1,q=1 via ACF/PACF, ajuste ARIMA(1,1,1), preveja próximos 30 dias com IC 95%, plotando sobre série histórica para visualização.",
                              "finalVerifications": [
                                "Série diferenciada é estacionária (ADF p<0.05)",
                                "Parâmetros p,d,q justificados por ACF/PACF",
                                "Resíduos do modelo são ruído branco",
                                "Previsões incluem intervalos de confiança válidos",
                                "Métricas de erro calculadas em conjunto de teste",
                                "Modelo selecionado tem AIC baixo comparado a alternativas"
                              ],
                              "assessmentCriteria": [
                                "Correta determinação de estacionariedade e d",
                                "Interpretação precisa de ACF/PACF para p e q",
                                "Diagnósticos de resíduos adequados (plots e testes)",
                                "Previsões geradas com IC e avaliação de performance",
                                "Código limpo, comentado e reproduzível",
                                "Interpretação financeira das previsões"
                              ],
                              "crossCurricularConnections": [
                                "Finanças: Modelagem de risco e valuation de ativos",
                                "Programação: Manipulação de dados em Python/R",
                                "Estatística: Testes de hipóteses e inferência",
                                "Machine Learning: Extensão para modelos mais avançados como SARIMA/GARCH"
                              ],
                              "realWorldApplication": "Previsão de preços de ações, commodities ou criptomoedas para estratégias de trading, gerenciamento de portfólio e análise de risco em bancos de investimento e fundos hedge."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.1.1.4",
                            "name": "Avaliar precisão das previsões de preços",
                            "description": "Calcular métricas como MAE, RMSE e MAPE para validar previsões de modelos ARIMA em dados de preços reais e comparar com benchmarks como random walk.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar dados de previsões e valores reais",
                                  "subSteps": [
                                    "Obtenha dados históricos de preços de um ativo financeiro (ex: ações via Yahoo Finance).",
                                    "Gere previsões usando um modelo ARIMA já treinado para o mesmo período.",
                                    "Alinhe os valores reais observados com as previsões correspondentes em um DataFrame ou array.",
                                    "Trate valores ausentes ou outliers nos dados.",
                                    "Divida os dados em conjuntos de treino/validação se necessário para consistência."
                                  ],
                                  "verification": "Verifique se os arrays de valores reais e previstos têm o mesmo comprimento e índices alinhados; plote-os para inspeção visual.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python com pandas, numpy, yfinance",
                                    "Jupyter Notebook",
                                    "Dados históricos de preços (ex: AAPL)"
                                  ],
                                  "tips": "Use funções como pd.merge() para alinhar séries temporais perfeitamente.",
                                  "learningObjective": "Dominar o alinhamento preciso de dados reais e previstos para cálculos de métricas.",
                                  "commonMistakes": [
                                    "Misalignment de índices temporais",
                                    "Inclusão de dados de treino nas métricas de teste",
                                    "Ignorar NaNs que distorcem cálculos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular métricas de erro absolutas e quadráticas",
                                  "subSteps": [
                                    "Implemente a fórmula do MAE: média dos valores absolutos das diferenças (y_true - y_pred).",
                                    "Calcule RMSE: raiz quadrada da média dos quadrados das diferenças.",
                                    "Use bibliotecas como sklearn.metrics.mean_absolute_error() e mean_squared_error() para validação.",
                                    "Armazene os resultados em um dicionário ou tabela para fácil comparação.",
                                    "Escalone as métricas se os preços estiverem em diferentes unidades (ex: log-retornos)."
                                  ],
                                  "verification": "Compare resultados manuais com funções de biblioteca; valores devem coincidir em pelo menos 4 casas decimais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com scikit-learn, numpy",
                                    "Código de fórmulas MAE/RMSE"
                                  ],
                                  "tips": "Sempre use np.abs() e np.sqrt() corretamente para evitar erros numéricos.",
                                  "learningObjective": "Aplicar fórmulas matemáticas de métricas de precisão em código.",
                                  "commonMistakes": [
                                    "Confundir MAE com MSE (sem raiz)",
                                    "Dividir por zero em médias vazias",
                                    "Usar erros relativos sem normalizar"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular MAPE e gerar benchmark random walk",
                                  "subSteps": [
                                    "Implemente MAPE: média dos erros percentuais absolutos (|erro| / |y_true|) * 100.",
                                    "Gere previsões de random walk: use o último valor observado como previsão para todos os passos à frente.",
                                    "Calcule MAE, RMSE e MAPE para o benchmark random walk nos mesmos dados.",
                                    "Trate divisões por zero em MAPE usando um pequeno epsilon (ex: 1e-8).",
                                    "Documente os valores do benchmark em uma tabela comparativa."
                                  ],
                                  "verification": "Confirme que MAPE do random walk é um limite inferior razoável; plote erros para visualização.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com numpy",
                                    "Fórmulas de MAPE e random walk"
                                  ],
                                  "tips": "Random walk é 'previsão ingênua': próximo = atual; ideal para baselines em finanças.",
                                  "learningObjective": "Entender e implementar métricas percentuais e benchmarks simples.",
                                  "commonMistakes": [
                                    "Divisão por zero em MAPE para y_true=0",
                                    "Benchmark incorreto (não usar último valor)",
                                    "Ignorar que MAPE é sensível a valores próximos de zero"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar métricas e interpretar resultados",
                                  "subSteps": [
                                    "Crie uma tabela resumindo MAE, RMSE, MAPE do ARIMA vs. random walk.",
                                    "Calcule reduções percentuais: ((benchmark - ARIMA) / benchmark) * 100.",
                                    "Interprete: se ARIMA > random walk, modelo não agrega valor; analise por horizonte de previsão.",
                                    "Gere gráficos de resíduos e Q-Q plots para diagnóstico adicional.",
                                    "Escreva um relatório curto com conclusões sobre a precisão do modelo."
                                  ],
                                  "verification": "Tabela mostra ARIMA melhor que benchmark em pelo menos uma métrica; relatório explica implicações.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python com matplotlib, pandas",
                                    "Template de tabela comparativa"
                                  ],
                                  "tips": "Use heatmaps para destacar melhorias; considere Diebold-Mariano test para significância.",
                                  "learningObjective": "Interpretar métricas no contexto financeiro e validar modelos contra baselines.",
                                  "commonMistakes": [
                                    "Concluir superioridade sem estatística",
                                    "Comparar métricas em escalas diferentes",
                                    "Ignorar volatilidade em interpretações"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dados diários de preços da ação AAPL de 2020-2023: treine ARIMA(1,1,1), preveja 30 dias à frente, calcule MAE=2.15, RMSE=3.42, MAPE=1.8%; random walk: MAE=2.85, RMSE=4.10, MAPE=2.4%. ARIMA supera em 25% em MAPE.",
                              "finalVerifications": [
                                "Métricas MAE, RMSE e MAPE calculadas corretamente para ARIMA e random walk.",
                                "Tabela comparativa mostra superioridade ou não do modelo.",
                                "Gráficos de previsões vs. reais alinhados sem erros de indexação.",
                                "Interpretação escrita identifica forças/fraquezas por horizonte.",
                                "Código reproduzível gera os mesmos valores em nova execução.",
                                "Tratamento de edge cases como zeros em MAPE documentado."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica das métricas (erro < 0.01).",
                                "Correta implementação de benchmark random walk.",
                                "Qualidade da tabela e visualizações comparativas.",
                                "Profundidade da interpretação financeira (ex: implicações para trading).",
                                "Código limpo, comentado e modular.",
                                "Tratamento robusto de dados (NaNs, zeros).",
                                "Relatório conciso com recomendações acionáveis."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de raízes, médias e estatística descritiva.",
                                "Programação: Manipulação de dados com pandas/numpy e métricas sklearn.",
                                "Finanças: Modelagem de séries temporais e avaliação de risco/previsão.",
                                "Econometria: Testes de estacionariedade e baselines em forecasting.",
                                "Visualização de Dados: Plots de resíduos e comparações com matplotlib."
                              ],
                              "realWorldApplication": "Em fundos de investimento, traders usam essas métricas para decidir se um modelo ARIMA justifica uso em estratégias de trading automatizado, comparando com random walk para evitar overfitting e garantir retornos acima do 'buy-and-hold'."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.1.2",
                        "name": "Modelagem de Volatilidade",
                        "description": "Uso de modelos ARCH e GARCH para modelar e prever a volatilidade condicional dos retornos financeiros, capturando clusters de volatilidade comuns em mercados.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.1.2.1",
                            "name": "Calcular retornos logarítmicos e testar normalidade",
                            "description": "Computar retornos diários logarítmicos de séries de preços e aplicar testes como Jarque-Bera para detectar não normalidade e leptocurtose nos retornos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Coletar e preparar dados de séries de preços",
                                  "subSteps": [
                                    "Baixe dados históricos de preços de ações de uma fonte confiável como Yahoo Finance.",
                                    "Importe os dados para um ambiente de programação (Python com pandas).",
                                    "Selecione a coluna de preços de fechamento ajustados.",
                                    "Verifique e limpe dados ausentes ou inconsistentes.",
                                    "Converta datas para formato datetime e defina como índice."
                                  ],
                                  "verification": "Dataset carregado com preços diários limpos e sem valores NaN, visualizado com plot de linha.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python (pandas, yfinance), Jupyter Notebook",
                                    "Internet para download de dados"
                                  ],
                                  "tips": "Use yfinance para download automatizado: yf.download('AAPL', start='2020-01-01').",
                                  "learningObjective": "Preparar dados financeiros limpos para análise de retornos.",
                                  "commonMistakes": [
                                    "Ignorar ajustes por dividendos/splits",
                                    "Usar preços não ajustados",
                                    "Não tratar valores ausentes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular retornos logarítmicos diários",
                                  "subSteps": [
                                    "Aplique a fórmula: retorno_log = ln(P_t / P_{t-1}) onde P_t é o preço no tempo t.",
                                    "Use np.log(preços / preços.shift(1)) no pandas.",
                                    "Remova o primeiro valor NaN resultante do shift.",
                                    "Visualize a distribuição dos retornos com histograma e estatísticas descritivas.",
                                    "Calcule estatísticas básicas: média, variância, skewness e kurtosis."
                                  ],
                                  "verification": "Série de retornos logarítmicos gerada com comprimento correto (n-1 observações) e plotada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python (pandas, numpy, matplotlib)",
                                    "Dataset de preços preparado"
                                  ],
                                  "tips": "Retornos logarítmicos são aditivos no tempo, ideais para séries temporais.",
                                  "learningObjective": "Dominar o cálculo de retornos logarítmicos para análise de volatilidade.",
                                  "commonMistakes": [
                                    "Usar retornos simples em vez de logarítmicos",
                                    "Esquecer de remover NaN",
                                    "Não verificar stationariedade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar testes de normalidade como Jarque-Bera",
                                  "subSteps": [
                                    "Instale e importe bibliotecas: from scipy.stats import jarque_bera.",
                                    "Execute jarque_bera(retornos) para obter estatística JB, p-value.",
                                    "Interprete: p-value < 0.05 indica rejeição da normalidade.",
                                    "Complemente com testes adicionais: Shapiro-Wilk ou Kolmogorov-Smirnov.",
                                    "Calcule skewness e kurtosis manualmente para confirmação."
                                  ],
                                  "verification": "Resultados do teste Jarque-Bera exibidos com p-value e interpretação escrita.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python (scipy.stats)",
                                    "Série de retornos logarítmicos"
                                  ],
                                  "tips": "Jarque-Bera testa skewness=0 e kurtosis=3; alto kurtosis indica leptocurtose.",
                                  "learningObjective": "Aplicar e interpretar testes estatísticos para normalidade em retornos financeiros.",
                                  "commonMistakes": [
                                    "Interpretar estatística JB em vez de p-value",
                                    "Testar em dados não estacionários",
                                    "Ignorar tamanho da amostra"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados e detectar não normalidade/leptocurtose",
                                  "subSteps": [
                                    "Analise skewness (assimetria) e excess kurtosis (>0 indica leptocurtose).",
                                    "Compare distribuição empírica com normal teórica via Q-Q plot.",
                                    "Documente evidências de não normalidade: fat tails, assimetria.",
                                    "Discuta implicações para modelagem (e.g., necessidade de GARCH).",
                                    "Gere relatório com gráficos e conclusões."
                                  ],
                                  "verification": "Relatório com Q-Q plot, estatísticas e conclusão sobre normalidade/leptocurtose.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python (scipy.stats, matplotlib, seaborn para Q-Q plot)",
                                    "Resultados dos testes"
                                  ],
                                  "tips": "Use statsmodels.qqplot para visualização intuitiva.",
                                  "learningObjective": "Interpretar evidências de distribuições não normais em finanças.",
                                  "commonMistakes": [
                                    "Assumir normalidade apesar de p-value baixo",
                                    "Não visualizar distribuições",
                                    "Ignorar leptocurtose em riscos"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dados diários da ação AAPL de 2020-2023: calcule retornos logarítmicos, aplique Jarque-Bera (tipicamente p-value ~0 rejeita normalidade), observe leptocurtose devido a eventos como COVID-19, confirmando fat tails nos retornos.",
                              "finalVerifications": [
                                "Retornos logarítmicos calculados corretamente sem NaN.",
                                "Teste Jarque-Bera executado com p-value reportado.",
                                "Skewness e kurtosis calculados e interpretados.",
                                "Q-Q plot mostra desvios da normalidade.",
                                "Conclusão escrita sobre não normalidade/leptocurtose.",
                                "Código reproduzível e documentado."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de retornos (erro <1e-10).",
                                "Correta aplicação e interpretação do teste Jarque-Bera.",
                                "Identificação precisa de leptocurtose (kurtosis >3).",
                                "Uso adequado de visualizações (histograma, Q-Q plot).",
                                "Relatório claro com implicações financeiras.",
                                "Código limpo, eficiente e comentado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Logaritmos naturais e propriedades estatísticas.",
                                "Programação: Manipulação de dados com Python/pandas.",
                                "Economia/Finanças: Modelos de risco e volatilidade.",
                                "Probabilidade: Distribuições e testes de hipóteses.",
                                "Visualização de Dados: Gráficos para análise exploratória."
                              ],
                              "realWorldApplication": "Em finanças quantitativas, detectar não normalidade nos retornos logarítmicos é crucial para precificar opções (Black-Scholes assume normalidade), gerenciar riscos em portfólios (Value-at-Risk) e modelar volatilidade com ARCH/GARCH em bancos e hedge funds."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.1.2.2",
                            "name": "Testar para heterocedasticidade condicional",
                            "description": "Realizar teste de Engle para ARCH e analisar gráficos de resíduos quadrados para identificar presença de volatilidade condicional em retornos financeiros.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os dados de retornos financeiros e obter resíduos padronizados",
                                  "subSteps": [
                                    "Colete uma série temporal de retornos financeiros (ex: log-retornos diários de ações).",
                                    "Ajuste um modelo ARMA(p,q) aos retornos para capturar a média condicional.",
                                    "Extraia os resíduos padronizados (ε_t) do modelo ARMA ajustado.",
                                    "Verifique estacionariedade dos resíduos usando teste ADF.",
                                    "Padronize os resíduos se necessário (divida por σ_t do modelo)."
                                  ],
                                  "verification": "Confirme que resíduos são estacionários (p-value ADF < 0.05) e sem autocorrelação (Ljung-Box test p-value > 0.05).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software R ou Python (pacotes rugarch, arch ou statsmodels)",
                                    "Dados históricos de retornos (Yahoo Finance ou Quandl)"
                                  ],
                                  "tips": "Use log-retornos para normalizar a distribuição; comece com ARMA(1,1) simples.",
                                  "learningObjective": "Compreender como obter resíduos brancos de um modelo de média para análise de variância condicional.",
                                  "commonMistakes": [
                                    "Ignorar não-estacionariedade nos retornos originais",
                                    "Não testar autocorrelação nos resíduos antes de prosseguir"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar o teste de Engle LM para ARCH",
                                  "subSteps": [
                                    "Regresse os resíduos quadrados (ε_t²) sobre uma constante e q lags de ε_{t-i}² (tipicamente q=4-12).",
                                    "Calcule a estatística LM = n * R², onde n é o número de observações e R² do modelo auxiliar.",
                                    "Compare com distribuição qui-quadrada com q graus de liberdade.",
                                    "Implemente no software: em R use arch.test() do pacote FinTS; em Python use arch.arch_model().",
                                    "Registre p-value e rejeite H0 (sem ARCH) se p < 0.05."
                                  ],
                                  "verification": "Obtenha p-value < 0.05 indicando rejeição de H0 de homocedasticidade.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código R: library(FinTS); arch.test(residuals, lags=12)",
                                    "Python: from arch import arch_model"
                                  ],
                                  "tips": "Escolha lags baseado em ACF de resíduos quadrados; teste múltiplos q para robustez.",
                                  "learningObjective": "Executar e interpretar o teste LM de Engle para detectar efeitos ARCH.",
                                  "commonMistakes": [
                                    "Usar resíduos não-padronizados",
                                    "Confundir lags de ε_t com ε_t²"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar gráficos de resíduos quadrados para volatilidade condicional",
                                  "subSteps": [
                                    "Plote a série temporal de resíduos quadrados (ε_t²).",
                                    "Gere ACF e PACF dos resíduos quadrados para identificar persistência.",
                                    "Plote resíduos quadrados vs tempo para clusters de volatilidade.",
                                    "Compare com resíduos originais para visual volatilidade agrupada.",
                                    "Identifique padrões como volatilidade em 'clusters' altos/baixos."
                                  ],
                                  "verification": "ACF mostra autocorrelações significativas nos primeiros lags de ε_t².",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Funções plot.acf() em R ou pd.plot_acf() em Python (statsmodels)"
                                  ],
                                  "tips": "Use escala log para ε_t² se houver outliers; zoom em períodos voláteis conhecidos (ex: crises).",
                                  "learningObjective": "Visualizar e diagnosticar heterocedasticidade condicional graficamente.",
                                  "commonMistakes": [
                                    "Interpretar volatilidade em resíduos originais ao invés de quadrados",
                                    "Ignorar lags insignificantes no PACF"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados e concluir sobre presença de volatilidade condicional",
                                  "subSteps": [
                                    "Combine evidências: p-value Engle + padrões gráficos.",
                                    "Se evidência de ARCH, sugira próximo passo: GARCH(1,1).",
                                    "Documente relatório: hipótese, estatística, p-value, gráficos.",
                                    "Teste robustez com sub-períodos ou diferentes lags.",
                                    "Conclua se dados exibem volatilidade condicional (heterocedasticidade)."
                                  ],
                                  "verification": "Relatório escrito com conclusão clara apoiada por testes e gráficos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Template de relatório Markdown ou Jupyter Notebook"
                                  ],
                                  "tips": "Sempre reporte tamanho da amostra e lags usados para reprodutibilidade.",
                                  "learningObjective": "Sintetizar testes estatísticos e gráficos para decisão em modelagem de volatilidade.",
                                  "commonMistakes": [
                                    "Concluir ARCH sem suporte gráfico",
                                    "Não considerar poder do teste em amostras pequenas"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando retornos diários do índice S&P500 de 2010-2020: ajuste ARMA(1,1), teste Engle com 12 lags (p-value=0.001 rejeita H0), ACF de ε_t² mostra persistência nos primeiros 5 lags, confirmando volatilidade condicional durante crises como COVID-19.",
                              "finalVerifications": [
                                "Teste de Engle rejeita H0 com p-value < 0.05.",
                                "ACF/PACF de resíduos quadrados exibe autocorrelações significativas.",
                                "Gráficos mostram clusters de alta/baixa volatilidade.",
                                "Relatório interpreta corretamente evidências combinadas.",
                                "Sugere modelo GARCH se ARCH detectado.",
                                "Resultados reproduzíveis com seed/code fornecido."
                              ],
                              "assessmentCriteria": [
                                "Precisão na extração e padronização de resíduos (sem autocorrelação).",
                                "Correta implementação e interpretação do teste LM Engle.",
                                "Análise gráfica detalhada com identificação de padrões voláteis.",
                                "Conclusão lógica baseada em evidências estatísticas e visuais.",
                                "Relatório claro, com código comentado e visualizações rotuladas.",
                                "Tratamento de erros comuns como lags inadequados."
                              ],
                              "crossCurricularConnections": [
                                "Finanças: Modelagem de risco e Value at Risk (VaR).",
                                "Econometria: Diagnóstico de modelos de séries temporais.",
                                "Programação: Manipulação de dados em R/Python (pandas, dplyr).",
                                "Estatística: Testes de hipótese e análise de variância.",
                                "Machine Learning: Previsão de volatilidade em redes neurais."
                              ],
                              "realWorldApplication": "Em bancos e fundos de investimento, detectar volatilidade condicional permite modelar GARCH para prever riscos, calcular margens de colateral em derivativos e otimizar portfólios durante períodos turbulentos como crises financeiras."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.1.2.3",
                            "name": "Estimar modelo ARCH",
                            "description": "Ajustar modelo ARCH(q) aos resíduos quadrados de retornos, interpretar coeficientes de lag e validar com testes de Ljung-Box nos resíduos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Coleta e pré-processamento de dados de retornos",
                                  "subSteps": [
                                    "Baixar dados históricos de preços de fechamento de um ativo financeiro (ex: ações ou índice).",
                                    "Calcular retornos logarítmicos: r_t = log(P_t / P_{t-1}).",
                                    "Ajustar um modelo ARMA simples aos retornos para obter resíduos padronizados.",
                                    "Calcular os resíduos quadrados: ε_t².",
                                    "Verificar estacionariedade dos resíduos quadrados com teste ADF."
                                  ],
                                  "verification": "Confirmar que os retornos são estacionários e resíduos quadrados exibem heterocedasticidade via ACF.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Dados históricos (Yahoo Finance ou Quandl)",
                                    "Software: R (pacote rugarch) ou Python (pacote arch)"
                                  ],
                                  "tips": "Use retornos diários para maior volatilidade observável; remova fins de semana e feriados.",
                                  "learningObjective": "Preparar série temporal adequada para modelagem de volatilidade.",
                                  "commonMistakes": [
                                    "Não remover valores ausentes",
                                    "Usar retornos simples em vez de logarítmicos",
                                    "Ignorar outliers"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Especificação e estimação do modelo ARCH(q)",
                                  "subSteps": [
                                    "Testar diferentes ordens q (1 a 5) usando critério de informação AIC/BIC.",
                                    "Especificar o modelo: σ_t² = α_0 + ∑_{i=1}^q α_i ε_{t-i}².",
                                    "Ajustar o modelo via máxima verossimilhança (MLE) condicional Gaussiana.",
                                    "Verificar convergência do algoritmo de otimização.",
                                    "Extrair coeficientes estimados e erros-padrão."
                                  ],
                                  "verification": "AIC/BIC mínimo para q selecionado e todos coeficientes α_i > 0.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código R: ugarchfit() ou Python: ARCH.fit()",
                                    "Série de resíduos quadrados"
                                  ],
                                  "tips": "Comece com q=1; use restrições para garantir positividade dos coeficientes.",
                                  "learningObjective": "Selecionar e estimar parâmetros do modelo ARCH adequadamente.",
                                  "commonMistakes": [
                                    "Escolha arbitrária de q sem critérios",
                                    "Ignorar não-convergência",
                                    "Coeficientes negativos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretação dos coeficientes de lag",
                                  "subSteps": [
                                    "Analisar α_0: componente constante da variância.",
                                    "Interpretar α_i (i=1 a q): contribuição dos choques passados à volatilidade atual.",
                                    "Verificar soma dos α_i <1 para estacionariedade.",
                                    "Testar significância com t-testes (p-value <0.05).",
                                    "Calcular half-life da volatilidade: log(0.5)/log(∑α_i)."
                                  ],
                                  "verification": "Relatório escrito explicando impacto econômico de cada coeficiente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Saída do modelo estimado",
                                    "Tabela de coeficientes"
                                  ],
                                  "tips": "Compare soma α_i com GARCH para clustering de volatilidade.",
                                  "learningObjective": "Compreender o significado econômico e estatístico dos parâmetros ARCH.",
                                  "commonMistakes": [
                                    "Confundir com ARMA",
                                    "Ignorar soma >1 (explosão de variância)",
                                    "Não testar significância"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validação do modelo com testes de Ljung-Box",
                                  "subSteps": [
                                    "Aplicar teste Ljung-Box aos resíduos padronizados η_t = ε_t / σ_t.",
                                    "Aplicar teste Ljung-Box aos resíduos quadrados padronizados η_t².",
                                    "Verificar ausência de autocorrelação serial (p-value >0.05 para lags até 20).",
                                    "Analisar Q-Q plot e histograma dos resíduos padronizados.",
                                    "Comparar variância condicional com observada."
                                  ],
                                  "verification": "p-values >0.05 em ambos os testes Ljung-Box.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Funções Box.test() em R ou acorr_ljungbox() em Python",
                                    "Resíduos do modelo"
                                  ],
                                  "tips": "Use múltiplos lags; se falhar, aumente q ou considere GARCH.",
                                  "learningObjective": "Validar adequação do modelo à captura de volatilidade.",
                                  "commonMistakes": [
                                    "Testar apenas resíduos originais",
                                    "Poucos lags no teste",
                                    "Ignorar resíduos quadrados"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Diagnóstico final e relatório",
                                  "subSteps": [
                                    "Gerar plots de volatilidade condicional vs. realizada.",
                                    "Realizar teste ARCH-LM para resíduos para confirmar ausência de ARCH remanescente.",
                                    "Documentar modelo final, coeficientes e diagnósticos.",
                                    "Prever volatilidade para próximo período.",
                                    "Discutir limitações (ex: assume normalidade)."
                                  ],
                                  "verification": "Relatório completo com plots e conclusões.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Gráficos: plot() em R/Python",
                                    "Template de relatório"
                                  ],
                                  "tips": "Salve seed para reprodutibilidade; exporte resultados em PDF.",
                                  "learningObjective": "Sintetizar análise e comunicar resultados.",
                                  "commonMistakes": [
                                    "Não plotar diagnósticos",
                                    "Omitir limitações",
                                    "Previsões sem IC"
                                  ]
                                }
                              ],
                              "practicalExample": "Estime um modelo ARCH(2) para os retornos diários do índice IBOVESPA de 01/01/2020 a 31/12/2023. Após ARMA(1,1), ajuste aos resíduos quadrados, interprete α1 e α2 (efeito de choques recentes vs. passados) e valide com Ljung-Box (lags 1-20).",
                              "finalVerifications": [
                                "Modelo convergeu com todos α_i >0 e soma <1.",
                                "Testes Ljung-Box nos resíduos e resíduos quadrados: p>0.05.",
                                "Plots mostram captura adequada de clusters de volatilidade.",
                                "Coeficientes significativos a 5%.",
                                "Previsão de volatilidade condicional plausível.",
                                "Ausência de ARCH remanescente via teste LM."
                              ],
                              "assessmentCriteria": [
                                "Correta preparação de resíduos quadrados (20%).",
                                "Seleção ótima de q via AIC/BIC e estimação válida (25%).",
                                "Interpretação precisa e econômica dos coeficientes (20%).",
                                "Validação robusta com Ljung-Box e diagnósticos (20%).",
                                "Relatório claro com plots e conclusões (15%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação Estatística (R/Python para estimação MLE).",
                                "Finanças Quantitativas (modelagem de risco e VaR).",
                                "Econometria (testes de hipóteses e especificação).",
                                "Matemática Aplicada (otimização e processos estocásticos).",
                                "Machine Learning (previsão de séries não-lineares)."
                              ],
                              "realWorldApplication": "Modelos ARCH são fundamentais em gestão de riscos financeiros, como cálculo de Value-at-Risk (VaR) em bancos, precificação de opções em trading algorítmico e alocação de portfólios em fundos de investimento, prevendo períodos de alta volatilidade em mercados como Bolsa de Valores."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.1.2.4",
                            "name": "Estimar e interpretar modelo GARCH",
                            "description": "Ajustar modelo GARCH(p,q) para capturar persistência de volatilidade, analisar parâmetros alfa e beta e gerar previsões de volatilidade futura.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparação dos dados para modelagem GARCH",
                                  "subSteps": [
                                    "Coletar série temporal de preços de ativos financeiros (ex: ações ou índices).",
                                    "Calcular retornos logarítmicos: r_t = log(P_t / P_{t-1}).",
                                    "Testar estacionariedade com teste ADF e remover tendência se necessário.",
                                    "Verificar presença de efeitos ARCH com teste de Engle.",
                                    "Quadratizar os resíduos dos retornos para análise de volatilidade."
                                  ],
                                  "verification": "Os retornos são estacionários (p-value ADF < 0.05) e teste LM de ARCH rejeita H0 (p-value < 0.05).",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Python (bibliotecas: pandas, numpy, arch, statsmodels)",
                                    "Dados históricos de preços (Yahoo Finance ou Quandl)",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Sempre use retornos logarítmicos para aproximar normalidade; visualize ACF/PACF dos quadrados dos retornos.",
                                  "learningObjective": "Preparar adequadamente uma série temporal financeira para captura de volatilidade condicional.",
                                  "commonMistakes": [
                                    "Usar preços em nível sem transformar em retornos",
                                    "Ignorar não-estacionariedade",
                                    "Não testar efeitos ARCH antes do modelo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Seleção e estimação do modelo GARCH(p,q)",
                                  "subSteps": [
                                    "Escolher ordens p e q iniciais baseadas em critérios como AIC/BIC (iniciar com GARCH(1,1)).",
                                    "Ajustar o modelo usando máxima verossimilhança (MLE) com distribuição normal ou t-Student.",
                                    "Verificar convergência do algoritmo de otimização.",
                                    "Inspecionar resíduos padronizados para ausência de autocorrelação.",
                                    "Comparar modelos com diferentes (p,q) usando testes de informação."
                                  ],
                                  "verification": "Modelo convergeu, alfa + beta próximo de 1 (persistência alta), resíduos sem ARCH restante (teste Ljung-Box).",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Python: biblioteca arch",
                                    "R: pacote rugarch (opcional)",
                                    "Jupyter Notebook para experimentação"
                                  ],
                                  "tips": "Use robustez com distribuição t-Student se caudas pesadas; monitore warnings de otimização.",
                                  "learningObjective": "Ajustar empiricamente um modelo GARCH otimizado para dados financeiros.",
                                  "commonMistakes": [
                                    "Escolher p/q muito altos sem critério",
                                    "Ignorar não-convergência",
                                    "Não validar resíduos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretação dos parâmetros alfa e beta",
                                  "subSteps": [
                                    "Analisar ω (constante): componente base de variância.",
                                    "Interpretar α (efeito de choque): impacto de inovações passadas na volatilidade atual.",
                                    "Interpretar β (persistência): influência da volatilidade passada.",
                                    "Verificar soma α + β ≈ 1 para alta persistência; testar significância estatística.",
                                    "Calcular meia-vida da volatilidade: log(0.5)/log(α + β)."
                                  ],
                                  "verification": "Relatório escrito explicando significância e implicações econômicas de cada parâmetro.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Resultados do modelo ajustado",
                                    "Gráficos de volatilidade condicional"
                                  ],
                                  "tips": "Se α + β > 0.99, volatilidade é altamente persistente; compare com benchmarks como EWMA.",
                                  "learningObjective": "Compreender o significado econômico e estatístico dos parâmetros GARCH.",
                                  "commonMistakes": [
                                    "Confundir α com persistência (é β)",
                                    "Ignorar intervalos de confiança",
                                    "Não relacionar com clustering de volatilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Geração de previsões de volatilidade e avaliação",
                                  "subSteps": [
                                    "Gerar forecasts de volatilidade para h=1 a 10 períodos à frente.",
                                    "Visualizar volatilidade realizada vs. prevista.",
                                    "Avaliar precisão com métricas: MSE, QLIKE, teste de Mincer-Zarnowitz.",
                                    "Simular cenários de stress (choques altos).",
                                    "Documentar limitações (ex: não captura saltos assimétricos)."
                                  ],
                                  "verification": "Previsões plausíveis, backtest com dados out-of-sample mostra erro baixo.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Modelo ajustado",
                                    "Dados out-of-sample",
                                    "Biblioteca arch para forecast"
                                  ],
                                  "tips": "Use rolling window para previsões realistas; compare com GJR-GARCH para assimetria.",
                                  "learningObjective": "Aplicar o modelo para previsões acionáveis e validar performance.",
                                  "commonMistakes": [
                                    "Prever in-sample em vez de out-of-sample",
                                    "Ignorar avaliação quantitativa",
                                    "Sobreajuste levando a forecasts ruins"
                                  ]
                                }
                              ],
                              "practicalExample": "Baixe dados diários do índice Bovespa (IBOV) de 2010-2023 via yfinance. Calcule retornos log, ajuste GARCH(1,1), interprete α≈0.05 (choques representam 5% da vol hoje), β≈0.94 (94% persistência), e preveja vol para próxima semana, comparando com variação real.",
                              "finalVerifications": [
                                "Modelo GARCH ajustado converge e α + β > 0.95.",
                                "Interpretação correta: α mede reação a shocks, β persistência.",
                                "Previsões geradas e plotadas contra volatilidade realizada.",
                                "Resíduos sem autocorrelação (Ljung-Box p>0.05).",
                                "Relatório resume meia-vida e implicações para risco.",
                                "Teste out-of-sample com QLIKE < benchmark EWMA."
                              ],
                              "assessmentCriteria": [
                                "Precisão na preparação de dados (estacionariedade e ARCH test).",
                                "Correta estimação e convergência do GARCH(p,q).",
                                "Interpretação econômica precisa de parâmetros.",
                                "Qualidade das previsões e métricas de avaliação.",
                                "Clareza em gráficos e relatório final.",
                                "Identificação de limitações do modelo."
                              ],
                              "crossCurricularConnections": [
                                "Finanças: Value-at-Risk (VaR) e gestão de portfólio.",
                                "Econometria: Modelos ARCH/GARCH family e testes de hipótese.",
                                "Programação: Manipulação de dados em Python/R.",
                                "Estatística: Máxima verossimilhança e distribuições assimétricas.",
                                "Machine Learning: Previsão de séries não-lineares."
                              ],
                              "realWorldApplication": "Em bancos e fundos de investimento, modelos GARCH são usados para calcular VaR diário, precificar opções e hedges contra volatilidade em mercados como Bolsa de Valores, auxiliando traders a gerenciar risco durante crises como a de 2008 ou COVID-19."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.1.3",
                        "name": "Avaliação de Riscos Financeiros",
                        "description": "Aplicação de medidas baseadas em séries temporais, como Value at Risk (VaR), para quantificar e gerenciar riscos em portfólios financeiros.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.1.3.1",
                            "name": "Calcular VaR histórico",
                            "description": "Ordenar retornos históricos de um portfólio e calcular VaR não paramétrico para níveis de confiança como 95% e 99%, interpretando perdas potenciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Coletar e Calcular Retornos Históricos do Portfólio",
                                  "subSteps": [
                                    "Obter preços históricos diários das ações ou ativos do portfólio de uma fonte confiável como Yahoo Finance ou arquivo CSV.",
                                    "Calcular retornos simples diários usando a fórmula: retorno_t = (preço_t - preço_{t-1}) / preço_{t-1}.",
                                    "Compilar todos os retornos em uma lista ou array único para o portfólio (ponderado se múltiplos ativos).",
                                    "Verificar a integridade dos dados: remover ou tratar valores ausentes, outliers extremos e confirmar pelo menos 250 observações.",
                                    "Converter para formato numérico adequado (ex: numpy array) e salvar para uso posterior."
                                  ],
                                  "verification": "Lista de retornos históricos calculados corretamente, sem NaNs ou erros, e plotada para inspeção visual.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Dados históricos de preços (CSV ou API como yfinance)",
                                    "Python com bibliotecas pandas e numpy"
                                  ],
                                  "tips": "Prefira log-retornos (ln(preço_t / preço_{t-1})) para séries longas, pois são aditivos.",
                                  "learningObjective": "Preparar dados de retornos históricos limpos e prontos para análise não-paramétrica de risco.",
                                  "commonMistakes": [
                                    "Usar preços absolutos em vez de retornos percentuais",
                                    "Ignorar feriados ou dados faltantes levando a viés",
                                    "Não ponderar retornos por alocação no portfólio"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Ordenar os Retornos Históricos em Ordem Crescente",
                                  "subSteps": [
                                    "Carregar o array de retornos históricos preparados.",
                                    "Ordenar os retornos do menor (mais negativo, maiores perdas) para o maior usando função de ordenação.",
                                    "Confirmar a ordenação plotando os retornos ordenados ou verificando os extremos.",
                                    "Calcular o número total de observações (n) para uso em percentis.",
                                    "Documentar a distribuição empírica básica (média, mediana, desvios)."
                                  ],
                                  "verification": "Retornos ordenados corretamente com o menor retorno na posição 0 e plotagem confirma ordem ascendente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python: numpy.sort() ou pandas.sort_values()",
                                    "Jupyter Notebook para visualização"
                                  ],
                                  "tips": "Sempre ordene em ordem crescente para focar no tail esquerdo (perdas).",
                                  "learningObjective": "Construir a distribuição empírica ordenada essencial para VaR histórico.",
                                  "commonMistakes": [
                                    "Ordenar em ordem decrescente confundindo perdas com ganhos",
                                    "Incluir retornos não calculados ou duplicados",
                                    "Esquecer de tratar empates em ordenação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular VaR Não-Paramétrico para 95% e 99% de Confiança",
                                  "subSteps": [
                                    "Identificar posições dos percentis: para 95% VaR, usar o 5º percentil (posição aproximada n * 0.05); para 99%, n * 0.01.",
                                    "Extrair os valores dos retornos ordenados nessas posições (usar interpolação linear se n não inteiro).",
                                    "Converter para VaR como perda potencial: VaR = -retorno_percentil (já que retornos negativos representam perdas).",
                                    "Calcular VaR em termos monetários multiplicando pelo valor atual do portfólio.",
                                    "Repetir para ambos níveis e registrar resultados com precisão de 4 casas decimais."
                                  ],
                                  "verification": "VaR 95% e 99% calculados coincidem com np.percentile(retornos_ordenados, [5, 1]) * -1 e testes manuais em subamostras.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python: numpy.percentile() ou scipy.stats.percentileofscore()",
                                    "Calculadora para validação manual"
                                  ],
                                  "tips": "Use interpolação='linear' em percentile para precisão em datasets pequenos.",
                                  "learningObjective": "Aplicar método histórico para quantificar risco em diferentes níveis de confiança.",
                                  "commonMistakes": [
                                    "Esquecer o sinal negativo (VaR como positivo para perdas)",
                                    "Usar percentil da direita (ganhos) em vez da esquerda",
                                    "Arredondar prematuramente posições não-inteiras"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar os Resultados de VaR e Perdas Potenciais",
                                  "subSteps": [
                                    "Explicar VaR 95%: 'Com 95% de confiança, a perda diária máxima não excederá X% do portfólio'.",
                                    "Comparar VaR 95% vs 99%: discutir trade-off entre confiança e magnitude da perda.",
                                    "Visualizar com histograma de retornos e linha vertical nos VaR.",
                                    "Discutir limitações: assume stationarity histórica, ignora correlações dinâmicas.",
                                    "Redigir relatório resumindo riscos e recomendações (ex: stop-loss)."
                                  ],
                                  "verification": "Relatório de interpretação escrito inclui definições corretas, visualizações e limitações, sem erros conceituais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python: matplotlib ou seaborn para gráficos",
                                    "Template de relatório Markdown"
                                  ],
                                  "tips": "Contextualize com valor do portfólio: perda em dólares é mais impactante.",
                                  "learningObjective": "Interpretar VaR no contexto de decisões financeiras e comunicação de risco.",
                                  "commonMistakes": [
                                    "Interpretar VaR como perda garantida (é probabilístico)",
                                    "Ignorar não-normalidade ou fat tails",
                                    "Não mencionar que é histórico, não preditivo"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um portfólio de R$100.000 com 252 retornos diários históricos de ações PETR4 (média -0.1%, desvio 2%). Retornos ordenados: 5º percentil = -3.2%, 1º = -5.8%. VaR 95% = R$3.200 (perda máxima esperada em 95% dos dias); VaR 99% = R$5.800. Interpretação: Em cenários normais, risco diário limitado a 3.2%, mas estresse a 5.8%.",
                              "finalVerifications": [
                                "Retornos históricos calculados e ordenados sem erros numéricos.",
                                "VaR 95% e 99% coincidem com percentis corretos do tail esquerdo.",
                                "Conversão para perdas monetárias precisa.",
                                "Visualizações confirmam distribuição e VaR.",
                                "Interpretação inclui confiança, limitações e recomendações.",
                                "Código reproduzível gera mesmos resultados."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos retornos e ordenação (erro < 0.01%).",
                                "Cálculo correto de percentis e sinal de VaR (100% match com fórmula).",
                                "Interpretação conceitual precisa e contextualizada.",
                                "Qualidade das visualizações e relatório (clareza e completude).",
                                "Tratamento adequado de dados (limpeza e validação).",
                                "Eficiência temporal e uso de ferramentas apropriadas."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Quantis empíricos e distribuições não-paramétricas.",
                                "Programação: Manipulação de dados com Python/pandas/numpy.",
                                "Finanças: Gerenciamento de risco e alocação de capital.",
                                "Matemática: Ordenação, interpolação e probabilidades condicionais.",
                                "Economia: Impacto de riscos em mercados e regulação (Basel)."
                              ],
                              "realWorldApplication": "Instituições financeiras como bancos (Itaú, Bradesco) e fundos de investimento calculam VaR histórico diariamente para definir limites de perda, cumprir exigências regulatórias do Banco Central (Resolução CMN 4.557), alocar capital de risco e reportar a investidores, ajudando a evitar crises como a de 2008."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.1.3.2",
                            "name": "Calcular VaR paramétrico",
                            "description": "Usar médias e variâncias de retornos modelados por GARCH para estimar VaR assumindo distribuição normal ou t-Student, com fórmulas analíticas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de VaR Paramétrico e Modelos GARCH",
                                  "subSteps": [
                                    "Defina Value at Risk (VaR) como a perda máxima esperada em um horizonte de tempo com um nível de confiança dado.",
                                    "Explique o método paramétrico: assume distribuição conhecida dos retornos (normal ou t-Student).",
                                    "Revise o modelo GARCH: como ele modela variância condicional dos retornos para capturar volatilidade em clusters.",
                                    "Identifique parâmetros chave: média μ, variância condicional σ²_t de GARCH(p,q).",
                                    "Discuta diferenças entre distribuição normal e t-Student (caudas mais pesadas na t)."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos e liste 3 diferenças entre normal e t-Student; confira com fontes confiáveis.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Analysis of Financial Time Series' de Ruey Tsay (capítulos relevantes)",
                                    "Artigos sobre GARCH e VaR",
                                    "Notebook Jupyter para anotações"
                                  ],
                                  "tips": "Use diagramas para visualizar GARCH: retornos ~ N(μ, σ_t²) onde σ_t² segue GARCH.",
                                  "learningObjective": "Compreender a base teórica do VaR paramétrico integrado a GARCH.",
                                  "commonMistakes": [
                                    "Confundir VaR histórico com paramétrico",
                                    "Ignorar variância condicional em séries financeiras",
                                    "Assumir homocedasticidade nos retornos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estimar Parâmetros de Média e Variância via Modelo GARCH",
                                  "subSteps": [
                                    "Colete dados de retornos diários de um ativo financeiro (ex: série histórica de ações).",
                                    "Ajuste um modelo GARCH(1,1) usando máxima verossimilhança (MLE).",
                                    "Extraia a média μ (geralmente 0 para retornos excessivos) e a variância condicional σ²_t para o horizonte de VaR.",
                                    "Teste diagnósticos: verifique resíduos padronizados para normalidade e autocorrelação.",
                                    "Previsão de σ²_{t+1} para o próximo período usando equação GARCH."
                                  ],
                                  "verification": "Execute o ajuste em software e verifique se Ljung-Box test p-value > 0.05 nos resíduos quadrados.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com bibliotecas arch, pandas, numpy",
                                    "Dados de Yahoo Finance ou Quandl",
                                    "Documentação arch library"
                                  ],
                                  "tips": "Comece com GARCH(1,1) simples; use log-retornos para evitar retornos negativos.",
                                  "learningObjective": "Obter empiricamente μ e σ_t para input no cálculo de VaR.",
                                  "commonMistakes": [
                                    "Usar retornos simples em vez de log-retornos",
                                    "Não padronizar resíduos",
                                    "Ignorar convergência do otimizador MLE"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Selecionar e Parametrizar a Distribuição dos Retornos",
                                  "subSteps": [
                                    "Escolha distribuição: normal N(μ, σ²) ou t-Student com ν graus de liberdade.",
                                    "Estime ν via teste de Kolmogorov-Smirnov ou QQ-plot nos resíduos GARCH.",
                                    "Calcule quantis: para normal, z_α = norm.ppf(α); para t, t.ppf(α, ν).",
                                    "Ajuste escala: para t-Student, variância é ν/(ν-2) * σ².",
                                    "Compare kurtose: t-Student para leptocurtose comum em finanças."
                                  ],
                                  "verification": "Gere QQ-plot comparando resíduos vs normal e t; escolha a com melhor fit.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python: scipy.stats (norm, t)",
                                    "Matplotlib para QQ-plots",
                                    "Dados do Step 2"
                                  ],
                                  "tips": "ν baixo (3-5) indica caudas pesadas; teste com dados reais de alta volatilidade.",
                                  "learningObjective": "Selecionar distribuição adequada baseada em evidências empíricas.",
                                  "commonMistakes": [
                                    "Sempre assumir normal apesar de evidência de caudas pesadas",
                                    "Esquecer de escalar variância da t",
                                    "Usar α=0.05 sem especificar confiança (ex: 95% VaR usa α=0.05)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular VaR Paramétrico com Fórmulas Analíticas",
                                  "subSteps": [
                                    "Fórmula geral: VaR_α = μ * Δt - z_α * σ * sqrt(Δt), onde z_α é quantil negativo.",
                                    "Para 1 dia (Δt=1), normal: VaR = μ - norm.ppf(α) * σ_t.",
                                    "Para t-Student: VaR = μ - t.ppf(α, ν) * σ_t * sqrt(ν/(ν-2)).",
                                    "Compute para múltiplos horizontes (ex: 10 dias) escalando sqrt(Δt).",
                                    "Implemente função em código para automação."
                                  ],
                                  "verification": "Calcule manualmente para σ=0.02, α=0.05, normal: verifique ≈ -0.0317 (1.645*0.02).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python: scipy.stats.ppf",
                                    "Excel para cálculos manuais iniciais",
                                    "Código do Step 2"
                                  ],
                                  "tips": "Use ppf(α) para quantil inferior (VaR é perda, negativo); reporte como positivo para magnitude.",
                                  "learningObjective": "Aplicar fórmulas exatas para VaR paramétrico.",
                                  "commonMistakes": [
                                    "Usar pdf em vez de ppf",
                                    "Não escalar para multi-dias",
                                    "Confundir α com 1-α (confiança)"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Interpretar o VaR Calculado",
                                  "subSteps": [
                                    "Backteste: compare VaR com retornos reais; conte violações (deve ≈ α * n).",
                                    "Kupiec test para validar cobertura incondicional.",
                                    "Sensibilidade: varie ν ou distribuição e observe impacto no VaR.",
                                    "Interprete: VaR de 1% em 10 dias significa perda máxima com 99% confiança.",
                                    "Documente relatório com gráficos de VaR vs retornos."
                                  ],
                                  "verification": "Número de violações em backtest dentro de intervalo binomial 95%.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python: statsmodels para Kupiec test",
                                    "Matplotlib para plots de exceções",
                                    "Dados históricos longos"
                                  ],
                                  "tips": "Use janela rolante para σ_t em backtest; reporte VaR em moeda (ex: * preço portfólio).",
                                  "learningObjective": "Garantir robustez e interpretação prática do VaR.",
                                  "commonMistakes": [
                                    "Backtest curto (use >250 dias)",
                                    "Ignorar subestimação de caudas",
                                    "Não ajustar por múltiplos testes"
                                  ]
                                }
                              ],
                              "practicalExample": "Para ações da Petrobras (PETR4.SA), ajuste GARCH(1,1) em retornos diários 2020-2023. Obtenha μ≈0, σ_t+1=0.025. Para VaR 95% 1-dia normal: -1.645*0.025 ≈ -4.11%. Para portfólio R$1M: perda máxima R$41.100 com 95% confiança.",
                              "finalVerifications": [
                                "Calcule VaR para dataset dado e backteste sem >5% desvios.",
                                "Explique fórmula t-Student vs normal em 2 frases.",
                                "Gere QQ-plot mostrando fit da t melhor que normal.",
                                "Implemente função Python que recebe GARCH params e retorna VaR.",
                                "Interprete VaR em contexto regulatório (Basel).",
                                "Compare VaR paramétrico vs histórico em tabela."
                              ],
                              "assessmentCriteria": [
                                "Precisão das fórmulas: 100% match com analítica.",
                                "Qualidade do fit GARCH: AIC baixo e resíduos white-noise.",
                                "Backtest válido: Kupiec p-value >0.05.",
                                "Escolha de distribuição justificada por testes gráficos/estatísticos.",
                                "Código limpo, comentado e reproduzível.",
                                "Interpretação contextualizada com unidades monetárias."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: distribuições, quantis, testes de hipóteses.",
                                "Programação: modelagem em Python/R com otimização numérica.",
                                "Finanças: gerenciamento de risco, regulação Basel III.",
                                "Econometria: séries temporais, volatilidade estocástica.",
                                "Matemática Aplicada: funções de densidade e verossimilhança."
                              ],
                              "realWorldApplication": "Bancos e fundos de investimento calculam VaR paramétrico diariamente para compliance regulatório (Basel), alocação de capital e limites de posição, integrando GARCH para capturar volatilidade dinâmica em crises como COVID-19."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.1.3.3",
                            "name": "Implementar VaR por simulação de Monte Carlo",
                            "description": "Gerar trajetórias futuras de retornos via simulações baseadas em modelos GARCH e calcular VaR percentile das distribuições simuladas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar dados históricos e ajustar modelo GARCH",
                                  "subSteps": [
                                    "Coletar série temporal de retornos logarítmicos de um ativo financeiro (ex: ações ou índice).",
                                    "Testar estacionariedade e realizar diferenciação se necessário (teste ADF).",
                                    "Ajustar modelo GARCH(1,1) usando máxima verossimilhança.",
                                    "Diagnosticar o modelo: verificar resíduos padronizados (teste Ljung-Box) e normalidade.",
                                    "Salvar parâmetros estimados (ω, α, β)."
                                  ],
                                  "verification": "Resíduos são brancos (autocorrelação insignificante) e modelo converge sem erros.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Python/R",
                                    "Bibliotecas: arch (Python) ou rugarch (R)",
                                    "Dados históricos (Yahoo Finance via yfinance)"
                                  ],
                                  "tips": "Use retornos logarítmicos para simetria; comece com GARCH(1,1) por simplicidade.",
                                  "learningObjective": "Compreender e aplicar modelagem de volatilidade condicional heteroscedástica.",
                                  "commonMistakes": [
                                    "Ignorar não-estacionariedade",
                                    "Não diagnosticar resíduos",
                                    "Escolha inadequada de ordem GARCH"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar parâmetros da simulação de Monte Carlo",
                                  "subSteps": [
                                    "Definir horizonte de previsão (ex: 1 dia, 10 dias) e número de simulações (ex: 10.000 trajetórias).",
                                    "Inicializar volatilidade condicional com a última estimada do GARCH.",
                                    "Especificar distribuição para inovações (normal ou t-Student baseada em resíduos).",
                                    "Preparar função recursiva para simular volatilidade: σ_t² = ω + α ε_{t-1}² + β σ_{t-1}².",
                                    "Testar função em uma simulação piloto com poucas trajetórias."
                                  ],
                                  "verification": "Função gera volatilidades positivas e trajetórias plausíveis em piloto.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python/R",
                                    "NumPy para vetores aleatórios",
                                    "Funções personalizadas"
                                  ],
                                  "tips": "Use np.random.normal ou multivariate para inovações; vetorize para eficiência.",
                                  "learningObjective": "Configurar simulações paramétricas baseadas em modelos de volatilidade.",
                                  "commonMistakes": [
                                    "Volatilidade negativa nas simulações",
                                    "Poucas simulações levando a variância alta",
                                    "Ignorar distribuição de inovações"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar trajetórias futuras de retornos via Monte Carlo",
                                  "subSteps": [
                                    "Simular inovações ε_t ~ N(0,1) ou t para cada trajetória e horizonte.",
                                    "Recursivamente calcular σ_t para cada passo no horizonte usando parâmetros GARCH.",
                                    "Computar retornos simulados: r_t = μ + σ_t * ε_t (μ=0 para retornos excessivos).",
                                    "Gerar matriz de trajetórias: linhas=simulações, colunas=horizonte.",
                                    "Visualizar histograma de volatilidades simuladas para checagem."
                                  ],
                                  "verification": "Trajetórias mostram volatilidade clustering similar aos dados históricos.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Python/R",
                                    "NumPy/pandas para matrizes",
                                    "Matplotlib para plots"
                                  ],
                                  "tips": "Paralelize com joblib para >10k simulações; armazene em array eficiente.",
                                  "learningObjective": "Implementar simulação forward-looking de processos estocásticos GARCH.",
                                  "commonMistakes": [
                                    "Erro na recursão de volatilidade",
                                    "Não escalar inovações corretamente",
                                    "Sobrecarga computacional sem vetorização"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular VaR percentile das distribuições simuladas",
                                  "subSteps": [
                                    "Para cada horizonte, coletar todos os retornos simulados em um vetor plano.",
                                    "Ordenar vetor e calcular percentil (ex: 5% para VaR 95%).",
                                    "Computar VaR absoluto e relativo ao retorno inicial.",
                                    "Gerar intervalos de confiança bootstrapping das simulações.",
                                    "Plotar fan chart das trajetórias e marcar VaR."
                                  ],
                                  "verification": "VaR é negativo e aumenta com horizonte; consistente com VaR histórico.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python/R",
                                    "NumPy.percentile",
                                    "Seaborn/Matplotlib para visualizações"
                                  ],
                                  "tips": "Use np.percentile(array, 5) para VaR 95%; considere CVaR para tail risk.",
                                  "learningObjective": "Extrair medidas de risco não-paramétricas de distribuições simuladas.",
                                  "commonMistakes": [
                                    "Percentil errado (confundir 5% com 95%)",
                                    "Não considerar múltiplos horizontes",
                                    "Ignorar normalização de retornos"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e interpretar o VaR simulado",
                                  "subSteps": [
                                    "Comparar VaR simulado com VaR histórico (backtesting: Kupiec test).",
                                    "Analisar cobertura: número de violações em período out-of-sample.",
                                    "Sensibilizar parâmetros GARCH e observar impacto no VaR.",
                                    "Documentar relatório com plots, valores e limitações.",
                                    "Implementar função reutilizável para novos ativos."
                                  ],
                                  "verification": "Backtest passa (p-value >0.05); VaR sensível a parâmetros.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Python/R",
                                    "Bibliotecas de backtesting",
                                    "Dados out-of-sample"
                                  ],
                                  "tips": "Use 250 dias out-of-sample; reporte VaR em % e valor monetário.",
                                  "learningObjective": "Validar robustez de medidas de risco computacionais.",
                                  "commonMistakes": [
                                    "Sem backtesting",
                                    "Sobreajuste do GARCH",
                                    "Interpretação errada de percentil"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente VaR 95% ao dia 10 para o índice IBOVESPA usando dados diários de 2020-2024. Ajuste GARCH(1,1), simule 50.000 trajetórias e calcule VaR como -2.5% (exemplo hipotético).",
                              "finalVerifications": [
                                "Modelo GARCH ajusta bem (AIC baixo, resíduos brancos).",
                                "Simulações produzem 10.000+ trajetórias sem erros numéricos.",
                                "VaR percentile é consistente com histórico (backtest ok).",
                                "Visualizações mostram fan chart plausível com volatilidade clustering.",
                                "Função é modular e roda em <5 min para horizontes curtos.",
                                "Sensibilidade a parâmetros altera VaR de forma esperada."
                              ],
                              "assessmentCriteria": [
                                "Precisão do ajuste GARCH (LLH e testes diagnósticos).",
                                "Eficiência computacional das simulações (>10k trajetórias rápidas).",
                                "Correção do cálculo percentile (teste com known distributions).",
                                "Qualidade das validações (backtest estatístico significativo).",
                                "Clareza do código e documentação (comentários e plots).",
                                "Robustez a diferentes ativos/horizontes."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: Distribuições condicionais e percentiles.",
                                "Programação Computacional: Vetorização e paralelismo em Python/R.",
                                "Finanças: Gerenciamento de risco e modelos estocásticos.",
                                "Matemática Aplicada: Equações diferenciais estocásticas discretas.",
                                "Análise de Dados: Séries temporais e validação de modelos."
                              ],
                              "realWorldApplication": "Bancos e fundos de investimento usam VaR Monte Carlo GARCH para definir limites de perda diária, alocar capital regulatório (Basel III) e stress tests em portfólios de R$ bilhões, evitando falências como a de 2008."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.1.3.4",
                            "name": "Realizar backtesting de medidas de risco",
                            "description": "Comparar VaR estimado com violações reais em dados out-of-sample usando testes como Kupiec e Christoffersen para validar a precisão das medidas de risco.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar dados out-of-sample e calcular VaR estimado",
                                  "subSteps": [
                                    "Coletar dados históricos de retornos de ativos financeiros para o período out-of-sample (ex: últimos 250 dias úteis).",
                                    "Calcular retornos diários logarítmicos: rt = log(Pt / Pt-1).",
                                    "Estimar VaR para diferentes níveis de confiança (ex: 95%, 99%) usando métodos paramétrico (normal), histórico ou EWMA.",
                                    "Armazenar os valores de VaR estimados para cada dia no período out-of-sample.",
                                    "Validar a estacionariedade dos dados com teste ADF se necessário."
                                  ],
                                  "verification": "Verificar se o array de VaR out-of-sample tem o mesmo comprimento que os retornos e sem valores NaN.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Dados históricos (Yahoo Finance ou Quandl)",
                                    "Python (pandas, numpy)",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Use rolling windows para simular previsão real-time; evite lookahead bias.",
                                  "learningObjective": "Dominar preparação de dados e estimação de VaR para backtesting.",
                                  "commonMistakes": [
                                    "Incluir dados in-sample no out-of-sample",
                                    "Ignorar feriados e ajustar datas",
                                    "Não escalar para unidades monetárias"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e contar violações de VaR",
                                  "subSteps": [
                                    "Definir violações: dias onde retorno real < VaR estimado (para VaR negativo).",
                                    "Criar indicador binário de violação: 1 se violado, 0 caso contrário.",
                                    "Contar número total de violações e calcular proporção observada: p = violações / N.",
                                    "Comparar p com nível esperado: α (ex: 0.05 para 95% VaR).",
                                    "Plotar série temporal de violações para inspeção visual."
                                  ],
                                  "verification": "Proporção de violações próxima de α ± sqrt(α(1-α)/N); gráfico sem clusters óbvios.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Python (pandas, matplotlib)",
                                    "Código do Step 1"
                                  ],
                                  "tips": "Use hit sequence: sum(indicador) == número de violações esperadas.",
                                  "learningObjective": "Aprender a detectar e quantificar exceções em medidas de risco.",
                                  "commonMistakes": [
                                    "Confundir sinal de VaR (long/short positions)",
                                    "Não ajustar por múltiplos horizontes",
                                    "Ignorar violações em fins de semana"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar teste de Kupiec (teste incondicional de proporção)",
                                  "subSteps": [
                                    "Calcular estatística LRuc = -2 * ln[ (1-α)^(N-n) * α^n / (1-p)^(N-n) * p^n ] onde n=violações, N=amostra.",
                                    "Comparar LRuc com qui-quadrado(1) crítico no nível desejado (ex: 3.84 para 5%).",
                                    "Implementar função em Python usando scipy.stats.chi2.",
                                    "Interpretar: p-value > 0.05 aceita H0 (proporção correta).",
                                    "Testar para múltiplos α."
                                  ],
                                  "verification": "Cálculo manual coincide com função implementada; p-value reportado corretamente.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Python (scipy.stats, numpy)",
                                    "Documentação Basel Accord"
                                  ],
                                  "tips": "Use log-likelihood para precisão numérica; teste bidirecional se necessário.",
                                  "learningObjective": "Executar e interpretar teste de Kupiec para validade de VaR.",
                                  "commonMistakes": [
                                    "Erro na fórmula LR (confundir uc/cc)",
                                    "Usar t-student em vez de qui-quadrado",
                                    "Amostra muito pequena (N<100)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar teste de Christoffersen (teste de independência/ clustering)",
                                  "subSteps": [
                                    "Calcular transições: n00, n01, n10, n11 de matriz de violações consecutivas.",
                                    "Estimar π00 = n00/(n00+n01), π1 = (n10+n11)/(n10+n11).",
                                    "Estatística LRind = -2 * ln[ probabilidade sob independência vs observada ].",
                                    "Comparar com qui-quadrado(1); rejeitar se clustering significativo.",
                                    "Reportar p-value e concluir sobre independência das violações."
                                  ],
                                  "verification": "Matriz de transição soma corretamente; LRind < crítico implica aceitação.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python (numpy para matriz)",
                                    "Referência: Christoffersen (1998)"
                                  ],
                                  "tips": "Verificar n01 e n10 >0; senão teste inválido.",
                                  "learningObjective": "Avaliar clustering de violações com teste condicional.",
                                  "commonMistakes": [
                                    "Índices errados na matriz (00 vs 11)",
                                    "Não tratar zeros nas transições",
                                    "Confundir com Kupiec"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar resultados, interpretar e relatar",
                                  "subSteps": [
                                    "Compilar tabela: α, violações observadas, p Kupiec, p Christoffersen.",
                                    "Concluir validade do modelo VaR: rejeitar se ambos testes falham.",
                                    "Visualizar: traffic light report (verde=passa, vermelho=falha).",
                                    "Sugerir ajustes: recalibrar modelo se rejeitado.",
                                    "Documentar relatório com código e outputs."
                                  ],
                                  "verification": "Relatório inclui todos testes, conclusões claras e recomendações.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Jupyter para relatório",
                                    "Templates de backtest"
                                  ],
                                  "tips": "Inclua confidence intervals para proporções.",
                                  "learningObjective": "Sintetizar backtesting para decisões de risco.",
                                  "commonMistakes": [
                                    "Ignorar tamanho da amostra",
                                    "Não contextualizar economicamente",
                                    "Relatório sem visuals"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dados diários do índice S&P500 de 2020-2023 (out-of-sample 2022-2023), calcule VaR 95% histórico com janela 250 dias. Identifique 13 violações em 252 dias (p=0.0516). Kupiec p-value=0.92 (passa), Christoffersen p=0.15 (passa), validando modelo para regulação Basel.",
                              "finalVerifications": [
                                "Proporção de violações está dentro de bandas de confiança para α.",
                                "Ambos testes Kupiec e Christoffersen têm p-value >0.05.",
                                "Gráficos mostram violações aleatórias sem clusters.",
                                "Relatório inclui interpretação econômica das falhas.",
                                "Código reproduzível gera mesmos resultados.",
                                "Testes sensíveis a diferentes janelas out-of-sample passam."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de LRuc e LRind (erro <1%).",
                                "Correta identificação de violações e matriz de transições.",
                                "Interpretação adequada de p-values e conclusões.",
                                "Qualidade visual dos plots e relatório.",
                                "Eficiência do código (vetorizado, sem loops desnecessários).",
                                "Tratamento de edge cases (poucas violações)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Testes de hipóteses qui-quadrado e log-likelihood.",
                                "Programação: Manipulação de séries temporais em Python/R.",
                                "Finanças: Conformidade regulatória (Basel III/IV).",
                                "Machine Learning: Validação de modelos preditivos.",
                                "Econometria: Modelos GARCH para VaR avançado."
                              ],
                              "realWorldApplication": "Bancos e fundos de investimento usam backtesting diário de VaR para aprovar modelos internos junto a reguladores como CVM/Bacen, evitando multas por subestimação de risco e otimizando alocação de capital."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.8.2",
                    "name": "Aplicações em Marketing",
                    "description": "Previsão de vendas, análise de tendências sazonais e segmentação de mercado com base em séries temporais.",
                    "individualConcepts": [
                      {
                        "id": "10.1.8.2.1",
                        "name": "Previsão de Vendas com Séries Temporais",
                        "description": "Aplicação de modelos de séries temporais para prever vendas futuras, considerando componentes como tendência e ruído, com base em dados históricos de marketing.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.2.1.1",
                            "name": "Preparar dados de vendas para modelagem temporal",
                            "description": "Importar dados de vendas de fontes como planilhas ou bancos de dados, transformá-los em séries temporais indexadas por tempo, tratar valores ausentes e realizar testes iniciais de estacionariedade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Importar dados de vendas de fontes variadas",
                                  "subSteps": [
                                    "Identifique a fonte dos dados (planilha CSV/Excel ou banco de dados SQL).",
                                    "Instale e importe bibliotecas necessárias (ex: pandas para Python, readr para R).",
                                    "Carregue os dados usando funções apropriadas (pd.read_csv(), pd.read_excel(), pd.read_sql()).",
                                    "Inspecione a estrutura inicial com head(), info() e describe().",
                                    "Salve uma cópia do dataset original para backup."
                                  ],
                                  "verification": "Execute df.head() e df.info() para confirmar que os dados foram carregados corretamente sem erros de parsing.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python com pandas instalado",
                                    "Arquivo CSV/Excel de exemplo com colunas: data_venda, produto, valor_venda",
                                    "Acesso a banco de dados de teste (opcional)"
                                  ],
                                  "tips": "Sempre especifique o separador e encoding na importação para evitar erros comuns em CSVs internacionais.",
                                  "learningObjective": "Carregar dados de vendas de múltiplas fontes de forma eficiente e inspecionar sua estrutura inicial.",
                                  "commonMistakes": [
                                    "Ignorar datas em formato não padrão levando a colunas erradas",
                                    "Não verificar tipos de dados (data como string)",
                                    "Carregar dataset grande sem amostragem inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Transformar dados em séries temporais indexadas por tempo",
                                  "subSteps": [
                                    "Converta a coluna de data para datetime usando pd.to_datetime().",
                                    "Agregue dados por período temporal relevante (diário, semanal, mensal) com resample() ou groupby().",
                                    "Defina o índice temporal com df.set_index('data').",
                                    "Ordene o índice cronologicamente com df.sort_index().",
                                    "Crie uma série temporal única somando valores de vendas por período."
                                  ],
                                  "verification": "Confirme com df.index.dtype == 'datetime64[ns]' e plote df.plot() para visualizar a série temporal contínua.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Biblioteca pandas",
                                    "Dataset importado do Step 1",
                                    "Matplotlib para plot inicial"
                                  ],
                                  "tips": "Use freq='M' no resample() para agregação mensal; verifique fusos horários se dados globais.",
                                  "learningObjective": "Converter dados tabulares irregulares em séries temporais padronizadas e indexadas corretamente.",
                                  "commonMistakes": [
                                    "Não converter data para datetime antes de indexar",
                                    "Agregação errada levando a duplicatas",
                                    "Índice não ordenado causando loops infinitos em modelos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Tratar valores ausentes na série temporal",
                                  "subSteps": [
                                    "Identifique missing values com df.isnull().sum() e visualize com df.plot().",
                                    "Escolha método de imputação: forward fill (ffill()), backward fill (bfill()), interpolação linear (interpolate()).",
                                    "Aplique o método selecionado baseado no contexto (ex: ffill para vendas sazonais).",
                                    "Verifique distribuição antes/depois com boxplots.",
                                    "Documente as imputações em um log ou nova coluna flag."
                                  ],
                                  "verification": "Confirme df.isnull().sum() == 0 e compare estatísticas descritivas pré/pós-tratamento.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "pandas",
                                    "Série temporal do Step 2",
                                    "Seaborn/Matplotlib para visualizações"
                                  ],
                                  "tips": "Para séries curtas, prefira interpolação; evite mean fill que distorce variância temporal.",
                                  "learningObjective": "Aplicar técnicas apropriadas de imputação para manter integridade da série temporal.",
                                  "commonMistakes": [
                                    "Deletar NAs sem justificativa (perda de informação)",
                                    "Usar fillna(0) em vendas (bias para baixo)",
                                    "Ignorar padrões sazonais na escolha do método"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Realizar testes iniciais de estacionariedade",
                                  "subSteps": [
                                    "Instale e importe statsmodels.tsa.stattools.",
                                    "Plote a série, ACF e PACF para inspeção visual.",
                                    "Aplique teste de Dickey-Fuller (adf_test) com hipóteses nulas/ alternativas claras.",
                                    "Interprete p-value (<0.05 indica estacionariedade).",
                                    "Se não estacionária, aplique log ou diferenciação e re-teste."
                                  ],
                                  "verification": "Obtenha p-value do ADF test <0.05 e confirme com plot de resíduos sem tendências.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "statsmodels instalado",
                                    "Série limpa do Step 3",
                                    "Jupyter Notebook para plots interativos"
                                  ],
                                  "tips": "Sempre teste múltiplas lags no ADF; log-transforma antes se variância crescente.",
                                  "learningObjective": "Diagnosticar propriedades de estacionariedade para preparar dados para modelagem.",
                                  "commonMistakes": [
                                    "Interpretar p-value errado (alta p-value = não estacionária)",
                                    "Não plotar ACF antes do teste",
                                    "Diferenciar excessivamente removendo sazonalidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dados de vendas mensais de uma rede de varejo (CSV com 36 meses de vendas de eletrônicos), importe via pandas, agregue por mês, imputa 2 NAs com ffill(), e confirme estacionariedade após log-transformação via ADF test (p=0.03).",
                              "finalVerifications": [
                                "Série temporal indexada corretamente por data sem gaps não tratados.",
                                "Zero valores ausentes após imputação.",
                                "Teste ADF indica estacionariedade (p<0.05).",
                                "Plots mostram ausência de tendência e sazonalidade excessiva.",
                                "Estatísticas descritivas estáveis pré/pós-processamento.",
                                "Código reproduzível com seed e logs de decisões."
                              ],
                              "assessmentCriteria": [
                                "Precisão na importação e parsing de datas (100% sem erros).",
                                "Adequação do método de imputação ao contexto temporal (justificado).",
                                "Correta implementação e interpretação do teste de estacionariedade.",
                                "Qualidade dos plots e visualizações diagnósticas.",
                                "Eficiência do código (otimizado, sem loops desnecessários).",
                                "Documentação clara de transformações aplicadas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estatística inferencial e testes de hipóteses.",
                                "Programação: Manipulação de dados com Python/pandas.",
                                "Negócios: Análise de marketing e previsão de demanda.",
                                "Banco de Dados: Queries SQL para extração inicial."
                              ],
                              "realWorldApplication": "Em equipes de marketing de e-commerce, preparar dados de vendas diárias para modelos ARIMA/SARIMA, otimizando estoque e campanhas promocionais, reduzindo overstock em 15-20%."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.2.1.2",
                            "name": "Realizar análise exploratória de séries de vendas",
                            "description": "Aplicar gráficos ACF/PACF, decomposição STL e testes de Dickey-Fuller para identificar tendências, sazonalidades e não-estacionaridade em dados de vendas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Carregar e Visualizar Inicialmente a Série de Vendas",
                                  "subSteps": [
                                    "Importar bibliotecas necessárias: pandas, matplotlib.pyplot, statsmodels.tsa.seasonal",
                                    "Carregar o dataset de vendas (ex: CSV com coluna de data e vendas)",
                                    "Converter a coluna de data para datetime e definir como índice",
                                    "Plotar a série temporal básica para observar tendências e sazonalidades visuais",
                                    "Calcular estatísticas descritivas (média, mediana, desvio padrão)"
                                  ],
                                  "verification": "Gráfico da série temporal gerado e estatísticas descritivas impressas sem erros",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python 3.x",
                                    "Bibliotecas: pandas, matplotlib, statsmodels",
                                    "Dataset de vendas (ex: vendas_mensais.csv)"
                                  ],
                                  "tips": "Use pd.to_datetime() com infer_datetime_format=True para eficiência em grandes datasets",
                                  "learningObjective": "Entender a estrutura dos dados de séries temporais e identificar padrões iniciais visuais",
                                  "commonMistakes": [
                                    "Ignorar NaNs ou dados ausentes",
                                    "Não definir índice temporal corretamente",
                                    "Escala inadequada no gráfico"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar Decomposição STL",
                                  "subSteps": [
                                    "Instalar/importar statsmodels se necessário",
                                    "Aplicar decomposição STL usando seasonal_decompose com período sazonal adequado (ex: 12 para mensal)",
                                    "Plotar os componentes: tendência, sazonalidade e resíduo",
                                    "Analisar visualmente a força da sazonalidade e tendência",
                                    "Salvar os componentes em variáveis para uso posterior"
                                  ],
                                  "verification": "Gráficos de decomposição STL exibidos corretamente com todos os componentes identificados",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Biblioteca statsmodels.tsa.seasonal",
                                    "Notebook Jupyter para visualizações interativas"
                                  ],
                                  "tips": "Ajuste o parâmetro 'period' baseado na frequência conhecida dos dados (ex: 7 para semanal)",
                                  "learningObjective": "Decompor a série em componentes aditivos para isolar tendências e sazonalidades",
                                  "commonMistakes": [
                                    "Período sazonal incorreto levando a decomposição falha",
                                    "Não inspecionar resíduos por padrões restantes",
                                    "Usar modelo multiplicativo sem verificar variância"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar Gráficos ACF e PACF",
                                  "subSteps": [
                                    "Usar plot_acf e plot_pacf do statsmodels.graphics.tsaplots",
                                    "Definir lags apropriados (ex: 40 lags)",
                                    "Plotar ACF para autocorrelação e PACF para autocorrelação parcial",
                                    "Identificar cortes significativos para possíveis ordens ARIMA",
                                    "Interpretar decaimento exponencial ou sinusoidal indicando não-estacionariedade"
                                  ],
                                  "verification": "Gráficos ACF/PACF gerados com bandas de confiança e interpretações anotadas",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "statsmodels.graphics.tsaplots",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Foque nos lags dentro das bandas azuis (95% confiança); ignore lag 0 em ACF",
                                  "learningObjective": "Detectar dependências temporais e padrões de autocorrelação na série",
                                  "commonMistakes": [
                                    "Interpretar lags insignificantes como significativos",
                                    "Não padronizar dados antes",
                                    "Confundir ACF com PACF"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Teste de Dickey-Fuller e Interpretar Resultados",
                                  "subSteps": [
                                    "Importar adfuller de statsmodels.tsa.stattools",
                                    "Executar adfuller() na série original e nos resíduos da decomposição",
                                    "Analisar p-value, estatística do teste e valores críticos",
                                    "Concluir sobre estacionariedade (rejeitar H0 se p<0.05)",
                                    "Documentar achados em relatório com gráficos e tabelas"
                                  ],
                                  "verification": "Resultados do teste ADF tabulados e conclusão sobre estacionariedade escrita",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "statsmodels.tsa.stattools",
                                    "Dataset processado dos steps anteriores"
                                  ],
                                  "tips": "Teste também diferenciações se não estacionária; use resíduos STL para teste mais robusto",
                                  "learningObjective": "Testar formalmente a estacionariedade para guiar modelagem futura",
                                  "commonMistakes": [
                                    "Ignorar tendência no teste sem detrending",
                                    "Confundir H0 (não-estacionária) com resultado",
                                    "Não reportar todos os outputs do teste"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar Análises e Gerar Relatório Exploratório",
                                  "subSteps": [
                                    "Compilar insights de todos os steps: tendências, sazonalidades, estacionariedade",
                                    "Criar dashboard ou relatório com todos os gráficos e conclusões",
                                    "Sugerir próximos passos (ex: diferenciação, modelagem ARIMA)",
                                    "Validar com subconjunto de dados ou cross-validation visual",
                                    "Exportar relatório como PDF ou HTML"
                                  ],
                                  "verification": "Relatório completo gerado com todos os elementos e insights coerentes",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Bibliotecas: matplotlib, seaborn para dashboard",
                                    "Ferramenta de export: nbconvert ou plotly"
                                  ],
                                  "tips": "Use subplot para organizar múltiplos gráficos em um só painel",
                                  "learningObjective": "Sintetizar análises exploratórias em insights acionáveis para previsão",
                                  "commonMistakes": [
                                    "Insights desconectados entre testes",
                                    "Omitir limitações dos dados",
                                    "Relatório sem visualizações claras"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dados reais de vendas mensais de produtos de uma rede varejista (disponível no Kaggle como 'Rossmann Store Sales'), carregue as vendas de uma loja específica de 2013-2015, aplique decomposição STL (período=12), identifique sazonalidade de feriados, detecte não-estacionariedade via ADF (p>0.05) e ACF com decaimento lento, confirmando necessidade de diferenciação para modelagem de previsão de estoque.",
                              "finalVerifications": [
                                "Decomposição STL revela tendência crescente e sazonalidade anual clara",
                                "Gráficos ACF/PACF mostram autocorrelações significativas em lags sazonais",
                                "Teste ADF rejeita estacionariedade na série original (p-value >0.05)",
                                "Insights documentados identificam padrões chave como picos de vendas em dezembro",
                                "Relatório inclui recomendações para modelagem (ex: SARIMA(1,1,1)(1,1,1)12)",
                                "Todos os gráficos são legíveis com títulos e legendas"
                              ],
                              "assessmentCriteria": [
                                "Precisão na implementação de funções STL, ACF/PACF e ADF (sem erros de código)",
                                "Interpretação correta dos resultados gráficos e estatísticos",
                                "Identificação precisa de tendências, sazonalidades e não-estacionariedade",
                                "Relatório claro, conciso e com visualizações profissionais",
                                "Eficiência temporal: análise completa em <6 horas",
                                "Uso adequado de parâmetros baseados no contexto dos dados"
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Testes de hipóteses e decomposição aditiva/multiplicativa",
                                "Programação: Manipulação de dados com pandas e visualização em Python",
                                "Marketing: Aplicação em previsão de demanda e planejamento promocional",
                                "Economia: Análise de ciclos econômicos em dados de vendas",
                                "Machine Learning: Preparação para modelos de séries temporais como ARIMA/LSTM"
                              ],
                              "realWorldApplication": "Em empresas de varejo como Amazon ou Walmart, essa análise exploratória guia o planejamento de estoque sazonal, otimização de promoções e previsão de demanda, reduzindo overstock em 15-20% e melhorando a precisão de forecasts para decisões de supply chain."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.2.1.3",
                            "name": "Implementar e avaliar modelos de previsão de vendas",
                            "description": "Selecionar e ajustar modelos como ARIMA ou ETS para previsão de vendas, calcular métricas como MAE e RMSE, e validar com dados de teste.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e explorar dados de séries temporais de vendas",
                                  "subSteps": [
                                    "Carregue o dataset de vendas históricas usando pandas em Python.",
                                    "Plote a série temporal para visualizar tendências, sazonalidade e ciclos.",
                                    "Teste estacionariedade com testes como ADF (Augmented Dickey-Fuller).",
                                    "Aplique transformações como diferenciação ou log se necessário.",
                                    "Divida os dados em treino e teste (ex: 80/20)."
                                  ],
                                  "verification": "Gráficos de série temporal limpa e resultados de teste de estacionariedade mostram p-valor < 0.05.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Python com pandas, matplotlib, statsmodels",
                                    "Dataset de vendas (ex: Walmart Sales ou Kaggle Time Series)"
                                  ],
                                  "tips": "Sempre visualize antes de modelar; use decompose() para separar componentes.",
                                  "learningObjective": "Entender e preparar dados de séries temporais para modelagem preditiva.",
                                  "commonMistakes": [
                                    "Ignorar sazonalidade",
                                    "Não testar estacionariedade",
                                    "Divisão inadequada de dados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e implementar modelo base (ARIMA ou ETS)",
                                  "subSteps": [
                                    "Identifique parâmetros ARIMA com auto_arima() ou análise ACF/PACF.",
                                    "Implemente ARIMA usando statsmodels.tsa.arima.model.ARIMA().",
                                    "Para ETS, use statsmodels.tsa.exponential_smoothing.ets.ETSModel().",
                                    "Ajuste o modelo aos dados de treino com fit().",
                                    "Gere previsões iniciais para os dados de teste."
                                  ],
                                  "verification": "Modelo ajustado sem erros e previsões geradas para horizonte de 12 períodos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Biblioteca statsmodels ou pmdarima para auto_arima",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Comece com ETS se houver forte sazonalidade; use auto_arima para automação.",
                                  "learningObjective": "Selecionar e codificar modelos de séries temporais adequados para previsão de vendas.",
                                  "commonMistakes": [
                                    "Escolher parâmetros manualmente sem ACF/PACF",
                                    "Ignorar ordem de integração (d)",
                                    "Sobreajuste precoce"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Ajustar hiperparâmetros e otimizar o modelo",
                                  "subSteps": [
                                    "Use validação cruzada temporal (TimeSeriesSplit) para testar combinações.",
                                    "Otimize parâmetros com grid search ou funções de otimização.",
                                    "Compare ARIMA e ETS com AIC/BIC para seleção final.",
                                    "Reajuste o melhor modelo nos dados completos de treino.",
                                    "Plote resíduos para checar normalidade e autocorrelação."
                                  ],
                                  "verification": "Resíduos mostram ausência de autocorrelação (Ljung-Box test p>0.05) e AIC mais baixo.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "scikit-learn para TimeSeriesSplit",
                                    "pmdarima para otimização"
                                  ],
                                  "tips": "Evite vazamento de dados futuros; otimize apenas em treino.",
                                  "learningObjective": "Otimizar modelos de previsão para melhor performance em dados de vendas.",
                                  "commonMistakes": [
                                    "Validação cruzada não-temporal",
                                    "Ignorar critérios como AIC",
                                    "Não checar resíduos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar modelo com métricas e validar resultados",
                                  "subSteps": [
                                    "Calcule MAE, RMSE, MAPE nas previsões vs. dados de teste.",
                                    "Implemente funções personalizadas: mae = mean(abs(y_true - y_pred)).",
                                    "Compare com baseline (média ou naive forecast).",
                                    "Valide com walk-forward validation para robustez.",
                                    "Interprete métricas e sugira melhorias."
                                  ],
                                  "verification": "Relatório com métricas < baseline e gráficos de previsão vs. real.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "NumPy para métricas",
                                    "Matplotlib para plots de previsão"
                                  ],
                                  "tips": "RMSE penaliza erros grandes; use MAPE para escalas percentuais em vendas.",
                                  "learningObjective": "Avaliar rigorosamente modelos preditivos usando métricas padrão.",
                                  "commonMistakes": [
                                    "Métricas só em treino",
                                    "Comparar sem baseline",
                                    "Ignorar intervalos de confiança"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dados mensais de vendas de produtos eletrônicos de uma loja online (ex: dataset Kaggle 'Store Sales'), implemente ARIMA(1,1,1)(1,1,1)[12] para prever vendas dos próximos 6 meses, ajuste com ETS se sazonal, calcule RMSE=150 unidades e valide que supera previsão naive em 20%.",
                              "finalVerifications": [
                                "Modelo gera previsões precisas com RMSE < 10% do MAE baseline.",
                                "Resíduos são estacionários e sem padrões.",
                                "Código roda sem erros em dados novos.",
                                "Relatório inclui gráficos e métricas interpretadas.",
                                "Modelo selecionado justificado por AIC/BIC.",
                                "Validação em hold-out set confirma generalização."
                              ],
                              "assessmentCriteria": [
                                "Precisão das métricas (MAE/RMSE abaixo de thresholds).",
                                "Qualidade da preparação de dados (estacionariedade comprovada).",
                                "Adequação do modelo escolhido (melhor AIC).",
                                "Robustez da validação (cross-validation temporal).",
                                "Clareza do código e documentação.",
                                "Interpretação prática dos resultados para marketing."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Python/R para análise de dados.",
                                "Estatística: Testes de hipóteses e inferência.",
                                "Negócios/Marketing: Planejamento de estoque e campanhas.",
                                "Machine Learning: Modelos supervisionados e tuning."
                              ],
                              "realWorldApplication": "Em empresas de varejo como Amazon ou Magazine Luiza, prever vendas sazonais otimiza estoque, reduz custos em 15-20% e melhora decisões de precificação e promoções baseadas em demanda futura."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.2.2",
                        "name": "Análise de Tendências Sazonais em Marketing",
                        "description": "Identificação e modelagem de padrões sazonais em dados de marketing, como picos de vendas em feriados ou estações, para otimizar campanhas.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.2.2.1",
                            "name": "Detectar componentes sazonais em séries temporais de marketing",
                            "description": "Usar decomposição clássica ou métodos como STL para separar tendência, sazonalidade e resíduo em séries de vendas ou tráfego web.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e Visualizar a Série Temporal",
                                  "subSteps": [
                                    "Coletar dados de séries temporais de marketing, como vendas mensais ou tráfego web, garantindo formato de data e valores numéricos.",
                                    "Verificar e tratar valores ausentes, outliers ou dados não estacionários usando interpolações ou remoção.",
                                    "Plotar a série temporal bruta com gráficos de linha para identificar padrões visuais iniciais de sazonalidade.",
                                    "Determinar a frequência sazonal (ex: 12 para mensal) com base no contexto de marketing.",
                                    "Calcular estatísticas descritivas básicas (média, mediana, variância) por período sazonal."
                                  ],
                                  "verification": "Gráfico da série temporal plotado corretamente sem erros de dados, com eixos rotulados e frequência identificada.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Dataset de exemplo (CSV de vendas ou tráfego web)",
                                    "Python com pandas, matplotlib ou R com ggplot2"
                                  ],
                                  "tips": "Sempre use índices de data em pandas para facilitar operações temporais; visualize múltiplas escalas (zoom em picos sazonais).",
                                  "learningObjective": "Compreender a estrutura de dados temporais e preparar para decomposição.",
                                  "commonMistakes": [
                                    "Ignorar valores ausentes levando a plots distorcidos",
                                    "Não converter datas para formato datetime",
                                    "Assumir frequência sem verificação contextual"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar Decomposição Clássica ou STL",
                                  "subSteps": [
                                    "Escolher método: decomposição clássica (aditiva/multiplicativa) para Python statsmodels ou STL para robustez em não-lineares.",
                                    "Implementar decomposição clássica: seasonal_decompose() no statsmodels, especificando model='additive' ou 'multiplicative'.",
                                    "Para STL: usar stl() no R ou Prophet/STL em Python, ajustando parâmetros de janela sazonal (ex: s.window=13 para mensal).",
                                    "Extrair componentes: tendência, sazonal e resíduo, plotando cada um separadamente.",
                                    "Ajustar parâmetros iterativamente se resíduos mostrarem padrões restantes."
                                  ],
                                  "verification": "Componentes plotados corretamente com soma/ produto reconstruindo a série original (verificar RMSE baixo).",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Bibliotecas: statsmodels, prophet (Python) ou forecast (R)",
                                    "Jupyter Notebook ou RStudio"
                                  ],
                                  "tips": "Use modelo multiplicativo para séries com variância crescente; teste reconstrução somando componentes.",
                                  "learningObjective": "Executar decomposição para isolar sazonalidade de forma precisa.",
                                  "commonMistakes": [
                                    "Escolher modelo aditivo para dados com heteroscedasticidade",
                                    "Janelas sazonais inadequadas causando over-smoothing",
                                    "Não plotar resíduos para validação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar e Interpretar Componentes Sazonais",
                                  "subSteps": [
                                    "Examinar componente sazonal: identificar picos/vales (ex: Black Friday em vendas).",
                                    "Comparar amplitude sazonal com tendência para medir impacto relativo.",
                                    "Analisar resíduos: testar estacionariedade (ADF test) e ausência de padrões.",
                                    "Mapear sazonalidade ao calendário de marketing (feriados, estações).",
                                    "Quantificar força sazonal (ex: média absoluta do componente sazonal / média da série)."
                                  ],
                                  "verification": "Relatório com interpretações claras, incluindo mapa sazonal e métricas quantificadas.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Funções de teste: adfuller (Python), Box.test (R)",
                                    "Ferramentas de anotação em plots"
                                  ],
                                  "tips": "Anotar plots com eventos de marketing conhecidos para validação visual.",
                                  "learningObjective": "Interpretar componentes no contexto de negócios de marketing.",
                                  "commonMistakes": [
                                    "Confundir sazonalidade com tendência de longo prazo",
                                    "Ignorar resíduos não aleatórios",
                                    "Não contextualizar com eventos reais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar Resultados e Previsões Sazonais",
                                  "subSteps": [
                                    "Reconstruir série original dos componentes e calcular erro de ajuste.",
                                    "Validar com hold-out set: decompor subconjunto de teste e comparar.",
                                    "Gerar previsões sazonais ajustadas e plotar com intervalos de confiança.",
                                    "Documentar insights acionáveis para marketing (ex: aumentar estoque em picos).",
                                    "Exportar componentes para relatórios ou dashboards."
                                  ],
                                  "verification": "Previsões sazonais com erro <10% em hold-out e insights documentados.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Bibliotecas de forecasting: Prophet ou ARIMA sazonal",
                                    "Excel ou Tableau para dashboards"
                                  ],
                                  "learningObjective": "Validar decomposição e aplicar em decisões de marketing.",
                                  "commonMistakes": [
                                    "Overfitting parâmetros sem validação cruzada",
                                    "Não quantificar incertezas em previsões",
                                    "Falta de ligação com ações de marketing"
                                  ],
                                  "tips": [
                                    "Utilize validação cruzada com pelo menos 5 folds para evitar overfitting nos parâmetros do modelo.",
                                    "Sempre plotar intervalos de confiança para visualizar incertezas e tomar decisões robustas.",
                                    "Conecte os picos identificados a métricas de desempenho do marketing (ex: conversão, rotatividade) para priorizar ações.",
                                    "Teste diferentes tamanhos de hold-out set (20-30% dos dados) para avaliar estabilidade das previsões.",
                                    "Documente hipóteses sobre causas de sazonalidade (ex: eventos, campanhas) para melhorar a precisão futura."
                                  ]
                                }
                              ],
                              "practicalExample": "Analise dados mensais de vendas de uma loja online de roupas (2018-2023). Use STL para decompor, identificando picos em dezembro (Natal) e verão, permitindo planejar estoque e promoções.",
                              "finalVerifications": [
                                "Componentes sazonais corretamente isolados e plotados.",
                                "Resíduos aleatórios e estacionários (p-value ADF <0.05).",
                                "Reconstrução da série original com RMSE <5%.",
                                "Insights sazonais mapeados a eventos de marketing.",
                                "Previsões sazonais geradas com intervalos de confiança.",
                                "Relatório com gráficos e recomendações acionáveis."
                              ],
                              "assessmentCriteria": [
                                "Precisão na preparação de dados (sem erros de formatação).",
                                "Correta escolha e aplicação do método de decomposição.",
                                "Interpretação contextualizada com métricas quantitativas.",
                                "Validação robusta com testes estatísticos.",
                                "Clareza em visualizações e comunicação de insights.",
                                "Criatividade em aplicações de marketing."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Testes de estacionariedade e decomposição.",
                                "Programação: Manipulação de dados em Python/R.",
                                "Marketing: Análise de comportamento do consumidor.",
                                "Negócios: Planejamento de estoque e campanhas.",
                                "Visualização de Dados: Criação de dashboards interativos."
                              ],
                              "realWorldApplication": "Em e-commerce, detectar sazonalidade em tráfego web permite otimizar anúncios pagos (ex: Google Ads) durante picos como Dia das Mães, reduzindo CAC e aumentando ROI em 20-30%."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.2.2.2",
                            "name": "Testar e diferenciar sazonalidade de ciclos",
                            "description": "Aplicar testes de sazonalidade (como OCSB) e gráficos de períodoograma para distinguir padrões sazonais fixos de ciclos irregulares em dados de marketing.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e Visualizar Dados de Série Temporal",
                                  "subSteps": [
                                    "Coletar dataset de marketing, como vendas mensais de produtos sazonais (ex: roupas de inverno).",
                                    "Inspecionar e limpar dados: tratar missing values, outliers e transformar para estacionariedade (diferenciação se necessário).",
                                    "Plotar série temporal, decomposição STL e gráficos ACF/PACF para identificar padrões iniciais.",
                                    "Verificar suposições de testes: normalidade residuals e ausência de breaks estruturais.",
                                    "Documentar transformações aplicadas em um relatório inicial."
                                  ],
                                  "verification": "Gráficos ACF mostram picos significativos em lags sazonais (ex: lag 12 para mensal) e dados estão estacionários (teste ADF p<0.05).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python (pandas, statsmodels, matplotlib) ou R (forecast, tseries)",
                                    "Dataset exemplo: vendas mensais de varejo (Kaggle)"
                                  ],
                                  "tips": "Comece sempre com visualizações para ganhar intuição antes de testes formais.",
                                  "learningObjective": "Preparar dados adequadamente para testes de sazonalidade, garantindo validade estatística.",
                                  "commonMistakes": [
                                    "Não testar estacionariedade primeiro",
                                    "Ignorar outliers que mascaram padrões",
                                    "Usar dados não-transformados em testes paramétricos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar Teste Estatístico de Sazonalidade (OCSB)",
                                  "subSteps": [
                                    "Implementar teste OCSB (Osborn-Chui-Smith-Birchenhall) usando pacote urca em R ou statsmodels em Python.",
                                    "Especificar lags sazonais esperados (ex: s=12 para dados mensais) e modelo H0 (sem sazonalidade).",
                                    "Executar teste e extrair estatística F e p-value.",
                                    "Interpretar: rejeitar H0 se p<0.05, indicando presença de sazonalidade.",
                                    "Realizar diagnósticos: checar residuals para autocorrelação (Ljung-Box)."
                                  ],
                                  "verification": "Teste OCSB retorna p-value <0.05 confirmando sazonalidade, com residuals brancos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "R (pacote urca) ou Python (statsmodels.tsa.stattools)",
                                    "Código template de teste OCSB"
                                  ],
                                  "tips": "Use lags conservadores para evitar sobre-rejeição; compare com teste Canova-Hansen se possível.",
                                  "learningObjective": "Executar e interpretar teste paramétrico para detectar sazonalidade determinística.",
                                  "commonMistakes": [
                                    "Especificar lags errados (ex: s=4 para mensal)",
                                    "Ignorar não-estacionariedade pré-teste",
                                    "Confundir sazonalidade com tendência"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir e Analisar Períodoograma",
                                  "subSteps": [
                                    "Calcular períodoograma via FFT usando spectrum() em R ou scipy.signal.periodogram em Python.",
                                    "Identificar picos espectrais dominantes e suas frequências (ex: pico em 1/12 para anual).",
                                    "Testar significância de picos com teste de Bartlett ou simulação de white noise.",
                                    "Plotar log-períodoograma para melhor visualização de componentes.",
                                    "Comparar espectro com bandas de confiança para ruído."
                                  ],
                                  "verification": "Períodoograma mostra picos significativos em frequências sazonais fixas (ex: 0.083 Hz para mensal).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python (scipy, matplotlib) ou R (spectrum)",
                                    "Notebook Jupyter com dados preparados"
                                  ],
                                  "tips": "Aplique janela (ex: Daniell) para reduzir leakage espectral em séries curtas.",
                                  "learningObjective": "Usar análise espectral para visualizar periodicidades na frequência.",
                                  "commonMistakes": [
                                    "Não log-transformar períodoograma",
                                    "Interpretar picos fracos como sazonais",
                                    "Usar séries não-estacionárias"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar Sazonalidade de Ciclos Irregulares",
                                  "subSteps": [
                                    "Comparar resultados OCSB e períodoograma: sazonalidade = picos fixos em frequências conhecidas.",
                                    "Identificar ciclos: picos irregulares ou em frequências baixas (ex: 2-8 anos) via filtro HP ou espectro.",
                                    "Modelar com SARIMA se sazonal vs ARIMA cíclico e comparar AIC/BIC.",
                                    "Simular cenários: adicionar ciclos sintéticos e retestar diferenciação.",
                                    "Concluir com relatório: 'Sazonal fixo vs ciclo irregular' baseado em evidências."
                                  ],
                                  "verification": "Relatório diferencia corretamente (ex: sazonal anual vs ciclo bienal econômico) com evidências de ambos os métodos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python/R com modelos SARIMA",
                                    "Dados simulados de ciclos (ex: via simular AR(2))"
                                  ],
                                  "tips": "Ciclos são não-periódicos; foque em largura de picos espectrais largos para ciclos.",
                                  "learningObjective": "Distinguir padrões fixos sazonais de variações cíclicas irregulares em marketing.",
                                  "commonMistakes": [
                                    "Confundir ciclos curtos com sazonalidade",
                                    "Não validar com modelagem out-of-sample",
                                    "Ignorar contexto de marketing"
                                  ]
                                }
                              ],
                              "practicalExample": "Em dados de vendas mensais de sorvetes (pico verão), OCSB rejeita H0 (p=0.01), períodoograma mostra pico fixo em freq=1/12; adicionar ciclo econômico simulado (AR(2)) cria picos largos em baixas freqs, diferenciados como irregular.",
                              "finalVerifications": [
                                "Implementa OCSB e obtém p-value correto em dataset teste.",
                                "Períodoograma identifica picos sazonais vs cíclicos.",
                                "Diferencia corretamente em simulação mista (sazonal + ciclo).",
                                "Relatório resume evidências de ambos métodos.",
                                "Valida com previsão SARIMA out-of-sample.",
                                "Explica impacto em decisões de marketing."
                              ],
                              "assessmentCriteria": [
                                "Precisão na implementação de OCSB (p-value matches expected).",
                                "Interpretação correta de períodoograma (picos significativos).",
                                "Diferenciação lógica sazonal vs ciclos com evidências múltiplas.",
                                "Qualidade do relatório: claro, com gráficos e conclusões acionáveis.",
                                "Tratamento de dados: estacionariedade e limpeza demonstrados.",
                                "Eficiência: tempo dentro do estimado e código limpo."
                              ],
                              "crossCurricularConnections": [
                                "Marketing: Otimização de campanhas sazonais vs estratégias anticíclicas.",
                                "Economia: Distinção de ciclos econômicos em séries de vendas.",
                                "Programação: Análise de dados com Python/R e visualização.",
                                "Matemática: Análise de Fourier e testes de hipóteses.",
                                "Negócios: Previsão de demanda e gestão de estoque."
                              ],
                              "realWorldApplication": "Em varejo online, detectar sazonalidade em vendas de Natal permite precificar dinamicamente e estocar adequadamente, enquanto ciclos irregulares (ex: recessão) guiam ajustes em promoções long-term, aumentando ROI em 15-20%."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.2.2.3",
                            "name": "Modelar e prever séries sazonais",
                            "description": "Implementar modelos SARIMA ou Prophet para capturar sazonalidade múltipla e gerar previsões ajustadas para planejamento de promoções.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e Explorar Dados de Séries Temporais",
                                  "subSteps": [
                                    "Carregar dados de vendas históricas com timestamps (ex: vendas diárias de produtos).",
                                    "Verificar e tratar valores ausentes, outliers e estacionariedade usando testes como ADF.",
                                    "Decompor a série para identificar tendências, sazonalidade (semanal, mensal, anual) e ruído.",
                                    "Visualizar gráficos ACF/PACF e decomposição sazonal.",
                                    "Transformar dados se necessário (log, diferenciação) para estabilizar variância."
                                  ],
                                  "verification": "Gráficos de decomposição mostram padrões sazonais claros e testes confirmam ausência de missing values.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": "Python (pandas, statsmodels, matplotlib), dataset de vendas CSV.",
                                  "tips": "Use resample() para agregações temporais adequadas ao ciclo sazonal.",
                                  "learningObjective": "Entender estrutura de séries temporais com múltipla sazonalidade.",
                                  "commonMistakes": "Ignorar feriados ou eventos especiais que afetam sazonalidade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar e Ajustar Modelo SARIMA",
                                  "subSteps": [
                                    "Determinar parâmetros p,d,q,P,D,Q,s via auto_arima ou análise ACF/PACF.",
                                    "Implementar SARIMAX para covariáveis como promoções passadas.",
                                    "Ajustar o modelo aos dados de treino com múltiplos períodos sazonais (ex: s=7 para semanal, s=365 para anual).",
                                    "Verificar resíduos com Ljung-Box para independência.",
                                    "Comparar AIC/BIC para otimização."
                                  ],
                                  "verification": "Modelo ajustado com resíduos brancos (p-value > 0.05 no teste Ljung-Box).",
                                  "estimatedTime": "3-4 horas",
                                  "materials": "Biblioteca statsmodels ou pmdarima em Python.",
                                  "tips": "Comece com auto_arima para sugestões iniciais de parâmetros.",
                                  "learningObjective": "Dominar especificação e ajuste de SARIMA para sazonalidade complexa.",
                                  "commonMistakes": "Sobrediferenciação que remove sazonalidade real."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e Comparar com Prophet",
                                  "subSteps": [
                                    "Instalar e inicializar Prophet com changepoint_prior_scale ajustado.",
                                    "Adicionar regressores para múltipla sazonalidade (add_seasonality para semanal/anual).",
                                    "Treinar modelo e gerar componentes (trend, seasonality, holidays).",
                                    "Cross-validar com cv() e performance_metrics().",
                                    "Comparar métricas (MAE, RMSE) entre SARIMA e Prophet."
                                  ],
                                  "verification": "Previsões in-sample se alinham visualmente com dados reais.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": "Biblioteca prophet (Facebook) em Python.",
                                  "tips": "Use holidays dataframe para capturar efeitos promocionais.",
                                  "learningObjective": "Aplicar Prophet para modelagem intuitiva de sazonalidade aditiva.",
                                  "commonMistakes": "Não ativar múltiplas sazonalidades, levando a underfitting."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Gerar Previsões e Aplicar ao Planejamento",
                                  "subSteps": [
                                    "Gerar previsões de 30-90 dias com intervalos de confiança.",
                                    "Avaliar out-of-sample com holdout set (MAPE < 10%).",
                                    "Interpretar impactos sazonais para otimizar datas de promoções.",
                                    "Simular cenários 'what-if' alterando regressores.",
                                    "Documentar relatório com visualizações e recomendações."
                                  ],
                                  "verification": "Previsões com erro médio abaixo de benchmark e alinhadas a picos sazonais.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Jupyter Notebook para relatórios interativos.",
                                  "tips": "Exporte previsões para Excel para integração com ferramentas de marketing.",
                                  "learningObjective": "Traduzir previsões em decisões de negócios acionáveis.",
                                  "commonMistakes": "Ignorar intervalos de confiança ao planejar estoques."
                                }
                              ],
                              "practicalExample": "Usando dados de vendas diárias de uma rede de varejo (vendas_de_varejo.csv), modele sazonalidade semanal (picos fins de semana) e anual (Black Friday), prevendo vendas para planejar promoções de Natal, ajustando estoque em 15% com base em Prophet.",
                              "finalVerifications": [
                                "Modelo captura >80% da variância sazonal observada.",
                                "Previsões out-of-sample com MAPE <8%.",
                                "Resíduos são estacionários e não autocorrelacionados.",
                                "Intervalos de confiança realistas (largura <20% da previsão média).",
                                "Recomendações de promoções alinhadas a picos previstos.",
                                "Código reproduzível e documentado."
                              ],
                              "assessmentCriteria": [
                                "Precisão das previsões (RMSE/MAPE baixo).",
                                "Correta identificação de múltiplas sazonalidades.",
                                "Validação robusta (cross-validation).",
                                "Interpretação business-oriented.",
                                "Eficiência computacional do modelo.",
                                "Qualidade da visualização e relatório."
                              ],
                              "crossCurricularConnections": [
                                "Marketing: Otimização de campanhas sazonais.",
                                "Programação: Manipulação avançada de dados em Python.",
                                "Estatística: Testes de hipóteses e validação de modelos.",
                                "Negócios: Planejamento estratégico e simulações what-if."
                              ],
                              "realWorldApplication": "Em e-commerce como Amazon, modelos SARIMA/Prophet preveem picos sazonais para alocar orçamentos de promoções, reduzindo overstock em 20% e aumentando receita em períodos como Dia das Mães."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.2.3",
                        "name": "Segmentação de Mercado com Séries Temporais",
                        "description": "Uso de séries temporais para clusterizar clientes ou produtos em segmentos baseados em padrões temporais, auxiliando estratégias de marketing direcionadas.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.2.3.1",
                            "name": "Extrair características temporais para segmentação",
                            "description": "Calcular features como autocorrelação, Fourier coefficients e tendências lineares de séries temporais de comportamento de clientes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparação e Exploração Inicial da Série Temporal",
                                  "subSteps": [
                                    "Carregue o dataset de séries temporais de comportamento de clientes (ex: compras mensais).",
                                    "Converta a coluna de tempo em formato datetime e defina como índice.",
                                    "Realize plotagens básicas (linha, histograma) para visualizar padrões, sazonalidades e missing values.",
                                    "Trate valores ausentes com interpolação linear ou forward fill.",
                                    "Normalize os dados dividindo pelo desvio padrão para padronização inicial."
                                  ],
                                  "verification": "Verifique se o DataFrame tem índice datetime válido e plots mostram padrões claros sem erros de NaN.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Python, bibliotecas: pandas, matplotlib, numpy",
                                  "tips": "Sempre plot antes de calcular features para identificar anomalias visuais.",
                                  "learningObjective": "Entender e preparar dados temporais para extração de features robusta.",
                                  "commonMistakes": [
                                    "Ignorar missing values levando a features distorcidas",
                                    "Não converter índice para datetime causando erros em funções temporais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Cálculo de Features de Autocorrelação",
                                  "subSteps": [
                                    "Calcule a função de autocorrelação (ACF) para lags de 1 a 12 (mensal).",
                                    "Extraia coeficientes significativos (acima de limite de confiança).",
                                    "Selecione top 5 lags com maior autocorrelação absoluta como features.",
                                    "Armazene em um vetor por cliente (ex: acf_lag1, acf_lag12).",
                                    "Teste estacionariedade com teste ADF para validar relevância."
                                  ],
                                  "verification": "Confira se valores de ACF estão entre -1 e 1 e plots mostram decays esperados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python, statsmodels.tsa.stattools (acf), scipy.stats",
                                  "tips": "Use lags relevantes ao domínio (ex: 12 para sazonalidade anual).",
                                  "learningObjective": "Capturar dependências temporais em séries de clientes.",
                                  "commonMistakes": [
                                    "Usar lags excessivos gerando multicolinearidade",
                                    "Ignorar significância estatística"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Extração de Coeficientes de Fourier",
                                  "subSteps": [
                                    "Aplique Transformada Rápida de Fourier (FFT) na série temporal.",
                                    "Extraia amplitudes e fases dos primeiros 10 harmônicos (frequências baixas).",
                                    "Converta para coeficientes reais/imaginários ou seno/cosseno.",
                                    "Filtre harmônicos relevantes baseados em picos de espectro.",
                                    "Adicione como features: fourier_amp1, fourier_phase5, etc."
                                  ],
                                  "verification": "Valide reconstruindo sinal parcial com top coeficientes (similaridade >90%).",
                                  "estimatedTime": "1 hora",
                                  "materials": "Python, numpy.fft, scipy.signal",
                                  "tips": "Pad com zeros para comprimentos potência de 2 otimizando FFT.",
                                  "learningObjective": "Decompor séries em componentes frecuenciais para detectar sazonalidades.",
                                  "commonMistakes": [
                                    "Não filtrar ruído de altas frequências",
                                    "Usar toda FFT gerando features irrelevantes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Cálculo de Tendências Lineares e Compilação",
                                  "subSteps": [
                                    "Ajuste modelo linear (OLS) na série vs tempo para slope e intercept.",
                                    "Calcule R² e p-value do slope como features de tendência.",
                                    "Aplique detrending subtraindo tendência para validar.",
                                    "Compile todas features em DataFrame único por cliente.",
                                    "Normalize features com StandardScaler para segmentação."
                                  ],
                                  "verification": "Features finais em matriz sem NaN, com estatísticas descritivas plausíveis.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python, statsmodels.api (OLS), sklearn.preprocessing",
                                  "tips": "Use janela rolante para tendências locais se série longa.",
                                  "learningObjective": "Quantificar direção e força de mudanças temporais.",
                                  "commonMistakes": [
                                    "Overfitting com polinômios altos",
                                    "Não normalizar escalas díspares"
                                  ]
                                }
                              ],
                              "practicalExample": "Com dados de compras mensais de 500 clientes de uma varejista (janeiro 2020 a dezembro 2023), extraia autocorrelações para detectar repetitividade, coeficientes Fourier para sazonalidade de fim de ano e tendências lineares para crescimento, gerando 20 features para K-means segmentação em 'sazonais', 'crescentes' e 'estáveis'.",
                              "finalVerifications": [
                                "Autocorrelações calculadas com lags corretos e significância.",
                                "Coeficientes Fourier reconstróem sinal com erro <10%.",
                                "Tendências lineares têm R² >0.5 para séries não-estacionárias.",
                                "Matriz de features tem shape esperado (n_clientes x n_features).",
                                "Sem NaN ou inf em features finais.",
                                "Visualizações confirmam captura de padrões temporais."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica das features (erro <1% vs manual).",
                                "Eficiência computacional (tempo <5min para 1000 séries).",
                                "Robustez a dados ruidosos/missing (features estáveis).",
                                "Relevância para segmentação (features discriminam clusters).",
                                "Documentação clara do código e outputs.",
                                "Uso correto de testes estatísticos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise Harmônica e Transformadas.",
                                "Programação: Manipulação Avançada de Dados com Pandas/NumPy.",
                                "Machine Learning: Feature Engineering para Clustering.",
                                "Marketing: Análise de Comportamento do Consumidor.",
                                "Estatística: Testes de Estacionariedade e Regressão."
                              ],
                              "realWorldApplication": "Em marketing digital, segmentar clientes por padrões temporais (ex: compradores sazonais de Natal vs contínuos) para campanhas personalizadas, otimizando retenção e ROI em até 30% via ofertas timed."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.2.3.2",
                            "name": "Aplicar clustering em séries temporais",
                            "description": "Utilizar algoritmos como K-means em espaço de features ou DTW para agrupar séries de compras ou visitas, determinando número ótimo de clusters via silhueta.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Pré-processamento das Séries Temporais",
                                  "subSteps": [
                                    "Coletar e carregar dados de séries temporais, como histórico de compras ou visitas por cliente",
                                    "Identificar e tratar valores ausentes usando interpolação linear ou forward-fill",
                                    "Normalizar as séries com z-score ou min-max scaling para uniformizar escalas",
                                    "Verificar e alinhar comprimentos das séries, truncando ou padding se necessário",
                                    "Explorar visualmente os dados com plots para detectar anomalias"
                                  ],
                                  "verification": "Executar df.isnull().sum() == 0 e plotar séries normalizadas sem discrepâncias visuais",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python com pandas, numpy, matplotlib",
                                    "Dataset de séries temporais de exemplo (ex: Kaggle retail sales)"
                                  ],
                                  "tips": "Salve uma cópia dos dados originais antes de qualquer transformação para rollback",
                                  "learningObjective": "Preparar séries temporais limpas, normalizadas e prontas para extração de features",
                                  "commonMistakes": [
                                    "Esquecer de normalizar, causando viés em features de magnitude diferente",
                                    "Ignorar sazonalidade inicial sem decomposição"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Extração de Features ou Definição de Métrica de Distância",
                                  "subSteps": [
                                    "Extrair features estatísticas: média, variância, skewness, autocorrelações em lags 1-12",
                                    "Implementar DTW (Dynamic Time Warping) como métrica de distância para séries não alinhadas",
                                    "Escolher abordagem: feature-based para K-means ou distance matrix para hierarchical/DBSCAN",
                                    "Construir matriz de features ou distâncias com bibliotecas como tsfresh ou tslearn",
                                    "Validar features com correlações e PCA para redução dimensional se >20 features"
                                  ],
                                  "verification": "Matriz de features/distâncias gerada com shape correto e sem valores infinitos",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python: tsfresh, tslearn, scikit-learn",
                                    "Jupyter Notebook para experimentação"
                                  ],
                                  "tips": "Use DTW para séries com padrões elásticos; features para dados curtos",
                                  "learningObjective": "Representar séries temporais em formato adequado para algoritmos de clustering padrão",
                                  "commonMistakes": [
                                    "Extrair poucas features, perdendo informação temporal",
                                    "Usar distância euclidiana sem DTW para séries desalinhadas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinação do Número Ótimo de Clusters",
                                  "subSteps": [
                                    "Implementar Elbow Method plotando inertia vs k (2 a 10 clusters)",
                                    "Calcular Silhouette Score para cada k usando make_silhouette_score",
                                    "Visualizar Silhouette plot para o k candidato ótimo",
                                    "Comparar múltiplos k e selecionar baseado em score >0.5 e interpretabilidade",
                                    "Testar estabilidade com múltiplas seeds e bootstrap"
                                  ],
                                  "verification": "Gráficos de Elbow e Silhouette gerados, com k ótimo justificado (ex: k=4, score=0.62)",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "scikit-learn: silhouette_score, KMeans",
                                    "matplotlib/seaborn para plots"
                                  ],
                                  "tips": "Priorize Silhouette sobre Elbow para séries temporais complexas",
                                  "learningObjective": "Selecionar k ótimo de forma quantitativa e visual para clustering robusto",
                                  "commonMistakes": [
                                    "Escolher k subjetivo sem métricas",
                                    "Ignorar overfitting em k muito alto"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicação do Clustering e Análise dos Resultados",
                                  "subSteps": [
                                    "Aplicar K-means ou AgglomerativeClustering com k ótimo e métrica DTW",
                                    "Atribuir labels de cluster a cada série e calcular centroids",
                                    "Visualizar clusters com line plots coloridos por label e PCA/TSNE em 2D",
                                    "Interpretar clusters: perfil médio, tamanho e relevância para marketing",
                                    "Avaliar com métricas adicionais como Davies-Bouldin e validar com hold-out"
                                  ],
                                  "verification": "Labels atribuídos corretamente, clusters visualmente separados e interpretados",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "scikit-learn, tslearn",
                                    "Dataset real de marketing (ex: UCI online retail)"
                                  ],
                                  "tips": "Nomeie clusters semanticamente (ex: 'Compradores sazonais') para aplicação prática",
                                  "learningObjective": "Executar clustering completo e extrair insights acionáveis de séries temporais",
                                  "commonMistakes": [
                                    "Não visualizar clusters, perdendo insights",
                                    "Interpretar sem contexto de domínio"
                                  ]
                                }
                              ],
                              "practicalExample": "Em dados de um e-commerce, use séries mensais de compras de 1000 clientes. Extraia features como tendência e sazonalidade, aplique K-means com k=3 via Silhouette (score=0.58), identificando clusters: 'Fieis' (compras estáveis), 'Impulsivos' (picos irregulares) e 'Sazonais' (Natal/BlackFriday).",
                              "finalVerifications": [
                                "Silhouette score médio > 0.5 para k selecionado",
                                "Clusters estáveis em 3 execuções com seeds diferentes (ARI > 0.8)",
                                "Visualizações mostram separação clara das séries por cluster",
                                "Cada cluster tem perfil descritivo coerente com dados de marketing",
                                "Matriz de distâncias ou features sem outliers extremos",
                                "Insights gerados aplicáveis à segmentação de clientes"
                              ],
                              "assessmentCriteria": [
                                "Correta preparação e normalização das séries (sem erros de shape/NaN)",
                                "Implementação precisa de features/DTW e Silhouette para k ótimo",
                                "Código reproduzível com comentários e plots profissionais",
                                "Interpretação de clusters com evidências quantitativas e qualitativas",
                                "Eficiência computacional (tempo <5min para 1000 séries)",
                                "Aplicação correta de bibliotecas sem warnings"
                              ],
                              "crossCurricularConnections": [
                                "Machine Learning: Clustering não supervisionado e validação interna",
                                "Estatística: Métricas de similaridade temporal e análise multivariada",
                                "Marketing: Segmentação comportamental e CRM",
                                "Programação: Manipulação de dados temporais em Python/R",
                                "Visualização de Dados: Plots de séries e redução dimensional"
                              ],
                              "realWorldApplication": "Em marketing digital, segmentar clientes por padrões temporais de visitas/compras permite campanhas personalizadas, como promoções sazonais para 'compradores de pico', otimizando retenção e ROI em e-commerces como Amazon ou Magazine Luiza."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.2.3.3",
                            "name": "Interpretar e validar segmentos de mercado",
                            "description": "Analisar perfis de clusters via visualizações e métricas de validação, relacionando padrões temporais a estratégias de segmentação e targeting.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e Visualizar Perfis de Clusters",
                                  "subSteps": [
                                    "Carregue o dataset de séries temporais segmentado por clusters (ex: dados de vendas por cliente ao longo do tempo).",
                                    "Selecione visualizações adequadas: scatter plots para similaridade temporal, heatmaps para padrões sazonais e line plots para séries por cluster.",
                                    "Gere as visualizações usando bibliotecas como Matplotlib ou Seaborn, destacando diferenças entre clusters.",
                                    "Anotar visualmente separações claras e sobreposições nos perfis.",
                                    "Salve as visualizações em um relatório inicial."
                                  ],
                                  "verification": "Visualizações geradas mostram distinções claras entre pelo menos 3 clusters, sem erros de plotting.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Python/Jupyter Notebook",
                                    "Bibliotecas: Pandas, Matplotlib, Seaborn",
                                    "Dataset de séries temporais de exemplo (ex: vendas mensais por cliente)"
                                  ],
                                  "tips": "Use cores contrastantes para clusters e adicione legendas descritivas para facilitar a interpretação.",
                                  "learningObjective": "Dominar a criação de visualizações que revelam perfis distintos de clusters em séries temporais.",
                                  "commonMistakes": [
                                    "Escalar incorretamente as séries temporais levando a distorções",
                                    "Ignorar normalização de dados antes da visualização",
                                    "Sobrecarregar gráficos com muitos clusters"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular e Interpretar Métricas de Validação",
                                  "subSteps": [
                                    "Calcule métricas internas como Silhouette Score, Davies-Bouldin Index e Calinski-Harabasz adaptadas para séries temporais (ex: DTW distance).",
                                    "Use funções de scikit-learn ou tslearn para computar scores em distâncias temporais.",
                                    "Interprete os resultados: Silhouette > 0.5 indica bons clusters; DB < 1 é ideal.",
                                    "Compare métricas com baselines (ex: clustering aleatório).",
                                    "Registre scores em uma tabela para análise."
                                  ],
                                  "verification": "Métricas calculadas corretamente com interpretação escrita (ex: 'Silhouette=0.65 indica separação forte').",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python",
                                    "Bibliotecas: scikit-learn, tslearn",
                                    "Dataset clusterizado"
                                  ],
                                  "tips": "Priorize distâncias como Dynamic Time Warping (DTW) para séries temporais em vez de Euclidean padrão.",
                                  "learningObjective": "Aplicar e interpretar métricas quantitativas para validar qualidade de clusters temporais.",
                                  "commonMistakes": [
                                    "Usar métricas euclidianas sem adaptação temporal",
                                    "Interpretar scores isoladamente sem contexto",
                                    "Esquecer de normalizar dados antes do cálculo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e Analisar Padrões Temporais nos Clusters",
                                  "subSteps": [
                                    "Examine séries temporais por cluster para detectar tendências, sazonalidades e anomalias (ex: picos em feriados).",
                                    "Aplique decomposição STL ou ACF para quantificar padrões.",
                                    "Descreva perfis: 'Cluster A: compras sazonais no verão'.",
                                    "Compare padrões cross-cluster para validação de heterogeneidade.",
                                    "Documente insights em bullet points com referências às visualizações."
                                  ],
                                  "verification": "Relatório com 3+ padrões temporais identificados por cluster, suportados por evidências visuais/estatísticas.",
                                  "estimatedTime": "1.5-2 horas",
                                  "materials": [
                                    "Python",
                                    "Bibliotecas: statsmodels (STL), Pandas",
                                    "Visualizações do Step 1"
                                  ],
                                  "tips": "Foque em padrões business-relevant como sazonalidade anual para marketing.",
                                  "learningObjective": "Extrair insights acionáveis de padrões temporais em clusters de mercado.",
                                  "commonMistakes": [
                                    "Confundir correlação com causalidade",
                                    "Ignorar outliers que revelam sub-padrões",
                                    "Generalizar padrões sem suporte estatístico"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar Segmentos a Estratégias de Segmentação e Targeting",
                                  "subSteps": [
                                    "Mapeie clusters a personas de mercado (ex: 'Cluster B: compradores impulsivos de fim de ano').",
                                    "Proponha estratégias: targeting via email para padrões sazonais detectados.",
                                    "Avalie viabilidade com métricas como tamanho do cluster e valor médio.",
                                    "Simule impacto: 'Campanha para Cluster C aumenta retenção em 20%'.",
                                    "Crie um plano de ação com KPIs."
                                  ],
                                  "verification": "Plano estratégico escrito relacionando 80% dos clusters a ações específicas de marketing.",
                                  "estimatedTime": "1-1.5 horas",
                                  "materials": [
                                    "Relatórios dos steps anteriores",
                                    "Ferramentas: Excel/Google Sheets para simulações"
                                  ],
                                  "tips": "Priorize clusters grandes e de alto valor para estratégias iniciais.",
                                  "learningObjective": "Conectar análises de clusters temporais a decisões estratégicas de marketing.",
                                  "commonMistakes": [
                                    "Propor estratégias genéricas sem base nos padrões temporais",
                                    "Ignorar restrições éticas de targeting",
                                    "Subestimar tamanho mínimo de cluster para viabilidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um dataset de séries temporais de compras de uma e-commerce (vendas diárias por 1000 clientes), clusterize em 4 grupos usando K-means com DTW. Visualize heatmaps mostrando Cluster 1 com picos natalinos (Silhouette=0.62). Interprete como 'festivos' e proponha targeting com promoções de Black Friday, prevendo +15% em vendas.",
                              "finalVerifications": [
                                "Gera visualizações claras distinguindo clusters temporais.",
                                "Calcula e interpreta corretamente métricas de validação (>3 métricas).",
                                "Identifica pelo menos 2 padrões temporais por cluster.",
                                "Relaciona segmentos a 3+ estratégias de targeting específicas.",
                                "Documenta relatório coeso com evidências quantitativas.",
                                "Valida clusters com scores acima de thresholds aceitáveis."
                              ],
                              "assessmentCriteria": [
                                "Precisão das visualizações e métricas (90%+ correção).",
                                "Profundidade da interpretação de padrões temporais (cobertura de tendências/sazonalidade).",
                                "Relevância e viabilidade das estratégias propostas.",
                                "Qualidade da documentação (clareza, estrutura, evidências).",
                                "Integração de validação quantitativa e qualitativa.",
                                "Criatividade em aplicações de targeting."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Clustering e validação de séries temporais.",
                                "Marketing: Segmentação comportamental e personas.",
                                "Visualização de Dados: Heatmaps e séries temporais.",
                                "Machine Learning: Distâncias temporais como DTW.",
                                "Análise de Negócios: KPIs e simulação de ROI."
                              ],
                              "realWorldApplication": "Empresas como Amazon usam isso para segmentar clientes por padrões de compra sazonais, otimizando campanhas personalizadas (ex: recomendações de Natal para 'compradores festivos'), aumentando conversões em 20-30% e reduzindo churn."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.8.3",
                    "name": "Aplicações em Operações",
                    "description": "Previsão de demanda, controle de estoques e planejamento de produção utilizando métodos de séries temporais.",
                    "individualConcepts": [
                      {
                        "id": "10.1.8.3.1",
                        "name": "Previsão de Demanda",
                        "description": "Aplicação de métodos de séries temporais para prever a demanda futura de produtos ou serviços, considerando padrões estacionários, não estacionários e sazonais.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.3.1.1",
                            "name": "Análise exploratória de dados de demanda",
                            "description": "Realizar análise exploratória em séries temporais de demanda, identificando tendências, sazonalidades e componentes estacionários ou não estacionários utilizando gráficos ACF, PACF e testes de estacionariedade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparação e Carregamento dos Dados de Demanda",
                                  "subSteps": [
                                    "Obtenha um dataset de séries temporais de demanda (ex: vendas mensais de um produto).",
                                    "Carregue os dados em um ambiente Python usando pandas.",
                                    "Converta a coluna de data para datetime e defina como índice.",
                                    "Trate valores ausentes (interpolação ou remoção).",
                                    "Realize uma inspeção inicial com describe() e info()."
                                  ],
                                  "verification": "Dataset carregado corretamente com índice datetime e sem valores ausentes, confirmado por plot inicial e summary statistics.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com pandas, matplotlib",
                                    "Dataset exemplo de demanda (ex: AirPassengers ou vendas fictícias CSV)"
                                  ],
                                  "tips": "Sempre verifique o formato de data antes de converter para evitar erros de parsing.",
                                  "learningObjective": "Preparar dados de séries temporais para análise exploratória de forma limpa e estruturada.",
                                  "commonMistakes": [
                                    "Ignorar valores ausentes levando a plots distorcidos",
                                    "Não definir índice datetime resultando em eixo X incorreto"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Visualização Inicial da Série Temporal",
                                  "subSteps": [
                                    "Plote a série temporal completa com matplotlib ou seaborn.",
                                    "Decomponha a série em tendência, sazonalidade e resíduo usando seasonal_decompose do statsmodels.",
                                    "Gere plots de autocorrelação parcial inicial se necessário.",
                                    "Identifique visualmente padrões como aumento/decaimento ou ciclos.",
                                    "Salve os gráficos para relatório."
                                  ],
                                  "verification": "Gráficos mostram claramente tendência, sazonalidade e resíduo; decomposition plot gerado sem erros.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "statsmodels.tsa.seasonal, matplotlib",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Use período sazonal correto (ex: 12 para dados mensais) para decomposition precisa.",
                                  "learningObjective": "Visualizar componentes básicos de uma série temporal para detecção inicial de padrões.",
                                  "commonMistakes": [
                                    "Período sazonal errado causando decomposição incorreta",
                                    "Escalas de eixo inadequadas ocultando padrões sutis"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Testes Estatísticos de Estacionariedade",
                                  "subSteps": [
                                    "Aplique o teste Augmented Dickey-Fuller (ADF) usando adfuller do statsmodels.",
                                    "Realize o teste KPSS para confirmar não-estacionariedade.",
                                    "Interprete p-values: ADF p<0.05 indica estacionariedade; KPSS p>0.05 indica estacionariedade.",
                                    "Se não estacionária, teste diferenciação de primeira ordem e re-teste.",
                                    "Registre estatísticas e conclusões em um log."
                                  ],
                                  "verification": "Relatório com p-values e conclusões claras sobre estacionariedade da série original e diferenciada.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "statsmodels.tsa.stattools",
                                    "Documentação dos testes ADF/KPSS"
                                  ],
                                  "tips": "Combine ADF e KPSS para robustez, pois um pode ser inconclusivo.",
                                  "learningObjective": "Aplicar e interpretar testes formais para determinar estacionariedade em séries temporais.",
                                  "commonMistakes": [
                                    "Interpretar p-value incorretamente (ex: rejeitar H0 no KPSS como estacionária)",
                                    "Não diferenciar após falha inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Geração e Análise de Gráficos ACF e PACF",
                                  "subSteps": [
                                    "Gere gráfico ACF (Autocorrelation Function) com lags até 40 usando plot_acf.",
                                    "Gere gráfico PACF (Partial Autocorrelation Function) da mesma forma.",
                                    "Analise decaimento: lento em ACF indica não-estacionariedade; cortes significativos sugerem ordem AR/MA.",
                                    "Compare com decomposição anterior para validar sazonalidade.",
                                    "Anote lags significativos (ex: barra fora de bandas de confiança)."
                                  ],
                                  "verification": "Gráficos ACF/PACF gerados com lags apropriados e anotações de padrões identificados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "statsmodels.graphics.tsaplots",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Ajuste lags baseado no tamanho da série para evitar overfitting visual.",
                                  "learningObjective": "Usar ACF e PACF para identificar estruturas autorregressivas e de média móvel.",
                                  "commonMistakes": [
                                    "Ignorar bandas de confiança levando a falsos positivos",
                                    "Não considerar sazonalidade em ACF sazonal"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretação Integrada e Relatório Final",
                                  "subSteps": [
                                    "Sintetize achados: tendência (crescente/decrescente), sazonalidade (período), estacionariedade.",
                                    "Proponha transformações se necessário (log, diferenciação).",
                                    "Crie um dashboard com todos os gráficos usando plotly ou subplots.",
                                    "Escreva conclusões acionáveis para previsão de demanda.",
                                    "Valide com sub-série ou holdout."
                                  ],
                                  "verification": "Relatório consolidado com síntese correta dos componentes identificados e recomendações.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "plotly para dashboard interativo",
                                    "Template de relatório Markdown"
                                  ],
                                  "tips": "Use holdout para verificar se padrões persistem, simulando previsão real.",
                                  "learningObjective": "Integrar todas as análises em insights acionáveis para previsão de demanda.",
                                  "commonMistakes": [
                                    "Sobre-generalizar padrões sem validação",
                                    "Ignorar contexto de demanda (ex: eventos externos)"
                                  ]
                                }
                              ],
                              "practicalExample": "Analise dados mensais de demanda de passagens aéreas (dataset AirPassengers). Identifique tendência crescente, sazonalidade anual e não-estacionariedade via ADF (p>0.05), com ACF mostrando decaimento lento e picos sazonais a lags 12,24.",
                              "finalVerifications": [
                                "Série plotada e decomposta corretamente mostrando tendência e sazonalidade.",
                                "Testes ADF/KPSS executados com interpretações precisas de p-values.",
                                "Gráficos ACF/PACF gerados com lags significativos anotados.",
                                "Conclusões integradas identificam todos os componentes (tendência, sazonalidade, estacionariedade).",
                                "Recomendações para modelagem futura (ex: diferenciação ou SARIMA).",
                                "Dashboard ou relatório visual compartilhável."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção de tendências e sazonalidades (80%+ acurácia visual/estatística).",
                                "Correta aplicação e interpretação de testes de estacionariedade (p-values reportados corretamente).",
                                "Qualidade dos gráficos ACF/PACF (lags adequados, anotações claras).",
                                "Profundidade da interpretação integrada e relevância para previsão de demanda.",
                                "Clareza e completude do relatório final.",
                                "Eficiência no tempo e uso de recursos apropriados."
                              ],
                              "crossCurricularConnections": [
                                "Programação em Python/R para manipulação de dados (Data Science).",
                                "Gestão de Operações e Supply Chain para aplicações em previsão de demanda.",
                                "Estatística Inferencial para testes de hipóteses.",
                                "Visualização de Dados para comunicação de insights.",
                                "Machine Learning para transição a modelos ARIMA/SARIMA."
                              ],
                              "realWorldApplication": "Em empresas de varejo ou manufatura, essa análise permite otimizar estoques prevendo picos de demanda sazonal (ex: Natal), reduzindo custos de armazenamento em 20-30% e evitando rupturas de estoque."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.8.3.1.2",
                            "name": "Seleção e aplicação de modelos de previsão",
                            "description": "Selecionar e aplicar modelos apropriados como ARIMA para séries não estacionárias, Holt-Winters para sazonais ou métodos automáticos para prever demanda futura em operações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar Características da Série Temporal",
                                  "subSteps": [
                                    "Coletar dados históricos de demanda com timestamps precisos",
                                    "Visualizar a série temporal usando gráficos de linha e decomposição",
                                    "Analisar presença de tendência, sazonalidade e ruído",
                                    "Identificar se a série é estacionária ou não através de inspeção visual",
                                    "Documentar padrões observados, como ciclos sazonais ou não-estacionariedade"
                                  ],
                                  "verification": "Relatório inicial com gráficos e descrição das características gerado",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Dados históricos em CSV",
                                    "Python com pandas, matplotlib e statsmodels",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Comece sempre com visualizações para ganhar intuição rápida sobre os dados",
                                  "learningObjective": "Reconhecer componentes chave (tendência, sazonalidade, estacionariedade) em séries temporais de demanda",
                                  "commonMistakes": [
                                    "Ignorar outliers que distorcem a análise",
                                    "Não considerar frequência dos dados (diária, mensal)",
                                    "Assumir estacionariedade sem verificação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Testar Estacionariedade e Preparar Dados",
                                  "subSteps": [
                                    "Aplicar teste de Dickey-Fuller Aumentado (ADF) para estacionariedade",
                                    "Realizar transformações como diferenciação ou logaritmo se necessário",
                                    "Decompor a série para separar componentes sazonais",
                                    "Verificar autocorrelação com gráficos ACF/PACF",
                                    "Limpar dados removendo valores ausentes ou outliers"
                                  ],
                                  "verification": "Resultados de testes ADF com p-valor < 0.05 e gráficos ACF/PACF produzidos",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Bibliotecas statsmodels e scipy no Python",
                                    "Dados preparados do Step 1"
                                  ],
                                  "tips": "Use diferenciação de ordem 1 ou 2 para não-estacionariedade; evite overdifferencing",
                                  "learningObjective": "Dominar testes estatísticos para determinar adequação de modelos como ARIMA",
                                  "commonMistakes": [
                                    "Não transformar dados adequadamente levando a resíduos não estacionários",
                                    "Ignorar sazonalidade no teste ADF",
                                    "Overfitting transformações sem validação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Selecionar e Ajustar o Modelo Apropriado",
                                  "subSteps": [
                                    "Escolher ARIMA para séries não estacionárias baseando-se em ACF/PACF",
                                    "Selecionar Holt-Winters para séries com tendência e sazonalidade clara",
                                    "Usar métodos automáticos como auto.arima() para otimização rápida",
                                    "Ajustar hiperparâmetros (p,d,q para ARIMA; alpha, beta, gamma para Holt-Winters)",
                                    "Treinar modelo em conjunto de treino e gerar previsões iniciais"
                                  ],
                                  "verification": "Modelo ajustado com parâmetros otimizados e AIC/BIC calculados",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Biblioteca pmdarima ou statsmodels para auto.arima",
                                    "Dados preparados"
                                  ],
                                  "tips": "Compare múltiplos modelos usando critérios como AIC para seleção final",
                                  "learningObjective": "Justificar seleção de modelos específicos com base em características da série",
                                  "commonMistakes": [
                                    "Escolher ARIMA sem testar estacionariedade",
                                    "Ignorar sazonalidade optando por modelo não sazonal",
                                    "Não validar hyperparameters com cross-validation temporal"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar, Prever e Validar o Modelo",
                                  "subSteps": [
                                    "Gerar previsões para horizonte futuro (ex: 12 meses)",
                                    "Calcular métricas de erro como MAE, RMSE e MAPE no conjunto de teste",
                                    "Visualizar previsões vs. valores reais",
                                    "Ajustar modelo iterativamente se erros forem altos",
                                    "Documentar aplicação em contexto de operações (ex: impacto em estoque)"
                                  ],
                                  "verification": "Relatório final com previsões, métricas de erro e gráficos de validação",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Conjunto de teste separado",
                                    "Bibliotecas scikit-learn para métricas"
                                  ],
                                  "tips": "Use validação cruzada temporal para evitar leakage de dados futuros",
                                  "learningObjective": "Avaliar performance do modelo e iterar para melhorias",
                                  "commonMistakes": [
                                    "Treinar em todo dataset sem split treino/teste",
                                    "Ignorar intervalo de confiança nas previsões",
                                    "Não contextualizar erros em termos de negócio"
                                  ]
                                }
                              ],
                              "practicalExample": "Prever demanda mensal de vendas de sorvete em uma rede de supermercados, usando Holt-Winters para capturar sazonalidade de verão e ARIMA para tendência de crescimento anual, otimizando pedidos de fornecedores.",
                              "finalVerifications": [
                                "Modelo selecionado justificado com testes de estacionariedade e decomposição",
                                "Previsões geradas com métricas de erro (MAPE < 15%) no conjunto de teste",
                                "Gráficos de previsão vs. real mostram bom ajuste",
                                "Documentação inclui parâmetros do modelo e racional de escolha",
                                "Aplicação simulada em cenário de operações com impacto quantificado",
                                "Intervalos de confiança calculados para previsões"
                              ],
                              "assessmentCriteria": [
                                "Precisão das previsões medida por MAPE abaixo de 10-15%",
                                "Justificativa correta da seleção do modelo baseada em características da série",
                                "Implementação correta de testes estatísticos (ADF, ACF/PACF)",
                                "Uso adequado de validação temporal sem data leakage",
                                "Relatório claro com visualizações e interpretações de negócio",
                                "Capacidade de iterar e melhorar o modelo com base em métricas"
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Testes de hipóteses e análise de resíduos",
                                "Programação: Implementação em Python/R com statsmodels e pmdarima",
                                "Gestão de Operações: Otimização de estoque e supply chain",
                                "Machine Learning: Modelos de forecasting automatizados como Prophet",
                                "Negócios: Decisões baseadas em previsões para redução de custos"
                              ],
                              "realWorldApplication": "Em indústrias de manufatura e varejo, como previsão de demanda de produtos perecíveis para minimizar desperdícios e otimizar inventário, reduzindo custos em até 20% em cadeias de suprimentos como Walmart ou Amazon."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.8.3.1.3",
                            "name": "Avaliação de precisão das previsões",
                            "description": "Calcular métricas de erro como MAE, RMSE e MAPE para validar previsões de demanda e ajustar modelos com base em resíduos e diagnósticos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparação dos dados para avaliação de previsões",
                                  "subSteps": [
                                    "Coletar dados históricos de demanda real e previsões geradas pelo modelo",
                                    "Alinhar as séries temporais por datas ou índices",
                                    "Tratar valores ausentes, outliers e inconsistências",
                                    "Dividir os dados em conjuntos de treino e teste, se aplicável",
                                    "Visualizar as séries real vs. prevista com gráficos"
                                  ],
                                  "verification": "Verificar se os vetores de valores reais e previstos têm o mesmo comprimento e alinhamento temporal via inspeção ou plot.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Jupyter Notebook ou RStudio",
                                    "Bibliotecas: pandas/NumPy (Python) ou dplyr/tidyr (R)",
                                    "Dados de exemplo em CSV"
                                  ],
                                  "tips": "Use funções como pd.merge() para alinhar dados e plt.plot() para visualização rápida.",
                                  "learningObjective": "Garantir dados limpos e alinhados para cálculos precisos de métricas.",
                                  "commonMistakes": [
                                    "Não alinhar índices temporais",
                                    "Ignorar valores ausentes",
                                    "Confundir treino com teste"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Cálculo das métricas de erro: MAE, RMSE e MAPE",
                                  "subSteps": [
                                    "Calcular erros residuais: real - previsto",
                                    "Computar MAE como média dos valores absolutos dos erros",
                                    "Computar RMSE como raiz quadrada da média dos erros ao quadrado",
                                    "Computar MAPE como média dos erros percentuais absolutos (evite divisão por zero)",
                                    "Implementar as fórmulas em código ou planilha e registrar os resultados"
                                  ],
                                  "verification": "Comparar resultados com cálculos manuais em uma amostra pequena para validar implementações.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Bibliotecas: scikit-learn (mean_absolute_error, mean_squared_error) ou fórmulas manuais",
                                    "Excel para validação manual"
                                  ],
                                  "tips": "Para MAPE, adicione um pequeno epsilon (ex: 1e-8) ao denominador para evitar divisão por zero.",
                                  "learningObjective": "Dominar o cálculo e interpretação de métricas padrão de precisão em previsões.",
                                  "commonMistakes": [
                                    "Esquecer raiz quadrada no RMSE",
                                    "Usar erros não absolutos no MAE",
                                    "Calcular MAPE com zeros no real"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Análise de resíduos e diagnósticos do modelo",
                                  "subSteps": [
                                    "Gerar resíduos e plotar: resíduos vs. tempo, QQ-plot, histograma",
                                    "Testar autocorrelação com ACF/PACF ou teste de Ljung-Box",
                                    "Verificar normalidade com teste Shapiro-Wilk ou Kolmogorov-Smirnov",
                                    "Identificar padrões como heterocedasticidade ou sazonalidade residual",
                                    "Documentar achados diagnósticos"
                                  ],
                                  "verification": "Plots mostram ausência de padrões óbvios e testes estatísticos com p-valor reportado.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Bibliotecas: statsmodels (Python) ou forecast (R)",
                                    "Matplotlib/ggplot2 para plots"
                                  ],
                                  "tips": "Use resample() para checar sazonalidade em resíduos; foque em diagnósticos visuais primeiro.",
                                  "learningObjective": "Identificar violações de pressupostos em modelos de séries temporais via resíduos.",
                                  "commonMistakes": [
                                    "Ignorar autocorrelação",
                                    "Interpretar plots sem testes estatísticos",
                                    "Não escalar resíduos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ajustes no modelo baseados em diagnósticos e reavaliação",
                                  "subSteps": [
                                    "Propor ajustes: adicionar lags, transformações ou modelo alternativo baseado em resíduos",
                                    "Reajustar o modelo com as modificações",
                                    "Recalcular métricas de erro e comparar com baseline",
                                    "Avaliar melhorias nos diagnósticos residuais",
                                    "Documentar iterações e decisões tomadas"
                                  ],
                                  "verification": "Métricas melhoradas (ex: RMSE reduzido) e resíduos mais aleatórios em novos plots.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Modelos: ARIMA/SARIMA ou Prophet",
                                    "Ferramentas de tuning como grid search"
                                  ],
                                  "tips": "Mantenha um log de versões do modelo para rastrear melhorias; use validação cruzada temporal.",
                                  "learningObjective": "Aplicar feedback de avaliação para iterar e melhorar previsões de demanda.",
                                  "commonMistakes": [
                                    "Ajustes sem base diagnóstica",
                                    "Overfitting por ignorar validação out-of-sample",
                                    "Não comparar com baseline"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma loja de varejo prevendo demanda semanal de smartphones: valores reais [100, 120, 110], previstos [105, 115, 112]. MAE=4.33, RMSE=5.03, MAPE=3.8%. Resíduos mostram autocorrelação; ajuste adicionando lag 1 reduz RMSE para 3.2%.",
                              "finalVerifications": [
                                "Métricas MAE, RMSE e MAPE calculadas corretamente com valores numéricos precisos",
                                "Plots de resíduos gerados e interpretados sem padrões evidentes",
                                "Testes diagnósticos aplicados com resultados documentados",
                                "Modelo ajustado com métricas comparadas antes/depois",
                                "Relatório com interpretação de precisão para decisões de estoque",
                                "Código reproduzível e dados versionados"
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos de métricas (erro <1%)",
                                "Qualidade e correção dos plots e testes de resíduos",
                                "Relevância e eficácia dos ajustes propostos",
                                "Interpretação clara das métricas em contexto de demanda",
                                "Documentação completa e acionável",
                                "Eficiência temporal e uso adequado de ferramentas"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estatística inferencial e álgebra linear",
                                "Programação: Manipulação de dados e visualização (Python/R)",
                                "Gestão de Operações: Otimização de cadeia de suprimentos",
                                "Economia: Modelagem econométrica de séries temporais"
                              ],
                              "realWorldApplication": "Em empresas de logística e varejo, como Amazon ou Magazine Luiza, para calibrar previsões de demanda, minimizar excessos/ faltas de estoque, reduzir custos operacionais em até 20% e melhorar satisfação do cliente."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.3.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.3.2",
                        "name": "Controle de Estoques",
                        "description": "Utilização de previsões de séries temporais para otimizar níveis de estoque, calculando pontos de reposição e estoques de segurança.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.3.2.1",
                            "name": "Modelagem de demanda para estoques",
                            "description": "Integrar previsões de séries temporais em modelos de controle de estoque, considerando variabilidade da demanda sazonal ou trend.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Séries Temporais e Modelos de Estoque",
                                  "subSteps": [
                                    "Estudar componentes de séries temporais: trend, sazonalidade, ciclos e ruído.",
                                    "Analisar modelos básicos de controle de estoque: EOQ, ponto de reorder e safety stock.",
                                    "Explorar impacto da variabilidade da demanda (sazonal ou trend) nos custos de estoque.",
                                    "Mapear como previsões de séries temporais substituem demanda média constante.",
                                    "Criar um fluxograma conectando previsão de demanda a decisões de estoque."
                                  ],
                                  "verification": "Criar um fluxograma ou tabela resumindo relações entre componentes e modelos de estoque.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Notas de séries temporais (ARIMA, Holt-Winters)",
                                    "Livro ou PDF de Gestão de Operações",
                                    "Ferramenta de diagramação como Draw.io"
                                  ],
                                  "tips": "Use exemplos visuais como gráficos de demanda sazonal para fixar conceitos.",
                                  "learningObjective": "Compreender como variabilidade da demanda afeta modelos de estoque e o papel das previsões.",
                                  "commonMistakes": [
                                    "Confundir sazonalidade com trend",
                                    "Ignorar custos de holding e faltas em EOQ",
                                    "Subestimar lead time"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Coletar e Explorar Dados de Demanda Histórica",
                                  "subSteps": [
                                    "Obter dados históricos de demanda (ex: vendas diárias/mensais por 2-3 anos).",
                                    "Realizar análise exploratória: plotar série temporal, decompor componentes.",
                                    "Testar estacionariedade (teste ADF) e identificar padrões sazonais/trend.",
                                    "Calcular estatísticas descritivas: média, variância, autocorrelação.",
                                    "Limpar dados: tratar outliers e missing values."
                                  ],
                                  "verification": "Gerar relatório com gráficos de decomposição e testes estatísticos interpretados.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Dataset de vendas (ex: Kaggle série temporal)",
                                    "Python (pandas, matplotlib, statsmodels) ou R",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Sempre plote dados brutos primeiro para visualizar padrões intuitivamente.",
                                  "learningObjective": "Preparar dados de demanda para modelagem precisa de séries temporais.",
                                  "commonMistakes": [
                                    "Não decompor série antes de modelar",
                                    "Ignorar sazonalidade em dados agregados",
                                    "Usar dados insuficientes (<24 períodos)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir e Validar Modelo de Previsão de Série Temporal",
                                  "subSteps": [
                                    "Selecionar modelo adequado: ARIMA para trend, Holt-Winters para sazonalidade.",
                                    "Ajustar parâmetros (ex: auto.arima ou grid search).",
                                    "Validar com métricas: MAE, RMSE, MAPE em conjunto de teste.",
                                    "Gerar previsões de demanda para horizonte futuro (ex: 12 meses).",
                                    "Visualizar previsões vs. dados reais e intervalos de confiança."
                                  ],
                                  "verification": "Produzir gráfico de previsão com métricas de erro <15% MAPE.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Bibliotecas Python: prophet, statsmodels ou pmdarima",
                                    "Dataset preparado do step 2",
                                    "Documentação de modelos SARIMA"
                                  ],
                                  "tips": "Comece com modelos simples; use intervalos de confiança para variabilidade.",
                                  "learningObjective": "Gerar previsões precisas que capturem sazonalidade e trend.",
                                  "commonMistakes": [
                                    "Sobreajuste (overfitting) em dados ruidosos",
                                    "Horizonte de previsão muito longo sem validação",
                                    "Ignorar resíduos não estacionários"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Previsões em Modelos de Controle de Estoque",
                                  "subSteps": [
                                    "Calcular demanda média prevista e desvio padrão para safety stock.",
                                    "Adaptar EOQ para demanda variável: Q = sqrt(2DS/h), com D prevista.",
                                    "Definir reorder point (ROP) = demanda durante lead time + safety stock.",
                                    "Simular inventário dinâmico considerando previsões sazonais.",
                                    "Otimizar parâmetros minimizando custo total (holding + faltas)."
                                  ],
                                  "verification": "Implementar simulação em código que mostre níveis de estoque ao longo do tempo.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Python (numpy, simpy para simulação)",
                                    "Planilha Excel para protótipo",
                                    "Fórmulas de estoque adaptadas"
                                  ],
                                  "tips": "Use loops para simular múltiplos cenários de demanda prevista.",
                                  "learningObjective": "Integrar previsões dinâmicas em decisões de estoque acionáveis.",
                                  "commonMistakes": [
                                    "Usar demanda constante em vez de prevista",
                                    "Subestimar safety stock para alta variabilidade",
                                    "Não considerar lead time variável"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Avaliar, Otimizar e Documentar o Modelo Integrado",
                                  "subSteps": [
                                    "Simular cenários: otimista, pessimista, com erros de previsão.",
                                    "Calcular KPIs: taxa de serviço, custo total de estoque, taxa de faltas.",
                                    "Sensibilidade: variar parâmetros de previsão e estoque.",
                                    "Documentar modelo: equações, premissas e recomendações.",
                                    "Propor melhorias (ex: machine learning avançado)."
                                  ],
                                  "verification": "Relatório final com KPIs, gráficos de simulação e análise de sensibilidade.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código dos steps anteriores",
                                    "Ferramentas de relatório (Jupyter ou Word)",
                                    "Templates de análise de sensibilidade"
                                  ],
                                  "tips": "Compare com baseline (demanda média) para quantificar ganhos.",
                                  "learningObjective": "Validar robustez do modelo integrado e comunicá-lo efetivamente.",
                                  "commonMistakes": [
                                    "Focar só em precisão de previsão, ignorar custo de estoque",
                                    "Não testar cenários extremos",
                                    "Documentação incompleta"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma fábrica de roupas, use dados de vendas de casacos (alta sazonalidade no inverno) para prever demanda com Holt-Winters SARIMA. Integre em modelo de estoque: calcule safety stock baseado em desvios previstos, simulando redução de 20% em faltas e 15% em custos de holding.",
                              "finalVerifications": [
                                "Previsões capturam >80% da variância sazonal/trend (R² >0.8).",
                                "Simulação de estoque mantém taxa de serviço >95%.",
                                "Custo total de estoque reduzido vs. baseline em pelo menos 10%.",
                                "Intervalos de confiança da previsão usados corretamente em safety stock.",
                                "Relatório documenta premissas, equações e resultados de sensibilidade.",
                                "Código reproduzível gera mesmos resultados."
                              ],
                              "assessmentCriteria": [
                                "Precisão de previsão: MAPE <12% em teste out-of-sample.",
                                "Correção matemática: fórmulas de EOQ/ROP/safety stock aplicadas com previsões.",
                                "Robustez: modelo performa bem em 3 cenários simulados.",
                                "Clareza: gráficos e explicações acessíveis a não-especialistas.",
                                "Otimização: identificação de trade-offs custo/serviço.",
                                "Documentação: completa e profissional."
                              ],
                              "crossCurricularConnections": [
                                "Gestão de Operações: Otimização de supply chain.",
                                "Estatística: Modelos avançados e validação.",
                                "Programação: Implementação em Python/R para simulações.",
                                "Negócios: Análise de custo-benefício em decisões operacionais.",
                                "Economia: Impacto de variabilidade em eficiência empresarial."
                              ],
                              "realWorldApplication": "Em varejo online como Amazon ou Magazine Luiza, modelar demanda sazonal de eletrônicos para ajustar estoques automaticamente via ERP, minimizando overstock no pós-Black Friday e faltas durante picos, economizando milhões em custos logísticos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.3.1"
                            ]
                          },
                          {
                            "id": "10.1.8.3.2.2",
                            "name": "Cálculo de estoque de segurança",
                            "description": "Determinar estoque de segurança usando desvios padrão de resíduos de previsões de séries temporais e níveis de serviço desejados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Fundamentais de Estoque de Segurança e Resíduos de Previsão",
                                  "subSteps": [
                                    "Defina estoque de segurança como buffer contra incertezas na demanda e suprimentos.",
                                    "Explique resíduos de previsão como diferenças entre valores reais e previstos em séries temporais.",
                                    "Descreva desvio padrão dos resíduos (σ) como medida de variabilidade dos erros de previsão.",
                                    "Discuta nível de serviço (LOS) como probabilidade de não estocar fora (ex: 95%).",
                                    "Revise a fórmula básica: SS = Z × σ × √LT, onde Z é o fator de serviço, σ desvio padrão dos resíduos, LT lead time."
                                  ],
                                  "verification": "Resuma os conceitos em um diagrama ou parágrafo e explique a fórmula com palavras próprias.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de séries temporais ou notas de aula",
                                    "Planilha Excel ou Python (pandas, numpy)",
                                    "Tabela Z-score da distribuição normal"
                                  ],
                                  "tips": "Use exemplos simples de demanda diária para visualizar incertezas antes de mergulhar em fórmulas.",
                                  "learningObjective": "Compreender os componentes teóricos do cálculo de estoque de segurança baseado em séries temporais.",
                                  "commonMistakes": [
                                    "Confundir resíduos com demanda real",
                                    "Ignorar o impacto do lead time na variância",
                                    "Usar média em vez de desvio padrão"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Coletar e Calcular Resíduos de Previsões de Séries Temporais",
                                  "subSteps": [
                                    "Obtenha dados históricos de demanda e previsões de uma série temporal (ex: vendas semanais).",
                                    "Calcule resíduos: e_t = D_t - Ŷ_t para cada período t.",
                                    "Verifique estacionariedade dos resíduos usando teste de Dickey-Fuller ou gráfico ACF.",
                                    "Registre pelo menos 30-50 resíduos para amostra estatisticamente válida.",
                                    "Limpe outliers nos resíduos para evitar distorções."
                                  ],
                                  "verification": "Gere uma lista de resíduos e plote histogram para confirmar distribuição aproximadamente normal.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Dataset de séries temporais (ex: vendas de varejo)",
                                    "Software: Excel, R ou Python (statsmodels)",
                                    "Gráficos de resíduos"
                                  ],
                                  "tips": "Use ARIMA ou Exponential Smoothing para gerar previsões precisas antes de calcular resíduos.",
                                  "learningObjective": "Calcular com precisão os resíduos de previsões para análise de variabilidade.",
                                  "commonMistakes": [
                                    "Usar poucos dados levando a σ instável",
                                    "Não transformar série para estacionariedade",
                                    "Confundir previsão com demanda suavizada"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Desvio Padrão e Determinar Fator Z para Nível de Serviço",
                                  "subSteps": [
                                    "Calcule σ = sqrt( (1/(n-1)) * Σ e_t² ) dos resíduos.",
                                    "Escolha LOS desejado (ex: 95% → Z=1.645; 99% → Z=2.326) consultando tabela normal padrão.",
                                    "Ajuste para lead time: variância efetiva = σ² × LT.",
                                    "Calcule σ_LT = σ × √LT.",
                                    "Documente suposições como independência dos erros e normalidade."
                                  ],
                                  "verification": "Confirme σ e Z com cálculos manuais e software, comparando resultados.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Tabela Z-score",
                                    "Calculadora ou Python (scipy.stats.norm.ppf)",
                                    "Planilha com fórmulas"
                                  ],
                                  "tips": "Para LOS variáveis, crie uma tabela lookup para Z-scores comuns para agilizar.",
                                  "learningObjective": "Dominar o cálculo de σ dos resíduos e seleção apropriada de Z baseada em LOS.",
                                  "commonMistakes": [
                                    "Usar desvio padrão populacional em vez amostral",
                                    "Esquecer raiz quadrada no lead time",
                                    "Selecionar Z errado para LOS assimétrico"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Fórmula de Estoque de Segurança e Validar",
                                  "subSteps": [
                                    "Calcule SS = Z × σ_LT.",
                                    "Simule cenários com diferentes LT e LOS para sensibilidade.",
                                    "Compare SS com estoque histórico para plausibilidade.",
                                    "Ajuste para sazonalidade se resíduos mostrarem padrões.",
                                    "Gere relatório com inputs, cálculos e output."
                                  ],
                                  "verification": "Teste com dataset conhecido: SS deve cobrir 95% dos cenários simulados sem estoque zero.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Simulador Monte Carlo em Python",
                                    "Dataset de teste com lead time conhecido",
                                    "Ferramenta de visualização (matplotlib)"
                                  ],
                                  "tips": "Incorpore custo de estoque vs. custo de falta para otimizar LOS realisticamente.",
                                  "learningObjective": "Executar cálculo completo de SS e interpretar resultados em contexto operacional.",
                                  "commonMistakes": [
                                    "Não considerar lead time variável",
                                    "Ignorar correlação temporal nos resíduos",
                                    "Superestimar SS sem validação"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Implementar e Monitorar Estoque de Segurança em Cenário Prático",
                                  "subSteps": [
                                    "Integre SS em modelo de reorder point: ROP = demanda média × LT + SS.",
                                    "Configure monitoramento mensal de resíduos para atualizar σ.",
                                    "Avalie performance com métricas como taxa de estoque fora.",
                                    "Ajuste modelo com feedback de dados reais.",
                                    "Documente processo para automação futura."
                                  ],
                                  "verification": "Simule 100 períodos e verifique LOS atendido em pelo menos 95% dos casos.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "ERP simulado ou Excel avançado",
                                    "Código Python para simulação",
                                    "Dashboard de KPIs"
                                  ],
                                  "tips": "Automatize com scripts para recalcular SS periodicamente com novos dados.",
                                  "learningObjective": "Aplicar e manter cálculo de SS em ambiente dinâmico de controle de estoques.",
                                  "commonMistakes": [
                                    "Não atualizar σ com novos resíduos",
                                    "Usar ROP sem SS",
                                    "Ignorar custos em decisões de LOS"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um supermercado com demanda diária de pão prevista por ARIMA (média 100 unidades, σ resíduos=15), LT=3 dias, LOS=95% (Z=1.645): σ_LT=15√3≈26, SS=1.645×26≈43 unidades. Adicione 43 pães ao ROP para evitar faltas.",
                              "finalVerifications": [
                                "Cálculo de σ dos resíduos bate com software padrão (±1%).",
                                "SS cobre LOS especificado em simulação Monte Carlo.",
                                "Fórmula aplicada corretamente incluindo √LT.",
                                "Resíduos plotados mostram normalidade aproximada.",
                                "Relatório inclui sensibilidade a variações de LOS e LT.",
                                "Integração com ROP testada em exemplo prático."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos de resíduos e σ (90%+ acurácia).",
                                "Seleção correta de Z para LOS dado (tabela ou função inversa CDF).",
                                "Inclusão de lead time na variância com justificativa.",
                                "Validação via simulação ou histórico (LOS atendido).",
                                "Explicação clara de suposições e limitações.",
                                "Aplicação prática em exemplo realista com números."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: Distribuição normal e Z-scores.",
                                "Gestão de Operações: Modelos de inventário (EOQ, ROP).",
                                "Análise de Dados: Séries temporais e modelagem preditiva.",
                                "Economia Empresarial: Trade-off custo de estoque vs. serviço.",
                                "Programação: Implementação em Python/R para automação."
                              ],
                              "realWorldApplication": "Em cadeias de suprimentos como Amazon ou Walmart, calcula SS para produtos sazonais usando erros de previsão de IA, minimizando faltas (custo alto) e excesso de estoque (capital preso), otimizando bilhões em inventário."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.8.3.2.3",
                            "name": "Definição de pontos de pedido",
                            "description": "Calcular pontos de reposição (ROP) baseados em lead time e previsões de demanda via métodos de séries temporais para minimizar custos de estoque.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Coleta e Preparação de Dados Históricos de Demanda e Lead Time",
                                  "subSteps": [
                                    "Reúna dados históricos de demanda diária ou semanal para o item de estoque por pelo menos 2-3 anos.",
                                    "Registre o lead time médio e sua variabilidade (desvio padrão) com fornecedores.",
                                    "Limpe os dados removendo outliers e valores ausentes, usando interpolação ou médias móveis.",
                                    "Calcule estatísticas descritivas básicas: média, mediana, variância da demanda.",
                                    "Crie uma série temporal alinhada no tempo (ex: índice de data)."
                                  ],
                                  "verification": "Verifique se o dataset está limpo e completo com pelo menos 100 observações, sem erros de formatação, via plot de série temporal.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": "Planilha Excel ou Python (pandas), dados históricos de vendas/estoque.",
                                  "tips": "Use gráficos de decomposição para identificar sazonalidade cedo.",
                                  "learningObjective": "Preparar dados confiáveis para modelagem de séries temporais.",
                                  "commonMistakes": "Ignorar sazonalidade ou feriados que afetam a demanda."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelagem e Previsão de Demanda Durante o Lead Time",
                                  "subSteps": [
                                    "Escolha e ajuste um modelo de séries temporais (ex: Holt-Winters para sazonalidade ou ARIMA).",
                                    "Divida dados em treino/teste (80/20) e valide o modelo com métricas como MAE ou RMSE.",
                                    "Gere previsões de demanda para o período do lead time (ex: 7-14 dias).",
                                    "Calcule intervalos de confiança (95%) para a previsão de demanda.",
                                    "Compare múltiplos modelos e selecione o melhor via critério AIC ou BIC."
                                  ],
                                  "verification": "Confirme precisão da previsão com RMSE < 10% no conjunto de teste e plots de resíduos aleatórios.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": "Python (statsmodels, pmdarima) ou R (forecast package), Jupyter Notebook.",
                                  "tips": "Comece com suavização exponencial simples se dados forem ruidosos.",
                                  "learningObjective": "Dominar previsão de demanda via séries temporais para lead time.",
                                  "commonMistakes": "Sobreajustar o modelo (overfitting) ignorando validação cruzada."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Cálculo do Ponto de Reposição (ROP)",
                                  "subSteps": [
                                    "Calcule demanda prevista durante lead time: Previsão média * lead time.",
                                    "Estime safety stock: Z * desvio padrão da demanda durante lead time (Z para nível de serviço, ex: 1.65 para 95%).",
                                    "Some: ROP = Demanda lead time + Safety stock.",
                                    "Incorpore variabilidade do lead time multiplicando pelo desvio padrão do LT.",
                                    "Documente fórmulas e premissas usadas."
                                  ],
                                  "verification": "Execute simulação: ROP deve cobrir 95% dos cenários de demanda real sem estoque excessivo.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Calculadora ou Python/Excel para fórmulas.",
                                  "tips": "Use Z=1.65 para equilíbrio custo-risco em estoques moderados.",
                                  "learningObjective": "Aplicar fórmula ROP otimizada com previsões de séries temporais.",
                                  "commonMistakes": "Usar demanda média simples em vez de previsão ajustada por tendências."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Otimização para Minimização de Custos de Estoque e Validação",
                                  "subSteps": [
                                    "Calcule custos: Holding cost * safety stock vs. custo de estoque zero (falta).",
                                    "Ajuste ROP iterativamente para minimizar custo total (holding + faltas).",
                                    "Simule cenários de demanda com Monte Carlo usando previsões.",
                                    "Compare ROP otimizado com método tradicional (média simples).",
                                    "Crie dashboard para monitoramento contínuo."
                                  ],
                                  "verification": "Custo total reduzido em pelo menos 10-20% vs. baseline, com service level >95%.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": "Python (numpy para simulações) ou Excel Solver.",
                                  "tips": "Priorize custo de holding baixo ajustando Z para baixo se possível.",
                                  "learningObjective": "Otimizar ROP para eficiência econômica usando simulações.",
                                  "commonMistakes": "Ignorar custo de faltas, levando a ROP subestimado."
                                }
                              ],
                              "practicalExample": "Para um supermercado gerenciando estoque de leite: Dados históricos mostram demanda sazonal (picos matinais). Lead time=3 dias. Modelo Holt-Winters prevê 1500L/dia durante LT. Safety stock=300L. ROP=4800L. Simulação mostra redução de 15% em custos de estoque sem faltas.",
                              "finalVerifications": [
                                "Previsão de demanda cobre 95% dos cenários reais durante lead time.",
                                "ROP calculado minimiza custo total (holding + faltas) em simulação.",
                                "Dashboard implementado para atualização semanal de ROP.",
                                "Comparação com histórico: redução em estoque médio sem aumento de faltas.",
                                "Documentação completa com fórmulas e premissas.",
                                "Teste sensibilidade: ROP robusto a ±20% variação em lead time."
                              ],
                              "assessmentCriteria": [
                                "Precisão da previsão (RMSE <15% no teste).",
                                "Correção matemática do ROP (inclui safety stock e LT variabilidade).",
                                "Redução comprovada de custos via simulação (>10%).",
                                "Uso adequado de métodos de séries temporais (justificado).",
                                "Relatório claro com visualizações e interpretações.",
                                "Capacidade de ajustar ROP a novos dados."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Modelos ARIMA e validação de hipóteses.",
                                "Gestão de Operações: EOQ e controle de inventário.",
                                "Programação: Implementação em Python/R para automação.",
                                "Finanças: Análise custo-benefício e NPV de estoque."
                              ],
                              "realWorldApplication": "Em cadeias de suprimentos como Amazon ou Walmart, ROP baseado em séries temporais evita overstock de produtos perecíveis, reduzindo desperdícios em 20-30% e otimizando capital de giro em logística global."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.3.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.8.3.3",
                        "name": "Planejamento de Produção",
                        "description": "Planejamento agregado e detalhado de produção utilizando previsões de séries temporais para alinhar capacidade com demanda prevista.",
                        "specificSkills": [
                          {
                            "id": "10.1.8.3.3.1",
                            "name": "Geração de planos de produção agregada",
                            "description": "Elaborar planos de produção agregada (APP) com base em previsões de séries temporais, balanceando custos de mão de obra, estoque e produção.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar Previsões de Demanda de Séries Temporais",
                                  "subSteps": [
                                    "Colete dados históricos de demanda para os produtos ou famílias de produtos relevantes.",
                                    "Aplique modelos de séries temporais (ex: ARIMA, Holt-Winters) para gerar previsões para o horizonte de planejamento agregado (geralmente 3-18 meses).",
                                    "Ajuste previsões com fatores sazonais, tendências e eventos promocionais.",
                                    "Agrupe previsões por famílias de produtos para nível agregado.",
                                    "Valide a precisão das previsões usando métricas como MAPE ou RMSE."
                                  ],
                                  "verification": "Previsões geradas e validadas com relatório de precisão (MAPE < 15%) e gráfico de séries temporais comparando real vs. previsto.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Software de séries temporais (R, Python com statsmodels ou Prophet)",
                                    "Dados históricos de vendas em CSV",
                                    "Planilha Excel para agregação"
                                  ],
                                  "tips": "Use decomposição de séries para identificar componentes e priorize modelos que capturem sazonalidade.",
                                  "learningObjective": "Dominar a geração e validação de previsões agregadas para planejamento de produção.",
                                  "commonMistakes": [
                                    "Ignorar sazonalidade levando a superestimação de demanda",
                                    "Não validar previsões com hold-out sets",
                                    "Usar granularidade fina em vez de agregada"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Parâmetros e Restrições do Planejamento",
                                  "subSteps": [
                                    "Identifique custos relevantes: mão de obra (regular, overtime), estoque (holding), produção (setup, capacidade).",
                                    "Estabeleça capacidades de produção por período (máx/mín por família de produto).",
                                    "Defina horizontes de planejamento (ex: trimestral) e backlog permitido.",
                                    "Compile dados de estoque inicial e lead times médios.",
                                    "Crie tabela de parâmetros com unidades consistentes (ex: custo por unidade)."
                                  ],
                                  "verification": "Tabela de parâmetros completa com todas as restrições documentadas e unidades verificadas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Planilhas Excel ou Google Sheets",
                                    "Documentação de custos da empresa fictícia ou real",
                                    "Templates de planejamento agregado"
                                  ],
                                  "tips": "Padronize unidades para evitar erros de escala; inclua cenários de sensibilidade para custos variáveis.",
                                  "learningObjective": "Entender e quantificar trade-offs entre custos e restrições em APP.",
                                  "commonMistakes": [
                                    "Omitir custos de estoque levando a planos irrealistas",
                                    "Ignorar capacidades mínimas de produção",
                                    "Usar horizontes muito longos sem dados confiáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular e Otimizar o Modelo de Plano Agregado",
                                  "subSteps": [
                                    "Defina variáveis de decisão: produção regular (P_r), overtime (P_o), estoque final (I_t) por período.",
                                    "Escreva a função objetivo: minimizar soma de custos (c_r*P_r + c_o*P_o + h*I_t).",
                                    "Implemente restrições de balanço: I_t = I_{t-1} + P_r + P_o - D_t (demanda prevista).",
                                    "Use solver linear (Excel Solver, PuLP em Python) para otimizar.",
                                    "Gere plano com níveis de produção, estoque e força de trabalho por período."
                                  ],
                                  "verification": "Modelo otimizado rodado com valor objetivo mínimo e todas restrições satisfeitas (relatório do solver).",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "Excel com Solver add-in ou Python (PuLP, SciPy)",
                                    "Dados de previsões e parâmetros do Step 1 e 2"
                                  ],
                                  "tips": "Teste o modelo com dados sintéticos simples antes de dados reais; linearize não-linearidades se necessário.",
                                  "learningObjective": "Construir e resolver modelos de programação linear para APP.",
                                  "commonMistakes": [
                                    "Erros em balanço de estoque levando a estoque negativo",
                                    "Não tratar overtime como variável separada",
                                    "Ignorar integer constraints em setups"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar, Refinar e Documentar o Plano",
                                  "subSteps": [
                                    "Analise sensibilidade: varie previsões ±10% e custos para cenários what-if.",
                                    "Verifique viabilidade operacional (ex: mudanças na força de trabalho < 10%).",
                                    "Gere gráficos: produção, estoque, custos ao longo do tempo.",
                                    "Documente suposições, riscos e recomendações de ajuste.",
                                    "Compare com plano naive (produzir para demanda) para justificar melhorias."
                                  ],
                                  "verification": "Relatório final com gráficos, análise de sensibilidade e comparação de custos (redução > 5%).",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Ferramentas de visualização (Excel charts, Matplotlib)",
                                    "Templates de relatório APP"
                                  ],
                                  "tips": "Foque em KPIs como custo total, nível de serviço e variabilidade de produção.",
                                  "learningObjective": "Avaliar robustez de planos APP e comunicar resultados.",
                                  "commonMistakes": [
                                    "Não testar sensibilidade ignorando incertezas",
                                    "Relatórios sem visualizações claras",
                                    "Falhar em justificar trade-offs"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma fábrica de smartphones produzindo duas famílias (básico e premium), com previsões de demanda trimestral: Q1 básico=1000, premium=500; Q2 básico=1500, premium=800. Custos: mão de obra regular $10/un, overtime $15/un, holding $2/un/mês. Capacidade: 1200 un/trimestre. O plano otimizado sugere produzir 1100 básico e 600 premium em Q1 com overtime mínimo, estoque de 200 para Q2, reduzindo custo total em 12% vs. chase demand.",
                              "finalVerifications": [
                                "Previsões validadas com MAPE <15%.",
                                "Modelo APP resolve sem violações de restrições.",
                                "Custo total mínimo alcançado com trade-offs balanceados.",
                                "Análise de sensibilidade cobre ±20% variação em demanda.",
                                "Gráficos mostram estoque estável e produção viável.",
                                "Relatório documenta todos os passos e suposições."
                              ],
                              "assessmentCriteria": [
                                "Precisão e agregação correta das previsões (30%).",
                                "Formulação precisa do modelo LP com restrições (25%).",
                                "Otimização gera plano factível e ótimo (20%).",
                                "Análise de sensibilidade e viabilidade operacional (15%).",
                                "Clareza de documentação e visualizações (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Modelos de séries temporais para previsões.",
                                "Matemática: Programação linear e otimização.",
                                "Economia: Análise de custos e trade-offs operacionais.",
                                "Programação: Implementação em Python/R para solvers.",
                                "Gestão: Planejamento estratégico de operações."
                              ],
                              "realWorldApplication": "Em indústrias como automotiva (Ford usa APP para planejamento anual de modelos), manufatura (Procter & Gamble equilibra produção de bens de consumo) e varejo (Walmart para estoque sazonal), reduzindo custos de estoque em 20-30% e melhorando utilização de capacidade."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.3.1",
                              "10.1.8.3.2"
                            ]
                          },
                          {
                            "id": "10.1.8.3.3.2",
                            "name": "Integração com sistemas MRP",
                            "description": "Integrar previsões de séries temporais em sistemas de Planejamento de Necessidades de Materiais (MRP) para planejamento mestre de produção.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e Formatar Previsões de Séries Temporais",
                                  "subSteps": [
                                    "Coletar dados históricos de demanda de materiais relevantes para o MRP.",
                                    "Aplicar modelo de séries temporais (ex: ARIMA ou Prophet) para gerar previsões de demanda futura.",
                                    "Ajustar previsões para o horizonte de planejamento do MRP (ex: 12 semanas).",
                                    "Exportar previsões em formato compatível com o sistema MRP (CSV, XML ou API JSON).",
                                    "Validar integridade dos dados exportados (sem valores nulos ou outliers)."
                                  ],
                                  "verification": "Arquivo de previsões gerado e lido corretamente por um validador de formato MRP.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Software de análise (Python com pandas/prophet, R)",
                                    "Dados históricos de demanda",
                                    "Documentação de formato MRP do sistema"
                                  ],
                                  "tips": "Alinhe o horizonte de previsão com os buckets de tempo do MRP (semanal/mensal).",
                                  "learningObjective": "Gerar previsões de demanda formatadas e prontas para importação em MRP.",
                                  "commonMistakes": [
                                    "Ignorar sazonalidade nos dados",
                                    "Usar horizonte de previsão incompatível",
                                    "Exportar sem validação de escala/unidades"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Estrutura de Demanda no Sistema MRP",
                                  "subSteps": [
                                    "Acessar módulo de planejamento mestre de produção (MPS) no sistema MRP.",
                                    "Mapear itens de materiais/boms finais às previsões de demanda importadas.",
                                    "Configurar parâmetros de segurança de estoque e lead times baseados em variância das previsões.",
                                    "Importar arquivo de previsões via upload, API ou integração ETL.",
                                    "Executar validação automática de dados no MRP para detectar erros de importação."
                                  ],
                                  "verification": "Sistema MRP confirma importação bem-sucedida sem erros de mapeamento.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Acesso ao software MRP (SAP, Oracle, Microsoft Dynamics)",
                                    "Credenciais de admin",
                                    "Esquema de BOM e master data"
                                  ],
                                  "tips": "Teste importação com subset pequeno de dados primeiro para evitar sobrecarga.",
                                  "learningObjective": "Configurar demanda prevista derivada de séries temporais no MRP.",
                                  "commonMistakes": [
                                    "Mapeamento incorreto de SKUs",
                                    "Ignorar lead times variáveis",
                                    "Sobrescrever dados históricos existentes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar Planejamento Mestre Integrado (MPS/MRP)",
                                  "subSteps": [
                                    "Rodar regeneração do MPS usando as previsões integradas como demanda driver.",
                                    "Explorar resultados: ordens planejadas, necessidades de materiais e estoque projetado.",
                                    "Ajustar lot sizes e políticas de ordenação considerando incerteza das previsões.",
                                    "Gerar relatórios de explosão de necessidades (net requirements).",
                                    "Simular cenários what-if alterando previsões para testar robustez."
                                  ],
                                  "verification": "Relatórios MPS/MRP gerados mostram necessidades alinhadas às previsões.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "Sistema MRP ativo",
                                    "Dados master atualizados (BOM, routings)",
                                    "Ferramentas de simulação MRP"
                                  ],
                                  "tips": "Monitore service levels projetados; ajuste safety stock se abaixo de 95%.",
                                  "learningObjective": "Executar e interpretar planejamento MRP impulsionado por previsões de séries temporais.",
                                  "commonMistakes": [
                                    "Não considerar restrições de capacidade",
                                    "Ignorar propagação de atrasos em BOM multi-nível",
                                    "Usar lot sizes fixos sem otimização"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar, Otimizar e Automatizar a Integração",
                                  "subSteps": [
                                    "Comparar plano MRP com baseline histórico para medir melhorias em estoque/lead time.",
                                    "Calcular métricas de erro (ex: MAD das previsões vs. demanda real simulada).",
                                    "Otimizar integração com scripts de automação (ex: pipeline ETL diário).",
                                    "Documentar processo de integração para equipe de operações.",
                                    "Testar end-to-end com dados reais ou simulados para ciclo completo."
                                  ],
                                  "verification": "Métricas de performance mostram redução de estoque >10% vs. baseline.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Ferramentas de ETL (Apache Airflow, Talend)",
                                    "Dados de teste/validação",
                                    "Ferramentas de métricas (Excel/Tableau)"
                                  ],
                                  "tips": "Automatize alertas para desvios >20% entre previsão e demanda real.",
                                  "learningObjective": "Validar eficácia da integração e estabelecer automação sustentável.",
                                  "commonMistakes": [
                                    "Não benchmarkar contra método anterior",
                                    "Subestimar tempo de otimização",
                                    "Falhar em documentar para handover"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma fábrica de smartphones, previsões de demanda para baterias (usando ARIMA em dados de vendas semanais) são importadas no SAP MRP. O sistema gera ordens planejadas para 10.000 unidades na semana 5, reduzindo estoque ocioso em 15% e evitando rupturas.",
                              "finalVerifications": [
                                "Previsões importadas corretamente sem erros de formato.",
                                "Plano MPS/MRP reflete demanda prevista com service level >95%.",
                                "Necessidades líquidas calculadas propagam corretamente pela BOM.",
                                "Simulação what-if altera planos conforme esperado.",
                                "Processo documentado e reproduzível por outro usuário.",
                                "Redução mensurável em estoque ou lead time vs. baseline."
                              ],
                              "assessmentCriteria": [
                                "Precisão da integração: 100% de importação sem erros.",
                                "Qualidade das previsões: Erro médio <15% em holdout set.",
                                "Eficiência do plano: Estoque médio reduzido >10%.",
                                "Robustez: Plano responde a variações de ±20% na previsão.",
                                "Documentação: Guia passo-a-passo completo.",
                                "Tempo de execução: Integração end-to-end <12 horas."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Modelagem avançada de séries temporais (ARIMA, LSTM).",
                                "Programação: Scripts Python/R para ETL e automação MRP.",
                                "Gestão de Operações: Otimização de supply chain e lean manufacturing.",
                                "Banco de Dados: Queries SQL para master data e integração.",
                                "Gestão de Projetos: Implementação de mudanças em sistemas ERP."
                              ],
                              "realWorldApplication": "Indústrias manufatureiras como automotiva (Ford integrando previsões em SAP para peças) ou farmacêutica usam isso para sincronizar produção com demanda volátil, minimizando custos de estoque e melhorando resposta a mercado."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.8.3.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ],
            "totalSkills": 363
          }
        ],
        "totalSkills": 363,
        "percentage": 100
      }
    ]
  }
}