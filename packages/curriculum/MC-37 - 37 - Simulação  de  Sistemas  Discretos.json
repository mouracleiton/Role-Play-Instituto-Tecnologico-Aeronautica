{
  "formatVersion": "1.0",
  "exportDate": "2025-12-04T22:57:18.866Z",
  "appVersion": "1.0",
  "curriculumData": {
    "metadata": {
      "baseOn": "Catálogo dos Cursos de Graduação 2025 - MC-37",
      "lastUpdated": "2025-12-04",
      "totalAtomicSkills": 346,
      "startDate": "2025-01-01",
      "duration": "5 anos",
      "dailyStudyHours": 6,
      "version": "2025",
      "institution": "Instituto Tecnológico de Aeronáutica (ITA)",
      "basedOn": "Catálogo dos Cursos de Graduação 2025 - MC-37"
    },
    "areas": [
      {
        "id": "10",
        "name": "Matemática Computacional",
        "description": "Área dedicada a disciplinas de matemática computacional no ITA, incluindo simulação e modelagem.",
        "disciplines": [
          {
            "id": "10.1",
            "name": "MC-37 - Simulação de Sistemas Discretos",
            "description": "simulação. As fases de simulação por computadores. Os procedimentos de modelagem de simulação. Métodos de amostragem, geração de números e variáveis aleatórias. Linguagens de simulação, avaliação de software de simulação. Validação de modelos, projeto e planejamento de experimento de simulação, técnicas de redução de variância. Bibliografia: BANKS, J. et al. Discrete-event system simulation. 3. ed. Upper Saddle River: Prentice Hall, 2000. KELTON, W. D.; LAW, A. M. Simulation modeling and analysis. New York: McGraw-Hill, 1991. PIDD, M. Computer simulation in management science. 4. ed. Chichester: Wiley, 1998.",
            "mainTopics": [
              {
                "id": "10.1.1",
                "name": "Fases de Simulação por Computadores",
                "description": "Apresenta as etapas principais envolvidas na realização de simulações utilizando computadores.",
                "totalSkills": 56,
                "atomicTopics": [
                  {
                    "id": "10.1.1.1",
                    "name": "Formulação do Problema",
                    "description": "Definição clara do problema a ser simulado e estabelecimento dos objetivos da simulação.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.1.1",
                        "name": "Definição Clara do Problema",
                        "description": "Processo de identificar e descrever de forma precisa o problema real do mundo físico ou abstrato que será abordado pela simulação, incluindo suas características principais e contexto.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.1.1",
                            "name": "Identificar os componentes principais do sistema",
                            "description": "Analisar o sistema real para listar entidades, atributos, atividades e eventos chave que compõem o problema a ser simulado, com base em observações ou dados empíricos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Realizar Observação Inicial e Coleta de Dados Empíricos",
                                  "subSteps": [
                                    "Observe o sistema real em operação por pelo menos 30 minutos, anotando padrões visíveis.",
                                    "Registre dados quantitativos como frequências de ocorrências usando cronômetro ou contadores.",
                                    "Entreviste stakeholders ou usuários para capturar perspectivas qualitativas.",
                                    "Documente o ambiente físico e restrições operacionais.",
                                    "Compile observações em um diário de campo inicial."
                                  ],
                                  "verification": "Verificar se o diário de campo contém pelo menos 10 entradas de observação com timestamps e descrições detalhadas.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": "Caderno de anotações, cronômetro, smartphone para fotos/vídeos (com permissão), formulário de entrevista simples.",
                                  "tips": "Mantenha neutralidade; evite assumir componentes sem evidências observadas.",
                                  "learningObjective": "Desenvolver habilidades de observação sistemática para fundamentar análise em dados reais.",
                                  "commonMistakes": "Ignorar variações sazonais ou depender apenas de memória em vez de registros."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Listar Entidades Principais",
                                  "subSteps": [
                                    "Revise o diário de campo e agrupe itens observados em categorias de 'objetos persistentes'.",
                                    "Liste entidades como pessoas, máquinas, itens ou locais que existem independentemente de ações.",
                                    "Priorize entidades com maior impacto no sistema usando critérios de frequência e criticidade.",
                                    "Desenhe um diagrama simples (fluxograma ou mapa mental) conectando entidades.",
                                    "Valide a lista consultando pelo menos uma segunda fonte de dados."
                                  ],
                                  "verification": "Lista de entidades contém 5-15 itens nomeados, com justificativa baseada em observações para cada uma.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": "Papel ou software de diagramação (ex: Draw.io, papel e caneta), diário de campo.",
                                  "tips": "Use nomes descritivos e concretos, como 'Cliente' em vez de 'Pessoa genérica'.",
                                  "learningObjective": "Reconhecer elementos estáticos do sistema como base para modelagem.",
                                  "commonMistakes": "Confundir entidades com ações transitórias ou incluir elementos irrelevantes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Atributos das Entidades Identificadas",
                                  "subSteps": [
                                    "Para cada entidade, liste propriedades mensuráveis observadas (ex: tamanho, estado, quantidade).",
                                    "Classifique atributos em fixos (constantes) e variáveis (mudam ao longo do tempo).",
                                    "Colete exemplos empíricos de valores reais de atributos durante observações.",
                                    "Especifique unidades de medida e faixas típicas baseadas em dados.",
                                    "Crie uma tabela relacionando entidades a seus atributos principais."
                                  ],
                                  "verification": "Tabela completa com pelo menos 2-5 atributos por entidade, incluindo exemplos numéricos ou descritivos.",
                                  "estimatedTime": "40-50 minutos",
                                  "materials": "Planilha (Google Sheets ou Excel), dados do diário de campo.",
                                  "tips": "Foquem em atributos que influenciam o comportamento do sistema.",
                                  "learningObjective": "Diferenciar e quantificar características que afetam simulações.",
                                  "commonMistakes": "Listar atributos vagos como 'importante' sem métricas específicas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Mapear Atividades e Eventos Chave",
                                  "subSteps": [
                                    "Identifique sequências de ações observadas envolvendo entidades e atributos.",
                                    "Liste atividades rotineiras (ex: processos repetitivos) e eventos raros (ex: falhas).",
                                    "Defina gatilhos, durações e condições para cada atividade/evento com base em dados.",
                                    "Ordene cronologicamente em um fluxograma de eventos.",
                                    "Quantifique frequências e probabilidades iniciais de eventos."
                                  ],
                                  "verification": "Fluxograma ou lista com 8-12 atividades/eventos, cada um com gatilho, duração estimada e evidência empírica.",
                                  "estimatedTime": "35-45 minutos",
                                  "materials": "Software de fluxograma (ex: Lucidchart gratuito), planilha para frequências.",
                                  "tips": "Distinga atividades (ações controladas) de eventos (aleatórios ou externos).",
                                  "learningObjective": "Capturar dinâmicas temporais do sistema para simulação precisa.",
                                  "commonMistakes": "Omitir eventos raros que impactam o sistema ou superestimar sequências lineares."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Organizar, Validar e Refinar a Lista Completa",
                                  "subSteps": [
                                    "Compile entidades, atributos, atividades e eventos em um documento unificado.",
                                    "Revise por completude: cobre todos os aspectos observados?",
                                    "Simule mentalmente ou com role-play para testar interações.",
                                    "Ajuste baseando em feedback de pares ou nova observação.",
                                    "Gere um resumo executivo com priorização de componentes críticos."
                                  ],
                                  "verification": "Documento final formatado com seções claras, versão revisada e assinatura de validação.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": "Documento Word/Google Docs, fluxogramas anteriores.",
                                  "tips": "Use checklists para garantir cobertura de todos os tipos de componentes.",
                                  "learningObjective": "Integrar componentes em uma visão holística validada empiricamente.",
                                  "commonMistakes": "Não refinar ambiguidades ou ignorar interdependências entre componentes."
                                }
                              ],
                              "practicalExample": "Ao simular uma fila de supermercado: Entidades (clientes, carrinhos, caixas registradoras); Atributos (número de itens no carrinho: 1-20, tempo de serviço: 2-5 min); Atividades (chegada de cliente, escaneamento de itens); Eventos (chegada aleatória de clientes a cada 1-3 min, falha no caixa a cada 30 min). Observado em 1 hora: 25 chegadas, média 8 itens/cliente.",
                              "finalVerifications": [
                                "Lista de entidades cobre >90% das observações iniciais.",
                                "Cada atributo tem pelo menos um exemplo empírico com unidade.",
                                "Atividades/eventos incluem frequências ou probabilidades estimadas.",
                                "Diagrama ou tabela mostra interconexões claras.",
                                "Resumo justifica seleções com referências a dados observados.",
                                "Componentes priorizados por impacto no problema de simulação."
                              ],
                              "assessmentCriteria": [
                                "Completude: Todos os componentes principais identificados sem lacunas evidentes (30%).",
                                "Precisão empírica: Baseado em observações/dados reais, não suposições (25%).",
                                "Clareza e organização: Listas/tablas/diagramas legíveis e estruturados (20%).",
                                "Detalhamento: Atributos quantificáveis, eventos com gatilhos (15%).",
                                "Relevância: Foco no problema de simulação, sem ruído (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Ciências: Modelagem de ecossistemas ou processos biológicos.",
                                "Engenharia: Análise de sistemas de produção ou tráfego.",
                                "Programação: Definição de classes/objetos em código de simulação.",
                                "Estatística: Coleta e análise de dados observacionais."
                              ],
                              "realWorldApplication": "Em indústrias, usado para modelar linhas de produção (ex: fábricas automotivas identificam máquinas como entidades, falhas como eventos), otimizando eficiência; em logística, simula fluxos de suprimentos para reduzir atrasos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.1.2",
                            "name": "Descrever o comportamento do sistema",
                            "description": "Elaborar uma narrativa detalhada dos fluxos de trabalho, interações e dinâmicas do sistema, destacando aspectos discretos e eventos que influenciam o problema.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar os componentes principais do sistema",
                                  "subSteps": [
                                    "Liste todos os agentes ou entidades envolvidas (ex.: clientes, servidores, recursos)",
                                    "Defina os estados possíveis de cada componente (ex.: ocioso, ocupado, em transição)",
                                    "Registre as variáveis discretas que descrevem o sistema (ex.: número de itens na fila)",
                                    "Desenhe um diagrama simples de blocos representando os componentes",
                                    "Priorize componentes que influenciam diretamente o problema central"
                                  ],
                                  "verification": "Verifique se há uma lista completa e diagramada de pelo menos 5-10 componentes principais sem duplicatas ou omissões evidentes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e caneta, software de diagramação como Draw.io ou Lucidchart, documentação inicial do problema",
                                  "tips": "Comece pelos atores humanos ou máquinas mais visíveis para ancorar a análise.",
                                  "learningObjective": "Compreender a composição estática do sistema discreto para basear a descrição dinâmica.",
                                  "commonMistakes": "Confundir componentes com eventos (foco em 'o quê' existe, não em 'o que acontece')"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Mapear as interações e fluxos de trabalho",
                                  "subSteps": [
                                    "Identifique as transições entre estados de cada componente (ex.: fila vazia para fila com 1 item)",
                                    "Descreva as regras de interação entre componentes (ex.: cliente avança quando caixa libera)",
                                    "Registre os fluxos sequenciais principais (ex.: chegada → processamento → saída)",
                                    "Anote dependências e loops (ex.: feedback de sobrecarga)",
                                    "Crie um fluxograma básico das interações"
                                  ],
                                  "verification": "Confira se o fluxograma cobre todas as interações identificadas no passo 1, com setas claras e labels descritivos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de fluxograma (Draw.io, Visio), quadro branco, notas do passo anterior",
                                  "tips": "Use setas direcionadas para mostrar causalidade e evite fluxos lineares irreais em sistemas discretos.",
                                  "learningObjective": "Modelar as dinâmicas relacionais do sistema através de fluxos acionáveis.",
                                  "commonMistakes": "Ignorar interações assíncronas ou probabilísticas comuns em simulações discretas"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Destacar eventos discretos e dinâmicas influenciadoras",
                                  "subSteps": [
                                    "Liste eventos discretos que alteram o estado (ex.: chegada de cliente, falha no servidor)",
                                    "Descreva probabilidades ou condições de disparo de cada evento",
                                    "Analise dinâmicas emergentes (ex.: formação de filas longas por gargalos)",
                                    "Identifique fatores externos que influenciam (ex.: horários de pico)",
                                    "Quantifique impactos iniciais onde possível (ex.: tempo médio por evento)"
                                  ],
                                  "verification": "Valide se há pelo menos 5-8 eventos listados com condições e impactos descritos em uma tabela.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Planilha (Excel ou Google Sheets) para tabela de eventos, timer para simulação mental",
                                  "tips": "Pense em 'cliques' do relógio da simulação: cada tick deve ter eventos potenciais.",
                                  "learningObjective": "Capturar a essência temporal e estocástica dos sistemas discretos.",
                                  "commonMistakes": "Tratar eventos como contínuos, perdendo a granularidade discreta"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Elaborar a narrativa coesa e detalhada",
                                  "subSteps": [
                                    "Integre componentes, fluxos e eventos em uma narrativa cronológica",
                                    "Use linguagem clara, com exemplos hipotéticos de execução",
                                    "Destaque pontos de influência no problema (ex.: gargalos que causam atrasos)",
                                    "Revise para consistência e fluidez",
                                    "Adicione resumo executivo do comportamento global"
                                  ],
                                  "verification": "Leia em voz alta: a narrativa deve fluir logicamente e cobrir todos os elementos anteriores sem contradições.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Editor de texto (Word, Google Docs), rascunhos dos passos anteriores",
                                  "tips": "Escreva como uma história: 'O sistema começa em estado X, então evento Y ocorre...'",
                                  "learningObjective": "Sintetizar análise técnica em comunicação acessível e precisa.",
                                  "commonMistakes": "Narrativa muito técnica ou vaga, sem ligar ao problema específico"
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado: Clientes chegam aleatoriamente (evento discreto), entram na fila (transição de estado), aguardam até o caixa processar itens (interação), saem após pagamento (fluxo completo). Dinâmica: filas crescem em horários de pico devido a poucos caixas, influenciando tempo médio de espera.",
                              "finalVerifications": [
                                "A narrativa cobre todos os componentes, interações e eventos identificados?",
                                "Os fluxos de trabalho são descritos de forma sequencial e lógica?",
                                "Eventos discretos e suas probabilidades/condições estão destacados?",
                                "Dinâmicas influenciadoras no problema são explicitadas?",
                                "A descrição é concisa mas detalhada, sem ambiguidades?",
                                "Um fluxograma ou diagrama suporta a narrativa?"
                              ],
                              "assessmentCriteria": [
                                "Completude: Todos os elementos do sistema (componentes, fluxos, eventos) abordados (30%)",
                                "Precisão: Descrições alinhadas ao contexto discreto, sem erros conceituais (25%)",
                                "Clareza: Linguagem acessível, narrativa fluida e bem estruturada (20%)",
                                "Detalhamento: Substância em dinâmicas e influências, com exemplos (15%)",
                                "Visualização: Uso efetivo de diagramas/fluxogramas para suporte (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação de modelos em linguagens como Python (bibliotecas SimPy)",
                                "Física: Analogia com sistemas de partículas discretas e colisões",
                                "Estatística: Análise probabilística de eventos e distribuições",
                                "Gestão de Projetos: Modelagem de fluxos em processos empresariais"
                              ],
                              "realWorldApplication": "Essa habilidade é essencial em engenharia de tráfego (simulação de semáforos e veículos discretos), logística (gerenciamento de filas em armazéns) e epidemiologia (modelos de propagação de doenças por eventos de contato discretos), permitindo prever gargalos e otimizar sistemas reais antes da implementação."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.1.3",
                            "name": "Documentar o contexto do problema",
                            "description": "Registrar o ambiente operacional, restrições reais e justificativa para a simulação, garantindo que a formulação reflita fielmente a realidade simulada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar o Ambiente Operacional",
                                  "subSteps": [
                                    "Observe o sistema real ou colete dados sobre ele.",
                                    "Liste os componentes principais (ex.: hardware, software, usuários).",
                                    "Descreva as interações e fluxos principais.",
                                    "Registre condições ambientais (ex.: temperatura, rede).",
                                    "Anote métricas iniciais relevantes (ex.: throughput atual)."
                                  ],
                                  "verification": "Verifique se a lista cobre todos os elementos observáveis e é mapeável ao sistema real.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de campo",
                                    "Fotos ou diagramas do sistema",
                                    "Entrevistas com stakeholders"
                                  ],
                                  "tips": "Use diagramas para visualizar o ambiente e evitar omissões.",
                                  "learningObjective": "Compreender e registrar fielmente o contexto físico e lógico do sistema.",
                                  "commonMistakes": [
                                    "Omitir detalhes sensoriais ou variáveis externas",
                                    "Focar apenas em componentes técnicos ignorando humanos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Documentar Restrições Reais",
                                  "subSteps": [
                                    "Identifique limitações técnicas (ex.: capacidade de processamento).",
                                    "Liste restrições de recursos (ex.: orçamento, tempo).",
                                    "Registre normas regulatórias ou éticas aplicáveis.",
                                    "Descreva dependências externas (ex.: APIs, fornecedores).",
                                    "Priorize restrições por impacto no sistema."
                                  ],
                                  "verification": "Confira se cada restrição é quantificável e vinculada a evidências reais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentos de especificação",
                                    "Relatórios de auditoria",
                                    "Planilhas de recursos"
                                  ],
                                  "tips": "Use uma tabela para categorizar restrições (alta/média/baixa prioridade).",
                                  "learningObjective": "Mapear todas as barreiras reais que afetam a simulação.",
                                  "commonMistakes": [
                                    "Ignorar restrições não técnicas como legais",
                                    "Superestimar flexibilidade de recursos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Elaborar Justificativa para a Simulação",
                                  "subSteps": [
                                    "Explique por que a simulação é necessária (ex.: custo, risco).",
                                    "Compare simulação vs. experimentos reais em termos de fidelidade.",
                                    "Defina escopo da simulação (o que modelar e o que abstrair).",
                                    "Justifique suposições com dados do ambiente real.",
                                    "Alinhe com objetivos gerais do projeto."
                                  ],
                                  "verification": "A justificativa responde 'por quê', 'como' e 'até onde' da simulação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Objetivos do projeto",
                                    "Análise custo-benefício",
                                    "Literatura sobre simulações similares"
                                  ],
                                  "tips": "Escreva em parágrafos curtos e use bullet points para clareza.",
                                  "learningObjective": "Argumentar racionalmente a escolha da simulação sobre abordagens reais.",
                                  "commonMistakes": [
                                    "Justificativas vagas sem dados",
                                    "Não mencionar trade-offs"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Compilar e Revisar o Documento Completo",
                                  "subSteps": [
                                    "Integre seções em um documento coeso com introdução e conclusão.",
                                    "Crie um sumário executivo destacando pontos chave.",
                                    "Revise por consistência e fidelidade à realidade.",
                                    "Valide com stakeholders ou pares.",
                                    "Formate com versão, data e referências."
                                  ],
                                  "verification": "Documento é legível, completo e aprovado por revisor externo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de texto (Word/Google Docs)",
                                    "Checklist de revisão",
                                    "Feedback de pares"
                                  ],
                                  "tips": "Use templates de relatório para padronização.",
                                  "learningObjective": "Produzir um artefato profissional e verificável.",
                                  "commonMistakes": [
                                    "Falta de formatação ou referências",
                                    "Inconsistências entre seções"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado: Ambiente - salão de 10x15m com 5 caixas, 200 clientes/hora; Restrições - 3 caixas disponíveis, tempo de atendimento 2min, sem filas >20 pessoas; Justificativa - testar rearranjo de caixas sem interromper operações reais, reduzindo custo em 80%.",
                              "finalVerifications": [
                                "O documento descreve o ambiente com detalhes sensoriais e mensuráveis?",
                                "Todas restrições são priorizadas e justificadas?",
                                "A justificativa liga simulação à realidade com evidências?",
                                "O texto é claro, conciso e livre de ambiguidades?",
                                "Há versionamento e referências rastreáveis?",
                                "Stakeholders confirmam fidelidade ao contexto real?"
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude na descrição do ambiente (30%)",
                                "Abrangência e priorização de restrições (25%)",
                                "Robustez da justificativa com dados (20%)",
                                "Clareza, coesão e formatação profissional (15%)",
                                "Validação externa e ausência de erros (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Redação Técnica: Estrutura de relatórios científicos",
                                "Gestão de Projetos: Análise de requisitos e riscos",
                                "Programação: Documentação de código e comentários",
                                "Análise de Sistemas: Modelagem UML e diagramas",
                                "Ética Profissional: Transparência em suposições"
                              ],
                              "realWorldApplication": "Engenheiros de software usam para requirements engineering em simulações de tráfego ou redes; cientistas em modelagem climática garantem reprodutibilidade; empresas otimizam processos logísticos sem paradas operacionais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.1.2",
                        "name": "Estabelecimento dos Objetivos da Simulação",
                        "description": "Definição explícita dos propósitos da simulação, focando em métricas de desempenho e resultados esperados para guiar todo o processo de modelagem.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.2.1",
                            "name": "Especificar medidas de desempenho",
                            "description": "Determinar indicadores quantitativos como tempo médio de espera, taxa de utilização ou throughput que a simulação deve avaliar para resolver o problema.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar o Problema e Objetivos Gerais da Simulação",
                                  "subSteps": [
                                    "Leia a descrição do problema e identifique os elementos principais do sistema discreto (ex.: filas, servidores, chegadas).",
                                    "Liste os objetivos principais da simulação, como otimizar tempo ou maximizar eficiência.",
                                    "Mapeie as variáveis de entrada e saída relevantes para o sistema.",
                                    "Discuta com stakeholders ou revise requisitos para confirmar escopo.",
                                    "Crie um diagrama simples do fluxo do sistema."
                                  ],
                                  "verification": "Verifique se há um mapa ou lista clara dos objetivos e elementos do sistema documentados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Descrição do problema, papel/caneta ou software de diagramação (ex.: Draw.io).",
                                  "tips": "Comece pelo 'porquê' da simulação para alinhar medidas aos objetivos reais.",
                                  "learningObjective": "Compreender o contexto do problema para selecionar medidas relevantes.",
                                  "commonMistakes": "Ignorar objetivos qualitativos iniciais, focando só em números sem contexto."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Medidas de Desempenho Candidatas",
                                  "subSteps": [
                                    "Pesquise medidas padrão para sistemas discretos: tempo médio de espera, taxa de utilização, throughput, tempo de ciclo.",
                                    "Classifique medidas por categoria: tempo-related, resource utilization, output rates.",
                                    "Liste 5-10 medidas potenciais baseadas no tipo de sistema (ex.: filas -> tempo de espera; produção -> throughput).",
                                    "Avalie relevância de cada medida aos objetivos identificados no Step 1.",
                                    "Priorize medidas com fórmulas matemáticas conhecidas (ex.: Little's Law para filas)."
                                  ],
                                  "verification": "Confira se há uma tabela com pelo menos 5 medidas candidatas, suas definições e relevância.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Referências de simulação (livros como 'Simulation Modeling and Analysis' de Law), planilha Excel.",
                                  "tips": "Use analogias reais: em um hospital, throughput é pacientes atendidos/hora.",
                                  "learningObjective": "Reconhecer e catalogar indicadores quantitativos apropriados para simulações.",
                                  "commonMistakes": "Escolher medidas genéricas sem ligação ao sistema específico."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Selecionar e Definir Medidas Específicas",
                                  "subSteps": [
                                    "Selecione 3-5 medidas principais com base em critérios: relevância, mensurabilidade, impacto nos objetivos.",
                                    "Defina cada medida com fórmula exata (ex.: Tempo médio de espera = soma(tempos espera)/n clientes).",
                                    "Especifique unidades (ex.: minutos, %), thresholds aceitáveis e como coletá-las na simulação.",
                                    "Crie uma tabela de especificação com nome, fórmula, unidade e objetivo alvo.",
                                    "Simule um cálculo manual com dados fictícios para validar definições."
                                  ],
                                  "verification": "Revise a tabela de medidas: cada uma deve ter fórmula, unidade e exemplo calculado.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Planilha para fórmulas (Excel/Google Sheets), calculadora.",
                                  "tips": "Garanta que medidas sejam estatisticamente robustas (médias, desvios, intervalos de confiança).",
                                  "learningObjective": "Definir indicadores quantitativos precisos e acionáveis.",
                                  "commonMistakes": "Definir medidas vagas sem fórmulas ou unidades claras."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Documentar as Medidas Escolhidas",
                                  "subSteps": [
                                    "Compare medidas com objetivos: cada uma resolve parte do problema?",
                                    "Teste sensibilidade: como mudanças em parâmetros afetam as medidas?",
                                    "Documente justificativa para seleção e exclusão de medidas.",
                                    "Revise com pares ou simulador para feedback.",
                                    "Atualize o plano de simulação com as medidas finais."
                                  ],
                                  "verification": "Documento final aprovado com justificativas e testes iniciais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documento Word/Google Docs, software de simulação básico (ex.: Simul8 trial).",
                                  "tips": "Pergunte: 'Essa medida me diz se o sistema atende o objetivo?'",
                                  "learningObjective": "Garantir alinhamento e viabilidade das medidas no contexto da simulação.",
                                  "commonMistakes": "Não validar com dados reais ou ignorar viabilidade computacional."
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado: especifique 'Tempo médio de espera dos clientes (minutos, fórmula: soma(tempos espera)/n, alvo <5 min)', 'Taxa de utilização do caixa (% tempo ocupado, alvo >80%)' e 'Throughput (clientes/hora, alvo >60)'. Calcule com 10 clientes fictícios para verificar.",
                              "finalVerifications": [
                                "Todas as medidas são quantitativas com fórmulas explícitas.",
                                "Medidas alinhadas diretamente aos objetivos da simulação.",
                                "Unidades e métodos de coleta definidos.",
                                "Exemplos de cálculo incluídos e corretos.",
                                "Justificativas para seleção fornecidas.",
                                "Thresholds ou alvos de desempenho especificados."
                              ],
                              "assessmentCriteria": [
                                "Precisão das fórmulas matemáticas (100% corretas).",
                                "Relevância e cobertura dos objetivos (cobertura >90%).",
                                "Clareza e completude da documentação (todos campos preenchidos).",
                                "Viabilidade de implementação na simulação (métodos de coleta viáveis).",
                                "Criatividade na seleção de medidas contextuais.",
                                "Ausência de erros comuns como medidas qualitativas."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Cálculo de médias, variâncias e intervalos de confiança.",
                                "Programação: Implementação de coleta de dados em código (Python/SimPy).",
                                "Engenharia Industrial: Otimização de processos e análise de gargalos.",
                                "Gestão de Operações: KPIs em logística e supply chain."
                              ],
                              "realWorldApplication": "Em fábricas, especificar throughput e utilização para otimizar linhas de produção; em call centers, tempo médio de espera para melhorar serviço ao cliente; em redes de TI, latência e taxa de perda para dimensionar servidores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.2.2",
                            "name": "Priorizar objetivos principais e secundários",
                            "description": "Classificar os objetivos por relevância, distinguindo metas críticas de análises complementares, alinhando com as necessidades do tomador de decisão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e listar todos os objetivos potenciais da simulação",
                                  "subSteps": [
                                    "Analise o problema de simulação e extraia objetivos implícitos e explícitos do contexto.",
                                    "Consulte o tomador de decisão para coletar expectativas e metas desejadas.",
                                    "Registre todos os objetivos em uma lista inicial sem julgamento prévio.",
                                    "Agrupe objetivos semelhantes para evitar duplicatas.",
                                    "Defina métricas mensuráveis para cada objetivo listado."
                                  ],
                                  "verification": "Verifique se a lista contém pelo menos 5-10 objetivos abrangentes e se todos têm métricas associadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta ou planilha digital (Google Sheets ou Excel), documento do problema de simulação.",
                                  "tips": "Use brainstorming livre para capturar ideias iniciais sem censura.",
                                  "learningObjective": "Compreender o escopo completo dos objetivos para uma base sólida de priorização.",
                                  "commonMistakes": "Ignorar objetivos secundários ou assumir objetivos sem consulta ao stakeholder."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Avaliar a relevância e criticidade de cada objetivo",
                                  "subSteps": [
                                    "Classifique cada objetivo quanto ao impacto no sucesso geral da simulação (alto, médio, baixo).",
                                    "Avalie o alinhamento com as necessidades principais do tomador de decisão.",
                                    "Pontue cada objetivo em uma escala de 1-10 considerando urgência, custo e viabilidade.",
                                    "Identifique dependências entre objetivos (ex.: um principal depende de um secundário).",
                                    "Documente justificativas para cada pontuação."
                                  ],
                                  "verification": "Confira se todos os objetivos têm pontuações e justificativas registradas em uma tabela de avaliação.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Planilha de avaliação com colunas para pontuação, impacto e justificativa.",
                                  "tips": "Priorize critérios SMART (Específico, Mensurável, Alcançável, Relevante, Temporal) na avaliação.",
                                  "learningObjective": "Desenvolver critérios objetivos para medir relevância e alinhamento.",
                                  "commonMistakes": "Subjetividade excessiva sem critérios claros ou viés pessoal na pontuação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Classificar e priorizar objetivos em principais e secundários",
                                  "subSteps": [
                                    "Separe objetivos com pontuação >7 como principais (críticos).",
                                    "Classifique os restantes como secundários (complementares).",
                                    "Ordene principais por ordem de prioridade (top 3-5) e secundários por relevância decrescente.",
                                    "Crie uma hierarquia visual (ex.: diagrama ou lista numerada).",
                                    "Ajuste com base em restrições de tempo/recursos da simulação."
                                  ],
                                  "verification": "Valide se há pelo menos 2-3 objetivos principais claramente destacados e ordenados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Ferramenta de diagramação (Draw.io ou PowerPoint), planilha atualizada.",
                                  "tips": "Use matriz Eisenhower (urgente/importante) para refinar a classificação.",
                                  "learningObjective": "Aplicar técnicas de priorização para distinguir metas críticas de complementares.",
                                  "commonMistakes": "Sobrecarregar a lista de principais ou ignorar trade-offs entre objetivos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Documentar a priorização e validar com stakeholders",
                                  "subSteps": [
                                    "Elabore um relatório resumido com lista priorizada, justificativas e métricas.",
                                    "Apresente a priorização ao tomador de decisão para feedback.",
                                    "Incorpore ajustes baseados no feedback recebido.",
                                    "Defina critérios de sucesso para cada nível de objetivo.",
                                    "Arquive a documentação para referência futura na simulação."
                                  ],
                                  "verification": "Obtenha aprovação escrita ou verbal do stakeholder e versão final do relatório.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documento Word/PDF, ferramenta de videoconferência (Zoom) para validação.",
                                  "tips": "Prepare perguntas abertas para o feedback: 'Isso reflete suas prioridades?'",
                                  "learningObjective": "Garantir alinhamento e consenso na priorização de objetivos.",
                                  "commonMistakes": "Pular a validação ou resistir a mudanças baseadas em feedback."
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado, objetivos principais: (1) Reduzir tempo médio de espera para <5 minutos; (2) Maximizar throughput de clientes (>100/hora). Secundários: (1) Otimizar alocação de caixas; (2) Analisar picos de demanda. Priorize principais para focar em satisfação do cliente, alinhando com metas do gerente.",
                              "finalVerifications": [
                                "Lista completa de objetivos identificados e avaliados.",
                                "Classificação clara em principais (críticos) e secundários (complementares).",
                                "Hierarquia priorizada com justificativas documentadas.",
                                "Alinhamento confirmado com necessidades do tomador de decisão.",
                                "Métricas mensuráveis definidas para todos os objetivos.",
                                "Relatório final aprovado por stakeholders."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude na identificação de objetivos (cobertura >90%).",
                                "Objetividade na avaliação de relevância (uso de escalas/critérios claros).",
                                "Equilíbrio na classificação (2-4 principais, resto secundários).",
                                "Qualidade da documentação e visualização da priorização.",
                                "Evidência de validação com stakeholders e ajustes incorporados.",
                                "Alinhamento com contexto da simulação de sistemas discretos."
                              ],
                              "crossCurricularConnections": [
                                "Gestão de Projetos: Técnicas de priorização MoSCoW (Must, Should, Could, Won't).",
                                "Engenharia de Software: Análise de requisitos e user stories.",
                                "Administração: Tomada de decisão baseada em valor e risco.",
                                "Estatística: Avaliação de impacto via análise de sensibilidade."
                              ],
                              "realWorldApplication": "Na indústria, como em simulações de supply chain para empresas como Amazon, priorizar objetivos principais (ex.: reduzir custos logísticos) garante foco em KPIs críticos, otimizando investimentos e decisões estratégicas em cenários de alta complexidade."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.2.3",
                            "name": "Alinhar objetivos com hipóteses iniciais",
                            "description": "Formular hipóteses testáveis relacionadas aos objetivos, preparando o terreno para experimentos de simulação subsequentes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar e Esclarecer os Objetivos da Simulação",
                                  "subSteps": [
                                    "Leia atentamente a descrição do problema de simulação.",
                                    "Liste os objetivos principais em termos SMART (Específicos, Mensuráveis, Alcançáveis, Relevantes, Temporais).",
                                    "Identifique métricas chave para medir o sucesso dos objetivos (ex.: tempo médio, taxa de utilização).",
                                    "Priorize os objetivos por importância para o problema.",
                                    "Registre os objetivos em um documento estruturado."
                                  ],
                                  "verification": "Verifique se todos os objetivos estão listados de forma clara, mensurável e priorizados em um documento.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Descrição do problema, editor de texto ou papel e caneta",
                                  "tips": "Use verbos acionáveis como 'reduzir', 'aumentar' ou 'otimizar' para tornar objetivos precisos.",
                                  "learningObjective": "Compreender e articular objetivos claros da simulação para guiar as hipóteses.",
                                  "commonMistakes": "Definir objetivos vagos como 'melhorar o sistema' sem métricas específicas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Elementos Chave do Problema",
                                  "subSteps": [
                                    "Mapeie as variáveis principais do sistema discreto (entradas, saídas, estados).",
                                    "Desenhe um diagrama simples do fluxo do sistema (ex.: fluxograma).",
                                    "Liste suposições iniciais sobre relações entre variáveis.",
                                    "Destaque incertezas ou pontos de dúvida no comportamento do sistema.",
                                    "Conecte cada elemento aos objetivos revisados."
                                  ],
                                  "verification": "Confirme a existência de um diagrama ou lista que conecta elementos aos objetivos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel, caneta ou software de diagramação como Draw.io",
                                  "tips": "Comece com 'O que acontece se...?' para identificar relações potenciais.",
                                  "learningObjective": "Mapear componentes do sistema para fundamentar hipóteses alinhadas.",
                                  "commonMistakes": "Ignorar variáveis secundárias que impactam os objetivos principais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular Hipóteses Testáveis Iniciais",
                                  "subSteps": [
                                    "Gere 3-5 hipóteses baseadas nos elementos chave e objetivos.",
                                    "Estruture cada hipótese no formato: 'Se [ação/variável], então [efeito mensurável]'.",
                                    "Garanta que cada hipótese seja falsificável e mensurável via simulação.",
                                    "Associe explicitamente cada hipótese a pelo menos um objetivo.",
                                    "Revise para eliminar redundâncias."
                                  ],
                                  "verification": "Liste de hipóteses com formato padrão, associadas a objetivos e mensuráveis.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Lista de objetivos e diagrama do sistema, editor de texto",
                                  "tips": "Use dados históricos ou conhecimento domínio para embasar hipóteses realistas.",
                                  "learningObjective": "Criar hipóteses específicas e testáveis ligadas aos objetivos.",
                                  "commonMistakes": "Criar hipóteses não testáveis como 'o sistema é eficiente' sem métricas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Alinhar e Refinar Hipóteses com Objetivos",
                                  "subSteps": [
                                    "Compare cada hipótese com os objetivos para verificar cobertura completa.",
                                    "Ajuste hipóteses para preencher lacunas nos objetivos.",
                                    "Teste logicamente o alinhamento: 'Essa hipótese responde ao objetivo?'.",
                                    "Priorize hipóteses por impacto potencial nos objetivos.",
                                    "Documente o alinhamento final em uma tabela (objetivo x hipótese)."
                                  ],
                                  "verification": "Tabela de alinhamento completa mostrando cobertura de todos os objetivos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Lista de hipóteses e objetivos, planilha ou tabela em editor de texto",
                                  "tips": "Use cores ou símbolos na tabela para destacar alinhamentos fortes/fracos.",
                                  "learningObjective": "Refinar hipóteses para total alinhamento com objetivos da simulação.",
                                  "commonMistakes": "Deixar hipóteses desalinhadas, focando em curiosidades irrelevantes."
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado (sistema discreto), objetivo: 'Reduzir tempo médio de espera para <5 minutos'. Hipótese alinhada: 'Se aumentar o número de caixas de 3 para 5, então o tempo médio de espera diminuirá em 40%, medido por 1000 simulações'.",
                              "finalVerifications": [
                                "Todas as hipóteses estão no formato 'Se-então' e são mensuráveis.",
                                "Cada objetivo tem pelo menos uma hipótese diretamente alinhada.",
                                "Hipóteses cobrem pelo menos 80% das métricas chave dos objetivos.",
                                "Não há hipóteses redundantes ou não testáveis.",
                                "Documentação inclui tabela de alinhamento clara.",
                                "Hipóteses preparam logicamente para experimentos de simulação."
                              ],
                              "assessmentCriteria": [
                                "Clareza e precisão dos objetivos (SMART).",
                                "Testabilidade e falsificabilidade das hipóteses.",
                                "Grau de alinhamento entre hipóteses e objetivos (cobertura completa).",
                                "Profundidade do mapeamento de elementos do problema.",
                                "Qualidade da documentação (diagramas, tabelas).",
                                "Realismo e relevância das hipóteses ao contexto discreto."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Formulação de testes de hipótese e análise de variância.",
                                "Programação: Preparação para codificação de simulações em Python ou R.",
                                "Ciências: Método científico aplicado a modelagem de sistemas.",
                                "Gestão de Projetos: Definição de metas e validação de premissas."
                              ],
                              "realWorldApplication": "Em engenharia de processos industriais, alinhar objetivos de otimização de produção (ex.: maximizar throughput) com hipóteses sobre gargalos, permitindo simulações que evitam custos reais de testes físicos, como em fábricas de automóveis ou logística de supply chain."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.1.3",
                        "name": "Delimitação do Escopo e Limitações",
                        "description": "Estabelecimento dos limites do problema simulado, identificando o que será incluído ou excluído para manter a viabilidade e relevância do modelo.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.3.1",
                            "name": "Identificar variáveis relevantes",
                            "description": "Selecionar variáveis de entrada, estado e saída essenciais ao problema, baseando-se na definição inicial e objetivos estabelecidos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definição Inicial e Objetivos do Problema",
                                  "subSteps": [
                                    "Leia atentamente a descrição inicial do problema de simulação.",
                                    "Identifique os objetivos principais da simulação (o que se quer prever ou analisar).",
                                    "Anote palavras-chave que indiquem elementos dinâmicos ou mensuráveis.",
                                    "Liste perguntas guias: O que influencia o sistema? O que muda ao longo do tempo? O que queremos medir?",
                                    "Crie um mapa mental preliminar conectando objetivos a possíveis elementos variáveis."
                                  ],
                                  "verification": "Verifique se há uma lista anotada de objetivos e palavras-chave extraídas da definição inicial.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documento do problema, papel e caneta ou software de mind mapping (ex: XMind, Draw.io)",
                                  "tips": "Foquem em separar fatos descritivos de elementos que variam; ignore detalhes irrelevantes inicialmente.",
                                  "learningObjective": "Compreender o escopo do problema para guiar a identificação de variáveis.",
                                  "commonMistakes": "Confundir descrições estáticas (ex: 'loja aberta') com variáveis dinâmicas; pular a revisão detalhada."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Variáveis de Entrada Potenciais",
                                  "subSteps": [
                                    "Liste fatores externos que afetam o sistema (ex: chegadas aleatórias, parâmetros configuráveis).",
                                    "Classifique-as como determinísticas (fixas) ou estocásticas (aleatórias).",
                                    "Quantifique quando possível (ex: taxa de chegada por hora).",
                                    "Relacione cada variável de entrada aos objetivos da simulação.",
                                    "Elimine entradas irrelevantes comparando com o escopo delimitado."
                                  ],
                                  "verification": "Crie uma tabela com colunas: Nome da Variável, Tipo (Determinística/Estocástica), Impacto nos Objetivos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Planilha (Google Sheets ou Excel), documento do problema",
                                  "tips": "Use distribuições probabilísticas conhecidas (ex: Poisson para chegadas) para inspirar identificações.",
                                  "learningObjective": "Reconhecer entradas como drivers iniciais do sistema discreto.",
                                  "commonMistakes": "Incluir variáveis de controle como entradas; superestimar o número de entradas desnecessárias."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar Variáveis de Estado e Saída Essenciais",
                                  "subSteps": [
                                    "Defina variáveis de estado como aquelas que evoluem no tempo (ex: fila atual, inventário).",
                                    "Identifique saídas como métricas finais ou agregadas (ex: tempo médio de espera, throughput).",
                                    "Garanta que estados capturem a dinâmica discreta (eventos discretos mudam estados).",
                                    "Priorize baseando-se em objetivos: quais estados levam às saídas desejadas?",
                                    "Valide interdependências: entradas → estados → saídas."
                                  ],
                                  "verification": "Desenhe um diagrama de fluxo: Entradas → Estados → Saídas, com setas indicando relações.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software de diagramação (Draw.io, Lucidchart), papel",
                                  "tips": "Pense em 'instantâneos' do sistema em eventos discretos para estados.",
                                  "learningObjective": "Diferenciar estados (internos dinâmicos) de saídas (resultados mensuráveis).",
                                  "commonMistakes": "Confundir saídas com estados; omitir estados críticos que propagam efeitos de entradas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Selecionar e Documentar Variáveis Relevantes",
                                  "subSteps": [
                                    "Revise todas as listas e selecione apenas as essenciais (minimal set para objetivos).",
                                    "Justifique cada seleção com ligação direta ao problema e limitações de escopo.",
                                    "Defina unidades, domínios e precisão para cada variável.",
                                    "Documente em formato tabular: Categoria (Entrada/Estado/Saída), Nome, Descrição, Justificativa.",
                                    "Realize uma auto-revisão: 'Esta variável é necessária para simular o comportamento alvo?'"
                                  ],
                                  "verification": "Tabela final completa com pelo menos 3-5 variáveis categorizadas e justificadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Planilha ou documento Word/Google Docs",
                                  "tips": "Aplique o princípio de Pareto: 20% das variáveis cobrem 80% do impacto na simulação.",
                                  "learningObjective": "Refinar seleções para um modelo enxuto e focado.",
                                  "commonMistakes": "Sobrecarregar com variáveis marginais; falta de justificativas claras."
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado: Entradas (taxa de chegada de clientes ~ Poisson(λ=10/hora), tempo de serviço ~ Expo(μ=5 min)); Estados (número de clientes na fila, servidor ocupado?); Saídas (tempo médio de espera, taxa de abandono). Justificativa: Foco em otimizar staffing para reduzir esperas.",
                              "finalVerifications": [
                                "Lista de variáveis categorizadas (entrada, estado, saída) está completa e sem duplicatas.",
                                "Cada variável tem justificativa ligada aos objetivos e escopo.",
                                "Diagrama de fluxo mostra relações lógicas entre variáveis.",
                                "Conjunto é minimal: remoção de qualquer uma altera resultados chave.",
                                "Unidades e domínios definidos para todas variáveis.",
                                "Nenhuma variável estática ou irrelevante incluída."
                              ],
                              "assessmentCriteria": [
                                "Precisão na categorização (entrada/estado/saída): 30%",
                                "Relevância e minimalismo do conjunto selecionado: 25%",
                                "Qualidade das justificativas e ligações aos objetivos: 20%",
                                "Clareza na documentação (tabelas, diagramas): 15%",
                                "Identificação de dinâmicas discretas específicas: 10%"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Definição de variáveis em código para simulações (ex: Python com SimPy).",
                                "Estatística: Modelagem de variáveis estocásticas (distribuições probabilísticas).",
                                "Física: Analogia com grandezas cinemáticas em sistemas discretos (ex: partículas em rede).",
                                "Engenharia de Software: Modelagem UML para estados e transições."
                              ],
                              "realWorldApplication": "Em simulações epidemiológicas como modelar COVID-19: entradas (taxa de contato, mobilidade), estados (infectados suscetíveis), saídas (pico de casos), essencial para prever surtos e testar políticas de lockdown."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.3.2",
                            "name": "Definir fronteiras do modelo",
                            "description": "Estabelecer os limites geográficos, temporais e funcionais do sistema simulado, evitando complexidade desnecessária.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar limites espaciais ou geográficos",
                                  "subSteps": [
                                    "Analise o sistema real e liste os componentes espaciais relevantes.",
                                    "Desenhe um diagrama esquemático destacando a área de interesse.",
                                    "Defina as bordas externas, excluindo elementos periféricos irrelevantes.",
                                    "Documente as dimensões (ex: comprimento, área) em unidades apropriadas.",
                                    "Justifique a escolha com base na relevância para o problema."
                                  ],
                                  "verification": "Verifique se o diagrama cobre apenas o escopo essencial sem vazamentos espaciais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel, caneta, software de diagramação (ex: Draw.io), descrição do sistema.",
                                  "tips": "Comece amplo e refine progressivamente para evitar omissões.",
                                  "learningObjective": "Compreender e delimitar o espaço físico do modelo de simulação.",
                                  "commonMistakes": "Incluir áreas muito amplas que aumentam complexidade computacional."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir limites temporais",
                                  "subSteps": [
                                    "Determine o intervalo de tempo inicial e final da simulação.",
                                    "Especifique o passo de tempo (ex: segundos, dias) com base na dinâmica do sistema.",
                                    "Identifique eventos de início e fim que delimitam o período.",
                                    "Calcule a duração total e verifique viabilidade computacional.",
                                    "Registre condições iniciais e finais esperadas."
                                  ],
                                  "verification": "Confirme se o intervalo temporal cobre o fenômeno de interesse sem extensão desnecessária.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Cronograma do sistema real, calculadora, planilha para timelines.",
                                  "tips": "Use dados históricos para ancorar o período realista.",
                                  "learningObjective": "Estabelecer um horizonte temporal preciso e eficiente para a simulação.",
                                  "commonMistakes": "Escolher passos de tempo muito pequenos, levando a alto custo computacional."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estabelecer limites funcionais e de variáveis",
                                  "subSteps": [
                                    "Liste todas as variáveis e funções do sistema dentro do escopo.",
                                    "Exclua comportamentos secundários ou raros que não afetem o objetivo principal.",
                                    "Defina regras de interação apenas para elementos dentro das fronteiras.",
                                    "Priorize variáveis essenciais e marque as simplificações assumidas.",
                                    "Crie uma tabela de inclusão/exclusão de funções."
                                  ],
                                  "verification": "Teste conceitualmente se o modelo ainda responde ao problema sem funções extras.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Lista de variáveis do problema, tabela em Excel ou similar.",
                                  "tips": "Pergunte: 'Isso afeta o resultado principal?' para decidir inclusão.",
                                  "learningObjective": "Delimitar comportamentos e variáveis para manter o modelo focado.",
                                  "commonMistakes": "Sobrecarregar com funções marginais, complicando a implementação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e refinar as fronteiras",
                                  "subSteps": [
                                    "Revise todas as fronteiras em conjunto com stakeholders ou documentação.",
                                    "Simule mentalmente ou com protótipo simples para detectar vazamentos.",
                                    "Ajuste limites para minimizar complexidade sem perder fidelidade.",
                                    "Documente assunções e impactos potenciais de simplificações.",
                                    "Obtenha aprovação ou feedback iterativo."
                                  ],
                                  "verification": "As fronteiras resultam em um modelo simples, mas representativo?",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Diagrama completo, checklist de validação, notas de revisão.",
                                  "tips": "Use a regra 80/20: capture 80% do valor com 20% da complexidade.",
                                  "learningObjective": "Garantir que as fronteiras sejam robustas e otimizadas.",
                                  "commonMistakes": "Ignorar feedback, resultando em escopo irrealista."
                                }
                              ],
                              "practicalExample": "Na simulação de uma fila de supermercado: limites espaciais - 5 caixas registradoras e área de 10x10m; temporais - 1 hora de pico (das 18h às 19h), passo de 1 minuto; funcionais - chegadas Poisson, atendimento FIFO, sem trocas de fila ou itens especiais.",
                              "finalVerifications": [
                                "Fronteiras espaciais estão claramente diagramadas e justificadas?",
                                "Intervalo temporal é adequado e computacionalmente viável?",
                                "Limites funcionais excluem apenas elementos irrelevantes?",
                                "Documentação inclui assunções e potenciais impactos?",
                                "Modelo simplificado ainda responde ao objetivo principal?",
                                "Não há vazamentos (interações externas não modeladas)?"
                              ],
                              "assessmentCriteria": [
                                "Clareza e precisão na descrição das fronteiras (20%)",
                                "Justificativa lógica para inclusões/exclusões (25%)",
                                "Equilíbrio entre simplicidade e fidelidade ao sistema real (25%)",
                                "Viabilidade computacional demonstrada (15%)",
                                "Documentação completa e organizada (15%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Definição de arrays e loops com bounds fixos.",
                                "Geografia: Escalas cartográficas e delimitação de territórios.",
                                "Física: Fronteiras em sistemas dinâmicos (ex: campos de força).",
                                "Gestão de Projetos: Definição de escopo para evitar scope creep."
                              ],
                              "realWorldApplication": "Em modelagem de epidemias, define-se fronteiras geográficas (uma cidade), temporais (6 meses) e funcionais (transmissão básica, sem mutações), permitindo simulações eficientes para políticas públicas sem sobrecarga computacional."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.3.3",
                            "name": "Reconhecer limitações e suposições",
                            "description": "Listar restrições inerentes ao problema, como dados disponíveis ou simplificações necessárias, documentando impactos potenciais na simulação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar o problema para identificar restrições inerentes",
                                  "subSteps": [
                                    "Leia a declaração do problema várias vezes, destacando elementos como dados disponíveis, recursos computacionais e tempo de simulação.",
                                    "Liste todas as restrições explícitas mencionadas, como tamanho da amostra de dados ou precisão numérica permitida.",
                                    "Identifique restrições implícitas, como limitações de hardware ou software usado na simulação.",
                                    "Categorize as restrições em tipos: de dados, computacionais, temporais e de modelo.",
                                    "Quantifique onde possível, ex.: 'Dados limitados a 1000 pontos'."
                                  ],
                                  "verification": "Verifique se a lista inicial tem pelo menos 4-6 restrições categorizadas e quantificadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Declaração do problema impressa ou digital, caderno ou editor de texto, caneta ou software de notas (ex.: Notion, Markdown).",
                                  "tips": "Use bullet points para organizar e revise a lista com uma segunda leitura do problema.",
                                  "learningObjective": "Desenvolver habilidade em extrair e categorizar restrições de forma sistemática de uma descrição de problema.",
                                  "commonMistakes": "Ignorar restrições implícitas ou confundir restrições com suposições."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Reconhecer e listar suposições feitas no modelo",
                                  "subSteps": [
                                    "Pergunte: 'Quais premissas foram feitas para simplificar o problema real?' como independência de variáveis ou distribuições probabilísticas assumidas.",
                                    "Liste suposições sobre o sistema discreto, ex.: 'Estados transitórios são negligenciados' ou 'Eventos são independentes'.",
                                    "Avalie a validade de cada suposição com base em conhecimento domínio-específico.",
                                    "Documente fontes das suposições, como literatura ou dados empíricos.",
                                    "Marque suposições sensíveis que possam afetar resultados significativamente."
                                  ],
                                  "verification": "Confirme que há 3-5 suposições listadas, cada uma com justificativa e marca de sensibilidade.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Referências bibliográficas ou dados iniciais do problema, planilha (ex.: Google Sheets) para tabular suposições.",
                                  "tips": "Use a técnica '5 Whys' para cavar suposições subjacentes.",
                                  "learningObjective": "Capacitar o aluno a detectar suposições ocultas e avaliar sua robustez.",
                                  "commonMistakes": "Listar fatos como suposições ou subestimar suposições triviais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Documentar impactos potenciais de limitações e suposições",
                                  "subSteps": [
                                    "Para cada restrição/suposição, descreva cenários de impacto: ex.: 'Dados limitados podem causar viés de amostragem'.",
                                    "Classifique impactos por severidade (baixa, média, alta) e probabilidade de ocorrência.",
                                    "Simule qualitativamente o efeito na simulação, como erro de propagação ou instabilidade numérica.",
                                    "Sugira mitigações iniciais, como coleta de mais dados ou testes de sensibilidade.",
                                    "Crie uma tabela resumindo: item, impacto, severidade, mitigação."
                                  ],
                                  "verification": "Revise a tabela para garantir que todo item tenha impacto e classificação documentados.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Planilha ou documento (ex.: Excel, LaTeX), diagramas de fluxo se aplicável.",
                                  "tips": "Priorize impactos de alta severidade para análise mais profunda.",
                                  "learningObjective": "Ensinar a prever e quantificar riscos de limitações na fidelidade da simulação.",
                                  "commonMistakes": "Ser vago nos impactos, como 'pode afetar resultados' sem especificar como."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Revisar e consolidar a documentação final",
                                  "subSteps": [
                                    "Compile todas as listas em um relatório unificado com seções claras.",
                                    "Cruzar-verifique com stakeholders ou pares para validação.",
                                    "Atualize com novas insights da análise anterior.",
                                    "Inclua um resumo executivo destacando top 3 limitações/suposições críticas.",
                                    "Planeje próximos passos, como validação experimental."
                                  ],
                                  "verification": "O relatório final deve ser legível, completo e aprovado por auto-revisão ou peer review.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documento final (ex.: Word, PDF), ferramenta de revisão (ex.: Grammarly).",
                                  "tips": "Mantenha linguagem objetiva e use gráficos para visualização de severidades.",
                                  "learningObjective": "Fomentar hábitos de documentação rigorosa para transparência em simulações.",
                                  "commonMistakes": "Omitir resumo ou falhar em priorizar itens críticos."
                                }
                              ],
                              "practicalExample": "Ao simular um sistema de filas em um call center discreto, reconheça limitações como 'dados históricos de apenas 6 meses (viés sazonal)' e suposições como 'chegadas de chamadas seguem Poisson (ignora picos promocionais)', documentando que isso pode superestimar tempo de espera em 20%.",
                              "finalVerifications": [
                                "Lista completa de pelo menos 8 itens (restrições + suposições) com categorização.",
                                "Cada item tem impacto documentado e classificado por severidade.",
                                "Relatório inclui tabela resumida e resumo executivo.",
                                "Todas as suposições têm justificativa ou fonte.",
                                "Mitigações sugeridas para itens de alta severidade.",
                                "Documento é claro, sem ambiguidades e pronto para compartilhamento."
                              ],
                              "assessmentCriteria": [
                                "Completude: Cobertura exaustiva de restrições e suposições (90%+).",
                                "Precisão: Identificação correta baseada no contexto do problema.",
                                "Profundidade de análise: Impactos bem articulados e quantificados.",
                                "Clareza na documentação: Estrutura lógica e linguagem acessível.",
                                "Criatividade em mitigações: Soluções práticas e viáveis.",
                                "Alinhamento com objetivos da simulação: Foco em relevância para resultados."
                              ],
                              "crossCurricularConnections": [
                                "Filosofia da Ciência: Questionamento de suposições epistemológicas em modelos.",
                                "Estatística: Análise de viés e variância devido a limitações de dados.",
                                "Engenharia de Software: Documentação de trade-offs em design de simulações.",
                                "Gestão de Projetos: Avaliação de riscos e planejamento de contingências."
                              ],
                              "realWorldApplication": "Em simulações epidemiológicas como previsão de surtos (ex.: COVID-19), reconhecer limitações de dados de mobilidade e suposições de taxa de transmissão constante permite documentar incertezas, guiando políticas públicas mais robustas e evitando overconfidence em previsões."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.2",
                    "name": "Construção do Modelo Conceitual",
                    "description": "Desenvolvimento do modelo abstrato que representa o sistema real.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.2.1.1",
                        "name": "Análise Preliminar do Sistema Real",
                        "description": "Estudo inicial e detalhado do sistema real para compreender suas componentes, comportamentos e dinâmicas, servindo como base para a abstração conceitual.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.1.1.1",
                            "name": "Identificar entidades e recursos do sistema",
                            "description": "Reconhecer e listar as entidades principais (como clientes, servidores, máquinas) e recursos compartilhados no sistema real, diferenciando-os com base em suas funções e interações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Entidades e Recursos",
                                  "subSteps": [
                                    "Estude a definição de entidade: elementos ativos ou passivos que possuem estado e participam de eventos no sistema.",
                                    "Analise a definição de recurso: elementos compartilhados e limitados, como servidores ou máquinas, que podem ser alocados a entidades.",
                                    "Diferencie entidades de recursos com exemplos iniciais simples.",
                                    "Revise interações típicas entre entidades e recursos.",
                                    "Anote as principais características funcionais de cada um."
                                  ],
                                  "verification": "Criar um glossário pessoal com definições e 3 exemplos de cada, sem erros conceituais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro-texto de simulação discreta",
                                    "Notas em papel ou editor de texto"
                                  ],
                                  "tips": "Use diagramas Venn para visualizar diferenças entre entidades e recursos.",
                                  "learningObjective": "Diferenciar conceitualmente entidades e recursos em sistemas discretos.",
                                  "commonMistakes": "Confundir entidades passivas (como itens) com recursos compartilhados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Observar e Descrever o Sistema Real",
                                  "subSteps": [
                                    "Escolha um sistema real para análise (ex: fila de supermercado).",
                                    "Observe o sistema por pelo menos 10 minutos, registrando todos os elementos visíveis.",
                                    "Registre eventos, estados e fluxos observados.",
                                    "Identifique padrões de movimento e alocação de elementos.",
                                    "Documente observações em um diário de campo com timestamps."
                                  ],
                                  "verification": "Produzir um relatório de observação com pelo menos 10 elementos anotados e fotos ou esboços.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Bloco de notas",
                                    "Celular para fotos/vídeos",
                                    "Cronômetro"
                                  ],
                                  "tips": "Observe em horários de pico para captar interações intensas.",
                                  "learningObjective": "Coletar dados empíricos do sistema real para basear a identificação.",
                                  "commonMistakes": "Ignorar elementos secundários que impactam o fluxo principal."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Listar e Categorizar Entidades e Recursos",
                                  "subSteps": [
                                    "Compile a lista inicial de todos os elementos observados.",
                                    "Classifique cada elemento como entidade (ativa/passiva) ou recurso (compartilhado).",
                                    "Agrupe por funções semelhantes (ex: entidades móveis, recursos fixos).",
                                    "Quantifique quando possível (ex: número aproximado de cada).",
                                    "Crie uma tabela com colunas: Nome, Tipo, Função Principal."
                                  ],
                                  "verification": "Gerar uma tabela categorizada com pelo menos 5 entidades e 3 recursos identificados.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets",
                                    "Relatório de observação do passo anterior"
                                  ],
                                  "tips": "Use cores na tabela para diferenciar tipos visualmente.",
                                  "learningObjective": "Listar de forma organizada os componentes principais do sistema.",
                                  "commonMistakes": "Sobrecarregar a lista com elementos irrelevantes ao modelo conceitual."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar Funções e Mapear Interações",
                                  "subSteps": [
                                    "Para cada entidade/recursos, descreva sua função específica e interações.",
                                    "Desenhe um diagrama de fluxo mostrando como entidades acessam recursos.",
                                    "Identifique gargalos ou pontos de compartilhamento.",
                                    "Valide com referências teóricas ou segunda observação.",
                                    "Refine a lista removendo ou ajustando itens incorretos."
                                  ],
                                  "verification": "Produzir um diagrama de interações validado por auto-revisão ou peer-review.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Ferramenta de diagramação como Draw.io ou papel",
                                    "Tabela do passo 3"
                                  ],
                                  "tips": "Comece com setas simples para interações antes de complexificar.",
                                  "learningObjective": "Mapear relações funcionais entre entidades e recursos.",
                                  "commonMistakes": "Assumir interações sem evidência observacional."
                                }
                              ],
                              "practicalExample": "Em uma simulação de call center: Entidades principais incluem 'chamadas de clientes' (chegam aleatoriamente, possuem estado: aguardando/atendida) e 'agentes humanos' (movem-se entre estados livres/ocupados). Recursos compartilhados são 'linhas telefônicas' (limitadas, alocadas a chamadas) e 'computadores' (compartilhados por agentes). Interações: Chamadas competem por linhas e agentes.",
                              "finalVerifications": [
                                "Lista contém pelo menos 80% das entidades e recursos principais observadas.",
                                "Cada item possui função e interações claramente descritas.",
                                "Diagrama de interações reflete observações reais sem contradições.",
                                "Diferenciação entre entidades e recursos é consistente com definições teóricas.",
                                "Quantificações aproximadas são realistas baseadas em observação.",
                                "Não há duplicatas ou itens irrelevantes na lista final."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: Correta distinção entre entidades e recursos (30%).",
                                "Completude: Cobertura de todos os elementos principais (25%).",
                                "Detalhamento funcional: Descrições claras de funções e interações (20%).",
                                "Qualidade do diagrama: Visualização clara e lógica (15%).",
                                "Evidência empírica: Suporte por observações documentadas (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Análise de Sistemas: Modelagem de fluxos em engenharia de software.",
                                "Programação Orientada a Objetos: Entidades como classes com atributos e métodos.",
                                "Matemática Discreta: Grafos para representar interações.",
                                "Gestão de Operações: Identificação de recursos em cadeias de suprimentos."
                              ],
                              "realWorldApplication": "Na simulação de logística hospitalar, identificar pacientes (entidades) e leitos/cirurgias (recursos) permite otimizar alocações, reduzindo tempos de espera e melhorando eficiência operacional em cenários reais como pandemias."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.1.2",
                            "name": "Definir variáveis de estado e eventos",
                            "description": "Determinar as variáveis que representam o estado atual do sistema (ex.: número de itens em fila) e os eventos que causam mudanças de estado, como chegadas e partidas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar o sistema real e identificar seus componentes principais",
                                  "subSteps": [
                                    "Descreva o sistema em termos simples, focando em fluxos de entrada, processamento e saída.",
                                    "Identifique entidades chave (ex.: clientes, itens, máquinas).",
                                    "Mapeie o comportamento dinâmico do sistema ao longo do tempo.",
                                    "Crie um diagrama de fluxo básico do sistema.",
                                    "Liste atributos relevantes das entidades."
                                  ],
                                  "verification": "Diagrama de fluxo completo com entidades e fluxos identificados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel, caneta, software de diagramação como Draw.io ou Lucidchart.",
                                  "tips": "Comece com observações reais do sistema para evitar suposições.",
                                  "learningObjective": "Compreender a estrutura estática e dinâmica do sistema.",
                                  "commonMistakes": "Ignorar aspectos não óbvios, como filas ocultas ou estados inativos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar eventos que causam mudanças no sistema",
                                  "subSteps": [
                                    "Liste todos os eventos possíveis que alteram o sistema (ex.: chegada, partida, falha).",
                                    "Classifique eventos como internos ou externos.",
                                    "Defina condições de disparo para cada evento.",
                                    "Ordene eventos por frequência e impacto.",
                                    "Verifique se eventos cobrem todos os cenários de mudança."
                                  ],
                                  "verification": "Lista exaustiva de eventos com classificações e condições.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha ou tabela em Excel/Google Sheets para listar eventos.",
                                  "tips": "Pense em 'o que pode acontecer de repente?' para capturar eventos raros.",
                                  "learningObjective": "Reconhecer triggers de transições de estado.",
                                  "commonMistakes": "Confundir eventos com estados ou omitir eventos compostos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir variáveis de estado que representam o estado atual",
                                  "subSteps": [
                                    "Selecione variáveis numéricas ou categóricas que capturem o estado completo (ex.: número em fila, status da máquina).",
                                    "Garanta minimalidade: variáveis independentes e suficientes.",
                                    "Atribua tipos de dados e domínios (ex.: inteiro não-negativo).",
                                    "Descreva como cada variável muda com eventos.",
                                    "Crie uma tabela de estado inicial e exemplos de transições."
                                  ],
                                  "verification": "Tabela de variáveis com tipos, domínios e mapeamento a eventos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Tabela em documento ou software como Notion ou Word.",
                                  "tips": "Use o princípio 'estado é snapshot no tempo' para guiar escolhas.",
                                  "learningObjective": "Modelar o estado do sistema de forma concisa e precisa.",
                                  "commonMistakes": "Definir variáveis redundantes ou insuficientes para descrever o estado."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e refinar as definições de variáveis e eventos",
                                  "subSteps": [
                                    "Simule cenários manuais com eventos para testar transições.",
                                    "Verifique se todos os estados possíveis são alcançáveis e únicos.",
                                    "Consulte descrições do sistema para alinhamento.",
                                    "Ajuste variáveis ou eventos baseados em inconsistências.",
                                    "Documente suposições e limitações."
                                  ],
                                  "verification": "Relatório de simulação manual sem inconsistências.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel para simulações manuais ou simulador simples como Python básico.",
                                  "tips": "Teste casos extremos, como sistema vazio ou sobrecarregado.",
                                  "learningObjective": "Garantir robustez do modelo conceitual.",
                                  "commonMistakes": "Não testar transições, levando a modelos frágeis."
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado: Variáveis de estado: num_clientes_fila (inteiro >=0), status_caixa (livre/ocupado). Eventos: chegada_cliente (aumenta num_clientes_fila), cliente_atendido (diminui num_clientes_fila, libera status_caixa).",
                              "finalVerifications": [
                                "Variáveis de estado capturam completamente o snapshot atual do sistema.",
                                "Todos os eventos listados causam mudanças mensuráveis nas variáveis.",
                                "Não há ambiguidades ou sobreposições entre estados.",
                                "Transições de estado são deterministicas para eventos dados.",
                                "Modelo cobre cenários normais e edge cases.",
                                "Documentação inclui tipos, domínios e exemplos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de variáveis essenciais (sem redundâncias).",
                                "Completude da lista de eventos relevantes.",
                                "Clareza nas descrições e mapeamentos de transições.",
                                "Validação através de simulações manuais sem falhas.",
                                "Minimalismo: número mínimo de variáveis para representar o estado.",
                                "Alinhamento com análise preliminar do sistema real."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Modelagem de estados em linguagens como Python (classes de estado finito).",
                                "Probabilidade: Distribuições para tempos entre eventos.",
                                "Física: Análogos em sistemas dinâmicos discretos.",
                                "Gestão de Operações: Modelos de filas (M/M/1).",
                                "Engenharia de Software: Diagramas UML de estados."
                              ],
                              "realWorldApplication": "Usado em simulações de call centers para otimizar número de atendentes, controle de tráfego aéreo para gerenciar decolagens/pousos, ou logística para modelar estoques em armazéns, reduzindo custos e gargalos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.1.3",
                            "name": "Mapear fluxos e processos observados",
                            "description": "Desenhar diagramas de fluxo para capturar os processos reais do sistema, incluindo sequências de atividades e pontos de decisão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Observação Inicial e Registro do Sistema",
                                  "subSteps": [
                                    "Visite o sistema real e observe o funcionamento por pelo menos 30 minutos sem interferir.",
                                    "Anote todas as atividades visíveis, atores envolvidos e fluxos observados em um caderno ou app de notas.",
                                    "Registre timestamps aproximados para sequências repetitivas.",
                                    "Identifique entradas, saídas e interações principais.",
                                    "Faça esboços rápidos de fluxos lineares observados."
                                  ],
                                  "verification": "Verifique se há pelo menos 10-15 observações detalhadas registradas com descrições claras.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": "Caderno de anotações, caneta, cronômetro, smartphone para fotos/vídeos (se permitido).",
                                  "tips": "Mantenha distância para evitar alterar o comportamento natural do sistema.",
                                  "learningObjective": "Desenvolver habilidades de observação sistemática para capturar dados reais do sistema.",
                                  "commonMistakes": "Ignorar detalhes repetitivos ou assumir conhecimento prévio sem registrar."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificação de Sequências de Atividades Principais",
                                  "subSteps": [
                                    "Revise as anotações e agrupe atividades em sequências lógicas (ex: início -> ação1 -> ação2 -> fim).",
                                    "Ordene as atividades cronologicamente com base nos timestamps.",
                                    "Defina símbolos padronizados: retângulos para atividades, setas para fluxos.",
                                    "Liste dependências entre atividades (o que deve preceder o quê).",
                                    "Crie uma tabela simples com colunas: Atividade, Duração aproximada, Frequência."
                                  ],
                                  "verification": "Confirme que todas as atividades observadas estão listadas em sequências coerentes sem lacunas.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": "Anotações do Step 1, planilha ou papel para tabela.",
                                  "tips": "Use cores para diferenciar tipos de atividades (ex: azul para ações manuais, verde para automáticas).",
                                  "learningObjective": "Mapear sequências lineares para representar o fluxo principal do processo.",
                                  "commonMistakes": "Pular atividades secundárias que impactam o fluxo principal."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detecção de Pontos de Decisão e Ramificações",
                                  "subSteps": [
                                    "Analise anotações para momentos onde o fluxo diverge (ex: 'se sim' vs 'se não').",
                                    "Identifique condições de decisão (ex: inspeção aprovada? estoque disponível?).",
                                    "Marque losangos para decisões e defina caminhos alternativos.",
                                    "Registre probabilidades aproximadas ou frequências para cada ramo.",
                                    "Verifique loops ou iterações no processo (ex: repetição até condição atendida)."
                                  ],
                                  "verification": "Liste pelo menos 3-5 pontos de decisão com condições claras e caminhos associados.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": "Anotações e tabela do Step 2, software de diagramação básico (ex: Draw.io gratuito).",
                                  "tips": "Pergunte 'O que acontece se X falhar?' para revelar ramificações ocultas.",
                                  "learningObjective": "Incorporar lógica condicional para tornar o mapa fiel à realidade dinâmica.",
                                  "commonMistakes": "Tratar decisões como atividades lineares, ignorando caminhos alternativos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construção e Validação do Diagrama de Fluxo",
                                  "subSteps": [
                                    "Desenhe o diagrama integrando sequências e decisões usando símbolos padrão (retângulo=atividade, losango=decisão, seta=fluxo).",
                                    "Inclua rótulos claros em cada elemento e legendas.",
                                    "Simule o fluxo percorrendo o diagrama com dados observados.",
                                    "Compare com observações originais e ajuste discrepâncias.",
                                    "Peça feedback de um observador independente para validar."
                                  ],
                                  "verification": "O diagrama deve reproduzir fielmente pelo menos 90% das observações sem ambiguidades.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": "Ferramenta de diagramação (Draw.io, Lucidchart), impressora para versão física.",
                                  "tips": "Mantenha o diagrama em uma página A4 para simplicidade visual.",
                                  "learningObjective": "Criar um artefato visual preciso e validado do processo real.",
                                  "commonMistakes": "Sobrecarregar o diagrama com detalhes excessivos, tornando-o ilegível."
                                }
                              ],
                              "practicalExample": "Em um supermercado, observe o fluxo de checkout: cliente chega -> escaneia itens (atividade) -> pagamento aprovado? (decisão: sim -> sacola e saída; não -> erro e retry) -> fim. Desenhe diagrama capturando filas, rejeições de cartão e loops de correção.",
                              "finalVerifications": [
                                "O diagrama inclui todas as atividades e decisões observadas?",
                                "Sequências e ramificações refletem fielmente os timestamps reais?",
                                "Símbolos e rótulos são padronizados e legíveis?",
                                "Simulação do diagrama reproduz o processo observado sem falhas?",
                                "Feedback externo confirma precisão?",
                                "Probabilidades ou frequências de ramos estão anotadas?"
                              ],
                              "assessmentCriteria": [
                                "Precisão: 90%+ de correspondência com observações reais.",
                                "Clareza: Diagrama legível em <1 minuto de análise.",
                                "Completude: Todas sequências, decisões e loops incluídos.",
                                "Padronização: Uso correto de símbolos BPMN ou flowchart básicos.",
                                "Validação: Evidências de simulação e feedback incorporados.",
                                "Detalhamento: Condições de decisão explícitas e quantificadas."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Processos: Modelagem BPMN para otimização industrial.",
                                "Programação: Tradução direta para fluxogramas de algoritmos em Python ou pseudocódigo.",
                                "Administração: Análise de fluxos para Lean Manufacturing ou Six Sigma.",
                                "Ciências Sociais: Mapeamento de comportamentos em sistemas humanos."
                              ],
                              "realWorldApplication": "Em simulações de sistemas discretos como linhas de montagem fabris, onde o diagrama serve de base para modelos computacionais em ferramentas como Arena ou AnyLogic, permitindo identificar gargalos e otimizar eficiência operacional."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.2.1.2",
                        "name": "Definição de Atributos e Relacionamentos",
                        "description": "Especificação dos atributos das entidades e das relações lógicas entre elas, formando a estrutura conceitual do modelo.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.1.2.1",
                            "name": "Atribuir atributos às entidades",
                            "description": "Associar propriedades mensuráveis (ex.: tempo de serviço, prioridades) às entidades identificadas, considerando distribuições estatísticas quando aplicável.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar entidades e brainstorm de atributos potenciais",
                                  "subSteps": [
                                    "Liste todas as entidades principais do sistema discreto simulando (ex.: clientes, servidores, máquinas).",
                                    "Para cada entidade, brainstorm propriedades mensuráveis relevantes (ex.: tempo de serviço, prioridade, tamanho).",
                                    "Classifique atributos como estáticos (fixos) ou dinâmicos (variáveis ao longo do tempo).",
                                    "Considere impactos no comportamento do sistema (ex.: como o atributo afeta filas ou processamento).",
                                    "Documente em uma tabela inicial: entidade | atributo | tipo (mensurável/qualitativo)."
                                  ],
                                  "verification": "Tabela inicial completa com pelo menos 3-5 atributos por entidade principal, revisada por pares ou autoavaliação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Folha de papel, planilha Excel/Google Sheets ou editor de texto como Notion.",
                                  "tips": "Priorize atributos que influenciam métricas chave como tempo de espera ou throughput.",
                                  "learningObjective": "Reconhecer e listar propriedades mensuráveis associadas a entidades em um modelo conceitual.",
                                  "commonMistakes": "Incluir atributos qualitativos não mensuráveis (ex.: 'cor favorita') em vez de quantitativos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar atributos relevantes e mensuráveis",
                                  "subSteps": [
                                    "Avalie cada atributo brainstormado pela relevância ao objetivo da simulação (ex.: otimizar filas?).",
                                    "Elimine atributos irrelevantes ou qualitativos, mantendo apenas mensuráveis (ex.: tempo em minutos, prioridade numérica 1-10).",
                                    "Defina faixas realistas baseadas em dados reais ou literatura (ex.: tempo de serviço médio de 5-10 min).",
                                    "Priorize atributos com impacto estatístico significativo no sistema.",
                                    "Atualize a tabela com justificativa de seleção para cada atributo mantido."
                                  ],
                                  "verification": "Tabela revisada com apenas atributos mensuráveis selecionados e justificativas documentadas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Planilha com colunas para justificativa, dados de referência (ex.: artigos sobre simulações).",
                                  "tips": "Use critérios SMART (Específicos, Mensuráveis, Alcançáveis, Relevantes, Temporais) para seleção.",
                                  "learningObjective": "Filtrar e priorizar atributos baseados em critérios de relevância e mensurabilidade.",
                                  "commonMistakes": "Selecionar atributos sem ligação clara ao objetivo da simulação, levando a modelos inchados."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir valores ou distribuições estatísticas para atributos",
                                  "subSteps": [
                                    "Para atributos estáticos, defina valores fixos ou intervalos (ex.: prioridade = 5).",
                                    "Para dinâmicos, identifique distribuições adequadas (ex.: tempo de chegada ~ Poisson(λ=2/hora), tempo de serviço ~ Exponencial(μ=8min)).",
                                    "Colete ou estime parâmetros estatísticos de dados reais ou benchmarks.",
                                    "Valide distribuições com testes simples (ex.: histograma mental de dados observados).",
                                    "Adicione à tabela: atributo | valor/distribuição | parâmetros | fonte/justificativa."
                                  ],
                                  "verification": "Todos atributos têm valores ou distribuições definidas com parâmetros e fontes documentadas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Software estatístico como R/Python (bibliotecas numpy/scipy) ou calculadora para simular distribuições.",
                                  "tips": "Comece com distribuições comuns em simulações discretas: Poisson para chegadas, Exponencial para serviços.",
                                  "learningObjective": "Aplicar conceitos estatísticos para modelar variabilidade realista em atributos de entidades.",
                                  "commonMistakes": "Usar distribuições inadequadas (ex.: Normal para tempos de chegada que não podem ser negativos)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Associar atributos às entidades e validar o modelo",
                                  "subSteps": [
                                    "Crie diagrama ou tabela final ligando entidades aos atributos selecionados.",
                                    "Simule manualmente um cenário curto para testar associações (ex.: avance 1 hora e veja impactos).",
                                    "Verifique consistência: atributos afetam logicamente o fluxo do sistema?",
                                    "Documente relacionamentos (ex.: atributo de cliente afeta servidor).",
                                    "Revise com checklist: mensurável? Estatisticamente sound? Completo?"
                                  ],
                                  "verification": "Diagrama/tabela final validada por simulação manual sem inconsistências.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Ferramenta de diagramação como Draw.io/Lucidchart, papel para simulação manual.",
                                  "tips": "Teste edge cases: atributos extremos (ex.: prioridade máxima mínima).",
                                  "learningObjective": "Integrar atributos em um modelo conceitual coerente e validado.",
                                  "commonMistakes": "Esquecer de validar associações, resultando em modelo conceitual desconectado da realidade."
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de banco: Entidade 'Cliente' ganha atributos 'tempo_chegada' (Poisson λ=3/hora), 'prioridade' (discreta: 1-5 baseado em tipo VIP), 'tempo_serviço' (Exponencial μ=7min). Entidade 'Caixa' tem 'capacidade' (fixa=1), 'eficiência' (Normal 95%, desv=5%). Simule: cliente VIP prioritário reduz tempo médio de espera em 20%.",
                              "finalVerifications": [
                                "Todos atributos estão associados explicitamente a entidades específicas.",
                                "Atributos são mensuráveis com unidades claras (ex.: minutos, unidades).",
                                "Distribuições estatísticas têm parâmetros justificados por dados reais.",
                                "Associações impactam logicamente o comportamento do sistema simulado.",
                                "Modelo documentado sem ambiguidades ou atributos pendentes.",
                                "Simulação manual inicial confirma plausibilidade."
                              ],
                              "assessmentCriteria": [
                                "Completude: Cobertura de todas entidades relevantes com ≥3 atributos cada (30%).",
                                "Precisão estatística: Distribuições apropriadas e parametrizadas corretamente (25%).",
                                "Relevância: Atributos alinhados ao objetivo da simulação (20%).",
                                "Clareza: Documentação tabular/diagrama legível e organizada (15%).",
                                "Validação: Evidência de testes manuais e correções (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Modelagem de distribuições probabilísticas (Poisson, Exponencial).",
                                "Ciência da Computação: Orientação a objetos e atributos em programação de simulações.",
                                "Engenharia Industrial: Análise de sistemas e modelagem de processos discretos.",
                                "Gestão de Dados: Definição de esquemas relacionais em bancos de dados simulados."
                              ],
                              "realWorldApplication": "Em simulações de logística para otimizar alocação de caminhões (atributos: carga, prioridade de entrega), reduzindo custos em 15% em empresas como Amazon ou indústrias manufatureiras."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.2.2",
                            "name": "Estabelecer regras de interação",
                            "description": "Definir as regras lógicas que governam as interações entre entidades, como prioridades de fila ou alocação de recursos em sistemas discretos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar Entidades e Interações Possíveis",
                                  "subSteps": [
                                    "Liste todas as entidades relevantes no sistema discreto (ex.: clientes, servidores, recursos).",
                                    "Mapeie as interações potenciais entre entidades (ex.: cliente chega à fila, servidor atende).",
                                    "Classifique interações como síncronas ou assíncronas.",
                                    "Documente atributos chave de cada entidade que influenciam interações (ex.: prioridade do cliente).",
                                    "Crie um diagrama inicial de fluxo de interações."
                                  ],
                                  "verification": "Diagrama completo com pelo menos 80% das interações mapeadas e revisado por pares.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de diagramação como Draw.io",
                                    "Descrição do sistema discreto"
                                  ],
                                  "tips": "Comece com interações mais frequentes para priorizar.",
                                  "learningObjective": "Compreender as entidades e suas interações fundamentais no modelo conceitual.",
                                  "commonMistakes": [
                                    "Ignorar interações raras mas críticas",
                                    "Confundir atributos com interações"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Condições Lógicas e Prioridades",
                                  "subSteps": [
                                    "Estabeleça condições booleanas para disparar interações (ex.: se fila < capacidade, alocar recurso).",
                                    "Defina prioridades hierárquicas (ex.: FIFO com prioridade alta para VIPs).",
                                    "Especifique regras de conflito (ex.: o que acontece se dois clientes chegam simultaneamente?).",
                                    "Use operadores lógicos (AND, OR, NOT) para complexidade.",
                                    "Teste condições com cenários hipotéticos simples."
                                  ],
                                  "verification": "Todas as condições cobrem cenários edge cases e são testadas em tabela verdade.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Planilha para tabela verdade (Excel/Google Sheets)",
                                    "Documentação de atributos das entidades"
                                  ],
                                  "tips": "Use pseudocódigo para clareza antes de formalizar.",
                                  "learningObjective": "Dominar a definição precisa de condições e prioridades lógicas.",
                                  "commonMistakes": [
                                    "Regras ambíguas sem operadores lógicos claros",
                                    "Sobrecarregar prioridades sem hierarquia"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Especificar Ações e Estados Resultantes",
                                  "subSteps": [
                                    "Descreva ações exatas para cada interação (ex.: mover cliente para fila, decrementar recurso).",
                                    "Defina mudanças de estado pós-interação (ex.: servidor ocupado = true).",
                                    "Inclua regras de timeout ou falha (ex.: se espera > 10min, cliente sai).",
                                    "Garanta conservação de recursos (ex.: alocação não excede disponibilidade).",
                                    "Formalize em formato legível como if-then-else."
                                  ],
                                  "verification": "Simulação manual de 5 interações confirma estados corretos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Editor de texto para pseudocódigo",
                                    "Diagrama de interações do step 1"
                                  ],
                                  "tips": "Mantenha ações atômicas e idempotentes quando possível.",
                                  "learningObjective": "Especificar ações determinísticas baseadas em regras de interação.",
                                  "commonMistakes": [
                                    "Ações que violam conservação de recursos",
                                    "Estados não atualizados corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Refinar Regras de Interação",
                                  "subSteps": [
                                    "Execute walkthroughs com cenários reais e edge cases.",
                                    "Verifique consistência lógica (sem loops infinitos ou deadlocks).",
                                    "Colete feedback de stakeholders ou pares.",
                                    "Ajuste regras para otimização (ex.: reduzir latência).",
                                    "Documente regras finais em um repositório centralizado."
                                  ],
                                  "verification": "100% dos cenários testados passam sem anomalias; documentação aprovada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Lista de cenários de teste",
                                    "Ferramenta de versionamento como Git"
                                  ],
                                  "tips": "Use checklists para validação sistemática.",
                                  "learningObjective": "Garantir robustez e refinamento das regras de interação.",
                                  "commonMistakes": [
                                    "Pular validação de edge cases",
                                    "Ignorar feedback externo"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado: Entidades (clientes, caixas); Regras: Se caixa livre e cliente na fila, alocar (prioridade para carrinhos grandes); Se fila > 5, abrir novo caixa; Cliente sai se espera > 15min.",
                              "finalVerifications": [
                                "Regras cobrem 100% das interações identificadas.",
                                "Nenhum deadlock ou loop infinito detectado em simulações manuais.",
                                "Prioridades e condições são lógicas e sem ambiguidades.",
                                "Mudanças de estado são consistentes e conservam recursos.",
                                "Documentação clara permite implementação direta em código.",
                                "Testes de edge cases passam com sucesso."
                              ],
                              "assessmentCriteria": [
                                "Completude: Todas interações mapeadas e reguladas.",
                                "Clareza: Regras legíveis com pseudocódigo ou diagramas.",
                                "Precisão lógica: Sem contradições ou ambiguidades.",
                                "Robustez: Lida com falhas e edge cases.",
                                "Eficiência: Regras otimizadas sem overhead desnecessário.",
                                "Documentação: Fácil de revisar e implementar."
                              ],
                              "crossCurricularConnections": [
                                "Lógica e Programação: Uso de condicionais e estruturas de controle.",
                                "Matemática Discreta: Teoria de grafos para modelar interações.",
                                "Ciência da Computação: Algoritmos de scheduling e filas.",
                                "Engenharia de Software: Modelagem UML para regras.",
                                "Estatística: Análise probabilística de interações."
                              ],
                              "realWorldApplication": "Em simulações de tráfego urbano (prioridades de semáforos), manufatura (alocação de máquinas em linhas de produção) ou call centers (distribuição de chamadas por prioridade), garantindo eficiência e previsibilidade em sistemas discretos reais."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.2.3",
                            "name": "Modelar sequências de eventos",
                            "description": "Descrever a ordem e dependências dos eventos no modelo conceitual, utilizando notação de eventos discretos para simulação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar Eventos Principais no Sistema",
                                  "subSteps": [
                                    "Analise o sistema discreto para listar todos os eventos que alteram o estado (ex: chegada, partida, falha).",
                                    "Classifique eventos como internos (ex: processamento) ou externos (ex: chegada aleatória).",
                                    "Defina triggers para cada evento (condições que o ativam).",
                                    "Registre atributos afetados por cada evento (ex: fila aumenta em 'chegada').",
                                    "Crie um glossário inicial de eventos com descrições breves."
                                  ],
                                  "verification": "Lista completa de eventos com classificações e triggers documentados em um diagrama ou tabela.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel, lápis, diagrama de fluxo ou software como Draw.io",
                                  "tips": "Comece pelo evento inicial e trace fluxos naturais para não omitir eventos raros.",
                                  "learningObjective": "Reconhecer e catalogar eventos discretos que definem dinâmicas do sistema.",
                                  "commonMistakes": "Ignorar eventos condicionais ou confundir eventos com estados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Mapear Ordem e Dependências entre Eventos",
                                  "subSteps": [
                                    "Desenhe um grafo direcionado onde nós são eventos e setas indicam precedência (A -> B significa A antes de B).",
                                    "Identifique dependências lógicas (ex: 'pagamento' depende de 'chegada ao caixa').",
                                    "Marque loops ou ciclos se aplicável (ex: reprocessamento).",
                                    "Atribua probabilidades ou condições de transição entre eventos.",
                                    "Valide o grafo consultando descrições do sistema real."
                                  ],
                                  "verification": "Grafo de dependências completo sem ciclos inválidos e com todas transições mapeadas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software de grafos (Graphviz, Lucidchart) ou papel quadriculado",
                                  "tips": "Use cores para diferenciar dependências obrigatórias vs. probabilísticas.",
                                  "learningObjective": "Estabelecer relações causais precisas entre eventos discretos.",
                                  "commonMistakes": "Assumir independência onde há correlações ocultas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Representar Sequências com Notação de Eventos Discretos",
                                  "subSteps": [
                                    "Adote notação padrão: E_i(t) para evento i no tempo t, com agenda de eventos futuros.",
                                    "Escreva sequências como E1 -> E2(t+Δt) onde Δt é delay.",
                                    "Inclua clocks lógicos: cada evento avança o clock do tipo mais próximo.",
                                    "Formalize em pseudocódigo: while(sim_time < end) { schedule next events }.",
                                    "Teste notação com um ciclo simples de eventos."
                                  ],
                                  "verification": "Pseudocódigo ou diagrama temporal que simula uma sequência básica sem ambiguidades.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Editor de texto, Python/Jupyter para protótipo simples",
                                  "tips": "Priorize clocks lógicos para evitar problemas de ordenação em simulações paralelas.",
                                  "learningObjective": "Utilizar notação formal para descrever dinâmicas temporais de eventos.",
                                  "commonMistakes": "Confundir tempo real com tempo simulado ou omitir gerenciamento de agenda."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Documentar o Modelo de Sequências",
                                  "subSteps": [
                                    "Simule manualmente 5-10 ciclos de eventos para checar consistência.",
                                    "Compare com dados reais ou especificações do sistema.",
                                    "Ajuste dependências baseadas em discrepâncias encontradas.",
                                    "Documente o modelo em formato legível: grafo + notação + explicações.",
                                    "Prepare para implementação computacional."
                                  ],
                                  "verification": "Documento final com simulação manual validada e sem inconsistências lógicas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Planilha Excel para tracking manual, documento Word/Google Docs",
                                  "tips": "Registre métricas como throughput para validação quantitativa precoce.",
                                  "learningObjective": "Garantir robustez e traceability do modelo conceitual.",
                                  "commonMistakes": "Pular validação, levando a modelos irrealistas."
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado: E1=ChegadaCliente(t), aumenta fila; E2=IniciaAtendimento (depende fila>0), avança clock lógico; E3=FinalizaCompra(t+5min), libera caixa. Sequência: E1 -> E2 -> E3, com agenda priorizando menor tempo restante.",
                              "finalVerifications": [
                                "Todos eventos identificados cobrem 100% das transições de estado.",
                                "Grafo de dependências é acíclico onde necessário e captura loops corretos.",
                                "Notação descreve ordenação temporal sem ambiguidades.",
                                "Simulação manual reproduz comportamentos esperados do sistema.",
                                "Documentação permite recriação independente por outro modelador.",
                                "Dependências incluem condições probabilísticas se aplicável."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação e classificação de eventos (90% cobertura).",
                                "Clareza e completude do mapeamento de dependências.",
                                "Correta aplicação de notação de eventos discretos (clocks, agendas).",
                                "Validação robusta com simulações manuais e ajustes.",
                                "Qualidade da documentação: legível, concisa e formal.",
                                "Integração de atributos/relacionamentos do contexto maior."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar agenda de eventos em linguagens como Python (SimPy).",
                                "Probabilidade e Estatística: Modelar delays e triggers estocásticos.",
                                "Ciência da Computação: Grafos e algoritmos de ordenação topológica.",
                                "Engenharia de Sistemas: Análise de fluxos em manufatura ou logística."
                              ],
                              "realWorldApplication": "Modelagem de linhas de produção em fábricas (sequências de montagem dependentes), simulação de tráfego urbano (eventos de sinalização e acidentes), ou filas em call centers (chegadas e atendimentos para otimizar staffing)."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.2.4",
                            "name": "Documentar suposições iniciais",
                            "description": "Registrar todas as suposições feitas durante a definição, incluindo justificativas baseadas na análise do sistema real.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar todas as suposições feitas na definição de atributos e relacionamentos",
                                  "subSteps": [
                                    "Revise o modelo conceitual atual e liste todas as decisões implícitas ou explícitas sobre atributos (ex.: valores iniciais, distribuições probabilísticas).",
                                    "Analise relacionamentos entre entidades e anote suposições sobre interações (ex.: independência entre variáveis).",
                                    "Considere o sistema real: compare com dados observados ou literatura para identificar suposições baseadas em simplificações.",
                                    "Classifique suposições por tipo: determinísticas (ex.: constantes fixas), probabilísticas (ex.: distribuições assumidas) ou estruturais (ex.: ausência de ciclos).",
                                    "Priorize suposições críticas que impactam a validade do modelo."
                                  ],
                                  "verification": "Verifique se há uma lista inicial completa de pelo menos 5-10 suposições identificadas, sem duplicatas.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": "Modelo conceitual documentado, notas de análise do sistema real, planilha ou editor de texto.",
                                  "tips": "Use brainstorming livre para capturar suposições intuitivas antes de filtrar.",
                                  "learningObjective": "Desenvolver habilidade em reconhecer suposições ocultas no processo de modelagem.",
                                  "commonMistakes": "Ignorar suposições triviais que se tornam críticas em cenários extremos; confundir fatos observados com suposições."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Registrar cada suposição com justificativa detalhada",
                                  "subSteps": [
                                    "Para cada suposição, escreva uma declaração clara e concisa (ex.: 'Tempo de processamento é constante em 5 minutos').",
                                    "Forneça justificativa baseada no sistema real: cite dados empíricos, referências bibliográficas ou razões lógicas.",
                                    "Inclua impacto potencial: descreva como a suposição afeta o modelo (ex.: 'Simplifica cálculo, mas ignora variabilidade').",
                                    "Adicione condições de validade: especifique limites onde a suposição pode falhar (ex.: 'Válida para cargas <80%').",
                                    "Formate em tabela: colunas para Suposição, Justificativa, Fonte, Impacto."
                                  ],
                                  "verification": "Confirme que 100% das suposições têm justificativa com pelo menos uma fonte ou evidência.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": "Planilha (Google Sheets/Excel), referências do sistema real (relatórios, artigos).",
                                  "tips": "Use linguagem precisa e quantificável para facilitar testes futuros.",
                                  "learningObjective": "Aprender a documentar suposições de forma rastreável e justificável.",
                                  "commonMistakes": "Justificativas vagas sem evidências; omitir impactos negativos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Validar e refinar as suposições documentadas",
                                  "subSteps": [
                                    "Teste cada suposição contra dados reais ou simulações preliminares simples.",
                                    "Consulte stakeholders ou especialistas para feedback sobre realismo.",
                                    "Identifique suposições redundantes ou conflitantes e resolva (ex.: mesclar ou remover).",
                                    "Adicione plano de sensibilidade: note como testar relaxamento da suposição.",
                                    "Atualize a documentação com revisões baseadas na validação."
                                  ],
                                  "verification": "Registre resultados de pelo menos um teste ou feedback por suposição crítica.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": "Dados reais do sistema, ferramentas de simulação básica (ex.: Python/Excel), lista de stakeholders.",
                                  "tips": "Priorize validação de suposições com alto impacto no modelo.",
                                  "learningObjective": "Capacitar validação proativa de suposições para robustez do modelo.",
                                  "commonMistakes": "Aceitar suposições sem questionamento; ignorar feedback contraditório."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Organizar e integrar a documentação no modelo conceitual",
                                  "subSteps": [
                                    "Crie uma seção dedicada 'Suposições Iniciais' no documento do modelo conceitual.",
                                    "Inclua sumário executivo das suposições principais e riscos associados.",
                                    "Linke suposições a atributos/relacionamentos específicos no diagrama.",
                                    "Prepare versão rastreável (ex.: Git para histórico de mudanças).",
                                    "Revise o documento completo para consistência e clareza."
                                  ],
                                  "verification": "Documento final aprovado por auto-revisão ou peer review, com links funcionais.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": "Documento do modelo conceitual (Markdown/Word), ferramenta de versionamento (Git/Google Docs).",
                                  "tips": "Mantenha a documentação concisa mas completa; use hyperlinks para navegação.",
                                  "learningObjective": "Integrar documentação de suposições de forma profissional e acessível.",
                                  "commonMistakes": "Esconder suposições em anexos; não versionar mudanças."
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado (sistema discreto), suposição: 'Chegada de clientes segue distribuição Poisson com λ=10/hora'. Justificativa: Observada em dados de 1 semana (histograma ajusta bem), fonte: logs do caixa. Impacto: Permite modelar variabilidade realista sem dados exógenos.",
                              "finalVerifications": [
                                "Todas suposições identificadas estão registradas com justificativa baseada em evidências reais.",
                                "Documentação está organizada em seção dedicada com tabela rastreável.",
                                "Suposições críticas foram validadas com testes ou feedback.",
                                "Riscos e planos de sensibilidade estão explicitados.",
                                "Documentação linkada ao modelo conceitual completo.",
                                "Versão final é clara, concisa e versionada."
                              ],
                              "assessmentCriteria": [
                                "Completude: Cobertura de 100% das suposições relevantes (nota 1-10).",
                                "Precisão das justificativas: Evidências concretas vs. vagas (nota 1-10).",
                                "Clareza e organização: Facilidade de leitura e navegação (nota 1-10).",
                                "Validação: Evidências de testes ou feedback incluídos (nota 1-10).",
                                "Profundidade de impacto: Análise de riscos e sensibilidade (nota 1-10).",
                                "Integração: Links efetivos ao modelo geral (nota 1-10)."
                              ],
                              "crossCurricularConnections": [
                                "Ciência da Computação: Documentação de premissas em algoritmos e validação em testes unitários.",
                                "Engenharia de Software: Rastreabilidade de requisitos e análise de risco em modelagem UML.",
                                "Estatística: Identificação e teste de hipóteses em modelagem probabilística.",
                                "Gestão de Projetos: Registro de assumptions em PMBOK para gerenciamento de riscos."
                              ],
                              "realWorldApplication": "Em simulações industriais como otimização de linhas de produção (ex.: fábricas automotivas), documentar suposições iniciais permite identificar gargalos precocemente, justificar investimentos em dados reais e adaptar modelos para cenários reais, reduzindo erros em 20-30% conforme estudos em simulação de eventos discretos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.2.1.3",
                        "name": "Abstração e Simplificação do Modelo",
                        "description": "Processo de abstrair elementos essenciais do sistema real, eliminando detalhes irrelevantes para criar um modelo conceitual viável e focado nos objetivos da simulação.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.1.3.1",
                            "name": "Aplicar princípios de abstração",
                            "description": "Selecionar apenas os aspectos relevantes do sistema real alinhados aos objetivos da simulação, ignorando ruídos e variações periféricas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir os objetivos claros da simulação",
                                  "subSteps": [
                                    "Escreva uma declaração precisa dos objetivos da simulação, focando no que precisa ser analisado ou previsto.",
                                    "Identifique as variáveis de saída principais (ex.: throughput, tempo médio de espera).",
                                    "Liste as perguntas específicas que a simulação deve responder.",
                                    "Priorize objetivos primários vs. secundários.",
                                    "Valide os objetivos com stakeholders ou requisitos do projeto."
                                  ],
                                  "verification": "Verifique se a declaração de objetivos é concisa, mensurável e alinhada ao problema real.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": "Papel, caneta ou editor de texto; documento de requisitos do projeto.",
                                  "tips": "Use o método SMART (Specific, Measurable, Achievable, Relevant, Time-bound) para objetivos.",
                                  "learningObjective": "Compreender como objetivos guiam a seleção de aspectos relevantes.",
                                  "commonMistakes": "Definir objetivos vagos como 'simular tudo' em vez de focados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Mapear todos os componentes do sistema real",
                                  "subSteps": [
                                    "Descreva o sistema real em detalhes: atores, processos, interações e variáveis.",
                                    "Crie um diagrama ou lista exaustiva de elementos (entidades, atributos, eventos).",
                                    "Classifique elementos como centrais, periféricos ou ruídos.",
                                    "Registre variações e incertezas observadas no sistema.",
                                    "Colete dados iniciais ou observações empíricas para embasar o mapeamento."
                                  ],
                                  "verification": "Confirme que o mapa cobre 100% dos elementos observáveis sem omissões iniciais.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": "Ferramentas de diagramação (Draw.io, Lucidchart); notas de campo ou dados reais.",
                                  "tips": "Use diagramas de fluxo ou UML para visualização clara.",
                                  "learningObjective": "Identificar integralmente o sistema para posterior filtragem.",
                                  "commonMistakes": "Ignorar elementos periféricos prematuramente, perdendo contexto."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Selecionar aspectos relevantes alinhados aos objetivos",
                                  "subSteps": [
                                    "Compare cada elemento mapeado com os objetivos: 'Isso impacta as saídas principais?'",
                                    "Classifique elementos como 'essencial', 'opcional' ou 'irrelevante'.",
                                    "Justifique seleções com raciocínio lógico ou evidências quantitativas.",
                                    "Agrupe elementos relacionados em abstrações de alto nível (ex.: 'fila de clientes').",
                                    "Documente decisões em uma tabela de relevância."
                                  ],
                                  "verification": "Todos os elementos essenciais estão selecionados e justificados.",
                                  "estimatedTime": "60-90 minutos",
                                  "materials": "Tabela de decisão (Excel/Google Sheets); mapa do sistema do passo anterior.",
                                  "tips": "Pergunte: 'Se remover isso, os objetivos ainda são atendidos?'",
                                  "learningObjective": "Aplicar filtros baseados em relevância para abstração.",
                                  "commonMistakes": "Sobrecarregar o modelo incluindo elementos marginais por 'segurança'."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ignorar ruídos, simplificar e validar a abstração",
                                  "subSteps": [
                                    "Elimine ou simplifique elementos irrelevantes (ex.: ruídos aleatórios como variações climáticas irrelevantes).",
                                    "Defina suposições explícitas para simplificações (ex.: distribuição uniforme).",
                                    "Crie um modelo conceitual preliminar com apenas elementos selecionados.",
                                    "Teste sensitividade: simule cenários para verificar impacto de omissões.",
                                    "Revise com pares ou especialistas para feedback."
                                  ],
                                  "verification": "O modelo simplificado produz resultados alinhados aos objetivos sem perda crítica de precisão.",
                                  "estimatedTime": "45-75 minutos",
                                  "materials": "Software de simulação básico (Python com SimPy); diagrama final.",
                                  "tips": "Documente trade-offs: precisão vs. complexidade.",
                                  "learningObjective": "Garantir que abstrações mantenham fidelidade aos objetivos.",
                                  "commonMistakes": "Remover elementos essenciais disfarçados de ruído."
                                }
                              ],
                              "practicalExample": "Ao simular uma fila de supermercado para otimizar caixas, foque em chegada de clientes, tempo de serviço e filas; ignore cor das roupas ou clima externo, pois não afetam o throughput médio.",
                              "finalVerifications": [
                                "Modelo conceitual documenta apenas elementos alinhados aos objetivos.",
                                "Lista de omissões/ruídos justificada com impacto mínimo comprovado.",
                                "Simulação preliminar reproduz comportamentos chave do sistema real.",
                                "Suposições explícitas e testadas para simplificações.",
                                "Feedback de revisão confirma relevância das seleções.",
                                "Tabela de decisão completa com classificações."
                              ],
                              "assessmentCriteria": [
                                "Precisão na seleção: 90%+ de elementos essenciais incluídos (Excelente).",
                                "Justificativas lógicas e baseadas em evidências (Excelente).",
                                "Eficiência: modelo 50%+ mais simples sem perda de validade (Bom).",
                                "Documentação clara de decisões e trade-offs (Excelente).",
                                "Validação empírica via testes sensitividade (Bom).",
                                "Ausência de vieses ou omissões críticas (Excelente)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Abstração em OOP (classes encapsulam relevâncias).",
                                "Física: Modelos newtonianos ignoram fricção periférica.",
                                "Engenharia de Software: Requisitos elicitação focada em user stories.",
                                "Estatística: Seleção de variáveis em regressão (evitar multicolinearidade)."
                              ],
                              "realWorldApplication": "Em modelagem financeira, abstrair flutuações de mercado periféricas para simular portfólios, focando apenas em riscos sistêmicos para otimizar alocações de ativos."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.3.2",
                            "name": "Realizar simplificações justificadas",
                            "description": "Introduzir simplificações como aproximações lineares ou agregações de entidades, com análise de impacto na fidelidade do modelo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar oportunidades de simplificação no modelo conceitual",
                                  "subSteps": [
                                    "Examine o modelo original detalhando entidades, relações e comportamentos complexos.",
                                    "Identifique componentes com alta complexidade computacional ou pouca influência no resultado final.",
                                    "Classifique potenciais simplificações: aproximações lineares para não-lineares, agregações de entidades similares.",
                                    "Registre razões iniciais para cada oportunidade, como custo computacional vs. precisão.",
                                    "Crie um mapa visual das partes candidatas à simplificação."
                                  ],
                                  "verification": "Lista completa de oportunidades identificadas com classificações e razões documentadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Modelo conceitual original, papel ou software de diagramação (ex: Draw.io), calculadora.",
                                  "tips": "Priorize simplificações que afetem menos de 5% da variância total do modelo.",
                                  "learningObjective": "Reconhecer padrões de complexidade desnecessária em modelos de simulação.",
                                  "commonMistakes": "Ignorar interdependências entre entidades, levando a simplificações inválidas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e definir o tipo de simplificação",
                                  "subSteps": [
                                    "Escolha uma simplificação específica (ex: linearizar uma função não-linear em torno de um ponto de operação).",
                                    "Defina parâmetros matemáticos da simplificação, como coeficientes de aproximação ou critérios de agregação.",
                                    "Estime o erro teórico usando análise de Taylor ou métricas de agregação (ex: variância intra-grupo).",
                                    "Compare alternativas de simplificação em uma tabela de prós, contras e impacto esperado.",
                                    "Valide a escolha com um especialista ou literatura relevante."
                                  ],
                                  "verification": "Definição formal da simplificação com equações e tabela de comparação documentada.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software matemático (ex: MATLAB, Python com SymPy), literatura de simulação.",
                                  "tips": "Use expansões de Taylor para aproximações lineares: f(x) ≈ f(x0) + f'(x0)(x - x0).",
                                  "learningObjective": "Aplicar técnicas matemáticas para definir simplificações precisas.",
                                  "commonMistakes": "Escolher simplificações sem estimativa de erro, subestimando perda de fidelidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a simplificação no modelo",
                                  "subSteps": [
                                    "Modifique o código ou diagrama do modelo substituindo o componente original pela simplificação.",
                                    "Teste unitário da simplificação isoladamente com dados de entrada conhecidos.",
                                    "Integre a simplificação ao modelo completo e execute simulações preliminares.",
                                    "Registre mudanças no versionamento do modelo (ex: Git commit com diff).",
                                    "Automatize a implementação se possível, usando funções modulares."
                                  ],
                                  "verification": "Modelo atualizado executa sem erros e produz saídas consistentes em testes unitários.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Ambiente de programação (ex: Python com NumPy/SciPy), modelo original em código.",
                                  "tips": "Mantenha o código original comentado para fácil reversão.",
                                  "learningObjective": "Integrar simplificações de forma robusta em modelos computacionais.",
                                  "commonMistakes": "Não testar unitariamente, causando bugs propagados no modelo inteiro."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar impacto na fidelidade do modelo",
                                  "subSteps": [
                                    "Execute simulações paralelas: modelo original vs. simplificado com múltiplas sementes aleatórias.",
                                    "Calcule métricas de fidelidade (ex: erro médio quadrático, Kolmogorov-Smirnov test).",
                                    "Visualize diferenças com gráficos (ex: trajetórias, distribuições de saída).",
                                    "Quantifique ganhos: tempo de computação reduzido e perda de precisão.",
                                    "Interprete resultados: se impacto > threshold (ex: 2%), refine ou reverta."
                                  ],
                                  "verification": "Relatório com métricas, gráficos e interpretação do impacto gerado.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Software de simulação e análise (ex: Python com Matplotlib, SciPy.stats).",
                                  "tips": "Use 100+ runs para estatística robusta em sistemas estocásticos.",
                                  "learningObjective": "Avaliar quantitativamente trade-offs entre simplicidade e precisão.",
                                  "commonMistakes": "Usar poucos runs, levando a conclusões estatisticamente inválidas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar justificativa e finalizar",
                                  "subSteps": [
                                    "Escreva justificativa clara: tipo de simplificação, análise de impacto e thresholds atendidos.",
                                    "Inclua evidências: métricas, gráficos e referências teóricas.",
                                    "Atualize documentação do modelo conceitual com seção de simplificações.",
                                    "Compartilhe com equipe para revisão peer-review.",
                                    "Planeje monitoramento futuro da simplificação em simulações reais."
                                  ],
                                  "verification": "Documento de justificativa completo aprovado por peer-review.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Editor de texto (ex: Markdown, LaTeX), ferramenta de compartilhamento (ex: GitHub).",
                                  "tips": "Estruture justificativa como: Problema > Solução > Evidência > Conclusão.",
                                  "learningObjective": "Comunicar decisões de modelagem de forma transparente e reprodutível.",
                                  "commonMistakes": "Omitir evidências quantitativas, tornando justificativa subjetiva."
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado (sistema discreto), agregue clientes similares em 'super-clientes' por categoria de compra (rápida/média/lenta), linearizando tempos de serviço. Analise impacto: erro MSE <1% em tempo total de espera, reduzindo tempo de simulação de 10min para 30s.",
                              "finalVerifications": [
                                "Simplificação implementada e testada no modelo.",
                                "Métricas de fidelidade calculadas e abaixo de thresholds definidos.",
                                "Justificativa documentada com evidências quantitativas.",
                                "Ganhos computacionais quantificados (ex: speedup >2x).",
                                "Revisão peer aprovada.",
                                "Modelo versionado com histórico de mudanças."
                              ],
                              "assessmentCriteria": [
                                "Identificação precisa de oportunidades (cobertura >80% das complexidades relevantes).",
                                "Definição matemática rigorosa da simplificação (equações corretas).",
                                "Análise de impacto estatisticamente válida (p-value <0.05 em testes).",
                                "Justificativa clara e concisa (1-2 páginas).",
                                "Trade-off simplicidade-fidelidade otimizado (ganho computacional sem perda crítica).",
                                "Documentação completa e reprodutível."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação modular em Python/SciPy.",
                                "Estatística: Testes de hipótese para validação de fidelidade.",
                                "Engenharia de Software: Versionamento e testes unitários.",
                                "Física: Aproximações em modelagem de sistemas dinâmicos."
                              ],
                              "realWorldApplication": "Em simulações de tráfego urbano, simplificar interseções complexas com aproximações lineares de fluxo, reduzindo tempo de otimização de sinaleiros de horas para minutos, mantendo precisão >95% para planejamento municipal."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.3.3",
                            "name": "Verificar consistência conceitual",
                            "description": "Revisar o modelo conceitual para garantir ausência de contradições lógicas e alinhamento com o comportamento observado do sistema real.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Mapear os componentes e relações do modelo conceitual",
                                  "subSteps": [
                                    "Identificar todas as entidades principais do sistema real abstraídas no modelo",
                                    "Listar relações lógicas entre entidades (ex.: dependências, transições)",
                                    "Definir regras e premissas fundamentais do modelo",
                                    "Desenhar um diagrama conceitual representando a estrutura",
                                    "Revisar abstrações para garantir que simplificações sejam explícitas"
                                  ],
                                  "verification": "Diagrama completo e legível, com todas entidades e relações documentadas sem ambiguidades",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de diagramação como Draw.io ou Lucidchart"
                                  ],
                                  "tips": "Use notação UML ou fluxogramas padronizados para maior clareza visual",
                                  "learningObjective": "Compreender e visualizar a estrutura lógica completa do modelo conceitual",
                                  "commonMistakes": [
                                    "Omitir relações secundárias ou emergentes",
                                    "Confundir abstração com omissão de elementos críticos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar consistência lógica interna do modelo",
                                  "subSteps": [
                                    "Examinar cada regra individual por auto-contradições",
                                    "Verificar compatibilidade entre regras (ex.: transitividade de relações)",
                                    "Simular fluxos lógicos sequenciais e cíclicos manualmente",
                                    "Identificar cenários hipotéticos que gerem paradoxos",
                                    "Corrigir ou qualificar regras inconsistentes"
                                  ],
                                  "verification": "Lista de verificações lógicas assinada, confirmando ausência de contradições internas",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou tabela para registrar regras e testes lógicos",
                                    "Software de lógica como Truth Table Generator"
                                  ],
                                  "tips": "Aplique tabelas-verdade para relações booleanas simples",
                                  "learningObjective": "Detectar e resolver inconsistências puramente lógicas no modelo",
                                  "commonMistakes": [
                                    "Ignorar interações não lineares entre regras",
                                    "Assumir consistência sem simulação explícita"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Validar alinhamento com o comportamento observado do sistema real",
                                  "subSteps": [
                                    "Coletar dados empíricos ou observações do sistema real relevante",
                                    "Mapear comportamentos reais às predições do modelo",
                                    "Quantificar desvios (ex.: métricas de erro como RMSE)",
                                    "Explicar desvios como abstrações válidas ou inconsistências",
                                    "Ajustar o modelo minimamente para restaurar alinhamento"
                                  ],
                                  "verification": "Relatório de comparação com métricas de alinhamento ≥ 85% e explicações para desvios",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Dados reais do sistema (planilhas, logs)",
                                    "Ferramentas de análise como Excel ou Python Pandas"
                                  ],
                                  "tips": "Priorize dados de cenários representativos e variados",
                                  "learningObjective": "Garantir que o modelo reflita fielmente o sistema real sem contradições observáveis",
                                  "commonMistakes": [
                                    "Usar dados insuficientes ou enviesados",
                                    "Atribuir desvios a 'ruído' sem análise"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar cenários edge e documentar verificações finais",
                                  "subSteps": [
                                    "Definir 3-5 cenários extremos ou raros baseados no domínio",
                                    "Simular esses cenários no modelo e comparar com expectativas reais",
                                    "Documentar todas verificações, ajustes e premissas restantes",
                                    "Gerar um relatório de consistência com evidências",
                                    "Propor iterações futuras se necessário"
                                  ],
                                  "verification": "Relatório final aprovado, com testes de cenários edge passando sem falhas",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Modelo conceitual mapeado",
                                    "Template de relatório de verificação"
                                  ],
                                  "tips": "Cenários edge revelam fraquezas ocultas; teste o 'que acontece se...'",
                                  "learningObjective": "Consolidar a verificação através de testes robustos e documentação",
                                  "commonMistakes": [
                                    "Escolher cenários irrelevantes",
                                    "Subestimar impacto de edge cases raros"
                                  ]
                                }
                              ],
                              "practicalExample": "Ao modelar uma fila de supermercado discreta, verifique se o modelo permite 'tempos de serviço negativos' (contradição lógica) ou se prediz tempos de espera maiores que o observado em horários de pico (alinhamento falho), ajustando regras de chegada/saída para consistência.",
                              "finalVerifications": [
                                "Ausência total de contradições lógicas internas no modelo",
                                "Alinhamento quantitativo ≥ 90% com dados reais observados",
                                "Todos cenários edge simulados sem falhas conceituais",
                                "Diagrama e relatório documentados e auditáveis",
                                "Premissas de abstração explicitadas e justificadas",
                                "Lista de ajustes realizados com razões lógicas"
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção de inconsistências (zero falsos negativos)",
                                "Profundidade da análise lógica e empírica (cobertura ≥ 95% dos componentes)",
                                "Qualidade da documentação (clareza, completude e evidências)",
                                "Eficiência temporal (conclusão dentro do estimado ±20%)",
                                "Criatividade em cenários de teste (relevância e abrangência)",
                                "Capacidade de propor ajustes mínimos e impactantes"
                              ],
                              "crossCurricularConnections": [
                                "Lógica Formal e Matemática Discreta (análise de proposições)",
                                "Programação e Verificação de Software (testes unitários conceituais)",
                                "Engenharia de Sistemas (validação de modelos)",
                                "Filosofia da Ciência (consistência empírica e teórica)",
                                "Estatística (análise de desvios e validação)"
                              ],
                              "realWorldApplication": "Em simulações de tráfego urbano, verifica-se consistência para evitar predições de engarrafamentos 'fantasmas', otimizando semáforos reais; ou em finanças, previne modelos de risco com contradições que subestimem crashes econômicos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.3",
                    "name": "Coleta e Análise de Dados",
                    "description": "Obtenção e processamento de dados reais para parametrizar o modelo.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.3.1",
                        "name": "Coleta de Dados Reais",
                        "description": "Identificação e obtenção de dados reais do sistema para servir de base à parametrização do modelo de simulação.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.1.1",
                            "name": "Identificação de Fontes de Dados",
                            "description": "Determinar fontes confiáveis de dados reais, como registros históricos, sensores ou observações diretas, considerando a relevância para o sistema discreto simulado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir os Requisitos de Dados para a Simulação",
                                  "subSteps": [
                                    "Analise o sistema discreto simulado (ex: eventos discretos como chegadas em uma fila).",
                                    "Identifique os tipos de dados necessários (ex: timestamps, contagens, estados).",
                                    "Especifique critérios de relevância: precisão temporal, granularidade e escopo geográfico.",
                                    "Liste variáveis chave que os dados devem cobrir.",
                                    "Documente os requisitos em uma tabela simples."
                                  ],
                                  "verification": "Tabela de requisitos completada com pelo menos 5 variáveis chave e critérios definidos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Notebook ou papel",
                                    "Descrição do sistema discreto"
                                  ],
                                  "tips": "Comece pelo objetivo da simulação para evitar coleta desnecessária de dados.",
                                  "learningObjective": "Compreender como mapear necessidades de dados ao sistema simulado.",
                                  "commonMistakes": [
                                    "Ignorar granularidade temporal",
                                    "Definir requisitos muito amplos sem foco"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Pesquisar Potenciais Fontes de Dados Reais",
                                  "subSteps": [
                                    "Liste fontes comuns: registros históricos (bancos de dados governamentais), sensores IoT, observações diretas.",
                                    "Busque em repositórios abertos como Kaggle, IBGE, NOAA ou APIs públicas.",
                                    "Categorize fontes por tipo: primárias (observações diretas) vs. secundárias (registros).",
                                    "Registre pelo menos 5-10 fontes potenciais com links e descrições breves.",
                                    "Verifique disponibilidade gratuita e formatos (CSV, JSON, etc.)."
                                  ],
                                  "verification": "Lista com 5+ fontes potenciais documentadas, incluindo links e tipos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Acesso à internet",
                                    "Navegador web",
                                    "Planilha (Google Sheets ou Excel)"
                                  ],
                                  "tips": "Use palavras-chave específicas do sistema, como 'dados de tráfego SP' para simulações urbanas.",
                                  "learningObjective": "Explorar e catalogar fontes reais relevantes para simulações discretas.",
                                  "commonMistakes": [
                                    "Focar apenas em fontes pagas",
                                    "Não verificar formatos compatíveis com simulação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar Confiabilidade e Relevância das Fontes",
                                  "subSteps": [
                                    "Avalie confiabilidade: autor da fonte, data de atualização, metodologia de coleta.",
                                    "Teste relevância: compare com requisitos do Step 1 (ex: dados cobrem o período simulado?).",
                                    "Pontue cada fonte em uma escala de 1-10 para confiabilidade, relevância e acessibilidade.",
                                    "Identifique vieses potenciais (ex: dados enviesados por amostragem).",
                                    "Elimine fontes inadequadas e justifique exclusões."
                                  ],
                                  "verification": "Tabela de avaliação com pontuações e justificativas para cada fonte.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Planilha de avaliação",
                                    "Acesso às fontes listadas"
                                  ],
                                  "tips": "Priorize fontes oficiais ou acadêmicas; cruze com múltiplas referências.",
                                  "learningObjective": "Desenvolver critérios objetivos para validar fontes de dados reais.",
                                  "commonMistakes": [
                                    "Subestimar vieses em dados históricos",
                                    "Ignorar custos de acesso ocultos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Selecionar e Documentar Fontes Finais",
                                  "subSteps": [
                                    "Selecione 2-4 fontes top com base nas avaliações.",
                                    "Descreva como integrar os dados na simulação (ex: pré-processamento necessário).",
                                    "Crie um plano de coleta: frequência, volume e ferramentas.",
                                    "Documente tudo em um relatório final com referências.",
                                    "Teste download de amostra de uma fonte para validar."
                                  ],
                                  "verification": "Relatório final com fontes selecionadas, plano de coleta e amostra baixada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha final",
                                    "Ferramentas de download (ex: wget ou browser)"
                                  ],
                                  "tips": "Mantenha redundância: selecione fontes backup para robustez.",
                                  "learningObjective": "Finalizar seleção estratégica de fontes para simulações precisas.",
                                  "commonMistakes": [
                                    "Selecionar apenas uma fonte",
                                    "Esquecer documentação para reprodutibilidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Para simular um sistema de filas em um call center, identifique fontes como logs de chamadas da ANATEL (registros históricos), sensores de rede para tempos de resposta e observações diretas em centros semelhantes, avaliando relevância para picos diários de chamadas.",
                              "finalVerifications": [
                                "Lista de 2-4 fontes selecionadas com pontuações >7/10.",
                                "Relatório documenta requisitos, avaliações e plano de coleta.",
                                "Amostra de dados baixada e compatível com simulação discreta.",
                                "Justificativas para exclusão de fontes inadequadas.",
                                "Critérios de relevância alinhados ao sistema simulado.",
                                "Identificação de potenciais vieses em cada fonte."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de requisitos de dados (cobertura completa das variáveis).",
                                "Diversidade e qualidade das fontes pesquisadas (mínimo 5 potenciais).",
                                "Avaliação rigorosa de confiabilidade e relevância (com pontuações justificadas).",
                                "Seleção estratégica com redundância e plano de integração viável.",
                                "Documentação clara e reprodutível.",
                                "Consideração de vieses e limitações reais."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Análise de qualidade e vieses em dados.",
                                "Ciências da Computação: Acesso a APIs e pré-processamento de dados.",
                                "História/Geografia: Uso de registros históricos e dados espaciais.",
                                "Física: Sensores e observações diretas em sistemas discretos.",
                                "Ética: Avaliação de privacidade em fontes de dados reais."
                              ],
                              "realWorldApplication": "Em simulações de epidemias como COVID-19, identificar fontes como dados do Ministério da Saúde ou OMS para taxas de infecção, permitindo modelar propagação discreta em redes populacionais e prever surtos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.1.2",
                            "name": "Seleção de Métodos de Amostragem",
                            "description": "Escolher métodos de amostragem adequados, como amostragem aleatória simples, estratificada ou por conglomerados, para garantir representatividade dos dados reais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Principais Tipos de Métodos de Amostragem",
                                  "subSteps": [
                                    "Estude a definição e características da amostragem aleatória simples.",
                                    "Analise a amostragem estratificada, identificando como divide a população em subgrupos homogêneos.",
                                    "Explore a amostragem por conglomerados, focando em clusters geográficos ou naturais.",
                                    "Compare com métodos não probabilísticos para contrastar vantagens probabilísticas.",
                                    "Registre exemplos iniciais de aplicação de cada método."
                                  ],
                                  "verification": "Liste corretamente as definições e pelo menos um exemplo para cada método sem erros.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro-texto de estatística",
                                    "Vídeos tutoriais online sobre amostragem (Khan Academy)",
                                    "Folha de anotações"
                                  ],
                                  "tips": "Use diagramas visuais para ilustrar diferenças entre métodos.",
                                  "learningObjective": "Identificar e diferenciar os tipos básicos de amostragem probabilística.",
                                  "commonMistakes": "Confundir estratificada com conglomerados; ignorar a necessidade de representatividade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a População e os Objetivos da Coleta de Dados",
                                  "subSteps": [
                                    "Descreva a população alvo em termos de tamanho, heterogeneidade e acessibilidade.",
                                    "Defina os objetivos da simulação ou estudo (ex.: precisão, custo, representatividade).",
                                    "Identifique variáveis demográficas ou características relevantes para estratificação.",
                                    "Avalie restrições práticas como tempo, orçamento e viabilidade logística.",
                                    "Crie um perfil resumido da população."
                                  ],
                                  "verification": "Produza um perfil escrito da população com pelo menos 4 características chave alinhadas aos objetivos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Questionário ou descrição do problema de simulação",
                                    "Planilha Excel para registrar características"
                                  ],
                                  "tips": "Priorize heterogeneidade: se alta, prefira estratificada.",
                                  "learningObjective": "Mapear características da população para guiar a escolha do método.",
                                  "commonMistakes": "Subestimar heterogeneidade, levando a amostras enviesadas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar Vantagens, Desvantagens e Adequação de Cada Método",
                                  "subSteps": [
                                    "Para cada método, liste prós (ex.: aleatória simples é imparcial) e contras (ex.: conglomerados podem ser caros).",
                                    "Simule cenários hipotéticos e classifique o método mais adequado para cada.",
                                    "Calcule tamanhos de amostra aproximados usando fórmulas básicas de estatística.",
                                    "Considere viés de seleção e variância em cada método.",
                                    "Crie uma tabela comparativa."
                                  ],
                                  "verification": "Tabela comparativa completa com pelo menos 3 prós/contras por método e classificações para 2 cenários.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Calculadora ou software como R/Python para simulações simples",
                                    "Tabela modelo em papel ou Google Sheets"
                                  ],
                                  "tips": "Use matriz de decisão para pontuar métodos por critérios como custo e precisão.",
                                  "learningObjective": "Avaliar trade-offs para seleção informada.",
                                  "commonMistakes": "Ignorar custos logísticos em conglomerados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Selecionar e Justificar o Método Adequado",
                                  "subSteps": [
                                    "Escolha o método baseado na análise anterior e justifique com evidências.",
                                    "Desenhe um plano de amostragem detalhado (tamanho, procedimento).",
                                    "Teste o plano em uma simulação pequena para validar representatividade.",
                                    "Documente alternativas rejeitadas e razões.",
                                    "Revise com critérios de representatividade estatística."
                                  ],
                                  "verification": "Plano de amostragem escrito com justificativa de 200+ palavras e teste simulado sem viés detectado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software de simulação (ex.: Python com numpy)",
                                    "Modelo de plano de amostragem"
                                  ],
                                  "tips": "Sempre valide com estatística descritiva da amostra vs. população.",
                                  "learningObjective": "Aplicar análise para decisão final e documentação.",
                                  "commonMistakes": "Escolha sem justificativa quantitativa ou qualitativa robusta."
                                }
                              ],
                              "practicalExample": "Em uma simulação de tráfego urbano discreto, para coletar dados reais de veículos em uma cidade heterogênea (carros, ônibus, motos), use amostragem estratificada por tipo de veículo em 10 interseções selecionadas por conglomerados geográficos, garantindo representatividade de horários de pico e baixa.",
                              "finalVerifications": [
                                "O aluno lista corretamente 3 métodos probabilísticos com definições precisas.",
                                "Produz uma tabela comparativa sem erros factuais.",
                                "Justifica escolha em um cenário real com prós/contras e plano viável.",
                                "Simula amostra e verifica representatividade via estatísticas descritivas.",
                                "Identifica viés em planos incorretos propostos.",
                                "Documenta plano com tamanho de amostra calculado adequadamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação e descrição de métodos (30%)",
                                "Análise profunda de população e objetivos (20%)",
                                "Avaliação equilibrada de trade-offs (20%)",
                                "Justificativa lógica e evidenciada da escolha (15%)",
                                "Plano prático e testável (10%)",
                                "Ausência de erros comuns em amostragem (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Cálculo de tamanho de amostra e intervalos de confiança.",
                                "Pesquisa de Mercado: Aplicação em surveys de consumidores.",
                                "Ciências Sociais: Amostragem em estudos demográficos.",
                                "Programação: Implementação em Python/R para simulações.",
                                "Gestão de Projetos: Consideração de custos e logística."
                              ],
                              "realWorldApplication": "Em pesquisas eleitorais, como as do IBGE ou institutos como Datafolha, onde amostragem estratificada por região, idade e renda garante resultados representativos, evitando erros como os vistos em eleições subestimadas por viés urbano."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.1.3.1.3",
                            "name": "Execução da Coleta de Dados",
                            "description": "Realizar a coleta prática de dados utilizando ferramentas manuais ou automatizadas, registrando-os de forma organizada para posterior análise.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Planejamento e Preparação da Coleta",
                                  "subSteps": [
                                    "Definir os parâmetros exatos a serem coletados (ex.: variáveis, intervalo de tempo, número de amostras).",
                                    "Escolher ferramentas adequadas: manuais (cronômetro, régua) ou automatizadas (sensores IoT, scripts Python).",
                                    "Preparar o formato de registro: criar planilha ou banco de dados com colunas para data/hora, valor, observações.",
                                    "Testar ferramentas em um piloto rápido para garantir funcionamento.",
                                    "Estabelecer protocolo de segurança e contingências para falhas."
                                  ],
                                  "verification": "Lista de verificação assinada confirmando que todas as ferramentas estão prontas e protocolo definido.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Lista de verificação",
                                    "Ferramentas selecionadas (ex.: cronômetro, sensores)",
                                    "Planilha Excel ou Google Sheets"
                                  ],
                                  "tips": "Priorize ferramentas automatizadas quando possível para reduzir erros humanos; sempre faça um teste piloto curto.",
                                  "learningObjective": "Compreender e preparar adequadamente os recursos para uma coleta eficiente e confiável.",
                                  "commonMistakes": [
                                    "Escolher ferramenta inadequada para o ambiente (ex.: sensor sem bateria).",
                                    "Não definir formato de registro, levando a dados desorganizados."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Execução da Coleta de Dados",
                                  "subSteps": [
                                    "Iniciar a coleta seguindo o protocolo estritamente, registrando o início com timestamp.",
                                    "Coletar dados em intervalos definidos, anotando valores em tempo real.",
                                    "Monitorar condições ambientais que possam afetar os dados (ex.: temperatura, ruído).",
                                    "Pausar se necessário e registrar motivos para interrupções.",
                                    "Manter consistência no método para toda a amostra."
                                  ],
                                  "verification": "Registro inicial preenchido com pelo menos 80% dos dados planejados coletados.",
                                  "estimatedTime": "30-60 minutos",
                                  "materials": [
                                    "Ferramentas de coleta (manuais ou sensores)",
                                    "Dispositivo de registro móvel (tablet/celular)"
                                  ],
                                  "tips": "Registre dados imediatamente para evitar perda de memória; use voz para notas rápidas se mãos ocupadas.",
                                  "learningObjective": "Executar a coleta prática com precisão e aderência ao protocolo.",
                                  "commonMistakes": [
                                    "Ignorar variações ambientais, invalidando dados.",
                                    "Atrasos no registro levando a erros de memória."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Registro Organizado dos Dados",
                                  "subSteps": [
                                    "Transferir dados brutos para o formato digital estruturado imediatamente após cada sessão.",
                                    "Rotular cada entrada com metadados: ID da amostra, data/hora, unidade de medida.",
                                    "Categorizar dados em colunas claras e aplicar formatação condicional para outliers.",
                                    "Adicionar campo para observações qualitativas (ex.: 'condição climática ruim').",
                                    "Salvar versão inicial com backup em nuvem."
                                  ],
                                  "verification": "Planilha completa com todas as entradas rotuladas e sem campos vazios críticos.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "Software de planilhas (Excel, Google Sheets)",
                                    "Disco externo ou nuvem para backup"
                                  ],
                                  "tips": "Use fórmulas automáticas para timestamps; nomeie arquivos com data e descrição (ex.: 'coleta_fila_2023-10-01').",
                                  "learningObjective": "Registrar dados de forma organizada e rastreável para análise futura.",
                                  "commonMistakes": [
                                    "Esquecer metadados, dificultando rastreabilidade.",
                                    "Não fazer backup, arriscando perda de dados."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificação Inicial e Encerramento",
                                  "subSteps": [
                                    "Checar completude: contar entradas vs. planejado e identificar lacunas.",
                                    "Validar consistência: procurar valores impossíveis ou outliers sem explicação.",
                                    "Calcular estatísticas básicas (média, min/max) para sanity check.",
                                    "Documentar lições aprendidas e ajustes para próximas coletas.",
                                    "Arquivar dados finais com relatório de resumo."
                                  ],
                                  "verification": "Relatório de verificação assinado confirmando dados prontos para análise.",
                                  "estimatedTime": "10-20 minutos",
                                  "materials": [
                                    "Planilha com fórmulas de validação",
                                    "Template de relatório"
                                  ],
                                  "tips": "Use gráficos rápidos para visualizar anomalias; envolva um par para dupla checagem.",
                                  "learningObjective": "Garantir qualidade inicial dos dados antes da análise avançada.",
                                  "commonMistakes": [
                                    "Ignorar outliers sem investigação.",
                                    "Não documentar lições, repetindo erros."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de sistema de filas discretas (ex.: fila de supermercado), use um cronômetro manual para coletar tempos de chegada e atendimento de 50 clientes, registrando em Google Sheets com colunas: ClienteID, HoraChegada, HoraAtendimento, TempoEspera, Observações (ex.: 'fila extra'). Automatize com script Python se sensores RFID estiverem disponíveis.",
                              "finalVerifications": [
                                "Todos os dados planejados foram coletados sem lacunas >5%.",
                                "Registro organizado com metadados completos e backup realizado.",
                                "Verificação inicial passou sem outliers não explicados.",
                                "Protocolo seguido com documentação de desvios.",
                                "Dados prontos para importação em software de simulação (ex.: AnyLogic).",
                                "Relatório de lições aprendidas gerado."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude dos dados coletados (90%+ taxa de sucesso).",
                                "Organização e rotulagem clara do registro.",
                                "Eficiência no uso de ferramentas manuais/automáticas.",
                                "Qualidade da verificação inicial (detecção de erros).",
                                "Adesão ao protocolo e documentação de processo.",
                                "Tempo respeitado dentro das estimativas."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Preparação para análise descritiva e inferencial.",
                                "Programação: Automação de coleta com Python ou Arduino.",
                                "Física/Engenharia: Coleta em experimentos reais de sistemas dinâmicos.",
                                "Gestão de Projetos: Planejamento e controle de qualidade de dados.",
                                "Ciência de Dados: Integração com pipelines ETL."
                              ],
                              "realWorldApplication": "Em simulações industriais como otimização de linhas de produção (ex.: coleta de tempos em fábricas da Toyota), monitoramento ambiental (sensores em estações meteorológicas) ou pesquisas de tráfego urbano (dados de GPS para modelagem de fluxos), garantindo dados reais alimentem modelos computacionais precisos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.3.2",
                        "name": "Processamento Inicial de Dados",
                        "description": "Limpeza e organização dos dados coletados para eliminar erros e preparar para análise estatística.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.2.1",
                            "name": "Limpeza e Validação de Dados",
                            "description": "Identificar e tratar outliers, valores ausentes e inconsistências nos dados reais, utilizando técnicas como imputação ou remoção.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Inspeção Inicial dos Dados",
                                  "subSteps": [
                                    "Carregue o dataset utilizando bibliotecas como pandas em Python.",
                                    "Execute comandos básicos de info() e describe() para overview estatístico.",
                                    "Verifique o shape, tipos de dados e amostra inicial com head() e tail().",
                                    "Gere um relatório sumário de valores únicos por coluna.",
                                    "Salve um log inicial das dimensões e tipos observados."
                                  ],
                                  "verification": "Confirme que o relatório inicial foi gerado e não há erros de carregamento.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python com pandas e numpy instalados",
                                    "Dataset de exemplo (CSV com dados reais simulados)"
                                  ],
                                  "tips": "Sempre trabalhe em uma cópia do dataset original para evitar perda de dados.",
                                  "learningObjective": "Compreender a estrutura inicial do dataset e identificar potenciais problemas precocemente.",
                                  "commonMistakes": [
                                    "Ignorar tipos de dados incorretos",
                                    "Não salvar cópia do original",
                                    "Pular amostragem visual"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificação de Valores Ausentes e Inconsistências",
                                  "subSteps": [
                                    "Use isnull().sum() para quantificar valores ausentes por coluna.",
                                    "Verifique duplicatas com duplicated().sum() e valores únicos inconsistentes.",
                                    "Analise padrões de missing data com heatmap de seaborn ou missingno.",
                                    "Identifique inconsistências como strings em colunas numéricas ou formatos de data errados.",
                                    "Documente percentuais de missing values e tipos de inconsistências."
                                  ],
                                  "verification": "Relatório de missing values e duplicatas gerado com percentuais calculados.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Bibliotecas: pandas, seaborn, missingno",
                                    "Jupyter Notebook para visualizações"
                                  ],
                                  "tips": "Priorize colunas com >20% de missing values para decisão de remoção.",
                                  "learningObjective": "Detectar sistematicamente falhas de qualidade nos dados.",
                                  "commonMistakes": [
                                    "Confundir NaN com zero",
                                    "Não visualizar padrões de missing data",
                                    "Ignorar duplicatas parciais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detecção e Tratamento de Outliers",
                                  "subSteps": [
                                    "Calcule estatísticas descritivas e use boxplots para visualizar outliers.",
                                    "Aplique método IQR: Q1 - 1.5*IQR e Q3 + 1.5*IQR para detecção.",
                                    "Use z-score (>3 ou <-3) como método alternativo para variáveis normais.",
                                    "Decida tratamento: remoção, cap ou transformação logarítmica.",
                                    "Aplique o tratamento selecionado e compare before/after."
                                  ],
                                  "verification": "Boxplots antes e depois mostram redução de outliers sem perda excessiva de dados.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Pandas, matplotlib, scipy.stats",
                                    "Dataset com outliers artificiais"
                                  ],
                                  "tips": "Considere o contexto do domínio antes de remover outliers (podem ser válidos).",
                                  "learningObjective": "Aplicar técnicas estatísticas para identificar e gerenciar outliers.",
                                  "commonMistakes": [
                                    "Remover todos os outliers indiscriminadamente",
                                    "Usar IQR em dados não univariados",
                                    "Não comparar distribuições"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicação de Imputação e Limpeza Final",
                                  "subSteps": [
                                    "Para missing values: imputar com média/mediana/modo ou KNNImputer.",
                                    "Corrija inconsistências: padronize formatos, converta tipos de dados.",
                                    "Remova duplicatas com drop_duplicates().",
                                    "Aplique remoção seletiva de linhas/colunas com alta taxa de missing.",
                                    "Reinspecione o dataset com os mesmos comandos do step 1."
                                  ],
                                  "verification": "isnull().sum().all() == 0 e describe() mostra dados coerentes.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Scikit-learn para imputadores",
                                    "Pandas para correções"
                                  ],
                                  "tips": "Teste múltiplas imputações e escolha pela que preserva melhor a variância.",
                                  "learningObjective": "Implementar técnicas de imputação e correção para restaurar integridade dos dados.",
                                  "commonMistakes": [
                                    "Imputar com zero em dados positivos",
                                    "Não tratar multicolinearidade pós-imputação",
                                    "Sobrecorrigir tipos de dados"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validação e Documentação dos Dados Limpos",
                                  "subSteps": [
                                    "Execute validações cruzadas: checagem de ranges lógicos por coluna.",
                                    "Compare estatísticas descritivas antes e depois da limpeza.",
                                    "Gere visualizações finais (histograms, correlações).",
                                    "Crie um relatório de mudanças: % removido, método usado por issue.",
                                    "Salve dataset limpo e relatório em arquivos versionados."
                                  ],
                                  "verification": "Relatório final confirma qualidade: sem missing, outliers controlados, consistência.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Pandas profiling ou ydata-profiling para relatório automático"
                                  ],
                                  "tips": "Use versionamento com DVC ou Git para rastrear mudanças nos dados.",
                                  "learningObjective": "Validar a eficácia da limpeza e documentar para reprodutibilidade.",
                                  "commonMistakes": [
                                    "Pular validação de ranges de negócio",
                                    "Não versionar datasets",
                                    "Ignorar drift de distribuição"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um dataset de simulação de tráfego urbano (colunas: tempo, veículos, velocidade, acidentes), identifique 15% de velocidades ausentes (imputar mediana), outliers de veículos >10000 (remover via IQR), e datas duplicadas (drop_duplicates). Pós-limpeza, valide com boxplots e prepare para modelagem de simulação discreta.",
                              "finalVerifications": [
                                "Dataset final sem valores ausentes ou duplicatas.",
                                "Outliers reduzidos em pelo menos 80% sem perda >10% de linhas.",
                                "Estatísticas descritivas coerentes com domínio (ex: velocidades entre 0-120 km/h).",
                                "Visualizações confirmam distribuições normais ou esperadas.",
                                "Relatório documentado com métricas before/after.",
                                "Código reprodutível gera os mesmos resultados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção: >95% de issues identificados corretamente.",
                                "Escolha adequada de técnicas: justificada por contexto.",
                                "Eficiência: perda de dados <15%, variância preservada.",
                                "Documentação completa e clara.",
                                "Validação robusta com múltiplos métodos.",
                                "Código limpo, comentado e modular."
                              ],
                              "crossCurricularConnections": [
                                "Estatística Descritiva (IQR, z-score)",
                                "Programação em Python (pandas, scikit-learn)",
                                "Análise Exploratória de Dados (EDA)",
                                "Simulação de Sistemas Discretos (preparação para modelagem)",
                                "Gestão de Projetos de Dados (versionamento e relatórios)"
                              ],
                              "realWorldApplication": "Na simulação de sistemas discretos para logística, limpar dados de sensores IoT garante precisão em previsões de filas e otimização de rotas, evitando erros caros em operações reais como supply chain de e-commerce."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.1.3"
                            ]
                          },
                          {
                            "id": "10.1.1.3.2.2",
                            "name": "Organização e Armazenamento de Dados",
                            "description": "Estruturar os dados em formatos adequados (tabelas, bancos de dados) para facilitar o processamento computacional em ferramentas de simulação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Análise Inicial dos Dados Coletados",
                                  "subSteps": [
                                    "Liste todos os dados brutos coletados da simulação, incluindo variáveis como tempo, eventos e estados.",
                                    "Classifique os dados por tipo: numéricos (ex: tempo), categóricos (ex: tipo de evento) e textuais.",
                                    "Identifique volume de dados, relações entre variáveis e possíveis dados faltantes ou outliers.",
                                    "Defina requisitos de processamento futuro, como consultas frequentes ou agregações.",
                                    "Documente um mapa conceitual das entidades e atributos."
                                  ],
                                  "verification": "Crie um relatório de análise com classificação de dados e mapa conceitual salvo em documento editável.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Dados brutos da simulação",
                                    "Editor de texto ou planilha (Google Sheets/Excel)",
                                    "Papel e caneta para esboços"
                                  ],
                                  "tips": "Priorize dados que serão usados diretamente na simulação para evitar sobrecarga desnecessária.",
                                  "learningObjective": "Compreender a estrutura inerente dos dados para informar escolhas de formatação.",
                                  "commonMistakes": [
                                    "Ignorar dados faltantes ou inconsistentes",
                                    "Subestimar o volume de dados futuros",
                                    "Não mapear relações entre variáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Seleção do Formato e Ferramenta Adequada",
                                  "subSteps": [
                                    "Avalie opções: tabelas simples (CSV/Excel) para dados pequenos; bancos relacionais (SQLite) para dados complexos com relações.",
                                    "Considere critérios: volume de dados, necessidade de queries SQL, integração com ferramentas de simulação (ex: Python/R).",
                                    "Teste protótipos rápidos: crie amostras em cada formato e simule carregamento.",
                                    "Escolha baseado em escalabilidade e facilidade de exportação para processamento computacional.",
                                    "Justifique a escolha em um parágrafo documentado."
                                  ],
                                  "verification": "Documento com comparação de formatos, protótipos testados e escolha final justificada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Ferramentas: Excel, CSV editor, SQLite browser",
                                    "Amostra de dados (10-20 registros)"
                                  ],
                                  "tips": "Para simulações discretas, prefira formatos que suportem chaves primárias para eventos sequenciais.",
                                  "learningObjective": "Selecionar formatos otimizados para processamento computacional em simulações.",
                                  "commonMistakes": [
                                    "Escolher ferramenta complexa para dados simples",
                                    "Ignorar compatibilidade com linguagens de programação",
                                    "Não testar com amostras reais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Criação da Estrutura de Armazenamento",
                                  "subSteps": [
                                    "Defina schema: crie tabelas/colunas com nomes claros (ex: tabela 'Eventos' com colunas ID, Timestamp, TipoEvento).",
                                    "Estabeleça relacionamentos: chaves primárias, estrangeiras e índices para consultas rápidas.",
                                    "Configure validações: tipos de dados, constraints para integridade (ex: timestamps positivos).",
                                    "Implemente a estrutura vazia na ferramenta escolhida.",
                                    "Gere um diagrama ER (Entity-Relationship) simples da estrutura."
                                  ],
                                  "verification": "Estrutura criada e diagrama ER salvo; execute query de teste para listar colunas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Ferramenta selecionada (SQLite, Excel)",
                                    "Ferramenta de diagrama (Draw.io ou papel)",
                                    "Documentação de schema"
                                  ],
                                  "tips": "Use nomes de colunas em inglês ou padronizados para facilitar scripts automatizados.",
                                  "learningObjective": "Construir schemas robustos que suportem análise e simulação eficiente.",
                                  "commonMistakes": [
                                    "Colunas mal nomeadas levando a confusão",
                                    "Falta de índices causando lentidão",
                                    "Ignorar normalização de dados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "População, Validação e Teste Final",
                                  "subSteps": [
                                    "Insira dados brutos na estrutura, transformando formatos se necessário (ex: limpar strings).",
                                    "Valide integridade: cheque duplicatas, tipos corretos e completude (>95% preenchido).",
                                    "Execute queries de teste: agregações, filtros e joins simulando uso na ferramenta de simulação.",
                                    "Otimize se necessário: adicione índices ou reorganize baseados em performance.",
                                    "Exporte amostra para ferramenta de simulação e confirme carregamento sem erros."
                                  ],
                                  "verification": "Relatório de validação com métricas (ex: % dados válidos) e log de queries bem-sucedidas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Dados completos",
                                    "Ferramenta de queries (DB Browser for SQLite)",
                                    "Script de teste em Python/R"
                                  ],
                                  "tips": "Automatize inserções com scripts para grandes volumes e sempre backup antes.",
                                  "learningObjective": "Garantir que os dados organizados sejam acionáveis para processamento computacional.",
                                  "commonMistakes": [
                                    "Inserir dados sem limpeza prévia",
                                    "Não testar queries reais de simulação",
                                    "Sobrecarregar com dados desnecessários"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de sistema de filas em um call center, colete dados de 500 chamadas (ID_chamada, tempo_chegada, tempo_atendimento, agente_id). Estruture em tabela SQLite com chaves primárias em ID_chamada e agente_id como estrangeira, valide sem duplicatas e teste query: SELECT AVG(tempo_atendimento) GROUP BY agente_id para análise posterior no Python com pandas.",
                              "finalVerifications": [
                                "Todos os dados estão em formato estruturado (tabelas ou DB) sem erros de tipo.",
                                "Queries básicas executam em <5 segundos para conjuntos de até 10k registros.",
                                "Não há duplicatas ou valores nulos não tratados (>95% completude).",
                                "Dados podem ser exportados/carregados em ferramenta de simulação sem perda.",
                                "Diagrama de estrutura reflete fielmente o armazenamento implementado.",
                                "Backup do armazenamento criado e acessível."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude da estrutura (normalização, tipos corretos): 30%",
                                "Eficiência para processamento (índices, queries otimizadas): 25%",
                                "Facilidade de uso e documentação clara: 20%",
                                "Validação robusta (integridade, testes): 15%",
                                "Escalabilidade para dados maiores: 10%"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Integração com bibliotecas como pandas ou SQLAlchemy para automação.",
                                "Estatística: Preparação de dados para análises descritivas e inferenciais em simulações.",
                                "Ciência da Computação: Conceitos de bancos de dados relacionais e modelagem de dados.",
                                "Gestão de Projetos: Organização de dados como etapa crítica em fluxos de simulação."
                              ],
                              "realWorldApplication": "Em simulações de logística para empresas como Amazon, organizar dados de envios (origem, destino, tempo) em bancos de dados para otimizar rotas via algoritmos computacionais, reduzindo custos operacionais em milhões."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.3.3",
                        "name": "Análise e Parametrização",
                        "description": "Processamento estatístico dos dados para extrair parâmetros que serão usados no modelo de simulação discreta.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.3.1",
                            "name": "Análise Estatística Descritiva",
                            "description": "Calcular medidas como média, variância, percentis e histogramas para caracterizar as distribuições dos dados reais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e Explorar o Conjunto de Dados",
                                  "subSteps": [
                                    "Carregar dados reais de simulação (ex: CSV com tempos de espera) usando pandas.read_csv()",
                                    "Inspecionar estrutura com .shape, .info() e .head()",
                                    "Verificar valores ausentes com .isnull().sum()",
                                    "Executar .describe() para visão inicial das estatísticas",
                                    "Limpar dados: remover ou imputar NaNs se necessário"
                                  ],
                                  "verification": "Dataset carregado corretamente, .describe() exibido sem erros e dados limpos confirmados.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python 3.x",
                                    "pandas",
                                    "numpy",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Salve o dataset limpo em uma variável para reutilização.",
                                  "learningObjective": "Preparar dados reais para análise estatística descritiva precisa.",
                                  "commonMistakes": [
                                    "Ignorar valores ausentes levando a cálculos errados",
                                    "Não converter tipos de dados numéricos",
                                    "Prosseguir sem inspeção inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Medidas de Tendência Central",
                                  "subSteps": [
                                    "Calcular média aritmética com np.mean(dados) ou dados.mean()",
                                    "Calcular mediana com np.median(dados) ou dados.median()",
                                    "Calcular moda com scipy.stats.mode(dados) ou dados.mode()",
                                    "Armazenar resultados em um dicionário ou DataFrame",
                                    "Interpretar: discutir se dados são simétricos baseados nessas medidas"
                                  ],
                                  "verification": "Valores de média, mediana e moda calculados e exibidos com precisão de 4 casas decimais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "pandas",
                                    "numpy",
                                    "scipy"
                                  ],
                                  "tips": "Use amostra (ddof=1) para variância em dados empíricos.",
                                  "learningObjective": "Dominar cálculo e interpretação de medidas centrais em distribuições reais.",
                                  "commonMistakes": [
                                    "Confundir média com mediana em distribuições assimétricas",
                                    "Usar população em vez de amostra",
                                    "Não tratar multimodais na moda"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Medidas de Dispersão",
                                  "subSteps": [
                                    "Calcular variância com np.var(dados, ddof=1) ou dados.var()",
                                    "Calcular desvio padrão com np.std(dados, ddof=1) ou dados.std()",
                                    "Calcular intervalo (max - min) e amplitude interquartil (Q3 - Q1)",
                                    "Comparar dispersão com medidas centrais",
                                    "Registrar valores em relatório"
                                  ],
                                  "verification": "Variância e desvio padrão calculados corretamente e comparados com valores conhecidos de teste.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "pandas",
                                    "numpy"
                                  ],
                                  "tips": "Sempre use ddof=1 para variância amostral em simulações.",
                                  "learningObjective": "Quantificar variabilidade nos dados para caracterizar distribuições.",
                                  "commonMistakes": [
                                    "Usar variância populacional (ddof=0) em dados de simulação",
                                    "Ignorar outliers na dispersão",
                                    "Confundir variância com desvio padrão"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Determinar Percentis e Quartis",
                                  "subSteps": [
                                    "Calcular quartis Q1, Q2 (mediana), Q3 com np.percentile(dados, [25,50,75])",
                                    "Calcular percentis específicos (ex: 5%, 95%) com np.percentile(dados, [5,95])",
                                    "Construir boxplot com plt.boxplot() para visualização",
                                    "Identificar assimetria e outliers via boxplot",
                                    "Documentar percentis em tabela"
                                  ],
                                  "verification": "Quartis e percentis calculados, boxplot gerado e salvo como imagem.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python 3.x",
                                    "pandas",
                                    "numpy",
                                    "matplotlib"
                                  ],
                                  "tips": "Percentis são robustos a outliers, use-os para dados skewed.",
                                  "learningObjective": "Usar percentis para resumir posições na distribuição empírica.",
                                  "commonMistakes": [
                                    "Interpolação errada em percentis",
                                    "Não plotar boxplot para validação visual",
                                    "Confundir Q1 com 25th percentile"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Construir e Interpretar Histogramas",
                                  "subSteps": [
                                    "Definir bins ótimos com np.histogram_bin_edges(dados, bins='auto')",
                                    "Plotar histograma com plt.hist(dados, bins=30, density=True)",
                                    "Adicionar curva de densidade kernel se aplicável (seaborn.kdeplot)",
                                    "Analisar forma: unimodal, skewed, kurtosis visual",
                                    "Salvar gráfico e escrever interpretação (ex: 'distribuição approx exponencial')"
                                  ],
                                  "verification": "Histograma plotado corretamente, interpretado em parágrafo curto e salvo.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python 3.x",
                                    "pandas",
                                    "matplotlib",
                                    "seaborn"
                                  ],
                                  "tips": "Normalize (density=True) para comparar com PDFs teóricas.",
                                  "learningObjective": "Visualizar e caracterizar distribuições de dados reais via histogramas.",
                                  "commonMistakes": [
                                    "Escolha ruim de bins distorcendo forma",
                                    "Escala errada no eixo y",
                                    "Não interpretar skewness/kurtosis"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de sistema de filas M/M/1 com 1000 chegadas, analise os tempos de espera: calcule média (2.5 min), variância (4.2), 95th percentile (8.1 min) e histograma para confirmar distribuição exponencial aproximada.",
                              "finalVerifications": [
                                "Todas medidas (média, variância, percentis) calculadas com precisão <0.01 erro relativo",
                                "Histogramas e boxplots gerados e salvos sem erros",
                                "Relatório escrito resumindo características da distribuição",
                                "Código executável reproduz resultados idênticos",
                                "Dados originais preservados e limpos documentados",
                                "Interpretação conecta resultados à simulação de sistemas discretos"
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica dos cálculos estatísticos",
                                "Qualidade e correção das visualizações (histogramas, boxplots)",
                                "Profundidade da interpretação das medidas e distribuições",
                                "Código limpo, comentado e modular",
                                "Tratamento adequado de dados reais (limpeza, outliers)",
                                "Conexão explícita com contexto de simulação"
                              ],
                              "crossCurricularConnections": [
                                "Programação Computacional: Manipulação de dados com pandas/numpy",
                                "Probabilidade e Estatística: Identificação de distribuições empíricas",
                                "Simulação de Sistemas: Análise de outputs de Monte Carlo",
                                "Ciência de Dados: EDA (Exploratory Data Analysis)",
                                "Engenharia: Otimização de processos baseados em estatísticas"
                              ],
                              "realWorldApplication": "Em simulações de call centers, analisar tempos de atendimento para dimensionar equipes; em logística, tempos de entrega para otimizar rotas e prever atrasos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.2.2"
                            ]
                          },
                          {
                            "id": "10.1.1.3.3.2",
                            "name": "Ajuste de Distribuições de Probabilidade",
                            "description": "Testar e ajustar distribuições probabilísticas (ex.: exponencial, normal, Poisson) aos dados reais para parametrizar geradores de variáveis aleatórias na simulação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Coleta e Preparação Inicial dos Dados Reais",
                                  "subSteps": [
                                    "Reúna dados reais relevantes para a simulação, como tempos de chegada ou durações de eventos.",
                                    "Limpe os dados removendo outliers, valores ausentes e inconsistências usando ferramentas como pandas em Python.",
                                    "Calcule estatísticas descritivas básicas: média, mediana, variância, assimetria e curtose.",
                                    "Crie histogramas e gráficos Q-Q para visualizar a distribuição empírica.",
                                    "Transforme os dados se necessário (ex.: log para dados assimétricos)."
                                  ],
                                  "verification": "Dados limpos e estatísticas descritivas documentadas em um relatório ou notebook Jupyter.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Conjunto de dados reais (CSV/Excel)",
                                    "Python com pandas, numpy, matplotlib/seaborn",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Sempre documente transformações aplicadas para rastreabilidade.",
                                  "learningObjective": "Preparar dados reais de forma limpa e analisável para testes de distribuição.",
                                  "commonMistakes": [
                                    "Ignorar outliers sem justificativa",
                                    "Não calcular momentos para guiar seleção de distribuições"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Seleção e Teste de Distribuições Candidatas",
                                  "subSteps": [
                                    "Identifique distribuições candidatas baseadas em estatísticas descritivas (ex.: Poisson para contagens, exponencial para tempos entre eventos).",
                                    "Aplique testes de aderência como Kolmogorov-Smirnov (KS), Anderson-Darling ou Chi-quadrado para cada distribuição.",
                                    "Use gráficos de probabilidade (PP plots) e Q-Q plots para inspeção visual.",
                                    "Calcule p-valores e estatísticas de teste para ranquear as melhores candidatas.",
                                    "Selecione as top 2-3 distribuições com melhor ajuste preliminar."
                                  ],
                                  "verification": "Relatório com resultados de testes (p-valores > 0.05) e gráficos comparativos salvos.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Python com scipy.stats, statsmodels",
                                    "Jupyter Notebook",
                                    "Dados preparados do Step 1"
                                  ],
                                  "tips": "Combine testes formais com inspeção visual para decisões robustas.",
                                  "learningObjective": "Avaliar empiricamente quais distribuições se ajustam melhor aos dados.",
                                  "commonMistakes": [
                                    "Escolher distribuição sem testes estatísticos",
                                    "Ignorar múltiplas candidatas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estimação e Ajuste de Parâmetros das Distribuições",
                                  "subSteps": [
                                    "Estime parâmetros usando Maximum Likelihood Estimation (MLE) para cada distribuição candidata.",
                                    "Implemente métodos alternativos como momentos ou regressão para comparação.",
                                    "Gere amostras simuladas com os parâmetros estimados.",
                                    "Compare estatísticas das amostras simuladas com as dos dados reais (média, variância, etc.).",
                                    "Ajuste iterativamente parâmetros se necessário para minimizar discrepâncias."
                                  ],
                                  "verification": "Parâmetros estimados documentados e amostras simuladas geradas com erro < 5% em estatísticas chave.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Python com scipy.stats (fit()), numpy.random",
                                    "Otimização com scipy.optimize se necessário"
                                  ],
                                  "tips": "Use MLE como padrão, mas valide com bootstrap para robustez.",
                                  "learningObjective": "Parametrizar distribuições de forma precisa para geração de variáveis aleatórias.",
                                  "commonMistakes": [
                                    "Usar média simples sem MLE",
                                    "Não validar parâmetros com simulações"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validação Final e Parametrização para Simulação",
                                  "subSteps": [
                                    "Execute simulações completas usando os geradores parametrizados (ex.: np.random.exponential).",
                                    "Compare distribuições simuladas vs. reais via testes KS e métricas como KS statistic ou AIC/BIC.",
                                    "Selecione a melhor distribuição baseada em critérios compostos (teste + informação + visual).",
                                    "Documente parâmetros finais para uso em geradores de simulação.",
                                    "Teste sensibilidade variando parâmetros ligeiramente."
                                  ],
                                  "verification": "Distribuição selecionada com KS p-value > 0.05 e parâmetros prontos para código de simulação.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Código de simulação em Python",
                                    "Ferramentas de teste do Step 2"
                                  ],
                                  "tips": "Prefira AIC/BIC para comparar modelos não aninhados.",
                                  "learningObjective": "Validar e finalizar o ajuste para aplicação em simulações reais.",
                                  "commonMistakes": [
                                    "Aceitar ajuste sem validação em simulações",
                                    "Não considerar critérios de informação"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado, colete tempos entre chegadas de clientes (dados reais: 120 observações). Teste exponencial (λ estimado via MLE), normal e lognormal. Ajuste exponencial se encaixa melhor (KS p=0.12), parametrizando np.random.exponential(1/λ) para gerar chegadas na simulação.",
                              "finalVerifications": [
                                "Testes de aderência (KS/Chi2) aprovam a distribuição selecionada (p > 0.05).",
                                "Estatísticas simuladas (média, variância, quantis) coincidem com dados reais (±5%).",
                                "Gráficos Q-Q e histogramas sobrepostos mostram bom overlay.",
                                "AIC/BIC menor para a distribuição escolhida vs. alternativas.",
                                "Gerador parametrizado reproduz dados reais em simulação de 10.000 runs.",
                                "Documentação completa com código reproduzível."
                              ],
                              "assessmentCriteria": [
                                "Precisão do ajuste: erro em momentos < 10%.",
                                "Uso correto de múltiplos testes e critérios de seleção.",
                                "Qualidade da preparação e visualização de dados.",
                                "Implementação eficiente de MLE e validação.",
                                "Documentação clara com justificativas e código.",
                                "Tratamento de erros comuns e sensibilidade."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Testes de hipóteses e estimação de parâmetros.",
                                "Programação: Implementação numérica com Python/NumPy/SciPy.",
                                "Engenharia de Simulação: Modelagem estocástica de sistemas.",
                                "Ciência de Dados: Análise exploratória e modelagem preditiva.",
                                "Probabilidade: Propriedades de distribuições discretas/contínuas."
                              ],
                              "realWorldApplication": "Em simulações de call centers para otimizar escalas de atendentes ajustando distribuições de chamadas (Poisson); em manufatura para modelar falhas de máquinas (Weibull/Exponencial); ou em logística para tempos de trânsito (lognormal), permitindo previsões precisas e otimização de recursos."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.3.1"
                            ]
                          },
                          {
                            "id": "10.1.1.3.3.3",
                            "name": "Extração de Parâmetros do Modelo",
                            "description": "Derivar parâmetros específicos do modelo de simulação, como taxas de chegada/saída ou tempos de serviço, a partir da análise dos dados processados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e Revisar Dados Processados",
                                  "subSteps": [
                                    "Carregue os dados brutos da simulação em uma ferramenta de análise (ex: Python com Pandas ou R).",
                                    "Limpe os dados removendo outliers e valores ausentes usando técnicas como z-score ou imputação média.",
                                    "Visualize os dados com histogramas, boxplots e séries temporais para identificar padrões iniciais.",
                                    "Segmente os dados por eventos relevantes, como chegadas e saídas no sistema.",
                                    "Documente estatísticas descritivas básicas: média, mediana, variância e desvios padrão."
                                  ],
                                  "verification": "Confirme que os dados estão limpos e visualizações mostram padrões claros sem anomalias evidentes.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software de análise (Python/Pandas, R, Excel)",
                                    "Dados de simulação processados",
                                    "Notebooks Jupyter ou R Markdown"
                                  ],
                                  "tips": "Sempre backup os dados originais antes de limpar para evitar perda de informação.",
                                  "learningObjective": "Entender a importância da preparação de dados para extração precisa de parâmetros.",
                                  "commonMistakes": [
                                    "Ignorar outliers que afetam médias",
                                    "Não segmentar dados por tipo de evento",
                                    "Usar visualizações inadequadas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Parâmetros Específicos do Modelo",
                                  "subSteps": [
                                    "Revise o modelo de simulação para listar parâmetros alvo (ex: λ para taxa de chegada, μ para taxa de serviço).",
                                    "Mapeie eventos nos dados aos parâmetros (ex: timestamps de chegada para λ).",
                                    "Defina hipóteses sobre distribuições (Poisson para chegadas, Exponencial para serviços).",
                                    "Crie uma tabela de mapeamento: parâmetro, eventos associados, método de estimação.",
                                    "Priorize parâmetros com maior impacto na simulação."
                                  ],
                                  "verification": "Tabela de mapeamento completa e alinhada com o modelo teórico.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Descrição do modelo de simulação",
                                    "Planilha ou documento para mapeamento"
                                  ],
                                  "tips": "Consulte literatura de simulação (ex: bancos de filas M/M/1) para hipóteses padrão.",
                                  "learningObjective": "Mapear corretamente dados observados aos parâmetros do modelo.",
                                  "commonMistakes": [
                                    "Confundir parâmetros de chegada com saída",
                                    "Ignorar dependências entre parâmetros",
                                    "Escolher distribuições inadequadas sem justificativa"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estimar Parâmetros Usando Métodos Estatísticos",
                                  "subSteps": [
                                    "Calcule estimativas pontuais: λ = número de chegadas / tempo total; média de tempo de serviço.",
                                    "Ajuste distribuições paramétricas usando MLE (Maximum Likelihood Estimation) ou momentos.",
                                    "Use testes de aderência (Kolmogorov-Smirnov, Chi-quadrado) para validar o ajuste.",
                                    "Gere intervalos de confiança via bootstrap ou fórmulas analíticas.",
                                    "Compare múltiplas estimativas e selecione a melhor com base em critérios como AIC/BIC."
                                  ],
                                  "verification": "Estimativas com intervalos de confiança e testes de aderência aprovados (p-value > 0.05).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Bibliotecas SciPy/Statsmodels em Python ou fitdistrplus em R",
                                    "Código de estimação preparado"
                                  ],
                                  "tips": "Implemente funções reutilizáveis para estimação para eficiência em múltiplos parâmetros.",
                                  "learningObjective": "Aplicar técnicas estatísticas para derivar parâmetros precisos de dados simulados.",
                                  "commonMistakes": [
                                    "Usar médias simples sem testar distribuições",
                                    "Não calcular intervalos de confiança",
                                    "Ignorar autocorrelação em dados de simulação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Refinar Parâmetros Extraídos",
                                  "subSteps": [
                                    "Reinsira parâmetros no modelo e rode uma simulação de validação curta.",
                                    "Compare saídas simuladas com dados originais (médias, variâncias, QQ-plots).",
                                    "Ajuste parâmetros iterativamente se discrepâncias > 5%.",
                                    "Documente sensibilidade analisando variações nos parâmetros.",
                                    "Gere relatório final com valores finais, justificativas e métricas de validação."
                                  ],
                                  "verification": "Simulação validada reproduz dados originais com erro < 5% em métricas chave.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software de simulação (ex: SimPy, Arena)",
                                    "Modelo de simulação atualizado"
                                  ],
                                  "tips": "Use métricas como RMSE ou KS statistic para quantificar validação.",
                                  "learningObjective": "Garantir que parâmetros extraídos sejam robustos e aplicáveis ao modelo.",
                                  "commonMistakes": [
                                    "Pular validação por pressa",
                                    "Ajustes excessivos levando a overfitting",
                                    "Não documentar iterações"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado, extraia λ (taxa de chegada de clientes) contando chegadas por hora nos logs de tempo, e μ (taxa de serviço) calculando a média exponencial dos tempos de checkout de 1000 transações, validando com QQ-plot contra distribuição exponencial.",
                              "finalVerifications": [
                                "Parâmetros estimados têm intervalos de confiança estreitos (<10% da estimativa).",
                                "Testes de aderência confirmam bom ajuste de distribuições (p>0.05).",
                                "Simulação validada reproduz estatísticas originais (média, variância) com erro <5%.",
                                "Documentação inclui mapeamento, cálculos e justificativas.",
                                "Sensibilidade analisada mostra estabilidade dos resultados."
                              ],
                              "assessmentCriteria": [
                                "Precisão das estimativas (comparada a valores conhecidos ou benchmarks).",
                                "Correto uso de métodos estatísticos e testes apropriados.",
                                "Qualidade da validação com simulações e métricas quantitativas.",
                                "Completude da documentação e mapeamento de parâmetros.",
                                "Eficiência no tempo e recursos utilizados.",
                                "Identificação e correção de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Estimação paramétrica e testes de hipóteses.",
                                "Programação: Manipulação de dados com Python/R e simulação.",
                                "Matemática Aplicada: Teoria de Filas e Processos Estocásticos.",
                                "Ciência de Dados: Limpeza, visualização e modelagem preditiva."
                              ],
                              "realWorldApplication": "Em logística, extrair taxas de chegada de pacotes e tempos de processamento em centros de distribuição para otimizar alocação de recursos e reduzir esperas; usado por empresas como Amazon ou FedEx em modelagem de supply chain."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.4",
                    "name": "Implementação Computacional",
                    "description": "Codificação do modelo em software ou linguagem de simulação.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.4.1",
                        "name": "Seleção de Linguagens e Softwares de Simulação",
                        "description": "Identificação e avaliação de linguagens de programação gerais e específicas para simulação, bem como softwares especializados, considerando critérios como facilidade de uso, suporte a eventos discretos e performance.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.1.1",
                            "name": "Classificar linguagens de simulação",
                            "description": "Diferenciar linguagens gerais (ex.: Python com SimPy, Java) de linguagens específicas (ex.: Simula, GPSS) e softwares comerciais (ex.: Arena, AnyLogic), analisando suas características para sistemas discretos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender linguagens de propósito geral para simulação",
                                  "subSteps": [
                                    "Pesquise definições e exemplos de linguagens gerais como Python com SimPy e Java.",
                                    "Identifique características chave: flexibilidade, bibliotecas extensíveis, uso em múltiplos domínios.",
                                    "Analise como elas suportam modelagem de eventos discretos via programação imperativa ou orientada a objetos.",
                                    "Compare com linguagens não-simulação para destacar adaptações.",
                                    "Registre prós (acessibilidade, comunidade) e contras (curva de aprendizado para simulação)."
                                  ],
                                  "verification": "Crie uma tabela comparativa com pelo menos 3 linguagens gerais e suas features para simulação discreta.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Documentação SimPy (simpy.readthedocs.io)",
                                    "Tutoriais Java para simulação",
                                    "Notebook Jupyter para testes"
                                  ],
                                  "tips": "Comece com Python/SimPy por ser mais acessível; use exemplos simples de filas.",
                                  "learningObjective": "Identificar e descrever linguagens gerais usadas em simulação de sistemas discretos.",
                                  "commonMistakes": [
                                    "Confundir bibliotecas com linguagens nativas",
                                    "Ignorar suporte a eventos discretos",
                                    "Não considerar performance em larga escala"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar linguagens específicas de simulação",
                                  "subSteps": [
                                    "Estude linguagens como Simula e GPSS: origens históricas e design focado em simulação.",
                                    "Liste características: primitives para filas, eventos, clocks de simulação.",
                                    "Examine sintaxe especializada (ex.: BLOCK, ADVANCE em GPSS).",
                                    "Avalie limitações atuais vs. linguagens modernas.",
                                    "Colete casos de uso em sistemas discretos como manufatura."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras comparando Simula e GPSS com linguagens gerais.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro 'Simulation Modeling and Analysis' de Law",
                                    "Documentação GPSS/H",
                                    "Artigos acadêmicos sobre Simula"
                                  ],
                                  "tips": "Foque em primitives de simulação para diferenciar de linguagens gerais.",
                                  "learningObjective": "Diferenciar linguagens específicas por suas features dedicadas a simulação discreta.",
                                  "commonMistakes": [
                                    "Subestimar obsolescência",
                                    "Confundir com softwares comerciais",
                                    "Ignorar herança em ferramentas modernas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar softwares comerciais de simulação",
                                  "subSteps": [
                                    "Investigue Arena e AnyLogic: interfaces gráficas, modelagem drag-and-drop.",
                                    "Descreva características: animação visual, integração estatística, exportação de resultados.",
                                    "Compare licenciamento, custo e escalabilidade para projetos industriais.",
                                    "Teste demos gratuitas para modelar um sistema discreto simples.",
                                    "Avalie suporte a linguagens embutidas (ex.: Java em AnyLogic)."
                                  ],
                                  "verification": "Instale demo de Arena/AnyLogic e modele uma fila única, documentando o processo.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Trial de Arena Simulation",
                                    "AnyLogic PLE (versão gratuita)",
                                    "Tutoriais oficiais YouTube"
                                  ],
                                  "tips": "Use trials gratuitos; priorize modelagem visual vs. código puro.",
                                  "learningObjective": "Classificar softwares comerciais por facilidades em simulação discreta.",
                                  "commonMistakes": [
                                    "Confundir com linguagens open-source",
                                    "Ignorar custos de licença",
                                    "Não testar usabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar e classificar linguagens baseadas em características",
                                  "subSteps": [
                                    "Crie critérios de classificação: propósito (geral/específico/comercial), suporte a eventos discretos, facilidade de uso.",
                                    "Classifique exemplos dados: Python/SimPy (geral), GPSS (específica), Arena (comercial).",
                                    "Analise trade-offs para sistemas discretos (ex.: velocidade vs. flexibilidade).",
                                    "Desenvolva uma matriz de decisão para seleção.",
                                    "Aplique a um caso: simulação de call center."
                                  ],
                                  "verification": "Produza uma matriz de classificação com 6+ exemplos e justifique escolhas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Planilha Google Sheets/Excel para matriz",
                                    "Artigos de revisão sobre ferramentas de simulação"
                                  ],
                                  "tips": "Use tabela com colunas: Tipo, Features, Prós/Contras, Adequação discreta.",
                                  "learningObjective": "Aplicar análise comparativa para classificar linguagens em contextos de simulação discreta.",
                                  "commonMistakes": [
                                    "Classificação superficial sem critérios",
                                    "Ignorar contexto de sistemas discretos",
                                    "Viés para ferramentas familiares"
                                  ]
                                }
                              ],
                              "practicalExample": "Para simular um sistema de filas em um supermercado (eventos discretos: chegada de clientes, checkout), classifique: Python/SimPy (geral - código flexível), GPSS (específica - primitives de fila nativas), Arena (comercial - modelagem visual rápida). Escolha Arena para protótipo rápido, SimPy para customizações avançadas.",
                              "finalVerifications": [
                                "Lista corretamente 3 exemplos de cada categoria com justificativa.",
                                "Cria matriz de classificação precisa para novos exemplos.",
                                "Explica trade-offs para um sistema discreto específico.",
                                "Identifica características chave de eventos discretos em cada tipo.",
                                "Aplica classificação a um cenário real sem erros.",
                                "Diferencia softwares de linguagens puras."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção entre tipos (90%+ acurácia).",
                                "Profundidade na análise de características (cita primitives específicas).",
                                "Uso de critérios claros e relevantes para sistemas discretos.",
                                "Criatividade em exemplos e matrizes comparativas.",
                                "Capacidade de justificar escolhas com trade-offs.",
                                "Integração de exemplos práticos e verificáveis."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em linguagens gerais.",
                                "Estatística: Análise de resultados de simulações.",
                                "Engenharia de Produção: Otimização de sistemas discretos.",
                                "Ciência da Computação: Paradigmas de modelagem de eventos.",
                                "Gestão de Projetos: Seleção de ferramentas por custo-benefício."
                              ],
                              "realWorldApplication": "Em logística, classificar ferramentas permite escolher Arena para modelar linhas de montagem rapidamente (reduzindo tempo de protótipo em 70%), ou Python/SimPy para integrações customizadas em supply chain, otimizando estoques e evitando gargalos em indústrias como automotiva."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.1.2",
                            "name": "Avaliar softwares de simulação",
                            "description": "Aplicar critérios de avaliação como custo, suporte técnico, bibliotecas para geração aleatória e modelagem de eventos discretos para selecionar o software adequado ao modelo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir Critérios de Avaliação",
                                  "subSteps": [
                                    "Identifique critérios principais: custo (licença, manutenção), suporte técnico (documentação, comunidade), bibliotecas para geração aleatória (distribuições estatísticas), modelagem de eventos discretos (suporte a queues, processos).",
                                    "Adicione critérios secundários: usabilidade, performance, compatibilidade com linguagens e integração com dados reais.",
                                    "Atribua pesos ou escalas (ex: 1-10) para cada critério baseado no contexto do modelo de simulação.",
                                    "Documente em uma tabela comparativa com descrições claras para cada critério.",
                                    "Valide critérios consultando requisitos do modelo específico."
                                  ],
                                  "verification": "Tabela de critérios completa com pelo menos 5 itens, pesos atribuídos e justificados.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Folha de cálculo (Excel/Google Sheets)",
                                    "Documentação do modelo de simulação",
                                    "Lista de requisitos do projeto"
                                  ],
                                  "tips": "Priorize critérios alinhados ao escopo do modelo; inclua escalabilidade para simulações grandes.",
                                  "learningObjective": "Customizar critérios de avaliação relevantes para simulações discretas.",
                                  "commonMistakes": [
                                    "Esquecer critérios de longo prazo como atualizações.",
                                    "Não contextualizar pesos ao modelo específico.",
                                    "Listar critérios genéricos sem métricas mensuráveis."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Pesquisar e Listar Softwares Candidatos",
                                  "subSteps": [
                                    "Busque softwares populares para simulação discreta: Arena, Simul8, AnyLogic, SimPy (Python), ExtendSim.",
                                    "Compile lista de pelo menos 3-5 opções usando fontes confiáveis (sites oficiais, fóruns como Stack Overflow, reviews acadêmicos).",
                                    "Registre informações iniciais: versão atual, plataformas suportadas, casos de uso semelhantes ao modelo.",
                                    "Filtre opções iniciais eliminando incompatíveis (ex: sem suporte a eventos discretos).",
                                    "Crie perfil resumido para cada software."
                                  ],
                                  "verification": "Lista documentada de 3-5 softwares com links para documentação e resumo inicial.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Internet para pesquisa",
                                    "Navegador web",
                                    "Ferramentas de notas (Notion/Evernote)"
                                  ],
                                  "tips": "Use termos como 'discrete event simulation software' em buscas; priorize open-source para custo baixo.",
                                  "learningObjective": "Identificar e catalogar ferramentas relevantes para simulação computacional.",
                                  "commonMistakes": [
                                    "Limitar a softwares comerciais caros.",
                                    "Ignorar opções open-source como SimPy.",
                                    "Não verificar atualizações recentes."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar Cada Software Contra os Critérios",
                                  "subSteps": [
                                    "Para cada critério, colete dados: custo via pricing pages, suporte via docs/forums, bibliotecas testando demos.",
                                    "Teste hands-on: instale trials/demos e verifique geração aleatória (ex: distribuições Poisson) e modelagem de eventos.",
                                    "Pontue cada software (ex: escala 1-10) com evidências (screenshots, quotes de docs).",
                                    "Registre prós/contras qualitativos para cada critério.",
                                    "Atualize tabela comparativa com pontuações e evidências."
                                  ],
                                  "verification": "Tabela preenchida com pontuações, evidências e testes para todos critérios e softwares.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Trials/demos dos softwares",
                                    "Máquina com specs adequadas",
                                    "Tabela de critérios"
                                  ],
                                  "tips": "Automatize testes simples com scripts; foque em features essenciais para eventos discretos.",
                                  "learningObjective": "Aplicar critérios de forma objetiva e baseada em evidências.",
                                  "commonMistakes": [
                                    "Avaliações subjetivas sem testes.",
                                    "Não testar bibliotecas reais.",
                                    "Ignorar limitações de performance."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar, Selecionar e Justificar",
                                  "subSteps": [
                                    "Calcule pontuação total ponderada para cada software.",
                                    "Compare visualmente (gráficos de radar ou barras na planilha).",
                                    "Selecione o top 1-2 com justificativa detalhada alinhada ao modelo.",
                                    "Considere trade-offs (ex: custo vs. suporte) e alternativas.",
                                    "Documente relatório final com recomendação e plano de implementação."
                                  ],
                                  "verification": "Relatório final com seleção justificada, tabela final e visualizações.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Tabela comparativa completa",
                                    "Ferramenta de gráficos (Excel)"
                                  ],
                                  "tips": "Use fórmulas para pontuações automáticas; valide com stakeholder simulado.",
                                  "learningObjective": "Tomar decisões baseadas em análise comparativa estruturada.",
                                  "commonMistakes": [
                                    "Selecionar pelo nome famoso sem dados.",
                                    "Ignorar trade-offs.",
                                    "Relatório vago sem justificativas quantitativas."
                                  ]
                                }
                              ],
                              "practicalExample": "Para simular um sistema de filas em um call center (eventos discretos com chegadas Poisson), avalie Arena (comercial, rico em bibliotecas), SimPy (Python, gratuito, flexível para aleatoriedade) e AnyLogic (híbrido). Colete custos (Arena: $10k/ano; SimPy: grátis), teste suporte a queues e selecione SimPy por custo-benefício.",
                              "finalVerifications": [
                                "Lista de critérios personalizados com pesos documentados.",
                                "Pelo menos 3 softwares pesquisados e avaliados com evidências.",
                                "Tabela comparativa completa com pontuações e testes hands-on.",
                                "Seleção justificada com trade-offs explicitados.",
                                "Relatório final pronto para apresentação.",
                                "Demonstração de teste em um software selecionado."
                              ],
                              "assessmentCriteria": [
                                "Precisão e relevância dos critérios (alinhados a simulação discreta).",
                                "Profundidade da pesquisa (fontes variadas, testes reais).",
                                "Objetividade nas pontuações (evidências fornecidas).",
                                "Qualidade da comparação (visuais, ponderação correta).",
                                "Justificativa da seleção (contexto do modelo considerado).",
                                "Clareza e completude do relatório final."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Integração com linguagens como Python/R para extensibilidade.",
                                "Estatística: Validação de bibliotecas de geração aleatória e distribuições.",
                                "Gestão de Projetos: Processo decisório baseado em critérios múltiplos.",
                                "Engenharia de Software: Avaliação de usabilidade e manutenção."
                              ],
                              "realWorldApplication": "Em logística, manufatura ou saúde, para selecionar software que otimize simulações de processos como linhas de produção ou atendimento hospitalar, reduzindo custos e tempo de desenvolvimento."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.1.3",
                            "name": "Comparar implementações em diferentes ferramentas",
                            "description": "Realizar comparações práticas entre implementações simples em linguagens como Python/SimPy e Arena, destacando vantagens em termos de flexibilidade e velocidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Implementar um modelo de simulação simples em Python com SimPy",
                                  "subSteps": [
                                    "Instalar SimPy via pip se necessário.",
                                    "Definir um modelo básico de fila única (single-server queue) com chegada de clientes e tempo de serviço exponencial.",
                                    "Escrever o código para simular 1000 chegadas e registrar métricas como tempo de espera médio.",
                                    "Executar a simulação e salvar resultados em um arquivo CSV.",
                                    "Documentar o código com comentários sobre flexibilidade para modificações."
                                  ],
                                  "verification": "Código roda sem erros e gera CSV com métricas corretas (ex: tempo médio de espera próximo a 1 unidade se λ=1, μ=1).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python 3.x, SimPy library, editor de código (VS Code ou Jupyter Notebook)",
                                  "tips": "Use ambientes virtuais para evitar conflitos de dependências.",
                                  "learningObjective": "Dominar a implementação rápida e flexível de simulações em código aberto.",
                                  "commonMistakes": "Esquecer de importar bibliotecas ou definir sementes aleatórias para reprodutibilidade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o mesmo modelo em Arena Simulation Software",
                                  "subSteps": [
                                    "Baixar e instalar Arena (versão trial se necessário).",
                                    "Criar módulos básicos: Create, Process, Dispose para fila única.",
                                    "Configurar distribuições exponenciais para chegadas (λ=1) e serviço (μ=1), rodar para 1000 entidades.",
                                    "Coletar estatísticas automáticas de tempo de espera médio via relatórios do Arena.",
                                    "Salvar o modelo .do e exportar relatório para PDF ou Excel."
                                  ],
                                  "verification": "Simulação roda e relatório mostra tempo médio de espera similar ao Python (aprox. 1 unidade).",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Arena Simulation Software, licença trial, computador com Windows",
                                  "tips": "Use o Basic Process panel para setups rápidos; teste com poucas entidades primeiro.",
                                  "learningObjective": "Entender a implementação visual e gráfica de simulações em software proprietário.",
                                  "commonMistakes": "Configurar incorretamente as distribuições ou não replicar o número exato de entidades."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar simulações comparativas e coletar métricas de desempenho",
                                  "subSteps": [
                                    "Rodar múltiplas réplicas (ex: 10 runs) em cada ferramenta, medindo tempo de execução total.",
                                    "Registrar métricas: tempo de simulação, tempo de setup/código, facilidade de mudança de parâmetros.",
                                    "Usar timeit em Python e cronômetro manual no Arena para medir velocidade.",
                                    "Comparar outputs estatísticos para validar equivalência do modelo.",
                                    "Criar uma tabela comparativa em Excel ou Markdown."
                                  ],
                                  "verification": "Tabela preenchida com tempos de execução (Python geralmente mais rápido para scripts simples) e métricas estatísticas concordantes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha Excel/Google Sheets, cronômetro",
                                  "tips": "Padronize hardware e desative antivírus durante testes para precisão.",
                                  "learningObjective": "Coletar dados empíricos objetivos para comparação quantitativa.",
                                  "commonMistakes": "Não usar réplicas suficientes, levando a variância alta nos resultados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar vantagens e documentar a comparação",
                                  "subSteps": [
                                    "Destacar flexibilidade: Python permite customizações infinitas vs. Arena mais limitado a módulos.",
                                    "Comparar velocidade: Arena mais rápido para GUIs complexas, Python para scripts leves.",
                                    "Discutir custo: Python grátis vs. Arena licenciado.",
                                    "Escrever relatório curto (1 página) com prós/contras e recomendação baseada em cenários.",
                                    "Compartilhar código e relatório em repositório GitHub."
                                  ],
                                  "verification": "Relatório completo identifica pelo menos 3 vantagens por ferramenta com evidências.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Editor de texto, GitHub account",
                                  "tips": "Use bullet points para clareza; inclua screenshots de outputs.",
                                  "learningObjective": "Sintetizar achados em insights acionáveis para seleção de ferramentas.",
                                  "commonMistakes": "Focar só em velocidade, ignorando flexibilidade e custo total de propriedade."
                                }
                              ],
                              "practicalExample": "Simular uma fila de caixa em supermercado: clientes chegam a taxa 1/min (exponencial), serviço leva 1.2 min em média. Compare tempo para rodar 1000 clientes e alterar para 2 caixas em cada ferramenta.",
                              "finalVerifications": [
                                "Capacidade de implementar o mesmo modelo em ambas ferramentas com resultados estatísticos equivalentes.",
                                "Tabela comparativa de tempos de execução e setup preenchida corretamente.",
                                "Relatório identifica vantagens claras: flexibilidade Python vs. facilidade visual Arena.",
                                "Recomendação contextualizada (ex: Python para pesquisa, Arena para indústria).",
                                "Códigos e modelos reproduzíveis sem erros.",
                                "Entendimento verbal de trade-offs em flexibilidade vs. velocidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão das implementações (métricas dentro de 5% de diferença).",
                                "Completude da tabela comparativa (mínimo 4 métricas: tempo exec, setup, flex, custo).",
                                "Profundidade da análise (prós/contras com evidências empíricas).",
                                "Clareza do relatório e documentação.",
                                "Criatividade em testar variações (ex: escalar modelo).",
                                "Tempo total dentro de 3 horas, demonstrando eficiência."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Uso de bibliotecas Python para simulação estocástica.",
                                "Análise de Dados: Interpretação de métricas e distribuições em simulações.",
                                "Engenharia de Software: Comparação de ferramentas de desenvolvimento.",
                                "Gestão de Projetos: Avaliação de custo-benefício em seleção de tech.",
                                "Estatística: Validação de réplicas e intervalos de confiança."
                              ],
                              "realWorldApplication": "Em logística, comparar Python/SimPy para protótipos rápidos em supply chain vs. Arena para validação em fábrica, escolhendo baseado em prazos e complexidade para otimizar throughput e reduzir gargalos."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.4.2",
                        "name": "Geração de Números e Variáveis Aleatórias",
                        "description": "Implementação de algoritmos para geração de números pseudo-aleatórios e transformação em variáveis aleatórias, essenciais para a estocasticidade em simulações discretas.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.2.1",
                            "name": "Implementar geradores de números pseudo-aleatórios",
                            "description": "Codificar métodos como Congruencial Linear e Mersenne Twister em uma linguagem escolhida, testando propriedades de independência e uniformidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender e Implementar o Gerador Congruencial Linear (LCG)",
                                  "subSteps": [
                                    "Estude a fórmula do LCG: X_{n+1} = (a * X_n + c) mod m, onde a é multiplicador, c incremento, m módulo.",
                                    "Escolha parâmetros bons: m=2^32, a=1664525, c=1013904223, semente inicial.",
                                    "Escreva uma classe ou função em Python para gerar uma sequência de N números pseudo-aleatórios.",
                                    "Implemente métodos para normalizar os números para [0,1].",
                                    "Gere uma sequência longa (ex: 10^6 números) e salve em lista."
                                  ],
                                  "verification": "Execute o código e verifique se gera números entre 0 e m-1 sem erros; imprima os primeiros 10 números.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python 3.x",
                                    "Editor de código (VS Code ou Jupyter Notebook)",
                                    "Biblioteca random (para comparação)"
                                  ],
                                  "tips": [
                                    "Use inteiros de 64 bits para evitar overflow.",
                                    "Teste com sementes diferentes para ver reprodutibilidade.",
                                    "Documente os parâmetros escolhidos no código."
                                  ],
                                  "learningObjective": "Compreender e codificar o algoritmo LCG com parâmetros otimizados.",
                                  "commonMistakes": [
                                    "Escolha de parâmetros ruins levando a períodos curtos.",
                                    "Overflow em multiplicações sem usar tipos grandes.",
                                    "Esquecer de modular corretamente."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Testar Propriedades de Independência e Uniformidade do LCG",
                                  "subSteps": [
                                    "Implemente teste de uniformidade: divida a sequência em bins e use teste qui-quadrado.",
                                    "Crie visualizações: histograma da distribuição e plot de autocorrelação para independência.",
                                    "Gere múltiplas sementes e compare estatísticas (média, variância).",
                                    "Implemente teste de poker ou runs test para independência.",
                                    "Registre p-valores dos testes estatísticos."
                                  ],
                                  "verification": "Histograma mostra distribuição uniforme; p-valor > 0.05 no qui-quadrado.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Python com NumPy, Matplotlib, SciPy (para stats.chi2)",
                                    "Jupyter Notebook para plots interativos"
                                  ],
                                  "tips": [
                                    "Use 10^5-10^6 amostras para testes confiáveis.",
                                    "Normalize para [0,1] antes de binning.",
                                    "Compare com random.uniform() como baseline."
                                  ],
                                  "learningObjective": "Avaliar empiricamente as propriedades estatísticas do LCG.",
                                  "commonMistakes": [
                                    "Bins insuficientes no histograma.",
                                    "Ignorar normalização levando a viés.",
                                    "Confundir independência com uniformidade."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o Gerador Mersenne Twister (MT19937)",
                                  "subSteps": [
                                    "Estude a estrutura: estado de 624 inteiros de 32 bits, twist e tempering.",
                                    "Implemente inicialização com semente e função de twist.",
                                    "Codifique funções de tempering: right shift, left shift e máscaras.",
                                    "Crie classe MT com métodos next() e seed().",
                                    "Gere sequência longa similar ao LCG."
                                  ],
                                  "verification": "Gere 1000 números e compare com saída conhecida de bibliotecas padrão (ex: Python's random).",
                                  "estimatedTime": "3-4 horas",
                                  "materials": [
                                    "Python 3.x",
                                    "Referência oficial MT19937 (Wikipedia ou código fonte)",
                                    "Testes unitários com pytest"
                                  ],
                                  "tips": [
                                    "Copie constantes exatas: w=32, n=624, etc.",
                                    "Implemente debug prints para twist cycle.",
                                    "Use bit operations eficientes (<<, >>, ^)."
                                  ],
                                  "learningObjective": "Codificar um PRNG complexo com período 2^19937-1.",
                                  "commonMistakes": [
                                    "Erros em máscaras de tempering.",
                                    "Twist incorreto levando a padrões repetitivos.",
                                    "Semente mal inicializada."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Comparar LCG e Mersenne Twister",
                                  "subSteps": [
                                    "Aplique os mesmos testes (uniformidade, independência) ao MT.",
                                    "Compare métricas: período efetivo, tempo de execução, p-valores.",
                                    "Visualize lado a lado: histogramas e autocorrelações.",
                                    "Discuta limitações: LCG curto período vs MT longo mas não cripto-seguro.",
                                    "Integre em uma simulação simples (ex: Monte Carlo pi)."
                                  ],
                                  "verification": "MT passa todos os testes com melhores métricas que LCG; simulação converge corretamente.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "NumPy, Matplotlib, SciPy",
                                    "Código dos steps anteriores"
                                  ],
                                  "tips": [
                                    "Meça tempo com timeit para performance.",
                                    "Use seed comum para comparações justas.",
                                    "Salve resultados em CSV para análise."
                                  ],
                                  "learningObjective": "Comparar PRNGs e validar para uso em simulações.",
                                  "commonMistakes": [
                                    "Comparar sem normalizar faixas.",
                                    "Ignorar overhead computacional do MT.",
                                    "Concluir superioridade sem métricas quantitativas."
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente o LCG para gerar números pseudo-aleatórios em uma simulação de Monte Carlo para estimar o valor de π: lance 'dardos' em um quadrado circunscrito, contando acertos dentro do círculo.",
                              "finalVerifications": [
                                "Códigos LCG e MT geram sequências sem erros e reprodutíveis.",
                                "Testes estatísticos mostram uniformidade (p>0.01) e independência.",
                                "Visualizações confirmam ausência de padrões ou viés.",
                                "Simulação Monte Carlo converge para π ≈ 3.1416 com erro <1%.",
                                "Documentação inclui parâmetros, resultados e análise.",
                                "Código é modular e bem comentado."
                              ],
                              "assessmentCriteria": [
                                "Correção da implementação LCG e MT (30%)",
                                "Qualidade e completude dos testes estatísticos (25%)",
                                "Análise comparativa e visualizações claras (20%)",
                                "Eficiência e reprodutibilidade do código (15%)",
                                "Documentação e compreensão demonstrada (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: Testes qui-quadrado e runs.",
                                "Programação: Estruturas de classes, bit manipulation.",
                                "Simulações Numéricas: Aplicação em Monte Carlo.",
                                "Criptografia: Limitações de PRNGs em segurança."
                              ],
                              "realWorldApplication": "Usado em simulações financeiras (Value at Risk), jogos (procedurais como Minecraft), modelagem climática e testes de software para cenários aleatórios."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.2.2",
                            "name": "Aplicar métodos de transformação de variáveis aleatórias",
                            "description": "Implementar técnicas como método da inversa cumulativa e método de aceitação-rejeição para gerar distribuições exponencial, normal e Poisson em código.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar fundamentos teóricos dos métodos de transformação",
                                  "subSteps": [
                                    "Estude a função de distribuição cumulativa (CDF) e sua inversa para distribuições contínuas.",
                                    "Revise o método da inversa cumulativa: gerar U ~ Uniform(0,1) e aplicar F^{-1}(U).",
                                    "Analise o método de aceitação-rejeição: usar envelope g(x) >= f(x) e aceitar com probabilidade f(x)/(M g(x)).",
                                    "Identifique fórmulas específicas para exponencial (λ), normal (Box-Muller ou rejeição) e Poisson (discreta via rejeição).",
                                    "Derive manualmente exemplos simples para exponencial e Poisson."
                                  ],
                                  "verification": "Resuma em um documento os passos matemáticos para cada método e distribuições, confirmando com fórmulas corretas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de probabilidade/simulação (ex: Ross), notas de aula, calculadora simbólica (SymPy).",
                                  "tips": "Desenhe gráficos da CDF e PDF para visualizar transformações.",
                                  "learningObjective": "Compreender a base matemática para implementação correta dos métodos.",
                                  "commonMistakes": "Confundir PDF com CDF; ignorar normalização no aceitação-rejeição."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar método da inversa cumulativa para distribuição exponencial",
                                  "subSteps": [
                                    "Gere números uniformes U com np.random.uniform(0,1,N).",
                                    "Calcule X = -log(U)/λ para exponencial.",
                                    "Escreva função em Python: def inverse_exponential(U, lambda_param): return -np.log(U)/lambda_param.",
                                    "Gere 10000 amostras e compute estatísticas (média, variância).",
                                    "Plote histograma e compare com PDF teórica."
                                  ],
                                  "verification": "Média das amostras ≈ 1/λ e variância ≈ 1/λ² (erro <5%).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python, NumPy, Matplotlib, Jupyter Notebook.",
                                  "tips": "Use seed para reprodutibilidade: np.random.seed(42).",
                                  "learningObjective": "Implementar e validar geração de exponencial via inversa.",
                                  "commonMistakes": "Usar log(1-U) em vez de log(U); esquecer importações."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estender inversa cumulativa para normal e adaptar para Poisson",
                                  "subSteps": [
                                    "Para normal: implemente aproximação via inversa (scipy.stats.norm.ppf) ou Box-Muller básico.",
                                    "Para Poisson (discreta): use inversa da CDF discreta via busca cumulativa.",
                                    "Escreva funções: inverse_normal(U), poisson_inverse(U, mu).",
                                    "Gere amostras e compare KS-test com distribuições teóricas.",
                                    "Integre em um módulo unificado de geradores."
                                  ],
                                  "verification": "Teste KS (Kolmogorov-Smirnov) p-value >0.05 contra scipy.stats.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Python, SciPy (para ppf e kstest), Matplotlib.",
                                  "tips": "Para Poisson, use loop eficiente para CDF cumulativa.",
                                  "learningObjective": "Adaptar método para distribuições não-invertíveis analiticamente.",
                                  "commonMistakes": "Overflow em log para U próximo de 0; CDF discreta mal implementada."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar método de aceitação-rejeição para normal e Poisson",
                                  "subSteps": [
                                    "Escolha envelope para normal: exponencial com M=√(2π) ou Cauchy.",
                                    "Para Poisson: use envelope exponencial discreta.",
                                    "Implemente loop: gere Y de g, U uniforme, aceite se U <= f(Y)/(M g(Y)).",
                                    "Meça taxa de aceitação (>20% ideal) e gere 10000 amostras.",
                                    "Valide com QQ-plot e momentos."
                                  ],
                                  "verification": "Taxa de aceitação reportada e histograma visualmente similar à teórica.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Python, NumPy, SciPy.stats para referência.",
                                  "tips": "Otimize M minimamente para eficiência.",
                                  "learningObjective": "Dominar rejeição para distribuições sem inversa fechada.",
                                  "commonMistakes": "Envelope inadequado (M muito alto); loop infinito por U=0."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar, validar e otimizar implementações",
                                  "subSteps": [
                                    "Execute testes unitários para cada função (média, var, KS-test).",
                                    "Compare performance (tempo) vs. scipy.random.",
                                    "Gere simulação mista: Monte Carlo para integral com essas vars.",
                                    "Documente código com docstrings e exemplos.",
                                    "Otimize vetorializando com NumPy."
                                  ],
                                  "verification": "Todos testes passam; tempo <10x scipy.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Pytest ou unittest, timeit para benchmark.",
                                  "tips": "Use assert para automação de testes.",
                                  "learningObjective": "Garantir robustez e eficiência das implementações.",
                                  "commonMistakes": "Ignorar bordas (U=0/1); testes insuficientes."
                                }
                              ],
                              "practicalExample": "Implemente um simulador de fila M/M/1 usando variáveis exponenciais geradas pelo método da inversa para tempos de chegada/serviços, rode 1000 réplicas e estime tempo médio no sistema, comparando com fórmula teórica ρ/(μ(1-ρ)).",
                              "finalVerifications": [
                                "Código gera amostras sem erros para todas distribuições.",
                                "Estatísticas amostrais (média/var) coincidem com teóricas (erro<2%).",
                                "KS-test ou QQ-plot confirma aderência à distribuição alvo.",
                                "Taxa de aceitação no método de rejeição >15%.",
                                "Benchmark mostra eficiência razoável vs. bibliotecas padrão.",
                                "Documentação inclui fórmulas e exemplos de uso."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática das fórmulas implementadas (100%).",
                                "Eficiência computacional e vetorização (80%+ performance).",
                                "Qualidade de validação estatística (testes + plots).",
                                "Clareza e modularidade do código (funções reutilizáveis).",
                                "Tratamento de edge cases e reprodutibilidade.",
                                "Documentação completa com explicações teóricas."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: validação via testes de hipóteses.",
                                "Programação: vetorização NumPy, testes unitários.",
                                "Simulação e Modelagem: aplicações em Monte Carlo.",
                                "Cálculo Numérico: aproximações de inversas e integrais.",
                                "Ciência de Dados: geração de dados sintéticos para ML."
                              ],
                              "realWorldApplication": "Em finanças, gerar retornos Poisson para contagens de trades; em telecom, simular delays exponenciais/normais para QoS; em epidemiologia, modelar tempos de infecção via exponencial para simulações SIR."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.2.3",
                            "name": "Testar qualidade de geradores aleatórios",
                            "description": "Executar testes estatísticos como teste de qui-quadrado e Kolmogorov-Smirnov no código implementado para validar a aleatoriedade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Gerar amostra de números aleatórios",
                                  "subSteps": [
                                    "Implemente ou utilize o gerador aleatório previamente codificado (ex: LCG ou Mersenne Twister).",
                                    "Gere uma amostra grande (mínimo 10.000 números) no intervalo [0,1).",
                                    "Salve os dados em um array ou arquivo para análise.",
                                    "Visualize os dados com histograma para inspeção inicial.",
                                    "Normalize os dados se necessário para a distribuição uniforme."
                                  ],
                                  "verification": "Amostra gerada com tamanho correto e histograma visualmente uniforme.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python",
                                    "NumPy",
                                    "Matplotlib"
                                  ],
                                  "tips": "Use sementes fixas para reprodutibilidade nos testes.",
                                  "learningObjective": "Preparar dados adequados para testes estatísticos de aleatoriedade.",
                                  "commonMistakes": [
                                    "Amostra muito pequena (menos de 5.000)",
                                    "Não normalizar para [0,1)",
                                    "Ignorar visualização inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar teste Qui-quadrado",
                                  "subSteps": [
                                    "Divida o intervalo [0,1) em k bins iguais (ex: k=10 ou 20).",
                                    "Calcule frequências observadas (Oi) em cada bin.",
                                    "Calcule frequências esperadas (Ei = n/k, onde n=tamanho da amostra).",
                                    "Compute estatística χ² = Σ (Oi - Ei)² / Ei.",
                                    "Calcule p-valor usando distribuição qui-quadrado com k-1 graus de liberdade."
                                  ],
                                  "verification": "Estatística χ² calculada e p-valor obtido; p-valor > 0.05 indica boa uniformidade.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python",
                                    "SciPy (stats.chi2)",
                                    "NumPy"
                                  ],
                                  "tips": "Escolha k apropriado: muito pequeno perde resolução, muito grande requer amostra maior.",
                                  "learningObjective": "Aplicar teste de bondade de ajuste Qui-quadrado para uniformidade.",
                                  "commonMistakes": [
                                    "Ei < 5 em algum bin",
                                    "Graus de liberdade errados (deve ser k-1)",
                                    "Não rejeitar H0 incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar teste Kolmogorov-Smirnov",
                                  "subSteps": [
                                    "Ordene a amostra em ordem crescente.",
                                    "Calcule a função empírica cumulativa (F_n(x)).",
                                    "Compare com CDF teórica uniforme F(x)=x.",
                                    "Compute estatística KS = sup |F_n(x) - F(x)|.",
                                    "Obtenha p-valor usando tabelas ou função SciPy (kstest)."
                                  ],
                                  "verification": "Estatística KS baixa (<0.1 tipicamente) e p-valor > 0.05.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python",
                                    "SciPy (stats.kstest)",
                                    "NumPy"
                                  ],
                                  "tips": "O teste KS é sensível a desvios nas caudas; combine com Qui-quadrado.",
                                  "learningObjective": "Executar teste KS para validar distribuição contínua uniforme.",
                                  "commonMistakes": [
                                    "Não ordenar a amostra",
                                    "Usar wrong CDF (não uniforme)",
                                    "Ignorar correção de continuidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados e validar gerador",
                                  "subSteps": [
                                    "Compare p-valores dos dois testes (ambos >0.05 para aprovação).",
                                    "Gere Q-Q plot e histograma ajustado para validação visual.",
                                    "Repita testes com múltiplas sementes ou amostras.",
                                    "Registre relatório com estatísticas, p-valores e conclusões.",
                                    "Discuta limitações e sugestões de melhoria no gerador."
                                  ],
                                  "verification": "Relatório completo com interpretação coerente e recomendação sobre qualidade.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python",
                                    "Matplotlib",
                                    "SciPy"
                                  ],
                                  "tips": "Se falhar, investigue período do gerador ou parâmetros.",
                                  "learningObjective": "Integrar testes estatísticos para avaliação holística de RNGs.",
                                  "commonMistakes": [
                                    "Aceitar p-valor isolado sem repetições",
                                    "Ignorar plots visuais",
                                    "Concluir sem discutir limitações"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente um gerador LCG com parâmetros a=1664525, c=1013904223, m=2^32. Gere 50.000 números, aplique Qui-quadrado (10 bins) e KS; verifique se p-valores >0.05 e plote histograma/Q-Q para confirmar uniformidade em simulação de Monte Carlo.",
                              "finalVerifications": [
                                "p-valor Qui-quadrado > 0.05",
                                "p-valor KS > 0.05",
                                "Histograma e Q-Q plot mostram adequação à uniforme",
                                "Testes repetidos com sementes diferentes consistentes",
                                "Relatório documenta código, resultados e interpretação",
                                "Estatísticas KS < 0.01 para amostras grandes"
                              ],
                              "assessmentCriteria": [
                                "Implementação correta e eficiente dos testes estatísticos",
                                "Uso apropriado de bibliotecas sem 'colar' soluções",
                                "Interpretação precisa de p-valores e rejeição/aceitação de H0",
                                "Visualizações claras e informativas",
                                "Relatório estruturado com conclusões fundamentadas",
                                "Identificação de erros comuns e limitações"
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Testes de hipóteses e distribuições",
                                "Programação: Implementação numérica e visualização de dados",
                                "Física: Simulações estocásticas em mecânica quântica",
                                "Criptografia: Avaliação de PRNGs para segurança",
                                "Finanças: Modelagem de risco com Monte Carlo"
                              ],
                              "realWorldApplication": "Validação de geradores pseudo-aleatórios em simulações Monte Carlo para previsão financeira, testes de software em jogos de azar, criptografia para chaves seguras e modelagem climática onde aleatoriedade garante robustez dos resultados."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.4.3",
                        "name": "Codificação do Modelo Conceitual",
                        "description": "Tradução do modelo conceitual validado em código executável, definindo entidades, eventos, filas e lógica de simulação para sistemas de eventos discretos.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.3.1",
                            "name": "Definir estruturas de dados para o modelo",
                            "description": "Estruturar classes ou objetos para entidades (ex.: clientes, servidores), eventos e filas em linguagens orientadas a objetos ou procedural.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar o modelo conceitual e identificar componentes principais",
                                  "subSteps": [
                                    "Revise o diagrama ou descrição do modelo conceitual para listar entidades (ex.: clientes, servidores), eventos (ex.: chegada, atendimento) e filas.",
                                    "Classifique cada componente por atributos estáticos (ID, estado) e dinâmicos (tempo de chegada, prioridade).",
                                    "Mapeie relacionamentos entre componentes, como filas associadas a servidores.",
                                    "Crie um glossário simples com definições claras para cada entidade, evento e fila.",
                                    "Valide a lista com stakeholders ou documentação para garantir completude."
                                  ],
                                  "verification": "Verifique se há uma lista completa e um diagrama de mapeamento sem ambiguidades.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Diagrama conceitual, papel/notas, editor de texto (ex.: Notion ou Markdown).",
                                  "tips": "Use diagramas UML ou fluxogramas para visualizar relacionamentos antes de codificar.",
                                  "learningObjective": "Identificar e catalogar todos os elementos de dados necessários para o modelo de simulação.",
                                  "commonMistakes": "Ignorar filas ou eventos secundários; superestimar atributos desnecessários."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar estruturas para entidades principais",
                                  "subSteps": [
                                    "Defina classes ou structs para entidades como Cliente (atributos: ID, tempoChegada, prioridade) e Servidor (atributos: ID, statusOcioso, tempoServico).",
                                    "Adicione métodos relevantes, como calcularTempoEspera() para Cliente ou atualizarStatus() para Servidor.",
                                    "Considere herança ou composição se houver subtipos (ex.: ClienteVIP herda de Cliente).",
                                    "Especifique tipos de dados precisos (int para ID, float para tempos, enum para status).",
                                    "Documente cada atributo com comentários sobre propósito e restrições."
                                  ],
                                  "verification": "Compile ou valide sintaxe das estruturas definidas em um protótipo simples.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "IDE (Python: PyCharm; C++: Visual Studio), referência de linguagem OO/procedural.",
                                  "tips": "Priorize encapsulamento: torne atributos privados e use getters/setters.",
                                  "learningObjective": "Criar estruturas robustas que capturem o estado e comportamento das entidades.",
                                  "commonMistakes": "Usar tipos genéricos como 'string' para tudo; esquecer validações de entrada."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir estruturas para eventos e filas",
                                  "subSteps": [
                                    "Crie uma classe Evento com atributos (tipo, tempo, entidadeEnvolvida) e métodos como processar().",
                                    "Implemente Fila como queue (FIFO) com enqueue(), dequeue(), size() e métodos de prioridade se aplicável.",
                                    "Integre referências: eventos apontam para entidades, filas contêm entidades.",
                                    "Adicione suporte a logging ou timestamps para rastreabilidade em simulações.",
                                    "Teste operações básicas em um script isolado (ex.: enfileirar 5 clientes e desenfileirar)."
                                  ],
                                  "verification": "Execute testes unitários para operações de fila e eventos sem erros.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Bibliotecas padrão (Python: collections.deque; C++: std::queue), framework de testes (unittest/pytest).",
                                  "tips": "Use queues prontas da linguagem para eficiência, customizando apenas o necessário.",
                                  "learningObjective": "Modelar fluxos dinâmicos com eventos e filas que suportem simulações temporais.",
                                  "commonMistakes": "Não tratar casos de fila vazia ou cheia; ignorar ordenação temporal de eventos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e refinar as estruturas de dados",
                                  "subSteps": [
                                    "Integre as estruturas em um esboço do simulador principal e rode uma simulação curta.",
                                    "Meça desempenho (memória, tempo de execução) e ajuste tamanhos ou tipos.",
                                    "Revise por aderência ao modelo conceitual, adicionando campos faltantes.",
                                    "Colete feedback de pares ou execute análise estática de código.",
                                    "Documente a API final das estruturas para uso posterior."
                                  ],
                                  "verification": "Simulação roda sem crashes e produz resultados esperados para cenários teste.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Simulador protótipo, profiler de performance (ex.: Python cProfile).",
                                  "tips": "Comece com dados pequenos para testes rápidos antes de escalar.",
                                  "learningObjective": "Garantir que as estruturas sejam eficientes, corretas e extensíveis.",
                                  "commonMistakes": "Sobre-otimizar prematuramente; pular testes de borda como filas vazias."
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de banco: Crie classe Cliente (id, chegada=10.5, servico=3.2), Servidor (id, ocioso=True), Evento (tipo='chegada', tempo=10.5, cliente=Cliente(1)), e Fila (lista de Clientes com enqueue/dequeue por tempo).",
                              "finalVerifications": [
                                "Todas entidades, eventos e filas têm atributos e métodos documentados.",
                                "Estruturas compilam e integram sem erros em protótipo de simulação.",
                                "Testes unitários cobrem 80%+ das operações (enqueue, dequeue, processar evento).",
                                "Desempenho suporta 1000+ entidades sem lentidão excessiva.",
                                "Documentação inclui exemplos de uso e diagrama de classes.",
                                "Nenhuma violação de encapsulamento ou vazamento de memória detectado."
                              ],
                              "assessmentCriteria": [
                                "Completude: Todos componentes do modelo conceitual mapeados (90%+ cobertura).",
                                "Precisão: Tipos de dados e métodos alinhados com requisitos (sem ambiguidades).",
                                "Eficiência: Operações O(1) para filas onde possível; baixo uso de memória.",
                                "Robustez: Tratamento de erros e casos edge implementado.",
                                "Documentação: Clara, com comentários e UML opcional.",
                                "Extensibilidade: Fácil adicionar novas entidades sem refatoração massiva."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Filas (M/M/1), distribuições probabilísticas para tempos.",
                                "Ciência da Computação: Estruturas de Dados (Queues, Linked Lists), Algoritmos de Simulação.",
                                "Engenharia de Software: Design Patterns (Observer para eventos), UML Modeling.",
                                "Probabilidade e Estatística: Geração de eventos aleatórios baseados em distribuições."
                              ],
                              "realWorldApplication": "Em simulações de call centers (filas de chamadas), logística (filas de caminhões em portos) ou redes (pacotes em roteadores), definindo estruturas para otimizar tempos de espera e alocação de recursos, reduzindo custos operacionais em empresas como Amazon ou telecoms."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.3.2",
                            "name": "Implementar lógica de eventos discretos",
                            "description": "Codificar o escalonador de eventos, processamento de chegadas e saídas, utilizando listas de eventos futuros e condições de parada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir estruturas de dados para eventos e Lista de Eventos Futuros (FEL)",
                                  "subSteps": [
                                    "Crie uma classe ou estrutura para representar um Evento, incluindo atributos como tempo (time), tipo (chegada/saída), entidade associada (ex: cliente ID) e parâmetros adicionais (ex: tempo de serviço).",
                                    "Implemente a FEL como uma fila de prioridade (priority queue) ordenada pelo tempo do evento, utilizando bibliotecas como heapq em Python ou PriorityQueue em Java.",
                                    "Inicialize a FEL com eventos de chegada iniciais, gerando tempos de chegada aleatórios baseados em uma distribuição (ex: exponencial).",
                                    "Defina o relógio de simulação (clock) inicializado em zero.",
                                    "Adicione métodos para inserir e remover eventos da FEL."
                                  ],
                                  "verification": "Verifique se a FEL retorna o evento com menor tempo quando consultada e se novos eventos são inseridos corretamente sem duplicatas.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Linguagem de programação (Python recomendado)",
                                    "Editor de código (VS Code ou PyCharm)",
                                    "Biblioteca heapq (Python)"
                                  ],
                                  "tips": "Sempre ordene a FEL pelo tempo de ocorrência; use timestamps únicos para evitar empates.",
                                  "learningObjective": "Compreender e implementar estruturas de dados eficientes para gerenciar eventos em simulações discretas.",
                                  "commonMistakes": [
                                    "Usar lista simples sem ordenação, causando ineficiência O(n)",
                                    "Esquecer de incluir tipo de evento, impedindo processamento condicional",
                                    "Inicializar clock incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o escalonador de eventos",
                                  "subSteps": [
                                    "Crie uma função para avançar o relógio de simulação (advance_clock) que atualiza o clock para o tempo do próximo evento na FEL.",
                                    "Implemente a lógica de extração do próximo evento: remova o evento de menor tempo da FEL e defina como evento corrente.",
                                    "Atualize estatísticas globais (ex: número de eventos processados) ao escalonar.",
                                    "Trate casos de FEL vazia como sinal para parar a simulação.",
                                    "Teste unitariamente o escalonador com eventos mockados."
                                  ],
                                  "verification": "Execute um teste com 3 eventos ordenados por tempo e confirme que o clock avança corretamente e eventos são extraídos na sequência esperada.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Mesmos do Step 1",
                                    "Ferramentas de teste unitário (unittest em Python)"
                                  ],
                                  "tips": "Mantenha o clock sempre <= tempo do próximo evento para evitar saltos temporais incorretos.",
                                  "learningObjective": "Dominar o mecanismo de escalonamento temporal em simulações de eventos discretos.",
                                  "commonMistakes": [
                                    "Avançar clock além do próximo evento",
                                    "Não remover evento da FEL após extração",
                                    "Ignorar eventos com mesmo tempo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Codificar processamento de eventos de chegada e saída",
                                  "subSteps": [
                                    "Para evento de chegada: incremente contadores de chegadas, se servidor livre agende saída e ocupe servidor; senão enfileire entidade.",
                                    "Para evento de saída: libere servidor, atualize estatísticas de saída/tempo no sistema, se fila não vazia desinfileire e agende nova saída.",
                                    "Gere tempos de serviço e interchegadasas aleatoriamente (ex: distribuição exponencial).",
                                    "Insira novos eventos futuros na FEL durante o processamento (ex: próxima chegada ou saída).",
                                    "Registre logs ou estatísticas parciais para depuração."
                                  ],
                                  "verification": "Simule 10 chegadas e saídas manualmente e verifique se contadores de fila, servidor e tempos médios estão corretos.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Biblioteca random ou numpy para geração aleatória",
                                    "Planilha para validar estatísticas manuais"
                                  ],
                                  "tips": "Use condicionais if/else claras baseadas no tipo de evento para evitar lógica duplicada.",
                                  "learningObjective": "Implementar dinâmicas de sistemas de filas com lógica condicional precisa.",
                                  "commonMistakes": [
                                    "Agendar saída sem verificar servidor livre",
                                    "Não atualizar tempos de espera na fila",
                                    "Gerar aleatoriedade sem semente para reprodutibilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Configurar loop principal de simulação e condições de parada",
                                  "subSteps": [
                                    "Estruture o loop while: enquanto FEL não vazia e condições de parada não atendidas, escalone e processe próximo evento.",
                                    "Defina condições de parada: número máximo de eventos, tempo de simulação máximo ou estado quiescente (fila e servidor vazios).",
                                    "Implemente coleta final de estatísticas (ex: tempo médio na fila, utilização do servidor).",
                                    "Adicione função de relatório final com impressões ou salvamento em arquivo.",
                                    "Teste a simulação completa com um cenário pequeno."
                                  ],
                                  "verification": "Execute a simulação até uma condição de parada e confirme que estatísticas finais são coerentes com eventos processados.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Mesmos anteriores",
                                    "Gráficos com matplotlib para visualizar resultados"
                                  ],
                                  "tips": "Priorize condições de parada robustas para evitar loops infinitos.",
                                  "learningObjective": "Construir um ciclo de simulação completo e autônomo com terminais claros.",
                                  "commonMistakes": [
                                    "Loop infinito por FEL não esvaziando",
                                    "Condições de parada muito restritivas",
                                    "Não coletar estatísticas durante processamento"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente uma simulação M/M/1 de fila de banco: clientes chegam a cada 5-10 min (exp. λ=0.2), serviço 8 min (μ=0.125). Rode por 100 chegadas, calcule tempo médio na fila e utilização do caixa.",
                              "finalVerifications": [
                                "FEL esvazia corretamente ao atingir condição de parada.",
                                "Clock final coincide com último evento processado.",
                                "Estatísticas de chegadas/saídas equilibram-se (diferença <=1).",
                                "Nenhum erro de índice ou divisão por zero durante execução.",
                                "Relatório final exibe métricas coerentes (ex: utilização entre 0-1).",
                                "Teste com semente fixa reproduz mesmos resultados."
                              ],
                              "assessmentCriteria": [
                                "Correção na ordenação e extração de eventos da FEL (100% de precisão em testes).",
                                "Eficiência: tempo de execução O(log n) por inserção/extracao.",
                                "Robustez: lida com cenários edge (FEL vazia, múltiplos eventos simultâneos).",
                                "Clareza do código: comentários, nomes variáveis descritivos.",
                                "Precisão estatística: métricas dentro de 10% de valores teóricos.",
                                "Modularidade: funções separadas para escalonador e processadores."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Estruturas de dados (filas de prioridade, classes).",
                                "Probabilidade e Estatística: Distribuições exponenciais, geração aleatória.",
                                "Algoritmos: Heaps e ordenação temporal.",
                                "Engenharia de Software: Testes unitários e depuração.",
                                "Teoria das Filas: Modelos M/M/1 e métricas de performance."
                              ],
                              "realWorldApplication": "Simulações de redes de telecomunicações para otimizar roteamento de pacotes, modelando chegadas e processamentos discretos; ou logística em supermercados para dimensionar caixas registradoras."
                            },
                            "estimatedTime": "5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.3.3",
                            "name": "Integrar coleta de estatísticas básicas",
                            "description": "Adicionar código para rastrear métricas como tempo médio no sistema, comprimento de fila e utilização de recursos durante a simulação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e definir as métricas estatísticas a serem coletadas",
                                  "subSteps": [
                                    "Analise o modelo conceitual da simulação para identificar eventos relevantes (chegadas, saídas, inícios e fins de serviço).",
                                    "Liste as métricas principais: tempo médio no sistema, comprimento médio da fila e utilização de recursos (ex.: % de tempo ocioso do servidor).",
                                    "Defina fórmulas matemáticas para cada métrica, como soma de tempos dividida pelo número de entidades para médias.",
                                    "Documente as métricas em comentários no código para clareza.",
                                    "Verifique se as métricas atendem aos objetivos da simulação."
                                  ],
                                  "verification": "Lista de métricas e fórmulas documentadas no código ou em um arquivo separado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Código base da simulação, papel e caneta ou editor de texto para anotações.",
                                  "tips": "Comece pelas métricas mais simples, como contadores de chegadas e saídas, antes de médias.",
                                  "learningObjective": "Compreender quais estatísticas são essenciais em simulações discretas e suas fórmulas.",
                                  "commonMistakes": "Esquecer métricas de ociosidade ou confundir tempo no sistema com tempo na fila."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar variáveis e estruturas de dados para coleta",
                                  "subSteps": [
                                    "Declare variáveis globais ou em uma classe de estatísticas: contadores (numChegadas, numSaidas), acumuladores (somaTempoSistema, somaTempoFila) e somaTempoOcioso.",
                                    "Inicialize todas as variáveis para zero no início da simulação.",
                                    "Crie uma estrutura ou objeto para agrupar as estatísticas (ex.: struct Estatisticas em C++ ou classe em Python).",
                                    "Adicione variáveis para tempo total de simulação e relógio atual.",
                                    "Teste a inicialização executando uma simulação curta sem coleta."
                                  ],
                                  "verification": "Variáveis inicializadas corretamente e visíveis via depurador ou print inicial.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de código (VS Code, PyCharm), depurador integrado.",
                                  "tips": "Use nomes de variáveis descritivos como 'acumTempoFila' para facilitar manutenção.",
                                  "learningObjective": "Implementar estruturas eficientes para armazenamento de dados estatísticos em simulações.",
                                  "commonMistakes": "Não inicializar variáveis, levando a resultados indefinidos; usar tipos inadequados (int para somas grandes)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar código de coleta de dados nos eventos da simulação",
                                  "subSteps": [
                                    "No evento de chegada: incremente contador de chegadas, registre tempo de chegada e adicione à soma do comprimento da fila.",
                                    "No evento de saída: registre tempo de saída, calcule e adicione tempo no sistema e na fila aos acumuladores.",
                                    "No início/fim de serviço: registre tempos para calcular utilização e ociosidade do servidor.",
                                    "Atualize comprimento da fila em cada evento relevante (fila++ ou fila--).",
                                    "Use o relógio da simulação para todos os cálculos de tempo."
                                  ],
                                  "verification": "Durante uma simulação de teste, prints mostram contadores incrementando corretamente em eventos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Código da simulação com eventos implementados, simulador de testes unitários.",
                                  "tips": "Insira prints temporários nos eventos para depurar a coleta em tempo real.",
                                  "learningObjective": "Capturar dados estatísticos de forma precisa e sincronizada com o ciclo de eventos.",
                                  "commonMistakes": "Atualizar estatísticas no momento errado (ex.: tempo na fila antes da chegada); esquecer de tratar filas vazias."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular estatísticas finais e implementar relatório",
                                  "subSteps": [
                                    "Ao final da simulação, calcule médias: tempoMedioSistema = somaTempoSistema / numSaidas.",
                                    "Calcule utilização: utilizacao = (tempoTotalServico / tempoSimulacao) * 100.",
                                    "Gere um relatório formatado com todas as métricas (console, arquivo ou gráfico simples).",
                                    "Adicione tratamento de divisões por zero (ex.: if numSaidas > 0).",
                                    "Teste com múltiplas rodadas para validar consistência."
                                  ],
                                  "verification": "Relatório exibido com valores coerentes (ex.: utilização entre 0-100%) após simulação completa.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Código completo, ferramenta de plotagem opcional (Matplotlib para Python).",
                                  "tips": "Arredonde resultados para 2 casas decimais para legibilidade.",
                                  "learningObjective": "Computar e apresentar estatísticas agregadas de simulações de forma profissional.",
                                  "commonMistakes": "Divisão por zero em médias; não considerar tempo total para utilização."
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila M/M/1 (chegadas Poisson λ=2, serviço exponencial μ=3), colete: após 1000 chegadas, tempo médio no sistema ≈ 1/ (μ - λ) = 1. Relatório final: 'Tempo médio sistema: 1.00 min, Comprimento médio fila: 2.00, Utilização servidor: 66.67%'. Código Python: acum_tempo_sistema += relogio_saida - relogio_chegada.",
                              "finalVerifications": [
                                "Código compila/executa sem erros em simulações completas.",
                                "Contadores batem com número de eventos processados.",
                                "Métricas calculadas coincidem com fórmulas teóricas em casos simples.",
                                "Relatório é exibido corretamente no console ou arquivo.",
                                "Não há vazamentos de memória ou loops infinitos.",
                                "Resultados são consistentes em múltiplas execuções."
                              ],
                              "assessmentCriteria": [
                                "Precisão das fórmulas de cálculo das métricas (100% correto).",
                                "Cobertura completa das métricas especificadas (tempo sistema, fila, utilização).",
                                "Eficiência: O(1) por evento, sem impacto significativo no desempenho.",
                                "Clareza do código: comentários e nomes variáveis intuitivos.",
                                "Robustez: tratamento de casos edge (fila vazia, zero saídas).",
                                "Qualidade do relatório: formatado e legível."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Estruturas de dados e controle de fluxo.",
                                "Estatística: Cálculo de médias, somas e percentuais.",
                                "Gestão de Operações: Métricas de desempenho em filas e serviços.",
                                "Análise de Dados: Coleta e agregação durante execução."
                              ],
                              "realWorldApplication": "Em centros de call center para otimizar número de atendentes (utilização <80%), em linhas de produção para reduzir gargalos (comprimento fila baixo), ou em redes de TI para monitorar latência e uso de servidores durante picos de tráfego."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.3.4",
                            "name": "Realizar testes unitários iniciais",
                            "description": "Executar simulações determinísticas (sem aleatoriedade) para verificar se o código reproduz corretamente o modelo conceitual simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar componentes chave do modelo conceitual para testes unitários",
                                  "subSteps": [
                                    "Revise o modelo conceitual simples documentado, focando em estados iniciais, transições determinísticas e saídas esperadas.",
                                    "Liste 3-5 funções ou métodos principais que implementam o núcleo do modelo (ex: inicialização, atualização de estado, cálculo de saída).",
                                    "Defina entradas determinísticas simples (sem aleatoriedade) baseadas no modelo, como valores iniciais fixos.",
                                    "Especifique saídas esperadas manualmente calculadas para cada entrada.",
                                    "Priorize testes para edge cases, como estado zero ou valores mínimos/máximos."
                                  ],
                                  "verification": "Lista de componentes, entradas e saídas esperadas documentada em um arquivo ou comentário no código.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação do modelo conceitual, editor de texto ou IDE (ex: VS Code, Jupyter Notebook).",
                                  "tips": "Use diagramas do modelo conceitual como referência visual para mapear componentes.",
                                  "learningObjective": "Mapear precisamente o modelo conceitual para casos de teste acionáveis.",
                                  "commonMistakes": "Ignorar edge cases ou assumir aleatoriedade em simulações que devem ser determinísticas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e documentar casos de teste determinísticos",
                                  "subSteps": [
                                    "Crie uma tabela ou lista com pelo menos 5 casos de teste: entrada, estado esperado, saída esperada e razão do teste.",
                                    "Garanta que todos os casos sejam determinísticos (seeds fixos ou sem random).",
                                    "Inclua testes para condições normais, boundary e inválidas (se aplicável ao modelo).",
                                    "Calcule manualmente as saídas esperadas usando o modelo conceitual em papel ou calculadora.",
                                    "Salve os casos em um formato legível, como Markdown ou JSON para fácil referência."
                                  ],
                                  "verification": "Tabela de casos de teste completa com pelo menos 5 entradas, disponível e revisada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Planilha (Google Sheets/Excel) ou Markdown editor, calculadora.",
                                  "tips": "Comece com casos simples para construir confiança antes de complexos.",
                                  "learningObjective": "Criar casos de teste abrangentes e verificáveis que reflitam o modelo conceitual.",
                                  "commonMistakes": "Definir saídas esperadas incorretas devido a cálculos manuais errados."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e executar testes unitários no código",
                                  "subSteps": [
                                    "Instale um framework de testes (ex: pytest para Python) se não estiver configurado.",
                                    "Escreva funções de teste para cada caso, usando asserts para comparar saída real vs esperada.",
                                    "Execute os testes em modo determinístico (sem paralelismo aleatório).",
                                    "Registre saídas dos testes em logs ou relatórios.",
                                    "Integre testes ao código principal via script de execução."
                                  ],
                                  "verification": "Todos os testes executados com 100% de pass rate inicial ou falhas identificadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "IDE com suporte a testes (PyCharm/VS Code), framework pytest/unittest, código fonte do modelo.",
                                  "tips": "Use nomes descritivos para testes como 'test_inicializacao_estado_zero' para clareza.",
                                  "learningObjective": "Implementar testes automatizados que validem fielmente o código contra o modelo.",
                                  "commonMistakes": "Esquecer de mockar dependências externas que introduzam não-determinismo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar resultados, depurar e validar",
                                  "subSteps": [
                                    "Revise falhas nos testes e compare saídas reais com esperadas.",
                                    "Depure o código do modelo usando breakpoints ou prints para rastrear discrepâncias.",
                                    "Corrija o código e reexecute os testes até 100% pass.",
                                    "Adicione testes adicionais para cobrir falhas descobertas.",
                                    "Documente lições aprendidas em comentários ou relatório."
                                  ],
                                  "verification": "Relatório final com todos testes passando e cobertura de pelo menos 80% dos componentes chave.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Debugger da IDE, logs de testes, documentação anterior.",
                                  "tips": "Use diff tools para comparar saídas reais vs esperadas em casos complexos.",
                                  "learningObjective": "Iterar em depuração para alinhar código perfeitamente ao modelo conceitual.",
                                  "commonMistakes": "Parar após primeiros passes sem verificar cobertura completa."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar e integrar testes ao pipeline",
                                  "subSteps": [
                                    "Crie um arquivo de testes dedicado e adicione ao repositório.",
                                    "Configure execução automática de testes (ex: pre-commit hook ou CI simples).",
                                    "Escreva um README com instruções para rodar testes unitários iniciais.",
                                    "Versão os testes junto com o código.",
                                    "Planeje expansão para testes mais avançados."
                                  ],
                                  "verification": "Testes documentados, executáveis via comando único e commitados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Git repositório, README.md template.",
                                  "tips": "Mantenha testes independentes para execução rápida.",
                                  "learningObjective": "Estabelecer práticas de teste sustentável para desenvolvimento de simulações.",
                                  "commonMistakes": "Não versionar testes, levando a perda de histórico."
                                }
                              ],
                              "practicalExample": "Para um modelo conceitual de fila FIFO simples (enqueue/dequeue determinísticos): Teste 1 - Enqueue [1,2,3], dequeue deve retornar 1 e fila=[2,3]; Teste 2 - Fila vazia, dequeue deve retornar None. Implemente em Python com pytest: def test_fila_fifo_basico(): f = Fila(); f.enqueue(1); assert f.dequeue() == 1.",
                              "finalVerifications": [
                                "Todos os testes unitários passam com 100% de sucesso.",
                                "Saídas dos testes coincidem exatamente com cálculos manuais do modelo conceitual.",
                                "Cobertura de testes inclui todos componentes chave identificados.",
                                "Execução é determinística em múltiplas runs.",
                                "Documentação de testes está completa e acessível.",
                                "Nenhuma falha ou warning nos logs de teste."
                              ],
                              "assessmentCriteria": [
                                "Abrangência: Pelo menos 5 casos de teste cobrindo normais e edge cases (30%).",
                                "Precisão: Asserts corretos e saídas esperadas validadas manualmente (25%).",
                                "Eficiência: Tempo de execução < 1s, código limpo e legível (20%).",
                                "Robustez: Testes independentes e idempotentes (15%).",
                                "Documentação: Casos e lições claras (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Práticas de TDD (Test-Driven Development) e depuração.",
                                "Matemática: Verificação de modelos discretos via provas por exaustão.",
                                "Engenharia de Software: Qualidade de código e CI/CD pipelines.",
                                "Lógica: Raciocínio dedutivo em validação de estados.",
                                "Estatística: Conceitos iniciais de reproducibilidade em simulações."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software para simulações financeiras (ex: modelos de fila em bancos), engenharia (simulação de redes de filas em telecom), ou jogos (lógica determinística de estados), garantindo que o código reflita fielmente o design conceitual antes de escalar para simulações complexas ou estocásticas."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.5",
                    "name": "Verificação e Validação do Modelo",
                    "description": "Verificação de erros na implementação e validação da fidelidade ao sistema real.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.5.1.1",
                        "name": "Verificação do Modelo",
                        "description": "Processo de assegurar que o modelo de simulação esteja implementado corretamente no código computacional, identificando e corrigindo erros de programação, lógica e implementação, garantindo que o modelo funcione como pretendido independentemente de sua fidelidade ao sistema real.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.1.1.1",
                            "name": "Identificar erros comuns na implementação de modelos discretos",
                            "description": "Reconhecer e diagnosticar falhas típicas como loops infinitos, erros em geradores de números aleatórios, problemas em filas de eventos e inconsistências lógicas em linguagens de simulação como GPSS ou Simio, utilizando checklists baseados em Banks et al. (2000).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Estudar os tipos comuns de erros em implementações de modelos discretos",
                                  "subSteps": [
                                    "Ler o capítulo relevante de Banks et al. (2000) sobre verificação de modelos de simulação discreta.",
                                    "Listar e categorizar erros típicos: loops infinitos, falhas em geradores de números aleatórios (RNGs), problemas em filas de eventos e inconsistências lógicas.",
                                    "Exemplificar cada erro com pseudocódigo simples em linguagens como GPSS ou Simio.",
                                    "Criar um glossário pessoal com definições e causas raiz de cada erro.",
                                    "Revisar exemplos de simulações reais onde esses erros ocorreram."
                                  ],
                                  "verification": "Conferir se a lista pessoal contém pelo menos 10 erros categorizados com exemplos pseudocódigo.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro 'Discrete-Event System Simulation' de Banks et al. (2000)",
                                    "Bloco de notas ou ferramenta digital como Notion",
                                    "Pseudocódigo editor (ex: VS Code)"
                                  ],
                                  "tips": "Comece pelos erros mais frequentes como loops infinitos para construir confiança rápida.",
                                  "learningObjective": "Compreender as causas e manifestações de erros comuns em modelos discretos.",
                                  "commonMistakes": [
                                    "Confundir erros sintáticos com lógicos",
                                    "Ignorar dependências entre componentes como RNG e filas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Familiarizar-se com checklists de verificação baseados em Banks et al.",
                                  "subSteps": [
                                    "Extrair e adaptar checklists do livro para erros em implementação: sintaxe, lógica, inicialização, terminação.",
                                    "Criar uma checklist personalizada em formato tabular com colunas para erro, sintoma, teste e correção.",
                                    "Testar a checklist em um modelo trivial de fila única sem erros para validar estrutura.",
                                    "Expandir a checklist para cobrir GPSS e Simio especificamente, adicionando itens linguaguem-dependentes.",
                                    "Simular uso da checklist verbalmente para 3 erros hipotéticos."
                                  ],
                                  "verification": "Checklist completa deve ter pelo menos 20 itens, testada em modelo trivial com relatório de aplicação.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Banks et al. (2000)",
                                    "Planilha Google Sheets ou Excel para checklist",
                                    "Documentação de GPSS/Simio online"
                                  ],
                                  "tips": "Use checkboxes interativas na planilha para facilitar o uso repetido.",
                                  "learningObjective": "Dominar ferramentas sistemáticas para diagnóstico de erros em simulações.",
                                  "commonMistakes": [
                                    "Checklists muito genéricas sem adaptação para simulação discreta",
                                    "Pular testes em modelos simples"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar checklists para diagnosticar erros em um modelo exemplo",
                                  "subSteps": [
                                    "Implementar ou carregar um modelo de simulação discreta com erros injetados (ex: loop infinito em fila de eventos).",
                                    "Executar o modelo e registrar sintomas observados (ex: tempo de simulação infinito).",
                                    "Aplicar a checklist passo a passo, marcando itens relevantes e anotando evidências.",
                                    "Isolar o erro usando depuração: traces, breakpoints em GPSS/Simio.",
                                    "Documentar o diagnóstico em um relatório curto com prints de tela ou logs."
                                  ],
                                  "verification": "Relatório deve identificar corretamente todos os 3-5 erros injetados no modelo exemplo.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Software de simulação: Simio ou GPSS/H",
                                    "Modelo exemplo com erros (fornecido ou criado)",
                                    "Debugger integrado ao software"
                                  ],
                                  "tips": "Execute simulações curtas primeiro para evitar travamentos longos.",
                                  "learningObjective": "Praticar diagnóstico sistemático em cenários controlados.",
                                  "commonMistakes": [
                                    "Assumir causa sem checklist completa",
                                    "Não registrar evidências para cada marcação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar diagnósticos e praticar em cenários variados",
                                  "subSteps": [
                                    "Corrigir erros identificados no modelo exemplo e reexecutar para confirmação.",
                                    "Aplicar checklist a 2-3 modelos adicionais de fontes variadas (ex: repositórios GitHub de simulações).",
                                    "Comparar diagnósticos com soluções conhecidas ou pares para validação cruzada.",
                                    "Refinar a checklist com itens novos descobertos.",
                                    "Simular uma revisão de código em equipe, explicando achados oralmente ou por escrito."
                                  ],
                                  "verification": "Todos os modelos adicionais diagnosticados com 90% de acurácia, checklist refinada documentada.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Modelos adicionais online",
                                    "Ferramenta de compartilhamento como GitHub",
                                    "Gravação de áudio para simulação oral"
                                  ],
                                  "tips": "Busque modelos open-source com issues reportados para prática realista.",
                                  "learningObjective": "Consolidar habilidades de identificação e validação de erros em contextos reais.",
                                  "commonMistakes": [
                                    "Não validar correções com reexecução",
                                    "Ignorar refinamentos na checklist"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um modelo de supermercado no Simio com fila de caixas, um loop infinito ocorre porque o gerador de chegada de clientes não verifica o tempo máximo de simulação, causando execuções intermináveis. Usando a checklist, identifica-se inconsistência lógica no bloco 'Create', corrigida adicionando condição de terminação.",
                              "finalVerifications": [
                                "Lista pessoal de erros comuns contém exemplos precisos para loops, RNGs, filas e lógica.",
                                "Checklist aplicada com sucesso a pelo menos 3 modelos, identificando todos os erros injetados.",
                                "Relatórios de diagnóstico incluem evidências (logs, traces) e correções validadas.",
                                "Explicação oral ou escrita de diagnósticos demonstra compreensão causal.",
                                "Checklist refinada cobre GPSS/Simio adequadamente.",
                                "Tempo de diagnóstico reduzido em prática repetida."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de pelo menos 80% dos erros comuns listados em Banks et al.",
                                "Uso sistemático da checklist em todos os passos, com documentação completa.",
                                "Qualidade das evidências em relatórios (prints, logs relevantes).",
                                "Capacidade de isolar causas raiz vs. sintomas superficiais.",
                                "Eficiência temporal: diagnóstico completo em < estimado por step.",
                                "Refinamentos na checklist mostram aprendizado iterativo."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Depuração e testes unitários em linguagens de simulação.",
                                "Estatística: Validação de RNGs e distribuições em simulações.",
                                "Engenharia de Software: Checklists e revisão de código para modelos complexos.",
                                "Gestão de Projetos: Verificação em ciclos de desenvolvimento de simulações."
                              ],
                              "realWorldApplication": "Em indústrias como manufatura e logística, identificar loops infinitos ou falhas em filas previne simulações falhas que levariam a decisões erradas em otimização de linhas de produção ou supply chains, economizando milhões em redesigns."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.1.1.2",
                            "name": "Aplicar técnicas de depuração em simulações",
                            "description": "Utilizar ferramentas de debugging integradas em softwares de simulação (ex.: Arena, AnyLogic) para rastrear execução passo a passo, inspecionar variáveis e eventos, e inserir pontos de interrupção para verificar o fluxo de eventos discretos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o Ambiente de Depuração",
                                  "subSteps": [
                                    "Abrir o software de simulação (ex.: AnyLogic ou Arena).",
                                    "Carregar o modelo de simulação a ser depurado.",
                                    "Ativar o modo de depuração nas configurações do software.",
                                    "Explorar as ferramentas de debug disponíveis: painel de variáveis, console de eventos e controles de execução.",
                                    "Executar uma simulação de teste rápida para confirmar o baseline sem debug."
                                  ],
                                  "verification": "O modo de depuração está ativo, ferramentas são acessíveis e uma simulação baseline roda sem crashes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de simulação instalado (AnyLogic ou Arena)",
                                    "Modelo de simulação salvo",
                                    "Documentação do software"
                                  ],
                                  "tips": "Atualize o software para a versão mais recente para evitar incompatibilidades com ferramentas de debug.",
                                  "learningObjective": "Preparar o ambiente de simulação para depuração eficiente e familiarizar-se com as interfaces de debug.",
                                  "commonMistakes": [
                                    "Esquecer de ativar o modo debug",
                                    "Usar configurações de simulação em vez de debug",
                                    "Ignorar atualizações do software"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Configurar Pontos de Depuração",
                                  "subSteps": [
                                    "Analisar o diagrama do modelo e mapear pontos críticos: inícios/fins de eventos discretos, mudanças de estado e variáveis voláteis.",
                                    "Inserir breakpoints em entidades, ações ou transições suspeitas.",
                                    "Adicionar watches para variáveis chave como contadores de eventos, tempos de espera e estados de filas.",
                                    "Configurar logs automáticos para rastrear sequências de eventos discretos.",
                                    "Validar a configuração executando um step inicial sem erros."
                                  ],
                                  "verification": "Breakpoints, watches e logs estão listados corretamente no painel de debug e ativam sem falhas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Modelo carregado no software",
                                    "Diagrama do modelo impresso ou anotado"
                                  ],
                                  "tips": "Limite a 5-10 breakpoints iniciais para evitar sobrecarga; priorize áreas com lógica complexa.",
                                  "learningObjective": "Selecionar pontos de depuração relevantes baseados na análise do fluxo de eventos discretos.",
                                  "commonMistakes": [
                                    "Inserir breakpoints excessivos causando lentidão",
                                    "Escolher pontos irrelevantes longe do erro suspeito",
                                    "Não configurar watches para variáveis dinâmicas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar Depuração Passo a Passo",
                                  "subSteps": [
                                    "Iniciar a simulação no modo debug.",
                                    "Usar controles de step (step into, step over, continue to breakpoint) para avançar controladamente.",
                                    "Em cada pausa, inspecionar valores de variáveis, pilha de eventos e fluxo de execução.",
                                    "Rastrear discrepâncias entre comportamento observado e esperado em eventos discretos.",
                                    "Registrar screenshots ou notas de inspeções chave."
                                  ],
                                  "verification": "Simulação avança corretamente nos breakpoints, com inspeções documentadas de pelo menos 80% dos pontos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Ambiente de debug configurado",
                                    "Bloco de notas ou ferramenta de captura de tela"
                                  ],
                                  "tips": "Use 'step over' para funções internas e 'step into' apenas para lógica customizada.",
                                  "learningObjective": "Monitorar e controlar a execução de simulações discretas para identificar anomalias em tempo real.",
                                  "commonMistakes": [
                                    "Avançar rápido sem inspecionar valores",
                                    "Confundir step into com step over",
                                    "Ignorar eventos assíncronos em simulações"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar, Corrigir e Validar Correções",
                                  "subSteps": [
                                    "Comparar dados inspecionados com especificações do modelo (ex.: valores esperados de variáveis).",
                                    "Identificar causas raiz: lógica errada, parâmetros incorretos ou condições de eventos falhas.",
                                    "Aplicar correções no modelo e remover breakpoints desnecessários.",
                                    "Reexecutar depuração completa para verificar resolução dos problemas.",
                                    "Documentar erros encontrados, correções e lições para relatórios futuros."
                                  ],
                                  "verification": "Modelo corrigido executa sem pausas nos breakpoints originais e produz saídas validadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Notas e screenshots da depuração anterior",
                                    "Backup do modelo original"
                                  ],
                                  "tips": "Sempre faça backup antes de correções; valide com múltiplas seeds de simulação aleatória.",
                                  "learningObjective": "Interpretar resultados de debug para correções precisas e validação do modelo de simulação.",
                                  "commonMistakes": [
                                    "Correções paliativas sem causa raiz",
                                    "Não retestar com dados variados",
                                    "Falta de documentação para reutilização"
                                  ]
                                }
                              ],
                              "practicalExample": "No AnyLogic, depurando um modelo de fila de call center: insira breakpoint no evento 'chegada de chamada'; inspecione variável 'filaAtual' que mostra 50 chamadas acumuladas inesperadamente; descubra taxa de atendimento baixa devido a parâmetro errado (de 2 para 5 min/chamada); corrija, reexecute e confirme tempo médio de espera reduzido para <3 min.",
                              "finalVerifications": [
                                "Inserir e gerenciar breakpoints em eventos discretos sem erros.",
                                "Inspecionar corretamente variáveis e pilha de eventos durante pausas.",
                                "Identificar discrepâncias lógicas e causas raiz em fluxos de simulação.",
                                "Corrigir modelo e validar com reexecução debug.",
                                "Documentar processo completo com evidências (screenshots/logs)."
                              ],
                              "assessmentCriteria": [
                                "Cobertura de pontos críticos de debug: ≥80% dos eventos chave monitorados.",
                                "Eficiência temporal: completado dentro de tempo estimado total (3h).",
                                "Precisão analítica: causas raiz identificadas em todos os erros simulados.",
                                "Eficácia das correções: modelo pós-debug atinge métricas esperadas (±5%).",
                                "Qualidade da documentação: clara, reproduzível e com lições aprendidas."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Equivalente a debugging em IDEs como Visual Studio ou PyCharm.",
                                "Análise de Dados: Interpretação de traces/logs como em ferramentas de monitoramento.",
                                "Engenharia de Software: Práticas de V&V (Verification & Validation) em ciclos ágeis.",
                                "Gestão de Operações: Troubleshooting em modelagem de processos industriais."
                              ],
                              "realWorldApplication": "Na logística de supply chain, como na Amazon, depuração de simulações em AnyLogic identifica gargalos em centros de distribuição, otimizando roteiros de robôs e reduzindo atrasos em 20-30%, economizando milhões em operações diárias."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.1.1.3",
                            "name": "Executar testes unitários e de integração no modelo",
                            "description": "Desenvolver e aplicar testes unitários para componentes isolados (ex.: gerador de chegadas) e testes de integração para submodelos combinados, garantindo modularidade e correção conforme recomendações de Law e Kelton (1991).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o Ambiente de Testes",
                                  "subSteps": [
                                    "Instalar bibliotecas de teste como unittest ou pytest no Python",
                                    "Criar estrutura de diretórios separada para testes (ex: /tests/unit e /tests/integration)",
                                    "Configurar mocks para dependências externas como geradores aleatórios",
                                    "Preparar dados de teste fixos ou seeds para reproducibilidade",
                                    "Configurar relatórios de cobertura de código com coverage.py"
                                  ],
                                  "verification": "Executar um teste dummy sem erros e gerar relatório de cobertura inicial",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python 3.x",
                                    "Bibliotecas: unittest/pytest, coverage.py",
                                    "Código fonte do modelo de simulação"
                                  ],
                                  "tips": "Use ambientes virtuais (venv) para isolar dependências e evite conflitos",
                                  "learningObjective": "Preparar um ambiente isolado e reprodutível para execução de testes automatizados",
                                  "commonMistakes": [
                                    "Não fixar seeds aleatórias, levando a resultados não reproduzíveis",
                                    "Misturar código de produção com testes",
                                    "Ignorar configuração de logging para depuração"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desenvolver Testes Unitários para Componentes Isolados",
                                  "subSteps": [
                                    "Identificar componentes isolados (ex: gerador de chegadas, servidor)",
                                    "Escrever testes para funções específicas com asserts de saída esperada",
                                    "Cobrir casos normais, edge cases e inválidos",
                                    "Usar mocks para simular entradas/saídas sem dependências reais",
                                    "Aplicar princípios de Law e Kelton: testar modularidade individual"
                                  ],
                                  "verification": "Todos os testes unitários passam com 100% de pass rate em execução isolada",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Editor de código (VS Code/PyCharm)",
                                    "Documentação Law e Kelton (1991)",
                                    "Exemplos de código do modelo"
                                  ],
                                  "tips": "Siga o padrão AAA (Arrange, Act, Assert) para clareza em cada teste",
                                  "learningObjective": "Criar testes unitários que validem correção de componentes individuais",
                                  "commonMistakes": [
                                    "Testar múltiplas responsabilidades em um teste",
                                    "Não testar casos de erro (ex: entrada inválida)",
                                    "Dependência implícita de estado global"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar e Depurar Testes Unitários",
                                  "subSteps": [
                                    "Executar suíte completa de testes unitários com coverage",
                                    "Analisar falhas e depurar código ou testes conforme necessário",
                                    "Refatorar testes para melhorar legibilidade e manutenibilidade",
                                    "Verificar cobertura de código mínima de 80% nos componentes",
                                    "Documentar resultados em relatório"
                                  ],
                                  "verification": "Relatório de cobertura mostra >=80% e zero falhas",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Ferramenta de coverage",
                                    "Debugger integrado no IDE"
                                  ],
                                  "tips": "Use --verbose no pytest para detalhes de falhas",
                                  "learningObjective": "Executar testes unitários de forma sistemática e corrigir discrepâncias",
                                  "commonMistakes": [
                                    "Ignorar warnings de cobertura baixa",
                                    "Não depurar falhas imediatamente",
                                    "Alterar código de produção sem novo teste"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Desenvolver Testes de Integração para Submodelos Combinados",
                                  "subSteps": [
                                    "Selecionar submodelos para integrar (ex: gerador + fila + servidor)",
                                    "Escrever testes que combinem componentes sem mocks excessivos",
                                    "Validar interações e fluxos end-to-end parciais",
                                    "Cobrir cenários de integração conforme modularidade de Law e Kelton",
                                    "Incluir testes de performance básica em integrações"
                                  ],
                                  "verification": "Testes de integração passam isoladamente dos unitários",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código fonte completo do modelo",
                                    "Dados de teste realistas"
                                  ],
                                  "tips": "Limite o escopo a 2-3 componentes por teste de integração",
                                  "learningObjective": "Desenvolver testes que garantam correção nas interfaces entre módulos",
                                  "commonMistakes": [
                                    "Testes muito amplos que viram end-to-end",
                                    "Não resetar estado entre testes",
                                    "Ignorar ordem de execução de eventos"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Executar Testes de Integração e Análise Final",
                                  "subSteps": [
                                    "Executar suíte completa (unit + integration) com seeds fixas",
                                    "Analisar resultados globais e cobertura combinada",
                                    "Corrigir falhas de integração e refatorar modelo se necessário",
                                    "Gerar relatório consolidado com métricas",
                                    "Comparar saídas com expectativas teóricas (ex: distribuições)"
                                  ],
                                  "verification": "Suíte total passa com cobertura >=85% e relatório documentado",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Ferramentas de teste e coverage",
                                    "Referência Law e Kelton"
                                  ],
                                  "tips": "Execute testes em batch com CI/CD simulado para automação",
                                  "learningObjective": "Validar integralmente a modularidade e correção do modelo via testes",
                                  "commonMistakes": [
                                    "Não comparar com validação analítica",
                                    "Sobrecarregar testes com dados reais desnecessários",
                                    "Parar após unitários sem integração"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um modelo de fila M/M/1, desenvolva testes unitários para o gerador de chegadas exponenciais (verificar média e variância com 1000 amostras) e integre com o servidor para testar tempo médio de espera, garantindo que a simulação reproduza resultados teóricos de Little's Law.",
                              "finalVerifications": [
                                "Todos os testes unitários e de integração passam (100% pass rate)",
                                "Cobertura de código combinada >=85%",
                                "Resultados reproduzíveis com seeds fixas",
                                "Relatório documenta falhas corrigidas e métricas",
                                "Validação contra referências teóricas (Law e Kelton)",
                                "Testes rodam em <5 minutos para suíte completa"
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude dos asserts em testes (cobertura de edge cases)",
                                "Adesão a princípios de modularidade e boas práticas de TDD",
                                "Qualidade da documentação e relatórios gerados",
                                "Eficiência temporal dos testes executados",
                                "Correção de erros identificados durante depuração",
                                "Integração efetiva de múltiplos componentes"
                              ],
                              "crossCurricularConnections": [
                                "Programação Orientada a Objetos (modularidade de classes)",
                                "Estatística Computacional (validação de distribuições)",
                                "Engenharia de Software (qualidade e testes automatizados)",
                                "Matemática Aplicada (análise de filas e simulações)",
                                "Gestão de Projetos (verificação em ciclos de desenvolvimento)"
                              ],
                              "realWorldApplication": "Em indústrias como logística e manufatura, esses testes garantem que modelos de simulação de sistemas de produção sejam confiáveis antes de otimizar processos reais, evitando custos com erros em cenários de alta escala como supply chains."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.5.1.2",
                        "name": "Validação do Modelo",
                        "description": "Processo de confirmar que o modelo de simulação reproduz fielmente o comportamento e as saídas estatísticas do sistema real, utilizando dados empíricos e testes para avaliar a credibilidade do modelo.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.1.2.1",
                            "name": "Comparar saídas do modelo com dados reais do sistema",
                            "description": "Colecionar dados históricos do sistema real e confrontá-los com réplicas do modelo via gráficos de tendência, histogramas e médias móveis, identificando discrepâncias em métricas como tempo de espera ou utilização de recursos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Coletar dados históricos do sistema real",
                                  "subSteps": [
                                    "Identifique as métricas relevantes, como tempo de espera e utilização de recursos, baseadas no contexto do sistema.",
                                    "Acesse bancos de dados ou logs do sistema real para extrair dados históricos em formato tabular (ex: CSV).",
                                    "Limpe os dados removendo outliers e valores ausentes usando ferramentas como Pandas ou Excel.",
                                    "Calcule estatísticas descritivas iniciais: média, mediana, desvio padrão para cada métrica.",
                                    "Documente a fonte e o período dos dados coletados."
                                  ],
                                  "verification": "Verifique se o dataset final tem pelo menos 1000 observações limpas e estatísticas calculadas em um relatório.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Acesso a logs do sistema real",
                                    "Python com Pandas e NumPy",
                                    "Excel ou Google Sheets"
                                  ],
                                  "tips": "Priorize dados de períodos representativos para evitar viés sazonal.",
                                  "learningObjective": "Aprender a coletar e preparar dados reais de forma confiável para comparação.",
                                  "commonMistakes": [
                                    "Ignorar limpeza de dados levando a análises enviesadas",
                                    "Selecionar período de dados não representativo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar réplicas de saídas do modelo de simulação",
                                  "subSteps": [
                                    "Execute múltiplas réplicas do modelo (pelo menos 30 runs) com sementes aleatórias diferentes para capturar variabilidade.",
                                    "Registre as mesmas métricas do sistema real: tempo de espera, utilização de recursos.",
                                    "Salve as saídas em formato compatível (CSV) com colunas idênticas aos dados reais.",
                                    "Calcule estatísticas agregadas das réplicas: médias, intervalos de confiança.",
                                    "Valide que o modelo está configurado corretamente para replicar condições reais."
                                  ],
                                  "verification": "Confirme que há pelo menos 30 réplicas com métricas calculadas e salvas em arquivo.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Software de simulação (ex: SimPy, Arena)",
                                    "Python para execução em batch"
                                  ],
                                  "tips": "Use paralelização para acelerar múltiplas runs se o modelo for computacionalmente intensivo.",
                                  "learningObjective": "Dominar a geração de dados de simulação robustos para validação estatística.",
                                  "commonMistakes": [
                                    "Poucas réplicas levando a variância alta",
                                    "Configuração incorreta do modelo ignorando parâmetros reais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Preparar visualizações comparativas",
                                  "subSteps": [
                                    "Carregue dados reais e de modelo em uma ferramenta de visualização (ex: Matplotlib, Seaborn).",
                                    "Crie gráficos de tendência (linhas temporais), histogramas de distribuições e médias móveis (janela de 50 pontos).",
                                    "Sobreponha curvas reais e de modelo em um único gráfico para cada métrica.",
                                    "Adicione elementos visuais: legendas, intervalos de confiança para o modelo, escalas idênticas.",
                                    "Salve visualizações em alta resolução para análise posterior."
                                  ],
                                  "verification": "Inspecione os gráficos gerados para garantir sobreposição clara e legibilidade.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com Matplotlib, Seaborn",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Use cores contrastantes e transparência para intervalos de confiança.",
                                  "learningObjective": "Desenvolver habilidades em visualização de dados para detecção visual de discrepâncias.",
                                  "commonMistakes": [
                                    "Escalas diferentes nos eixos distorcendo percepções",
                                    "Falta de intervalos de confiança no modelo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e identificar discrepâncias",
                                  "subSteps": [
                                    "Compare visualmente os gráficos identificando desvios qualitativos (ex: picos ausentes).",
                                    "Calcule métricas quantitativas de discrepância: RMSE, MAE, testes estatísticos (Kolmogorov-Smirnov).",
                                    "Liste discrepâncias por métrica com magnitudes (ex: tempo de espera 15% maior no modelo).",
                                    "Priorize discrepâncias impactantes (acima de 10% de diferença relativa).",
                                    "Documente hipóteses para causas das discrepâncias (ex: suposições do modelo erradas)."
                                  ],
                                  "verification": "Produza um relatório com tabela de discrepâncias e gráficos anotados.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Python com SciPy para testes estatísticos",
                                    "Relatório em Markdown ou Word"
                                  ],
                                  "tips": "Combine análise qualitativa e quantitativa para robustez.",
                                  "learningObjective": "Capacitar na quantificação e interpretação de validação de modelos.",
                                  "commonMistakes": [
                                    "Foco só em visual sem métricas numéricas",
                                    "Ignorar variabilidade estatística"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de call center, colete dados reais de 1 mês (tempos de espera médios de 2.5 min). Rode 50 réplicas do modelo gerando esperas médias de 2.8 min. Plote histogramas mostrando distribuição real (skewed right) vs modelo (normal), revelando discrepância na cauda longa; calcule RMSE de 0.4 min e ajuste o modelo para distribuidores reais de chegada.",
                              "finalVerifications": [
                                "Gráficos mostram sobreposição visual das tendências principais.",
                                "Discrepâncias quantificadas com RMSE/MAE abaixo de 20% para métricas críticas.",
                                "Testes estatísticos (KS-test p-value > 0.05) confirmam distribuições semelhantes onde esperado.",
                                "Relatório lista pelo menos 3 discrepâncias com hipóteses causais.",
                                "Dados e códigos versionados em repositório (GitHub).",
                                "Intervalos de confiança do modelo capturam 95% dos dados reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão das métricas de discrepância (erro < 5% em cálculos).",
                                "Qualidade visual dos gráficos (clareza, escalas consistentes).",
                                "Robustez estatística (múltiplas réplicas e testes apropriados).",
                                "Profundidade da análise (qualitativa + quantitativa).",
                                "Documentação completa e acionável.",
                                "Identificação correta de pelo menos 80% das discrepâncias reais."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Testes de hipóteses e análise de distribuições.",
                                "Programação: Manipulação de dados com Python/Pandas.",
                                "Engenharia de Software: Versionamento e reproducibilidade de simulações.",
                                "Gestão de Projetos: Documentação de validação para stakeholders."
                              ],
                              "realWorldApplication": "Na indústria manufatureira, validar modelos de simulação de linhas de produção comparando utilizações de máquinas reais vs simuladas, permitindo otimizações que reduzem downtime em 20% antes de investimentos reais."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.1.2.2",
                            "name": "Aplicar testes estatísticos para validação",
                            "description": "Executar testes como qui-quadrado para distribuições, teste t de Student para médias e intervalos de confiança para verificar se as saídas simuladas são estatisticamente indistinguíveis das observadas, conforme Pidd (1998).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e analisar os dados observados e simulados",
                                  "subSteps": [
                                    "Coletar dados observados do sistema real (ex.: tempos de espera em uma fila)",
                                    "Executar simulações para gerar dados simulados equivalentes",
                                    "Verificar normalidade e homogeneidade dos dados com testes preliminares (Shapiro-Wilk, Levene)",
                                    "Organizar dados em tabelas ou vetores para cada teste (frequências para qui-quadrado, médias para t-test)",
                                    "Visualizar dados com histogramas e boxplots para inspeção inicial"
                                  ],
                                  "verification": "Dados preparados estão limpos, normalizados e visualizados sem discrepâncias óbvias",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software estatístico (Python com SciPy/Pandas, R ou Excel)",
                                    "Dados observados e simulados em CSV"
                                  ],
                                  "tips": "Use seeds fixas nas simulações para reprodutibilidade",
                                  "learningObjective": "Preparar dados de forma adequada para aplicação de testes estatísticos específicos",
                                  "commonMistakes": [
                                    "Ignorar outliers que distorcem resultados",
                                    "Não equalizar tamanhos de amostra",
                                    "Confundir dados categóricos com contínuos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar teste qui-quadrado para validação de distribuições",
                                  "subSteps": [
                                    "Construir tabela de contingência com frequências observadas e esperadas",
                                    "Calcular estatística qui-quadrado: Σ[(O-E)^2 / E]",
                                    "Determinar graus de liberdade e valor p via distribuição qui-quadrado",
                                    "Executar teste no software (ex.: scipy.stats.chisquare em Python)",
                                    "Interpretar: p > 0.05 indica distribuições indistinguíveis"
                                  ],
                                  "verification": "Resultado do teste qui-quadrado gerado com p-value reportado e interpretado corretamente",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Biblioteca SciPy ou função chisq.test no R",
                                    "Tabela de frequências pronta"
                                  ],
                                  "tips": "Garanta que categorias tenham pelo menos 5 observações esperadas",
                                  "learningObjective": "Aplicar e interpretar teste qui-quadrado para comparar distribuições categóricas",
                                  "commonMistakes": [
                                    "Usar em dados contínuos sem discretização",
                                    "Esquecer correção de Yates para 2x2",
                                    "Interpretar p-value ao contrário"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar teste t de Student para comparação de médias",
                                  "subSteps": [
                                    "Verificar pressupostos: normalidade e variâncias iguais",
                                    "Calcular médias e desvios padrão de dados observados e simulados",
                                    "Executar teste t pareado ou independente (scipy.stats.ttest_ind)",
                                    "Obter estatística t, graus de liberdade e p-value",
                                    "Concluir se médias são estatisticamente iguais (p > 0.05)"
                                  ],
                                  "verification": "Relatório do teste t inclui t-stat, df e p-value com interpretação",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software com função ttest (Python/R)",
                                    "Vetores de dados numéricos"
                                  ],
                                  "tips": "Use teste t de Welch se variâncias diferirem",
                                  "learningObjective": "Realizar teste t para validar igualdade de médias entre simulação e realidade",
                                  "commonMistakes": [
                                    "Aplicar sem verificar normalidade",
                                    "Confundir teste pareado com independente",
                                    "Ignorar tamanho de amostra pequeno"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular intervalos de confiança e interpretar validação global",
                                  "subSteps": [
                                    "Calcular IC 95% para médias: média ± (t * SE)",
                                    "Verificar se ICs de observados e simulados se sobrepõem",
                                    "Combinar resultados dos testes anteriores em um relatório",
                                    "Decidir validação: todos testes passam se p > 0.05 e ICs compatíveis",
                                    "Documentar limitações e sugestões de refinamento do modelo"
                                  ],
                                  "verification": "Intervalos de confiança calculados e decisão de validação justificada",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Funções de IC em SciPy ou R (t.interval)",
                                    "Resultados prévios dos testes"
                                  ],
                                  "tips": "Use bootstrap para ICs não-paramétricos se normalidade falhar",
                                  "learningObjective": "Integrar testes e ICs para uma validação estatística completa",
                                  "commonMistakes": [
                                    "Usar Z em vez de t para amostras pequenas",
                                    "Sobrepor ICs sem testar significância",
                                    "Ignorar múltiplos testes (correção Bonferroni)"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar e revisar a validação estatística",
                                  "subSteps": [
                                    "Compilar relatório com gráficos, tabelas e conclusões",
                                    "Comparar com critérios de Pidd (1998) para validação",
                                    "Testar sensibilidade alterando parâmetros da simulação",
                                    "Arquivar resultados para validação futura",
                                    "Discutir implicações para o modelo simulado"
                                  ],
                                  "verification": "Relatório completo gerado e revisado por pares ou autoavaliação",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de relatórios (Jupyter Notebook, LaTeX ou Word)",
                                    "Referência Pidd (1998)"
                                  ],
                                  "tips": "Inclua código fonte para reprodutibilidade",
                                  "learningObjective": "Documentar processo de validação de forma profissional e revisável",
                                  "commonMistakes": [
                                    "Relatório vago sem números",
                                    "Não citar fontes",
                                    "Omitir discussão de falhas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado, compare frequências de tempos de espera observados (dados reais de 100 clientes) com simulados (1000 runs). Aplique qui-quadrado às categorias de tempo (<5min, 5-10min, >10min), t-test nas médias de espera e ICs para validar se o modelo captura o comportamento real.",
                              "finalVerifications": [
                                "Todos testes (qui-quadrado, t-test, ICs) executados com p-values >0.05",
                                "Relatório inclui gráficos comparativos de dados observados vs simulados",
                                "Código fonte é executável e reprodutível",
                                "Interpretação alinhada com Pidd (1998)",
                                "Limitações do modelo identificadas",
                                "Validação aprovada ou rejeitada com justificativa"
                              ],
                              "assessmentCriteria": [
                                "Precisão na escolha e execução dos testes estatísticos (90% correto)",
                                "Correta interpretação de p-values e ICs (sem inversão de lógica)",
                                "Qualidade dos substeps e verificações em cada passo",
                                "Relatório completo e visualmente claro",
                                "Integração de múltiplos testes sem erros de múltipla comparação",
                                "Tempo total dentro do estimado (±20%)"
                              ],
                              "crossCurricularConnections": [
                                "Estatística Inferencial: Fundamentos de testes de hipóteses",
                                "Programação Computacional: Uso de Python/R para análise estatística",
                                "Simulação de Sistemas: Validação em eventos discretos (Arena, Simul8)",
                                "Gestão de Projetos: Documentação de validação em engenharia",
                                "Ciência de Dados: Visualização e manipulação de dados com Pandas/Matplotlib"
                              ],
                              "realWorldApplication": "Na indústria logística, validar modelos de simulação de centros de distribuição para otimizar estoques, reduzindo custos em 15-20% ao garantir que previsões de throughput sejam estatisticamente equivalentes aos dados reais de operação."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.1.2.3",
                            "name": "Realizar validação de face e análises de sensibilidade",
                            "description": "Consultar especialistas do domínio para validação qualitativa (face validity) e variar parâmetros do modelo para analisar impactos nas saídas, confirmando robustez e identificando suposições críticas (Banks et al., 2000).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a Validação de Face",
                                  "subSteps": [
                                    "Identifique especialistas do domínio relevantes para o modelo de simulação (ex.: gerentes de operações para simulações de filas).",
                                    "Prepare uma apresentação clara do modelo, incluindo diagrama, suposições e saídas esperadas.",
                                    "Crie um questionário ou roteiro de entrevista com perguntas sobre plausibilidade e realismo do modelo.",
                                    "Defina critérios qualitativos para face validity, como 'o modelo representa fielmente o sistema real?'",
                                    "Agende sessões de consulta com os especialistas."
                                  ],
                                  "verification": "Lista de especialistas identificados e agendamentos confirmados; apresentação e questionário prontos e revisados.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Apresentação em PowerPoint ou PDF do modelo",
                                    "Questionário ou roteiro de entrevista",
                                    "Lista de contatos de especialistas"
                                  ],
                                  "tips": "Escolha especialistas com experiência prática no domínio para feedback autêntico.",
                                  "learningObjective": "Compreender e preparar materiais para elicitar feedback qualitativo de especialistas.",
                                  "commonMistakes": [
                                    "Selecionar especialistas sem experiência relevante",
                                    "Preparar materiais muito técnicos sem contexto acessível"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar a Validação de Face",
                                  "subSteps": [
                                    "Apresente o modelo aos especialistas e colete feedback qualitativo via entrevistas ou questionários.",
                                    "Registre respostas detalhadas, incluindo concordâncias e discordâncias sobre suposições e comportamentos.",
                                    "Classifique o feedback em categorias: plausível, implausível, sugestões de melhoria.",
                                    "Discuta ambiguidades com os especialistas para esclarecimentos.",
                                    "Compile um relatório resumido do feedback coletado."
                                  ],
                                  "verification": "Relatório de feedback com pelo menos 80% de concordância em plausibilidade e ações para discrepâncias.",
                                  "estimatedTime": "6 horas",
                                  "materials": [
                                    "Ferramentas de gravação ou notas (Zoom, Google Forms)",
                                    "Relatório template para feedback"
                                  ],
                                  "tips": "Use perguntas abertas para capturar insights ricos e evite leading questions.",
                                  "learningObjective": "Coletar e sintetizar feedback qualitativo para validar a representatividade do modelo.",
                                  "commonMistakes": [
                                    "Ignorar feedback minoritário",
                                    "Não registrar respostas verbatim para perda de nuances"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Planejar e Realizar Análises de Sensibilidade",
                                  "subSteps": [
                                    "Identifique parâmetros chave do modelo (ex.: taxa de chegada, tempo de serviço) e suposições críticas.",
                                    "Defina variações sistemáticas: ±10%, ±20%, cenários extremos.",
                                    "Execute simulações múltiplas variando um parâmetro por vez (one-at-a-time) ou todos juntos (global).",
                                    "Monitore impactos nas saídas principais (ex.: tempo médio de espera).",
                                    "Gere gráficos e tabelas de sensibilidade (tornado plots)."
                                  ],
                                  "verification": "Gráficos de sensibilidade gerados mostrando impactos quantificáveis em pelo menos 5 parâmetros.",
                                  "estimatedTime": "8 horas",
                                  "materials": [
                                    "Software de simulação (Arena, Simul8)",
                                    "Planilhas para tracking (Excel)",
                                    "Bibliotecas Python (SALib para análise global)"
                                  ],
                                  "tips": "Comece com one-at-a-time para simplicidade antes de métodos globais.",
                                  "learningObjective": "Avaliar robustez do modelo variando parâmetros e identificando sensíveis.",
                                  "commonMistakes": [
                                    "Variar parâmetros irrelevantes",
                                    "Ignorar correlações entre parâmetros"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Resultados e Documentar Robustez",
                                  "subSteps": [
                                    "Interprete resultados: identifique parâmetros críticos e suposições impactantes.",
                                    "Compare com feedback de face validity para consistência.",
                                    "Recomende ajustes no modelo ou faixa de confiança nas saídas.",
                                    "Documente achados em relatório final com evidências.",
                                    "Valide robustez geral: modelo é sensível demais a suposições?"
                                  ],
                                  "verification": "Relatório final com conclusões sobre robustez, suposições críticas e recomendações implementadas.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Templates de relatório",
                                    "Gráficos de sensibilidade",
                                    "Feedback de face validity"
                                  ],
                                  "tips": "Use thresholds (ex.: >10% mudança = sensível) para objetividade.",
                                  "learningObjective": "Sintetizar validações para confirmar robustez e guiar melhorias.",
                                  "commonMistakes": [
                                    "Sobre-generalizar de poucas runs",
                                    "Não ligar achados à decisão prática"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um modelo de simulação de fila de supermercado, consulte caixas e gerentes para validar se tempos de serviço e chegadas parecem reais (face validity). Varie taxa de chegada em ±20% e observe impacto no tempo de espera: se dobra, é sensível, exigindo dados reais mais precisos.",
                              "finalVerifications": [
                                "Feedback de face validity coletado de ≥3 especialistas com ≥80% aprovação.",
                                "Análises de sensibilidade executadas para ≥5 parâmetros chave.",
                                "Gráficos/tabelas mostram impactos claros e identificam top-3 suposições críticas.",
                                "Relatório documenta robustez geral e recomendações acionáveis.",
                                "Modelo ajustado com base em achados e revalidado.",
                                "Consistência entre validação qualitativa e quantitativa confirmada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação e consulta de especialistas (qualidade do feedback).",
                                "Abrangência das variações de parâmetros e métodos de sensibilidade usados.",
                                "Profundidade da análise de impactos e interpretação de resultados.",
                                "Clareza e completude da documentação final.",
                                "Integração efetiva de face validity com sensibilidade.",
                                "Capacidade de identificar e mitigar suposições críticas."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Análise de variância e testes de sensibilidade.",
                                "Programação: Implementação de loops de simulação e visualizações (Python/R).",
                                "Gestão de Projetos: Consulta de stakeholders e elicitação de requisitos.",
                                "Engenharia de Software: Verificação e validação em modelagem.",
                                "Pesquisa Científica: Métodos qualitativos e quantitativos de validação."
                              ],
                              "realWorldApplication": "Em manufatura, validar modelos de produção para otimizar linhas de montagem; em saúde, analisar filas de emergência para alocação de recursos; em finanças, testar robustez de modelos de risco variando volatilidade de mercado."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.1.2.4",
                            "name": "Planejar experimentos de validação",
                            "description": "Definir número de réplicas, comprimento de simulação transitória e estacionária, e critérios de parada para experimentos de validação, integrando técnicas de redução de variância como controle de variáveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir objetivos da validação e requisitos estatísticos",
                                  "subSteps": [
                                    "Identificar as métricas de performance do modelo a serem validadas (ex: tempo médio de espera, taxa de utilização).",
                                    "Determinar o nível de confiança desejado (ex: 95%) e precisão (ex: erro relativo < 5%).",
                                    "Analisar a estrutura do modelo para identificar fontes de variabilidade estocástica.",
                                    "Revisar literatura ou dados históricos para estimar variâncias iniciais das métricas.",
                                    "Documentar hipóteses de validação (ex: modelo reproduz distribuição empírica)."
                                  ],
                                  "verification": "Checklist completo dos objetivos e requisitos assinados e revisados por pares.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Documentação do modelo",
                                    "Ferramentas de análise estatística (R ou Python com pandas)",
                                    "Literatura sobre simulação discreta"
                                  ],
                                  "tips": "Comece com requisitos realistas baseados em recursos computacionais disponíveis.",
                                  "learningObjective": "Compreender como alinhar planejamento estatístico aos objetivos de validação.",
                                  "commonMistakes": [
                                    "Subestimar variabilidade levando a planos subpotentes",
                                    "Ignorar múltiplas métricas de interesse"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Determinar comprimento das simulações transitória e estacionária",
                                  "subSteps": [
                                    "Executar simulações preliminares curtas para plotar curvas de amostragem cumulativa.",
                                    "Identificar ponto de estabilização usando testes como Welch's ou inspeção visual de médias móveis.",
                                    "Calcular comprimento transitório (ex: 10% do total ou até estabilização).",
                                    "Definir comprimento estacionário baseado em autocorrelação e precisão desejada (ex: 1000-5000 runs).",
                                    "Validar com simulações de teste para confirmar independência das fases."
                                  ],
                                  "verification": "Gráficos de warm-up e estacionário mostram estabilização clara; valores documentados.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software de simulação (ex: SimPy em Python, Arena)",
                                    "Bibliotecas de plotagem (matplotlib, ggplot2)"
                                  ],
                                  "tips": "Use plotagens interativas para visualizar rapidamente a estabilização.",
                                  "learningObjective": "Dominar análise de warm-up para evitar bias em estatísticas estacionárias.",
                                  "commonMistakes": [
                                    "Cortar transitório muito cedo causando bias",
                                    "Simulações estacionárias muito curtas aumentando variância"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular número de réplicas e integrar redução de variância",
                                  "subSteps": [
                                    "Estimar variância piloto das métricas de interesse via simulações iniciais.",
                                    "Usar fórmula de intervalo de confiança para calcular réplicas mínimas: n = (Z * CV / E)^2, onde CV é coeficiente de variação.",
                                    "Selecionar técnicas como controle comum, variáveis antitéticas ou stratified sampling.",
                                    "Implementar piloto com redução de variância para refinar estimativas.",
                                    "Ajustar número final de réplicas considerando correlações entre réplicas."
                                  ],
                                  "verification": "Cálculos documentados com fórmulas, valores piloto e n final justificado.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Calculadora estatística ou script Python/R para IC",
                                    "Documentos sobre técnicas de variance reduction"
                                  ],
                                  "tips": "Priorize controle comum se houver cenários comparáveis para reduzir variância em até 50%.",
                                  "learningObjective": "Aplicar métodos estatísticos para otimizar eficiência experimental.",
                                  "commonMistakes": [
                                    "Não usar pilotos levando a super ou sub-dimensionamento",
                                    "Ignorar dependências entre réplicas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estabelecer critérios de parada e documentar plano completo",
                                  "subSteps": [
                                    "Definir critérios sequenciais (ex: IC estabiliza, convergência de KS-test).",
                                    "Especificar condições de parada para réplicas (ex: CV < 0.1 ou max 100 runs).",
                                    "Integrar validação cruzada com dados reais ou modelos conhecidos.",
                                    "Criar cronograma de execução e alocação de recursos computacionais.",
                                    "Redigir relatório do plano com todos os parâmetros e justificativas."
                                  ],
                                  "verification": "Plano completo aprovado por revisor, com simulação teste executada.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Template de plano de experimento",
                                    "Ferramenta de documentação (LaTeX, Markdown)"
                                  ],
                                  "tips": "Inclua contingências para falhas computacionais ou variâncias inesperadas.",
                                  "learningObjective": "Sintetizar planejamento em um protocolo reproduzível e robusto.",
                                  "commonMistakes": [
                                    "Critérios vagos levando a execuções infinitas",
                                    "Plano não documentado causando irreprodutibilidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Para validar um modelo de simulação de fila M/M/1 em um call center, planeje 50 réplicas independentes, descartando 200 chamadas transitórias (10%), rodando 2000 estacionárias por réplica, usando controle comum randomizado para comparar com baseline empírico, parando quando IC do tempo médio de espera < 5% (95% confiança).",
                              "finalVerifications": [
                                "Número de réplicas calculado com base em piloto e atende precisão desejada.",
                                "Fases transitória e estacionária claramente delimitadas com evidência gráfica.",
                                "Pelo menos uma técnica de redução de variância integrada e justificada.",
                                "Critérios de parada quantitativos e testáveis definidos.",
                                "Plano documentado com cronograma e recursos alocados.",
                                "Simulação piloto confirma viabilidade do plano."
                              ],
                              "assessmentCriteria": [
                                "Precisão estatística: Erro relativo das estimativas < 10% do alvo.",
                                "Eficiência: Redução de variância > 20% via técnicas aplicadas.",
                                "Robustez: Plano lida com variabilidades inesperadas via contingências.",
                                "Clareza: Documentação permite reprodução por terceiros.",
                                "Alinhamento: Todos parâmetros suportam objetivos de validação.",
                                "Inovação: Uso criativo de técnicas além do básico."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Cálculo de intervalos de confiança e testes de hipóteses.",
                                "Programação: Implementação de simulações paralelas e análise de dados.",
                                "Design de Experimentos: Planejamento DOE para simulações estocásticas.",
                                "Engenharia de Software: Validação de modelos computacionais.",
                                "Gestão de Projetos: Alocação de recursos e cronogramas."
                              ],
                              "realWorldApplication": "Em indústrias como manufatura (validação de linhas de produção via simulação), finanças (modelos de risco Monte Carlo) e saúde (simulações de epidemias), onde planos precisos reduzem custos computacionais e aumentam confiança em decisões baseadas em modelos."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.6",
                    "name": "Projeto e Execução de Experimentos",
                    "description": "Planejamento das rodadas de simulação, análise de resultados e técnicas de redução de variância.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.6.1",
                        "name": "Planejamento das Rodadas de Simulação",
                        "description": "Definição dos fatores de controle, níveis experimentais, número de replicatas e designs experimentais adequados para simulações de sistemas discretos, visando otimizar a exploração do espaço de parâmetros.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.6.1.1",
                            "name": "Identificar fatores de entrada e respostas de interesse",
                            "description": "Selecionar variáveis controláveis (fatores) como taxas de chegada, tempos de serviço e configurações de filas, e definir medidas de desempenho (respostas) como tempo médio no sistema ou taxa de utilização em simulações discretas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de fatores de entrada e respostas de interesse",
                                  "subSteps": [
                                    "Estude a definição de fatores de entrada: variáveis controláveis que influenciam o comportamento do sistema, como taxas de chegada de clientes ou tempos de serviço.",
                                    "Revise respostas de interesse: medidas de desempenho quantificáveis, como tempo médio no sistema ou taxa de utilização de recursos.",
                                    "Analise exemplos de simulações discretas de eventos (DES), como filas M/M/1, para diferenciar entradas de saídas.",
                                    "Crie um glossário pessoal com termos chave: fator, resposta, controlável, desempenho.",
                                    "Discuta com um colega ou tutor para esclarecer dúvidas conceituais."
                                  ],
                                  "verification": "Crie um mapa mental ou tabela resumindo 5 fatores e 5 respostas de um sistema de fila simples; revise se está correto.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro-texto de simulação (ex: Law & Kelton), papel e caneta, acesso a slides do curso MC-37"
                                  ],
                                  "tips": "Use analogias do dia a dia, como tráfego em um semáforo, para fixar conceitos.",
                                  "learningObjective": "Diferenciar precisamente fatores de entrada controláveis de respostas de desempenho em simulações DES.",
                                  "commonMistakes": [
                                    "Confundir fatores com eventos aleatórios não controláveis",
                                    "Ignorar o escopo do sistema ao listar variáveis",
                                    "Misturar respostas com fatores"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e listar todos os possíveis fatores de entrada do sistema",
                                  "subSteps": [
                                    "Desenhe um diagrama do sistema (ex: fluxo de uma fila de banco) destacando pontos de entrada e processamento.",
                                    "Liste todas as variáveis potenciais: taxas (chegada/saída), configurações (número de servidores), distribuições probabilísticas.",
                                    "Classifique cada variável como controlável (ex: número de caixas) ou incontrolável (ex: feriados).",
                                    "Priorize fatores baseados no contexto do experimento, removendo irrelevantes.",
                                    "Documente em uma tabela: nome da variável, tipo (contínua/discreta), faixa possível de valores."
                                  ],
                                  "verification": "Gere uma lista de pelo menos 8 fatores com classificações; valide com referências do curso.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software de diagramação (ex: Draw.io), planilha Excel ou Google Sheets, notas do contexto MC-37"
                                  ],
                                  "tips": "Comece pelo diagrama para visualizar fluxos e evitar omissões.",
                                  "learningObjective": "Listar e classificar fatores de entrada relevantes de forma sistemática para um sistema DES específico.",
                                  "commonMistakes": [
                                    "Listar variáveis irrelevantes ou fora do escopo",
                                    "Não especificar faixas de variação",
                                    "Confundir parâmetros fixos com fatores variáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir respostas de interesse alinhadas aos objetivos do experimento",
                                  "subSteps": [
                                    "Revise os objetivos da simulação (ex: minimizar tempo de espera).",
                                    "Selecione métricas de desempenho: tempo médio no sistema, comprimento médio da fila, taxa de utilização, probabilidade de espera > X.",
                                    "Especifique como calcular cada resposta (ex: média de amostras de simulação).",
                                    "Garanta mensurabilidade e relevância prática para o problema.",
                                    "Crie uma tabela de respostas: nome, fórmula, unidade, meta desejada."
                                  ],
                                  "verification": "Desenvolva uma lista de 5 respostas com fórmulas; teste em um exemplo simples manualmente.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Planilha para cálculos (Excel), pseudocódigo para simulação básica, referências estatísticas"
                                  ],
                                  "tips": "Alinhe respostas diretamente aos objetivos para evitar métricas desnecessárias.",
                                  "learningObjective": "Selecionar e especificar respostas de interesse quantificáveis e relevantes para avaliação de desempenho.",
                                  "commonMistakes": [
                                    "Escolher métricas não calculáveis em DES",
                                    "Definir respostas vagas sem fórmulas",
                                    "Ignorar variância ou intervalos de confiança"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e documentar a seleção final de fatores e respostas",
                                  "subSteps": [
                                    "Compare sua seleção com literatura ou exemplos semelhantes (ex: simulações de call centers).",
                                    "Simule cenários qualitativos: 'O que acontece se fator X variar?'.",
                                    "Revise por completude: cobre todos os aspectos críticos do sistema?",
                                    "Documente justificativas para cada escolha em um relatório curto.",
                                    "Apresente a um par para feedback e ajustes."
                                  ],
                                  "verification": "Produza um documento final validado com pelo menos 3 fatores e 4 respostas; obtenha aprovação de um tutor.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Document editor (Google Docs), exemplos de simulações do curso"
                                  ],
                                  "tips": "Use a regra SMART (Specific, Measurable, Achievable, Relevant, Time-bound) para validação.",
                                  "learningObjective": "Validar e justificar escolhas de fatores e respostas para robustez experimental.",
                                  "commonMistakes": [
                                    "Não justificar seleções",
                                    "Sobrecarregar com muitos fatores",
                                    "Pular validação externa"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de supermercado: Fatores de entrada = taxa de chegada de clientes (λ=10/hora, variando 8-12), número de caixas (1-4), tempo médio de serviço (5 min, variando 3-7). Respostas = tempo médio na fila (<10 min), taxa de utilização dos caixas (>80%), probabilidade de fila >5 clientes (<5%). Execute rodadas variando caixas para otimizar layout.",
                              "finalVerifications": [
                                "Lista fatores controláveis com faixas e justificativas corretas.",
                                "Define pelo menos 4 respostas mensuráveis com fórmulas.",
                                "Diagrama do sistema inclui todos os fatores identificados.",
                                "Justificativas alinham com objetivos do experimento.",
                                "Validação qualitativa demonstra impacto das variações.",
                                "Documentação está clara e completa para uso em simulação."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: distinção clara entre fatores e respostas (30%)",
                                "Completude: cobertura de variáveis relevantes (25%)",
                                "Mensurabilidade: fórmulas e cálculos viáveis (20%)",
                                "Relevância: alinhamento com objetivos (15%)",
                                "Documentação: clareza e justificativas (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Estatística: cálculo de médias, variâncias e intervalos de confiança para respostas.",
                                "Programação: implementação de geradores de variáveis aleatórias para fatores.",
                                "Engenharia de Produção: otimização de sistemas de filas reais.",
                                "Análise de Dados: interpretação de saídas de simulações."
                              ],
                              "realWorldApplication": "Em logística, identificar fatores como taxa de chegada de caminhões e número de docas em um armazém, com respostas como tempo médio de carregamento, para otimizar operações e reduzir custos em empresas como Amazon ou portos marítimos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.1.2",
                            "name": "Escolher design experimental apropriado",
                            "description": "Aplicar designs fatoriais completos, fracionários ou de superfície de resposta para planejar rodadas de simulação, considerando o equilíbrio entre custo computacional e precisão estatística.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar fatores, níveis e objetivos do experimento",
                                  "subSteps": [
                                    "Liste todos os fatores de entrada relevantes para a simulação (ex.: taxa de chegada, tempo de serviço).",
                                    "Defina os níveis para cada fator (ex.: baixo, médio, alto).",
                                    "Especifique os objetivos principais (ex.: estimar efeitos principais, interações).",
                                    "Documente restrições iniciais de custo computacional (ex.: limite de rodadas).",
                                    "Crie uma tabela de fatores e níveis."
                                  ],
                                  "verification": "Verifique se a tabela de fatores e níveis está completa e alinhada aos objetivos do experimento.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": "Planilha (Excel/Google Sheets), documento de especificação do problema de simulação.",
                                  "tips": "Comece com poucos fatores (3-5) para simplicidade inicial.",
                                  "learningObjective": "Compreender e mapear os elementos chave do problema experimental.",
                                  "commonMistakes": "Ignorar interações potenciais entre fatores ou definir níveis irreais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Avaliar custo computacional e requisitos de precisão",
                                  "subSteps": [
                                    "Estime o tempo de cada rodada de simulação (ex.: 1 minuto por run).",
                                    "Calcule o número de rodadas necessárias para cada tipo de design (fatorial completo: 2^k; fracionário: 2^{k-p}).",
                                    "Defina thresholds de precisão (ex.: poder estatístico > 80%, intervalo de confiança < 10%).",
                                    "Compare custo vs. precisão em uma matriz qualitativa.",
                                    "Priorize trade-offs com base no contexto (ex.: protótipo vs. produção)."
                                  ],
                                  "verification": "Confirme que há uma matriz comparativa com custos estimados e métricas de precisão.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": "Calculadora ou software (Python/R para simulações rápidas), tabela de comparação.",
                                  "tips": "Use fórmulas padrão: para fatorial completo, runs = níveis^fatores.",
                                  "learningObjective": "Quantificar o equilíbrio entre recursos computacionais e qualidade estatística.",
                                  "commonMistakes": "Subestimar tempo de simulação ou ignorar variância do sistema."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar e selecionar o design experimental apropriado",
                                  "subSteps": [
                                    "Revise designs: fatorial completo (alta precisão, alto custo), fracionário (reduz runs, assume aliases), superfície de resposta (otimização contínua).",
                                    "Escolha baseado na análise: ex.: fracionário 2^{k-1} para 5 fatores.",
                                    "Justifique a escolha com cálculos (ex.: runs reduzidas de 32 para 16).",
                                    "Verifique confusões/aliases em designs fracionários usando tabelas de resolução.",
                                    "Documente a decisão em um relatório curto."
                                  ],
                                  "verification": "O relatório inclui justificativa quantitativa e tabela de design selecionado.",
                                  "estimatedTime": "60-90 minutos",
                                  "materials": "Tabelas de designs experimentais (livros como Montgomery DOE), software DOE (Minitab/JMP ou Python: pyDOE).",
                                  "tips": "Para interações altas, prefira designs de resolução alta (IV ou V).",
                                  "learningObjective": "Aplicar critérios de seleção para designs DOE em simulações.",
                                  "commonMistakes": "Escolher design muito confuso sem verificar aliases principais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Configurar e planejar as rodadas de simulação",
                                  "subSteps": [
                                    "Gere a matriz de design (ex.: usando randomização).",
                                    "Defina replicatas por run para reduzir variância.",
                                    "Planeje sequência de execução (randomizada para evitar bias).",
                                    "Prepare script de simulação para automatizar runs.",
                                    "Teste com 1-2 runs para validar setup."
                                  ],
                                  "verification": "Matriz de design gerada com pelo menos 10 runs planejadas e script funcional.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": "Software de simulação (Python: simpy/numpy; Arena), gerador de designs (DOE software).",
                                  "tips": "Randomize sempre para minimizar efeitos de ordem.",
                                  "learningObjective": "Implementar o design selecionado de forma prática e robusta.",
                                  "commonMistakes": "Esquecer replicatas ou não randomizar runs."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e documentar a escolha do design",
                                  "subSteps": [
                                    "Simule power analysis ou sensitivity para confirmar precisão.",
                                    "Compare com alternativas (ex.: o que perderia com design mais simples?).",
                                    "Documente plano completo: design, runs, software.",
                                    "Revise com checklist de equilíbrio custo-precisão.",
                                    "Prepare para próxima fase: execução."
                                  ],
                                  "verification": "Documento final aprovado com validação quantitativa.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": "Checklist de validação, software estatístico (R: algdesign).",
                                  "tips": "Use gráficos de power curve para visualização.",
                                  "learningObjective": "Garantir robustez da escolha através de validação.",
                                  "commonMistakes": "Pular validação assumindo que o design é ótimo."
                                }
                              ],
                              "practicalExample": "Em uma simulação de sistema de filas M/M/1, fatores: taxa chegada (1-5/min), serviço (2-6/min). Objetivo: efeitos principais + interações. Custo: max 32 runs (5min cada). Escolha: fatorial fracionário 2^{4-1}=8 runs + 2 centro, equilibrando 40min total com precisão >85%.",
                              "finalVerifications": [
                                "Design selecionado reduz runs em pelo menos 50% vs. completo sem perda crítica de precisão.",
                                "Justificativa inclui cálculos de custo e power analysis.",
                                "Matriz de design randomizada e pronta para execução.",
                                "Aliases/confusões documentados e aceitáveis.",
                                "Plano alinha com objetivos e restrições do problema.",
                                "Teste piloto confirma viabilidade computacional."
                              ],
                              "assessmentCriteria": [
                                "Precisão da identificação de fatores e níveis (completude e relevância).",
                                "Qualidade quantitativa da análise custo-precisão (cálculos corretos).",
                                "Justificativa lógica e estatística para o design escolhido.",
                                "Robustez da configuração (randomização, replicatas).",
                                "Documentação clara e acionável do plano.",
                                "Validação final demonstra equilíbrio adequado."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Análise de variância (ANOVA) e power analysis.",
                                "Programação: Automatização de simulações em Python/R.",
                                "Otimização: Integração com métodos de superfície de resposta para tuning.",
                                "Engenharia de Software: Design de experimentos em testes de performance."
                              ],
                              "realWorldApplication": "Na indústria farmacêutica, otimizar formulações de drogas via simulações DoE fracionárias, reduzindo testes físicos caros de milhares para centenas, acelerando aprovação FDA."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.1.3",
                            "name": "Determinar número de replicatas e runs",
                            "description": "Calcular o número de replicatas independentes e runs totais com base em análises de poder estatístico e variância preliminar para garantir intervalos de confiança confiáveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Replicatas, Runs e Estatística",
                                  "subSteps": [
                                    "Definir 'replicata' como uma execução independente da simulação com sementes aleatórias diferentes para capturar variabilidade inerente.",
                                    "Diferenciar 'run' (execução única) de 'replicata' (conjunto de runs independentes).",
                                    "Explicar poder estatístico (probabilidade de detectar efeito real) e sua relação com tamanho da amostra.",
                                    "Descrever variância preliminar como medida de dispersão dos resultados de simulações piloto.",
                                    "Entender intervalos de confiança (IC) e como o número de replicatas afeta sua largura."
                                  ],
                                  "verification": "Resumir definições em um diagrama ou tabela comparativa sem erros conceituais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação de simulação (ex: livros como 'Simulation Modeling and Analysis' de Law)",
                                    "Planilha ou caderno para anotações"
                                  ],
                                  "tips": "Use analogias como 'replicatas são como repetir um experimento de laboratório várias vezes'.",
                                  "learningObjective": "Dominar terminologia e relações entre replicatas, runs, poder e IC.",
                                  "commonMistakes": [
                                    "Confundir replicata com run simples",
                                    "Ignorar que variância preliminar é essencial para cálculos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar Simulações Piloto para Estimar Variância Preliminar",
                                  "subSteps": [
                                    "Configurar uma simulação piloto simples com 10-20 runs preliminares.",
                                    "Executar as runs coletando métricas chave (ex: tempo médio de espera).",
                                    "Calcular a variância amostral (s²) usando fórmula: s² = Σ(xi - x̄)² / (n-1).",
                                    "Determinar o desvio padrão (s) como raiz quadrada da variância.",
                                    "Visualizar dados com histograma ou boxplot para validar normalidade aproximada."
                                  ],
                                  "verification": "Produzir relatório com variância calculada e gráfico, confirmando valores consistentes.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software de simulação (Python com SimPy ou R)",
                                    "Planilha Excel/Google Sheets para cálculos"
                                  ],
                                  "tips": "Mantenha sementes aleatórias diferentes em cada run para capturar variabilidade real.",
                                  "learningObjective": "Coletar e analisar dados preliminares para estimativa precisa de variância.",
                                  "commonMistakes": [
                                    "Usar poucos runs piloto (menos de 10)",
                                    "Confundir variância populacional com amostral"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar Análise de Poder Estatístico",
                                  "subSteps": [
                                    "Definir parâmetros: nível de significância (α=0.05), poder desejado (0.80), tamanho do efeito esperado.",
                                    "Usar fórmula ou ferramenta para tamanho da amostra: n = (Z_{1-α/2} + Z_{1-β})² * (σ² / δ²), onde δ é margem de erro.",
                                    "Aplicar para IC: largura desejada L = 2 * Z_{1-α/2} * σ / √n, resolvendo para n.",
                                    "Ferramentas: pwr package no R ou G*Power software.",
                                    "Ajustar para replicatas: número de replicatas r = n / runs por replicata."
                                  ],
                                  "verification": "Gerar tabela com n calculado para diferentes poderes e margens, validada por fórmula manual.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "R com pacote pwr ou Python com statsmodels",
                                    "Calculadora científica ou software G*Power"
                                  ],
                                  "tips": "Comece com suposições conservadoras para σ se dados piloto forem incertos.",
                                  "learningObjective": "Aplicar análise de poder para dimensionar experimentos de simulação.",
                                  "commonMistakes": [
                                    "Esquecer de inverter fórmula para resolver n",
                                    "Usar distribuição t em vez de normal para amostras grandes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular Número Total de Replicatas e Runs e Validar",
                                  "subSteps": [
                                    "Combinar resultados: replicatas r = n calculado, runs totais = r * runs por replicata.",
                                    "Simular com números calculados e verificar largura do IC real.",
                                    "Ajustar iterativamente se IC exceder margem desejada (aumentar r).",
                                    "Documentar plano final: r replicatas, runs totais, semente scheme.",
                                    "Testar sensibilidade variando σ em ±20%."
                                  ],
                                  "verification": "Executar simulação final com plano e confirmar IC dentro da margem em pelo menos 95% dos casos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código de simulação completo",
                                    "Ferramentas de plotagem (matplotlib ou ggplot)"
                                  ],
                                  "tips": "Automatize cálculos em script para reutilização.",
                                  "learningObjective": "Finalizar plano de simulação robusto e validado.",
                                  "commonMistakes": [
                                    "Não validar com simulação real",
                                    "Subestimar runs totais levando a IC largos"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar e Planejar Execução Completa",
                                  "subSteps": [
                                    "Criar relatório com todos cálculos, premissas e justificativas.",
                                    "Definir protocolo de execução: paralelização se possível.",
                                    "Preparar para fase de coleta de dados em simulação full-scale.",
                                    "Discutir trade-offs: custo computacional vs precisão.",
                                    "Planejar análise posterior (ex: ANOVA para múltiplas configurações)."
                                  ],
                                  "verification": "Relatório aprovado por checklist de completude.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Template de relatório LaTeX ou Markdown"
                                  ],
                                  "tips": "Inclua código fonte no relatório para reprodutibilidade.",
                                  "learningObjective": "Integrar planejamento em workflow de simulação completo.",
                                  "commonMistakes": [
                                    "Omitir sensibilidade analysis",
                                    "Ignorar custo computacional"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila M/M/1 (supermercado), com λ=5 clientes/hora, μ=6, pilot de 20 runs dá tempo médio de espera 12min, s=4min. Para IC 95% com largura ≤2min, análise de poder dá n≈385, então 10 replicatas de 38.5 runs cada (arredondar para 39), total 390 runs.",
                              "finalVerifications": [
                                "Variância preliminar calculada corretamente de pilots.",
                                "Análise de poder usa α=0.05 e poder≥0.80.",
                                "IC simulado tem largura média ≤ margem desejada.",
                                "Número de replicatas ≥ mínimo teórico.",
                                "Plano documentado com trade-offs computacionais.",
                                "Teste de sensibilidade confirma robustez."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos cálculos de variância e n (erro <5%).",
                                "Uso correto de fórmulas de poder e IC.",
                                "Validação prática via simulação.",
                                "Relatório claro e reprodutível.",
                                "Consideração de trade-offs custo-benefício.",
                                "Aplicação correta de conceitos em contexto de simulação discreta."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Análise de poder e inferência.",
                                "Programação Computacional: Implementação de simulações em Python/R.",
                                "Design de Experimentos: Planejamento DOE.",
                                "Matemática Aplicada: Probabilidade e distribuições.",
                                "Gestão de Projetos: Orçamentação computacional."
                              ],
                              "realWorldApplication": "Em engenharia de manufatura, otimizar linhas de produção via simulação Monte Carlo, garantindo que decisões baseadas em tempos médios sejam confiáveis com IC estreitos, evitando investimentos errados por variabilidade não capturada."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.6.2",
                        "name": "Execução de Experimentos de Simulação",
                        "description": "Realização prática das rodadas de simulação planejadas, incluindo configuração do software, geração de sementes aleatórias e coleta sistemática de dados de saída.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.6.2.1",
                            "name": "Configurar e executar rodadas de simulação",
                            "description": "Implementar o plano experimental em linguagens ou softwares de simulação como Arena ou Simio, garantindo sincronização de sementes para replicatas independentes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente de simulação",
                                  "subSteps": [
                                    "Instalar ou abrir o software de simulação (ex: Arena ou Simio).",
                                    "Verificar requisitos de sistema e atualizações disponíveis.",
                                    "Criar um novo projeto ou arquivo para o experimento.",
                                    "Configurar unidades de medida e preferências iniciais conforme o plano experimental.",
                                    "Testar uma simulação básica para validar o ambiente."
                                  ],
                                  "verification": "Ambiente pronto quando uma simulação de teste simples executa sem erros e gera resultados básicos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software Arena ou Simio instalado",
                                    "Plano experimental documentado",
                                    "Computador com specs recomendadas"
                                  ],
                                  "tips": "Salve o projeto imediatamente após configuração para evitar perda de dados.",
                                  "learningObjective": "Configurar corretamente o ambiente de simulação para suportar experimentos complexos.",
                                  "commonMistakes": [
                                    "Ignorar atualizações do software levando a bugs",
                                    "Usar unidades erradas afetando resultados",
                                    "Não testar simulação básica antes de prosseguir"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir ou importar o modelo de simulação",
                                  "subSteps": [
                                    "Analisar o plano experimental para identificar entidades, recursos e lógica de processos.",
                                    "Construir módulos básicos (ex: chegada, processamento, saída) no software.",
                                    "Definir distribuições probabilísticas e parâmetros iniciais conforme o plano.",
                                    "Conectar módulos logicamente e adicionar controles de tempo.",
                                    "Executar uma única rodada de teste para validar o modelo."
                                  ],
                                  "verification": "Modelo validado quando uma rodada única reproduz comportamento esperado sem falhas lógicas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Plano experimental detalhado",
                                    "Diagramas de fluxo do sistema",
                                    "Biblioteca de módulos do software"
                                  ],
                                  "tips": "Use diagramas do plano como blueprint para evitar discrepâncias no modelo.",
                                  "learningObjective": "Implementar fielmente o plano experimental em um modelo de simulação funcional.",
                                  "commonMistakes": [
                                    "Distribuições erradas nos arrivals/processos",
                                    "Falhas em conexões lógicas causando deadlocks",
                                    "Ignorar warm-up period inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar rodadas de simulação e sementes aleatórias",
                                  "subSteps": [
                                    "Definir número de replicatas (ex: 10-30) baseado no plano para independência estatística.",
                                    "Configurar gerador de números aleatórios com sementes sincronizadas (ex: seed inicial diferente por replicata).",
                                    "Ajustar run length, warm-up time e outros parâmetros de replicação.",
                                    "Salvar configuração de replicatas em um cenário ou módulo dedicado.",
                                    "Testar configuração com 2-3 replicatas curtas para verificar variabilidade."
                                  ],
                                  "verification": "Configuração correta quando replicatas geram resultados independentes com sementes rastreáveis nos logs.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação do software sobre random streams",
                                    "Plano experimental com specs de replicatas",
                                    "Ferramentas de log do software"
                                  ],
                                  "tips": "Use seeds incrementais (ex: 1,2,3...) para facilitar replicação e debugging.",
                                  "learningObjective": "Garantir replicatas independentes através de sincronização de sementes para análise estatística confiável.",
                                  "commonMistakes": [
                                    "Reutilizar mesma seed causando resultados correlacionados",
                                    "Número insuficiente de replicatas para precisão",
                                    "Não documentar seeds usadas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar rodadas e coletar dados iniciais",
                                  "subSteps": [
                                    "Iniciar execução de todas as replicatas em batch ou sequencial.",
                                    "Monitorar progresso em tempo real, pausando se houver erros.",
                                    "Verificar logs para anomalias durante a execução.",
                                    "Coletar saídas automáticas (ex: relatórios de throughput, queue lengths).",
                                    "Exportar dados brutos para análise posterior."
                                  ],
                                  "verification": "Execução completa quando todas replicatas terminam com dados coletados e sem erros críticos nos logs.",
                                  "estimatedTime": "60 minutos (dependendo da complexidade)",
                                  "materials": [
                                    "Configuração salva do modelo",
                                    "Espaço em disco para outputs",
                                    "Planilha ou ferramenta para dados"
                                  ],
                                  "tips": "Execute em modo batch para eficiência e configure notificações de fim.",
                                  "learningObjective": "Executar múltiplas rodadas de simulação de forma eficiente e registrar dados para verificação.",
                                  "commonMistakes": [
                                    "Não monitorar levando a execuções falhas silenciosas",
                                    "Sobrecarga de sistema por runs longos sem pausas",
                                    "Perda de dados por não exportar imediatamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado no Arena: configure 20 replicatas de 8 horas cada, com seeds 1001 a 1020 para arrivals de clientes (exponencial média 5 min) e tempos de serviço (normal 3±1 min), coletando médias de tempo na fila por replicata.",
                              "finalVerifications": [
                                "Todas replicatas executadas sem erros e com logs limpos.",
                                "Sementes usadas documentadas e diferentes entre replicatas.",
                                "Dados coletados incluem métricas chave do plano (ex: throughput, utilization).",
                                "Resultados mostram variabilidade esperada (desvio padrão razoável).",
                                "Tempo total de execução alinhado com estimativas.",
                                "Arquivos de output salvos e acessíveis para análise."
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração de sementes (independência verificada).",
                                "Fidelidade do modelo ao plano experimental (teste de validação passado).",
                                "Eficiência na execução (sem desperdício de tempo ou recursos).",
                                "Qualidade dos dados coletados (completude e formatação).",
                                "Documentação clara de configurações e resultados.",
                                "Capacidade de troubleshooting erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Análise de variância entre replicatas.",
                                "Programação: Scripts para automação de batches em simulação.",
                                "Gestão de Projetos: Planejamento de experimentos e controle de runs.",
                                "Engenharia de Produção: Otimização de sistemas discretos.",
                                "Ciência de Dados: Coleta e pré-processamento de dados simulados."
                              ],
                              "realWorldApplication": "Em logística de armazéns, configurar rodadas de simulação no Simio para testar layouts de picking com replicatas independentes, avaliando impacto de variações sazonais em throughput e permitindo decisões baseadas em dados confiáveis para redução de custos operacionais."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.2.2",
                            "name": "Coletar e armazenar dados de saída",
                            "description": "Registrar métricas de desempenho de forma estruturada durante a execução, utilizando arquivos de saída ou bancos de dados para facilitar análises posteriores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir métricas de desempenho a serem coletadas",
                                  "subSteps": [
                                    "Identifique as variáveis chave da simulação (ex: tempo de espera, throughput, utilização de recursos).",
                                    "Especifique o formato dos dados (ex: numérico, timestamp, categórico).",
                                    "Determine a frequência de coleta (ex: a cada iteração, evento ou intervalo fixo).",
                                    "Crie um esquema de dados com colunas e tipos esperados.",
                                    "Documente o propósito de cada métrica para análises futuras."
                                  ],
                                  "verification": "Verifique se há um esquema documentado com todas as métricas listadas e suas descrições.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e caneta ou editor de texto (ex: Notion, Markdown); documentação da simulação.",
                                  "tips": "Priorize métricas alinhadas aos objetivos do experimento para evitar sobrecarga de dados.",
                                  "learningObjective": "Compreender quais dados são relevantes para análise posterior em simulações discretas.",
                                  "commonMistakes": "Coletar dados irrelevantes ou excessivos, levando a arquivos desnecessariamente grandes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escolher e configurar o método de armazenamento",
                                  "subSteps": [
                                    "Avalie opções: arquivos CSV/JSON para simplicidade ou SQLite/PostgreSQL para queries complexas.",
                                    "Instale bibliotecas necessárias (ex: pandas para CSV, sqlite3 para banco local).",
                                    "Crie a estrutura de armazenamento: abra arquivo ou inicialize tabela com esquema definido.",
                                    "Configure headers ou colunas com nomes padronizados e tipos corretos.",
                                    "Teste a criação inicial (ex: insira uma linha de teste e leia de volta)."
                                  ],
                                  "verification": "Confirme que o arquivo ou banco foi criado e uma entrada de teste pode ser lida corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python com pandas e sqlite3; ambiente de desenvolvimento (Jupyter Notebook ou IDE).",
                                  "tips": "Use CSV para protótipos rápidos; migre para DB se houver >10k registros esperados.",
                                  "learningObjective": "Selecionar e preparar ferramentas adequadas para armazenamento estruturado de dados de simulação.",
                                  "commonMistakes": "Ignorar tipos de dados, causando erros de parsing posterior."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar coleta e registro durante a execução da simulação",
                                  "subSteps": [
                                    "Integre pontos de coleta no código da simulação (ex: após cada evento discreto).",
                                    "Colete métricas em um dicionário ou DataFrame temporário.",
                                    "Registre periodicamente no armazenamento (ex: flush a cada 100 iterações para evitar perda).",
                                    "Adicione timestamps e IDs de replicação para rastreabilidade.",
                                    "Implemente tratamento de erros para falhas de escrita."
                                  ],
                                  "verification": "Execute uma simulação curta e confirme que dados são escritos em tempo real sem crashes.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código fonte da simulação; bibliotecas pandas ou sqlite3.",
                                  "tips": "Use logging para monitorar a coleta; evite writes síncronos em loops críticos para performance.",
                                  "learningObjective": "Integrar coleta de dados de forma eficiente e robusta no loop de simulação.",
                                  "commonMistakes": "Esquecer de flush dados, resultando em perda ao final da execução."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar integridade e finalizar o armazenamento",
                                  "subSteps": [
                                    "Execute a simulação completa e verifique contagem de registros esperada.",
                                    "Realize queries básicas: soma, média, checagem de valores ausentes.",
                                    "Gere um resumo estatístico inicial e salve como metadado.",
                                    "Compacte ou backup o arquivo/banco para análises futuras.",
                                    "Documente o processo de coleta no README do experimento."
                                  ],
                                  "verification": "Os dados carregam corretamente e estatísticas básicas batem com expectativas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Ferramentas de query (pandas.read_csv ou sqlite browser); simulador executado.",
                                  "tips": "Sempre valide com uma amostra pequena antes da run full.",
                                  "learningObjective": "Garantir qualidade e usabilidade dos dados coletados para análises subsequentes.",
                                  "commonMistakes": "Não tratar valores NaN ou outliers durante validação."
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila M/M/1 (supermercado), colete tempo de espera de 1000 clientes a cada chegada, armazene em CSV com colunas: cliente_id, chegada_time, servico_time, espera_time. Use pandas para append e salve ao final, permitindo plotar histograma de esperas.",
                              "finalVerifications": [
                                "Todos os registros esperados estão presentes sem duplicatas.",
                                "Tipos de dados são consistentes (ex: floats para tempos).",
                                "Não há valores missing ou inválidos (ex: negativos).",
                                "Timestamps e IDs são sequenciais e únicos.",
                                "Arquivo/DB pode ser lido e queryado sem erros.",
                                "Resumo estatístico (média, desv pad) é gerado corretamente."
                              ],
                              "assessmentCriteria": [
                                "Esquema de dados cobre todas métricas relevantes (completude).",
                                "Coleta é eficiente, sem impactar performance da simulação (>90% speedup mantido).",
                                "Dados armazenados são íntegros e reproduzíveis em múltiplas runs.",
                                "Documentação clara do processo e esquema.",
                                "Tratamento robusto de erros e edge cases.",
                                "Validação final demonstra qualidade dos dados."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Manipulação de arquivos e estruturas de dados (pandas, SQL).",
                                "Estatística: Preparação de datasets para análise descritiva/inferencial.",
                                "Ciência de Dados: ETL (Extract, Transform, Load) em pipelines de simulação.",
                                "Gestão de Projetos: Documentação e versionamento de dados experimentais."
                              ],
                              "realWorldApplication": "Em simulações de redes de telecomunicações, coletar latência e perda de pacotes em logs para otimizar roteadores; ou em manufatura, registrar tempos de ciclo em fábricas para lean manufacturing."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.2.3",
                            "name": "Monitorar a execução para detecção de anomalias",
                            "description": "Verificar condições de terminais, regimes transitórios e possíveis falhas computacionais durante as rodadas para assegurar a validade dos dados coletados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar Ferramentas e Parâmetros de Monitoramento",
                                  "subSteps": [
                                    "Identificar métricas chave como uso de CPU, memória, condições de terminais e regimes transitórios baseadas na descrição do experimento.",
                                    "Definir thresholds para anomalias (ex: CPU > 90%, memória vazamento > 10%) usando dados históricos ou benchmarks.",
                                    "Configurar ferramentas de logging e alertas em tempo real no software de simulação.",
                                    "Estabelecer baseline de execução normal com uma rodada de teste curta.",
                                    "Verificar integração das ferramentas com o ambiente de simulação."
                                  ],
                                  "verification": "Checklist assinada confirmando thresholds definidos, logs ativos e baseline estável sem alertas falsos.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": "Software de simulação (ex: SimPy ou Arena), ferramentas de monitoramento (ex: Prometheus, Grafana, logs do sistema), documentação do experimento.",
                                  "tips": "Use thresholds conservadores para evitar alertas excessivos no início.",
                                  "learningObjective": "Configurar monitoramento proativo para capturar anomalias precocemente.",
                                  "commonMistakes": "Definir thresholds muito rígidos levando a falsos positivos ou ignorar regimes transitórios."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar Rodadas e Monitorar Condições em Tempo Real",
                                  "subSteps": [
                                    "Iniciar a primeira rodada de simulação com monitoramento ativo.",
                                    "Observar continuamente condições de terminais (ex: estados de chegada/saída) via dashboards.",
                                    "Monitorar regimes transitórios para estabilização (ex: primeiros 10% da simulação).",
                                    "Verificar métricas computacionais como tempo de processamento e overflows.",
                                    "Registrar variações normais vs. suspeitas em log manual ou automático."
                                  ],
                                  "verification": "Dashboards mostram monitoramento contínuo sem interrupções e logs iniciais salvos.",
                                  "estimatedTime": "45-60 minutos por rodada",
                                  "materials": "Ambiente de simulação rodando, dashboards de monitoramento em tela dividida, timer para regimes transitórios.",
                                  "tips": "Mantenha uma tela dedicada para gráficos em tempo real para detecção visual rápida.",
                                  "learningObjective": "Desenvolver vigilância ativa durante execução para identificar desvios imediatos.",
                                  "commonMistakes": "Focar apenas em métricas finais, ignorando flutuações transitórias."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detectar, Classificar e Documentar Anomalias",
                                  "subSteps": [
                                    "Analisar alertas em tempo real e pausar simulação se threshold violado.",
                                    "Classificar anomalia (ex: falha terminal, transitória, computacional) com evidências de logs.",
                                    "Capturar screenshots ou dumps de estado para documentação.",
                                    "Comparar com baseline para confirmar se é anomalia verdadeira.",
                                    "Atualizar log com timestamp, tipo e impacto potencial nos dados."
                                  ],
                                  "verification": "Relatório de anomalias criado com pelo menos 80% classificadas e documentadas.",
                                  "estimatedTime": "15-30 minutos por anomalia detectada",
                                  "materials": "Logs e alertas gerados, editor de texto para relatório, ferramentas de debug (ex: gdb para C++).",
                                  "tips": "Priorize anomalias de alto impacto como falhas computacionais sobre variações menores.",
                                  "learningObjective": "Classificar anomalias com precisão para decisões informadas.",
                                  "commonMistakes": "Confundir variações estatísticas normais com anomalias reais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Correções, Validar e Finalizar Execução",
                                  "subSteps": [
                                    "Implementar correção (ex: reiniciar terminal, ajustar parâmetros, corrigir código).",
                                    "Reiniciar rodada afetada e monitorar por recorrência.",
                                    "Validar dados coletados pós-correção contra critérios de validade.",
                                    "Compilar relatório final de execução com anomalias resolvidas.",
                                    "Arquivar logs para auditoria futura."
                                  ],
                                  "verification": "Dados finais validados sem anomalias pendentes e relatório completo aprovado.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": "Código fonte editável, ferramentas de validação de dados, template de relatório.",
                                  "tips": "Teste correções em escala reduzida antes de rodadas completas.",
                                  "learningObjective": "Garantir integridade de dados através de correções iterativas.",
                                  "commonMistakes": "Prosseguir com dados inválidos sem revalidação completa."
                                }
                              ],
                              "practicalExample": "Em uma simulação de sistema de filas de supermercado usando SimPy, durante a execução, o uso de memória sobe para 95% devido a um loop infinito em eventos de chegada; o monitoramento detecta via alerta, pausa a simulação, corrige o código limitando eventos, reinicia e valida que os tempos de espera médios estabilizam em 5 minutos sem vazamentos.",
                              "finalVerifications": [
                                "Todos logs de execução revisados e anomalias resolvidas.",
                                "Dados coletados atendem critérios de validade (ex: convergência estatística).",
                                "Baseline e execuções finais comparadas sem desvios significativos.",
                                "Relatório de monitoramento completo com timestamps.",
                                "Nenhuma falha computacional não documentada.",
                                "Condições de terminais e regimes transitórios estabilizados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção de anomalias (>90% taxa de acerto).",
                                "Tempo de resposta a alertas (<5 minutos).",
                                "Completude da documentação de logs e relatórios.",
                                "Eficácia das correções (zero recorrências).",
                                "Validação final de dados sem artefatos.",
                                "Uso eficiente de recursos de monitoramento."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Análise de desvios e testes de normalidade em dados simulados.",
                                "Programação: Técnicas de debugging e profiling de performance.",
                                "Engenharia de Software: Práticas de logging e monitoramento em produção.",
                                "Gestão de Projetos: Controle de qualidade em experimentos iterativos."
                              ],
                              "realWorldApplication": "Em centros de dados e simulações industriais, como modelagem de tráfego aéreo, onde monitoramento detecta sobrecargas em servidores, previne falhas em tempo real e assegura precisão em previsões operacionais, evitando perdas financeiras por downtimes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.6.3",
                        "name": "Análise de Resultados de Simulação",
                        "description": "Processamento estatístico dos dados obtidos, incluindo estimação de parâmetros, intervalos de confiança e testes de hipóteses para interpretar o comportamento do modelo simulado.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.6.3.1",
                            "name": "Realizar análises estatísticas descritivas",
                            "description": "Calcular médias, desvios padrão e histogramas para cada combinação de fatores, identificando distribuições de saída das simulações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e organizar os dados das simulações",
                                  "subSteps": [
                                    "Coletar todos os resultados das réplicas de simulação para cada combinação de fatores.",
                                    "Identificar e agrupar os dados por níveis dos fatores (ex.: fator A baixo/alto, fator B baixo/alto).",
                                    "Verificar a integridade dos dados: remover outliers inválidos ou valores ausentes.",
                                    "Estruturar os dados em uma tabela ou DataFrame com colunas para fatores, réplicas e saídas.",
                                    "Salvar o conjunto de dados preparado em formato acessível (CSV ou DataFrame)."
                                  ],
                                  "verification": "Conferir se cada combinação de fatores possui o número correto de réplicas e sem dados faltantes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Planilha Excel, Python (pandas) ou R (data.frame)",
                                  "tips": "Use funções de groupby no pandas para agilizar o agrupamento.",
                                  "learningObjective": "Dominar a organização de dados experimentais para análise estatística.",
                                  "commonMistakes": "Ignorar valores ausentes ou agrupar incorretamente fatores."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular médias e desvios padrão para cada combinação",
                                  "subSteps": [
                                    "Selecionar a variável de saída relevante (ex.: tempo de ciclo).",
                                    "Calcular a média aritmética para cada grupo de réplicas usando funções built-in.",
                                    "Calcular o desvio padrão (amostral) para medir dispersão em cada grupo.",
                                    "Armazenar os resultados em uma tabela resumida com fatores, média e desvio padrão.",
                                    "Verificar cálculos manualmente em uma amostra pequena para validação."
                                  ],
                                  "verification": "Comparar resultados com cálculo manual em pelo menos uma combinação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Python (pandas, numpy) ou R (mean(), sd())",
                                  "tips": "Use ddply no R ou groupby.agg no pandas para automação.",
                                  "learningObjective": "Aplicar medidas de tendência central e dispersão em dados simulados.",
                                  "commonMistakes": "Confundir desvio padrão populacional com amostral ou usar mediana em vez de média."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar histogramas para visualizar distribuições",
                                  "subSteps": [
                                    "Para cada combinação de fatores, selecionar os dados de saída das réplicas.",
                                    "Definir número de bins adequado (ex.: Sturges' rule ou sqrt(n)).",
                                    "Plotar histogramas normalizados para cada grupo usando software de visualização.",
                                    "Adicionar rótulos, títulos e legendas identificando os fatores.",
                                    "Salvar os gráficos em arquivo para relatório."
                                  ],
                                  "verification": "Visualmente inspecionar se os histogramas mostram a distribuição corretamente sem sobreposição.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python (matplotlib, seaborn) ou R (ggplot2, hist())",
                                  "tips": "Experimente diferentes bins para melhor representação da forma da distribuição.",
                                  "learningObjective": "Criar visualizações estatísticas para inspeção de distribuições empíricas.",
                                  "commonMistakes": "Escolher poucos bins levando a visualizações distorcidas ou escalas inadequadas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar e descrever as distribuições de saída",
                                  "subSteps": [
                                    "Analisar a forma dos histogramas (simetria, caudas, multimodalidade).",
                                    "Comparar visualmente com distribuições conhecidas (normal, exponencial, etc.).",
                                    "Calcular estatísticas adicionais se necessário (assimetria, curtose).",
                                    "Documentar observações para cada combinação em um relatório.",
                                    "Discutir implicações das distribuições para o modelo de simulação."
                                  ],
                                  "verification": "Redigir um parágrafo resumindo a distribuição dominante por combinação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software estatístico (Python scipy.stats ou R moments)",
                                  "tips": "Use Q-Q plots complementares aos histogramas para confirmação.",
                                  "learningObjective": "Interpretar distribuições empíricas de simulações discretas.",
                                  "commonMistakes": "Forçar identificação de distribuição sem evidência visual clara."
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila M/M/1 com taxa de chegada λ=5 e serviço μ=6 ou 7, execute 100 réplicas para cada combinação. Calcule média e desvio do tempo no sistema, gere histogramas e identifique distribuição exponencial aproximada.",
                              "finalVerifications": [
                                "Tabela com médias e desvios padrão corretos para todas combinações de fatores.",
                                "Histogramas gerados e salvos para cada combinação, com bins adequados.",
                                "Descrição textual das distribuições identificadas por combinação.",
                                "Verificação numérica: médias batem com somatório/réplicas.",
                                "Gráficos legíveis com títulos indicando fatores.",
                                "Relatório resumido sem erros de agrupamento."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos cálculos estatísticos (erro <1%).",
                                "Qualidade visual dos histogramas (clareza, legibilidade).",
                                "Correção na identificação de distribuições baseadas em evidências.",
                                "Completude: todas combinações analisadas.",
                                "Organização e documentação dos resultados.",
                                "Validação cruzada com métodos manuais."
                              ],
                              "crossCurricularConnections": [
                                "Programação Computacional: Uso de bibliotecas como pandas e matplotlib.",
                                "Probabilidade: Reconhecimento de distribuições teóricas em dados empíricos.",
                                "Engenharia Industrial: Análise para otimização de sistemas de produção.",
                                "Ciência de Dados: Técnicas de exploração de dados (EDA)."
                              ],
                              "realWorldApplication": "Na indústria manufatureira, analisar simulações de linhas de produção para diferentes configurações de máquinas, calculando tempos médios e variabilidades para decidir investimentos em equipamentos, reduzindo custos operacionais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.3.2",
                            "name": "Construir intervalos de confiança",
                            "description": "Aplicar métodos como o de replicatas independentes ou batch means para obter intervalos de confiança de 95% nas medidas de desempenho.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os métodos de intervalos de confiança em simulações",
                                  "subSteps": [
                                    "Estude os conceitos de replicatas independentes e batch means.",
                                    "Identifique quando usar cada método: replicatas para sistemas com estado inicial transitório, batch means para steady-state.",
                                    "Revise a fórmula do intervalo de confiança: média ± t * (desvio padrão / sqrt(n)).",
                                    "Entenda o nível de confiança de 95% e o papel do teste t de Student.",
                                    "Analise exemplos teóricos de medidas de desempenho como tempo médio no sistema."
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças entre replicatas e batch means, com exemplos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de simulação (ex: Law & Kelton), notas de aula, calculadora.",
                                  "tips": "Comece com replicatas independentes se o sistema tiver warmup period claro.",
                                  "learningObjective": "Diferenciar e selecionar o método apropriado para construção de IC em simulações.",
                                  "commonMistakes": "Confundir replicatas independentes com runs correlacionados ou ignorar o período de warmup."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar e executar as simulações para coleta de dados",
                                  "subSteps": [
                                    "Defina parâmetros da simulação: número de replicatas (ex: 10-30) ou tamanho de batch.",
                                    "Implemente o warmup period para eliminar transient effects.",
                                    "Execute as simulações independentes ou divida a saída em batches não sobrepostos.",
                                    "Colete medidas de desempenho (ex: média de throughput ou tempo de espera).",
                                    "Salve os dados em formato tabular para análise."
                                  ],
                                  "verification": "Verifique se os dados coletados têm o número correto de replicatas/batches e sem valores ausentes.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software de simulação (Arena, Python com SimPy, R), computador.",
                                  "tips": "Use sementes aleatórias diferentes para cada replicata para independência.",
                                  "learningObjective": "Gerar dados de simulação adequados para análise estatística robusta.",
                                  "commonMistakes": "Usar a mesma semente em todas replicatas ou batches muito pequenos levando a variância alta."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular estatísticas descritivas dos dados",
                                  "subSteps": [
                                    "Calcule a média amostral das replicatas ou batch means.",
                                    "Compute o desvio padrão amostral (s) das médias.",
                                    "Determine os graus de liberdade (n-1, onde n é número de replicatas/batches).",
                                    "Encontre o valor crítico t para 95% de confiança usando tabela ou função.",
                                    "Calcule o erro padrão: s / sqrt(n)."
                                  ],
                                  "verification": "Compare cálculos manuais com output de software (ex: Python scipy.stats.t.interval).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha Excel, Python (numpy, scipy), tabela de valores t.",
                                  "tips": "Use funções built-in como np.mean() e np.std() para precisão.",
                                  "learningObjective": "Obter estatísticas precisas necessárias para o IC.",
                                  "commonMistakes": "Usar desvio padrão populacional em vez de amostral ou erro no valor t."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir, interpretar e validar o intervalo de confiança",
                                  "subSteps": [
                                    "Aplique a fórmula: IC = média ± t * (s / sqrt(n)).",
                                    "Interprete o IC: com 95% de confiança, a verdadeira média está nesse intervalo.",
                                    "Verifique se o comprimento do IC é aceitável (ex: <10% da média).",
                                    "Aumente n se necessário para reduzir o IC.",
                                    "Documente o processo e conclusões."
                                  ],
                                  "verification": "O IC contém a média conhecida de um benchmark ou simulação longa.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software estatístico, relatório template.",
                                  "tips": "Para batch means, ajuste pela autocorrelação se batches forem sobrepostos.",
                                  "learningObjective": "Construir e interpretar IC de 95% para decisões baseadas em simulação.",
                                  "commonMistakes": "Interpretar 95% como probabilidade da média estar no IC pós-cálculo."
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila M/M/1 com λ=4 e μ=5, execute 20 replicatas independentes de 1000 chegadas cada (warmup 200), colete tempo médio na fila, calcule IC 95%: ex. [2.1, 2.9] minutos, indicando estimativa precisa.",
                              "finalVerifications": [
                                "IC de 95% calculado corretamente com método escolhido.",
                                "Dados mostram independência (teste de autocorrelação se aplicável).",
                                "Comprimento do IC é razoável para precisão desejada.",
                                "Interpretação correta: não probabilística pós-dados.",
                                "Relatório inclui todos cálculos e justificativas.",
                                "Validação contra simulação de referência longa."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática nos cálculos de média, s e t.",
                                "Seleção adequada de método (replicatas vs batch means).",
                                "Número suficiente de replicatas/batches para precisão.",
                                "Interpretação precisa e sem erros conceituais.",
                                "Documentação clara com gráficos de dados e IC.",
                                "Aplicação correta de warmup e independência."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Inferência paramétrica e testes de hipóteses.",
                                "Programação: Implementação em Python/R para simulações estocásticas.",
                                "Engenharia Industrial: Otimização de sistemas de filas e manufatura.",
                                "Ciência de Dados: Análise de variabilidade em big data simulados."
                              ],
                              "realWorldApplication": "Em logística, construir IC para tempo médio de entrega em simulações de supply chain, permitindo decisões confiáveis sobre investimentos em frota ou estoque."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.3.3",
                            "name": "Interpretar resultados via ANOVA ou regressão",
                            "description": "Executar análises de variância ou modelos de regressão para detectar efeitos principais, interações e respostas não lineares nos experimentos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e validar os dados experimentais",
                                  "subSteps": [
                                    "Coletar e organizar os dados de saída da simulação em formato tabular (fatores como variáveis independentes e métricas como dependentes).",
                                    "Verificar pressupostos de normalidade dos resíduos usando testes como Shapiro-Wilk ou gráficos QQ.",
                                    "Testar homogeneidade de variâncias com Levene ou Bartlett.",
                                    "Identificar e tratar outliers ou dados faltantes.",
                                    "Transformar variáveis se necessário para linearidade."
                                  ],
                                  "verification": "Relatório confirmando que todos os pressupostos foram atendidos ou ajustados, com gráficos e p-valores.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software R (pacotes: car, nortest) ou Python (scipy, statsmodels)",
                                    "Planilha de dados da simulação em CSV"
                                  ],
                                  "tips": "Sempre visualize os dados com boxplots por grupo para detectar problemas iniciais.",
                                  "learningObjective": "Garantir que os dados atendam aos requisitos para análises paramétricas como ANOVA e regressão.",
                                  "commonMistakes": [
                                    "Prosseguir sem testar normalidade",
                                    "Ignorar violações de homogeneidade",
                                    "Não documentar transformações"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar análise de variância (ANOVA)",
                                  "subSteps": [
                                    "Definir o modelo ANOVA com fatores principais e interações relevantes do experimento.",
                                    "Executar ANOVA univariada ou multifatorial usando funções como aov() em R ou anova_lm() em Python.",
                                    "Analisar a tabela ANOVA: identificar efeitos principais e interações significativos (p < 0,05).",
                                    "Realizar testes post-hoc como Tukey HSD para comparações múltiplas.",
                                    "Calcular tamanhos de efeito (eta-squared)."
                                  ],
                                  "verification": "Tabela ANOVA com p-valores e testes post-hoc interpretados corretamente.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "R (pacotes: stats, agricolae) ou Python (statsmodels)",
                                    "Script de código preparado"
                                  ],
                                  "tips": "Inclua interações de 2 vias primeiro; evite modelos muito complexos sem poder estatístico.",
                                  "learningObjective": "Detectar efeitos principais e interações nos resultados experimentais.",
                                  "commonMistakes": [
                                    "Esquecer interações",
                                    "Interpretar p-valores sem contexto",
                                    "Não ajustar para múltiplas comparações"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar modelos de regressão",
                                  "subSteps": [
                                    "Construir modelo de regressão linear simples ou múltipla com fatores contínuos ou categóricos.",
                                    "Incluir termos polinomiais ou splines para capturar não-linearidades.",
                                    "Verificar resíduos: normalidade, homocedasticidade e independência.",
                                    "Selecionar modelo via AIC/BIC ou stepwise.",
                                    "Interpretar coeficientes, R² e predições."
                                  ],
                                  "verification": "Modelo ajustado com resíduos válidos e predições plotadas contra dados observados.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "R (pacotes: lm, MASS) ou Python (sklearn, statsmodels)",
                                    "Dados preparados"
                                  ],
                                  "tips": "Use gráficos de resíduos vs. ajustados para detectar não-linearidades.",
                                  "learningObjective": "Modelar respostas não lineares e relações funcionais nos dados de simulação.",
                                  "commonMistakes": [
                                    "Sobreajuste com muitos termos",
                                    "Ignorar multicolinearidade",
                                    "Não validar o modelo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e integrar resultados",
                                  "subSteps": [
                                    "Comparar resultados de ANOVA e regressão para consistência.",
                                    "Identificar efeitos principais, interações e não-linearidades chave.",
                                    "Visualizar com gráficos de interação, superfícies de resposta ou plots residuais.",
                                    "Reportar conclusões com confiança intervals e implicações para o experimento.",
                                    "Recomendar próximos passos baseados nas descobertas."
                                  ],
                                  "verification": "Relatório final com interpretações claras, gráficos e recomendações.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Ferramentas de plotagem: ggplot2 (R) ou matplotlib/seaborn (Python)",
                                    "Templates de relatório"
                                  ],
                                  "tips": "Use superfícies de resposta para interações em regressão.",
                                  "learningObjective": "Sintetizar análises para insights acionáveis sobre o sistema simulado.",
                                  "commonMistakes": [
                                    "Focar só em significância estatística sem magnitude",
                                    "Não integrar ANOVA e regressão",
                                    "Conclusões sem visualizações"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de sistema de filas M/M/c, com fatores: número de servidores (1-5) e taxa de chegada (λ=2-10), analise o tempo médio de espera. Use ANOVA para detectar interação entre servidores e λ, e regressão quadrática para modelar o aumento não linear do tempo de espera com λ alto.",
                              "finalVerifications": [
                                "Identifica corretamente efeitos principais e interações na ANOVA.",
                                "Constrói e valida um modelo de regressão que captura não-linearidades.",
                                "Interpreta p-valores, coeficientes e R² de forma precisa.",
                                "Gera visualizações claras de resultados.",
                                "Recomenda ajustes no design experimental baseados na análise.",
                                "Verifica todos os pressupostos das análises."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção de significância (90%+ acurácia em testes simulados).",
                                "Qualidade dos modelos: R² > 0.8 e resíduos adequados.",
                                "Profundidade da interpretação: menciona magnitude de efeitos.",
                                "Uso correto de visualizações e testes post-hoc.",
                                "Relatório claro e estruturado com conclusões acionáveis.",
                                "Tratamento adequado de pressupostos e erros."
                              ],
                              "crossCurricularConnections": [
                                "Estatística Inferencial: testes de hipóteses e intervalos de confiança.",
                                "Programação Computacional: scripts em R/Python para automação.",
                                "Design de Experimentos: planejamento fatorial e poder estatístico.",
                                "Simulação e Modelagem: validação de modelos estocásticos.",
                                "Visualização de Dados: gráficos interativos para insights."
                              ],
                              "realWorldApplication": "Em logística, otimizar alocação de recursos em armazéns analisando interações entre turnos e volume de chegada via ANOVA/regressão em simulações, reduzindo tempos de espera em 20-30%."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.6.4",
                        "name": "Técnicas de Redução de Variância",
                        "description": "Métodos avançados para minimizar a variabilidade das estimativas em simulações, aumentando a precisão sem aumentar excessivamente o tempo computacional.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.6.4.1",
                            "name": "Aplicar números aleatórios comuns (CRN)",
                            "description": "Usar a mesma sequência de números aleatórios em todas as rodadas para correlacionar saídas e reduzir variância em comparações entre cenários.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Números Aleatórios Comuns (CRN)",
                                  "subSteps": [
                                    "Estude a definição de CRN: uso da mesma sequência de números pseudoaleatórios em múltiplas simulações para correlacionar saídas.",
                                    "Revise como a variância em simulações independentes afeta comparações entre cenários.",
                                    "Analise um exemplo simples: compare variância com e sem CRN em duas filas idênticas.",
                                    "Identifique benefícios: redução de variância em diferenças de médias entre cenários.",
                                    "Registre em um diagrama como CRN induz dependência positiva entre réplicas."
                                  ],
                                  "verification": "Crie um resumo de 200 palavras explicando CRN e seus benefícios, com um diagrama simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de simulação ou PDF sobre técnicas de redução de variância",
                                    "Papel e caneta para diagrama",
                                    "Acesso a simulador online como AnyLogic ou Python com NumPy"
                                  ],
                                  "tips": "Foquem em exemplos visuais; use gráficos de variância para ilustrar a redução.",
                                  "learningObjective": "Explicar o mecanismo de CRN e sua justificativa estatística.",
                                  "commonMistakes": [
                                    "Confundir CRN com sementes fixas independentes",
                                    "Ignorar a necessidade de cenários comparáveis",
                                    "Subestimar o impacto na dependência entre réplicas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar e Preparar Sequência Comum de Números Aleatórios",
                                  "subSteps": [
                                    "Escolha um gerador de números pseudoaleatórios (ex: Mersenne Twister em Python).",
                                    "Defina uma semente comum (seed) para todas as simulações (ex: seed=42).",
                                    "Gere uma sequência longa o suficiente para cobrir todas as réplicas e cenários (ex: 10.000 números).",
                                    "Salve a sequência em um arquivo ou array compartilhado.",
                                    "Teste a uniformidade da sequência com testes estatísticos básicos (ex: teste de Kolmogorov-Smirnov)."
                                  ],
                                  "verification": "Execute código para gerar e imprimir os primeiros 10 números da sequência; confirme reproducibilidade com a mesma seed.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com bibliotecas numpy.random e scipy.stats",
                                    "Editor de código como Jupyter Notebook",
                                    "Arquivo de texto para salvar sequência"
                                  ],
                                  "tips": "Use np.random.seed() no início; gere mais números do que necessário para evitar exaustão.",
                                  "learningObjective": "Gerar uma sequência determinística e compartilhável de números aleatórios.",
                                  "commonMistakes": [
                                    "Usar seeds diferentes por acidente",
                                    "Gerar sequências curtas insuficientes",
                                    "Não testar reproducibilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar CRN em Múltiplos Cenários de Simulação",
                                  "subSteps": [
                                    "Defina dois cenários comparáveis (ex: fila M/M/1 com taxas de chegada μ1 e μ2).",
                                    "Inicialize o gerador com a mesma seed para ambos cenários.",
                                    "Consuma números da sequência comum sequencialmente para eventos em cada simulação (ex: chegadas e serviços).",
                                    "Execute N réplicas (ex: 100) para cada cenário, usando a sequência compartilhada.",
                                    "Registre saídas como tempo médio no sistema para cada réplica."
                                  ],
                                  "verification": "Rode as simulações e plote saídas pareadas; observe correlação positiva nas réplicas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Código Python personalizado para simulação de filas",
                                    "Bibliotecas: numpy, matplotlib para plots",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Estruture o código em funções modulares: uma para consumir da sequência comum.",
                                  "learningObjective": "Aplicar CRN corretamente em simulações paralelas para induzir correlação.",
                                  "commonMistakes": [
                                    "Reincializar seed entre cenários",
                                    "Usar streams independentes",
                                    "Desalinhar consumo de números entre réplicas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Resultados e Verificar Redução de Variância",
                                  "subSteps": [
                                    "Calcule médias e variâncias das saídas para cada cenário.",
                                    "Compute variância da diferença entre médias pareadas (com CRN) vs. independentes.",
                                    "Plote gráficos de scatter plot das saídas pareadas para visualizar correlação.",
                                    "Realize teste estatístico (ex: t-pareado) para intervalos de confiança mais estreitos.",
                                    "Compare com baseline sem CRN e documente a redução percentual de variância."
                                  ],
                                  "verification": "Gere relatório com tabelas e gráficos mostrando redução de variância >20%.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com pandas, matplotlib, scipy.stats",
                                    "Planilha Excel para tabelas opcionais"
                                  ],
                                  "tips": "Use fórmulas: Var(D) = Var(X-Y) ≈ 2Var(X)(1-ρ), onde ρ é correlação induzida por CRN.",
                                  "learningObjective": "Quantificar o impacto de CRN na precisão de comparações.",
                                  "commonMistakes": [
                                    "Confundir variância individual com variância da diferença",
                                    "Ignorar normalidade das diferenças",
                                    "Não plotar para inspeção visual"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila M/M/1, compare dois cenários: taxa de serviço 1.0 vs. 1.2. Gere 1000 números aleatórios com seed=42. Use-os sequencialmente para chegadas em ambas simulações. Execute 50 réplicas: sem CRN, IC da diferença de médias tem largura 0.15; com CRN, reduz para 0.08, demonstrando eficiência.",
                              "finalVerifications": [
                                "Sequência de números é idêntica e reproducível em todas as rodadas.",
                                "Correlação positiva observada nas saídas pareadas (ρ > 0.5).",
                                "Variância da diferença entre cenários reduzida em pelo menos 20%.",
                                "Intervalos de confiança mais estreitos confirmados estatisticamente.",
                                "Código modular permite reutilização em novos cenários.",
                                "Relatório inclui gráficos e métricas quantitativas."
                              ],
                              "assessmentCriteria": [
                                "Compreensão conceitual demonstrada em explicação clara (20%)",
                                "Implementação correta da sequência comum sem erros de seed (30%)",
                                "Aplicação precisa em simulações com alinhamento de consumo (25%)",
                                "Análise estatística robusta com visualizações (15%)",
                                "Documentação completa e reprodutível (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Análise de variância e testes pareados.",
                                "Programação: Geradores pseudoaleatórios e modularidade de código.",
                                "Probabilidade: Dependência induzida e propriedades de uniformidade.",
                                "Engenharia Industrial: Otimização de simulações em manufatura."
                              ],
                              "realWorldApplication": "Em simulações de supply chain, CRN permite comparar políticas de estoque com menos réplicas, acelerando decisões em logística de e-commerce como Amazon, reduzindo tempo de simulação de dias para horas."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.4.2",
                            "name": "Implementar variáveis antitéticas",
                            "description": "Gerar pares de simulações com números aleatórios complementares (1-U) para explorar simetria e reduzir variância nas estimativas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de variáveis antitéticas",
                                  "subSteps": [
                                    "Estude a definição: variáveis antitéticas usam pares de números aleatórios U e 1-U para gerar correlação negativa perfeita.",
                                    "Analise como a simetria em torno de 0.5 reduz a variância na média das simulações.",
                                    "Revise exemplos teóricos de Monte Carlo padrão versus antitético.",
                                    "Compare fórmulas de variância: Var((X_U + X_{1-U})/2) < Var(X_U).",
                                    "Discuta pré-condições: função simétrica e monotônica."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras explicando o mecanismo de redução de variância.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Artigo ou vídeo sobre métodos de redução de variância em Monte Carlo",
                                    "Notebook Jupyter para anotações"
                                  ],
                                  "tips": "Visualize graficamente U e 1-U em um histograma para ver a simetria.",
                                  "learningObjective": "Dominar a teoria por trás da correlação negativa em variáveis antitéticas.",
                                  "commonMistakes": [
                                    "Ignorar a necessidade de monotonicidade na função simulada",
                                    "Confundir com amostragem estratificada"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar geração de pares antitéticos",
                                  "subSteps": [
                                    "Configure um gerador de números aleatórios uniformes (ex: numpy.random.uniform(0,1)).",
                                    "Crie uma função que gere pares (U, 1-U) para N simulações.",
                                    "Teste a geração com 1000 pares e verifique a média ≈0.5 e correlação ≈-1.",
                                    "Armazene pares em arrays separados para simulações pareadas.",
                                    "Adicione seed para reprodutibilidade nos testes."
                                  ],
                                  "verification": "Execute e imprima correlação entre U e 1-U; deve ser próximo de -1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python com NumPy e SciPy",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Use np.corrcoef para verificar correlação rapidamente.",
                                  "learningObjective": "Gerar corretamente números aleatórios complementares.",
                                  "commonMistakes": [
                                    "Gerar U e 1-U independentemente (perde correlação)",
                                    "Usar U=0 ou 1 sem tratamento de bordas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar simulações pareadas",
                                  "subSteps": [
                                    "Defina uma função de simulação exemplo (ex: estimar integral ∫sin(x) dx via hit-or-miss).",
                                    "Rode simulação padrão com 10k amostras e calcule média e variância.",
                                    "Rode simulação antitética: para cada par, compute (f(U) + f(1-U))/2.",
                                    "Calcule média e variância da simulação antitética.",
                                    "Repita com múltiplos runs para estimar variância da estimativa."
                                  ],
                                  "verification": "Compare variâncias: antitética deve ser menor em pelo menos 20-50%.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código Python pronto para Monte Carlo básico",
                                    "Gráficos com Matplotlib"
                                  ],
                                  "tips": "Escolha função onde antitéticas funcionam bem, como funções monotônicas.",
                                  "learningObjective": "Aplicar pares antitéticos em uma simulação real.",
                                  "commonMistakes": [
                                    "Média incorreta dos pares (deve ser /2)",
                                    "Não parear corretamente as simulações"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e validar redução de variância",
                                  "subSteps": [
                                    "Calcule razão de variâncias (padrão / antitética) e teste significância com bootstrap.",
                                    "Gere gráficos de erro padrão vs. número de pares.",
                                    "Experimente com funções não-simétricas para ver quando falha.",
                                    "Documente resultados em relatório com tabelas e plots.",
                                    "Otimize: combine com outros métodos como controle variacional."
                                  ],
                                  "verification": "Relatório mostra redução consistente de variância com evidências numéricas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "SciPy para bootstrap",
                                    "Matplotlib/Seaborn para visualizações"
                                  ],
                                  "tips": "Use 100 runs independentes para variância da variância.",
                                  "learningObjective": "Avaliar empiricamente a eficácia das antitéticas.",
                                  "commonMistakes": [
                                    "Amostra única sem replicatas (não mede variância)",
                                    "Função inadequada que não beneficia antitéticas"
                                  ]
                                }
                              ],
                              "practicalExample": "Estime a integral de 0 a 1 de f(x) = 4x(1-x) usando Monte Carlo hit-or-miss. Gere 5000 pares (U,1-U), compute médias pareadas e compare variância com método padrão: a antitética reduz variância em ~50% devido à simetria da função.",
                              "finalVerifications": [
                                "Correlação entre pares U e 1-U é próxima de -1.",
                                "Variância da estimativa antitética é menor que a padrão.",
                                "Código roda sem erros e é reprodutível com seed.",
                                "Gráficos mostram convergência mais rápida com antitéticas.",
                                "Relatório explica resultados com números concretos.",
                                "Testado em pelo menos duas funções diferentes."
                              ],
                              "assessmentCriteria": [
                                "Correta implementação de pares antitéticos (30%)",
                                "Redução observada e quantificada de variância (25%)",
                                "Análise estatística robusta com replicatas (20%)",
                                "Código limpo, comentado e modular (15%)",
                                "Interpretação teórica precisa (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Conceitos de covariância e redução de variância em Monte Carlo.",
                                "Programação: Uso de vetores NumPy e funções vetorizadas para eficiência.",
                                "Finanças: Aplicações em simulação de caminhos de Brownian para opções.",
                                "Física Computacional: Redução de ruído em simulações de partículas.",
                                "Machine Learning: Variância em métodos de ensemble e bagging."
                              ],
                              "realWorldApplication": "Em finanças quantitativas, variáveis antitéticas aceleram a precificação de opções europeias via Monte Carlo, reduzindo tempo de computação em 30-50% para precisão equivalente, essencial em trading de alta frequência e gerenciamento de risco."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.4.3",
                            "name": "Utilizar variáveis de controle",
                            "description": "Incorporar covariáveis conhecidas com baixa variância para ajustar as estimativas principais, melhorando a precisão das medidas de desempenho.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Variáveis de Controle",
                                  "subSteps": [
                                    "Estude a definição: variáveis de controle são covariáveis com baixa variância e alta correlação negativa ou positiva conhecida com a variável de interesse.",
                                    "Revise a fórmula de redução de variância: Var(Y - βX) = Var(Y) + β²Var(X) - 2βCov(Y,X), onde β é o coeficiente de regressão.",
                                    "Analise exemplos teóricos de simulações Monte Carlo onde a variância é reduzida.",
                                    "Identifique pré-requisitos: conhecimento de regressão linear simples e simulações básicas.",
                                    "Anote as condições ideais: relação linear conhecida e Var(X) << Var(Y)."
                                  ],
                                  "verification": "Resuma em 3 frases o mecanismo de redução de variância e liste 2 exemplos hipotéticos.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Livro-texto de simulação (ex: 'Simulation' de Ross), notas de aula, calculadora.",
                                  "tips": "Desenhe diagramas de correlação para visualizar a relação Y vs X.",
                                  "learningObjective": "Explicar como variáveis de controle reduzem variância em estimativas de simulação.",
                                  "commonMistakes": "Confundir com estratificação; assumir correlação sem verificação."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e Validar Variável de Controle Adequada",
                                  "subSteps": [
                                    "Escolha uma simulação alvo (ex: tempo médio de serviço em fila M/M/1).",
                                    "Liste covariáveis candidatas com baixa variância (ex: número de chegadas em intervalo fixo).",
                                    "Execute simulação piloto para calcular correlação Cov(Y,X) e verificar |ρ| > 0.5.",
                                    "Confirme baixa variância de X via simulações múltiplas.",
                                    "Documente a relação linear esperada entre Y e X."
                                  ],
                                  "verification": "Gere relatório com coeficiente de correlação e variâncias de Y e X da simulação piloto.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Software de simulação (Python com NumPy/SciPy, R), dataset piloto de 1000 runs.",
                                  "tips": "Use gráficos de dispersão para inspecionar linearidade visualmente.",
                                  "learningObjective": "Identificar e validar covariáveis adequadas para controle de variância.",
                                  "commonMistakes": "Escolher X com alta variância; ignorar não-linearidades."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Coleta e Ajuste na Simulação",
                                  "subSteps": [
                                    "Modifique o código de simulação para registrar pares (Y_i, X_i) em cada run.",
                                    "Calcule β = Cov(Y,X)/Var(X) usando amostra coletada.",
                                    "Ajuste estimativa: média ajustada = média(Y) - β*(média(X) - μ_X), onde μ_X é conhecido.",
                                    "Implemente regressão linear robusta se necessário.",
                                    "Execute simulação completa com 10,000 runs."
                                  ],
                                  "verification": "Verifique código rodando sem erros e produza pares (Y,X) salvos em arquivo.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Python/Jupyter Notebook, bibliotecas NumPy, SciPy.stats.linregress.",
                                  "tips": "Salve seeds aleatórias para reprodutibilidade.",
                                  "learningObjective": "Integrar coleta de X e computar ajuste β na simulação.",
                                  "commonMistakes": "Usar β errado (ex: inclinar); não centralizar X se μ_X ≠ 0."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Redução de Variância e Refinar",
                                  "subSteps": [
                                    "Calcule variância bruta Var(Y) e ajustada Var(Y - βX).",
                                    "Compare intervalos de confiança: verifique redução >20%.",
                                    "Teste sensibilidade variando tamanho da amostra.",
                                    "Refine escolha de X ou β se redução insuficiente.",
                                    "Gere relatório comparativo com tabelas e gráficos."
                                  ],
                                  "verification": "Produza tabela mostrando Var(reduzida)/Var(original) < 1 e IC mais estreito.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Mesmo software do step 3, Excel/Matplotlib para visualizações.",
                                  "tips": "Use bootstrap para estimar variâncias com confiança.",
                                  "learningObjective": "Quantificar e validar melhoria na precisão das estimativas.",
                                  "commonMistakes": "Comparar médias em vez de variâncias; ignorar viés introduzido."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar e Generalizar a Técnica",
                                  "subSteps": [
                                    "Escreva relatório completo: método, resultados, lições.",
                                    "Identifique cenários onde técnica falha (ex: correlação fraca).",
                                    "Adapte para múltiplas controles se aplicável.",
                                    "Planeje integração em experimentos maiores.",
                                    "Compartilhe código em repositório."
                                  ],
                                  "verification": "Relatório aprovado por peer review simulada (auto-avaliação checklist).",
                                  "estimatedTime": "1 hora",
                                  "materials": "Editor de texto, GitHub para código.",
                                  "tips": "Use templates LaTeX/Markdown para relatórios profissionais.",
                                  "learningObjective": "Documentar processo para replicabilidade e aprendizado contínuo.",
                                  "commonMistakes": "Omitir detalhes de implementação; super-generalizar resultados."
                                }
                              ],
                              "practicalExample": "Em simulação de fila M/M/1, Y = tempo de espera do cliente, X = número de chegadas no intervalo de serviço (baixa variância). Colete pares, ajuste β, reduza variância de E[Y] em 30%.",
                              "finalVerifications": [
                                "Correlação |ρ(Y,X)| > 0.5 confirmada.",
                                "Variância ajustada < 80% da original.",
                                "Intervalo de confiança 95% reduzido em largura.",
                                "Sem viés introduzido (média ajustada ≈ verdadeira).",
                                "Código reprodutível com seeds fixas.",
                                "Relatório inclui gráficos de Y vs Y-βX."
                              ],
                              "assessmentCriteria": [
                                "Precisão da explicação conceitual (30%).",
                                "Correta implementação e validação de β (25%).",
                                "Quantificação clara de redução de variância (20%).",
                                "Qualidade do relatório e visualizações (15%).",
                                "Identificação de erros potenciais (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Regressão linear e análise de variância.",
                                "Programação: Implementação numérica em Python/R.",
                                "Probabilidade: Teoria de Monte Carlo e variância.",
                                "Engenharia Industrial: Otimização de simulações em manufatura."
                              ],
                              "realWorldApplication": "Em finanças, reduzir variância em simulações de Value-at-Risk usando retornos de benchmark como controle; em logística, otimizar simulações de supply chain para precisão em prazos de entrega."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.2",
                "name": "Procedimentos de Modelagem de Simulação",
                "description": "Descreve os passos e técnicas para construir modelos de simulação eficazes.",
                "totalSkills": 59,
                "atomicTopics": [
                  {
                    "id": "10.1.2.1",
                    "name": "Formulação do Problema",
                    "description": "Definição dos objetivos, escopo e requisitos para o modelo de simulação.",
                    "individualConcepts": [
                      {
                        "id": "37.1.1.1",
                        "name": "Definição dos Objetivos da Simulação",
                        "description": "Estabelecimento claro dos propósitos e metas que o modelo de simulação deve alcançar, incluindo o que se pretende analisar ou otimizar no sistema discreto.",
                        "specificSkills": [
                          {
                            "id": "37.1.1.1.1",
                            "name": "Identificar objetivos principais do estudo",
                            "description": "Reconhecer e formular os objetivos fundamentais da simulação, como avaliação de desempenho, teste de cenários ou otimização de processos em sistemas discretos de eventos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o contexto e o problema geral",
                                  "subSteps": [
                                    "Ler a descrição completa do problema de simulação.",
                                    "Identificar os elementos chave do sistema discreto de eventos (entidades, recursos, eventos).",
                                    "Mapear as restrições e variáveis relevantes do sistema.",
                                    "Questionar o propósito geral do estudo com base no contexto fornecido.",
                                    "Anotar perguntas iniciais sobre o que o estudo busca resolver."
                                  ],
                                  "verification": "Criar um resumo escrito do problema com pelo menos 5 elementos chave identificados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Descrição do problema, papel e caneta ou editor de texto.",
                                  "tips": "Use perguntas como 'O que o cliente quer saber?' para guiar a compreensão.",
                                  "learningObjective": "Entender profundamente o problema para alinhar objetivos à realidade do sistema.",
                                  "commonMistakes": "Ignorar restrições do sistema ou focar apenas em sintomas superficiais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Listar objetivos potenciais da simulação",
                                  "subSteps": [
                                    "Brainstorming de objetivos comuns: avaliação de desempenho, teste de cenários, otimização de processos.",
                                    "Categorizar objetivos em qualitativos (ex.: viabilidade) e quantitativos (ex.: tempo médio).",
                                    "Relacionar cada objetivo potencial às métricas mensuráveis do sistema.",
                                    "Consultar literatura ou exemplos semelhantes para inspirar objetivos.",
                                    "Priorizar objetivos iniciais em uma lista numerada."
                                  ],
                                  "verification": "Gerar uma lista de pelo menos 5 objetivos potenciais com descrições breves.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Lista de brainstorm, exemplos de simulações semelhantes.",
                                  "tips": "Pense em 'o que se mede?' para tornar objetivos acionáveis.",
                                  "learningObjective": "Gerar uma gama ampla de objetivos relevantes ao sistema discreto.",
                                  "commonMistakes": "Listar objetivos vagos ou não relacionados ao sistema de eventos discretos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar e selecionar objetivos principais",
                                  "subSteps": [
                                    "Avaliar cada objetivo pela relevância, factibilidade e impacto no problema.",
                                    "Usar critérios como SMART (Específico, Mensurável, Alcançável, Relevante, Temporal).",
                                    "Eliminar objetivos redundantes ou secundários.",
                                    "Consultar stakeholders fictícios ou reais para validação.",
                                    "Selecionar 2-4 objetivos principais e justificar a escolha."
                                  ],
                                  "verification": "Documentar a seleção com justificativas para cada objetivo mantido ou descartado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Matriz de avaliação (planilha ou tabela), critérios SMART.",
                                  "tips": "Pontue cada objetivo de 1-10 em cada critério para objetividade.",
                                  "learningObjective": "Discriminar objetivos principais dos secundários com base em critérios rigorosos.",
                                  "commonMistakes": "Selecionar muitos objetivos, diluindo o foco da simulação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formular e validar objetivos finais",
                                  "subSteps": [
                                    "Redigir objetivos em linguagem clara e mensurável (ex.: 'Reduzir tempo médio de espera em 20%').",
                                    "Verificar alinhamento com o problema original e métricas do sistema.",
                                    "Simular cenários hipotéticos para testar a utilidade dos objetivos.",
                                    "Revisar com pares ou autoavaliação para refinamento.",
                                    "Finalizar declaração de objetivos principais."
                                  ],
                                  "verification": "Produzir uma declaração final de objetivos com métricas associadas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Rascunhos anteriores, ferramenta de edição de texto.",
                                  "tips": "Use verbos acionáveis como 'avaliar', 'otimizar', 'testar'.",
                                  "learningObjective": "Formular objetivos precisos que guiem a modelagem de simulação.",
                                  "commonMistakes": "Criar objetivos ambíguos que não possam ser simulados quantitativamente."
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado (sistema discreto de eventos), os objetivos principais identificados são: 1) Avaliar o tempo médio de espera dos clientes em diferentes configurações de caixas; 2) Otimizar o número de caixas para minimizar filas acima de 5 minutos; 3) Testar cenários de pico de demanda para prever gargalos.",
                              "finalVerifications": [
                                "Objetivos estão alinhados ao problema original.",
                                "Cada objetivo é mensurável com métricas do sistema.",
                                "Há 2-4 objetivos principais, sem redundâncias.",
                                "Objetivos são factíveis dentro do escopo da simulação.",
                                "Declaração final é clara e acionável.",
                                "Justificativas suportam a seleção."
                              ],
                              "assessmentCriteria": [
                                "Clareza e precisão na formulação dos objetivos (nota 1-5).",
                                "Relevância e alinhamento com o contexto do sistema discreto (nota 1-5).",
                                "Uso de métricas quantitativas e qualitativas adequadas (nota 1-5).",
                                "Profundidade na avaliação e priorização (nota 1-5).",
                                "Completude da documentação e justificativas (nota 1-5).",
                                "Criatividade na identificação de cenários reais (nota 1-5)."
                              ],
                              "crossCurricularConnections": [
                                "Gestão de Projetos: Definição de escopo e metas.",
                                "Engenharia de Produção: Otimização de processos.",
                                "Estatística: Métricas de desempenho e análise de dados.",
                                "Administração: Análise de cenários de negócios."
                              ],
                              "realWorldApplication": "Na logística de distribuição de uma empresa de e-commerce, identificar objetivos como otimizar rotas de entrega para reduzir atrasos em 15%, permitindo decisões baseadas em simulações que economizam custos e melhoram satisfação do cliente."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "37.1.1.1.2",
                            "name": "Especificar métricas de desempenho",
                            "description": "Definir indicadores quantitativos chave, como tempo médio de espera, taxa de utilização ou throughput, alinhados aos objetivos do modelo de simulação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os objetivos da simulação",
                                  "subSteps": [
                                    "Leia e liste os objetivos principais do problema de simulação.",
                                    "Identifique aspectos qualitativos que precisam ser quantificados (ex.: eficiência, atrasos).",
                                    "Classifique objetivos por prioridade (alto, médio, baixo).",
                                    "Anote perguntas chave: O que medir para avaliar sucesso?",
                                    "Crie um mapa mental conectando objetivos a possíveis medidas."
                                  ],
                                  "verification": "Verifique se há uma lista clara de objetivos com classificações de prioridade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação do problema de simulação, papel ou ferramenta de mind mapping (ex.: MindMeister).",
                                  "tips": "Foquem em verbos de ação nos objetivos para guiar as métricas.",
                                  "learningObjective": "Compreender como objetivos guiam a seleção de métricas quantitativas.",
                                  "commonMistakes": "Ignorar objetivos secundários ou confundir com soluções."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar métricas potenciais",
                                  "subSteps": [
                                    "Pesquise métricas padrão para o tipo de sistema (ex.: filas: tempo de espera; produção: throughput).",
                                    "Liste 5-10 métricas candidatas com definições iniciais.",
                                    "Classifique métricas por tipo: tempo, taxa, probabilidade, custo.",
                                    "Avalie relevância inicial para cada objetivo.",
                                    "Exclua métricas irrelevantes ou redundantes."
                                  ],
                                  "verification": "Confira se a lista tem pelo menos 5 métricas com classificações e definições breves.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Referências de simulação (ex.: livros como 'Simulation Modeling and Analysis' de Law), internet para exemplos.",
                                  "tips": "Use acrônimos como WIPT (Work In Process Time) para sistemas de manufatura.",
                                  "learningObjective": "Reconhecer e catalogar métricas quantitativas comuns em simulações discretas.",
                                  "commonMistakes": "Escolher métricas genéricas sem contexto do sistema."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir métricas chave com fórmulas precisas",
                                  "subSteps": [
                                    "Selecione 3-5 métricas principais alinhadas aos objetivos prioritários.",
                                    "Defina cada métrica com fórmula matemática (ex.: Tempo médio de espera = soma(tempos)/n).",
                                    "Especifique unidades de medida e condições de coleta.",
                                    "Determine thresholds ou alvos (ex.: throughput > 90%).",
                                    "Crie uma tabela resumindo métricas, fórmulas e objetivos ligados."
                                  ],
                                  "verification": "Revise a tabela para garantir fórmulas corretas e alinhamento explícito.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Planilha (Excel/Google Sheets), calculadora ou software simbólico (ex.: SymPy).",
                                  "tips": "Garanta que fórmulas sejam mensuráveis durante a simulação.",
                                  "learningObjective": "Formular definições quantitativas precisas e acionáveis para métricas.",
                                  "commonMistakes": "Definir métricas vagas sem fórmulas ou unidades."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e documentar as métricas",
                                  "subSteps": [
                                    "Simule cenários hipotéticos para testar viabilidade das métricas.",
                                    "Verifique alinhamento: cada métrica responde a pelo menos um objetivo?",
                                    "Consulte stakeholders ou literatura para validação.",
                                    "Documente em formato estruturado: tabela ou relatório.",
                                    "Planeje coleta de dados na simulação (ex.: variáveis de saída)."
                                  ],
                                  "verification": "Peça feedback ou autoavalie se todas as verificações de alinhamento passam.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Ferramenta de simulação básica (ex.: Simul8 trial ou Python com SimPy), documento de relatório.",
                                  "tips": "Use diagramas de fluxo para visualizar coleta de métricas.",
                                  "learningObjective": "Garantir robustez e usabilidade das métricas no modelo de simulação.",
                                  "commonMistakes": "Pular validação, levando a métricas não coletáveis."
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado, defina: Throughput = itens processados / hora (alvo: >50/hora); Tempo médio de espera = soma(esperas)/clientes (alvo: <5 min); Taxa de utilização = tempo ocupado / tempo total do caixa (>80%). Alinhe ao objetivo de reduzir filas.",
                              "finalVerifications": [
                                "Todas as métricas são quantitativas com fórmulas explícitas.",
                                "Cada métrica alinha-se a pelo menos um objetivo da simulação.",
                                "Unidades e métodos de coleta estão definidos.",
                                "Há 3-5 métricas principais, sem redundâncias.",
                                "Thresholds ou alvos estão especificados para avaliação.",
                                "Documentação está clara e tabular."
                              ],
                              "assessmentCriteria": [
                                "Precisão das fórmulas matemáticas (correção e completude).",
                                "Alinhamento explícito entre métricas e objetivos (cobertura total).",
                                "Relevância contextual ao sistema simulado.",
                                "Número adequado de métricas (nem poucas, nem excessivas).",
                                "Clareza na documentação e usabilidade prática.",
                                "Inovação ou adaptação de métricas padrão ao problema."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Cálculo de médias, variâncias e distribuições para métricas.",
                                "Programação: Implementação de coleta de dados em linguagens como Python (SimPy).",
                                "Engenharia Industrial: Aplicação em otimização de processos e Lean Manufacturing.",
                                "Gestão de Projetos: Definição de KPIs alinhados a metas.",
                                "Análise de Dados: Visualização e interpretação de resultados métricos."
                              ],
                              "realWorldApplication": "Em logística, especificar throughput e tempo de espera otimiza supply chains; em call centers, taxa de utilização melhora alocação de agentes; em manufatura, métricas guiam simulações para reduzir bottlenecks e custos operacionais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "37.1.1.1.3",
                            "name": "Priorizar objetivos hierarquicamente",
                            "description": "Estabelecer uma hierarquia de importância entre os objetivos para guiar decisões subsequentes na modelagem, considerando restrições de tempo e recursos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Listar e Compreender Todos os Objetivos",
                                  "subSteps": [
                                    "Identifique todos os objetivos iniciais da simulação listados na formulação do problema.",
                                    "Descreva cada objetivo em termos claros e mensuráveis, evitando ambiguidades.",
                                    "Classifique objetivos como primários (essenciais) ou secundários (desejáveis) com base na declaração inicial.",
                                    "Documente restrições conhecidas de tempo, recursos computacionais e dados para cada objetivo.",
                                    "Crie uma tabela inicial com colunas: Objetivo, Descrição, Restrições Associadas."
                                  ],
                                  "verification": "Verifique se a tabela está completa e todos os objetivos estão descritos de forma mensurável sem ambiguidades.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel ou editor de texto (Google Docs, Notion), lista inicial de objetivos do problema"
                                  ],
                                  "tips": "Use verbos de ação (analisar, prever, otimizar) para tornar objetivos mensuráveis.",
                                  "learningObjective": "Dominar a identificação e documentação precisa de objetivos para análise hierárquica.",
                                  "commonMistakes": [
                                    "Omitir objetivos secundários relevantes",
                                    "Descrições vagas como 'melhorar performance' sem métricas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Critérios de Priorização",
                                  "subSteps": [
                                    "Estabeleça critérios chave: impacto no problema principal, viabilidade com restrições de tempo/recursos, dependências entre objetivos.",
                                    "Atribua pesos aos critérios (ex: impacto=40%, viabilidade=30%, urgência=30%) baseados no contexto da simulação.",
                                    "Crie uma escala de pontuação para cada critério (1-5 ou 1-10) com definições claras para cada nível.",
                                    "Valide os critérios com stakeholders simulados ou requisitos do problema.",
                                    "Documente os critérios em uma matriz de avaliação."
                                  ],
                                  "verification": "Confirme que todos os critérios têm pesos somando 100% e escalas definidas claramente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Planilha (Excel, Google Sheets), matriz de critérios template"
                                  ],
                                  "tips": "Priorize critérios alinhados ao objetivo principal da simulação discreta, como precisão vs. velocidade.",
                                  "learningObjective": "Aprender a criar critérios objetivos e ponderados para priorização hierárquica.",
                                  "commonMistakes": [
                                    "Critérios subjetivos sem escalas",
                                    "Pesos desbalanceados ignorando restrições reais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar e Classificar Objetivos",
                                  "subSteps": [
                                    "Pontue cada objetivo usando a matriz de critérios, calculando pontuação total ponderada.",
                                    "Ordene os objetivos do maior para o menor pontuação, formando uma hierarquia inicial.",
                                    "Identifique conflitos ou dependências (ex: objetivo A depende de B).",
                                    "Ajuste pontuações considerando interdependências e restrições cumulativas.",
                                    "Visualize a hierarquia em um diagrama (lista numerada ou árvore)."
                                  ],
                                  "verification": "A hierarquia deve ter objetivos ordenados com pontuações calculadas e dependências anotadas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Planilha com fórmulas para pontuação automática, ferramenta de diagrama (Draw.io, Lucidchart)"
                                  ],
                                  "tips": "Use fórmulas no Excel para automatizar: =SOMA(produto(pesos, pontuações)).",
                                  "learningObjective": "Desenvolver habilidade em quantificar e ordenar objetivos hierarquicamente.",
                                  "commonMistakes": [
                                    "Ignorar dependências levando a hierarquia irrealista",
                                    "Pontuações inconsistentes entre avaliadores"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Refinar a Hierarquia",
                                  "subSteps": [
                                    "Simule cenários: 'Se tempo limitado a 50%, quais objetivos manter?'",
                                    "Consulte feedback externo ou autoavaliação contra objetivos principais.",
                                    "Ajuste a hierarquia com base em trade-offs (ex: sacrificar secundário por primário viável).",
                                    "Documente justificativas para cada posição na hierarquia.",
                                    "Crie um plano de contingência para re-priorização se restrições mudarem."
                                  ],
                                  "verification": "Hierarquia final documentada com justificativas e plano de contingência aprovado em revisão simulada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Hierarquia inicial, checklist de validação"
                                  ],
                                  "tips": "Teste com 'what-if' analysis para robustez.",
                                  "learningObjective": "Garantir que a hierarquia seja robusta e adaptável a mudanças.",
                                  "commonMistakes": [
                                    "Não validar com cenários reais",
                                    "Hierarquia rígida sem contingências"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado discreta, objetivos incluem: 1) Minimizar tempo médio de espera (primário), 2) Otimizar layout de caixas (secundário), 3) Prever picos de demanda. Critérios: impacto na satisfação do cliente (peso 50%). Hierarquia final: 1º tempo de espera, 2º previsão de picos, 3º layout (devido a restrições de tempo).",
                              "finalVerifications": [
                                "Hierarquia escrita com pelo menos 3 objetivos ordenados e pontuações.",
                                "Matriz de critérios completa com pesos e escalas.",
                                "Diagrama visual da hierarquia com dependências.",
                                "Justificativas para top 2 objetivos alinhadas a restrições.",
                                "Plano de contingência para corte de 30% dos objetivos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na pontuação e cálculo ponderado (sem erros matemáticos).",
                                "Clareza e mensurabilidade das descrições de objetivos.",
                                "Consideração explícita de restrições de tempo/recursos.",
                                "Identificação correta de dependências e trade-offs.",
                                "Robustez da hierarquia em cenários de validação.",
                                "Documentação completa e profissional."
                              ],
                              "crossCurricularConnections": [
                                "Gestão de Projetos: Técnicas de MoSCoW (Must, Should, Could, Won't).",
                                "Tomada de Decisão em Administração: Análise multicritério (AHP).",
                                "Programação: Priorização de features em desenvolvimento ágil.",
                                "Economia: Alocação de recursos escassos."
                              ],
                              "realWorldApplication": "Em modelagem de simulações para logística (ex: supply chain), priorizar objetivos como reduzir custos de estoque sobre otimização fina de rotas quando orçamento é limitado, guiando equipes de engenharia a focar esforços iniciais em alto impacto."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "37.1.1.2",
                        "name": "Delimitação do Escopo do Modelo",
                        "description": "Determinação das fronteiras do sistema a ser simulado, excluindo elementos irrelevantes para focar no que impacta diretamente os objetivos.",
                        "specificSkills": [
                          {
                            "id": "37.1.1.2.1",
                            "name": "Mapear fronteiras do sistema",
                            "description": "Identificar entradas, saídas, processos internos e interações externas relevantes para o modelo de simulação de sistemas discretos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar entradas e saídas do sistema",
                                  "subSteps": [
                                    "Analise o problema de simulação para listar todas as entradas possíveis (ex.: dados de chegada de clientes).",
                                    "Liste saídas relevantes (ex.: tempo de espera médio).",
                                    "Classifique entradas como determinísticas ou estocásticas.",
                                    "Priorize entradas/saídas críticas para o escopo do modelo.",
                                    "Registre em uma tabela inicial."
                                  ],
                                  "verification": "Verifique se a lista de entradas/saídas cobre todos os elementos mencionados no problema e se há pelo menos 3 de cada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta ou ferramenta de diagramação como Draw.io/Lucidchart",
                                  "tips": "Comece pelo 'black box' view: foque no que entra e sai sem detalhes internos ainda.",
                                  "learningObjective": "Compreender os fluxos de dados que definem as interfaces do sistema.",
                                  "commonMistakes": "Ignorar entradas indiretas ou saídas secundárias que impactam o resultado."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Mapear processos internos principais",
                                  "subSteps": [
                                    "Descreva os processos principais dentro das fronteiras (ex.: processamento de pedidos).",
                                    "Identifique variáveis de estado internas (ex.: número de itens no estoque).",
                                    "Desenhe um fluxograma simples dos processos sequenciais ou paralelos.",
                                    "Destaque dependências entre processos internos.",
                                    "Confirme que processos mapeados são relevantes para entradas/saídas."
                                  ],
                                  "verification": "Crie um diagrama preliminar e valide se todo processo liga uma entrada a uma saída.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software de fluxograma (Draw.io, Visio) ou quadro branco",
                                  "tips": "Use caixas para processos e setas para fluxos; mantenha simples inicialmente.",
                                  "learningObjective": "Representar a lógica interna do sistema discretos de forma visual.",
                                  "commonMistakes": "Incluir subprocessos irrelevantes, expandindo o escopo desnecessariamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar interações externas e delimitar fronteiras",
                                  "subSteps": [
                                    "Liste interações com sistemas externos (ex.: fornecedores, ambiente).",
                                    "Decida o que modelar internamente vs. assumir como entrada/saída.",
                                    "Marque fronteiras claras no diagrama (linha tracejada para limites).",
                                    "Avalie impactos de interações ignoradas no modelo.",
                                    "Documente justificativas para delimitações."
                                  ],
                                  "verification": "Pergunte: 'Isso afeta diretamente as saídas principais?' para cada interação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Diagrama do Step 2 + documento de notas (Google Docs/Word)",
                                  "tips": "Aplique o princípio de Pareto: foque nos 20% de interações que causam 80% do impacto.",
                                  "learningObjective": "Delimitar escopo para evitar complexidade excessiva em simulações discretas.",
                                  "commonMistakes": "Confundir interações externas com internas, borrando fronteiras."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e documentar o mapa de fronteiras",
                                  "subSteps": [
                                    "Revise o diagrama completo com stakeholders ou auto-perguntas.",
                                    "Simule cenários simples para testar fronteiras.",
                                    "Adicione legendas e anotações ao mapa final.",
                                    "Registre suposições e limitações do escopo.",
                                    "Prepare para iteração futura."
                                  ],
                                  "verification": "O mapa permite responder: 'Onde o modelo começa e termina?' claramente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Diagrama final + checklist de validação",
                                  "tips": "Use cores: verde para interno, vermelho para externo.",
                                  "learningObjective": "Garantir robustez do mapa para formulação precisa do modelo.",
                                  "commonMistakes": "Pular validação, levando a modelos com vazamentos de escopo."
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado: entradas (chegada de clientes, itens por carrinho), saídas (tempo total no caixa), processos internos (escaneamento, pagamento), interações externas (estoque externo assumido como entrada estocástica). Fronteiras: modelo para de um caixa, ignorando logística de estoque.",
                              "finalVerifications": [
                                "Todas entradas e saídas estão listadas e priorizadas.",
                                "Processos internos cobrem fluxos de entrada a saída.",
                                "Fronteiras estão explicitamente marcadas no diagrama.",
                                "Interações externas são tratadas como entradas/saídas ou justificadas como fora de escopo.",
                                "Mapa é legível e inclui legendas.",
                                "Suposições documentadas para refinamento futuro."
                              ],
                              "assessmentCriteria": [
                                "Completude: Todas componentes (entradas, saídas, processos, interações) cobertas (30%).",
                                "Precisão: Delimitações lógicas e alinhadas ao problema (25%).",
                                "Clareza visual: Diagrama intuitivo e bem anotado (20%).",
                                "Justificativa: Racional para escolhas de escopo documentada (15%).",
                                "Viabilidade: Escopo modelável em simulação discreta (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Software: Modelagem UML para sistemas.",
                                "Programação: Definição de interfaces em código (APIs).",
                                "Gestão de Projetos: Definição de escopo em PMBOK.",
                                "Física: Análise de sistemas em mecânica."
                              ],
                              "realWorldApplication": "Em simulações de manufatura (ex.: linha de produção da Toyota), mapeia entradas (matéria-prima), saídas (produtos acabados), processos (montagem) e interações (fornecedores), otimizando eficiência e reduzindo gargalos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "37.1.1.1.1"
                            ]
                          },
                          {
                            "id": "37.1.1.2.2",
                            "name": "Excluir componentes não essenciais",
                            "description": "Analisar e justificar a remoção de elementos periféricos que não afetam significativamente os objetivos, simplificando o modelo sem perda de fidelidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar componentes essenciais e periféricos no modelo",
                                  "subSteps": [
                                    "Liste todos os componentes atuais do modelo de simulação.",
                                    "Defina os objetivos principais do modelo com base no problema.",
                                    "Classifique cada componente como essencial (diretamente ligado aos objetivos) ou periférico (indireto ou secundário).",
                                    "Crie um diagrama ou tabela visualizando a classificação.",
                                    "Priorize componentes por impacto nos resultados principais."
                                  ],
                                  "verification": "Verifique se há uma lista completa classificada com pelo menos 80% dos componentes categorizados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Diagrama do modelo original",
                                    "Lista de objetivos do problema",
                                    "Ferramenta de diagramação como Draw.io ou papel e caneta"
                                  ],
                                  "tips": "Use critérios quantitativos como frequência de interação com componentes essenciais para classificar.",
                                  "learningObjective": "Diferenciar componentes essenciais de periféricos alinhados aos objetivos da simulação.",
                                  "commonMistakes": [
                                    "Confundir periféricos com essenciais por viés de complexidade",
                                    "Ignorar interações sutis entre componentes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o impacto da remoção de componentes periféricos",
                                  "subSteps": [
                                    "Selecione 2-3 componentes periféricos candidatos à remoção.",
                                    "Simule cenários com e sem esses componentes usando métricas chave (ex: tempo de execução, precisão dos outputs).",
                                    "Calcule diferenças percentuais em resultados principais (deve ser <5% para aprovação).",
                                    "Registre trade-offs como ganho em simplicidade vs. perda potencial de realismo.",
                                    "Documente evidências quantitativas e qualitativas."
                                  ],
                                  "verification": "Compare outputs de simulações: diferença <5% nos KPIs principais.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software de simulação (ex: Python com SimPy)",
                                    "Dados de entrada padronizados",
                                    "Planilha para métricas"
                                  ],
                                  "tips": "Execute múltiplas runs (Monte Carlo) para robustez estatística.",
                                  "learningObjective": "Quantificar impactos da remoção para evitar perda de fidelidade.",
                                  "commonMistakes": [
                                    "Usar apenas uma run de simulação",
                                    "Focar só em tempo, ignorando precisão"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Justificar a remoção com argumentos claros e documentados",
                                  "subSteps": [
                                    "Escreva justificativas para cada remoção, citando análises do passo anterior.",
                                    "Inclua evidências: gráficos de comparação, cálculos de impacto.",
                                    "Avalie riscos residuais e condições para reintrodução futura.",
                                    "Revise com pares ou auto-revisão para clareza.",
                                    "Atualize documentação do modelo com seção 'Simplificações Justificadas'."
                                  ],
                                  "verification": "Justificativas aprovadas por checklist: clara, evidenciada, risco avaliado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Relatório de análise do passo 2",
                                    "Template de justificativa",
                                    "Ferramenta de edição como Google Docs"
                                  ],
                                  "tips": "Use formato 'Problema-Evidência-Decisão-Risco' para estrutura.",
                                  "learningObjective": "Comunicar decisões de simplificação de forma transparente e defensável.",
                                  "commonMistakes": [
                                    "Justificativas vagas sem dados",
                                    "Subestimar riscos de cenários edge"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar o modelo simplificado e iterar se necessário",
                                  "subSteps": [
                                    "Execute simulações completas no modelo simplificado vs. original.",
                                    "Meça KPIs globais: precisão, performance, legibilidade do código.",
                                    "Colete feedback de stakeholders sobre utilidade.",
                                    "Ajuste se violações > threshold (ex: precisão <95%).",
                                    "Finalize versão simplificada com changelog."
                                  ],
                                  "verification": "KPIs do modelo simplificado atendem thresholds pré-definidos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código fonte original e simplificado",
                                    "Ambiente de teste",
                                    "Checklist de validação"
                                  ],
                                  "tips": "Automatize testes com scripts para reprodutibilidade.",
                                  "learningObjective": "Confirmar que simplificação preserva fidelidade aos objetivos.",
                                  "commonMistakes": [
                                    "Não testar cenários extremos",
                                    "Ignorar feedback externo"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado (sistema discreto de eventos), remova o componente 'variação climática afetando chegada de clientes' (periférico), pois análises mostram impacto <2% no tempo médio de espera (objetivo principal), reduzindo complexidade de 150 para 80 linhas de código sem perda de fidelidade.",
                              "finalVerifications": [
                                "Modelo simplificado mantém precisão >95% nos KPIs principais.",
                                "Tempo de execução reduzido em pelo menos 20%.",
                                "Documentação inclui todas justificativas com evidências.",
                                "Código mais legível e manutenível (medido por linhas ou cyclomatic complexity).",
                                "Testes em cenários edge passam sem falhas novas.",
                                "Stakeholders aprovam simplificação."
                              ],
                              "assessmentCriteria": [
                                "Classificação de componentes precisa e alinhada aos objetivos (80%+).",
                                "Análises quantitativas robustas com múltiplas simulações.",
                                "Justificativas claras, evidenciadas e sem ambiguidades.",
                                "Validação completa com thresholds explícitos.",
                                "Trade-offs documentados e riscos mitigados.",
                                "Melhoria mensurável em performance sem perda de fidelidade."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Software: Refatoração e princípios de simplicidade (KISS).",
                                "Estatística: Análise de sensibilidade e validação de modelos.",
                                "Gestão de Projetos: Trade-off custo-benefício em modelagem.",
                                "Filosofia da Ciência: Princípio da parcimônia (navalha de Occam)."
                              ],
                              "realWorldApplication": "Em simulações industriais como logística de supply chain, engenheiros removem efeitos periféricos como 'flutuações de humor do operador' para acelerar otimizações, permitindo decisões rápidas em fábricas reais sem comprometer previsões de throughput."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "37.1.1.2.3",
                            "name": "Definir níveis de detalhe",
                            "description": "Estabelecer o grau de granularidade necessário para o modelo, equilibrando precisão e complexidade computacional em simulações discretas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar Objetivos e Requisitos da Simulação",
                                  "subSteps": [
                                    "Identifique os objetivos principais da simulação (ex.: prever comportamento médio ou detalhes finos).",
                                    "Liste restrições computacionais (tempo de execução, memória disponível).",
                                    "Defina métricas de precisão necessárias baseadas nos objetivos.",
                                    "Documente o escopo do problema real versus o modelo simplificado.",
                                    "Consulte stakeholders para alinhar expectativas de granularidade."
                                  ],
                                  "verification": "Checklist completo dos objetivos e restrições documentado e revisado.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": "Documentação do problema, planilha de requisitos, software de notas (ex.: Notion ou Excel).",
                                  "tips": "Priorize objetivos de alto nível antes de detalhes técnicos para evitar sobrecarga inicial.",
                                  "learningObjective": "Compreender como os objetivos guiam a escolha de granularidade.",
                                  "commonMistakes": "Ignorar restrições computacionais, levando a modelos inviáveis; assumir granularidade fina sem justificativa."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Componentes e Variáveis do Sistema",
                                  "subSteps": [
                                    "Mapeie todos os elementos do sistema discreto (estados, transições, agentes).",
                                    "Classifique variáveis por relevância (essenciais, secundárias, irrelevantes).",
                                    "Estime o número de estados possíveis em diferentes níveis de detalhe.",
                                    "Crie um diagrama de componentes com níveis hierárquicos potenciais.",
                                    "Avalie interdependências entre componentes para granularidade agregada."
                                  ],
                                  "verification": "Diagrama de componentes com classificações de variáveis aprovado por auto-revisão.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": "Ferramentas de diagramação (ex.: Draw.io, Lucidchart), papel e caneta para rascunhos.",
                                  "tips": "Use abstrações iniciais para mapear sem entrar em detalhes prematuros.",
                                  "learningObjective": "Mapear o sistema para identificar onde aplicar granularidade variável.",
                                  "commonMistakes": "Sobrecarregar o mapa com variáveis irrelevantes; subestimar interdependências."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar Trade-offs de Granularidade",
                                  "subSteps": [
                                    "Defina cenários de granularidade: baixa (agregada), média, alta (detalhada).",
                                    "Simule estimativas de complexidade (ex.: O(n^k) para diferentes n).",
                                    "Calcule métricas comparativas: precisão vs. tempo de simulação.",
                                    "Teste protótipos simples para cada cenário usando código básico.",
                                    "Registre prós e contras qualitativos e quantitativos em uma tabela."
                                  ],
                                  "verification": "Tabela de trade-offs preenchida com estimativas numéricas e protótipos testados.",
                                  "estimatedTime": "60-90 minutos",
                                  "materials": "Linguagem de programação simples (ex.: Python com NumPy), planilha para cálculos.",
                                  "tips": "Comece com estimativas analíticas antes de codificar para agilizar.",
                                  "learningObjective": "Quantificar o equilíbrio entre precisão e custo computacional.",
                                  "commonMistakes": "Focar apenas em precisão sem medir complexidade real; usar cenários irreais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Selecionar e Justificar o Nível de Detalhe",
                                  "subSteps": [
                                    "Escolha o nível ótimo baseado na análise de trade-offs.",
                                    "Justifique a decisão com evidências quantitativas e qualitativas.",
                                    "Defina regras para refinar granularidade em iterações futuras.",
                                    "Documente o nível escolhido no plano de modelagem.",
                                    "Planeje validação cruzada com dados reais ou benchmarks."
                                  ],
                                  "verification": "Documento de justificativa final com nível definido e plano de validação.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": "Template de relatório, software de edição de texto.",
                                  "tips": "Use critérios ponderados (ex.: 60% precisão, 40% eficiência) para decisão objetiva.",
                                  "learningObjective": "Formalizar a seleção de granularidade com justificativa robusta.",
                                  "commonMistakes": "Escolher nível extremo sem trade-offs; omitir justificativa para futuras revisões."
                                }
                              ],
                              "practicalExample": "Em uma simulação de tráfego urbano discreta, defina níveis: baixa granularidade (fluxo médio por rua), média (grupos de veículos), alta (cada carro com posição exata). Equilibre para rodar em 1 hora com 90% de precisão em congestionamentos, usando Python para protótipos.",
                              "finalVerifications": [
                                "Nível de detalhe alinhado aos objetivos originais?",
                                "Estimativas de complexidade computacional realistas e testadas?",
                                "Trade-offs documentados com métricas quantitativas?",
                                "Justificativa clara e reprodutível?",
                                "Plano para ajustes iterativos incluído?",
                                "Validação preliminar com protótipo bem-sucedida?"
                              ],
                              "assessmentCriteria": [
                                "Precisão do modelo atende aos requisitos mínimos (ex.: erro < 10%).",
                                "Complexidade computacional dentro de limites (ex.: < 1 hora de execução).",
                                "Análise de trade-offs abrangente e quantitativa.",
                                "Justificativa lógica e baseada em evidências.",
                                "Flexibilidade para refinamentos futuros.",
                                "Integração coerente com escopo geral do modelo."
                              ],
                              "crossCurricularConnections": [
                                "Ciência da Computação: Análise de complexidade algorítmica (Big O).",
                                "Física: Modelagem de sistemas dinâmicos discretos.",
                                "Engenharia de Software: Design de sistemas escaláveis.",
                                "Estatística: Avaliação de precisão e variância em simulações."
                              ],
                              "realWorldApplication": "Em simulações epidemiológicas como modelagem de propagação de doenças (ex.: COVID-19), definir níveis de detalhe permite equilibrar rastreamento individual (alta granularidade para hotspots) com populações agregadas (baixa para regiões amplas), otimizando previsões para políticas públicas sem sobrecarregar supercomputadores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "37.1.1.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "37.1.1.3",
                        "name": "Identificação dos Requisitos do Modelo",
                        "description": "Levantamento das especificações técnicas, funcionais e de precisão exigidas para que o modelo atenda aos objetivos dentro do escopo definido.",
                        "specificSkills": [
                          {
                            "id": "37.1.1.3.1",
                            "name": "Listar requisitos funcionais",
                            "description": "Documentar funções que o modelo deve replicar, como geração de eventos, filas e despachos em sistemas de simulação discreta de eventos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar o sistema real e identificar entidades principais",
                                  "subSteps": [
                                    "Estude a descrição do problema e observe o sistema real ou diagramas.",
                                    "Identifique entidades chave como recursos, filas, agentes e eventos.",
                                    "Registre atributos de cada entidade (ex: capacidade de fila, tempo de serviço).",
                                    "Crie um glossário inicial de termos do domínio.",
                                    "Desenhe um diagrama simples de entidades e relacionamentos."
                                  ],
                                  "verification": "Verifique se há uma lista completa de entidades com atributos documentados e um diagrama preliminar.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Descrição do problema, papel/caneta ou ferramenta de diagramação como Draw.io.",
                                  "tips": "Comece pelo 'o quê' antes do 'como'; foque em objetos que mudam de estado.",
                                  "learningObjective": "Compreender as componentes fundamentais do sistema para basear requisitos funcionais.",
                                  "commonMistakes": "Ignorar entidades passivas como filas ou confundir entidades com processos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Mapear eventos, estados e transições",
                                  "subSteps": [
                                    "Liste todos os eventos possíveis (ex: chegada, partida, falha).",
                                    "Defina estados iniciais e finais para cada entidade.",
                                    "Mapeie sequências de eventos que alteram estados (fluxogramas de eventos).",
                                    "Identifique dependências entre eventos e entidades.",
                                    "Anote condições de disparo e efeitos colaterais de cada evento."
                                  ],
                                  "verification": "Confirme um fluxograma ou tabela de eventos com estados de entrada/saída para cada um.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Ferramenta de fluxograma (Lucidchart ou papel), timer para observação.",
                                  "tips": "Use cronograma de eventos para visualizar ordem temporal; priorize eventos frequentes.",
                                  "learningObjective": "Modelar dinâmicas do sistema através de eventos discretos.",
                                  "commonMistakes": "Listar ações contínuas como eventos discretos ou omitir eventos raros mas críticos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar e listar requisitos funcionais específicos",
                                  "subSteps": [
                                    "Para cada evento, defina funções necessárias (ex: gerar chegada, enfileirar, despachar).",
                                    "Especifique entradas/saídas e lógica interna de cada função.",
                                    "Inclua gerenciamento de filas (FIFO, prioridades), escalonamento e clocks simulados.",
                                    "Priorize requisitos por frequência e impacto na simulação.",
                                    "Formate como lista numerada com verbos de ação (ex: 'Gerar evento de chegada')."
                                  ],
                                  "verification": "Revise a lista para cobrir todos os eventos mapeados, sem duplicatas.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Planilha ou editor de texto para lista estruturada.",
                                  "tips": "Use template: Função | Evento desencadeado | Entradas | Saídas | Condições.",
                                  "learningObjective": "Traduzir comportamentos observados em funções replicáveis pelo modelo.",
                                  "commonMistakes": "Ser vago (ex: 'gerenciar fila' em vez de 'enfileirar cliente se caixa livre') ou incluir não-funcionais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Documentar, organizar e validar a lista",
                                  "subSteps": [
                                    "Compile a lista em documento hierárquico (categorias como Geração, Filas, Despachos).",
                                    "Adicione referências cruzadas aos eventos e entidades.",
                                    "Compartilhe com stakeholders para feedback.",
                                    "Ajuste com base em gaps identificados.",
                                    "Versão final com data e assinaturas."
                                  ],
                                  "verification": "Documento aprovado com cobertura de 100% dos eventos principais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Google Docs ou Word, lista de contatos de stakeholders.",
                                  "tips": "Mantenha linguagem precisa e não-ambígua; use bullet points para clareza.",
                                  "learningObjective": "Garantir que requisitos sejam acionáveis e validados.",
                                  "commonMistakes": "Não priorizar ou validar, levando a requisitos incompletos."
                                }
                              ],
                              "practicalExample": "Em uma simulação de supermercado: 1. Gerar evento de chegada de cliente (Poisson). 2. Enfileirar em caixa mais curta. 3. Despachar para pagamento se caixa livre. 4. Atualizar estatísticas de tempo de espera.",
                              "finalVerifications": [
                                "Todos os eventos principais têm funções associadas?",
                                "Requisitos cobrem geração de eventos, filas e despachos?",
                                "Lista é priorizada e sem ambiguidades?",
                                "Documentação referencia entidades e fluxos?",
                                "Validação com stakeholder confirma completude?",
                                "Nenhum requisito funcional foi omitido de processos críticos?"
                              ],
                              "assessmentCriteria": [
                                "Completude: Todos os comportamentos chave replicados.",
                                "Clareza: Linguagem precisa com entradas/saídas definidas.",
                                "Relevância: Foco exclusivo em funcionais de DES.",
                                "Estruturação: Organizada hierarquicamente e priorizada.",
                                "Precisão: Sem erros lógicos ou ambiguidades.",
                                "Validação: Evidência de revisão externa."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação das funções em linguagens como Python/SimPy.",
                                "Estatística: Modelagem probabilística de eventos (distribuições).",
                                "Gestão de Projetos: Especificação de requisitos em engenharia de software.",
                                "Análise de Sistemas: Modelagem UML para entidades e estados."
                              ],
                              "realWorldApplication": "Em engenharia de software para definir APIs de simulação; em logística para modelar armazéns com filas de picking e despachos; em manufatura para simular linhas de produção com eventos de falha e manutenção."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "37.1.1.2.1"
                            ]
                          },
                          {
                            "id": "37.1.1.3.2",
                            "name": "Determinar requisitos de precisão e confiança",
                            "description": "Especificar níveis de confiança estatística e intervalos de erro aceitáveis para as saídas da simulação, baseados em métodos de amostragem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Precisão e Confiança",
                                  "subSteps": [
                                    "Defina precisão como o grau de proximidade entre o valor estimado e o verdadeiro.",
                                    "Explique confiança como a probabilidade de que o intervalo contenha o verdadeiro valor (ex: 95%).",
                                    "Diferencie erro absoluto, relativo e intervalo de confiança.",
                                    "Estude a relação entre tamanho da amostra, variância e largura do intervalo de confiança.",
                                    "Revise fórmulas básicas: IC = média ± Z * (desvio padrão / sqrt(n))."
                                  ],
                                  "verification": "Resuma os conceitos em um diagrama ou mapa mental e explique para um par.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de estatística introdutória, calculadora, papel e caneta.",
                                  "tips": "Use analogias como arremesso de dardos para visualizar precisão vs. acurácia.",
                                  "learningObjective": "Identificar e diferenciar precisão, confiança e componentes de intervalos de erro.",
                                  "commonMistakes": "Confundir precisão com acurácia; ignorar o impacto da variância."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Métodos de Amostragem em Simulações",
                                  "subSteps": [
                                    "Liste métodos: aleatória simples, estratificada, por conglomerados e importância.",
                                    "Analise como cada método afeta variância e precisão em simulações discretas.",
                                    "Simule amostras pequenas vs. grandes para observar impacto na confiança.",
                                    "Calcule variância amostral para dados simulados de um sistema discreto (ex: filas).",
                                    "Compare eficiência: quando usar amostragem estratificada vs. aleatória."
                                  ],
                                  "verification": "Crie uma tabela comparativa dos métodos com prós e contras.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software de simulação (Python com NumPy/SciPy), planilha Excel.",
                                  "tips": "Comece com amostras pequenas para ver variabilidade alta, depois aumente n.",
                                  "learningObjective": "Selecionar método de amostragem adequado para minimizar erro em simulações.",
                                  "commonMistakes": "Escolher amostragem inadequada para o sistema (ex: aleatória em dados heterogêneos)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Níveis de Confiança e Intervalos de Erro",
                                  "subSteps": [
                                    "Determine Z-scores para níveis comuns: 1.96 para 95%, 2.58 para 99%.",
                                    "Calcule tamanho de amostra mínimo: n = (Z * σ / E)^2, onde E é margem de erro.",
                                    "Aplique a simulações: rode réplicas e compute IC para médias de saídas.",
                                    "Ajuste para distribuições não-normais usando bootstrap ou t-Student.",
                                    "Valide cálculos com dados simulados de um sistema discreto."
                                  ],
                                  "verification": "Execute cálculo para um dataset simulado e confira com ferramenta online.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Python/Jupyter Notebook, bibliotecas statsmodels ou scipy.stats.",
                                  "tips": "Use loops para múltiplas réplicas e plote ICs para visualização.",
                                  "learningObjective": "Computar e interpretar intervalos de confiança para saídas de simulação.",
                                  "commonMistakes": "Usar Z em vez de t para amostras pequenas; ignorar normalidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Especificar Requisitos para o Modelo de Simulação",
                                  "subSteps": [
                                    "Analise o problema: identifique saídas críticas (ex: tempo médio, throughput).",
                                    "Defina tolerâncias: ex: erro relativo <5%, confiança 95%.",
                                    "Integre método de amostragem e calcule n réplicas necessárias.",
                                    "Documente requisitos: 'IC de 95% com largura <10% da média'.",
                                    "Teste e refine baseados em runs preliminares."
                                  ],
                                  "verification": "Escreva um parágrafo especificando requisitos para um problema dado.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Template de documento de requisitos, software de simulação.",
                                  "tips": "Comece conservador (alta confiança, baixo erro) e otimize custo computacional.",
                                  "learningObjective": "Formular requisitos precisos e acionáveis para simulações discretas.",
                                  "commonMistakes": "Definir requisitos vagos; subestimar custo de réplicas altas."
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado (sistema discreto de eventos), especifique: para tempo médio de espera, use amostragem estratificada por horários, 95% confiança, margem de erro ±2 minutos, calculando n=500 réplicas via fórmula, validando com 10 runs preliminares.",
                              "finalVerifications": [
                                "Calcula corretamente IC para dados simulados com precisão.",
                                "Seleciona método de amostragem justificado pelo contexto.",
                                "Especifica requisitos numéricos claros (nível %, largura IC).",
                                "Documenta trade-offs entre precisão, confiança e custo computacional.",
                                "Valida com simulação real, ajustando se necessário.",
                                "Explica impacto em decisões baseadas na simulação."
                              ],
                              "assessmentCriteria": [
                                "Exatidão matemática nos cálculos de IC e n (90%+ correto).",
                                "Adequação do método de amostragem ao problema (lógica clara).",
                                "Especificidade dos requisitos (quantificados, não vagos).",
                                "Profundidade de análise de trade-offs e erros potenciais.",
                                "Clareza na documentação e comunicação.",
                                "Criatividade na aplicação a cenários reais."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Inferência e testes de hipóteses.",
                                "Probabilidade: Distribuições e teorema central do limite.",
                                "Programação: Implementação de simulações em Python/R.",
                                "Engenharia de Software: Validação e verificação de modelos.",
                                "Gestão de Projetos: Balanceamento de precisão vs. recursos."
                              ],
                              "realWorldApplication": "Em finanças, determinar confiança em simulações Monte Carlo para VaR (Value at Risk), garantindo que previsões de risco tenham IC estreito para decisões de investimento seguras; ou em manufatura, especificar precisão para simulações de linhas de produção, otimizando throughput com confiança alta."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "37.1.1.1.2"
                            ]
                          },
                          {
                            "id": "37.1.1.3.3",
                            "name": "Avaliar restrições de recursos",
                            "description": "Considerar limitações computacionais, de tempo de execução e de dados disponíveis para viabilizar a implementação do modelo de simulação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar as restrições de recursos disponíveis",
                                  "subSteps": [
                                    "Levantar especificações do hardware: CPU (núcleos, clock), RAM total, armazenamento em disco",
                                    "Determinar limites de tempo de execução: prazos do projeto e tolerância para testes",
                                    "Avaliar disponibilidade de dados: tamanho do dataset, qualidade e acesso (ex.: APIs limitadas)",
                                    "Listar restrições de software: bibliotecas instaladas, versões de linguagens e licenças"
                                  ],
                                  "verification": "Lista documentada e completa de todas as restrições identificadas, com fontes de dados",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Especificações do computador (Task Manager ou systeminfo), documentação do projeto, lista de datasets"
                                  ],
                                  "tips": "Use comandos como 'systeminfo' no Windows ou 'lscpu' no Linux para dados precisos do hardware",
                                  "learningObjective": "Compreender e catalogar todas as limitações do ambiente de simulação",
                                  "commonMistakes": [
                                    "Ignorar restrições de software ou rede",
                                    "Subestimar picos de uso de recursos durante simulações paralelas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estimar os requisitos de recursos do modelo proposto",
                                  "subSteps": [
                                    "Calcular complexidade computacional: notação Big O para loops e operações principais",
                                    "Estimar uso de memória: tamanho de arrays, estruturas de dados e overhead de simulação",
                                    "Projetar tempo de execução: número de iterações × tempo médio por passo, considerando cenários de escala",
                                    "Prever demanda de dados: volume necessário para treinamento ou simulação inicial",
                                    "Simular protótipo mínimo para validação empírica das estimativas"
                                  ],
                                  "verification": "Tabela comparativa com estimativas numéricas (ex.: RAM: 2GB, tempo: 5min) e justificativas",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Planilha (Excel/Google Sheets), código protótipo simples, perfilador de performance (ex.: timeit no Python)"
                                  ],
                                  "tips": "Comece com um modelo pequeno e escale linearmente para projeções realistas",
                                  "learningObjective": "Desenvolver habilidades para quantificar demandas computacionais de um modelo",
                                  "commonMistakes": [
                                    "Não considerar overhead de I/O em datasets grandes",
                                    "Usar complexidade otimista sem testes empíricos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar viabilidade e identificar gargalos",
                                  "subSteps": [
                                    "Comparar estimativas vs. restrições disponíveis: RAM requerida ≤ disponível?",
                                    "Calcular margens de segurança: adicionar 20-30% buffer para imprevistos",
                                    "Identificar gargalos principais: ex. memória excede limite ou tempo ultrapassa prazo",
                                    "Avaliar impactos qualitativos: precisão da simulação afetada por simplificações",
                                    "Priorizar restrições críticas por ordem de impacto no modelo"
                                  ],
                                  "verification": "Relatório de análise com matriz de comparação e lista de gargalos destacados",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha de comparação, gráficos de barras para visualização"
                                  ],
                                  "tips": "Use cores no relatório (verde: OK, vermelho: crítico) para facilitar a leitura rápida",
                                  "learningObjective": "Capacitar análise comparativa para decisões informadas sobre viabilidade",
                                  "commonMistakes": [
                                    "Ignorar interdependências, como tempo afetado por falta de RAM",
                                    "Não incluir buffers de segurança"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Propor ajustes e documentar a avaliação",
                                  "subSteps": [
                                    "Sugerir otimizações: reduzir precisão numérica, usar amostragem ou paralelização",
                                    "Explorar alternativas: migração para cloud (AWS/GCP) ou modelos aproximados",
                                    "Validar propostas com reestimação rápida de recursos",
                                    "Documentar decisão final: viável sim/não, com justificativa e plano de contingência",
                                    "Preparar relatório executivo com recomendações acionáveis"
                                  ],
                                  "verification": "Documento final com propostas testadas, decisão clara e plano de implementação",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Ferramentas de documentação (Markdown/Google Docs), acesso a cloud trials"
                                  ],
                                  "tips": "Priorize soluções low-cost primeiro, como otimizações de código, antes de hardware novo",
                                  "learningObjective": "Aprender a mitigar restrições e comunicar trade-offs efetivamente",
                                  "commonMistakes": [
                                    "Propor soluções inviáveis sem custo-benefício",
                                    "Documentar sem quantificar impactos das mudanças"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de filas discretas para um call center com 10.000 chamadas, identifique que o PC tem 8GB RAM e 5min limite; estime 6GB e 7min necessários; detecte gargalo de tempo; proponha reduzir iterações para 5.000, otimizando para 3min e 4GB.",
                              "finalVerifications": [
                                "Todas restrições foram listadas com valores numéricos precisos",
                                "Estimativas de recursos validadas empiricamente em protótipo",
                                "Gargalos identificados com análise quantitativa e qualitativa",
                                "Propostas de ajuste viáveis e priorizadas por impacto",
                                "Documentação completa com matriz de decisão e buffers de segurança",
                                "Viabilidade geral declarada com plano de contingência"
                              ],
                              "assessmentCriteria": [
                                "Precisão das estimativas (>85% alinhada com testes reais)",
                                "Completude da identificação de restrições (todas categorias cobertas)",
                                "Qualidade da análise de gargalos (com margens e priorização)",
                                "Criatividade e realismo das propostas de otimização",
                                "Clareza e estrutura da documentação final",
                                "Integração de trade-offs entre precisão e recursos"
                              ],
                              "crossCurricularConnections": [
                                "Ciência da Computação: Análise de algoritmos e Big O",
                                "Engenharia de Software: Requisitos não-funcionais e escalabilidade",
                                "Gestão de Projetos: Planejamento de recursos e risco",
                                "Estatística: Amostragem e redução de dimensionalidade de dados"
                              ],
                              "realWorldApplication": "Na indústria farmacêutica, simulações de folding de proteínas em drug discovery respeitam limites de supercomputadores; em apps de mobilidade urbana (ex.: Waze), modelos de tráfego rodam em smartphones com restrições de bateria e CPU para previsões em tempo real."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "37.1.1.3.4",
                            "name": "Documentar requisitos em formato estruturado",
                            "description": "Criar um documento formal com todos os requisitos, facilitando a validação e comunicação com stakeholders no processo de modelagem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Coletar e Organizar Requisitos Identificados",
                                  "subSteps": [
                                    "Revise todos os requisitos previamente identificados do problema de simulação.",
                                    "Classifique-os em categorias como funcionais, não-funcionais, restrições e suposições.",
                                    "Priorize os requisitos com base na importância para o modelo de simulação.",
                                    "Crie uma lista inicial com descrições claras e fontes (ex: stakeholder interviews).",
                                    "Valide a completude listando gaps potenciais."
                                  ],
                                  "verification": "Verifique se a lista cobre 100% dos requisitos identificados sem duplicatas ou ambiguidades.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Lista de requisitos brutos",
                                    "Planilha ou editor de texto (Google Sheets, Notion)"
                                  ],
                                  "tips": "Use cores ou tags para categorizar visualmente e facilitar a navegação.",
                                  "learningObjective": "Dominar a organização sistemática de requisitos para evitar omissões.",
                                  "commonMistakes": [
                                    "Ignorar requisitos não-funcionais como performance",
                                    "Não citar fontes, levando a disputas futuras"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e Definir o Formato Estruturado do Documento",
                                  "subSteps": [
                                    "Escolha um template padrão: tabela com colunas (ID, Descrição, Categoria, Prioridade, Status).",
                                    "Adapte para simulações discretas: inclua colunas específicas como 'Variáveis Envolvidas' e 'Métricas de Saída'.",
                                    "Defina convenções: use IDs hierárquicos (ex: REQ-1.1), glossário para termos técnicos.",
                                    "Crie seções: Introdução, Requisitos Detalhados, Apêndices (diagramas).",
                                    "Teste o template com 2-3 requisitos de exemplo."
                                  ],
                                  "verification": "Confirme que o template é legível, escalável e cobre todos os tipos de requisitos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Templates de requisitos (IEEE 830 ou adaptado)",
                                    "Ferramentas como Markdown, Word ou Confluence"
                                  ],
                                  "tips": "Opte por formatos versionados (ex: Git) para rastreabilidade em equipes.",
                                  "learningObjective": "Aprender a escolher formatos que otimizem comunicação em modelagem.",
                                  "commonMistakes": [
                                    "Formatos muito rígidos que não se adaptam a simulações complexas",
                                    "Sobrecarregar com colunas desnecessárias"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Preencher o Documento com Conteúdo Detalhado",
                                  "subSteps": [
                                    "Preencha cada requisito com descrição precisa, critérios de aceitação e exemplos.",
                                    "Inclua traceabilidade: link para o problema original e stakeholders responsáveis.",
                                    "Adicione diagramas ou pseudocódigo para requisitos de simulação (ex: fluxos de eventos discretos).",
                                    "Garanta linguagem formal, objetiva e livre de jargões não definidos.",
                                    "Numere e indexe todos os itens para referência fácil."
                                  ],
                                  "verification": "Leia o documento como um stakeholder externo: ele é autoexplicativo?",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Diagramas de simulação (Draw.io, Lucidchart)",
                                    "Glossário de termos da simulação discreta"
                                  ],
                                  "tips": "Use verbos acionáveis nos critérios (ex: 'O modelo deve simular X com precisão Y%').",
                                  "learningObjective": "Desenvolver habilidade em redação técnica precisa para validação.",
                                  "commonMistakes": [
                                    "Descrições vagas como 'rápido o suficiente'",
                                    "Falta de exemplos concretos para simulações"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Revisar, Validar e Finalizar o Documento",
                                  "subSteps": [
                                    "Realize auto-revisão: cheque completude, consistência e clareza.",
                                    "Compartilhe draft com stakeholders para feedback (use checklist de validação).",
                                    "Incorpore mudanças e registre versão final com histórico.",
                                    "Adicione sumário executivo e índice para navegação.",
                                    "Exporte em PDF para distribuição formal."
                                  ],
                                  "verification": "Obtenha aprovação assinada ou feedback positivo de pelo menos um stakeholder.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Checklist de revisão (completude, precisão, usabilidade)",
                                    "Ferramenta de colaboração (Google Docs)"
                                  ],
                                  "tips": "Planeje rodadas de revisão curtas para evitar delays no processo de modelagem.",
                                  "learningObjective": "Garantir qualidade através de iterações e validação externa.",
                                  "commonMistakes": [
                                    "Pular revisão, resultando em mal-entendidos na implementação",
                                    "Ignorar feedback menor"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma simulação de fila em um supermercado: Crie tabela com REQ-1: 'O modelo deve simular chegada de clientes Poisson(λ=5/hora)' (Categoria: Funcional, Prioridade: Alta, Verificação: Distribuição gerada matches histórico). Inclua diagrama de estados e critérios como tempo médio de espera < 10min.",
                              "finalVerifications": [
                                "Todos os requisitos estão categorizados e priorizados corretamente.",
                                "O documento é versionado com histórico de mudanças.",
                                "Stakeholders confirmam compreensão e aprovação.",
                                "Formato permite fácil rastreabilidade para implementação da simulação.",
                                "Nenhum requisito ambíguo ou incompleto permanece.",
                                "Inclui glossário e diagramas relevantes para sistemas discretos."
                              ],
                              "assessmentCriteria": [
                                "Clareza e precisão da linguagem (nota 1-5).",
                                "Completude: cobre 100% dos requisitos identificados.",
                                "Estrutura: facilita comunicação e validação (legibilidade, indexação).",
                                "Traceabilidade: links para fontes e stakeholders.",
                                "Adequação ao contexto de simulação discreta (métricas, variáveis específicas).",
                                "Profissionalismo: formatação, sumário e apêndices."
                              ],
                              "crossCurricularConnections": [
                                "Redação Técnica (Língua Portuguesa/Comunicação): Estrutura formal de documentos.",
                                "Gestão de Projetos: Rastreabilidade e versionamento (ex: Agile/Scrum).",
                                "Programação: Especificação de requisitos para codificação de simulações.",
                                "Estatística: Definição precisa de distribuições e métricas em simulações.",
                                "Design de Sistemas: Diagramas e modelagem UML-like."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software de simulação (ex: AnyLogic, Simul8), engenharia de processos industriais ou análise de filas em logística, onde documentos estruturados evitam erros caros na implementação e facilitam auditorias regulatórias."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "37.1.1.3.1",
                              "37.1.1.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.2",
                    "name": "Coleta e Análise de Dados",
                    "description": "Obtenção, processamento e análise de dados reais para parametrizar o modelo.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.2.1",
                        "name": "Obtenção de Dados Reais",
                        "description": "Processo de identificação, seleção e coleta de dados reais de sistemas discretos para servir como base na parametrizização do modelo de simulação, considerando fontes como históricos de operação, sensores ou registros operacionais.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.1.1",
                            "name": "Identificar Fontes de Dados Relevantes",
                            "description": "Determinar as fontes apropriadas de dados reais, como logs de sistemas, bancos de dados operacionais ou medições diretas, específicas para eventos discretos em simulações como filas ou processos de manufatura.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Sistema e os Eventos Discretos",
                                  "subSteps": [
                                    "Analise a descrição do sistema de simulação, identificando eventos discretos como chegadas, serviços ou falhas.",
                                    "Mapeie os componentes do sistema (ex.: filas, servidores, máquinas em manufatura).",
                                    "Defina os parâmetros chave que geram dados (taxas de chegada, tempos de processamento).",
                                    "Crie um diagrama simples do fluxo de eventos discretos.",
                                    "Liste perguntas específicas sobre os dados necessários para cada evento."
                                  ],
                                  "verification": "Diagrama completo do sistema com eventos discretos mapeados e lista de perguntas de dados revisada por pares.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e caneta ou software de diagramação (ex.: Draw.io)",
                                    "Descrição do sistema de simulação"
                                  ],
                                  "tips": "Comece pelo fluxo principal de eventos para evitar sobrecarga de detalhes iniciais.",
                                  "learningObjective": "Entender a estrutura de eventos discretos para guiar a busca por fontes de dados relevantes.",
                                  "commonMistakes": [
                                    "Ignorar eventos secundários como falhas",
                                    "Confundir eventos discretos com contínuos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Listar Possíveis Fontes de Dados Reais",
                                  "subSteps": [
                                    "Brainstorm fontes internas: logs de sistemas, bancos de dados operacionais (SQL/NoSQL).",
                                    "Considere fontes externas: sensores IoT, medições manuais, APIs de terceiros.",
                                    "Categorize fontes por tipo: automatizadas (logs), semi-automatizadas (relatórios), manuais (observações).",
                                    "Pesquise exemplos específicos para o domínio (ex.: logs de ERP para manufatura).",
                                    "Documente pelo menos 5-10 fontes potenciais com descrições breves."
                                  ],
                                  "verification": "Lista documentada de pelo menos 8 fontes com categorias e exemplos iniciais.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Planilha ou documento (Google Sheets/Word)",
                                    "Acesso a documentação de sistemas reais ou exemplos online"
                                  ],
                                  "tips": "Use palavras-chave do domínio (fila, manufatura) em buscas para fontes reais.",
                                  "learningObjective": "Identificar uma ampla gama de fontes potenciais adaptadas ao sistema discreto.",
                                  "commonMistakes": [
                                    "Limitar-se a uma categoria de fontes",
                                    "Incluir fontes irrelevantes sem filtro inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar Relevância, Disponibilidade e Qualidade das Fontes",
                                  "subSteps": [
                                    "Para cada fonte, avalie relevância: cobre os eventos discretos? (sim/não/parcial).",
                                    "Verifique disponibilidade: acesso atual? Formato utilizável? (ex.: CSV, JSON).",
                                    "Avalie qualidade: precisão, frequência de atualização, volume de dados históricos.",
                                    "Pontue cada fonte em uma escala de 1-10 para relevância, disponibilidade e qualidade.",
                                    "Elimine fontes com pontuação média abaixo de 6 e justifique."
                                  ],
                                  "verification": "Tabela de avaliação com pontuações e justificativas para todas as fontes listadas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Planilha de avaliação com colunas para critérios",
                                    "Acesso simulado ou real a amostras de dados"
                                  ],
                                  "tips": "Priorize fontes com dados históricos longos para simulações robustas.",
                                  "learningObjective": "Desenvolver critérios objetivos para filtrar fontes viáveis.",
                                  "commonMistakes": [
                                    "Superestimar disponibilidade sem verificação",
                                    "Ignorar questões de privacidade ou custo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Selecionar e Justificar Fontes Finais",
                                  "subSteps": [
                                    "Selecione 3-5 fontes top com base na avaliação.",
                                    "Escreva justificativas detalhadas para cada seleção, ligando aos eventos discretos.",
                                    "Planeje extração: queries SQL, scripts de parsing de logs, etc.",
                                    "Identifique gaps e fontes alternativas de backup.",
                                    "Crie um relatório resumido com fontes selecionadas e plano de coleta."
                                  ],
                                  "verification": "Relatório final com fontes selecionadas, justificativas e plano de extração aprovado por instructor.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Template de relatório",
                                    "Ferramentas de prototipagem (ex.: Python para queries)"
                                  ],
                                  "tips": "Inclua diversificação de fontes para robustez na simulação.",
                                  "learningObjective": "Finalizar uma seleção estratégica de fontes alinhada aos objetivos da simulação.",
                                  "commonMistakes": [
                                    "Selecionar muitas fontes sem priorização",
                                    "Faltar justificativas baseadas em evidências"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de call center: fontes incluem logs de chamadas (timestamps de chegada/fim), banco de dados CRM (duração de interações), gravações de chamadas para tempos de espera, e relatórios diários de volume de chamadas. Avalie logs como alta relevância (eventos discretos exatos) e alta disponibilidade.",
                              "finalVerifications": [
                                "Lista de fontes selecionadas cobre todos os eventos discretos principais.",
                                "Cada fonte tem justificativa ligada a parâmetros da simulação.",
                                "Plano de extração é factível com ferramentas disponíveis.",
                                "Avaliação de qualidade identifica potenciais vieses ou gaps.",
                                "Relatório inclui backups para fontes indisponíveis.",
                                "Diagrama integra fontes ao fluxo de eventos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de eventos discretos (90% cobertura).",
                                "Diversidade e relevância das fontes listadas (mínimo 8 fontes avaliadas).",
                                "Rigor na avaliação quantitativa (pontuações consistentes).",
                                "Justificativas claras e baseadas em evidências.",
                                "Plano de extração prático e acionável.",
                                "Identificação proativa de riscos e mitigações."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Análise de qualidade e vieses em dados reais.",
                                "Ciência da Computação: Queries em bancos de dados e parsing de logs.",
                                "Engenharia Industrial: Aplicação em manufatura e logística.",
                                "Gestão de Dados: Privacidade (GDPR) e ética em coleta.",
                                "Programação: Scripts para automação de extração de dados."
                              ],
                              "realWorldApplication": "Em processos de manufatura, identificar logs de máquinas CNC e sensores RFID para simular tempos de setup e falhas, otimizando linhas de produção e reduzindo downtime em 20% via simulações validadas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.2",
                            "name": "Aplicar Métodos de Amostragem",
                            "description": "Selecionar e implementar métodos de amostragem estatística, como amostragem aleatória simples ou estratificada, para coletar uma amostra representativa dos dados do sistema discreto sem viés.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Princípios Básicos de Amostragem Estatística",
                                  "subSteps": [
                                    "Defina o conceito de população e amostra em sistemas discretos.",
                                    "Identifique fontes de viés na coleta de dados, como amostragem não aleatória.",
                                    "Estude os tipos principais: amostragem aleatória simples, estratificada, por conglomerados e sistemática.",
                                    "Analise vantagens e desvantagens de cada método para sistemas discretos.",
                                    "Revise fórmulas básicas para cálculo do tamanho da amostra."
                                  ],
                                  "verification": "Resuma em um diagrama os tipos de amostragem e seus riscos de viés.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Estatística Descritiva",
                                    "Vídeos tutoriais sobre amostragem (Khan Academy)",
                                    "Folha de papel ou software de diagramação como Draw.io"
                                  ],
                                  "tips": "Use analogias cotidianas, como sortear nomes em uma urna, para fixar conceitos.",
                                  "learningObjective": "Dominar os fundamentos teóricos para seleção informada de métodos.",
                                  "commonMistakes": [
                                    "Confundir população com amostra",
                                    "Ignorar heterogeneidade em sistemas discretos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar o Método de Amostragem Adequado",
                                  "subSteps": [
                                    "Descreva as características do sistema discreto (ex.: estados finitos, transições).",
                                    "Avalie a estratificação necessária baseada em variáveis relevantes.",
                                    "Calcule o tamanho mínimo da amostra usando fórmula de margem de erro.",
                                    "Compare métodos: aleatória simples para homogeneidade, estratificada para heterogeneidade.",
                                    "Justifique a escolha com base no contexto de simulação."
                                  ],
                                  "verification": "Elabore um relatório curto justificando o método escolhido para um caso hipotético.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora ou Excel para fórmulas",
                                    "Lista de dados simulados do sistema discreto"
                                  ],
                                  "tips": "Priorize estratificada se houver subgrupos desiguais na população.",
                                  "learningObjective": "Capacitar a escolha contextualizada de métodos sem viés.",
                                  "commonMistakes": [
                                    "Escolher método sem considerar variabilidade",
                                    "Subestimar tamanho da amostra"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o Método de Amostragem",
                                  "subSteps": [
                                    "Prepare a lista ou frame da população (ex.: IDs de eventos discretos).",
                                    "Gere números aleatórios para amostragem simples (usando Python random ou Excel RAND).",
                                    "Para estratificada, divida em estratos e amostre proporcionalmente.",
                                    "Colete os dados da amostra sem introduzir viés manual.",
                                    "Registre o processo em um log para reprodutibilidade."
                                  ],
                                  "verification": "Execute o código ou processo e obtenha uma amostra de 100 itens; compare distribuições.",
                                  "estimatedTime": "1,5 horas",
                                  "materials": [
                                    "Python com bibliotecas numpy e pandas",
                                    "Excel ou Google Sheets",
                                    "Dataset de exemplo de sistema discreto (ex.: tempos de serviço)"
                                  ],
                                  "tips": "Use seed fixa no gerador aleatório para resultados reproduzíveis.",
                                  "learningObjective": "Executar amostragem prática de forma precisa e eficiente.",
                                  "commonMistakes": [
                                    "Não usar randomização verdadeira",
                                    "Erros em proporções estratificadas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar a Representatividade da Amostra",
                                  "subSteps": [
                                    "Compare estatísticas descritivas da amostra vs. população conhecida.",
                                    "Aplique teste qui-quadrado para uniformidade.",
                                    "Verifique intervalos de confiança para proporções.",
                                    "Identifique e corrija viés detectado (ex.: oversampling).",
                                    "Documente métricas de qualidade da amostra."
                                  ],
                                  "verification": "Gere relatório com testes estatísticos confirmando representatividade (p-valor > 0.05).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python com scipy.stats",
                                    "Tabelas de qui-quadrado"
                                  ],
                                  "tips": "Visualize com histogramas para detecção rápida de discrepâncias.",
                                  "learningObjective": "Garantir que a amostra seja viés-free e utilizável na simulação.",
                                  "commonMistakes": [
                                    "Ignorar testes estatísticos",
                                    "Confundir significância com representatividade"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de banco (sistema discreto com estados: livre, atendendo), use amostragem estratificada para coletar tempos de espera de 200 clientes, divididos por horários de pico e não-pico, garantindo representatividade sem viés horário.",
                              "finalVerifications": [
                                "A amostra reflete as proporções da população (teste qui-quadrado ok).",
                                "Ausência de viés detectado em comparações univariadas.",
                                "Tamanho da amostra atende margem de erro de 5%.",
                                "Processo documentado e reproduzível.",
                                "Dados coletados prontos para análise em simulação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na seleção e justificativa do método (30%).",
                                "Implementação correta sem erros de codificação (25%).",
                                "Validação estatística robusta (20%).",
                                "Documentação clara e completa (15%).",
                                "Eficiência temporal e uso de recursos (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Cálculos de inferência e testes de hipóteses.",
                                "Programação: Uso de bibliotecas para randomização e análise.",
                                "Ciência de Dados: Preparação de dados para machine learning.",
                                "Gestão de Projetos: Planejamento de coletas em cenários reais."
                              ],
                              "realWorldApplication": "Em controle de qualidade industrial, amostrar peças defeituosas de linhas de produção para simulações de manutenção preditiva, ou em pesquisas eleitorais para estimar intenções de voto sem viés demográfico."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.3",
                            "name": "Registrar Dados de Forma Estruturada",
                            "description": "Coletar e registrar dados em formatos estruturados, como planilhas ou bancos de dados, garantindo rastreabilidade e inclusão de metadados como timestamps de eventos discretos para posterior análise.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o Esquema de Dados Estruturado",
                                  "subSteps": [
                                    "Identifique as variáveis principais dos eventos discretos (ex: tempo de chegada, valor medido, ID do evento).",
                                    "Inclua metadados obrigatórios: timestamp (data/hora exata), ID único sequencial, fonte dos dados e observações.",
                                    "Crie uma tabela com colunas claras: nome da coluna, tipo de dado (texto, número, data), e exemplo de valor.",
                                    "Valide o esquema simulando 3 entradas de dados fictícios para garantir completude.",
                                    "Documente o esquema em um arquivo separado para referência futura."
                                  ],
                                  "verification": "Esquema documentado com pelo menos 5 colunas, incluindo metadados, e 3 exemplos preenchidos corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Planilha vazia (Google Sheets ou Excel)",
                                    "Exemplos de dados de simulações discretas"
                                  ],
                                  "tips": [
                                    "Priorize colunas que permitam reconstruir a sequência temporal dos eventos.",
                                    "Use nomes de colunas em inglês ou padronizados para compatibilidade futura."
                                  ],
                                  "learningObjective": "Compreender e projetar estruturas de dados que suportem rastreabilidade e análise posterior.",
                                  "commonMistakes": [
                                    "Omitir timestamps precisos",
                                    "Usar nomes de colunas vagos ou duplicados",
                                    "Ignorar tipos de dados inconsistentes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar o Ambiente de Registro de Dados",
                                  "subSteps": [
                                    "Escolha a ferramenta: planilha (Excel/Google Sheets) para iniciantes ou banco simples (SQLite via ferramenta online).",
                                    "Crie uma nova planilha/tabela e adicione as colunas conforme o esquema definido.",
                                    "Formate células: data/hora para timestamps (formato ISO 8601), números para valores quantitativos, texto para observações.",
                                    "Adicione formatação condicional para destacar entradas incompletas (ex: células vazias em vermelho).",
                                    "Teste inserindo uma linha de dados fictícios e salve o arquivo."
                                  ],
                                  "verification": "Planilha configurada com formatação correta e uma linha de teste salva sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Google Sheets ou Microsoft Excel",
                                    "Ferramenta de BD simples como DB Browser for SQLite (opcional)",
                                    "Esquema do Step 1"
                                  ],
                                  "tips": [
                                    "Use fórmulas automáticas para gerar IDs sequenciais (ex: =ROW()).",
                                    "Habilite versionamento automático na planilha para histórico."
                                  ],
                                  "learningObjective": "Configurar ferramentas digitais para captura estruturada de dados com suporte a metadados.",
                                  "commonMistakes": [
                                    "Formatos de data inconsistentes",
                                    "Não testar inserções antes da coleta real",
                                    "Planilhas sem backup automático"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Coletar e Registrar Dados com Metadados",
                                  "subSteps": [
                                    "Inicie a coleta: registre cada evento discreto imediatamente ao observá-lo.",
                                    "Preencha timestamp usando função NOW() ou relógio preciso no momento exato.",
                                    "Adicione ID único, valores principais e metadados (fonte, observações relevantes).",
                                    "Registre pelo menos 10 entradas reais ou simuladas, mantendo ordem cronológica.",
                                    "Pause periodicamente para revisar entradas recentes por completude."
                                  ],
                                  "verification": "Pelo menos 10 linhas preenchidas com todos os campos obrigatórios, timestamps em ordem crescente.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Ambiente configurado do Step 2",
                                    "Fonte de dados reais (ex: simulação manual de sistema discreto)",
                                    "Relógio cronometrado"
                                  ],
                                  "tips": [
                                    "Registre em tempo real para evitar erros de memória.",
                                    "Use atalhos de teclado para agilizar entradas repetitivas."
                                  ],
                                  "learningObjective": "Executar registro preciso de dados em tempo real, incorporando metadados para rastreabilidade.",
                                  "commonMistakes": [
                                    "Timestamps aproximados em vez de exatos",
                                    "Pular metadados em entradas apressadas",
                                    "Desordem nas linhas de registro"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar Rastreabilidade e Preparar para Análise",
                                  "subSteps": [
                                    "Ordene os dados por timestamp e verifique sequência lógica dos eventos.",
                                    "Crie uma coluna derivada para validar (ex: soma cumulativa ou gráfico simples).",
                                    "Simule análise: filtre por ID ou período e reconstrua narrativa dos eventos.",
                                    "Identifique e corrija inconsistências (ex: gaps em timestamps).",
                                    "Exporte para CSV e gere um relatório resumido de metadados."
                                  ],
                                  "verification": "Relatório de validação gerado confirmando rastreabilidade completa de todas as entradas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha com dados do Step 3",
                                    "Ferramentas de gráfico (Sheets/Excel)",
                                    "Editor de texto para relatório"
                                  ],
                                  "tips": [
                                    "Use filtros e pivôs para testes rápidos de rastreabilidade.",
                                    "Sempre inclua hash ou checksum para integridade futura."
                                  ],
                                  "learningObjective": "Garantir que os dados estruturados permitam análise posterior sem perda de contexto.",
                                  "commonMistakes": [
                                    "Não ordenar por tempo",
                                    "Ignorar gaps ou outliers",
                                    "Exportar sem validação prévia"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado (sistema discreto), registre: ID do cliente (sequencial), timestamp de chegada, tempo de serviço, itens comprados e observação (ex: 'fila prioritária usada'). Use Google Sheets para capturar 20 chegadas reais durante 30 minutos, permitindo reconstruir o fluxo da fila por hora.",
                              "finalVerifications": [
                                "Pode ordenar dados por timestamp e recriar a sequência exata de eventos.",
                                "Todos os registros incluem metadados completos (ID, timestamp, fonte).",
                                "Filtro por período recupera subconjunto coerente sem lacunas inexplicáveis.",
                                "Gráfico temporal dos dados reflete lógica do sistema simulado.",
                                "Exportação para CSV preserva estrutura e tipos de dados.",
                                "Simulação de análise (ex: média de tempos) produz resultados válidos."
                              ],
                              "assessmentCriteria": [
                                "Completude: 100% das colunas preenchidas em todas as entradas.",
                                "Precisão: Timestamps exatos e IDs únicos sem duplicatas.",
                                "Rastreabilidade: Sequência temporal permite reconstrução narrativa.",
                                "Estrutura: Esquema segue boas práticas (tipos corretos, nomes claros).",
                                "Eficiência: Tempo de registro por entrada < 30 segundos após setup.",
                                "Validação: Relatório final identifica e corrige 100% das inconsistências."
                              ],
                              "crossCurricularConnections": [
                                "Ciência da Computação: Conceitos de bancos de dados relacionais e normalização.",
                                "Estatística: Preparação de datasets para análise descritiva e inferencial.",
                                "Programação: Integração com scripts para automação de logging (ex: Python pandas).",
                                "Física/Engenharia: Registro em experimentos de sistemas dinâmicos discretos.",
                                "Gestão de Projetos: Documentação rastreável para relatórios e auditorias."
                              ],
                              "realWorldApplication": "Em pesquisas científicas (ex: logging de partículas em aceleradores), desenvolvimento de software (logs de eventos para debugging), ou indústrias (rastreamento de produção em linhas de montagem), onde dados estruturados com timestamps habilitam análise preditiva, auditoria e otimização de processos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.2",
                        "name": "Processamento e Limpeza de Dados",
                        "description": "Tratamento inicial dos dados coletados para remover inconsistências, tratar valores ausentes e preparar o conjunto para análise estatística, assegurando qualidade para modelagem de simulação discreta.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.2.1",
                            "name": "Detectar e Tratar Valores Ausentes",
                            "description": "Identificar dados faltantes em séries temporais de eventos discretos e aplicar técnicas como imputação por média ou interpolação linear, preservando a integridade estatística do conjunto.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Carregar Dataset e Detectar Valores Ausentes",
                                  "subSteps": [
                                    "Instale bibliotecas: pip install pandas numpy matplotlib seaborn",
                                    "Carregue o dataset de série temporal discreta usando pd.read_csv('dados_eventos.csv', parse_dates=['timestamp'], index_col='timestamp')",
                                    "Execute df.isnull().sum() e df.isnull().mean() * 100 para contar e calcular proporção de missings por coluna",
                                    "Visualize missings com sns.heatmap(df.isnull()) e df.plot() para identificar padrões temporais",
                                    "Gere relatório resumido com pd.concat([df.isnull().sum(), df.isnull().mean()*100], axis=1)"
                                  ],
                                  "verification": "Relatório gerado confirmando detecção precisa de todos os valores ausentes, com contagens e porcentagens exibidas.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "Pandas",
                                    "NumPy",
                                    "Matplotlib",
                                    "Seaborn",
                                    "Dataset CSV de exemplo com missings em série temporal discreta"
                                  ],
                                  "tips": [
                                    "Verifique o índice temporal com df.index para garantir ordem cronológica",
                                    "Use df.info() para overview inicial dos tipos de dados",
                                    "Salve visualizações para documentação"
                                  ],
                                  "learningObjective": "Carregar dados de séries temporais discretas e quantificar valores ausentes de forma precisa.",
                                  "commonMistakes": [
                                    "Confundir valores zero com NaN",
                                    "Ignorar missings em colunas não-numéricas",
                                    "Não converter timestamp para índice adequado"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Padrões e Mecanismos de Missing Data",
                                  "subSteps": [
                                    "Classifique o mecanismo: MCAR (teste Little's MCAR), MAR (padrões por covariates), MNAR (ausência informativa)",
                                    "Plote a série temporal com df.plot() e adicione marcadores para missings para visualizar gaps",
                                    "Calcule estatísticas condicionais: médias antes/depois de missings com groupby ou rolling",
                                    "Avalie impacto: compare distribuições com e sem missings usando boxplots lado a lado",
                                    "Documente decisão: imputação viável se <30% missings e mecanismo não-MNAR severo"
                                  ],
                                  "verification": "Relatório escrito descrevendo mecanismo de missing data e recomendação de tratamento.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "Pandas",
                                    "NumPy",
                                    "Matplotlib",
                                    "Seaborn",
                                    "SciPy para testes MCAR"
                                  ],
                                  "tips": [
                                    "Procure padrões cíclicos em eventos discretos como falhas de sensores",
                                    "Use resample() para agregações temporais",
                                    "Considere contexto da simulação para classificar MNAR"
                                  ],
                                  "learningObjective": "Interpretar causas e impactos de valores ausentes em séries temporais discretas.",
                                  "commonMistakes": [
                                    "Assumir sempre MCAR sem teste",
                                    "Ignorar autocorrelação temporal nos padrões",
                                    "Superestimar viabilidade de imputação em >50% missings"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Imputação por Média",
                                  "subSteps": [
                                    "Calcule a média global ou rolling: mean_val = df.mean() ou df.rolling(window=5).mean().mean()",
                                    "Aplique imputação: df_imputed_mean = df.fillna(method='ffill').fillna(mean_val) para eventos discretos",
                                    "Gere cópia backup: df_original = df.copy()",
                                    "Visualize antes/depois: pd.concat([df_original, df_imputed_mean], axis=1).plot()",
                                    "Salve dataset imputado: df_imputed_mean.to_csv('dados_media_imputados.csv')"
                                  ],
                                  "verification": "Dataset resultante sem NaNs e média preservada dentro de 1% do original.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "Pandas",
                                    "NumPy"
                                  ],
                                  "tips": [
                                    "Use janela rolling para séries com tendência",
                                    "Combine ffill/bfill com média para bordas",
                                    "Evite média global em séries não-estacionárias"
                                  ],
                                  "learningObjective": "Implementar imputação por média adaptada a séries temporais discretas.",
                                  "commonMistakes": [
                                    "Usar média incluindo NaNs",
                                    "Aplicar em séries com forte tendência sem ajuste",
                                    "Não tratar bordas da série"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Interpolação Linear",
                                  "subSteps": [
                                    "Prepare índice numérico: df['index_num'] = range(len(df)) se não temporal contínuo",
                                    "Aplique interpolação: df_imputed_linear = df.interpolate(method='linear', limit_direction='both')",
                                    "Para eventos discretos, use time-based: df.interpolate(method='time') se index datetime",
                                    "Visualize fits: df.plot() com linhas conectando pontos interpolados",
                                    "Salve: df_imputed_linear.to_csv('dados_linear_imputados.csv')"
                                  ],
                                  "verification": "Dataset sem NaNs e gráfico mostrando interpolação suave sem saltos artificiais.",
                                  "estimatedTime": "25-40 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "Pandas"
                                  ],
                                  "tips": [
                                    "'limit_direction=both' para extrapolar bordas",
                                    "Combine com ffill para gaps grandes",
                                    "Verifique se preserva monotonicidade em tempos de eventos"
                                  ],
                                  "learningObjective": "Executar interpolação linear preservando continuidade em séries discretas.",
                                  "commonMistakes": [
                                    "Interpolação em gaps muito grandes (>10 pontos)",
                                    "Ignorar que linear assume tendência linear",
                                    "Não usar método='time' para índices datetime"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar Integridade Estatística e Comparar Métodos",
                                  "subSteps": [
                                    "Compare estatísticas: pd.DataFrame({'Original': df_original.describe(), 'Media': df_imputed_mean.describe(), 'Linear': df_imputed_linear.describe()})",
                                    "Testes: from scipy.stats import ks_2samp; ks_2samp(df_original.dropna(), df_imputed_mean)",
                                    "Análise de resíduos: (df_imputed - df_original).plot() para artefatos",
                                    "Métricas de qualidade: MAE entre original e imputado nos pontos conhecidos",
                                    "Selecione melhor método baseado em KS p-value >0.05 e baixa variância introduzida"
                                  ],
                                  "verification": "Relatório de validação mostrando preservação estatística (p-value >0.05 em testes).",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "Pandas",
                                    "NumPy",
                                    "SciPy",
                                    "Matplotlib"
                                  ],
                                  "tips": [
                                    "Priorize KS test para distribuições",
                                    "Use ACF para autocorrelação preservada",
                                    "Documente escolha final com justificativa"
                                  ],
                                  "learningObjective": "Avaliar e garantir que imputações não distorcem propriedades estatísticas.",
                                  "commonMistakes": [
                                    "Comparar apenas médias ignorando variância",
                                    "Não testar em subconjuntos conhecidos",
                                    "Aceitar imputação sem métricas quantitativas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de sistema de filas para loja de varejo, dataset de tempos de chegada de clientes: index=[10:00, 10:05, 10:10, 10:15, 10:20, 10:25, 10:30], valores=[1, 2, NaN, 4, NaN, 6, 7]. Detecte 2 NaNs (28.6%). Imputação média: média=4, NaNs→4. Interpolação linear: 10:10→3 (entre 2 e 4), 10:20→5 (entre 4 e 6). Valide: médias originais ~4 preservadas, gráficos suaves.",
                              "finalVerifications": [
                                "Nenhum valor NaN restante no dataset final.",
                                "Estatísticas descritivas (média, mediana, desvio padrão) variam <5% pré/pós-imputação.",
                                "Gráficos de série temporal mostram continuidade sem artefatos visíveis.",
                                "Testes KS confirmam distribuições similares (p>0.05).",
                                "Autocorrelação preservada em lags 1-5.",
                                "Métricas de erro (MAE) <10% nos pontos conhecidos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção: 100% dos missings identificados corretamente.",
                                "Escolha adequada de método: Justificada pelo mecanismo de missing data.",
                                "Preservação estatística: Variação <5% em momentos centrais.",
                                "Eficiência computacional: Código executa em <5 minutos para 10k pontos.",
                                "Documentação: Relatórios e visualizações claras incluídos.",
                                "Robustez: Funciona com diferentes proporções de missings (10-30%)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística Descritiva: Cálculo de médias e testes de hipóteses.",
                                "Programação em Python: Manipulação de DataFrames e visualizações.",
                                "Análise de Séries Temporais: Interpolação e autocorrelação.",
                                "Simulação de Eventos Discretos: Aplicação em modelagem de filas e processos.",
                                "Ciência de Dados: Limpeza e pré-processamento de dados reais."
                              ],
                              "realWorldApplication": "Em simulações de tráfego urbano com dados de sensores IoT que falham intermitentemente, imputar tempos de chegada de veículos permite modelar congestionamentos precisos, otimizando semáforos e reduzindo atrasos em 15-20%."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.2.2",
                            "name": "Remover Outliers e Ruídos",
                            "description": "Aplicar testes estatísticos, como boxplot ou Z-score, para detectar e eliminar outliers em dados de tempos de serviço ou chegadas, evitando distorções nos parâmetros do modelo de simulação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e Visualizar os Dados Iniciais",
                                  "subSteps": [
                                    "Carregue o conjunto de dados em um ambiente de programação como Python com pandas.",
                                    "Realize uma análise exploratória inicial: calcule estatísticas descritivas (média, mediana, desvio padrão).",
                                    "Crie visualizações básicas como histograma e boxplot preliminar para identificar distribuições e potenciais outliers.",
                                    "Documente as características dos dados, como tamanho da amostra e contexto (ex: tempos de serviço).",
                                    "Salve uma cópia dos dados originais para comparação posterior."
                                  ],
                                  "verification": "Confirme que o histograma e boxplot foram gerados e salvos, e estatísticas descritivas foram calculadas e exibidas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python com pandas, numpy, matplotlib/seaborn",
                                    "Jupyter Notebook",
                                    "Dataset de exemplo (ex: tempos de chegada CSV)"
                                  ],
                                  "tips": [
                                    "Use plt.boxplot() para visualização rápida; sempre rotule eixos claramente.",
                                    "Comece com visualizações para intuição antes de cálculos."
                                  ],
                                  "learningObjective": "Compreender a estrutura dos dados e identificar padrões visuais iniciais de outliers.",
                                  "commonMistakes": [
                                    "Ignorar valores auscentes antes da visualização.",
                                    "Usar escalas inadequadas nos gráficos que mascaram outliers.",
                                    "Não salvar cópia original dos dados."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escolher e Aplicar Método de Detecção: Z-Score",
                                  "subSteps": [
                                    "Calcule o Z-score para cada ponto de dados: (x - média) / desvio padrão.",
                                    "Defina um limiar padrão (ex: |Z| > 3 para outliers extremos).",
                                    "Identifique pontos com Z-score acima do limiar e liste-os.",
                                    "Crie uma máscara booleana para marcar outliers potenciais.",
                                    "Visualize os dados com Z-scores destacados."
                                  ],
                                  "verification": "Gere uma lista ou DataFrame dos índices e valores dos outliers detectados via Z-score.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python com pandas, numpy, scipy.stats",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": [
                                    "Use numpy.abs(z_scores) > 3 para detecção simétrica.",
                                    "Ajuste limiar baseado no domínio (ex: 2.5 para dados normais)."
                                  ],
                                  "learningObjective": "Dominar o cálculo e interpretação do Z-score para detecção quantitativa de outliers.",
                                  "commonMistakes": [
                                    "Calcular Z-score em dados não normalizados ou categóricos.",
                                    "Confundir Z-score com percentis.",
                                    "Aplicar limiar fixo sem considerar tamanho da amostra."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Escolher e Aplicar Método de Detecção: Boxplot (IQR)",
                                  "subSteps": [
                                    "Calcule quartis: Q1 (25%), Q3 (75%) e IQR = Q3 - Q1.",
                                    "Defina limites: inferior = Q1 - 1.5*IQR, superior = Q3 + 1.5*IQR.",
                                    "Identifique outliers como valores fora desses limites.",
                                    "Compare resultados com Z-score para validação cruzada.",
                                    "Atualize a visualização do boxplot destacando outliers."
                                  ],
                                  "verification": "Exiba boxplot com outliers plotados separadamente e liste os valores detectados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python com pandas, matplotlib/seaborn",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": [
                                    "Use seaborn.boxplot() para boxplots mais informativos.",
                                    "Ajuste multiplicador de IQR (ex: 3 para outliers extremos)."
                                  ],
                                  "learningObjective": "Aplicar método não paramétrico do boxplot para detecção robusta de outliers.",
                                  "commonMistakes": [
                                    "Usar 1.5*IQR rigidamente sem contexto de assimetria.",
                                    "Ignorar múltiplos boxplots para comparação.",
                                    "Confundir whiskers com outliers."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Decidir Tratamento e Remover Outliers",
                                  "subSteps": [
                                    "Avalie outliers: verifique se são erros de medição, ruídos ou variações reais.",
                                    "Decida estratégia: remoção simples, imputação ou transformação (ex: winsorização).",
                                    "Crie um novo dataset filtrado removendo outliers confirmados.",
                                    "Registre justificativa para cada remoção (ex: 'valor impossível no contexto').",
                                    "Salve o dataset limpo."
                                  ],
                                  "verification": "Compare estatísticas descritivas antes/depois e confirme redução de distorções (ex: média estabilizada).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com pandas",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": [
                                    "Priorize remoção apenas se >1-5% dos dados; senão, investigue causas.",
                                    "Use df.drop() com índices específicos."
                                  ],
                                  "learningObjective": "Avaliar criticamente outliers e aplicar tratamento apropriado sem perda excessiva de informação.",
                                  "commonMistakes": [
                                    "Remover todos os outliers automaticamente sem análise.",
                                    "Remover outliers legítimos que representam variabilidade real.",
                                    "Não documentar decisões de remoção."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar Limpeza e Analisar Impacto",
                                  "subSteps": [
                                    "Reexecute estatísticas descritivas e visualizações no dataset limpo.",
                                    "Compare parâmetros (média, variância) antes/depois para confirmar correção de distorções.",
                                    "Teste robustez: simule uso em modelo de simulação (ex: distribuição de tempos).",
                                    "Gere relatório resumido com métricas de mudança.",
                                    "Arquive datasets e código para reprodutibilidade."
                                  ],
                                  "verification": "Demonstre que parâmetros do modelo (ex: média de tempos) mudaram significativamente para valores realistas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python com pandas, matplotlib",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": [
                                    "Use paired t-test para validar diferenças significativas.",
                                    "Sempre valide com domínio experto."
                                  ],
                                  "learningObjective": "Verificar eficácia da limpeza e seu impacto em análises subsequentes de simulação.",
                                  "commonMistakes": [
                                    "Assumir limpeza perfeita sem comparações quantitativas.",
                                    "Ignorar efeitos em subgrupos de dados.",
                                    "Não testar em pipeline de simulação."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um dataset de tempos de chegada de clientes a um caixa de supermercado (CSV com 1000 entradas), detecte outliers como tempos > 30min (possíveis erros de registro). Use Z-score para identificar 5 valores extremos, remova-os via boxplot confirmação, resultando em média reduzida de 8.2min para 4.5min, evitando superestimação em modelo de fila simulada.",
                              "finalVerifications": [
                                "Dataset limpo tem estatísticas descritivas realistas (ex: sem valores impossíveis).",
                                "Visualizações mostram distribuição normalizada sem caudas extremas.",
                                "Z-score e boxplot concordam em >90% dos outliers detectados.",
                                "Relatório documenta todas decisões de remoção com justificativas.",
                                "Teste em modelo de simulação mostra parâmetros estáveis (ex: variância <20% original).",
                                "Código é reprodutível e comentado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção: >95% de outliers reais identificados sem falsos positivos excessivos.",
                                "Justificativa contextual: decisões baseadas em domínio, não automáticas.",
                                "Eficiência computacional: código limpo e otimizado.",
                                "Validação completa: comparações antes/depois com métricas quantitativas.",
                                "Documentação: relatório claro com visualizações e conclusões.",
                                "Robustez: método funciona em datasets variados (pequenos/grandes)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística Descritiva: Uso de quartis e desvios para análise exploratória.",
                                "Programação Computacional: Manipulação de dados com pandas e visualização.",
                                "Simulação e Modelagem: Preparação de inputs realistas para Monte Carlo.",
                                "Ciência de Dados: Técnicas de pré-processamento em pipelines ML.",
                                "Qualidade de Dados: Conceitos de integridade e governança de dados."
                              ],
                              "realWorldApplication": "Em simulações de aeroportos, remover outliers de tempos de check-in evita superdimensionamento de filas, otimizando alocação de staff e reduzindo custos operacionais em milhões anualmente."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.2.3",
                            "name": "Normalizar e Transformar Dados",
                            "description": "Realizar transformações como normalização min-max ou logarítmica em variáveis de sistemas discretos para padronizar escalas e facilitar comparações em análises de simulação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos de normalização e transformação de dados",
                                  "subSteps": [
                                    "Estude a definição de normalização Min-Max: (x - min) / (max - min)",
                                    "Aprenda sobre transformação logarítmica: log(x + 1) para valores positivos",
                                    "Identifique quando usar cada uma em sistemas discretos (ex.: escalas diferentes em simulações)",
                                    "Revise distribuições comuns em simulações discretas (Poisson, exponencial)",
                                    "Compare antes/depois com exemplos simples"
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a fórmula Min-Max e um caso para logarítmica",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de normalização (Wikipedia ou Khan Academy)",
                                    "Notebook para anotações",
                                    "Calculadora"
                                  ],
                                  "tips": "Sempre adicione 1 na transformação log para evitar log(0)",
                                  "learningObjective": "Dominar as fórmulas e critérios de aplicação em simulações discretas",
                                  "commonMistakes": [
                                    "Confundir Min-Max com Z-score",
                                    "Aplicar log em zeros sem ajuste",
                                    "Ignorar outliers"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar o conjunto de dados para processamento",
                                  "subSteps": [
                                    "Colete ou simule dados de variáveis discretas (ex.: tempos de chegada em fila)",
                                    "Identifique min, max e valores zero/negativos em cada variável",
                                    "Separe variáveis que precisam de Min-Max (escalas fixas) vs. log (distribuições assimétricas)",
                                    "Crie uma cópia dos dados originais para comparação",
                                    "Visualize dados com histogramas ou boxplots"
                                  ],
                                  "verification": "Dataset preparado com estatísticas descritivas (min, max, média) calculadas e documentadas",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python com Pandas e Matplotlib ou Excel",
                                    "Dataset de exemplo de simulação discreta"
                                  ],
                                  "tips": "Use Pandas df.describe() para estatísticas rápidas",
                                  "learningObjective": "Preparar dados limpos e analisados para transformações seguras",
                                  "commonMistakes": [
                                    "Não tratar valores ausentes",
                                    "Esquecer de identificar variáveis categóricas",
                                    "Alterar dados originais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar normalização Min-Max às variáveis selecionadas",
                                  "subSteps": [
                                    "Calcule min e max da variável alvo",
                                    "Aplique a fórmula Min-Max a cada valor: novo_x = (x - min) / (max - min)",
                                    "Implemente em código ou planilha para todo o dataset",
                                    "Arredonde para 4 casas decimais se necessário",
                                    "Salve a coluna normalizada"
                                  ],
                                  "verification": "Verifique se todos valores estão entre 0 e 1 (min=0, max=1)",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python (Pandas, NumPy): df['norm'] = (df['col'] - df['col'].min()) / (df['col'].max() - df['col'].min())",
                                    "Excel com fórmulas"
                                  ],
                                  "tips": "Use funções vetorizadas no Pandas para eficiência em grandes datasets",
                                  "learningObjective": "Executar normalização Min-Max com precisão em dados de simulação",
                                  "commonMistakes": [
                                    "Dividir por zero (max=min)",
                                    "Não atualizar min/max após remoção de outliers",
                                    "Esquecer de aplicar a todas as instâncias"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar transformação logarítmica e validar resultados",
                                  "subSteps": [
                                    "Selecione variáveis assimétricas (ex.: tempos exponenciais)",
                                    "Aplique log(x + 1) ou log(x) se x > 0",
                                    "Compare distribuições antes/depois (histogramas)",
                                    "Verifique se escalas agora permitem comparações",
                                    "Documente mudanças em relatório"
                                  ],
                                  "verification": "Histogramas mostram distribuição mais normal e escalas padronizadas",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python com NumPy: np.log(df['col'] + 1)",
                                    "Gráficos comparativos"
                                  ],
                                  "tips": "Teste diferentes bases de log (natural vs. base 10) para melhor ajuste",
                                  "learningObjective": "Aplicar logarítmica corretamente e validar impacto em análises",
                                  "commonMistakes": [
                                    "Log de negativos/zero sem shift",
                                    "Não inverter transformação se necessário",
                                    "Ignorar verificação visual"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de sistema de filas em call center: normalize tempos de atendimento (2-15 min) para [0,1] via Min-Max; aplique log(tempo_chegada +1) para tempos exponenciais (1-100 min), facilitando comparação de eficiência entre turnos.",
                              "finalVerifications": [
                                "Dados normalizados estão rigorosamente em [0,1]",
                                "Transformação log resulta em valores finitos e reduz assimetria",
                                "Comparação pré/pós mostra escalas padronizadas",
                                "Código ou fórmulas reproduzíveis sem erros",
                                "Relatório documenta escolhas e resultados",
                                "Teste com novo dado mantém consistência"
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática das transformações (erro < 0.001)",
                                "Seleção adequada de métodos por tipo de variável",
                                "Qualidade da preparação e limpeza de dados",
                                "Efetividade na padronização de escalas (verificação visual)",
                                "Documentação clara e completa",
                                "Eficiência computacional em datasets médios"
                              ],
                              "crossCurricularConnections": [
                                "Estatística: distribuições e testes de normalidade",
                                "Programação: manipulação de dados com Python/Pandas",
                                "Ciência de Dados: pré-processamento para ML",
                                "Simulação: modelagem estocástica em sistemas discretos",
                                "Matemática Aplicada: funções logarítmicas e escalonamento"
                              ],
                              "realWorldApplication": "Em simulações de redes de telecomunicações, normalizar latências e pacotes perdidos para otimizar roteamento; em logística, transformar tempos de entrega para análises comparativas entre rotas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.2.4",
                            "name": "Estruturar Dados em Tabelas de Eventos",
                            "description": "Organizar os dados processados em tabelas de eventos discretos, com colunas para tempo de ocorrência, tipo de evento e atributos associados, prontas para input em softwares de simulação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a Estrutura da Tabela de Eventos",
                                  "subSteps": [
                                    "Identifique os eventos discretos nos dados processados (ex: chegada, partida, falha).",
                                    "Defina colunas obrigatórias: Tempo de Ocorrência (timestamp ou float), Tipo de Evento (string ou enum), Atributos Associados (dict ou colunas específicas como ID, Estado).",
                                    "Especifique tipos de dados para cada coluna (ex: float para tempo, categorical para tipo).",
                                    "Crie o cabeçalho da tabela e defina regras de ordenação (primariamente por tempo crescente).",
                                    "Adicione colunas opcionais como ID do Objeto Envolvido ou Probabilidade, se relevante."
                                  ],
                                  "verification": "Verifique se o cabeçalho possui todas as colunas definidas sem duplicatas e com tipos corretos anotados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Planilha (Excel/Google Sheets)",
                                    "Documentação dos dados processados",
                                    "Papel e caneta para esboço"
                                  ],
                                  "tips": "Sempre priorize tempo como primeira coluna para facilitar ordenação automática.",
                                  "learningObjective": "Compreender e projetar a arquitetura de uma tabela otimizada para eventos discretos em simulações.",
                                  "commonMistakes": [
                                    "Esquecer colunas de atributos variáveis, levando a perda de dados.",
                                    "Não definir tipos de dados, causando erros em importações.",
                                    "Ignorar ordenação por tempo, resultando em simulações incorretas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Mapear Dados Processados para Eventos Discretos",
                                  "subSteps": [
                                    "Revise os dados limpos e identifique sequências que representem eventos (ex: mudança de estado).",
                                    "Crie um mapeamento: associe cada linha ou grupo de dados a um evento específico.",
                                    "Extraia valores para cada coluna: calcule tempos exatos de ocorrência.",
                                    "Registre atributos relevantes para cada evento (ex: tamanho da fila em um evento de chegada).",
                                    "Valide o mapeamento manualmente em uma amostra de 10% dos dados."
                                  ],
                                  "verification": "Confira se 100% dos dados processados foram mapeados sem duplicatas ou omissões.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Dados processados em CSV/JSON",
                                    "Ferramenta de edição (Excel ou Python Pandas)",
                                    "Dicionário de mapeamento"
                                  ],
                                  "tips": "Use filtros condicionais para automatizar extração de mudanças de estado.",
                                  "learningObjective": "Desenvolver habilidade em transformar dados contínuos ou brutos em eventos discretos acionáveis.",
                                  "commonMistakes": [
                                    "Mapear incorretamente tempos, causando sobreposições de eventos.",
                                    "Perder atributos contextuais, como ID de entidade.",
                                    "Criar eventos redundantes de um mesmo dado."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Preencher e Ordenar a Tabela de Eventos",
                                  "subSteps": [
                                    "Insira os dados mapeados linha por linha na tabela seguindo o cabeçalho.",
                                    "Ordene as linhas por Tempo de Ocorrência em ordem crescente.",
                                    "Preencha lacunas ou valores ausentes com defaults apropriados (ex: N/A para atributos).",
                                    "Adicione índices sequenciais para rastreamento.",
                                    "Salve uma versão preliminar da tabela."
                                  ],
                                  "verification": "Execute uma ordenação e verifique se tempos estão em sequência lógica sem gaps injustificados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha ou editor de dados (Pandas)",
                                    "Dados mapeados"
                                  ],
                                  "tips": "Use funções de sort automáticas para evitar erros manuais.",
                                  "learningObjective": "Dominar o preenchimento preciso e ordenação de tabelas para simulações sequenciais.",
                                  "commonMistakes": [
                                    "Inserir dados fora de ordem, invalidando a simulação.",
                                    "Ignorar valores nulos, propagando erros downstream.",
                                    "Duplicar linhas inadvertidamente."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Formatar para Softwares de Simulação",
                                  "subSteps": [
                                    "Verifique consistência: todos eventos têm atributos completos e tempos únicos/monotônicos.",
                                    "Teste importação em um software de simulação (ex: SimPy, AnyLogic demo).",
                                    "Formate para compatibilidade: CSV com delimitadores padrão, sem headers especiais.",
                                    "Gere estatísticas resumidas (ex: contagem por tipo de evento).",
                                    "Documente a tabela com metadados (origem, versão)."
                                  ],
                                  "verification": "Importe com sucesso no software e rode uma simulação teste sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software de simulação (SimPy ou Excel para mock)",
                                    "Ferramenta de exportação (CSV)",
                                    "Validador de dados (Pandas describe())"
                                  ],
                                  "tips": "Sempre teste com subset pequeno antes da tabela completa.",
                                  "learningObjective": "Garantir que a tabela esteja pronta para uso real em pipelines de simulação.",
                                  "commonMistakes": [
                                    "Formatos incompatíveis (ex: vírgula vs ponto em floats).",
                                    "Validações superficiais, ignorando edge cases.",
                                    "Falta de documentação, dificultando reutilização."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado: Colunas [Tempo, Tipo_Evento, Cliente_ID, Tempo_Servico]. Linhas exemplo: [10.5, 'Chegada', 1, null]; [12.0, 'Saida', 1, 1.5]; [11.0, 'Chegada', 2, null]. Tabela ordenada permite simular o caixa corretamente no SimPy.",
                              "finalVerifications": [
                                "Tabela possui colunas exatas: Tempo, Tipo, Atributos (mínimo).",
                                "Linhas ordenadas por Tempo crescente sem duplicatas.",
                                "100% dos dados processados mapeados e sem valores inválidos.",
                                "Importação bem-sucedida em software de simulação teste.",
                                "Estatísticas resumidas geradas (ex: 50 chegadas, 48 saídas).",
                                "Documentação de metadados incluída."
                              ],
                              "assessmentCriteria": [
                                "Precisão do mapeamento de eventos: 95%+ cobertura sem erros.",
                                "Ordenação e formatação corretas: 100% monotônica por tempo.",
                                "Completude de atributos: Nenhum campo obrigatório vazio.",
                                "Compatibilidade com simulação: Teste sem falhas.",
                                "Eficiência: Tempo total dentro de 1.5h para dataset médio.",
                                "Documentação clara e reutilizável."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Manipulação de DataFrames com Pandas para automação.",
                                "Banco de Dados: Modelagem de tabelas relacionais e normalização.",
                                "Estatística: Análise de processos estocásticos e contagens de eventos.",
                                "Engenharia de Software: Preparação de dados para pipelines de ML/Simulação.",
                                "Gestão de Projetos: Documentação e validação de artefatos."
                              ],
                              "realWorldApplication": "Na logística de e-commerce, estruturar eventos de 'chegada de pacote' e 'despacho' em tabelas permite simular gargalos em centros de distribuição, otimizando rotas e reduzindo atrasos em 20%."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.3",
                        "name": "Análise Estatística para Parametrização",
                        "description": "Realizar análises estatísticas nos dados processados para estimar parâmetros como médias, variâncias e distribuições de probabilidade, essenciais para configurar geradores de variáveis aleatórias no modelo de simulação discreta.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.3.1",
                            "name": "Calcular Estatísticas Descritivas",
                            "description": "Computar medidas como média, mediana, desvio padrão e coeficiente de variação para tempos entre chegadas e serviços em sistemas de filas discretos, usando ferramentas como Excel ou Python.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Coletar e Organizar os Dados de Tempos",
                                  "subSteps": [
                                    "Reúna os dados de tempos entre chegadas e serviços de uma simulação de fila discreta (ex: lista de 20-50 valores).",
                                    "Importe os dados para Excel (copie em coluna) ou Python (use pandas para carregar de CSV).",
                                    "Limpe os dados: remova outliers óbvios ou valores negativos, ordene para mediana.",
                                    "Verifique a contagem de dados e calcule N (tamanho da amostra).",
                                    "Salve uma cópia dos dados originais."
                                  ],
                                  "verification": "Dados organizados em uma coluna/lista única, sem erros de formatação, prontos para cálculos.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets",
                                    "Python com bibliotecas pandas e numpy",
                                    "Dados de exemplo de simulação de fila (CSV)"
                                  ],
                                  "tips": "Use funções como SORT() no Excel ou df.sort_values() no Python para facilitar a mediana.",
                                  "learningObjective": "Preparar dados brutos de simulações de filas para análise estatística precisa.",
                                  "commonMistakes": [
                                    "Incluir valores inválidos como negativos",
                                    "Esquecer de ordenar para mediana",
                                    "Não fazer backup dos dados originais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Média e Mediana",
                                  "subSteps": [
                                    "No Excel: Use =AVERAGE(A1:A20) para média e =MEDIAN(A1:A20) para mediana.",
                                    "No Python: np.mean(data) e np.median(data) com import numpy as np.",
                                    "Registre os valores em células/variáveis separadas.",
                                    "Compare manualmente com cálculo simples para 5 primeiros valores para validar.",
                                    "Anote se a distribuição é simétrica (média ≈ mediana)."
                                  ],
                                  "verification": "Valores de média e mediana calculados e validados contra cálculo manual em subconjunto.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Excel com fórmulas",
                                    "Python Jupyter Notebook",
                                    "Documentação de funções numpy/pandas"
                                  ],
                                  "tips": "Para grandes datasets, Python é mais eficiente; teste com dados pequenos primeiro.",
                                  "learningObjective": "Dominar cálculo de medidas de tendência central em contextos de simulação.",
                                  "commonMistakes": [
                                    "Confundir população vs amostra (use funções de amostra)",
                                    "Não ordenar dados antes da mediana manual",
                                    "Arredondar prematuramente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Desvio Padrão",
                                  "subSteps": [
                                    "No Excel: Use =STDEV.S(A1:A20) para desvio padrão amostral.",
                                    "No Python: np.std(data, ddof=1) para desvio padrão amostral.",
                                    "Calcule variância primeiro se desejar: =VAR.S() ou np.var(ddof=1), depois raiz quadrada.",
                                    "Valide com fórmula manual: sqrt(Σ(xi - mean)^2 / (N-1)).",
                                    "Registre o valor e interprete: alto DP indica variabilidade nos tempos."
                                  ],
                                  "verification": "Desvio padrão calculado corretamente, validado com pelo menos um cálculo manual.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Excel fórmulas STDEV/VAR",
                                    "Python numpy",
                                    "Calculadora para validação manual"
                                  ],
                                  "tips": "Sempre use .S para amostra em simulações; ddof=1 no Python garante isso.",
                                  "learningObjective": "Aplicar medidas de dispersão para quantificar variabilidade em tempos de filas.",
                                  "commonMistakes": [
                                    "Usar STDEV.P em vez de STDEV.S",
                                    "Esquecer ddof=1 no Python",
                                    "Confundir variância com desvio padrão"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular Coeficiente de Variação e Interpretar",
                                  "subSteps": [
                                    "Calcule CV = (Desvio Padrão / Média) * 100%. No Excel: =(STDEV.S(A1:A20)/AVERAGE(A1:A20))*100.",
                                    "No Python: (np.std(data, ddof=1) / np.mean(data)) * 100.",
                                    "Interprete: CV < 20% = baixa variabilidade; > 50% = alta, impacta modelagem de filas.",
                                    "Gere um relatório resumido com todos os valores.",
                                    "Compare CV entre chegadas e serviços para insights de simulação."
                                  ],
                                  "verification": "CV calculado, interpretado corretamente, e relatório gerado com todos os stats.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Excel ou Python",
                                    "Template de relatório simples"
                                  ],
                                  "tips": "CV é unitless, ideal para comparar datasets com escalas diferentes.",
                                  "learningObjective": "Usar coeficiente de variação para parametrizar modelos de simulação de filas.",
                                  "commonMistakes": [
                                    "Dividir por mediana em vez de média",
                                    "Esquecer o *100 para porcentagem",
                                    "Ignorar interpretação contextual"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de call center com 10 tempos entre chegadas (minutos): [2, 5, 3, 7, 1, 4, 6, 2, 8, 3]. Média: 4.1 min; Mediana: 3.5 min; DP: 2.18 min; CV: 53.2% (alta variabilidade, sugere necessidade de modelo Poisson). Repita para tempos de serviço.",
                              "finalVerifications": [
                                "Todos os cálculos (média, mediana, DP, CV) batem com validação manual ou ferramenta alternativa.",
                                "Relatório inclui interpretação: ex. 'Alta CV indica chegadas irregulares'.",
                                "Códigos/fórmulas funcionam com novo dataset de teste.",
                                "Diferença entre chegadas e serviços destacada.",
                                "Gráfico simples (boxplot) gerado para visualização."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática: erros < 0.01 nos cálculos.",
                                "Correto uso de ferramentas: fórmulas/códigos sem bugs.",
                                "Interpretação contextual: ligação com simulação de filas.",
                                "Eficiência: tempo dentro do estimado, código limpo.",
                                "Validação: evidência de checagens manuais.",
                                "Relatório claro e completo."
                              ],
                              "crossCurricularConnections": [
                                "Estatística Básica: fundamentos de inferência.",
                                "Programação: manipulação de dados em Python/pandas.",
                                "Engenharia de Produção: modelagem de filas (Teoria de Filas).",
                                "Ciência de Dados: análise exploratória pré-simulação.",
                                "Matemática Aplicada: probabilidades em sistemas discretos."
                              ],
                              "realWorldApplication": "Em otimização de supermercados ou hospitais, calcular CV de tempos de chegada/service parametrizam simulações Monte Carlo para reduzir filas e tempos de espera, economizando custos operacionais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.3.2",
                            "name": "Testar Aderência a Distribuições",
                            "description": "Aplicar testes de bondade de ajuste, como Kolmogorov-Smirnov ou qui-quadrado, para verificar se os dados seguem distribuições comuns em simulações discretas, como exponencial ou Poisson.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparação dos Dados e Seleção do Teste Adequado",
                                  "subSteps": [
                                    "Gerar ou coletar uma amostra de dados simulados de distribuições discretas como Poisson ou exponencial usando Python (ex: numpy.random.poisson).",
                                    "Verificar pré-requisitos: independência das observações, tamanho amostral mínimo (n > 30 para qui-quadrado, n > 20 para KS).",
                                    "Definir a hipótese nula (H0: dados seguem a distribuição especificada) e alternativa (H1: não seguem).",
                                    "Escolher o teste: qui-quadrado para categóricas/discretas observadas vs esperadas; KS para contínuas comparando CDF empírica vs teórica.",
                                    "Instalar e importar bibliotecas: pip install scipy, import scipy.stats as stats."
                                  ],
                                  "verification": "Lista de dados gerada, hipóteses documentadas e bibliotecas importadas sem erros.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python 3.x",
                                    "Jupyter Notebook ou IDE",
                                    "Biblioteca NumPy e SciPy"
                                  ],
                                  "tips": "Use seed para reprodutibilidade: np.random.seed(42).",
                                  "learningObjective": "Identificar pré-condições e selecionar teste apropriado para validação de distribuições.",
                                  "commonMistakes": [
                                    "Amostra muito pequena",
                                    "Ignorar independência das observações",
                                    "Confundir tipos de dados (discreto vs contínuo)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementação do Teste Qui-Quadrado de Bondade de Ajuste",
                                  "subSteps": [
                                    "Calcular frequências observadas (histograma dos dados) e esperadas sob a distribuição assumida (ex: Poisson λ estimado via MLE).",
                                    "Construir tabela de contingência: observadas vs esperadas, garantindo esperadas >5 por célula.",
                                    "Aplicar stats.chisquare(data_obs, data_exp) para obter estatística qui-quadrado e p-valor.",
                                    "Visualizar com histograma e barras esperadas/observadas usando matplotlib.",
                                    "Registrar graus de liberdade (k-1-m, k categorias, m parâmetros estimados)."
                                  ],
                                  "verification": "Estatística qui-quadrado e p-valor calculados; gráfico gerado sem warnings.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "SciPy.stats.chisquare",
                                    "Matplotlib para plots",
                                    "Dados da amostra"
                                  ],
                                  "tips": "Agrupar categorias raras para atender fi >5.",
                                  "learningObjective": "Executar e interpretar teste qui-quadrado para distribuições discretas.",
                                  "commonMistakes": [
                                    "Não estimar parâmetros corretamente",
                                    "Esquecer de agrupar bins vazios",
                                    "Interpretar p-valor ao contrário"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementação do Teste Kolmogorov-Smirnov",
                                  "subSteps": [
                                    "Estimar parâmetros da distribuição (ex: λ para exponencial via média amostral).",
                                    "Aplicar stats.kstest(data, 'expon', args=(scale,)) ou 'poisson' para obter D estatística e p-valor.",
                                    "Gerar QQ-plot (Quantile-Quantile) com stats.probplot para visual inspeção.",
                                    "Comparar CDF empírica vs teórica plotando ambas com matplotlib.",
                                    "Anotar sensibilidade do KS a desvios nas caudas."
                                  ],
                                  "verification": "D e p-valor do KS obtidos; QQ-plot mostra alinhamento linear se H0 verdadeira.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "SciPy.stats.kstest e probplot",
                                    "Matplotlib/Seaborn"
                                  ],
                                  "tips": "KS é não-paramétrico, bom para qualquer contínua; use loc/scale para ajustar.",
                                  "learningObjective": "Aplicar KS para testar aderência em distribuições contínuas ou discretas.",
                                  "commonMistakes": [
                                    "Parâmetros errados no args",
                                    "Confundir com teste de duas amostras",
                                    "Ignorar plots visuais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretação dos Resultados e Conclusão",
                                  "subSteps": [
                                    "Comparar p-valores: se >0.05, não rejeitar H0 (boa aderência); documentar ambos testes.",
                                    "Analisar discrepâncias: qui-quadrado sensível a centro, KS a caudas.",
                                    "Gerar relatório: incluir estatísticas, plots, decisão e confiança.",
                                    "Testar robustez: repetir com diferentes seeds ou tamanhos de amostra.",
                                    "Concluir parametrização para simulação (ex: usar λ estimado se aderente)."
                                  ],
                                  "verification": "Relatório escrito com decisões claras e plots anexados.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Relatório em Markdown ou PDF",
                                    "Todos os códigos anteriores"
                                  ],
                                  "tips": "Sempre combine testes e visuals; p>0.05 não prova H0, só falha em rejeitar.",
                                  "learningObjective": "Interpretar resultados estatísticos e validar modelos de simulação.",
                                  "commonMistakes": [
                                    "Rejeitar H0 baseado só em um teste",
                                    "Ignorar múltiplos testes (ajuste Bonferroni)",
                                    "Concluir causalidade de aderência"
                                  ]
                                }
                              ],
                              "practicalExample": "Em simulação de sistema de filas discretas (supermercado), gere 1000 interchegadas como Poisson(λ=5). Aplique qui-quadrado (discretizado em bins) e KS para verificar se seguem Poisson; plote histogramas e QQ-plot. Se p>0.05, valide λ para modelagem de staffing.",
                              "finalVerifications": [
                                "Ambos testes implementados sem erros de código.",
                                "P-valores calculados e interpretados corretamente (threshold 0.05).",
                                "Gráficos (histograma, QQ-plot, CDF) gerados e analisados.",
                                "Relatório conclui aderência ou sugere ajustes na parametrização.",
                                "Testes repetidos com variação de amostra para robustez.",
                                "Parâmetros estimados via MLE ou momentos coincidem com assumidos."
                              ],
                              "assessmentCriteria": [
                                "Correção técnica na implementação dos testes (40%).",
                                "Qualidade dos visualizações e análise gráfica (20%).",
                                "Interpretação precisa de p-valores e decisões (20%).",
                                "Relatório claro e completo (10%).",
                                "Tratamento de edge cases e robustez (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística Inferencial: Hipóteses, p-valores e testes não-paramétricos.",
                                "Programação Computacional: SciPy/NumPy para análise estatística.",
                                "Simulação e Modelagem: Validação de geradores pseudo-aleatórios.",
                                "Ciência de Dados: Análise exploratória e QQ-plots.",
                                "Probabilidade: Propriedades de distribuições Poisson/Exponencial."
                              ],
                              "realWorldApplication": "Na logística de supply chain, testar se tempos de chegada de pacotes seguem exponencial para calibrar modelos de simulação de filas, otimizando alocação de recursos e reduzindo esperas em 20%."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.3.3",
                            "name": "Estimar Parâmetros de Distribuições",
                            "description": "Estimar parâmetros de distribuições probabilísticas (ex.: λ para exponencial) a partir dos dados reais, utilizando métodos de momentos ou máxima verossimilhança para parametrizar o modelo de simulação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Coleta e Preparação Inicial dos Dados",
                                  "subSteps": [
                                    "Coletar amostra de dados reais relevantes para a distribuição pretendida (ex.: tempos de espera).",
                                    "Realizar limpeza de dados: remover outliers e valores ausentes.",
                                    "Calcular estatísticas descritivas básicas (média, variância, mediana).",
                                    "Visualizar os dados com histograma ou Q-Q plot para confirmar adequação à distribuição.",
                                    "Normalizar os dados se necessário para análise."
                                  ],
                                  "verification": "Dados limpos, estatísticas calculadas e visualizações geradas sem erros.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Conjunto de dados reais (ex.: CSV com 100+ observações)",
                                    "Software: Python (pandas, matplotlib) ou R",
                                    "Planilha Excel para cálculos iniciais"
                                  ],
                                  "tips": "Sempre use pelo menos 30 observações para estimativas confiáveis; plotar histograma ajuda a identificar distribuição.",
                                  "learningObjective": "Preparar dados reais de forma limpa e analisável para estimação de parâmetros.",
                                  "commonMistakes": [
                                    "Ignorar outliers sem justificativa",
                                    "Usar amostras muito pequenas",
                                    "Não visualizar os dados antes da análise"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estimativa de Parâmetros pelo Método dos Momentos",
                                  "subSteps": [
                                    "Identificar os momentos teóricos da distribuição (ex.: para exponencial, E[X] = 1/λ).",
                                    "Calcular momentos amostrais (média amostral como primeiro momento).",
                                    "Igualar momentos teóricos aos amostrais e resolver para os parâmetros (ex.: λ = 1/média).",
                                    "Implementar cálculo em código ou fórmula manual.",
                                    "Registrar o valor estimado e erro padrão aproximado."
                                  ],
                                  "verification": "Parâmetro calculado (ex.: λ) bate com fórmula e código; resultados documentados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Fórmulas de momentos para distribuições comuns",
                                    "Python (numpy para momentos) ou calculadora",
                                    "Notas teóricas da distribuição"
                                  ],
                                  "tips": "Para exponencial, λ é simplesmente o inverso da média; teste com dados simulados primeiro.",
                                  "learningObjective": "Aplicar método dos momentos para obter estimativas simples e rápidas de parâmetros.",
                                  "commonMistakes": [
                                    "Confundir momentos teóricos com amostrais",
                                    "Não resolver corretamente as equações",
                                    "Aplicar a distribuições assimétricas sem ajuste"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estimativa de Parâmetros por Máxima Verossimilhança",
                                  "subSteps": [
                                    "Escrever a função de verossimilhança para a distribuição (ex.: L(λ) = λ^n * exp(-λ * soma xi) para exponencial).",
                                    "Derivar a log-verossimilhança e encontrar o máximo (ex.: λ_MLE = n / soma xi).",
                                    "Implementar numericamente se analítico não disponível (usar otimização).",
                                    "Calcular o parâmetro estimado e intervalo de confiança via bootstrap ou assimptótico.",
                                    "Comparar com método dos momentos."
                                  ],
                                  "verification": "Valor de λ_MLE calculado corretamente; log-likelihood plotada para confirmação.",
                                  "estimatedTime": "1 hora e 30 minutos",
                                  "materials": [
                                    "Biblioteca scipy.optimize (Python) ou optim (R)",
                                    "Dados preparados do Step 1",
                                    "Documentação de MLE para distribuições"
                                  ],
                                  "tips": "Use log-verossimilhança para evitar underflow numérico; bootstrap para IC em amostras pequenas.",
                                  "learningObjective": "Dominar o método de máxima verossimilhança para estimativas eficientes e assintoticamente ótimas.",
                                  "commonMistakes": [
                                    "Esquecer o log na verossimilhança",
                                    "Não maximizar corretamente (minimizar -logL)",
                                    "Ignorar suposições de i.i.d."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validação, Seleção e Aplicação no Modelo de Simulação",
                                  "subSteps": [
                                    "Gerar dados simulados com parâmetros estimados e comparar com dados reais (teste KS ou χ²).",
                                    "Avaliar qual método (momentos ou MLE) se ajusta melhor via AIC/BIC.",
                                    "Selecionar o melhor parâmetro e integrá-lo ao modelo de simulação.",
                                    "Executar simulação preliminar e verificar saídas.",
                                    "Documentar processo e sensibilidade aos parâmetros."
                                  ],
                                  "verification": "Testes estatísticos passam (p-value > 0.05); simulação reproduz dados reais.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Biblioteca scipy.stats para testes KS/χ²",
                                    "Ferramenta de simulação (ex.: SimPy Python)",
                                    "Dados originais para comparação"
                                  ],
                                  "tips": "Use QQ-plots para validação visual; teste sensibilidade variando ±10% no parâmetro.",
                                  "learningObjective": "Validar estimativas e parametrizar modelos de simulação com confiança.",
                                  "commonMistakes": [
                                    "Não testar ajuste goodness-of-fit",
                                    "Escolher método sem comparação",
                                    "Ignorar viés em amostras pequenas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um call center, dados de 100 tempos de atendimento (em minutos): média=5min. Pelo momentos: λ=0.2/min. Pelo MLE: λ=0.198/min. Simular fila com esses λ para prever tempo médio de espera.",
                              "finalVerifications": [
                                "Parâmetros λ estimados por ambos métodos com diferença <5%.",
                                "Teste KS confirma bom ajuste da distribuição simulada aos dados (p>0.05).",
                                "Modelo de simulação parametrizado executa sem erros e reproduz estatísticas reais.",
                                "Documentação inclui fórmulas, código e resultados.",
                                "Intervalo de confiança para λ calculado e razoável.",
                                "Sensibilidade testada: variação de 10% no λ altera saídas em <15%."
                              ],
                              "assessmentCriteria": [
                                "Precisão das estimativas (erro relativo <10% vs. verdadeiros valores simulados).",
                                "Correta implementação de fórmulas e código sem bugs.",
                                "Validação estatística robusta com múltiplos testes.",
                                "Escolha justificada do método (ex.: MLE preferido por eficiência).",
                                "Integração clara no contexto de simulação discreta.",
                                "Documentação completa e reproduzível."
                              ],
                              "crossCurricularConnections": [
                                "Estatística Inferencial: Conceitos de estimadores e verossimilhança.",
                                "Programação Computacional: Uso de NumPy/SciPy para otimização e testes.",
                                "Modelagem de Sistemas: Parametrização em simulações de eventos discretos.",
                                "Análise de Dados: Limpeza e visualização com pandas/matplotlib.",
                                "Probabilidade: Propriedades de distribuições exponencial/Poisson."
                              ],
                              "realWorldApplication": "Parametrizar simulações de filas em bancos/supermercados (tempos de serviço exponenciais), previsão de falhas em engenharia de confiabilidade (tempos entre falhas), ou modelagem de tráfego de rede (pacotes Poisson)."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.3.4",
                            "name": "Visualizar Dados para Insights",
                            "description": "Criar histogramas, gráficos Q-Q e boxplots para visualizar padrões em dados de eventos discretos, auxiliando na identificação de parâmetros e validação preliminar para o modelo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o Conjunto de Dados",
                                  "subSteps": [
                                    "Carregue o dataset de eventos discretos usando pandas (ex: pd.read_csv()).",
                                    "Inspecione os dados com .describe() e .info() para identificar estatísticas básicas e tipos de dados.",
                                    "Limpe os dados removendo valores ausentes ou outliers iniciais com .dropna() ou filtros condicionais.",
                                    "Divida os dados em subconjuntos se necessário (ex: por categorias de eventos).",
                                    "Salve uma cópia limpa para visualizações subsequentes."
                                  ],
                                  "verification": "Execute .head() e .describe() para confirmar que os dados estão limpos e prontos, sem NaNs ou anomalias óbvias.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Python com pandas instalado",
                                    "Dataset de exemplo (ex: tempos de chegada em fila, CSV com 1000+ registros)"
                                  ],
                                  "tips": "Sempre visualize uma amostra pequena primeiro com plt.hist() rápido para validar a carga.",
                                  "learningObjective": "Garantir que os dados estejam prontos para visualização estatística precisa.",
                                  "commonMistakes": [
                                    "Ignorar valores ausentes, levando a distorções",
                                    "Não verificar escalas numéricas inconsistentes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar Histogramas para Distribuição de Frequências",
                                  "subSteps": [
                                    "Importe matplotlib.pyplot e configure o estilo com plt.style.use('seaborn-v0_8').",
                                    "Gere o histograma com plt.hist(dados, bins=30, density=True, alpha=0.7).",
                                    "Adicione rótulos, título e grade com plt.xlabel(), plt.title() e plt.grid().",
                                    "Sobreponha uma curva de densidade KDE com seaborn kdeplot para suavização.",
                                    "Salve o gráfico com plt.savefig('histograma.png')."
                                  ],
                                  "verification": "O histograma exibe barras claras com picos identificáveis e eixo de densidade normalizado.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Bibliotecas: matplotlib, seaborn",
                                    "Jupyter Notebook ou script Python"
                                  ],
                                  "tips": "Escolha bins otimizados com np.histogram_bin_edges(dados, 'fd') para melhor resolução.",
                                  "learningObjective": "Visualizar a distribuição empírica e identificar multimodalidade ou assimetria.",
                                  "commonMistakes": [
                                    "Poucos bins causando perda de detalhes",
                                    "Não normalizar para densidade, distorcendo comparações"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar Gráficos Q-Q para Validação de Distribuição",
                                  "subSteps": [
                                    "Importe scipy.stats e calcule estatísticas teóricas com stats.probplot(dados, dist='norm', plot=plt).",
                                    "Configure o plot Q-Q com plt.figure() e stats.probplot() para distribuição normal ou exponencial.",
                                    "Adicione linha de referência teórica e rótulos com plt.plot() e plt.text().",
                                    "Compare múltiplas distribuições (ex: normal vs. exponencial) em subplots.",
                                    "Interprete desvios nas caudas com anotações manuais."
                                  ],
                                  "verification": "O gráfico Q-Q mostra alinhamento linear nos quantis médios e desvios quantificáveis nas extremidades.",
                                  "estimatedTime": "25-30 minutos",
                                  "materials": [
                                    "Bibliotecas: scipy.stats, matplotlib",
                                    "Dados preparados do Step 1"
                                  ],
                                  "tips": "Use dist='expon' para eventos discretos como chegadas em filas, comum em simulações.",
                                  "learningObjective": "Avaliar aderência a distribuições teóricas para parametrização inicial.",
                                  "commonMistakes": [
                                    "Assumir normalidade sem testar múltiplas distribuições",
                                    "Ignorar desvios nas caudas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir Boxplots para Resumo Estatístico e Outliers",
                                  "subSteps": [
                                    "Use seaborn.boxplot(dados) ou plt.boxplot(dados) para gerar o boxplot básico.",
                                    "Personalize com hue para categorias múltiplas se aplicável (ex: boxplot(x='categoria', y='valor')).",
                                    "Adicione estatísticas resumidas (mediana, Q1, Q3, whiskers) via anotações.",
                                    "Identifique e destaque outliers com filtros e plt.scatter().",
                                    "Combine com violinplot para densidade adicional via sns.violinplot()."
                                  ],
                                  "verification": "Boxplot exibe mediana central, quartis simétricos e outliers marcados corretamente.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Bibliotecas: seaborn, matplotlib",
                                    "Dados categorizados se aplicável"
                                  ],
                                  "tips": "Ajuste whisker limits para 1.5*IQR padrão, mas teste 3*IQR para dados ruidosos.",
                                  "learningObjective": "Detectar variabilidade, assimetria e anomalias para validação preliminar.",
                                  "commonMistakes": [
                                    "Não rotacionar para múltiplas caixas em datasets grandes",
                                    "Confundir whiskers com outliers"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar Insights e Validar para Modelagem",
                                  "subSteps": [
                                    "Compile os três gráficos em um dashboard com subplots (plt.subplots(1,3)).",
                                    "Anote padrões comuns: picos no histograma, linearidade no Q-Q, outliers no boxplot.",
                                    "Extraia parâmetros iniciais (ex: média do histograma para lambda em Poisson).",
                                    "Compare visualmente com distribuições teóricas esperadas para simulação.",
                                    "Documente insights em um relatório Markdown ou notebook cell."
                                  ],
                                  "verification": "Relatório lista 3+ insights acionáveis ligados a parâmetros do modelo.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Todos os gráficos gerados",
                                    "Notebook Jupyter para dashboard"
                                  ],
                                  "tips": "Use plt.tight_layout() para layouts limpos em múltiplos plots.",
                                  "learningObjective": "Integrar visualizações para insights preliminares na parametrização de simulações.",
                                  "commonMistakes": [
                                    "Focar só em um gráfico, ignorando contradições",
                                    "Não quantificar insights numericamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um dataset de 1000 tempos interchegada de clientes em um call center (exponencial simulada), o histograma revela pico em baixos valores, Q-Q confirma exponencial nas caudas, e boxplot destaca 5% de outliers longos, sugerindo lambda ≈ 1/μédia para modelo M/M/1.",
                              "finalVerifications": [
                                "Histogramas identificam pelo menos 2 padrões (ex: pico, cauda longa).",
                                "Q-Q plots mostram aderência qualitativa a distribuição esperada (>80% linearidade).",
                                "Boxplots marcam outliers corretamente e exibem quartis simétricos.",
                                "Dashboard integrado permite comparação visual rápida.",
                                "Insights documentados ligam visualizações a parâmetros iniciais (ex: λ, μ).",
                                "Gráficos salvos em alta resolução sem erros de eixo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na preparação de dados (sem NaNs, escalas corretas): 20%.",
                                "Qualidade visual dos gráficos (rótulos, legendas, clareza): 25%.",
                                "Correta implementação de histogramas, Q-Q e boxplots: 30%.",
                                "Profundidade de interpretação e extração de insights: 15%.",
                                "Integração em dashboard e documentação: 10%."
                              ],
                              "crossCurricularConnections": [
                                "Estatística Descritiva: Cálculo de quartis e testes de normalidade.",
                                "Programação em Python: Manipulação de dados com pandas e plotting.",
                                "Ciência de Dados: Visualização exploratória (EDA) para machine learning.",
                                "Simulação e Modelagem: Validação empírica para Monte Carlo.",
                                "Análise de Sistemas: Aplicação em filas e processos estocásticos."
                              ],
                              "realWorldApplication": "Em logística, visualizar tempos de chegada de caminhões para parametrizar simulações de filas em portos, otimizando alocação de guindastes e reduzindo atrasos em 15-20%."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.3",
                    "name": "Desenvolvimento do Modelo Conceitual",
                    "description": "Criação da representação abstrata e hierárquica do sistema a ser simulado.",
                    "individualConcepts": [
                      {
                        "id": "37.1.2.3.1",
                        "name": "Definição e Importância do Modelo Conceitual",
                        "description": "Compreensão do modelo conceitual como representação abstrata inicial do sistema real, destacando sua relevância nas fases iniciais da modelagem de simulação de sistemas discretos.",
                        "specificSkills": [
                          {
                            "id": "37.1.2.3.1.1",
                            "name": "Identificar objetivos da simulação",
                            "description": "Determinar os objetivos claros e mensuráveis da simulação para guiar a criação do modelo conceitual, considerando o problema real do sistema discreto.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar o Problema Real do Sistema Discreto",
                                  "subSteps": [
                                    "Leia e resuma a descrição do problema real, identificando entidades principais (ex: clientes, servidores).",
                                    "Mapeie os eventos discretos que ocorrem no sistema (ex: chegada, atendimento, saída).",
                                    "Identifique restrições e variáveis chave do sistema (ex: capacidade limitada, tempos variáveis).",
                                    "Liste as dores ou ineficiências atuais observadas no sistema real."
                                  ],
                                  "verification": "Crie um diagrama simples do sistema com entidades e eventos mapeados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Descrição do problema real",
                                    "Papel e caneta ou ferramenta de diagramação como Draw.io"
                                  ],
                                  "tips": "Foque em fatos observáveis, evite suposições prematuras.",
                                  "learningObjective": "Compreender a estrutura e dinâmica do sistema discreto real.",
                                  "commonMistakes": [
                                    "Ignorar eventos raros mas impactantes.",
                                    "Confundir sintomas com causas raiz."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Brainstorm Objetivos Iniciais da Simulação",
                                  "subSteps": [
                                    "Pergunte: 'O que queremos alcançar com a simulação?' (ex: testar cenários, otimizar recursos).",
                                    "Gere uma lista de 5-10 objetivos potenciais baseados na análise do problema.",
                                    "Priorize objetivos alinhados ao problema real, agrupando os semelhantes.",
                                    "Escreva cada objetivo em linguagem simples e ativa."
                                  ],
                                  "verification": "Lista de pelo menos 5 objetivos iniciais documentados em bullet points.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Lista de análise do Step 1",
                                    "Bloco de notas ou Google Docs"
                                  ],
                                  "tips": "Use verbos de ação como 'reduzir', 'aumentar', 'testar' para dinamizar.",
                                  "learningObjective": "Gerar objetivos preliminares relevantes ao contexto da simulação.",
                                  "commonMistakes": [
                                    "Definir objetivos muito amplos ou vagos.",
                                    "Focar apenas em soluções em vez de experimentação."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Refinar Objetivos para Clareza e Mensurabilidade",
                                  "subSteps": [
                                    "Aplique critérios SMART: Specific, Measurable, Achievable, Relevant, Time-bound a cada objetivo.",
                                    "Defina métricas quantitativas (ex: tempo médio < 5 min, taxa de utilização > 80%).",
                                    "Elimine ou funda objetivos redundantes ou não mensuráveis.",
                                    "Reescreva os 3-5 objetivos principais em formato final."
                                  ],
                                  "verification": "Objetivos refinados em formato SMART com métricas explícitas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Lista de objetivos iniciais",
                                    "Tabela SMART template"
                                  ],
                                  "tips": "Quantifique sempre: 'melhorar' vira 'reduzir em 20%'.",
                                  "learningObjective": "Transformar objetivos descritivos em mensuráveis e acionáveis.",
                                  "commonMistakes": [
                                    "Esquecer mensurabilidade, deixando subjetivo.",
                                    "Sobrecarregar com muitos objetivos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Alinhar Objetivos ao Modelo Conceitual",
                                  "subSteps": [
                                    "Verifique se objetivos guiam elementos do modelo conceitual (entidades, estados, eventos).",
                                    "Consulte stakeholders ou documentação para feedback rápido.",
                                    "Ajuste com base em viabilidade de simulação discreta.",
                                    "Documente objetivos finais com justificativa breve."
                                  ],
                                  "verification": "Documento final com objetivos validados e alinhados, pronto para modelagem.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Objetivos refinados",
                                    "Feedback de pares ou auto-revisão checklist"
                                  ],
                                  "tips": "Pergunte: 'Isso pode ser simulado discretamente?'",
                                  "learningObjective": "Garantir que objetivos sejam viáveis e direcionem o modelo conceitual.",
                                  "commonMistakes": [
                                    "Não alinhar com capacidades da simulação.",
                                    "Ignorar feedback externo."
                                  ]
                                }
                              ],
                              "practicalExample": "Para simular um sistema de fila em um supermercado, identifique objetivos como: 'Reduzir o tempo médio de espera na fila para menos de 3 minutos em 95% dos casos' e 'Otimizar o número de caixas para taxa de utilização entre 75-85%', medindo via estatísticas de chegada e serviço.",
                              "finalVerifications": [
                                "Objetivos são específicos e focados no problema real.",
                                "Cada objetivo possui métricas quantitativas claras.",
                                "Objetivos são viáveis para simulação discreta (eventos finitos).",
                                "Lista limitada a 3-5 objetivos priorizados.",
                                "Alinhamento explícito com entidades e eventos do sistema.",
                                "Documentação inclui justificativas breves."
                              ],
                              "assessmentCriteria": [
                                "Clareza: Objetivos legíveis e sem ambiguidades (20%).",
                                "Mensurabilidade: Presença de KPIs numéricos (25%).",
                                "Relevância: Ligação direta ao problema real (20%).",
                                "Viabilidade: Adequação a simulação discreta (20%).",
                                "Completude: Cobertura de aspectos chave sem excessos (15%)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Definição de métricas e KPIs de performance.",
                                "Gestão de Projetos: Uso de critérios SMART para metas.",
                                "Programação: Tradução de objetivos em variáveis de simulação.",
                                "Engenharia de Sistemas: Análise de requisitos funcionais."
                              ],
                              "realWorldApplication": "Em logística, identificar objetivos como 'minimizar atrasos de entrega em 30%' guia simulações de roteirização de veículos, otimizando frotas em empresas como Amazon ou UPS."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "37.1.2.3.1.2",
                            "name": "Diferenciar modelo conceitual de outros modelos",
                            "description": "Explicar as diferenças entre modelo conceitual, modelo lógico e modelo de implementação, enfatizando a abstração do mundo real para simulação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a Definição e Propósito do Modelo Conceitual",
                                  "subSteps": [
                                    "Leia a definição: um modelo conceitual é uma representação abstrata de alto nível do sistema real, focando em entidades, relacionamentos e comportamentos essenciais sem detalhes técnicos.",
                                    "Identifique os componentes principais: entidades, atributos, relações e regras de negócio.",
                                    "Analise como ele abstrai o mundo real, ignorando implementação específica.",
                                    "Estude exemplos simples, como um modelo conceitual de um banco com clientes e contas.",
                                    "Registre em um diagrama simples os elementos chave."
                                  ],
                                  "verification": "Crie um diagrama conceitual básico de um sistema familiar e explique verbalmente seu propósito.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta ou ferramenta de diagramação como Draw.io; leitura sobre modelagem conceitual (UML ou ER).",
                                  "tips": "Comece pelo 'por quê' antes do 'como' para manter o foco na abstração.",
                                  "learningObjective": "Compreender o modelo conceitual como abstração inicial do mundo real.",
                                  "commonMistakes": "Confundir com detalhes de código ou banco de dados; incluir elementos de implementação cedo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o Modelo Lógico e suas Características",
                                  "subSteps": [
                                    "Defina o modelo lógico: refinamento do conceitual com estruturas de dados normalizadas, chaves primárias/estrangeiras e tipos de dados independentes de implementação física.",
                                    "Compare com o conceitual: adiciona precisão lógica sem especificar storage ou queries.",
                                    "Mapeie entidades conceituais para tabelas lógicas com relacionamentos (1:1, 1:N, N:N).",
                                    "Pratique convertendo um diagrama conceitual simples em lógico.",
                                    "Verifique normalização básica (1NF, 2NF)."
                                  ],
                                  "verification": "Transforme um modelo conceitual dado em lógico e identifique adições feitas.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Exemplos de diagramas ER; software como Lucidchart.",
                                  "tips": "Use notação padrão (Crow's Foot) para clareza visual.",
                                  "learningObjective": "Diferenciar o nível lógico como ponte entre conceitual e implementação.",
                                  "commonMistakes": "Misturar tipos de dados físicos (ex: VARCHAR(50)) no lógico."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o Modelo de Implementação",
                                  "subSteps": [
                                    "Defina o modelo de implementação: versão física com detalhes de storage, índices, queries otimizadas e hardware específico.",
                                    "Liste diferenças: inclui DDL SQL, partições, triggers e otimizações de performance.",
                                    "Compare com lógico: traduz estruturas lógicas para código executável em um SGBD específico.",
                                    "Examine um exemplo de script SQL gerado de um modelo lógico.",
                                    "Avalie trade-offs: performance vs. portabilidade."
                                  ],
                                  "verification": "Gere um script de implementação simples de um modelo lógico e explique escolhas físicas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ambiente SQL (MySQL Workbench); exemplos de DDL.",
                                  "tips": "Pense em cenários reais de performance para motivar detalhes físicos.",
                                  "learningObjective": "Reconhecer o modelo de implementação como o mais concreto e dependente de tecnologia.",
                                  "commonMistakes": "Ignorar dependências de vendor (ex: Oracle vs. PostgreSQL)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar e Contrastar os Três Modelos com Ênfase em Abstração",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: colunas para Conceitual, Lógico, Implementação; linhas para abstração, detalhes, independência.",
                                    "Enfatize progressão: mundo real → conceitual (abstração) → lógico (estrutura) → implementação (execução).",
                                    "Discuta benefícios: reutilização, comunicação e escalabilidade.",
                                    "Aplique a um caso: simulação de fila em supermercado em cada nível.",
                                    "Resuma diferenças em um parágrafo conciso."
                                  ],
                                  "verification": "Apresente a tabela comparativa e responda perguntas sobre diferenças chave.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Planilha ou tabela em Markdown; caso de estudo de simulação.",
                                  "tips": "Use setas para mostrar fluxo de refinamento entre modelos.",
                                  "learningObjective": "Diferenciar claramente os modelos e sua progressão na modelagem de simulação.",
                                  "commonMistakes": "Tratar todos como intercambiáveis; subestimar abstração no conceitual."
                                }
                              ],
                              "practicalExample": "Em uma simulação de sistema de filas em um supermercado: Modelo Conceitual (clientes chegam, esperam, são atendidos); Lógico (tabelas Clientes, Filas com FKs); Implementação (tabelas com índices em PostgreSQL, triggers para timestamps).",
                              "finalVerifications": [
                                "Explicar verbalmente as diferenças principais sem consultar notas.",
                                "Classificar corretamente um diagrama dado como conceitual, lógico ou de implementação.",
                                "Converter um modelo conceitual simples para lógico em 10 minutos.",
                                "Identificar 3 erros comuns em uma mistura de níveis de modelo.",
                                "Desenhar tabela comparativa de memória.",
                                "Aplicar conceitos a um novo sistema discreto (ex: tráfego)."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições (90% correto).",
                                "Clareza na distinção de níveis de abstração.",
                                "Uso correto de exemplos e diagramas.",
                                "Compreensão da progressão conceitual-lógico-implementação.",
                                "Capacidade de identificar erros em modelos mistos.",
                                "Profundidade na ênfase à abstração do mundo real."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Mapeamento para OOP (classes conceituais vs. código).",
                                "Engenharia de Software: Ciclo de modelagem em Agile/DevOps.",
                                "Física/Matemática: Abstrações em modelagem de sistemas dinâmicos.",
                                "Gestão de Projetos: Comunicação entre stakeholders via modelos conceituais."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software de simulação (ex: AnyLogic ou Simulink), engenheiros usam modelo conceitual para validar requisitos com clientes, lógico para design de banco e implementação para deploy em produção, garantindo escalabilidade em simulações de logística ou epidemiologia."
                            },
                            "estimatedTime": "45 minutos",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "37.1.2.3.1.3",
                            "name": "Reconhecer limitações da abstração",
                            "description": "Analisar como a abstração no modelo conceitual simplifica o sistema real, identificando potenciais perdas de informação relevantes para simulações discretas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Abstração em Modelos Conceituais",
                                  "subSteps": [
                                    "Defina abstração como o processo de simplificar elementos essenciais de um sistema real para representação em um modelo.",
                                    "Identifique os objetivos da abstração: reduzir complexidade computacional e focar em comportamentos principais.",
                                    "Diferencie abstração de simplificação excessiva, destacando que ela mantém fidelidade aos fenômenos chave.",
                                    "Estude exemplos básicos de abstrações em simulações discretas, como tratar objetos contínuos como estados discretos.",
                                    "Registre os benefícios e trade-offs iniciais da abstração."
                                  ],
                                  "verification": "Escreva uma definição de abstração com pelo menos dois exemplos e um trade-off, revisada por um colega ou autoavaliação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula sobre modelagem conceitual",
                                    "Artigo introdutório sobre simulações discretas",
                                    "Caderno para anotações"
                                  ],
                                  "tips": "Use diagramas Venn para visualizar o que é mantido versus descartado na abstração.",
                                  "learningObjective": "Dominar a definição e propósito da abstração no contexto de modelagem de simulações discretas.",
                                  "commonMistakes": [
                                    "Confundir abstração com eliminação total de detalhes irrelevantes.",
                                    "Ignorar os benefícios da simplificação para a viabilidade computacional.",
                                    "Não diferenciar abstração de aproximação numérica."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever o Sistema Real em Detalhe",
                                  "subSteps": [
                                    "Liste todos os componentes, interações e variáveis do sistema real relevante para a simulação.",
                                    "Classifique variáveis como contínuas, discretas, determinísticas ou estocásticas.",
                                    "Documente dinâmicas temporais e espaciais do sistema real com diagramas ou fluxogramas.",
                                    "Identifique informações sensíveis ou críticas que influenciam o comportamento geral.",
                                    "Compare com documentação existente ou dados empíricos do sistema."
                                  ],
                                  "verification": "Crie um fluxograma detalhado do sistema real e valide com referências bibliográficas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Dados reais ou estudos de caso do sistema",
                                    "Software de diagramação como Draw.io",
                                    "Referências acadêmicas sobre o sistema"
                                  ],
                                  "tips": "Comece pelo macro (visão geral) e refine para micro (detalhes específicos).",
                                  "learningObjective": "Capturar fielmente a complexidade do sistema real como base para análise de abstrações.",
                                  "commonMistakes": [
                                    "Omitir variáveis secundárias que podem se tornar relevantes em cenários extremos.",
                                    "Focar excessivamente em detalhes irrelevantes, perdendo o escopo.",
                                    "Não considerar variabilidade temporal ou estocástica."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Mapear Abstrações e Simplificações no Modelo Conceitual",
                                  "subSteps": [
                                    "Sobreponha o modelo conceitual ao sistema real, destacando quais elementos foram abstraídos.",
                                    "Registre simplificações específicas, como discretização de tempo contínuo ou agregação de estados.",
                                    "Quantifique onde possível as perdas, como redução de dimensionalidade ou suposições de independência.",
                                    "Crie uma tabela comparativa: Sistema Real vs. Modelo Conceitual.",
                                    "Avalie se as abstrações preservam propriedades emergentes do sistema."
                                  ],
                                  "verification": "Gere uma tabela comparativa com pelo menos 5 pares de elementos e discuta com um parceiro.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets para tabelas",
                                    "Modelo conceitual prévio (ID 37.1.2.3.1)",
                                    "Ferramentas de edição de texto"
                                  ],
                                  "tips": "Use cores na tabela: verde para preservado, vermelho para perdido.",
                                  "learningObjective": "Visualizar explicitamente as transformações da abstração no modelo.",
                                  "commonMistakes": [
                                    "Subestimar perdas em interações não-lineares.",
                                    "Assumir que todas as simplificações são neutras.",
                                    "Não mapear feedback loops do sistema real."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar e Avaliar Limitações e Perdas de Informação",
                                  "subSteps": [
                                    "Liste potenciais perdas de informação relevantes para simulações discretas, como granularidade perdida.",
                                    "Analise impactos: precisão, estabilidade numérica ou validade em regimes extremos.",
                                    "Priorize limitações por criticidade usando critérios como frequência de ocorrência e magnitude de erro.",
                                    "Proponha mitigações qualitativas, como refinamento de parâmetros.",
                                    "Documente cenários onde as limitações invalidam o modelo."
                                  ],
                                  "verification": "Elabore um relatório de 1 página listando 4+ limitações com impactos e valide contra um exemplo prático.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Exemplo prático de simulação",
                                    "Checklist de validação de modelos",
                                    "Software de simulação básico como NetLogo"
                                  ],
                                  "tips": "Pergunte: 'O que o modelo ignora que poderia mudar o resultado em 20%?'",
                                  "learningObjective": "Reconhecer limitações específicas da abstração e seu impacto em simulações discretas.",
                                  "commonMistakes": [
                                    "Ignorar perdas cumulativas em simulações longas.",
                                    "Não considerar sensibilidade a parâmetros abstraídos.",
                                    "Superestimar robustez do modelo sem testes."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação discreta de tráfego urbano, o sistema real inclui motoristas com comportamentos imprevisíveis (fadiga, distrações), veículos com desgaste variável e semáforos com falhas. O modelo conceitual abstrai para partículas em grade com velocidades médias e tempos fixos de sinal, perdendo variabilidade humana e falhas, o que subestima congestionamentos em horários de pico reais.",
                              "finalVerifications": [
                                "Pode listar pelo menos 4 limitações específicas da abstração no exemplo dado.",
                                "Explica como uma perda de informação afeta resultados de simulação discreta.",
                                "Cria uma tabela comparativa sistema real vs. modelo com perdas destacadas.",
                                "Identifica cenários onde limitações causam erros >10% na simulação.",
                                "Propõe pelo menos 2 mitigações para limitações identificadas.",
                                "Valida análise com dados empíricos ou literatura."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude na identificação de pelo menos 3 perdas relevantes.",
                                "Análise qualitativa clara do impacto nas simulações discretas.",
                                "Uso de ferramentas visuais (tabelas/diagramas) para clareza.",
                                "Relevância das limitações ao contexto de modelagem conceitual.",
                                "Profundidade na discussão de trade-offs e mitigações.",
                                "Coerência lógica entre sistema real, abstração e limitações."
                              ],
                              "crossCurricularConnections": [
                                "Física: Abstrações em modelagem de dinâmica de partículas e fluidos discretos.",
                                "Ciência da Computação: Limitações em algoritmos de simulação Monte Carlo.",
                                "Estatística: Análise de viés e variância introduzidos por abstrações.",
                                "Engenharia: Validação de modelos em sistemas de controle discretos.",
                                "Filosofia da Ciência: Discussão epistemológica sobre simplificações em teorias científicas."
                              ],
                              "realWorldApplication": "Na previsão de epidemias com simulações discretas (ex: modelo SIR), abstrair contatos humanos para taxas médias perde heterogeneidade de redes sociais, levando a subestimações de surtos e erros em políticas de quarentena, como visto na COVID-19."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "37.1.2.3.2",
                        "name": "Identificação de Componentes do Sistema",
                        "description": "Definição dos elementos fundamentais como entidades, atributos, estados, eventos e atividades no contexto de sistemas discretos.",
                        "specificSkills": [
                          {
                            "id": "37.1.2.3.2.1",
                            "name": "Listar entidades e atributos",
                            "description": "Identificar e catalogar entidades (ex.: clientes, máquinas) e seus atributos (ex.: tempo de chegada, capacidade) em um sistema discreto para simulação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar o Problema e Identificar Entidades Principais",
                                  "subSteps": [
                                    "Leia a descrição do sistema discreto com atenção, destacando componentes ativos e passivos.",
                                    "Desenhe um diagrama simples do fluxo do sistema (ex.: fluxograma ou mapa mental).",
                                    "Liste todas as entidades potenciais, como agentes móveis (clientes) ou recursos fixos (máquinas).",
                                    "Classifique entidades em categorias: ativas (que mudam estado), passivas (que armazenam estado) e recursos.",
                                    "Elimine entidades irrelevantes que não impactam a simulação."
                                  ],
                                  "verification": "Verifique se a lista inicial tem pelo menos 3-5 entidades únicas sem duplicatas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Descrição do problema",
                                    "Papel/caneta ou software de diagramação (ex.: Draw.io)"
                                  ],
                                  "tips": "Comece pelo 'o quê' se move ou muda no sistema; ignore detalhes finos inicialmente.",
                                  "learningObjective": "Reconhecer e catalogar entidades fundamentais em um sistema discreto.",
                                  "commonMistakes": "Confundir entidades com processos ou eventos; listar conceitos abstratos como 'fila' em vez de objetos concretos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Brainstorm e Listar Atributos para Cada Entidade",
                                  "subSteps": [
                                    "Para cada entidade, pergunte: 'Quais propriedades descrevem seu estado?' (ex.: posição, tempo).",
                                    "Liste atributos dinâmicos (que mudam, ex.: tempo de chegada) e estáticos (fixos, ex.: capacidade).",
                                    "Inclua atributos relevantes para eventos: chegada, partida, serviço.",
                                    "Quantifique atributos quando possível (ex.: tempo em minutos, capacidade em unidades).",
                                    "Priorize atributos que afetam o comportamento da simulação."
                                  ],
                                  "verification": "Cada entidade deve ter 3-6 atributos listados com exemplos de valores.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Lista de entidades do Step 1",
                                    "Tabela em planilha (ex.: Google Sheets)"
                                  ],
                                  "tips": "Use perguntas como 'O que preciso saber sobre esta entidade para simular?' para gerar ideias.",
                                  "learningObjective": "Associar atributos mensuráveis e relevantes a entidades específicas.",
                                  "commonMistakes": "Listar atributos genéricos demais (ex.: 'nome') sem relevância para simulação; ignorar atributos temporais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Relações e Refinar a Lista",
                                  "subSteps": [
                                    "Identifique interações: como entidades compartilham atributos ou se afetam mutuamente.",
                                    "Adicione atributos derivados (ex.: tempo de espera = chegada - serviço).",
                                    "Revise para redundâncias e remova ou mescle atributos semelhantes.",
                                    "Formate em tabela: colunas para Entidade, Atributo, Tipo (numérico/booleano), Descrição.",
                                    "Valide com o contexto da simulação: atributos devem suportar eventos discretos."
                                  ],
                                  "verification": "Tabela completa com relações anotadas e sem redundâncias.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela do Step 2",
                                    "Software de tabela (ex.: Excel)"
                                  ],
                                  "tips": "Pense em termos de estado do sistema: atributos definem o estado em cada instante discreto.",
                                  "learningObjective": "Estruturar entidades e atributos de forma relacional e refinada.",
                                  "commonMistakes": "Sobrecarregar com atributos irrelevantes; esquecer relações entre entidades."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Documentar a Lista Final",
                                  "subSteps": [
                                    "Compare a lista com a descrição original do sistema para cobertura completa.",
                                    "Simule mentalmente um ciclo de eventos e verifique se atributos cobrem mudanças.",
                                    "Peça feedback de um par ou anote questões pendentes.",
                                    "Documente em formato JSON ou tabela exportável para uso em modelagem.",
                                    "Registre suposições feitas sobre atributos (ex.: distribuições probabilísticas)."
                                  ],
                                  "verification": "Lista final aprovada, com documentação clara e sem lacunas identificadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Lista refinada do Step 3",
                                    "Template de documentação JSON"
                                  ],
                                  "tips": "Teste com 'e se?': 'E se este atributo mudar, o sistema ainda funciona?'",
                                  "learningObjective": "Garantir robustez e usabilidade da lista para próxima fase de modelagem.",
                                  "commonMistakes": "Pular validação, levando a modelos incompletos; não documentar suposições."
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado: Entidades - Clientes (atributos: ID, tempo_chegada, tempo_serviço_necessário, itens_no_carrinho), Caixas (atributos: ID, status_disponivel, tempo_serviço_atual, capacidade_max_itens). Relação: Clientes se juntam à fila do Caixa disponível.",
                              "finalVerifications": [
                                "Todas entidades principais do sistema estão listadas sem omissões?",
                                "Cada entidade possui pelo menos 3 atributos relevantes e mensuráveis?",
                                "Atributos cobrem estados dinâmicos e estáticos necessários para eventos discretos?",
                                "Lista está formatada em tabela clara com descrições e tipos?",
                                "Relações entre entidades e atributos estão anotadas?",
                                "Suposições sobre atributos estão documentadas?"
                              ],
                              "assessmentCriteria": [
                                "Completude: 90%+ das entidades e atributos essenciais identificados (peso: 30%)",
                                "Relevância: Atributos diretamente ligados à simulação discreta (peso: 25%)",
                                "Estrutura: Uso de tabela ou lista organizada com tipos e descrições (peso: 20%)",
                                "Precisão: Sem redundâncias ou erros conceituais (peso: 15%)",
                                "Documentação: Suposições e relações claras (peso: 10%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Entidades como classes/objetos, atributos como propriedades em linguagens como Python ou Java.",
                                "Banco de Dados: Modelagem ER (Entidade-Relacionamento) para tabelas em SQL.",
                                "Engenharia de Software: Análise de requisitos e modelagem de dados UML.",
                                "Estatística: Atributos para distribuições probabilísticas em simulações Monte Carlo."
                              ],
                              "realWorldApplication": "Na indústria manufatureira, listar entidades (máquinas, peças) e atributos (tempo de processamento, falhas) para simular linhas de produção e otimizar gargalos; em logística, modelar caminhões (atributos: carga, rota) para roteirização eficiente."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "37.1.2.3.1.1"
                            ]
                          },
                          {
                            "id": "37.1.2.3.2.2",
                            "name": "Definir eventos e atividades",
                            "description": "Classificar eventos (ex.: chegada, partida) e atividades (ex.: processamento) que alteram o estado do sistema em modelagem discreta de eventos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender definições fundamentais de eventos e atividades em DES",
                                  "subSteps": [
                                    "Estude a definição de modelagem discreta de eventos (DES): mudanças de estado ocorrem apenas em pontos discretos no tempo.",
                                    "Diferencie eventos (instantâneos, ex.: chegada de cliente) de atividades (duram tempo, ex.: processamento de pedido).",
                                    "Revise exemplos clássicos: filas (chegada/partida como eventos, serviço como atividade).",
                                    "Anote as características principais: eventos alteram estado imediatamente; atividades consomem tempo e recursos.",
                                    "Crie um glossário pessoal com termos chave como 'estado do sistema', 'fila de eventos'."
                                  ],
                                  "verification": "Resuma as diferenças em um parágrafo e compare com definições padrão de um textbook de simulação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Textbook de simulação discreta (ex.: Law & Kelton), notas em papel ou digital.",
                                  "tips": "Use diagramas de Venn para visualizar sobreposições e diferenças.",
                                  "learningObjective": "Diferenciar precisamente eventos de atividades em contextos de DES.",
                                  "commonMistakes": "Confundir atividades com eventos prolongados; ignorar que eventos podem disparar atividades."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar um sistema real para identificar potenciais eventos e atividades",
                                  "subSteps": [
                                    "Escolha um sistema simples, como uma fila de caixa em supermercado.",
                                    "Mapeie o estado do sistema: número de clientes na fila, servidor ocupado ou livre.",
                                    "Liste todos os pontos de mudança: chegada de cliente (evento), início/fim de serviço (eventos), pagamento (atividade).",
                                    "Classifique cada mudança como evento ou atividade baseada na duração e impacto no estado.",
                                    "Desenhe um diagrama de fluxo temporal destacando eventos (pontos) e atividades (setas com duração)."
                                  ],
                                  "verification": "Crie uma tabela com 5+ itens classificados corretamente, sem erros de categorização.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Papel/caneta para diagrama, vídeo de fila real ou simulação online (ex.: AnyLogic free trial).",
                                  "tips": "Observe vídeos reais para capturar dinâmicas autênticas.",
                                  "learningObjective": "Identificar componentes dinâmicos em sistemas observáveis.",
                                  "commonMistakes": "Omitir eventos secundários como 'abandono de fila'; tratar tudo como evento."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir e formalizar eventos e atividades para um modelo conceitual",
                                  "subSteps": [
                                    "Para um sistema dado, defina cada evento: nome, condições de disparo, efeitos no estado (ex.: chegada aumenta fila em 1).",
                                    "Defina atividades: nome, duração (distribuição probabilística), recursos necessários, eventos de início/fim.",
                                    "Priorize eventos: classifique como exógenos (externos, ex.: chegadas) ou endógenos (internos, ex.: partida).",
                                    "Crie uma lista numerada com pelo menos 4 eventos e 3 atividades, incluindo parâmetros iniciais.",
                                    "Valide consistência: certifique-se de que atividades são triggeradas por eventos."
                                  ],
                                  "verification": "Apresente definições em formato tabular e simule manualmente 3 ciclos sem inconsistências.",
                                  "estimatedTime": "1 hora e 15 minutos",
                                  "materials": "Planilha Excel/Google Sheets para tabelas, pseudocódigo para simulação manual.",
                                  "tips": "Use notação formal: Evento E1: Chegada ~ Poisson(λ), Δestado = +1 cliente.",
                                  "learningObjective": "Formalizar definições acionáveis para implementação em software de simulação.",
                                  "commonMistakes": "Definir durações fixas sem considerar variabilidade; faltar dependências entre eventos/atividades."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar e validar eventos/atividades no modelo conceitual completo",
                                  "subSteps": [
                                    "Incorpore eventos e atividades em um modelo conceitual maior: inclua entidades, recursos, filas.",
                                    "Simule cenários: avance tempo para próximo evento, execute atividade se aplicável.",
                                    "Identifique loops e feedback: ex., partida libera servidor para nova atividade.",
                                    "Teste edge cases: sistema vazio, sobrecarga, falhas.",
                                    "Documente o calendário de eventos futuro (future event list) para um ciclo simulado."
                                  ],
                                  "verification": "Execute simulação manual de 10 unidades de tempo e liste estados corretos em cada evento.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software gratuito como Simul8 Community ou papel para simulação stepwise.",
                                  "tips": "Mantenha uma 'fila de eventos' manual para praticar lógica DES.",
                                  "learningObjective": "Construir e validar um modelo conceitual coeso em DES.",
                                  "commonMistakes": "Ignorar ordenação de eventos simultâneos; não atualizar estado corretamente."
                                }
                              ],
                              "practicalExample": "Em uma simulação de call center: Eventos - Chamada chegando (aumenta fila), Agente finaliza chamada (libera agente). Atividades - Atendimento pela duração média de 5 min (distribuição exponencial), ocupando agente.",
                              "finalVerifications": [
                                "Lista completa de 5+ eventos e 3+ atividades com classificações corretas.",
                                "Diagrama de fluxo mostrando triggers e efeitos no estado.",
                                "Simulação manual de 5 ciclos sem erros lógicos.",
                                "Definições formais com parâmetros (taxas, durações).",
                                "Identificação de pelo menos 2 eventos exógenos e 2 endógenos.",
                                "Validação contra exemplo padrão (ex.: fila M/M/1)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção eventos vs. atividades (90%+ correto).",
                                "Completude das definições (inclui efeitos, durações, triggers).",
                                "Consistência lógica no modelo (sem ciclos infinitos ou estados inválidos).",
                                "Uso de terminologia DES padrão.",
                                "Criatividade em exemplos reais e edge cases.",
                                "Clareza na documentação e diagramas."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: Modelagem de chegadas (Poisson) e serviços (Exponencial).",
                                "Programação: Implementação em linguagens como Python (SimPy library).",
                                "Engenharia Industrial: Otimização de filas e recursos em manufatura.",
                                "Ciência da Computação: Algoritmos de gerenciamento de eventos prioritários."
                              ],
                              "realWorldApplication": "Modelagem de sistemas logísticos como aeroportos (chegadas de voos como eventos, handling de bagagem como atividades) para otimizar tempos de espera e alocação de recursos, reduzindo atrasos em 20-30%."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "37.1.2.3.1.1"
                            ]
                          },
                          {
                            "id": "37.1.2.3.2.3",
                            "name": "Mapear recursos e filas",
                            "description": "Descrever recursos compartilhados e mecanismos de fila no modelo conceitual para representar restrições em sistemas de simulação discreta.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar Recursos Compartilhados no Sistema",
                                  "subSteps": [
                                    "Analise a descrição do sistema para listar entidades passivas limitadas, como máquinas, operadores ou espaços.",
                                    "Classifique recursos como compartilhados (usados por múltiplas entidades) ou dedicados (exclusivos).",
                                    "Defina atributos iniciais: capacidade máxima, tempo de setup e regras de alocação.",
                                    "Registre disponibilidade inicial e condições de falha.",
                                    "Crie um inventário tabular com colunas para nome, tipo, capacidade e localização."
                                  ],
                                  "verification": "Verifique se há uma tabela completa com pelo menos 3-5 recursos identificados e seus atributos documentados.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Descrição detalhada do sistema",
                                    "Ferramenta de diagramação (ex: Draw.io)",
                                    "Planilha (Excel ou Google Sheets)"
                                  ],
                                  "tips": "Priorize recursos que causam gargalos observados no sistema real.",
                                  "learningObjective": "Reconhecer e catalogar recursos passivos que impõem restrições ao fluxo do sistema.",
                                  "commonMistakes": [
                                    "Confundir recursos com entidades ativas (ex: clientes como recursos)",
                                    "Subestimar capacidades variáveis por turno"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Detectar Pontos de Formação de Filas",
                                  "subSteps": [
                                    "Identifique estações de trabalho ou processos onde entidades ativas competem por recursos limitados.",
                                    "Mapeie fluxos de chegada de entidades e compare com taxas de processamento dos recursos.",
                                    "Observe discrepâncias que levam a esperas: chegada > processamento.",
                                    "Classifique filas como FIFO, LIFO ou prioridade baseada em regras do sistema.",
                                    "Anote atributos da fila: capacidade máxima, política de rejeição (ex: perda de clientes)."
                                  ],
                                  "verification": "Desenhe um fluxograma simples destacando pelo menos 2 pontos de fila com entradas/saídas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Fluxograma do sistema",
                                    "Dados históricos de observação (se disponível)",
                                    "Software de modelagem (ex: AnyLogic trial)"
                                  ],
                                  "tips": "Use observação empírica ou dados para validar pontos de fila reais.",
                                  "learningObjective": "Localizar restrições dinâmicas que geram filas no modelo conceitual.",
                                  "commonMistakes": [
                                    "Ignorar filas virtuais (esperas não físicas)",
                                    "Assumir filas ilimitadas sem validar capacidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Interações entre Recursos e Filas",
                                  "subSteps": [
                                    "Especifique regras de alocação: qual entidade pega o recurso primeiro da fila?",
                                    "Modele eventos de chegada à fila, espera, alocação e liberação do recurso.",
                                    "Inclua mecanismos de prioridade ou renegociação (ex: interrupções).",
                                    "Defina métricas de monitoramento: tempo médio de espera, comprimento da fila.",
                                    "Integre feedback loops, como expansão de fila afetando chegada upstream."
                                  ],
                                  "verification": "Crie um diagrama de estado mostrando transições recurso-fila para um exemplo específico.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Diagrama de fluxograma expandido",
                                    "Literatura sobre simulação discreta (ex: Law & Kelton)",
                                    "Ferramenta UML ou BPMN"
                                  ],
                                  "tips": "Simule mentalmente um ciclo completo para validar lógica.",
                                  "learningObjective": "Estabelecer dinâmicas de compartilhamento e enfileiramento no modelo.",
                                  "commonMistakes": [
                                    "Definir regras estáticas ignorando variabilidade estocástica",
                                    "Esquecer liberação assíncrona de recursos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Recursos e Filas no Modelo Conceitual",
                                  "subSteps": [
                                    "Atualize o diagrama conceitual com ícones para recursos (retângulos) e filas (setas com buffers).",
                                    "Adicione legendas explicando símbolos e variáveis associadas.",
                                    "Valide consistência: todo uso de recurso leva a uma fila se indisponível.",
                                    "Documente suposições e parametrizações para experimentação futura.",
                                    "Revise com stakeholder para feedback qualitativo."
                                  ],
                                  "verification": "Apresente o modelo conceitual completo com recursos e filas anotados e aprovado por pares.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Modelo conceitual inicial",
                                    "Ferramenta de diagrama (ex: Lucidchart)",
                                    "Checklist de validação"
                                  ],
                                  "tips": "Use cores para diferenciar recursos compartilhados vs. dedicados.",
                                  "learningObjective": "Incorporar recursos e filas de forma coesa no framework conceitual da simulação.",
                                  "commonMistakes": [
                                    "Sobrecarregar o diagrama com detalhes de implementação",
                                    "Omitir conexões bidirecionais fila-recurso"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um supermercado: Caixas registradoras são recursos compartilhados (capacidade 1 cliente por caixa). Clientes formam filas FIFO quando todos caixas ocupados. Atributos: 5 caixas, tempo médio de serviço 3 min, fila máxima 10 clientes com perda se excedida.",
                              "finalVerifications": [
                                "Lista exaustiva de recursos com atributos corretos.",
                                "Diagrama conceitual com filas mapeadas em pontos de restrição.",
                                "Regras de alocação e políticas de fila documentadas.",
                                "Simulação mental de um cenário teste sem inconsistências.",
                                "Métricas de performance associadas a filas definidas.",
                                "Validação cruzada com dados reais ou observações."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de recursos limitantes (80% cobertura).",
                                "Clareza e completude das regras de fila e alocação.",
                                "Consistência lógica no diagrama conceitual.",
                                "Adequação de atributos a variabilidade estocástica.",
                                "Profundidade de documentação para reproducibilidade.",
                                "Integração eficaz com outros componentes do modelo."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: Modelagem de tempos de chegada e serviço (distribuições exponenciais).",
                                "Programação: Implementação em linguagens como Python (SimPy) ou Java.",
                                "Gestão de Operações: Teoria de filas (M/M/1, M/M/c) para análise.",
                                "Engenharia de Software: Design de modelos UML para simulações.",
                                "Economia: Otimização de custos em alocação de recursos escassos."
                              ],
                              "realWorldApplication": "Em logística de manufatura, mapear máquinas CNC como recursos e jobs como filas otimiza agendamento, reduzindo tempo ocioso em 20-30% e backlog de produção."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "37.1.2.3.2.1"
                            ]
                          },
                          {
                            "id": "37.1.2.3.2.4",
                            "name": "Especificar regras de lógica",
                            "description": "Documentar regras de decisão e lógica de controle (ex.: prioridades de serviço) que governam o comportamento das entidades no modelo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar eventos e decisões que requerem regras lógicas",
                                  "subSteps": [
                                    "Analise o diagrama conceitual do sistema para listar todos os eventos discretos (ex.: chegada de entidade, falha de recurso).",
                                    "Identifique pontos de decisão onde o comportamento das entidades varia (ex.: priorizar serviços baseados em tipo de cliente).",
                                    "Mapeie entidades envolvidas e suas interações que dependem de condições.",
                                    "Registre perguntas como 'O que acontece se X ocorrer?' para cada entidade.",
                                    "Crie uma tabela inicial com colunas: Evento, Entidade, Possíveis Decisões."
                                  ],
                                  "verification": "Lista exaustiva de eventos e decisões documentada em tabela ou diagrama de fluxo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Diagrama conceitual do modelo, planilha ou software de diagramação (ex.: Draw.io, Excel)",
                                  "tips": "Use fluxogramas para visualizar ramificações lógicas desde o início.",
                                  "learningObjective": "Reconhecer todos os pontos onde lógica condicional governa o comportamento do sistema.",
                                  "commonMistakes": "Omitir eventos raros ou condições edge cases que afetam a simulação."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir condições e critérios para cada regra",
                                  "subSteps": [
                                    "Para cada decisão identificada, liste condições booleanas (ex.: se tempo de espera > 10min E tipo=urgente).",
                                    "Especifique prioridades ou precedências entre condições (ex.: urgência sobre FIFO).",
                                    "Use operadores lógicos: AND, OR, NOT, para compor critérios complexos.",
                                    "Quantifique critérios sempre que possível (ex.: thresholds numéricos).",
                                    "Valide condições com exemplos hipotéticos de estados do sistema."
                                  ],
                                  "verification": "Cada decisão possui pelo menos 2-3 condições claras e quantificáveis documentadas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Tabela de eventos do passo 1, pseudocódigo editor (ex.: Notion, Google Docs)",
                                  "tips": "Comece com condições simples e refine para complexidade necessária.",
                                  "learningObjective": "Construir expressões lógicas precisas que capturam o comportamento real do sistema.",
                                  "commonMistakes": "Condições vagas ou não quantificáveis, levando a ambiguidades na simulação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Especificar ações e comportamentos resultantes das regras",
                                  "subSteps": [
                                    "Para cada conjunto de condições, defina a ação exata (ex.: atribuir recurso A, alterar estado da entidade).",
                                    "Descreva mudanças de estado das entidades ou recursos afetados.",
                                    "Inclua regras de fallback para condições não cobertas (ex.: default behavior).",
                                    "Garanta que ações sejam atômicas e consistentes com o modelo discreto.",
                                    "Teste logicamente: simule cenários manuais para verificar fluxo."
                                  ],
                                  "verification": "Regras completas no formato 'SE condições ENTÃO ação' para todos os casos.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Pseudocódigo das condições, simulador simples ou papel para fluxos manuais",
                                  "tips": "Escreva regras em formato if-then-else para facilitar implementação futura.",
                                  "learningObjective": "Mapear logicamente condições a ações acionáveis no modelo de simulação.",
                                  "commonMistakes": "Ações conflitantes ou incompletas para cenários múltiplos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Documentar e validar as regras de lógica",
                                  "subSteps": [
                                    "Compile todas as regras em um documento estruturado (tabela ou diagrama de decisão).",
                                    "Revise por cobertura: todas as decisões têm regras? Sem sobreposições?",
                                    "Valide com stakeholders ou cenários reais do sistema modelado.",
                                    "Inclua glossário de termos lógicos e exemplos.",
                                    "Prepare para integração: sugira pseudocódigo para codificação."
                                  ],
                                  "verification": "Documento final aprovado com validação de cobertura 100%.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Documento compilado, checklist de validação",
                                  "tips": "Use tabelas de verdade para regras complexas com múltiplas condições.",
                                  "learningObjective": "Produzir documentação clara e validada de regras lógicas para o modelo conceitual.",
                                  "commonMistakes": "Documentação informal ou sem validação, causando erros na implementação."
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado, regras como: SE cliente tem carrinho grande E fila express < 3 ENTÃO direcione para express; SENÃO vá para fila normal. Isso governa o roteamento de entidades (clientes) baseado em atributos e estado do sistema.",
                              "finalVerifications": [
                                "Todas as entidades e eventos têm regras lógicas associadas.",
                                "Regras cobrem 100% dos cenários identificados, incluindo edge cases.",
                                "Condições são booleanas e quantificáveis.",
                                "Ações resultantes são consistentes e atômicas.",
                                "Documentação permite recriação direta no código de simulação.",
                                "Validação manual confirma ausência de loops infinitos ou ambiguidades."
                              ],
                              "assessmentCriteria": [
                                "Completude: Cobertura total de decisões (peso 25%).",
                                "Precisão lógica: Condições sem ambiguidades (peso 25%).",
                                "Clareza da documentação: Fácil leitura e compreensão (peso 20%).",
                                "Validação: Testes manuais bem-sucedidos (peso 15%).",
                                "Eficiência: Regras otimizadas sem redundâncias (peso 10%).",
                                "Integração: Facilidade para pseudocódigo (peso 5%)."
                              ],
                              "crossCurricularConnections": [
                                "Lógica Proposicional (Matemática): Operadores booleanos e tabelas de verdade.",
                                "Programação Estruturada: Estruturas if-else e switch-case.",
                                "Ciência da Computação: Autômatos finitos em simulações discretas.",
                                "Engenharia de Software: Especificação formal de requisitos.",
                                "Estatística: Probabilidades condicionais em eventos discretos."
                              ],
                              "realWorldApplication": "Em simulações de tráfego urbano para otimizar semáforos (regras baseadas em densidade e prioridade de emergência), ou em manufatura para controle de robôs em linhas de produção (prioridades de tarefas baseadas em falhas e demandas)."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "37.1.2.3.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "37.1.2.3.3",
                        "name": "Construção Hierárquica e Documentação",
                        "description": "Organização hierárquica dos componentes em níveis de abstração e criação de diagramas para comunicação do modelo conceitual.",
                        "specificSkills": [
                          {
                            "id": "37.1.2.3.3.1",
                            "name": "Estruturar hierarquia do modelo",
                            "description": "Organizar componentes em níveis hierárquicos (ex.: subsistemas, módulos) para facilitar a decomposição e reutilização em simulações complexas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e listar componentes principais do modelo",
                                  "subSteps": [
                                    "Analise o problema de simulação para extrair entidades chave (ex.: agentes, processos, recursos).",
                                    "Crie uma lista inicial de todos os componentes sem hierarquia, agrupando itens semelhantes.",
                                    "Defina atributos essenciais para cada componente (ex.: estado, interações).",
                                    "Valide a lista com stakeholders ou requisitos do modelo.",
                                    "Priorize componentes por complexidade e frequência de uso."
                                  ],
                                  "verification": "Lista completa de componentes documentada em um diagrama ou tabela, com pelo menos 5-10 itens principais.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de diagramação (ex.: Draw.io, Lucidchart)",
                                    "Descrição do problema de simulação"
                                  ],
                                  "tips": "Comece pelo nível mais alto (sistema global) e desça gradualmente; use post-its para brainstorm visual.",
                                  "learningObjective": "Dominar a extração sistemática de componentes de um problema de simulação discreta.",
                                  "commonMistakes": [
                                    "Ignorar componentes secundários que afetam o comportamento global.",
                                    "Listar itens muito granulares sem agrupamento inicial.",
                                    "Não considerar interações entre componentes desde o início."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir níveis hierárquicos e relações pai-filho",
                                  "subSteps": [
                                    "Classifique componentes em níveis: superior (subsistemas), médio (módulos), inferior (submódulos).",
                                    "Estabeleça relações hierárquicas: cada componente filho pertence a exatamente um pai.",
                                    "Use critérios como encapsulamento, reutilização e decomposição para justificar níveis.",
                                    "Desenhe um esboço de árvore hierárquica para visualizar a estrutura.",
                                    "Ajuste níveis para equilibrar profundidade (máximo 4-5 níveis) e granularidade."
                                  ],
                                  "verification": "Diagrama de árvore hierárquica com relações pai-filho claras e legendas explicativas.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Ferramenta de modelagem hierárquica (ex.: yEd, Visio)",
                                    "Lista de componentes do Step 1"
                                  ],
                                  "tips": "Aplique o princípio 'single responsibility': cada nó hierárquico tem uma função única.",
                                  "learningObjective": "Aprender a criar estruturas hierárquicas balanceadas para decomposição de modelos complexos.",
                                  "commonMistakes": [
                                    "Criar hierarquias planas sem profundidade suficiente.",
                                    "Permitir múltiplos pais para um filho, violando árvore estrita.",
                                    "Sobrecarregar níveis superiores com detalhes desnecessários."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estabelecer conexões e interfaces entre níveis hierárquicos",
                                  "subSteps": [
                                    "Identifique interfaces de comunicação (ex.: mensagens, eventos) entre componentes de níveis diferentes.",
                                    "Defina regras de reutilização: módulos independentes para uso em outros modelos.",
                                    "Teste a hierarquia simulando fluxos de dados de cima para baixo e vice-versa.",
                                    "Adicione metadados a cada nó (ex.: parâmetros, dependências).",
                                    "Refatore conexões para minimizar acoplamento forte."
                                  ],
                                  "verification": "Mapa de interfaces documentado, com fluxos de dados traçados no diagrama hierárquico.",
                                  "estimatedTime": "2-4 horas",
                                  "materials": [
                                    "Software de simulação protótipo (ex.: Python com NetworkX para grafos)",
                                    "Diagrama do Step 2"
                                  ],
                                  "tips": "Use padrões como 'black box' para tratar subsistemas como unidades opacas com APIs definidas.",
                                  "learningObjective": "Compreender como hierarquias facilitam modularidade e reutilização em simulações.",
                                  "commonMistakes": [
                                    "Ignorar interfaces, levando a hierarquias desconectadas.",
                                    "Alta dependência entre níveis, reduzindo reutilização.",
                                    "Não testar fluxos, resultando em gargalos invisíveis."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Documentar e validar a hierarquia completa",
                                  "subSteps": [
                                    "Gere documentação formal: descrição textual, diagrama final e código de estrutura (se aplicável).",
                                    "Realize revisão por pares ou auto-revisão contra critérios de qualidade.",
                                    "Simule um cenário simples para verificar decomposição e recomposição.",
                                    "Otimize para reutilização: identifique módulos exportáveis.",
                                    "Arquive a hierarquia em repositório versionado."
                                  ],
                                  "verification": "Documento completo com diagrama, testes simulados e relatório de validação aprovados.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Ferramenta de documentação (ex.: Markdown, LaTeX)",
                                    "Ferramenta de versionamento (ex.: Git)"
                                  ],
                                  "tips": "Use UML ou notação específica de simulação para padronizar diagramas.",
                                  "learningObjective": "Finalizar hierarquias com documentação profissional e validação prática.",
                                  "commonMistakes": [
                                    "Documentação incompleta ou desatualizada.",
                                    "Pular validação, assumindo correção teórica.",
                                    "Não versionar, dificultando iterações futuras."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de supermercado discreto: Nível 1 - Supermercado; Nível 2 - Caixas (Registradoras, Filas); Nível 3 - Clientes e Produtos em cada caixa; Nível 4 - Eventos de chegada/partida. Isso permite reutilizar o módulo 'Fila' em simulações de bancos.",
                              "finalVerifications": [
                                "Hierarquia possui 3-5 níveis com pelo menos 10 componentes organizados.",
                                "Cada componente tem interfaces definidas e é reutilizável independentemente.",
                                "Diagrama permite recompor o modelo completo sem ambiguidades.",
                                "Simulação de teste roda sem erros de decomposição.",
                                "Documentação cobre todos os nós com metadados.",
                                "Critérios de qualidade (equilíbrio, modularidade) atendidos."
                              ],
                              "assessmentCriteria": [
                                "Clareza e consistência da estrutura hierárquica (30%).",
                                "Efetividade na decomposição e reutilização (25%).",
                                "Qualidade das interfaces e conexões (20%).",
                                "Documentação completa e profissional (15%).",
                                "Validação prática via simulação (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Estruturas de dados como árvores e grafos (ex.: classes aninhadas em OOP).",
                                "Engenharia de Software: Design modular e arquitetura hierárquica (ex.: microservices).",
                                "Biologia: Taxonomia e cladogramas para classificação hierárquica de espécies.",
                                "Gestão de Projetos: WBS (Work Breakdown Structure) para decomposição de tarefas."
                              ],
                              "realWorldApplication": "Em simulações industriais como supply chain (cadeia de suprimentos), onde hierarquias de armazéns > setores > prateleiras facilitam otimização de logística e escalabilidade para grandes redes de distribuição."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "37.1.2.3.2.1"
                            ]
                          },
                          {
                            "id": "37.1.2.3.3.2",
                            "name": "Criar diagramas conceituais",
                            "description": "Utilizar ferramentas como fluxogramas ou diagramas de entidade-relacionamento para visualizar o modelo conceitual de forma clara e hierárquica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar o modelo conceitual e identificar elementos chave",
                                  "subSteps": [
                                    "Leia a descrição do modelo conceitual e destaque os conceitos principais, entidades e relações.",
                                    "Liste todos os componentes hierárquicos: níveis principais, subcomponentes e dependências.",
                                    "Classifique elementos em categorias como entradas, processos, saídas e fluxos.",
                                    "Crie um brainstorm inicial com palavras-chave e setas provisórias para relações.",
                                    "Priorize elementos por importância hierárquica (topo para base)."
                                  ],
                                  "verification": "Verifique se a lista cobre 100% dos elementos do modelo conceitual sem duplicatas ou omissões.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Descrição do modelo conceitual",
                                    "Papel e caneta ou ferramenta de notas como Notion/OneNote"
                                  ],
                                  "tips": "Use cores diferentes para tipos de elementos (ex: azul para entidades, vermelho para relações).",
                                  "learningObjective": "Identificar e organizar componentes conceituais de forma hierárquica.",
                                  "commonMistakes": [
                                    "Ignorar relações implícitas",
                                    "Listar elementos sem hierarquia",
                                    "Sobrecarregar com detalhes irrelevantes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar o tipo de diagrama e ferramenta apropriada",
                                  "subSteps": [
                                    "Avalie o modelo: escolha fluxograma para processos sequenciais ou DER para entidades relacionais.",
                                    "Pesquise ferramentas: Lucidchart, Draw.io, Visio ou papel para protótipos.",
                                    "Configure a ferramenta: defina canvas, paleta de símbolos e layout hierárquico (top-down).",
                                    "Crie um template básico com caixas para conceitos principais.",
                                    "Teste a ferramenta com um elemento simples para familiarizar."
                                  ],
                                  "verification": "Confirme que o diagrama escolhido representa hierarquia e relações claramente; teste com um mini-exemplo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Acesso a ferramentas online gratuitas como Draw.io",
                                    "Lista de tipos de diagramas"
                                  ],
                                  "tips": "Prefira ferramentas gratuitas e colaborativas para simulações em equipe.",
                                  "learningObjective": "Escolher representações visuais adequadas ao contexto do modelo.",
                                  "commonMistakes": [
                                    "Escolher ferramenta complexa sem necessidade",
                                    "Ignorar hierarquia no layout",
                                    "Usar símbolos inadequados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir o diagrama de forma hierárquica",
                                  "subSteps": [
                                    "Posicione conceitos principais no topo e expanda subníveis abaixo.",
                                    "Adicione setas ou linhas para relações, com rótulos descritivos (ex: 'contém', 'depende de').",
                                    "Use formas consistentes: retângulos para entidades, losangos para decisões.",
                                    "Ajuste layout para evitar cruzamentos e manter fluxo visual claro.",
                                    "Inclua legendas para símbolos e cores usadas."
                                  ],
                                  "verification": "O diagrama deve fluir logicamente do geral ao específico sem ambiguidades.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de diagramação selecionada",
                                    "Lista de elementos do Step 1"
                                  ],
                                  "tips": "Mantenha espaçamento uniforme e zoom out periodicamente para visão geral.",
                                  "learningObjective": "Visualizar relações conceituais de forma clara e hierárquica.",
                                  "commonMistakes": [
                                    "Sobrecarregar com texto longo",
                                    "Cruzar linhas desnecessariamente",
                                    "Perder hierarquia em níveis profundos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Refinar, validar e documentar o diagrama",
                                  "subSteps": [
                                    "Revise por completude: todos elementos e relações incluídos?",
                                    "Peça feedback ou valide contra o modelo original.",
                                    "Adicione anotações, títulos e versão.",
                                    "Exporte em formatos editável e imagem (PNG/PDF).",
                                    "Crie um resumo explicando o diagrama em 1 parágrafo."
                                  ],
                                  "verification": "Diagrama é legível, completo e compreensível por terceiros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama construído",
                                    "Modelo conceitual original"
                                  ],
                                  "tips": "Use versão 1.0 e itere; compartilhe para revisão rápida.",
                                  "learningObjective": "Garantir qualidade e usabilidade do diagrama conceitual.",
                                  "commonMistakes": [
                                    "Pular validação",
                                    "Esquecer legendas",
                                    "Não documentar mudanças"
                                  ]
                                }
                              ],
                              "practicalExample": "Para simular um sistema de filas em um supermercado: topo 'Supermercado' > subníveis 'Caixas' (entidades), 'Clientes' (fluxo de entrada), setas 'Chegada -> Fila -> Atendimento -> Saída', com DER para relações entre produtos e estoques.",
                              "finalVerifications": [
                                "Diagrama captura todos os conceitos principais e relações hierárquicas do modelo.",
                                "Layout é claro, sem cruzamentos excessivos e com fluxo lógico.",
                                "Símbolos e legendas são consistentes e explicados.",
                                "Hierarquia é visualmente evidente do geral ao específico.",
                                "Diagrama é exportado e documentado com resumo.",
                                "Validação externa confirma compreensão sem o texto original."
                              ],
                              "assessmentCriteria": [
                                "Clareza visual e legibilidade (espaçamento, cores, fontes).",
                                "Precisão na representação hierárquica e relações.",
                                "Completude: todos elementos do modelo incluídos.",
                                "Adequação da ferramenta e tipo de diagrama escolhido.",
                                "Documentação e anotações de suporte.",
                                "Criatividade na visualização sem perda de fidelidade."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Diagramas de fluxo para algoritmos em Python/SimPy.",
                                "Design Gráfico: Princípios de UX/UI em ferramentas como Figma.",
                                "Gestão de Projetos: Mapas mentais em metodologias Ágeis.",
                                "Biologia: Diagramas de redes ecológicas ou cadeias alimentares.",
                                "Engenharia: Modelagem UML para sistemas discretos."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, diagramas conceituais como ERDs são usados para projetar bancos de dados em simulações de tráfego ou logística, facilitando comunicação entre equipes e reduzindo erros em implementações de simulações discretas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "37.1.2.3.2.3"
                            ]
                          },
                          {
                            "id": "37.1.2.3.3.3",
                            "name": "Documentar o modelo conceitual",
                            "description": "Elaborar documentação formal incluindo suposições, simplificações e escopo, conforme referências como Banks et al. (2000).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e listar os componentes principais do modelo conceitual",
                                  "subSteps": [
                                    "Revisar o modelo conceitual e listar entidades, atributos e atividades principais.",
                                    "Desenhar um diagrama hierárquico ou de fluxo representando os componentes.",
                                    "Definir relações lógicas entre entidades e atividades.",
                                    "Registrar inputs, outputs e variáveis de estado iniciais.",
                                    "Validar a lista com referências como Banks et al. (2000)."
                                  ],
                                  "verification": "Verificar se o diagrama cobre todos os componentes sem omissões, comparando com o modelo original.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software de diagramação (ex: Draw.io ou Lucidchart)",
                                    "Referências bibliográficas (Banks et al., 2000)",
                                    "Papel e caneta para rascunhos"
                                  ],
                                  "tips": "Comece com um diagrama simples para visualizar conexões antes de detalhar.",
                                  "learningObjective": "Compreender e organizar os elementos fundamentais do modelo conceitual de forma visual e textual.",
                                  "commonMistakes": [
                                    "Omitir variáveis de estado dinâmicas",
                                    "Ignorar relações causais entre componentes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Documentar suposições e simplificações do modelo",
                                  "subSteps": [
                                    "Listar todas as suposições matemáticas e conceituais adotadas.",
                                    "Justificar cada suposição com evidências ou referências teóricas.",
                                    "Identificar simplificações feitas (ex: distribuições probabilísticas aproximadas).",
                                    "Avaliar potenciais impactos dessas simplificações na precisão do modelo.",
                                    "Citar fontes como Banks et al. (2000) para suporte."
                                  ],
                                  "verification": "Conferir se cada suposição tem justificativa explícita e impacto avaliado.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Folha de cálculo ou documento Word/Google Docs",
                                    "Livro ou PDF de Banks et al. (2000)",
                                    "Notas do desenvolvimento do modelo"
                                  ],
                                  "tips": "Use uma tabela com colunas: Suposição, Justificativa, Impacto.",
                                  "learningObjective": "Desenvolver habilidade em explicitar premissas para garantir transparência e reprodutibilidade.",
                                  "commonMistakes": [
                                    "Listar suposições sem justificativa",
                                    "Subestimar impactos de simplificações"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir e documentar o escopo do modelo conceitual",
                                  "subSteps": [
                                    "Delimitar o que o modelo inclui (fronteiras do sistema).",
                                    "Especificar o que está excluído e por quê.",
                                    "Definir níveis de detalhe hierárquico (ex: macro e micro).",
                                    "Descrever condições iniciais e parâmetros de simulação.",
                                    "Integrar escopo com suposições documentadas."
                                  ],
                                  "verification": "Verificar se o escopo é claro, evitando ambiguidades sobre inclusões/exclusões.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Template de documentação de escopo",
                                    "Diagramas do Step 1"
                                  ],
                                  "tips": "Use frases como 'Inclui...' e 'Exclui...' para clareza.",
                                  "learningObjective": "Estabelecer limites precisos para evitar escopo creep na simulação.",
                                  "commonMistakes": [
                                    "Escopo vago ou excessivamente amplo",
                                    "Não justificar exclusões"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estruturar a documentação formal completa",
                                  "subSteps": [
                                    "Organizar seções: Introdução, Componentes, Suposições, Escopo, Diagramas.",
                                    "Escrever texto formal e conciso em linguagem técnica.",
                                    "Incluir referências bibliográficas e glossário de termos.",
                                    "Formatar com headings, tabelas e figuras numeradas.",
                                    "Garantir consistência com padrões de documentação científica."
                                  ],
                                  "verification": "Ler o documento inteiro para checar fluxo lógico e formatação.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Editor de texto (LaTeX, Word ou Markdown)",
                                    "Templates de relatório acadêmico",
                                    "Diagramas prontos"
                                  ],
                                  "tips": "Siga estrutura IMRaD adaptada para modelos conceituais.",
                                  "learningObjective": "Produzir documentação profissional e padronizada.",
                                  "commonMistakes": [
                                    "Texto prolixo ou informal",
                                    "Falta de numeração em figuras/tabelas"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Revisar e validar a documentação",
                                  "subSteps": [
                                    "Realizar auto-revisão checklist: completude, clareza, precisão.",
                                    "Solicitar feedback de pares ou mentor.",
                                    "Corrigir erros e refinar linguagem.",
                                    "Testar se a documentação permite recriar o modelo independentemente.",
                                    "Arquivar versão final com controle de versão."
                                  ],
                                  "verification": "Simular recriação do modelo usando apenas a documentação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Checklist de revisão",
                                    "Ferramenta de versionamento (Git)",
                                    "Peer review"
                                  ],
                                  "tips": "Deixe o documento 'descansar' 1 dia antes da revisão final.",
                                  "learningObjective": "Garantir qualidade e usabilidade da documentação por terceiros.",
                                  "commonMistakes": [
                                    "Pular revisão por pressa",
                                    "Ignorar feedback externo"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado (M/M/1), documentar: suposição de chegadas Poisson (λ=10/h), simplificação ignorando filas múltiplas, escopo limitado a uma caixa (exclui estoque), com diagrama de estados e tabela de variáveis.",
                              "finalVerifications": [
                                "Todos os componentes do modelo estão listados e diagramados?",
                                "Suposições e simplificações estão justificadas com referências?",
                                "Escopo é claramente delimitado com inclusões e exclusões?",
                                "Documentação permite recriação independente do modelo?",
                                "Formatação é profissional com seções, tabelas e citações?",
                                "Glossário e referências bibliográficas estão presentes?"
                              ],
                              "assessmentCriteria": [
                                "Clareza e precisão da linguagem técnica (nota 1-5).",
                                "Completude das seções obrigatórias (suposições, escopo, componentes).",
                                "Uso efetivo de diagramas e tabelas para visualização.",
                                "Justificativas lógicas e referenciadas (ex: Banks et al.).",
                                "Capacidade de reprodutibilidade por terceiros.",
                                "Organização hierárquica e fluxo lógico do documento."
                              ],
                              "crossCurricularConnections": [
                                "Redação Técnica e Científica (Língua Portuguesa/Comunicação).",
                                "Desenvolvimento de Software (Documentação de Código e APIs).",
                                "Gestão de Projetos (Definição de Escopo e Requisitos).",
                                "Estatística e Probabilidade (Justificativa de Suposições Distribuicionais)."
                              ],
                              "realWorldApplication": "Engenheiros de simulação em indústrias como manufatura ou logística usam essa documentação para validar modelos em equipes, garantir reprodutibilidade em pesquisas acadêmicas e auditorias regulatórias em simulações de sistemas discretos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "37.1.2.3.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.4",
                    "name": "Implementação Computacional",
                    "description": "Tradução do modelo conceitual para código usando linguagens ou softwares de simulação.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.4.1",
                        "name": "Seleção e Avaliação de Linguagens e Softwares de Simulação",
                        "description": "Processo de escolha e análise de linguagens de programação específicas para simulação ou softwares comerciais que facilitam a tradução do modelo conceitual para código executável, considerando critérios como facilidade de uso, performance e suporte a eventos discretos.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.1.1",
                            "name": "Identificar linguagens especializadas em simulação",
                            "description": "Reconhecer e descrever linguagens como GPSS, SIMSCRIPT, SIMAN e SLAM, destacando suas características para modelagem de sistemas discretos e exemplos de aplicação em procedimentos de modelagem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender conceitos fundamentais de linguagens especializadas em simulação",
                                  "subSteps": [
                                    "Pesquisar a definição de linguagens de simulação e sua distinção de linguagens gerais como Python ou C++",
                                    "Identificar o foco principal em modelagem de sistemas discretos (eventos discretos, filas, recursos)",
                                    "Listar as linguagens chave: GPSS, SIMSCRIPT, SIMAN e SLAM",
                                    "Ler documentação introdutória sobre por que linguagens especializadas são preferidas para simulação",
                                    "Anotar vantagens gerais: abstrações prontas para filas, eventos e estatísticas"
                                  ],
                                  "verification": "Criar um mapa mental ou tabela resumindo definições e linguagens chave, com pelo menos 5 pontos por linguagem",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Acesso à internet para artigos acadêmicos",
                                    "Documentação oficial ou PDFs de GPSS/SIMSCRIPT",
                                    "Ferramenta de notas como Notion ou papel"
                                  ],
                                  "tips": "Comece com fontes acadêmicas como livros de simulação (ex: Law & Kelton) para precisão histórica",
                                  "learningObjective": "Compreender o papel e as vantagens das linguagens especializadas em simulação de eventos discretos",
                                  "commonMistakes": "Confundir com linguagens gerais de programação sem foco em simulação; ignorar contexto histórico (anos 60-80)"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar características e sintaxe de GPSS e SIMSCRIPT",
                                  "subSteps": [
                                    "Estudar GPSS: blocos como GENERATE, QUEUE, SEIZE, DEPARTURE; foco em transações e blocos",
                                    "Explorar SIMSCRIPT: orientação a eventos, declaração de entidades, módulos para lógica de processo",
                                    "Comparar sintaxe básica com exemplos de código simples para uma fila única",
                                    "Destacar forças: GPSS para simulações rápidas de filas; SIMSCRIPT para flexibilidade em modelos complexos",
                                    "Executar ou simular mentalmente um código exemplo de cada"
                                  ],
                                  "verification": "Escrever pseudocódigo ou diagramas de fluxo para um modelo de fila simples em GPSS e SIMSCRIPT",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Tutoriais online de GPSS/H",
                                    "Exemplos de código SIMSCRIPT de repositórios GitHub",
                                    "Simulador online ou software GPSS World"
                                  ],
                                  "tips": "Use diagramas de blocos para GPSS para visualizar fluxo; foque em keywords principais",
                                  "learningObjective": "Reconhecer e descrever sintaxe e características únicas de GPSS e SIMSCRIPT para modelagem discreta",
                                  "commonMistakes": "Ignorar diferenças de paradigma (GPSS transacional vs SIMSCRIPT procedural); não testar exemplos"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar SIMAN e SLAM, com ênfase em modelagem hierárquica",
                                  "subSteps": [
                                    "Estudar SIMAN: módulos de estação, entidade, transportador; integração com Arena",
                                    "Analisar SLAM: níveis múltiplos (atividade, processo, sistema); flexibilidade para híbridos discreto/contínuo",
                                    "Identificar aplicações: SIMAN para manufatura flexível; SLAM para sistemas complexos com submodelos",
                                    "Comparar com GPSS/SIMSCRIPT em termos de abstração e extensibilidade",
                                    "Compilar tabela de características: paradigma, foco, exemplos de uso"
                                  ],
                                  "verification": "Preencher uma tabela comparativa com 4 colunas (linguagem, características chave, aplicações, limitações)",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Documentação Arena/SIMAN",
                                    "Livros como 'Simulation Modeling and Analysis' de Averill Law",
                                    "Planilha Excel ou Google Sheets"
                                  ],
                                  "tips": "Associe SIMAN a software moderno como Arena; SLAM é predecessor, mas poderoso para customizações",
                                  "learningObjective": "Descrever capacidades de SIMAN e SLAM para modelagem avançada de sistemas discretos",
                                  "commonMistakes": "Confundir SIMAN com Arena (SIMAN é a linguagem subjacente); subestimar hierarquia em SLAM"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar aplicações e exemplos práticos em procedimentos de modelagem",
                                  "subSteps": [
                                    "Mapear exemplos: GPSS para call centers; SIMSCRIPT para logística; SIMAN para linhas de produção; SLAM para aeroportos",
                                    "Descrever ciclo de modelagem: seleção baseada em complexidade do sistema discreto",
                                    "Criar fluxograma de decisão para escolher linguagem por tipo de sistema",
                                    "Avaliar limitações modernas (obsolescência vs poder para casos específicos)",
                                    "Preparar resumo com 1 exemplo por linguagem"
                                  ],
                                  "verification": "Produzir um relatório de 1 página com exemplos de aplicação e fluxograma de seleção",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Casos de estudo acadêmicos",
                                    "Ferramenta de diagramação como Draw.io",
                                    "Editor de texto"
                                  ],
                                  "tips": "Pense em cenários reais como filas em supermercados para tornar exemplos relacionáveis",
                                  "learningObjective": "Aplicar conhecimento para destacar usos em modelagem de simulação discreta",
                                  "commonMistakes": "Focar só em teoria sem exemplos concretos; ignorar evolução para softwares modernos"
                                }
                              ],
                              "practicalExample": "Modelar uma fila de atendimento em um banco usando GPSS: definir transações como clientes (GENERATE), fila (QUEUE), servidor (SEIZE/RELEASE), coletar estatísticas de tempo de espera e throughput.",
                              "finalVerifications": [
                                "Listar corretamente GPSS, SIMSCRIPT, SIMAN e SLAM com pelo menos 3 características cada",
                                "Descrever um exemplo de aplicação para cada linguagem em sistemas discretos",
                                "Criar tabela comparativa destacando diferenças em paradigma e foco",
                                "Explicar quando selecionar uma sobre as outras em procedimentos de modelagem",
                                "Identificar limitações modernas e alternativas como Arena",
                                "Demonstrar compreensão via fluxograma de seleção de linguagem"
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de características (80% acurácia em keywords e paradigmas)",
                                "Profundidade de exemplos de aplicação (concretos e relevantes a eventos discretos)",
                                "Qualidade da comparação (destacar forças/fraquezas relativas)",
                                "Clareza na comunicação (linguagem técnica acessível)",
                                "Completude da tabela/fluxograma (todos elementos presentes)",
                                "Evidência de pesquisa (citações de fontes confiáveis)"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Sintaxe similar a linguagens procedurais/orientadas a eventos",
                                "Estatística: Coleta e análise de métricas de performance em simulações",
                                "Engenharia Industrial: Modelagem de processos de manufatura e logística",
                                "Ciência da Computação: Abstrações de alto nível para simulação de sistemas",
                                "Matemática Aplicada: Teoria de filas e processos estocásticos"
                              ],
                              "realWorldApplication": "Em logística de supply chain, usar GPSS para simular filas de carregamento em armazéns, otimizando throughput e reduzindo gargalos; em manufatura, SIMAN para modelar linhas de produção flexíveis, avaliando cenários de 'what-if' para melhorias de eficiência."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.1.2",
                            "name": "Avaliar softwares comerciais de simulação",
                            "description": "Analisar ferramentas como Arena, ProModel e Extend, utilizando critérios de avaliação como interface gráfica, suporte a validação, custo e integração com linguagens gerais, com base em referências bibliográficas como Banks et al.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Pesquisar e coletar informações sobre softwares comerciais de simulação",
                                  "subSteps": [
                                    "Acessar sites oficiais de Arena, ProModel e Extend para obter descrições gerais e recursos principais.",
                                    "Baixar versões de teste ou demos gratuitas, instalando-as em ambiente controlado.",
                                    "Ler documentação oficial, manuais de usuário e tutoriais introdutórios disponíveis.",
                                    "Identificar e listar features chave relacionadas a simulação de eventos discretos, como modelagem de filas e animação.",
                                    "Compilar dados iniciais sobre requisitos de sistema e suporte multiplataforma."
                                  ],
                                  "verification": "Criação de um documento ou planilha com resumo factual de cada software, incluindo links e screenshots de interfaces.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Acesso à internet",
                                    "Computador com especificações mínimas para instalação de demos",
                                    "Sites oficiais: arena.com, promodel.com, extend.com"
                                  ],
                                  "tips": [
                                    "Priorize informações atualizadas das últimas versões; anote datas de publicação para rastreabilidade."
                                  ],
                                  "learningObjective": "Compreender as capacidades e limitações básicas dos softwares Arena, ProModel e Extend.",
                                  "commonMistakes": [
                                    "Baixar versões desatualizadas sem verificar compatibilidade",
                                    "Ignorar restrições de licença trial",
                                    "Não capturar screenshots para evidências visuais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir critérios de avaliação com base em referências bibliográficas",
                                  "subSteps": [
                                    "Consultar o livro 'Discrete-Event System Simulation' de Banks et al. para identificar critérios padrão de avaliação de softwares de simulação.",
                                    "Listar e detalhar critérios específicos: interface gráfica (usabilidade e animação), suporte a validação (estatísticas e debugging), custo (licenciamento e manutenção), integração com linguagens gerais (ex.: Python, C++).",
                                    "Atribuir pesos ou escalas qualitativas/quantitativas a cada critério (ex.: 1-10).",
                                    "Criar uma matriz de avaliação em planilha para aplicação futura.",
                                    "Validar critérios com exemplos de literatura ou casos de estudo citados em Banks et al."
                                  ],
                                  "verification": "Matriz de critérios documentada com pesos, escalas e justificativas referenciadas.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Livro 'Discrete-Event System Simulation' de Banks et al. (edição recente)",
                                    "Planilha Google Sheets ou Excel",
                                    "Artigos acadêmicos complementares via Google Scholar"
                                  ],
                                  "tips": [
                                    "Use critérios SMART (Específicos, Mensuráveis, Alcançáveis, Relevantes, Temporais) para maior rigor."
                                  ],
                                  "learningObjective": "Aplicar conhecimentos bibliográficos para estabelecer uma framework de avaliação objetiva.",
                                  "commonMistakes": [
                                    "Definir critérios subjetivos sem base literária",
                                    "Ignorar custo total de propriedade (TCO)",
                                    "Sobrecarregar com critérios irrelevantes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar critérios de avaliação a cada software",
                                  "subSteps": [
                                    "Testar interface gráfica em cada software criando um modelo simples de fila única.",
                                    "Avaliar suporte a validação executando simulações com coleta de estatísticas e verificando ferramentas de debugging.",
                                    "Pesquisar e registrar custos: licenças perpétuas, assinaturas anuais e pacotes educacionais.",
                                    "Verificar integração testando importação/exportação de dados com linguagens como Python ou Excel.",
                                    "Pontuar cada critério na matriz, registrando evidências (screenshots, logs de simulação)."
                                  ],
                                  "verification": "Planilha preenchida com pontuações, evidências e comentários para todos os critérios e softwares.",
                                  "estimatedTime": "6 horas",
                                  "materials": [
                                    "Demos instaladas de Arena, ProModel e Extend",
                                    "Ambiente de teste com Python instalado",
                                    "Planilha de critérios do Step 2"
                                  ],
                                  "tips": [
                                    "Execute simulações idênticas em todos os softwares para comparações justas."
                                  ],
                                  "learningObjective": "Realizar análises práticas e quantitativas de softwares usando critérios padronizados.",
                                  "commonMistakes": [
                                    "Testes inconsistentes entre softwares",
                                    "Não documentar evidências numéricas de validação",
                                    "Subestimar barreiras de integração"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar resultados e formular recomendações",
                                  "subSteps": [
                                    "Calcular pontuações totais na matriz e ranquear os softwares.",
                                    "Analisar trade-offs (ex.: alto custo vs. melhor interface).",
                                    "Redigir relatório comparativo destacando forças e fraquezas, citando Banks et al.",
                                    "Formular recomendação contextualizada (ex.: para ensino vs. indústria).",
                                    "Revisar relatório quanto a completude e referências."
                                  ],
                                  "verification": "Relatório final de 5-10 páginas com matriz, gráficos comparativos e conclusão.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Planilha completa do Step 3",
                                    "Ferramenta de edição de texto (Word/Google Docs)",
                                    "Referências bibliográficas"
                                  ],
                                  "tips": [
                                    "Inclua gráficos de radar para visualização intuitiva das pontuações."
                                  ],
                                  "learningObjective": "Sintetizar análises em recomendações acionáveis e fundamentadas.",
                                  "commonMistakes": [
                                    "Viés pessoal na recomendação sem dados",
                                    "Omitir limitações do estudo",
                                    "Relatório sem citações adequadas"
                                  ]
                                }
                              ],
                              "practicalExample": "Avaliar Arena, ProModel e Extend para simular o fluxo de pacientes em um pronto-socorro hospitalar, testando modelagem de filas, tempos de espera e validação estatística, escolhendo o mais adequado para otimização de recursos.",
                              "finalVerifications": [
                                "Matriz de avaliação completa com pontuações e evidências para todos os critérios.",
                                "Relatório escrito com análise comparativa e recomendação justificada.",
                                "Todas as referências a Banks et al. corretamente citadas.",
                                "Evidências práticas (screenshots, logs de simulação) anexadas.",
                                "Recomendação contextualizada para um cenário específico.",
                                "Autoavaliação do processo destacando lições aprendidas."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude na aplicação dos critérios de avaliação (30%).",
                                "Qualidade das evidências práticas e testes realizados (25%).",
                                "Profundidade da análise comparativa e uso de referências (20%).",
                                "Clareza e estrutura do relatório final (15%).",
                                "Originalidade na identificação de trade-offs e recomendações (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Software: Avaliação de usabilidade e integração de ferramentas.",
                                "Gestão de Projetos: Análise custo-benefício e seleção de tecnologias.",
                                "Estatística Aplicada: Suporte a validação e análise de resultados de simulação.",
                                "Economia Empresarial: Considerações de custo e ROI em aquisições de software."
                              ],
                              "realWorldApplication": "Profissionais de engenharia industrial e operações usam essa avaliação para selecionar softwares que otimizem processos em manufatura, logística e serviços, como simular linhas de produção na indústria automotiva ou centros de distribuição da Amazon, reduzindo custos e melhorando eficiência."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.1.3",
                            "name": "Comparar linguagens gerais adaptadas para simulação",
                            "description": "Comparar o uso de linguagens como Python (com bibliotecas SimPy), C++ ou Java para implementação de simulações discretas, versus linguagens especializadas, focando em flexibilidade e overhead computacional.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e Catalogar Linguagens Gerais e Especializadas",
                                  "subSteps": [
                                    "Liste linguagens gerais como Python (com SimPy), C++ e Java, anotando bibliotecas relevantes para simulações discretas.",
                                    "Pesquise linguagens especializadas como Arena, AnyLogic ou ExtendSim, focando em suas finalidades principais.",
                                    "Crie uma tabela comparativa inicial com colunas para nome, tipo (geral/especializada), suporte a eventos discretos e exemplos de uso.",
                                    "Colete dados preliminares sobre instalação e curva de aprendizado de cada uma.",
                                    "Documente fontes confiáveis usadas na pesquisa."
                                  ],
                                  "verification": "Verifique se a tabela contém pelo menos 3 linguagens gerais e 2 especializadas com descrições breves.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Navegador web, planilha (Google Sheets ou Excel), documentação oficial de SimPy, C++, Java e ferramentas como Arena.",
                                  "tips": "Use sites como Stack Overflow e papers acadêmicos para exemplos reais de uso em simulações.",
                                  "learningObjective": "Compreender as diferenças fundamentais entre linguagens gerais adaptadas e especializadas para simulações discretas.",
                                  "commonMistakes": "Confundir linguagens de script (Python) com compiladas (C++) sem notar impactos em performance."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Avaliar Flexibilidade de Uso",
                                  "subSteps": [
                                    "Analise a capacidade de customização: teste scripts simples em Python/SimPy para modificar regras de simulação.",
                                    "Compare com linguagens especializadas: note limitações em interfaces gráficas vs código aberto em C++/Java.",
                                    "Avalie integração com outros sistemas (ex: Python com Pandas para análise de dados vs isolamento em ferramentas especializadas).",
                                    "Registre cenários onde flexibilidade é crítica, como prototipagem rápida.",
                                    "Pontue cada linguagem em uma escala de 1-10 para flexibilidade com justificativa."
                                  ],
                                  "verification": "Confirme tabela atualizada com pontuações de flexibilidade e pelo menos um exemplo por linguagem.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Ambiente de desenvolvimento (Jupyter Notebook para Python, IDE para C++/Java), documentação de SimPy.",
                                  "tips": "Comece com protótipos mínimos viáveis (MVP) para testar flexibilidade rapidamente.",
                                  "learningObjective": "Dominar critérios para medir flexibilidade em contextos de simulação discreta.",
                                  "commonMistakes": "Superestimar flexibilidade de ferramentas especializadas sem testar extensibilidade via scripts."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Medir e Comparar Overhead Computacional",
                                  "subSteps": [
                                    "Implemente uma simulação discreta simples (ex: fila M/M/1) em Python/SimPy, C++ e uma ferramenta especializada.",
                                    "Meça métricas: tempo de execução, uso de CPU/memória com ferramentas como timeit (Python) ou perf (C++).",
                                    "Execute múltiplas rodadas (100+) para estatísticas médias e compare overhead (interpretação vs compilação).",
                                    "Analise trade-offs: overhead alto em linguagens gerais para protótipos vs eficiência em especializadas para produção.",
                                    "Crie gráficos comparativos usando Matplotlib ou Excel."
                                  ],
                                  "verification": "Verifique existência de pelo menos 3 medições por linguagem com gráficos e tabela de resultados.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Computador com Python, C++ compiler (GCC), Java JDK, SimPy library, ferramenta especializada trial (ex: AnyLogic).",
                                  "tips": "Padronize o modelo de simulação para fair comparison; use seeds fixos para reprodutibilidade.",
                                  "learningObjective": "Aplicar benchmarks quantitativos para avaliar performance em simulações.",
                                  "commonMistakes": "Ignorar overhead de bibliotecas externas ou testar em hardware inconsistente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar Comparação e Recomendações",
                                  "subSteps": [
                                    "Compile prós/contras: flexibilidade vs overhead para cada linguagem.",
                                    "Defina cenários ideais: gerais para pesquisa (Python), especializadas para indústria (Arena).",
                                    "Escreva um relatório resumido com tabela final e visualizações.",
                                    "Teste compreensão respondendo: 'Qual escolher para simulação de 1M eventos? Por quê?'",
                                    "Atualize portfólio com o relatório e códigos fonte."
                                  ],
                                  "verification": "Relatório completo com recomendações contextualizadas e auto-perguntas respondidas.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Editor de texto ou LaTeX para relatório, GitHub para versionamento.",
                                  "tips": "Use matriz de decisão (ex: Pugh matrix) para sintetizar escolhas.",
                                  "learningObjective": "Integrar análises qualitativas e quantitativas em decisões informadas de seleção de ferramentas.",
                                  "commonMistakes": "Generalizar resultados de um benchmark pequeno para todos os casos."
                                }
                              ],
                              "practicalExample": "Implemente uma simulação de fila de supermercado (chegadas Poisson, serviço exponencial) em Python com SimPy (flexível, overhead médio) vs AnyLogic (rápida visualização, menos customizável), medindo tempo para 10.000 clientes e comparando código vs drag-and-drop.",
                              "finalVerifications": [
                                "Tabela comparativa completa com 3+ linguagens gerais e 2+ especializadas.",
                                "Benchmarks executados com dados numéricos e gráficos.",
                                "Relatório com prós/contras claros e cenários de uso.",
                                "Exemplo prático implementado e testado.",
                                "Auto-avaliação respondendo perguntas de síntese.",
                                "Fontes citadas e reprodutibilidade confirmada."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude da catalogação de linguagens (30%).",
                                "Qualidade quantitativa dos benchmarks de overhead (25%).",
                                "Profundidade na análise de flexibilidade com exemplos (20%).",
                                "Clareza e estrutura do relatório final (15%).",
                                "Reprodutibilidade e documentação de códigos (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação e Ciência da Computação: Implementação de algoritmos de simulação.",
                                "Engenharia de Software: Seleção de ferramentas e trade-offs de performance.",
                                "Estatística: Análise de resultados de simulações estocásticas.",
                                "Gestão de Projetos: Decisões baseadas em custo-benefício computacional."
                              ],
                              "realWorldApplication": "Em otimização de linhas de produção industriais, onde Python/SimPy permite protótipos rápidos para engenheiros, enquanto C++ reduz overhead para simulações em larga escala em manufatura, ou em logística para modelar supply chains com ferramentas como Arena."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.4.2",
                        "name": "Geração de Números Pseudo-Aleatórios",
                        "description": "Implementação de algoritmos para produzir sequências de números pseudo-aleatórios que simulam comportamento estocástico em modelos de simulação de sistemas discretos.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.2.1",
                            "name": "Implementar gerador congruencial linear",
                            "description": "Codificar o método do gerador congruencial linear (LCG) em uma linguagem escolhida, especificando parâmetros como multiplicador, incremento e módulo, e testando a uniformidade da distribuição gerada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o algoritmo LCG e selecionar parâmetros ótimos",
                                  "subSteps": [
                                    "Estude a fórmula do LCG: X_{n+1} = (a * X_n + c) mod m, onde X_0 é a semente.",
                                    "Pesquise critérios para bons parâmetros: m primo grande (ex: 2^31-1), a período total (ex: 16807), c=1 ou 0.",
                                    "Escolha uma linguagem de programação (ex: Python) e defina valores iniciais: m=2147483647, a=16807, c=0, seed=12345.",
                                    "Documente as escolhas em um comentário no código.",
                                    "Calcule manualmente os primeiros 5 números para validar entendimento."
                                  ],
                                  "verification": "Cálculos manuais coincidem com os primeiros valores gerados por código simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação LCG online, calculadora ou papel para cálculos manuais, editor de código (VS Code ou Jupyter Notebook).",
                                  "tips": "Use parâmetros testados como os de Park-Miller para evitar períodos curtos.",
                                  "learningObjective": "Compreender os componentes matemáticos do LCG e critérios para qualidade pseudo-aleatória.",
                                  "commonMistakes": "Escolher m não primo, levando a períodos curtos; ignorar overflow em linguagens com inteiros limitados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a função geradora LCG em código",
                                  "subSteps": [
                                    "Crie uma função def lcg(seed, a, c, m, n): que retorna lista de n números.",
                                    "Inicialize x = seed, loop n vezes: x = (a * x + c) % m, append x/m para [0,1).",
                                    "Trate overflow usando int64 ou modulo em Python.",
                                    "Adicione parâmetros como input e teste com n=10.",
                                    "Escreva docstring explicando uso e parâmetros."
                                  ],
                                  "verification": "Função gera lista correta comparada a cálculos manuais dos primeiros termos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Editor de código Python, intérprete Python 3+.",
                                  "tips": "Sempre normalize para [0,1) dividindo por m para uniformidade.",
                                  "learningObjective": "Codificar corretamente o iterativo matemático em loop programático.",
                                  "commonMistakes": "Esquecer o modulo % m, causando números explosivos; usar float cedo demais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar sequência longa e visualizar distribuição",
                                  "subSteps": [
                                    "Gere 10.000 números com lcg().",
                                    "Use matplotlib para plotar histograma da sequência.",
                                    "Divida em bins (ex: 20) e plote frequências.",
                                    "Compare visualmente com distribuição uniforme.",
                                    "Salve gráfico como PNG."
                                  ],
                                  "verification": "Histograma mostra barras aproximadamente iguais em altura.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Bibliotecas Python: numpy, matplotlib (pip install).",
                                  "tips": "Use plt.hist(rands, bins=50, density=True) para normalizar.",
                                  "learningObjective": "Visualizar e interpretar saída pseudo-aleatória.",
                                  "commonMistakes": "Gerar poucos números (baixa amostra); escalas erradas no plot."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar uniformidade estatisticamente",
                                  "subSteps": [
                                    "Implemente teste qui-quadrado simples: divida em k bins, calcule chi2 = sum((obs-exp)^2/exp).",
                                    "Defina k=10, exp=N/k, threshold=chi2.ppf(0.95, k-1).",
                                    "Execute teste e imprima p-value ou aceita/rejeita H0: uniforme.",
                                    "Repita com diferentes seeds e parâmetros ruins para comparar.",
                                    "Registre resultados em tabela Markdown."
                                  ],
                                  "verification": "Chi-quadrado abaixo do threshold para parâmetros bons.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Biblioteca scipy.stats para chi2; numpy para cálculos.",
                                  "tips": "Instale scipy: pip install scipy; use from scipy.stats import chisquare.",
                                  "learningObjective": "Aplicar teste estatístico básico para validar gerador.",
                                  "commonMistakes": "Confundir observed/expected; bins desiguais."
                                }
                              ],
                              "practicalExample": "Implemente LCG em Python para simular 1000 lançamentos de um dado de 6 faces: r = lcg(...); dice = [int(r*6)+1 for r in sequence[:1000]]. Conte frequências e verifique se cada face ~16.67%. Plote gráfico de barras.",
                              "finalVerifications": [
                                "Código executa sem erros e gera sequência de 10k+ números.",
                                "Histograma visualmente uniforme.",
                                "Teste qui-quadrado passa (p-value > 0.05).",
                                "Mudança de seed altera sequência deterministicamente.",
                                "Período detectado longo (ex: >1M com print ciclo).",
                                "Normalização produz valores em [0,1)."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática da implementação LCG (100% match manuais).",
                                "Qualidade visual e estatística da uniformidade (chi2 < threshold).",
                                "Código limpo, comentado e modular (função reutilizável).",
                                "Uso adequado de visualizações e testes estatísticos.",
                                "Documentação de parâmetros e resultados.",
                                "Tratamento de edge cases (seed=0, n=1)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Loops, funções, bibliotecas numéricas (numpy).",
                                "Estatística: Testes de hipóteses, distribuições uniformes.",
                                "Matemática Discreta: Aritmética modular, teoria dos números.",
                                "Ciência da Computação: Algoritmos iterativos, análise de complexidade O(n)."
                              ],
                              "realWorldApplication": "LCG é usado em simulações Monte Carlo para finanças (preços de opções), jogos (RNG em videogames como Minecraft), criptografia básica e testes de software para dados aleatórios, garantindo reprodutibilidade sem hardware RNG caro."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.2.2",
                            "name": "Aplicar testes de aleatoriedade",
                            "description": "Executar testes estatísticos como teste de qui-quadrado, poker e corridas para validar a qualidade dos números pseudo-aleatórios gerados, utilizando bibliotecas ou código customizado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a sequência de números pseudo-aleatórios",
                                  "subSteps": [
                                    "Escolha ou implemente um gerador de números pseudo-aleatórios (PRNG), como Linear Congruential Generator (LCG).",
                                    "Gere uma sequência longa (mínimo 10.000 números) normalizando para o intervalo [0,1].",
                                    "Salve a sequência em um arquivo ou array para uso nos testes.",
                                    "Defina parâmetros como semente fixa para reprodutibilidade.",
                                    "Visualize os primeiros números e histograma básico para inspeção inicial."
                                  ],
                                  "verification": "Sequência gerada com pelo menos 10.000 números, salva e visualizada corretamente sem erros.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python ou linguagem similar",
                                    "Bibliotecas: numpy, matplotlib",
                                    "Editor de código (VS Code ou Jupyter)"
                                  ],
                                  "tips": "Use semente fixa (ex: seed=42) para resultados reproduzíveis durante testes.",
                                  "learningObjective": "Compreender e gerar sequências PRNG adequadas para testes estatísticos.",
                                  "commonMistakes": [
                                    "Gerar sequências curtas (menos de 5.000), comprometendo validade dos testes.",
                                    "Não normalizar para [0,1], invalidando comparações com distribuições uniformes.",
                                    "Ignorar overflow em implementações customizadas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar e executar o teste de qui-quadrado",
                                  "subSteps": [
                                    "Divida a sequência em bins (ex: 10 intervalos de 0.1).",
                                    "Calcule frequências observadas em cada bin e esperadas (uniforme: N/10).",
                                    "Compute estatística qui-quadrado: soma((O_i - E_i)^2 / E_i).",
                                    "Determine graus de liberdade (k-1) e p-valor usando tabela ou função chi2.sf.",
                                    "Interprete: p-valor > 0.05 indica boa uniformidade."
                                  ],
                                  "verification": "Código executa, retorna estatística e p-valor corretos; sequência passa se p>0.05.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python",
                                    "Bibliotecas: numpy, scipy.stats",
                                    "Tabela de qui-quadrado (opcional)"
                                  ],
                                  "tips": "Use scipy.stats.chisquare para validação rápida contra implementação customizada.",
                                  "learningObjective": "Aplicar teste de qui-quadrado para verificar uniformidade de PRNG.",
                                  "commonMistakes": [
                                    "Número insuficiente de bins (use 10+ para N>10k).",
                                    "Esquecer de subtrair 1 nos graus de liberdade.",
                                    "Interpretar p-valor <0.05 como falha sem contexto."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e executar o teste de poker",
                                  "subSteps": [
                                    "Converta os primeiros 5.000 números para dígitos (multiplique por 10^5 e pegue 5 dígitos).",
                                    "Agrupe em mãos de poker de 5 cartas (cada dígito 0-9 como carta 0-9).",
                                    "Conte frequências de tipos: nada, um par, dois pares, trinca, full house, quadra, straight flush.",
                                    "Calcule qui-quadrado comparando observadas com probabilidades teóricas.",
                                    "Avalie p-valor para independência e uniformidade."
                                  ],
                                  "verification": "Frequências contadas corretamente, p-valor computado e sequência aprovada se p>0.01.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python",
                                    "numpy",
                                    "scipy.stats",
                                    "Tabela de probabilidades poker (consultar Knuth)"
                                  ],
                                  "tips": "Implemente função para classificar mãos de poker passo a passo para evitar bugs.",
                                  "learningObjective": "Detectar padrões de dependência via teste de poker em PRNG.",
                                  "commonMistakes": [
                                    "Erro na classificação de mãos (ex: confundir full house com trinca).",
                                    "Usar sequência não truncada para 5 dígitos.",
                                    "Ignorar limite de 5.000 dígitos como recomendado."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e executar o teste de corridas acima/abaixo",
                                  "subSteps": [
                                    "Transforme sequência em binária: 1 se >0.5, 0 caso contrário.",
                                    "Conte corridas (sequências alternadas de 1s e 0s).",
                                    "Calcule número de corridas Z e estatística de teste: Z = (R - (2n1 n0)/N) / sqrt(...).",
                                    "Compute p-valor para distribuição normal aproximada.",
                                    "Interprete: |Z| < 1.96 indica aleatoriedade (95% confiança)."
                                  ],
                                  "verification": "Binária gerada, Z calculado corretamente, p-valor indica aprovação.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python",
                                    "numpy",
                                    "scipy.stats.norm"
                                  ],
                                  "tips": "Comece com sequência longa (>100) para boa aproximação normal.",
                                  "learningObjective": "Verificar independência serial via teste de corridas em PRNG.",
                                  "commonMistakes": [
                                    "Contar corridas incorretamente (ex: ignorar corridas de comprimento 1).",
                                    "Não verificar n1 ≈ n0/2 antes do teste.",
                                    "Usar distribuição qui-quadrado em vez de normal."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar resultados e interpretar qualidade do PRNG",
                                  "subSteps": [
                                    "Compile resultados de todos os testes em tabela (estatística, p-valor).",
                                    "Avalie se todos passam (ex: p>0.01 ou 0.05 dependendo do teste).",
                                    "Compare com PRNG conhecidos (random.random() vs custom LCG).",
                                    "Discuta limitações e sugira melhorias no gerador.",
                                    "Documente relatório com gráficos e conclusões."
                                  ],
                                  "verification": "Relatório gerado com tabela, gráficos e conclusão sobre aleatoriedade.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python",
                                    "matplotlib, pandas para tabelas"
                                  ],
                                  "tips": "Sempre teste múltiplas sementes para robustez.",
                                  "learningObjective": "Integrar testes para avaliação holística de PRNG.",
                                  "commonMistakes": [
                                    "Aceitar PRNG falhando em >1 teste.",
                                    "Não considerar tamanho amostral em interpretações.",
                                    "Omitir comparação com benchmarks."
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente um LCG com parâmetros ruins (a=1, c=1, m=100) gere 20.000 números, aplique os 3 testes e observe falhas (p-valores baixos), contrastando com parâmetros bons (a=1664525, c=1013904223, m=2^32).",
                              "finalVerifications": [
                                "Gera sequências PRNG e aplica os três testes sem erros de código.",
                                "Interpreta corretamente p-valores e aprova/rejeita geradores.",
                                "Compara resultados custom vs bibliotecas padrão.",
                                "Identifica padrões não-aleatórios em geradores ruins.",
                                "Documenta análise com tabelas e gráficos claros.",
                                "Explica limitações de cada teste."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos cálculos estatísticos (erro <1%).",
                                "Correta implementação de sub-rotinas (validada vs scipy).",
                                "Interpretação coerente dos resultados (passa/falha justificada).",
                                "Relatório completo com visualizações.",
                                "Eficiência do código (roda em <10s para N=10k).",
                                "Cobertura de edge cases (sementes variadas)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Testes de hipóteses e distribuições qui-quadrado/normal.",
                                "Programação: Algoritmos numéricos e manipulação de arrays.",
                                "Criptografia: Avaliação de geradores para segurança.",
                                "Simulações: Validação em Monte Carlo e modelagem estocástica.",
                                "Ciência de Dados: Análise exploratória e testes de qualidade de dados."
                              ],
                              "realWorldApplication": "Validar geradores em simulações Monte Carlo para finanças (preços de ações), jogos (RPGs com loot aleatório), criptografia (chaves seguras) e machine learning (inicialização de pesos), evitando vieses que comprometem resultados realistas."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.4.2.3",
                            "name": "Configurar sementes e streams independentes",
                            "description": "Implementar múltiplos streams de números aleatórios com sementes diferentes para replicações independentes em experimentos de simulação, evitando correlação entre rodadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Sementes e Streams em PRNG",
                                  "subSteps": [
                                    "Estude o funcionamento de geradores de números pseudo-aleatórios (PRNG) e sua determinística.",
                                    "Analise o impacto de uma semente fixa na reprodutibilidade de sequências aleatórias.",
                                    "Diferencie um stream único de múltiplos streams independentes para evitar correlações.",
                                    "Revise bibliotecas como Python's random e numpy.random.RandomState para gerenciamento de streams.",
                                    "Examine casos onde streams compartilhados causam viés em simulações repetidas."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras explicando sementes vs. streams, com um diagrama simples.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação oficial Python random module",
                                    "NumPy RandomState docs",
                                    "Notebook Jupyter para testes"
                                  ],
                                  "tips": "Visualize sequências geradas com print() para observar padrões com sementes iguais.",
                                  "learningObjective": "Dominar os princípios teóricos que justificam o uso de sementes independentes em simulações.",
                                  "commonMistakes": [
                                    "Confundir pseudo-aleatoriedade com aleatoriedade verdadeira",
                                    "Ignorar que a mesma semente sempre produz a mesma sequência"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Semente Única em um Gerador de Números Aleatórios",
                                  "subSteps": [
                                    "Importe a biblioteca random ou numpy.random.",
                                    "Crie um gerador com semente fixa usando random.seed() ou RandomState(seed=123).",
                                    "Gere uma sequência de números aleatórios e salve-a para referência.",
                                    "Reinicie o gerador com a mesma semente e gere novamente para verificar reprodutibilidade.",
                                    "Teste com semente diferente para observar variação na sequência."
                                  ],
                                  "verification": "Execute o código duas vezes com a mesma semente e confirme sequências idênticas via assert.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python IDE como VS Code ou Jupyter Notebook",
                                    "Biblioteca numpy instalada"
                                  ],
                                  "tips": "Use numpy.random.seed() globalmente primeiro para testes iniciais antes de streams locais.",
                                  "learningObjective": "Configurar corretamente um PRNG com semente para garantir reprodutibilidade básica.",
                                  "commonMistakes": [
                                    "Esquecer de importar numpy corretamente",
                                    "Usar seed() após gerar números, invalidando o efeito"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Criar Múltiplos Streams Independentes com Sementes Diferentes",
                                  "subSteps": [
                                    "Crie dois ou mais objetos RandomState com sementes únicas (ex: seed=42, seed=123).",
                                    "Gere sequências paralelas de números aleatórios de cada stream.",
                                    "Implemente uma função para rodadas de simulação usando streams dedicados.",
                                    "Salve seeds usadas em um log para replicação futura.",
                                    "Teste independência gerando 1000 números de cada e calculando correlação (deve ser ~0)."
                                  ],
                                  "verification": "Calcule coeficiente de correlação entre streams; deve ser próximo de zero.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código Python com numpy",
                                    "Ferramenta para calcular correlação como numpy.corrcoef"
                                  ],
                                  "tips": "Escolha sementes primos ou baseadas em timestamp para diversidade natural.",
                                  "learningObjective": "Gerenciar streams independentes para simulações multi-rodadas sem correlação.",
                                  "commonMistakes": [
                                    "Reutilizar o mesmo RandomState entre streams",
                                    "Definir semente global que sobrepõe locais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Streams em uma Simulação e Verificar Independência",
                                  "subSteps": [
                                    "Desenvolva uma simulação simples (ex: Monte Carlo para média de uniformes).",
                                    "Execute 5 rodadas independentes usando streams com sementes únicas por rodada.",
                                    "Colete resultados e analise variância entre rodadas.",
                                    "Compare com versão correlacionada (mesma semente) para demonstrar diferença.",
                                    "Documente o código com comentários sobre configuração de seeds."
                                  ],
                                  "verification": "Plotar histogramas de resultados das rodadas; devem sobrepor sem padrões correlacionados.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Matplotlib para plots",
                                    "Jupyter Notebook para visualização interativa"
                                  ],
                                  "tips": "Use loops com seeds incrementais (ex: seed = base + rodada_id) para simplicidade.",
                                  "learningObjective": "Integrar configuração de streams em experimentos reais de simulação.",
                                  "commonMistakes": [
                                    "Não resetar streams entre rodadas",
                                    "Confundir variância natural com correlação indesejada"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de Monte Carlo para estimar π, crie dois streams: stream1 (seed=42) gera pontos (x,y) no quadrado [0,1]x[0,1]; stream2 (seed=123) gera pontos de validação. Execute 10 rodadas independentes alterando seeds (ex: seed=42+i para i em 0-9), garantindo que cada rodada produza estimativas não correlacionadas.",
                              "finalVerifications": [
                                "Gerar 5 sequências de 1000 números de streams independentes e confirmar correlação < 0.05.",
                                "Replicar uma simulação completa 3 vezes com mesmas seeds e obter resultados idênticos.",
                                "Modificar uma seed e verificar que apenas o stream afetado muda.",
                                "Executar 10 rodadas de Monte Carlo e plotar resultados sem padrões visíveis de correlação.",
                                "Documentar seeds usadas em um arquivo JSON para reprodutibilidade total.",
                                "Testar em código compartilhado: colegas executam e obtêm mesmas sequências."
                              ],
                              "assessmentCriteria": [
                                "Correção na configuração de múltiplos RandomState com sementes únicas (100%).",
                                "Demonstração de independência via cálculo de correlação entre streams (<0.1).",
                                "Reprodutibilidade comprovada em múltiplas execuções com mesmas seeds.",
                                "Integração limpa em simulação sem vazamento de estado entre streams.",
                                "Código comentado e modular, com logging de seeds.",
                                "Análise estatística dos resultados de rodadas independentes."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Análise de variância e testes de independência em dados simulados.",
                                "Programação: Gerenciamento de estado em objetos e boas práticas de modularidade.",
                                "Ciência de Dados: Reprodutibilidade em experimentos de machine learning.",
                                "Física Computacional: Simulações estocásticas em modelagem de partículas.",
                                "Matemática Discreta: Propriedades de sequências pseudo-aleatórias e congruência linear."
                              ],
                              "realWorldApplication": "Em simulações científicas como previsão climática ou finanças (Value-at-Risk), streams independentes com sementes únicas permitem rodadas paralelas não correlacionadas em supercomputadores, garantindo resultados robustos e replicáveis para validação regulatória."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.4.3",
                        "name": "Geração de Variáveis Aleatórias",
                        "description": "Técnicas para transformar números pseudo-aleatórios uniformes em variáveis aleatórias com distribuições específicas, essenciais para modelar tempos de chegada, serviço e outros eventos em simulações discretas.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.3.1",
                            "name": "Implementar método da transformada inversa",
                            "description": "Codificar o método da função inversa cumulativa para gerar variáveis de distribuições contínuas como exponencial e normal, calculando a inversa analítica ou numérica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a teoria do método da transformada inversa",
                                  "subSteps": [
                                    "Estude a definição da função de distribuição cumulativa (CDF) F(x) para distribuições contínuas.",
                                    "Aprenda que o método inverso gera U ~ Uniform(0,1), então X = F^{-1}(U).",
                                    "Revise exemplos analíticos: para exponencial λ, F^{-1}(u) = -ln(1-u)/λ.",
                                    "Entenda quando usar inversa numérica: para CDF sem forma fechada, como normal padrão.",
                                    "Implemente um solver numérico básico (ex: bisection) para F(x) = u."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como gerar uma amostra exponencial usando U=0.5 e λ=1.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de probabilidade (ex: Ross), notebook Jupyter ou Python IDLE",
                                    "Documentação NumPy/SciPy"
                                  ],
                                  "tips": "Desenhe gráficos da CDF e PDF para visualizar a inversa.",
                                  "learningObjective": "Dominar os fundamentos teóricos para justificar implementações.",
                                  "commonMistakes": [
                                    "Confundir PDF com CDF",
                                    "Usar U diretamente sem inverter",
                                    "Ignorar o domínio de U em (0,1)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar inversa analítica para distribuição exponencial",
                                  "subSteps": [
                                    "Gere U ~ Uniform(0,1) usando np.random.uniform(0,1, size=n).",
                                    "Calcule X = -np.log(1-U) / λ para λ dado.",
                                    "Crie uma função reusable: def inverse_exponential(U, lambda_param): ...",
                                    "Gere 10000 amostras e plote histograma.",
                                    "Compare estatísticas: média deve ≈ 1/λ, variância ≈ 1/λ²."
                                  ],
                                  "verification": "Execute código e verifique se média das amostras está próxima de 1/λ.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python com NumPy, Matplotlib",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Use 1-U em vez de U para evitar log(0); teste com λ=1 e λ=2.",
                                  "learningObjective": "Codificar e testar geração de variáveis exponenciais.",
                                  "commonMistakes": [
                                    "np.log(U) em vez de np.log(1-U)",
                                    "Esquecer divisão por λ",
                                    "Amostras insuficientes para validação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar inversa numérica para distribuição normal",
                                  "subSteps": [
                                    "Defina CDF normal padrão Φ(x) usando scipy.stats.norm.cdf.",
                                    "Implemente método de bisection para resolver Φ(x) = U: def bisect_inverse(U, tol=1e-6): ...",
                                    "Gere U e aplique bisect_inverse para X ~ N(0,1).",
                                    "Para N(μ,σ²), escale: X = μ + σ * Z onde Z~N(0,1).",
                                    "Gere amostras, plote histograma e QQ-plot vs normal."
                                  ],
                                  "verification": "QQ-plot mostra alinhamento linear; KS-test p-value >0.05.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com SciPy, NumPy, Matplotlib, SciPy.stats"
                                  ],
                                  "tips": "Limite bisection: low=-10, high=10 para normal; aumente tol se lento.",
                                  "learningObjective": "Aplicar métodos numéricos para CDF sem inversa analítica.",
                                  "commonMistakes": [
                                    "Loop infinito no bisection sem tol",
                                    "Usar norm.ppf diretamente (trapacear!)",
                                    "Ignorar padronização μ,σ"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar, otimizar e documentar a implementação",
                                  "subSteps": [
                                    "Compare tempos de execução: analítica vs numérica com %timeit.",
                                    "Teste estatísticas: média, variância, KS-test para ambas distribuições.",
                                    "Crie script completo com funções modulares e docstrings.",
                                    "Adicione visualizações: histogramas lado a lado com PDF teórica.",
                                    "Escreva relatório resumindo resultados e limitações."
                                  ],
                                  "verification": "Código documentado roda end-to-end produzindo gráficos e stats válidos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Mesmos do passo anterior",
                                    "Template de relatório Markdown"
                                  ],
                                  "tips": "Use vectorização NumPy para eficiência; evite loops Python.",
                                  "learningObjective": "Garantir robustez e usabilidade do código.",
                                  "commonMistakes": [
                                    "Validação visual sem testes estatísticos",
                                    "Código não modular",
                                    "Omitir docstrings"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado, use método inverso para gerar tempos de chegada exponenciais (λ=0.5 por minuto) e serviços normais (μ=3min, σ=1min), simulando 1000 clientes para estimar tempo médio de espera.",
                              "finalVerifications": [
                                "Código gera amostras sem erros para exponencial e normal.",
                                "Histogramas e QQ-plots coincidem com distribuições teóricas.",
                                "Estatísticas amostrais (média, var) dentro de 5% do teórico.",
                                "KS-test rejeita H0 de não-normalidade com p>0.01.",
                                "Funções são eficientes (<1s para 10k amostras).",
                                "Documentação cobre uso e parâmetros."
                              ],
                              "assessmentCriteria": [
                                "Correção teórica: inversa aplicada adequadamente.",
                                "Eficiência numérica: convergência rápida no bisection.",
                                "Validação robusta: múltiplos testes estatísticos.",
                                "Código limpo: modular, comentado, vectorizado.",
                                "Visualizações claras: plots informativos.",
                                "Generalidade: funciona para parâmetros variados."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: CDF, testes de aderência.",
                                "Programação Numérica: solvers iterativos, vectorização.",
                                "Simulação e Modelagem: Monte Carlo, filas.",
                                "Cálculo Numérico: métodos de raiz (bisection).",
                                "Data Science: geração de dados sintéticos."
                              ],
                              "realWorldApplication": "Geração de cenários estocásticos em finanças (retornos lognormais via normal), logística (tempos de chegada), machine learning (dados aumentados) e risco (simulações VaR)."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.4.3.2",
                            "name": "Aplicar método de aceitação-rejeição",
                            "description": "Implementar o algoritmo de aceitação-rejeição para distribuições como gamma e beta, definindo a função envelope e verificando eficiência através de taxa de aceitação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender e Definir as Distribuições Alvo e de Proposta",
                                  "subSteps": [
                                    "Estude a densidade da distribuição alvo f(x), como gamma(α, β) ou beta(α, β).",
                                    "Escolha uma distribuição de proposta g(x) fácil de amostrar, como exponencial para gamma ou uniforme para beta.",
                                    "Calcule o limite superior M tal que f(x) ≤ M * g(x) para todo x no suporte.",
                                    "Verifique graficamente se o envelope cobre a densidade alvo.",
                                    "Documente os parâmetros α, β e o valor de M encontrado."
                                  ],
                                  "verification": "Crie um gráfico comparando f(x), g(x) e M*g(x); confirme que M*g(x) ≥ f(x) em todos os pontos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python com NumPy e Matplotlib",
                                    "Documentação SciPy para gamma e beta"
                                  ],
                                  "tips": "Comece com distribuições simples como gamma(2,1) para testar; use plot para visualizar o envelope.",
                                  "learningObjective": "Identificar componentes necessários para o método de aceitação-rejeição e validar o envelope.",
                                  "commonMistakes": [
                                    "Escolher M muito pequeno causando rejeições inválidas",
                                    "Ignorar o suporte das distribuições levando a amostras inválidas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Funções de Densidade e Envelope",
                                  "subSteps": [
                                    "Defina a função densidade alvo f(x) usando scipy.stats.",
                                    "Defina a função densidade da proposta g(x).",
                                    "Implemente a função envelope h(x) = M * g(x).",
                                    "Crie funções para amostrar de g(x) e uniforme(0, h(x)).",
                                    "Teste as funções com valores isolados para garantir saídas corretas."
                                  ],
                                  "verification": "Execute testes unitários: amostre 1000 pontos e confirme que h(x) >= f(x) para todos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python, NumPy, SciPy.stats",
                                    "Editor de código como Jupyter Notebook"
                                  ],
                                  "tips": "Use log-pdf para evitar underflow em densidades; normalize se necessário.",
                                  "learningObjective": "Codificar densidades probabilísticas e envelope de forma eficiente e testável.",
                                  "commonMistakes": [
                                    "Esquecer de normalizar g(x)",
                                    "Usar pdf não logarítmica em regiões de alta densidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Codificar o Algoritmo de Aceitação-Rejeição",
                                  "subSteps": [
                                    "Implemente o loop principal: gere x ~ g(x), u ~ Uniform(0,1), y = u * h(x).",
                                    "Aceite x se y <= f(x), senão rejeite e repita.",
                                    "Colete N amostras aceitas (ex: 10000).",
                                    "Registre o número total de propostas e calcule taxa de aceitação.",
                                    "Armazene as amostras em uma lista ou array."
                                  ],
                                  "verification": "Gere 5000 amostras e confirme que a taxa de aceitação é positiva e estável.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com NumPy",
                                    "Funções do step anterior"
                                  ],
                                  "tips": "Implemente com while loop até atingir N aceitações; use vetorização parcial para speed-up.",
                                  "learningObjective": "Executar o core do algoritmo de rejection sampling de forma correta e eficiente.",
                                  "commonMistakes": [
                                    "Gerar u ~ Uniform(0, h(x)) incorretamente",
                                    "Não parar após N aceitações levando a loops infinitos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Eficiência e Validar Amostras",
                                  "subSteps": [
                                    "Calcule estatísticas das amostras: média, variância e compare com valores teóricos.",
                                    "Plote histograma das amostras vs densidade teórica.",
                                    "Meça e reporte a taxa de aceitação (aceitas / totais).",
                                    "Otimize M se taxa < 0.3 e re-teste.",
                                    "Teste com diferentes parâmetros para gamma/beta."
                                  ],
                                  "verification": "Histograma sobreposto à pdf teórica com KS-test p-value > 0.05; taxa de aceitação reportada.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Matplotlib, SciPy.stats (ks_2samp ou kstest)"
                                  ],
                                  "tips": "Use 10000+ amostras para boa aproximação; compare com scipy.rvs para validação.",
                                  "learningObjective": "Verificar corretude e eficiência do método através de métricas quantitativas.",
                                  "commonMistakes": [
                                    "Poucas amostras levando a viés",
                                    "Ignorar discrepâncias em caudas da distribuição"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente aceitação-rejeição para gerar 10000 amostras de Beta(2,5) usando Uniforme(0,1) como g(x) com M=2.3. Plote histograma, calcule taxa de aceitação (~0.45) e valide média ~0.286 vs teórica.",
                              "finalVerifications": [
                                "Taxa de aceitação calculada e >0.2 para eficiência razoável.",
                                "Estatísticas amostrais (média, var) dentro de 5% dos valores teóricos.",
                                "Gráficos mostram boa sobreposição histograma vs pdf.",
                                "KS-test confirma distribuição gerada matches teórica (p>0.05).",
                                "Código roda sem erros para gamma(3,2) também.",
                                "Documentação inclui M usado e número total de propostas."
                              ],
                              "assessmentCriteria": [
                                "Corretude do envelope: h(x) >= f(x) para todos x testados.",
                                "Eficiência: taxa aceitação otimizada (>0.3 ideal).",
                                "Qualidade amostras: testes estatísticos passam.",
                                "Código limpo, modular e comentado.",
                                "Validação visual e quantitativa completa.",
                                "Generalização para gamma/beta demonstrada."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Inferência e validação de distribuições.",
                                "Programação: Algoritmos numéricos e simulação Monte Carlo.",
                                "Probabilidade: Teoria de densidades e sampling.",
                                "Visualização de Dados: Plots com Matplotlib/Seaborn."
                              ],
                              "realWorldApplication": "Em simulações financeiras para modelar retornos de ativos com distribuições beta/gamma (risco); em bioinformática para gerar contagens genéticas via gamma; otimização bayesiana em ML onde sampling eficiente é crucial."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.4.3.3",
                            "name": "Gerar variáveis discretas por convolução",
                            "description": "Codificar soma de variáveis independentes (convolução) para distribuições como soma de exponenciais (Erlang) ou binomial, integrando com geradores de uniformes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a convolução de distribuições discretas",
                                  "subSteps": [
                                    "Revise as funções de massa de probabilidade (PMF) para distribuições discretas básicas como Bernoulli e Geométrica.",
                                    "Estude a definição matemática da convolução: PMF da soma Z = X + Y é p_Z(k) = ∑ p_X(i) * p_Y(k-i) para i onde definido.",
                                    "Analise exemplos simples: soma de duas Bernoulli independentes resulta em Bernoulli com p alterado ou Binomial(2,p).",
                                    "Discuta independência: soma de independentes tem PMF convolucionada.",
                                    "Explore propriedades: momentos aditivos E[Z] = E[X] + E[Y]."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a fórmula de convolução e compute manualmente PMF para soma de duas Bernoulli(p=0.5).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Notebook com Python/Jupyter",
                                    "Documentação de probabilidade discreta (ex: Wikipedia PMF)",
                                    "Papel e caneta para cálculos manuais"
                                  ],
                                  "tips": "Use diagramas de Venn ou árvores para visualizar somas independentes.",
                                  "learningObjective": "Dominar a teoria da convolução discreta e sua interpretação como soma de independentes.",
                                  "commonMistakes": [
                                    "Confundir convolução com produto de PMFs",
                                    "Ignorar limites de suporte discreto",
                                    "Esquecer normalização da PMF"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar geração de variáveis discretas primitivas com uniformes",
                                  "subSteps": [
                                    "Implemente gerador de uniforme [0,1) usando random.random().",
                                    "Crie função para Bernoulli(p): if U < p then 1 else 0.",
                                    "Desenvolva gerador para Geométrica (sucessos até primeiro fracasso): conte trials até U cumulativa exceder 1-p.",
                                    "Teste com 1000 amostras e compare média com valor teórico E[X].",
                                    "Generalize para outras discretas simples via método da inversa CDF."
                                  ],
                                  "verification": "Gere 10000 amostras de Bernoulli(0.3), compute proporção de 1s (deve ≈0.3 ±0.01).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com numpy e matplotlib",
                                    "Código base para random.uniform"
                                  ],
                                  "tips": "Use np.cumsum para CDF inversa eficiente em distribuições discretas.",
                                  "learningObjective": "Gerar amostras de primitivas discretas integrando com geradores uniformes.",
                                  "commonMistakes": [
                                    "Usar random.random() sem seed para reprodutibilidade",
                                    "Erro em off-by-one no loop de Geométrica",
                                    "Não discretizar corretamente o suporte"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Codificar a soma de variáveis independentes independentes",
                                  "subSteps": [
                                    "Escreva função para somar n independentes: loop ou recursão para gerar cada e somar.",
                                    "Implemente para Binomial(n,p): some n Bernoulli(p).",
                                    "Adapte para soma de Geométricas: Negative Binomial (trials até r sucessos).",
                                    "Inclua opção para diferentes distribuições por lista de parâmetros.",
                                    "Visualize histograma das somas com PMF teórica sobreposta."
                                  ],
                                  "verification": "Gere Binomial(10,0.4) via soma, compare KS-test com scipy.stats.binom (p>0.05).",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "numpy",
                                    "matplotlib",
                                    "scipy.stats para validação"
                                  ],
                                  "tips": "Vetorize com np.random para eficiência em grandes n.",
                                  "learningObjective": "Implementar geração por convolução prática via soma repetida.",
                                  "commonMistakes": [
                                    "Corrigir independência (não reutilizar seeds)",
                                    "Overflow em somas grandes sem tipos int64",
                                    "Ignorar variância crescente com n"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e estender para casos como Erlang discreta",
                                  "subSteps": [
                                    "Discretize exponencial: Geométrica como aproximação discreta de Expo(λ).",
                                    "Gere Erlang discreta: soma de k Geométricas independentes.",
                                    "Compute estatísticas: média, variância e compare com teóricas.",
                                    "Teste robustez: varie parâmetros e n, cheque normalidade para grandes k (CLT).",
                                    "Documente código com comentários sobre eficiência vs métodos diretos."
                                  ],
                                  "verification": "Para soma de 5 Geom(0.2), média ≈5/0.2=25, verifique |média_amostra - 25| < 1.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código dos steps anteriores",
                                    "scipy.stats.nbinom para NegBin validação"
                                  ],
                                  "tips": "Use seed(np.random.seed(42)) para resultados reproduzíveis.",
                                  "learningObjective": "Aplicar convolução a casos avançados e validar numericamente.",
                                  "commonMistakes": [
                                    "Confundir Erlang contínua com discreta sem discretização",
                                    "Não escalar λ para match Expo",
                                    "Subestimar tempo computacional para k grande"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente um simulador de chegadas em fila: use soma de 3 Geométricas(p=0.1) para tempo entre chegadas discretas (dias), gere 1000 amostras e plote histograma vs PMF NegBin(r=3,p=0.1). Integre com uniformes para cada Geométrica.",
                              "finalVerifications": [
                                "Código gera PMFs que matcham teóricas (KS-test p>0.01).",
                                "Médias e variâncias das amostras estão dentro de 2 desvios teóricos.",
                                "Histograma visualmente sobrepõe PMF convolucionada.",
                                "Execução eficiente: <1s para 10k amostras de Binomial(50,p).",
                                "Reprodutível com seed fixo.",
                                "Sem erros de indexação ou overflow."
                              ],
                              "assessmentCriteria": [
                                "Precisão: match estatístico >95% com teórico.",
                                "Eficiência: O(n) tempo para soma de n variáveis.",
                                "Clareza: código comentado, funções modulares.",
                                "Generalidade: funciona para Bernoulli, Geom, params variáveis.",
                                "Validação: testes unitários incluídos.",
                                "Visualização: plots com labels e legendas."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade: teorema central limite na soma.",
                                "Programação: vetores numpy, loops eficientes.",
                                "Estatística: testes de bondade de ajuste (KS, Chi2).",
                                "Simulação: modelagem de sistemas estocásticos.",
                                "Numérico: estabilidade de somas aleatórias."
                              ],
                              "realWorldApplication": "Em simulações de filas discretas (ex: call centers), modelar tempo total de serviço como soma de tarefas independentes (Erlang discreta); em finanças, somar retornos binários para portfólios binomial aproximado; otimização de redes com delays cumulativos."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.3.1"
                            ]
                          },
                          {
                            "id": "10.1.2.4.3.4",
                            "name": "Integrar geração aleatória no modelo conceitual",
                            "description": "Incorporar geradores de variáveis aleatórias na estrutura do código de simulação, associando distribuições específicas a entidades como tempos interchegada e de processamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar entidades e pontos de aleatoriedade no modelo conceitual",
                                  "subSteps": [
                                    "Analise o modelo conceitual da simulação e liste entidades como chegadas, processamento ou saídas.",
                                    "Mapeie atributos estocásticos, ex: tempos interchegada, tempos de processamento ou falhas.",
                                    "Defina ranges realistas e parâmetros iniciais baseados em dados históricos ou literatura.",
                                    "Crie um diagrama ou tabela associando cada entidade à sua variável aleatória.",
                                    "Documente justificativas estatísticas para cada escolha de aleatoriedade."
                                  ],
                                  "verification": "Tabela ou diagrama completo mapeando entidades a variáveis aleatórias com justificativas.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Diagrama do modelo conceitual",
                                    "Literatura sobre simulações (ex: livros de Law & Kelton)",
                                    "Ferramentas de diagramação como Draw.io"
                                  ],
                                  "tips": "Priorize variáveis com maior impacto na variância do sistema, como tempos interchegada.",
                                  "learningObjective": "Mapear precisamente onde a aleatoriedade afeta o comportamento do sistema simulado.",
                                  "commonMistakes": [
                                    "Ignorar dependências entre variáveis aleatórias.",
                                    "Escolher ranges irreais sem base estatística.",
                                    "Esquecer de documentar o mapeamento."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e parametrizar distribuições probabilísticas adequadas",
                                  "subSteps": [
                                    "Estude distribuições comuns: Exponencial para tempos interchegada, Uniforme para durações fixas variáveis, Normal para erros.",
                                    "Colete ou estime parâmetros (média, variância) via dados reais ou testes de hipóteses.",
                                    "Valide a adequação com testes como Kolmogorov-Smirnov ou QQ-plots.",
                                    "Defina seeds para reprodutibilidade em testes iniciais.",
                                    "Crie uma especificação escrita com fórmulas e parâmetros para cada distribuição."
                                  ],
                                  "verification": "Especificação documentada com parâmetros e justificativa de adequação para cada distribuição.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Bibliotecas como NumPy/SciPy para testes",
                                    "Dados históricos ou gerados sinteticamente",
                                    "Tabelas de distribuições probabilísticas"
                                  ],
                                  "tips": "Use Exponential para processos de memória zero; evite Normal para tempos positivos.",
                                  "learningObjective": "Escolher distribuições que reflitam fielmente os processos estocásticos do sistema real.",
                                  "commonMistakes": [
                                    "Usar distribuição inadequada (ex: Uniforme para tempos interchegada).",
                                    "Parâmetros não calibrados causando viés.",
                                    "Esquecer bounds para evitar valores negativos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar funções geradoras de variáveis aleatórias",
                                  "subSteps": [
                                    "Crie funções modulares para cada gerador (ex: def generate_interarrival(lambda): return np.random.exponential(1/lambda)).",
                                    "Incorpore seeds e configurações parametrizáveis.",
                                    "Teste individualmente cada gerador gerando amostras e plotando histogramas.",
                                    "Garanta compatibilidade com a linguagem de simulação (Python, R, etc.).",
                                    "Adicione logs para rastrear valores gerados durante execução."
                                  ],
                                  "verification": "Funções testadas individualmente com histogramas e estatísticas descritivas coincidentes aos parâmetros.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Python com NumPy/SciPy/Matplotlib",
                                    "Jupyter Notebook para testes interativos"
                                  ],
                                  "tips": "Use np.random.seed() para reprodutibilidade; vetorize gerações para eficiência.",
                                  "learningObjective": "Desenvolver geradores robustos e testáveis de variáveis aleatórias.",
                                  "commonMistakes": [
                                    "Não usar inversa da CDF corretamente para distribuições customizadas.",
                                    "Gerar amostras insuficientes para validação.",
                                    "Funções não parametrizáveis."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar geradores no código da simulação e validar",
                                  "subSteps": [
                                    "Substitua valores fixos pelas chamadas aos geradores nas estruturas de dados ou loops.",
                                    "Ajuste o fluxo do modelo para incorporar as variáveis geradas dinamicamente.",
                                    "Execute simulações completas e colete métricas (médias, desvios).",
                                    "Compare saídas com modelo determinístico para confirmar impacto da aleatoriedade.",
                                    "Refatore código para modularidade, permitindo troca de distribuições."
                                  ],
                                  "verification": "Simulação executa sem erros, produzindo saídas estocásticas consistentes com expectativas teóricas.",
                                  "estimatedTime": "2-4 horas",
                                  "materials": [
                                    "Código base da simulação",
                                    "Ferramentas de profiling (ex: cProfile)",
                                    "Plots para análise de resultados"
                                  ],
                                  "tips": "Inicie com poucas réplicas para depuração rápida; aumente para precisão.",
                                  "learningObjective": "Integrar aleatoriedade de forma seamless no modelo computacional.",
                                  "commonMistakes": [
                                    "Integração causando loops infinitos ou crashes.",
                                    "Não sincronizar seeds entre geradores correlacionados.",
                                    "Ignorar overhead computacional de gerações frequentes."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila M/M/1 (um servidor), integre np.random.exponential(1/5) para tempos interchegada (λ=5/hora) e np.random.exponential(1/4) para tempos de processamento (μ=4/hora). Execute 1000 réplicas e verifique se o tempo médio na fila aproxima 4/ (4*1) =1 hora pela fórmula de Little.",
                              "finalVerifications": [
                                "Valores gerados respeitam parâmetros das distribuições (teste KS p>0.05).",
                                "Modelo executa múltiplas réplicas sem crashes ou anomalias.",
                                "Métricas agregadas (média, IC 95%) convergem para valores teóricos.",
                                "Código é modular: troca de distribuição altera comportamento corretamente.",
                                "Logs mostram distribuição realista de eventos estocásticos.",
                                "Reprodutibilidade: mesmas seeds geram mesmas sequências."
                              ],
                              "assessmentCriteria": [
                                "Precisão no mapeamento de entidades a distribuições (100% cobertura).",
                                "Implementação correta e eficiente dos geradores (sem bugs evidentes).",
                                "Documentação completa de parâmetros e justificativas.",
                                "Validação estatística robusta com testes e visualizações.",
                                "Modularidade do código para extensibilidade.",
                                "Impacto mensurável da aleatoriedade nas métricas do sistema."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística (distribuições, testes de adequação)",
                                "Programação Orientada a Objetos (funções modulares)",
                                "Análise de Sistemas em Filas (teoria de colas)",
                                "Visualização de Dados (histogramas, QQ-plots)",
                                "Otimização Computacional (seeds e reprodutibilidade)"
                              ],
                              "realWorldApplication": "Em simulações de call centers para dimensionar atendentes, considerando chegadas aleatórias; em manufatura para prever gargalos com tempos de máquina variáveis; ou em logística para modelar atrasos estocásticos em entregas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.1.1",
                              "10.1.2.4.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.5",
                    "name": "Verificação do Modelo",
                    "description": "Testes para garantir que o modelo computacional foi implementado corretamente.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.5.1",
                        "name": "Inspeção Estática do Modelo",
                        "description": "Técnicas de revisão manual do código e lógica do modelo sem execução, para identificar erros conceituais e de implementação antes dos testes dinâmicos.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.1.1",
                            "name": "Realizar Code Walkthrough",
                            "description": "Executar uma revisão passo a passo do código fonte com colegas ou sozinho, verificando a lógica de eventos discretos, filas e transições de estado conforme o modelo conceitual.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparação para o Code Walkthrough",
                                  "subSteps": [
                                    "Reúna o código fonte completo e o modelo conceitual (diagrama de estados, fluxos de eventos discretos e filas).",
                                    "Identifique os participantes (colegas ou auto-revisão) e defina o escopo: focar em lógica de eventos, filas e transições.",
                                    "Crie um checklist inicial baseado no modelo: entradas/saídas de filas, triggers de eventos, validações de estado.",
                                    "Configure o ambiente: editor de código com highlights de sintaxe e ferramentas de diagramação.",
                                    "Revise brevemente o código sozinho para familiarizar-se com a estrutura geral."
                                  ],
                                  "verification": "Checklist de preparação preenchido e compartilhado com participantes; todos materiais acessíveis.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": "Código fonte, modelo conceitual (PDF/diagrama), checklist em documento compartilhado, editor de código (VS Code).",
                                  "tips": "Priorize o modelo conceitual como referência absoluta para evitar viés do código.",
                                  "learningObjective": "Entender completamente o escopo e alinhar expectativas antes da revisão.",
                                  "commonMistakes": "Pular a revisão do modelo conceitual, levando a misalignment; não envolver participantes cedo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Walkthrough Inicial Linha por Linha",
                                  "subSteps": [
                                    "Inicie do topo: trace a inicialização de variáveis de estado, filas e eventos.",
                                    "Simule execução manual: anote valores de variáveis em cada linha crítica (ex: enqueue/dequeue em filas).",
                                    "Marque pontos de entrada/saída de funções relacionadas a eventos discretos.",
                                    "Discuta verbalmente ou anote fluxos condicionais (if/else para transições de estado).",
                                    "Pausa em blocos complexos para desenhar fluxogramas manuais."
                                  ],
                                  "verification": "Mapa de execução manual completo com valores simulados anotados para pelo menos 80% das linhas.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": "Papel/caneta para anotações manuais, quadro branco virtual (Miro/Jamboard), código destacado.",
                                  "tips": "Use 'rubber duck debugging': explique cada linha como se estivesse ensinando uma criança.",
                                  "learningObjective": "Mapear o fluxo de execução e identificar discrepâncias superficiais cedo.",
                                  "commonMistakes": "Ler código muito rápido sem simulação manual; ignorar inicializações de filas vazias."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificação Detalhada de Lógica Crítica",
                                  "subSteps": [
                                    "Valide eventos discretos: confirme triggers corretos e ordem de processamento (FIFO em filas).",
                                    "Inspecione transições de estado: trace mudanças (idle -> busy) e condições de reversão.",
                                    "Teste cenários edge: fila vazia/cheia, eventos simultâneos, estados inválidos.",
                                    "Compare com modelo conceitual: cada transição codificada matches o diagrama?",
                                    "Registre anomalias: loops infinitos potenciais ou vazamentos de eventos."
                                  ],
                                  "verification": "Relatório de validação com matches/discrepâncias listadas para todos componentes críticos.",
                                  "estimatedTime": "60-90 minutos",
                                  "materials": "Modelo conceitual impresso, planilha de cenários edge (Google Sheets), debugger mental anotado.",
                                  "tips": "Simule 3-5 cenários reais do domínio (ex: chegada de clientes em fila de banco).",
                                  "learningObjective": "Garantir fidelidade da lógica de simulação ao modelo teórico.",
                                  "commonMistakes": "Focar só em sintaxe, ignorando semântica de eventos; não testar edges como fila overflow."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Análise Colaborativa e Identificação de Issues",
                                  "subSteps": [
                                    "Discuta achados com colegas: cada um apresenta uma seção e recebe feedback.",
                                    "Priorize issues: críticos (erros lógicos), médios (ineficiências em filas), menores (estilo).",
                                    "Brainstorm soluções: refatore trechos problemáticos no local se possível.",
                                    "Vote em severidade usando escala (1-5) para consenso.",
                                    "Atualize checklist com issues resolvidos/pendentes."
                                  ],
                                  "verification": "Minutas da discussão com issues priorizados e responsáveis atribuídos.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": "Ferramenta colaborativa (Zoom/Discord com screen share), planilha de issues (Trello/Jira).",
                                  "tips": "Promova 'devil's advocate': um participante defende possíveis falhas intencionalmente.",
                                  "learningObjective": "Desenvolver habilidades de revisão em equipe e priorização.",
                                  "commonMistakes": "Dominância de uma voz; não documentar desacordos para follow-up."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentação e Fechamento",
                                  "subSteps": [
                                    "Compile relatório final: sumário de issues, sugestões de fixes e status do modelo.",
                                    "Atualize código com comentários inline sobre findings.",
                                    "Planeje próximo passo: unit tests para issues identificados.",
                                    "Auto-avaliação: o que funcionou no walkthrough?",
                                    "Compartilhe relatório com stakeholders."
                                  ],
                                  "verification": "Relatório final aprovado por todos participantes; código atualizado com comentários.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": "Template de relatório (Google Doc), versão controlada do código (Git).",
                                  "tips": "Use templates padronizados para relatórios para consistência futura.",
                                  "learningObjective": "Formalizar lições aprendidas para iterações futuras.",
                                  "commonMistakes": "Pular documentação, perdendo conhecimento para revisões subsequentes."
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado: trace o código linha 45 (chegada de cliente: enqueue na fila), verifique se estado muda de 'aberto' para 'processando' só após dequeue, simule 10 clientes chegando simultaneamente para checar overflow, identifique bug onde eventos de pagamento são perdidos em transições.",
                              "finalVerifications": [
                                "Código alinhado 100% com diagrama de estados do modelo conceitual.",
                                "Todos eventos discretos processados na ordem correta (FIFO comprovado).",
                                "Cenários edge (fila vazia/cheia) sem crashes lógicos simulados.",
                                "Transições de estado bidirecionais validadas (ex: busy -> idle).",
                                "Checklist de issues zerado ou priorizado com plano de ação.",
                                "Comentários inline adicionados em pontos críticos."
                              ],
                              "assessmentCriteria": [
                                "Profundidade da simulação manual: cobertura de >90% das linhas lógicas.",
                                "Precisão na detecção de discrepâncias com o modelo (zero falsos negativos).",
                                "Qualidade da colaboração: todos participantes contribuíram igualmente.",
                                "Eficiência temporal: completado dentro do estimado com outputs acionáveis.",
                                "Documentação completa e acionável para próximos passos.",
                                "Criatividade em cenários testados (além do básico)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Teoria de Filas e Autômatos Finitos.",
                                "Engenharia de Software: Práticas de Code Review e Debugging.",
                                "Lógica Computacional: Verificação Formal de Propriedades.",
                                "Gestão de Projetos: Técnicas Ágeis de Inspeção em Pares."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software para simulações industriais, como logística de supply chain (gerenciamento de filas de caminhões) ou telecomunicações (roteamento de pacotes em redes), onde code walkthroughs previnem falhas caras em produção, reduzindo downtime em 30-50% conforme estudos da IEEE."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.1.2",
                            "name": "Aplicar Checklist de Verificação",
                            "description": "Utilizar uma lista de verificação padrão para simulações discretas, cobrindo sintaxe, inicialização de variáveis aleatórias, tratamento de exceções e consistência com diagrama de eventos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o Checklist e os Materiais de Inspeção",
                                  "subSteps": [
                                    "Obter o checklist padrão para simulações discretas de fontes confiáveis (ex: repositório do curso).",
                                    "Coletar o código fonte do modelo de simulação a ser verificado.",
                                    "Reunir o diagrama de eventos correspondente ao modelo.",
                                    "Configurar um ambiente de edição de código com suporte a linting (ex: VS Code com Python linter).",
                                    "Revisar brevemente o escopo do checklist: sintaxe, variáveis aleatórias, exceções e diagrama."
                                  ],
                                  "verification": "Lista de materiais pronta e checklist impresso ou anotado com seções marcadas como 'pendente'.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Checklist PDF ou digital",
                                    "Código fonte (.py ou similar)",
                                    "Diagrama de eventos (imagem ou PDF)",
                                    "Editor de código"
                                  ],
                                  "tips": "Marque o checklist com checkboxes para facilitar o rastreamento visual.",
                                  "learningObjective": "Identificar e organizar todos os recursos necessários para uma inspeção estática eficiente.",
                                  "commonMistakes": [
                                    "Usar versão desatualizada do checklist",
                                    "Ignorar o diagrama de eventos",
                                    "Ambiente sem ferramentas de linting"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar a Sintaxe do Código",
                                  "subSteps": [
                                    "Executar análise estática com linter (ex: pylint ou flake8).",
                                    "Ler o código linha por linha procurando erros de indentação, chaves ou operadores.",
                                    "Testar compilação ou execução parcial sem inputs para detectar erros de sintaxe.",
                                    "Documentar todos os erros encontrados e sugestões de correção.",
                                    "Confirmar que o código é sintaticamente válido após ajustes iniciais."
                                  ],
                                  "verification": "Relatório do linter sem erros críticos e código compila sem falhas de sintaxe.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta de linting instalada",
                                    "Código fonte"
                                  ],
                                  "tips": "Comece pela função main para identificar problemas globais rapidamente.",
                                  "learningObjective": "Dominar a detecção e correção de erros sintáticos em códigos de simulação.",
                                  "commonMistakes": [
                                    "Confundir warnings com erros",
                                    "Ignorar sintaxe em comentários ou strings",
                                    "Não testar compilação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Inspecionar Inicialização de Variáveis Aleatórias",
                                  "subSteps": [
                                    "Identificar todas as variáveis aleatórias (ex: seeds para RNG).",
                                    "Verificar se geradores são inicializados corretamente (ex: np.random.seed()).",
                                    "Confirmar que seeds são consistentes ou configuráveis para reprodutibilidade.",
                                    "Checar se há inicializações múltiplas desnecessárias ou ausentes.",
                                    "Testar com seed fixa para validar comportamento determinístico."
                                  ],
                                  "verification": "Todas as variáveis aleatórias têm seed inicializada e testes mostram reprodutibilidade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Bibliotecas de RNG (numpy.random, random)",
                                    "Código fonte"
                                  ],
                                  "tips": "Use print statements temporários para rastrear valores iniciais das variáveis.",
                                  "learningObjective": "Garantir reprodutibilidade em simulações estocásticas através de inicializações adequadas.",
                                  "commonMistakes": [
                                    "Esquecer seed em loops",
                                    "Usar seeds fixas em produção",
                                    "Não testar reprodutibilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Tratamento de Exceções",
                                  "subSteps": [
                                    "Localizar pontos potenciais de falha (divisão por zero, index out of range).",
                                    "Conferir presença de try-except blocks em operações críticas.",
                                    "Avaliar se exceções são tratadas de forma específica (ex: ValueError) ou genérica.",
                                    "Verificar logging ou mensagens de erro informativas.",
                                    "Simular exceções para testar o tratamento."
                                  ],
                                  "verification": "Código lida graciosamente com exceções simuladas sem crashes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código fonte",
                                    "Debugger ou testes unitários simples"
                                  ],
                                  "tips": "Priorize exceções em loops de simulação onde falhas podem invalidar runs inteiros.",
                                  "learningObjective": "Implementar tratamento robusto de exceções para simulações confiáveis.",
                                  "commonMistakes": [
                                    "Try-except too broad capturando erros legítimos",
                                    "Ausência de logging",
                                    "Ignorar exceções silenciosas"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Conferir Consistência com o Diagrama de Eventos",
                                  "subSteps": [
                                    "Mapear eventos do código com os do diagrama (ex: chegada, partida).",
                                    "Verificar ordem e condições de disparo dos eventos.",
                                    "Checar se variáveis e estados no código correspondem aos diagramados.",
                                    "Identificar discrepâncias e propor alinhamentos.",
                                    "Documentar conformidade geral."
                                  ],
                                  "verification": "Relatório de mapeamento mostrando 100% de cobertura de eventos sem discrepâncias.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagrama de eventos",
                                    "Código fonte"
                                  ],
                                  "tips": "Use cores ou anotações no diagrama para marcar eventos verificados.",
                                  "learningObjective": "Assegurar que o modelo implementado reflete fielmente o design conceitual.",
                                  "commonMistakes": [
                                    "Interpretar mal transições no diagrama",
                                    "Ignorar eventos raros",
                                    "Não mapear estados"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação discreta de fila M/M/1 em Python usando numpy, aplique o checklist: verifique sintaxe no loop de eventos, confirme np.random.seed(42) para chegadas Poisson, adicione try-except em divisões de tempo de serviço, e valide que eventos de chegada/partida batem com o diagrama de estados da fila.",
                              "finalVerifications": [
                                "Todas as seções do checklist foram completadas e assinadas.",
                                "Código passa em linting, compila e executa sem crashes.",
                                "Resultados são reprodutíveis com seed fixa.",
                                "Discrepâncias com diagrama foram resolvidas ou documentadas.",
                                "Relatório final lista issues encontrados e correções aplicadas.",
                                "Tempo total de simulação é consistente com expectativas."
                              ],
                              "assessmentCriteria": [
                                "Completude: Todas as verificações do checklist foram realizadas (30%).",
                                "Precisão: Identificação correta de erros sem falsos positivos (25%).",
                                "Documentação: Relatório claro com evidências e sugestões (20%).",
                                "Eficiência: Tempo respeitado e otimizações sugeridas (15%).",
                                "Conformidade: Alinhamento total com diagrama de eventos (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Análise estática e debugging.",
                                "Qualidade de Software: Práticas de code review e QA.",
                                "Probabilidade e Estatística: Geradores aleatórios e reprodutibilidade.",
                                "Engenharia de Sistemas: Validação de modelos contra especificações.",
                                "Gestão de Projetos: Uso de checklists para padronização."
                              ],
                              "realWorldApplication": "Checklists de verificação são essenciais em indústrias como finanças (simulações Monte Carlo para risco), logística (modelos de filas em supply chain) e telecomunicações (simulações de redes discretas), garantindo que modelos computacionais sejam confiáveis antes de decisões críticas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.1.3",
                            "name": "Análise de Fluxo de Controle",
                            "description": "Examinar fluxogramas e estruturas condicionais no código para garantir que todos os caminhos possíveis em um sistema discreto sejam cobertos e livres de loops infinitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Exame Inicial do Fluxograma",
                                  "subSteps": [
                                    "Identifique o símbolo de início e fim do fluxograma.",
                                    "Mapeie os blocos principais: processos, decisões e fluxos.",
                                    "Anote entradas, saídas e variáveis envolvidas.",
                                    "Desenhe uma visão geral simplificada do fluxograma.",
                                    "Registre observações iniciais sobre complexidade."
                                  ],
                                  "verification": "Fluxograma mapeado com todos os blocos principais anotados e visão geral desenhada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Fluxograma impresso ou digital",
                                    "Papel e caneta",
                                    "Marcadores"
                                  ],
                                  "tips": "Comece pelo início e siga as setas sequencialmente para evitar confusão.",
                                  "learningObjective": "Compreender a estrutura global do fluxograma para análise subsequente.",
                                  "commonMistakes": [
                                    "Ignorar setas de retorno",
                                    "Pular blocos de decisão",
                                    "Não anotar variáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificação de Estruturas Condicionais e Loops",
                                  "subSteps": [
                                    "Localize todos os símbolos de decisão (losangos).",
                                    "Identifique loops explícitos (setas de retorno para decisões).",
                                    "Classifique condicionais como if/else ou switch.",
                                    "Marque loops com contadores ou condições de parada.",
                                    "Liste todas as estruturas em uma tabela."
                                  ],
                                  "verification": "Tabela completa com todas as condicionais e loops identificados e classificados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Fluxograma",
                                    "Planilha ou tabela em papel",
                                    "Caneta colorida para marcar"
                                  ],
                                  "tips": "Use cores diferentes para condicionais (azul) e loops (vermelho) para visualização rápida.",
                                  "learningObjective": "Reconhecer padrões de controle de fluxo para análise de caminhos.",
                                  "commonMistakes": [
                                    "Confundir processos com decisões",
                                    "Não detectar loops aninhados",
                                    "Omitir condicionais compostas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Análise de Todos os Caminhos Possíveis",
                                  "subSteps": [
                                    "Para cada decisão, liste os ramos 'sim' e 'não'.",
                                    "Trace caminhos completos do início ao fim.",
                                    "Verifique cobertura: todos os ramos levam a um fim válido?",
                                    "Conte o número total de caminhos e documente-os.",
                                    "Identifique caminhos redundantes ou inalcançáveis."
                                  ],
                                  "verification": "Lista exaustiva de caminhos com verificação de cobertura total.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Fluxograma marcado",
                                    "Árvore de caminhos em papel ou software como Draw.io"
                                  ],
                                  "tips": "Use numeração para caminhos (ex: Caminho 1: Sim-Não-Sim) para rastreamento fácil.",
                                  "learningObjective": "Garantir que todos os cenários discretos sejam cobertos no modelo.",
                                  "commonMistakes": [
                                    "Não considerar combinações de decisões múltiplas",
                                    "Ignorar caminhos com loops",
                                    "Assumir cobertura sem traçar"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificação de Loops Infinitos e Relatório Final",
                                  "subSteps": [
                                    "Examine cada loop: há condição de saída clara?",
                                    "Simule execuções com valores extremos (contador=0, max).",
                                    "Confirme ausência de dependências circulares.",
                                    "Compile relatório com achados, riscos e recomendações.",
                                    "Sugira testes dinâmicos para validação."
                                  ],
                                  "verification": "Relatório assinado confirmando ausência de loops infinitos e cobertura completa.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Lista de caminhos",
                                    "Simulador simples ou papel para testes",
                                    "Template de relatório"
                                  ],
                                  "tips": "Teste loops com condições booleanas invertidas para detectar infinitos.",
                                  "learningObjective": "Detectar e mitigar falhas críticas em fluxos de controle.",
                                  "commonMistakes": [
                                    "Não testar condições de borda",
                                    "Aceitar loops sem contador",
                                    "Relatório incompleto"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um fluxograma de simulação de fila em um caixa de supermercado: identifique decisões como 'Fila vazia? (Sim: fim; Não: atenda cliente)', loops para 'Próximo cliente?', trace caminhos como 'Chegada múltipla sem saída' e verifique se há loop infinito sem 'Fila esvaziada'.",
                              "finalVerifications": [
                                "Todos os caminhos possíveis foram traçados e documentados.",
                                "Nenhum loop sem condição de parada explícita.",
                                "Cobertura total de entradas/saídas discretas confirmada.",
                                "Riscos de caminhos inalcançáveis identificados.",
                                "Recomendações para melhorias incluídas.",
                                "Relatório revisado por pares."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de todas as estruturas de controle (90%+).",
                                "Exaustividade na cobertura de caminhos (sem omissões).",
                                "Detecção correta de potenciais loops infinitos.",
                                "Clareza e organização do relatório.",
                                "Uso adequado de verificações e simulações.",
                                "Conexão com o contexto do sistema discreto."
                              ],
                              "crossCurricularConnections": [
                                "Lógica Proposicional (Matemática): Análise de condições booleanas.",
                                "Algoritmos e Estruturas de Dados (Programação): Grafos e árvores de decisão.",
                                "Verificação Formal (Ciência da Computação): Model checking estático.",
                                "Probabilidade Discreta (Estatística): Cobertura de estados em simulações."
                              ],
                              "realWorldApplication": "Na verificação de software para simulações industriais, como controle de tráfego aéreo ou linhas de produção, garantindo que modelos discretos cubram todos os cenários sem falhas catastróficas por loops infinitos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.5.1.2",
                        "name": "Testes Unitários e de Componentes",
                        "description": "Execução isolada de módulos individuais do modelo para verificar o funcionamento correto de funções específicas, como geradores de números aleatórios ou lógica de filas.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.1.2.1",
                            "name": "Implementar Testes Unitários",
                            "description": "Desenvolver e executar testes automatizados para componentes isolados, como a função de chegada de entidades ou atualização de relógios de simulação, comparando saídas com valores esperados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o Ambiente de Testes Unitários",
                                  "subSteps": [
                                    "Instalar o framework de testes (ex: pytest para Python).",
                                    "Criar um diretório de testes separado do código principal.",
                                    "Configurar arquivos de configuração como pytest.ini para relatórios.",
                                    "Importar módulos necessários do código de simulação.",
                                    "Executar um teste de smoke para validar o setup."
                                  ],
                                  "verification": "pytest roda sem erros e detecta testes vazios.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python instalado",
                                    "pytest via pip",
                                    "Código fonte da simulação",
                                    "Editor de código (VS Code)"
                                  ],
                                  "tips": "Use ambientes virtuais (venv) para isolar dependências.",
                                  "learningObjective": "Configurar um ambiente isolado e funcional para testes unitários.",
                                  "commonMistakes": [
                                    "Não usar virtualenv levando a conflitos de pacotes",
                                    "Esquecer de instalar pytest",
                                    "Misturar código de produção e testes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Isolar o Componente a Testar",
                                  "subSteps": [
                                    "Selecionar função específica, ex: funcao_chegada_entidades(tempo_atual).",
                                    "Extrair a função para um módulo isolado se necessário.",
                                    "Mockar dependências externas como geradores de números aleatórios.",
                                    "Definir interface clara: inputs (tempo) e outputs esperados (entidade chegada ou não).",
                                    "Documentar pré-condições e pós-condições da função."
                                  ],
                                  "verification": "Função roda isoladamente sem dependências externas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código fonte da simulação",
                                    "Documentação da função"
                                  ],
                                  "tips": "Use funções puras sempre que possível para facilitar testes.",
                                  "learningObjective": "Isolar componentes para testes independentes.",
                                  "commonMistakes": [
                                    "Não mockar dependências causando falhas intermitentes",
                                    "Testar múltiplas funções de uma vez",
                                    "Ignorar edge cases na identificação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Casos de Teste Abrangentes",
                                  "subSteps": [
                                    "Listar casos normais: chegada em tempo exato.",
                                    "Incluir edge cases: tempo zero, tempo negativo, múltiplas chegadas.",
                                    "Definir casos de erro: inputs inválidos.",
                                    "Especificar valores esperados para cada input.",
                                    "Priorizar cobertura: 80% linhas, 100% branches críticos."
                                  ],
                                  "verification": "Tabela de casos de teste cobre happy path, edges e erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou Markdown para tabela de testes",
                                    "Especificação da função"
                                  ],
                                  "tips": "Use TDD: escreva testes antes do código se possível.",
                                  "learningObjective": "Criar casos de teste que garantam robustez.",
                                  "commonMistakes": [
                                    "Focar só em casos normais ignorando edges",
                                    "Valores esperados incorretos por falta de cálculo",
                                    "Poucos testes levando a cobertura baixa"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e Codificar os Testes Unitários",
                                  "subSteps": [
                                    "Criar arquivo test_modelo.py com classe TestChegadaEntidades.",
                                    "Escrever funções assert para cada caso: assert funcao(input) == expected.",
                                    "Usar parametrize para múltiplos casos.",
                                    "Adicionar asserts para exceções: pytest.raises.",
                                    "Garantir nomes descritivos: test_chegada_em_tempo_exato."
                                  ],
                                  "verification": "Código de teste passa linting e syntax check.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Framework pytest",
                                    "Editor com suporte a pytest"
                                  ],
                                  "tips": "Nomes de testes devem ser legíveis como sentenças.",
                                  "learningObjective": "Codificar testes automatizados e legíveis.",
                                  "commonMistakes": [
                                    "Hardcodear valores em asserts",
                                    "Não usar parametrize para repetição",
                                    "Testes frágeis dependentes de estado global"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Executar, Depurar e Refatorar Testes",
                                  "subSteps": [
                                    "Rodar pytest -v para execução verbose.",
                                    "Analisar falhas e corrigir código ou testes.",
                                    "Medir cobertura com pytest-cov.",
                                    "Refatorar testes para clareza e performance.",
                                    "Commitar testes no repositório com mensagem descritiva."
                                  ],
                                  "verification": "100% dos testes passam e cobertura >90%.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "pytest-cov instalado",
                                    "Git para versionamento"
                                  ],
                                  "tips": "Execute testes frequentemente durante desenvolvimento.",
                                  "learningObjective": "Garantir testes confiáveis e manter alta cobertura.",
                                  "commonMistakes": [
                                    "Ignorar warnings de cobertura",
                                    "Não depurar falhas imediatamente",
                                    "Testes lentos por falta de mocks"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a função chegada_entidades(tempo_atual, interarrivals=[5,3]): teste que em tempo=5 retorna 1 entidade chegada, comparando com expected=1; edge case tempo=2 retorna 0.",
                              "finalVerifications": [
                                "Todos os testes passam consistentemente (pytest -v).",
                                "Cobertura de código >90% para o componente.",
                                "Testes rodam em <1 segundo.",
                                "Refatoração do código não quebra testes.",
                                "Documentação dos testes atualizada.",
                                "Testes isolados: falha em um não afeta outros."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos asserts: 100% corretos.",
                                "Cobertura abrangente: inclui edges e erros.",
                                "Legibilidade: nomes e estrutura clara.",
                                "Eficiência: tempo de execução rápido.",
                                "Manutenibilidade: fácil adicionar novos testes.",
                                "Robustez: mocks adequados, sem flakiness."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Práticas de TDD e Clean Code.",
                                "Matemática: Modelagem probabilística em chegadas (Poisson).",
                                "Estatística: Validação de simulações via testes.",
                                "Engenharia de Software: Ciclo de vida de desenvolvimento."
                              ],
                              "realWorldApplication": "Em simulações de filas em call centers ou logística, testes unitários garantem que modelos de chegada de clientes sejam precisos, evitando erros caros em decisões baseadas em simulações."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.1.2.2",
                            "name": "Verificar Geração de Variáveis Aleatórias",
                            "description": "Testar a distribuição de variáveis aleatórias (ex.: exponencial para tempos de serviço) usando testes estatísticos como qui-quadrado para confirmar aderência à distribuição teórica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar e Gerar Amostra de Variáveis Aleatórias",
                                  "subSteps": [
                                    "Selecionar a distribuição teórica (ex.: exponencial com parâmetro λ conhecido)",
                                    "Definir tamanho da amostra N (mínimo 1000 para boa precisão)",
                                    "Implementar gerador de variáveis aleatórias usando biblioteca apropriada (ex.: numpy.random.exponential)",
                                    "Salvar os dados gerados em um array ou arquivo para análise"
                                  ],
                                  "verification": "Verificar se foram geradas exatamente N variáveis e inspecionar estatísticas descritivas básicas (média, variância) que aproximem os valores teóricos",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com NumPy e SciPy",
                                    "Jupyter Notebook ou IDE",
                                    "Documentação da distribuição teórica"
                                  ],
                                  "tips": "Use sementes fixas (np.random.seed) para reprodutibilidade durante testes iniciais",
                                  "learningObjective": "Entender como gerar variáveis aleatórias sintéticas aderentes a uma distribuição específica",
                                  "commonMistakes": [
                                    "Escolher N muito pequeno levando a variância alta",
                                    "Confundir parâmetros da distribuição (ex.: scale vs. rate na exponencial)",
                                    "Não fixar semente causando resultados não reproduzíveis"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar Dados: Construir Histograma e Frequências Observadas",
                                  "subSteps": [
                                    "Definir número de bins usando regra de Sturges ou sqrt(N)",
                                    "Criar histograma das variáveis geradas",
                                    "Calcular frequências observadas (Oi) em cada bin",
                                    "Normalizar frequências para proporções se necessário"
                                  ],
                                  "verification": "Histograma deve mostrar forma aproximada da PDF teórica; somar Oi deve igualar N",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python: NumPy, Matplotlib ou Seaborn para plot",
                                    "Ferramenta de visualização gráfica"
                                  ],
                                  "tips": "Evite bins vazios ajustando limites ou número de bins; plote overlay da PDF teórica",
                                  "learningObjective": "Preparar dados empíricos para comparação com distribuição teórica via discretização",
                                  "commonMistakes": [
                                    "Número inadequado de bins (muito poucos ou muitos)",
                                    "Ignorar limites dos bins levando a frequências incorretas",
                                    "Não visualizar o histograma antes de prosseguir"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Frequências Esperadas e Estatística Qui-Quadrado",
                                  "subSteps": [
                                    "Calcular probabilidades teóricas (Pi) para cada bin usando CDF da distribuição",
                                    "Computar frequências esperadas (Ei = N * Pi)",
                                    "Garantir Ei >= 5 em todos os bins (agrupar se necessário)",
                                    "Calcular estatística qui-quadrado: Σ (Oi - Ei)^2 / Ei"
                                  ],
                                  "verification": "Verificar se Σ Ei ≈ N e todos Ei >= 5; calcular χ² manualmente para validar",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python: SciPy.stats para CDF",
                                    "Calculadora ou código para soma"
                                  ],
                                  "tips": "Use scipy.stats.expon.cdf para probabilidades; agrupe bins extremos com baixa Ei",
                                  "learningObjective": "Aplicar fórmula do teste qui-quadrado para comparar observadas vs. esperadas",
                                  "commonMistakes": [
                                    "Ei < 5 em bins levando a teste inválido",
                                    "Erro na CDF (ex.: não subtrair limites corretos)",
                                    "Não ajustar graus de liberdade por agrupamento"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar Teste Estatístico e Interpretar Resultados",
                                  "subSteps": [
                                    "Usar função pronta (scipy.stats.chisquare) ou calcular p-value manualmente",
                                    "Definir nível de significância α (ex.: 0.05)",
                                    "Comparar p-value com α e rejeitar ou aceitar H0 (aderência à distribuição)",
                                    "Documentar resultados com plot e tabela de Oi/Ei"
                                  ],
                                  "verification": "p-value calculado corretamente e conclusão lógica (não rejeitar H0 indica boa aderência)",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python: SciPy.stats.chisquare",
                                    "Tabela de χ² crítica para validação manual"
                                  ],
                                  "tips": "Sempre reporte graus de liberdade (k-1-p, onde p=parâmetros estimados)",
                                  "learningObjective": "Interpretar p-value no contexto de testes de bondade de ajuste",
                                  "commonMistakes": [
                                    "Confundir H0 (aderência) com rejeição automática",
                                    "Usar α inadequado sem justificativa",
                                    "Ignorar suposições do teste qui-quadrado"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Documentar a Verificação",
                                  "subSteps": [
                                    "Repetir geração e teste com múltiplas sementes para robustez",
                                    "Comparar com outros testes (ex.: Kolmogorov-Smirnov) se possível",
                                    "Registrar relatório com código, resultados e conclusões",
                                    "Ajustar gerador se teste falhar (ex.: verificar implementação RNG)"
                                  ],
                                  "verification": "Relatório completo com pelo menos 3 runs independentes mostrando consistência",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Notebook Jupyter para relatório",
                                    "Git para versionamento de código"
                                  ],
                                  "tips": "Automatize em script para múltiplas runs; inclua Q-Q plot auxiliar",
                                  "learningObjective": "Garantir reprodutibilidade e completude na verificação de componentes de simulação",
                                  "commonMistakes": [
                                    "Teste único sem verificação de variabilidade",
                                    "Não documentar parâmetros usados",
                                    "Ignorar falhas parciais do gerador"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de tempos de serviço em um call center, gere 5000 variáveis aleatórias exponenciais com λ=0.2 (média 5 min). Construa histograma com 15 bins, calcule qui-quadrado e confirme p-value > 0.05, validando que os tempos simulados seguem a distribuição teórica para modelagem realista de filas.",
                              "finalVerifications": [
                                "p-value do teste qui-quadrado > 0.05 (não rejeita H0)",
                                "Histograma visualmente sobreposto à PDF teórica",
                                "Todas Ei >= 5 e soma Oi = soma Ei = N",
                                "Estatísticas descritivas (média, variância) dentro de 5% dos teóricos",
                                "Teste reproduzível com diferentes sementes",
                                "Relatório documentado com código e plots"
                              ],
                              "assessmentCriteria": [
                                "Implementação correta do gerador e teste qui-quadrado (sem erros de código)",
                                "Escolha adequada de N, bins e α com justificativa",
                                "Interpretação precisa do p-value e conclusão",
                                "Uso de visualizações (histograma, Q-Q plot) para suporte",
                                "Tratamento de edge cases (bins vazios, agrupamento)",
                                "Relatório claro e reprodutível"
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Testes de hipóteses e bondade de ajuste",
                                "Programação Computacional: Bibliotecas NumPy/SciPy para simulação e stats",
                                "Simulação e Modelagem: Validação de geradores RNG em Monte Carlo",
                                "Probabilidade: Propriedades de distribuições contínuas e discretização",
                                "Ciência de Dados: Análise exploratória e testes não-paramétricos"
                              ],
                              "realWorldApplication": "Na otimização de sistemas de filas em aeroportos ou hospitais, verifica-se se tempos de serviço simulados (exponenciais) aderem à teoria, permitindo simulações precisas para dimensionar recursos e reduzir esperas, evitando erros caros em planejamento operacional."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.1.2.3",
                            "name": "Testar Lógica de Eventos",
                            "description": "Simular eventos unitários, como chegada ou partida, em um ambiente controlado para validar a ordem de processamento e atualizações de estado no modelo de eventos discretos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o Ambiente de Teste Inicial",
                                  "subSteps": [
                                    "Inicialize o simulador de eventos discretos com um estado vazio (ex: fila vazia, tempo zero).",
                                    "Defina parâmetros básicos do modelo, como taxa de chegada ou serviço.",
                                    "Execute uma verificação inicial do estado para confirmar ausência de eventos pendentes.",
                                    "Configure mecanismos de logging ou depuração para rastrear eventos e estados.",
                                    "Salve uma cópia do estado inicial como baseline."
                                  ],
                                  "verification": "Confirme que o log mostra estado inicial correto e sem eventos agendados.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Simulador de eventos discretos (ex: Python com SimPy, AnyLogic ou ferramenta customizada)",
                                    "Editor de código (VS Code ou Jupyter Notebook)",
                                    "Documentação do modelo de simulação"
                                  ],
                                  "tips": "Use variáveis de debug para expor estados internos; evite configurações complexas no início.",
                                  "learningObjective": "Compreender e preparar um ambiente controlado para testes isolados.",
                                  "commonMistakes": [
                                    "Iniciar com estado não zerado",
                                    "Esquecer de ativar logs",
                                    "Configurar parâmetros irrelevantes prematuramente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Simular e Validar Evento Unitário de Chegada",
                                  "subSteps": [
                                    "Agende um único evento de chegada em um tempo específico (ex: t=0).",
                                    "Execute a simulação até o processamento desse evento.",
                                    "Verifique se o estado foi atualizado corretamente (ex: tamanho da fila aumentou em 1).",
                                    "Confira se o tempo de simulação avançou corretamente e logs registram a ordem.",
                                    "Repita o teste com variação no tempo de chegada para isolar o comportamento."
                                  ],
                                  "verification": "O estado reflete a chegada (fila +1) e logs mostram processamento único sem erros.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Simulador configurado do Step 1",
                                    "Scripts de teste unitário",
                                    "Ferramentas de visualização de logs"
                                  ],
                                  "tips": "Pause a simulação logo após o evento para inspecionar estados; compare com baseline.",
                                  "learningObjective": "Validar o processamento isolado de um evento de entrada e suas atualizações de estado.",
                                  "commonMistakes": [
                                    "Processar múltiplos eventos acidentalmente",
                                    "Ignorar atualizações de tempo",
                                    "Não resetar estado entre testes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular e Validar Evento Unitário de Partida",
                                  "subSteps": [
                                    "Prepare o estado com um elemento presente (ex: insira um via chegada manual).",
                                    "Agende um evento de partida em tempo posterior.",
                                    "Execute até o processamento e verifique redução no estado (ex: fila -1).",
                                    "Confirme que condições pré-requisitos foram checadas (ex: fila não vazia).",
                                    "Analise logs para ordem correta e ausência de estados inválidos."
                                  ],
                                  "verification": "Estado atualizado corretamente (fila -1) sem violações de lógica.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Simulador do Step 1",
                                    "Scripts de teste",
                                    "Debugger integrado"
                                  ],
                                  "tips": "Teste cenários edge como partida com fila vazia para capturar erros.",
                                  "learningObjective": "Garantir que eventos de saída respeitem dependências e atualizem estados adequadamente.",
                                  "commonMistakes": [
                                    "Executar partida sem elemento presente",
                                    "Não validar pré-condições",
                                    "Confundir ordem temporal"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar Sequência de Eventos e Ordem de Processamento",
                                  "subSteps": [
                                    "Agende uma sequência curta de eventos (ex: chegada t=1, partida t=2, chegada t=3).",
                                    "Execute a simulação completa e rastreie a fila de eventos.",
                                    "Verifique se eventos foram processados na ordem temporal correta.",
                                    "Confirme atualizações cumulativas de estado em cada passo.",
                                    "Compare estado final com expectativa manual calculada."
                                  ],
                                  "verification": "Logs mostram ordem exata de processamento e estado final matches expectativa.",
                                  "estimatedTime": "25-30 minutos",
                                  "materials": [
                                    "Simulador completo",
                                    "Planilha para cálculo manual de estados",
                                    "Ferramentas de assert em testes"
                                  ],
                                  "tips": "Use asserts automatizados para validações; visualize timeline de eventos.",
                                  "learningObjective": "Dominar a validação de interações múltiplas e ordem em modelos discretos.",
                                  "commonMistakes": [
                                    "Ignorar empates de tempo",
                                    "Não sincronizar clocks",
                                    "Sobrecarregar com muitos eventos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de banco: Agende chegada de cliente A às 9:00 (fila: 0→1), partida às 9:05 (fila:1→0). Verifique se às 9:02 a fila ainda é 1 e logs confirmam ordem sem sobreposições.",
                              "finalVerifications": [
                                "Eventos unitários atualizam estado isoladamente sem side-effects.",
                                "Sequências respeitam ordem temporal estrita.",
                                "Estados intermediários e finais coincidem com expectativas manuais.",
                                "Logs capturam todos processamentos sem gaps ou erros.",
                                "Testes edge (fila vazia, empates) são gerenciados corretamente.",
                                "Reset de ambiente funciona entre testes."
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração inicial e isolamento de testes (30%).",
                                "Correta identificação e verificação de atualizações de estado (25%).",
                                "Validação robusta de ordem e sequências (20%).",
                                "Uso efetivo de logs e debugs (15%).",
                                "Cobertura de cenários edge e common mistakes (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Testes unitários e TDD (Test-Driven Development).",
                                "Engenharia de Software: Verificação e validação de modelos.",
                                "Matemática Discreta: Filas de prioridade e algoritmos de scheduling.",
                                "Ciência da Computação: Simulação e modelagem estocástica."
                              ],
                              "realWorldApplication": "Em simulações de logística (ex: centros de distribuição da Amazon), testar lógica de eventos garante que chegadas de pacotes e despachos sejam processados na ordem certa, evitando erros em inventários e otimizações de fluxo."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.5.1.3",
                        "name": "Testes de Sistema com Casos Conhecidos",
                        "description": "Rodar o modelo completo com entradas simples e resultados analíticos conhecidos para detectar discrepâncias na implementação global.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.1.3.1",
                            "name": "Executar Simulações com Entradas Triviais",
                            "description": "Usar cenários extremos como sistema vazio, uma única entidade ou tempos determinísticos para verificar se o modelo produz saídas exatas conforme soluções analíticas simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e Definir Cenários Triviais",
                                  "subSteps": [
                                    "Analise o modelo de simulação para listar cenários extremos: sistema vazio, uma única entidade e tempos determinísticos.",
                                    "Defina parâmetros iniciais para cada cenário, como taxa de chegada zero ou chegada única em tempo t=0.",
                                    "Documente as entradas triviais em uma tabela clara com valores exatos.",
                                    "Verifique se os cenários cobrem casos limite conhecidos do modelo.",
                                    "Priorize cenários onde soluções analíticas são trivialmente conhecidas."
                                  ],
                                  "verification": "Lista de cenários triviais documentada com parâmetros e soluções esperadas iniciais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Descrição do modelo de simulação",
                                    "Planilha ou papel para tabela",
                                    "Documentação teórica do sistema"
                                  ],
                                  "tips": "Comece sempre pelo caso mais simples (sistema vazio) para ganhar confiança.",
                                  "learningObjective": "Selecionar entradas triviais relevantes que permitam verificação exata.",
                                  "commonMistakes": [
                                    "Escolher cenários complexos disfarçados de triviais.",
                                    "Omitir documentação das premissas analíticas.",
                                    "Ignorar interações entre parâmetros."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar Soluções Analíticas Esperadas",
                                  "subSteps": [
                                    "Para sistema vazio: calcule que nenhuma entidade processa e métricas como tempo médio zero.",
                                    "Para uma única entidade: resolva manualmente o tempo de permanência ou saídas exatas.",
                                    "Para tempos determinísticos: use equações simples para prever eventos e estados.",
                                    "Registre fórmulas matemáticas e resultados numéricos esperados.",
                                    "Valide as soluções analíticas com raciocínio lógico ou referências teóricas."
                                  ],
                                  "verification": "Tabela com soluções analíticas calculadas e justificadas para cada cenário.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Fórmulas analíticas do modelo",
                                    "Calculadora ou software simbólico como SymPy",
                                    "Referências bibliográficas"
                                  ],
                                  "tips": "Use álgebra elementar; evite simulações para este passo.",
                                  "learningObjective": "Calcular saídas exatas para entradas triviais usando análise matemática.",
                                  "commonMistakes": [
                                    "Erros aritméticos em cálculos simples.",
                                    "Confundir unidades de tempo ou parâmetros.",
                                    "Assumir distribuições probabilísticas em casos determinísticos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar e Executar Simulações",
                                  "subSteps": [
                                    "Configure o software de simulação com as entradas triviais exatas.",
                                    "Execute múltiplas réplicas (pelo menos 10) para casos com variância mínima.",
                                    "Registre saídas: estados, eventos, métricas como tempo médio e comprimento de fila.",
                                    "Garanta sementes fixas para reprodutibilidade em geradores de números aleatórios.",
                                    "Monitore logs para detectar anomalias durante a execução."
                                  ],
                                  "verification": "Relatório de saídas da simulação salvo para cada cenário.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de simulação (ex: SimPy, Arena)",
                                    "Computador com ambiente configurado",
                                    "Scripts de configuração"
                                  ],
                                  "tips": "Use sementes fixas para resultados determinísticos sempre que possível.",
                                  "learningObjective": "Executar simulações controladas com entradas triviais de forma reprodutível.",
                                  "commonMistakes": [
                                    "Configurar parâmetros incorretamente.",
                                    "Executar poucas réplicas.",
                                    "Ignorar efeitos de inicialização transitória."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Resultados e Validar o Modelo",
                                  "subSteps": [
                                    "Compare saídas numéricas da simulação com soluções analíticas usando métricas de erro (ex: diferença absoluta < 1e-6).",
                                    "Identifique e investigue discrepâncias, ajustando o modelo se necessário.",
                                    "Gere gráficos ou tabelas de comparação visual.",
                                    "Conclua se o modelo passa nos testes triviais.",
                                    "Documente lições aprendidas para testes futuros."
                                  ],
                                  "verification": "Relatório final com comparações, erros e conclusão de validação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilhas para comparação (Excel, Python Pandas)",
                                    "Ferramentas de plotagem (Matplotlib)"
                                  ],
                                  "tips": "Defina tolerância de erro a priori baseada na precisão numérica.",
                                  "learningObjective": "Avaliar a fidelidade do modelo através de verificação quantitativa.",
                                  "commonMistakes": [
                                    "Aceitar erros grandes como 'ruído'.",
                                    "Não investigar causas de falhas.",
                                    "Esquecer de reportar casos falhos."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila M/M/1, configure taxa de chegada λ=0 (sistema vazio): solução analítica espera fila sempre vazia e tempo de serviço zero. Execute simulação por 1000 unidades de tempo e verifique se o comprimento médio da fila é exatamente 0.",
                              "finalVerifications": [
                                "Todas saídas da simulação coincidem com soluções analíticas dentro de tolerância numérica.",
                                "Múltiplas réplicas produzem resultados idênticos ou dentro de variância esperada.",
                                "Nenhuma anomalia em logs de eventos ou estados.",
                                "Relatório documenta todos cenários testados e conclusões.",
                                "Modelo ajustado se discrepâncias foram encontradas e corrigidas.",
                                "Testes reprodutíveis com sementes fixas."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude na definição de cenários triviais (cobertura de casos limite).",
                                "Correção matemática nas soluções analíticas derivadas.",
                                "Configuração precisa e execução reprodutível da simulação.",
                                "Análise quantitativa rigorosa de comparações (erros < 1e-6).",
                                "Documentação clara e identificação de lições aprendidas.",
                                "Capacidade de investigar e corrigir discrepâncias."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação de testes unitários em código de simulação.",
                                "Matemática: Resolução de equações diferenciais ou probabilísticas simples.",
                                "Engenharia de Software: Práticas de verificação e validação (V&V).",
                                "Estatística: Análise de variância em réplicas de simulação.",
                                "Física: Modelagem de sistemas discretos em dinâmica de partículas."
                              ],
                              "realWorldApplication": "Na engenharia aeroespacial, valida modelos de simulação de tráfego aéreo com cenários triviais (voo único) para garantir precisão antes de simulações complexas, evitando erros caros em design de sistemas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.1.3.2",
                            "name": "Realizar Execução Passo a Passo",
                            "description": "Executar o modelo em modo debug, avançando um evento por vez, e registrar manualmente o estado do sistema para comparação com expectativas teóricas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o Ambiente de Debug e Preparar Registros",
                                  "subSteps": [
                                    "Carregue o modelo de simulação no ambiente de execução.",
                                    "Ative o modo debug ou passo a passo na ferramenta de simulação.",
                                    "Crie uma tabela ou planilha para registrar estados: colunas para evento, tempo, estado do sistema (ex: filas, recursos), variáveis chave.",
                                    "Defina as expectativas teóricas para os primeiros eventos baseadas no modelo.",
                                    "Teste a configuração executando um evento nulo para validar o setup."
                                  ],
                                  "verification": "Confirme que o debugger pausa no primeiro evento e a tabela de registro está pronta e vazia.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Código do modelo de simulação",
                                    "Ferramenta de debug (ex: IDE com breakpoints ou simpy.step())",
                                    "Planilha ou papel para registros",
                                    "Documentação do modelo com expectativas teóricas"
                                  ],
                                  "tips": "Use breakpoints condicionais para pausar apenas em eventos relevantes; salve o estado inicial como baseline.",
                                  "learningObjective": "Preparar um ambiente controlado para execução manual passo a passo.",
                                  "commonMistakes": [
                                    "Esquecer de ativar modo debug",
                                    "Não definir expectativas teóricas antecipadamente",
                                    "Tabela de registro incompleta"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar e Registrar os Primeiros Eventos",
                                  "subSteps": [
                                    "Avance o primeiro evento usando o comando de step/debug.",
                                    "Registre manualmente: número do evento, tempo simulado, estado completo do sistema (ex: número em fila, servidor ocupado).",
                                    "Compare o estado registrado com a expectativa teórica para esse evento.",
                                    "Anote qualquer discrepância observada.",
                                    "Repita para 2-3 eventos iniciais, pausando após cada um."
                                  ],
                                  "verification": "Todos os primeiros eventos foram executados, registrados e comparados sem erros de configuração.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ambiente de debug configurado",
                                    "Tabela de registros atualizada",
                                    "Expectativas teóricas impressas ou em tela"
                                  ],
                                  "tips": "Registre estados em formato tabular para facilitar comparações visuais; use cópias de variáveis para evitar mutações acidentais.",
                                  "learningObjective": "Dominar a execução e documentação precisa de eventos iniciais em simulações discretas.",
                                  "commonMistakes": [
                                    "Avançar múltiplos eventos de uma vez",
                                    "Registro incompleto de variáveis de estado",
                                    "Ignorar pequenas discrepâncias iniciais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Prosseguir com Eventos Subsequentes e Monitorar Evolução",
                                  "subSteps": [
                                    "Continue avançando eventos um por um até o meio da simulação.",
                                    "Registre estados após cada evento, focando em componentes dinâmicos como filas e alocações.",
                                    "Compare cada estado com expectativas cumulativas teóricas.",
                                    "Identifique padrões emergentes ou erros propagados.",
                                    "Pausar se detectar anomalias e investigue variáveis intermediárias."
                                  ],
                                  "verification": "Registros completos para pelo menos 50% dos eventos, com comparações realizadas e notas de discrepâncias.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de registros em andamento",
                                    "Debugger ativo",
                                    "Lista de expectativas teóricas estendida"
                                  ],
                                  "tips": "Mantenha consistência no formato de registro; use cores para destacar matches (verde) vs mismatches (vermelho).",
                                  "learningObjective": "Executar e analisar sequências longas de eventos em modo passo a passo.",
                                  "commonMistakes": [
                                    "Perder o ritmo e avançar rápido demais",
                                    "Não registrar todas as variáveis relevantes",
                                    "Ignorar propagação de erros de eventos anteriores"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar Execução, Comparar Integralmente e Analisar",
                                  "subSteps": [
                                    "Complete todos os eventos restantes, registrando até o fim da simulação.",
                                    "Compile uma visão geral: resuma matches, mismatches e taxas de acerto.",
                                    "Analise causas raízes de discrepâncias (ex: lógica de modelo errada).",
                                    "Gere um relatório final com tabelas comparativas.",
                                    "Valide o estado final contra o resultado teórico esperado."
                                  ],
                                  "verification": "Relatório completo gerado, com análise de todas as discrepâncias resolvidas ou explicadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Registros completos",
                                    "Ferramentas de análise (ex: Excel para gráficos)",
                                    "Modelo teórico de referência"
                                  ],
                                  "tips": "Automatize comparações simples com fórmulas em planilha; documente lições aprendidas para iterações futuras.",
                                  "learningObjective": "Sintetizar dados de debug para validar o modelo de simulação.",
                                  "commonMistakes": [
                                    "Parar antes do fim",
                                    "Análise superficial de discrepâncias",
                                    "Relatório incompleto"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila M/M/1 (caixa de supermercado), configure debug no modelo Python com simpy. Avance: chegada cliente 1 (fila=1), serviço inicia (fila=0, ocupado=1), serviço termina (fila=0, ocupado=0). Registre estados após cada evento e compare com teoria: tempo de espera esperado=0 para primeiro cliente.",
                              "finalVerifications": [
                                "Todos os eventos foram executados passo a passo sem skips.",
                                "Estados registrados correspondem 100% aos capturados no debug.",
                                "Comparações com expectativas teóricas completas e documentadas.",
                                "Discrepâncias analisadas com causas identificadas.",
                                "Relatório final gerado e salvo.",
                                "Estado final do sistema matches expectativa teórica."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude dos registros de estado (90%+ acurácia).",
                                "Detecção e análise correta de discrepâncias.",
                                "Eficiência no uso do modo debug (sem erros de operação).",
                                "Qualidade do relatório comparativo (claro, tabular, analítico).",
                                "Compreensão demonstrada das expectativas teóricas.",
                                "Tempo respeitado sem comprometer qualidade."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Uso de debuggers e breakpoints.",
                                "Matemática: Teoria de filas e processos estocásticos.",
                                "Engenharia de Software: Testes unitários e validação de modelos.",
                                "Estatística: Análise de desvios e validação empírica."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software embarcado ou simulações industriais (ex: logística de supply chain), essa técnica permite detectar bugs sutis em sistemas discretos antes de execuções em massa, economizando tempo e recursos em cenários como otimização de tráfego ou manufatura."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.1.3.3",
                            "name": "Comparar com Modelos Analíticos",
                            "description": "Rodar simulações de sistemas simples (ex.: fila M/M/1 com parâmetros conhecidos) e comparar estatísticas de steady-state com fórmulas de teoria de filas para validar precisão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Calcular Estatísticas Analíticas Exatas para o Modelo M/M/1",
                                  "subSteps": [
                                    "Identifique os parâmetros conhecidos: taxa de chegada λ e taxa de serviço μ.",
                                    "Verifique se ρ = λ/μ < 1 para estabilidade.",
                                    "Calcule estatísticas steady-state: L = ρ/(1-ρ) (tamanho médio da fila), W = L/λ (tempo médio na fila), Lq = ρ²/(1-ρ) (fila sem servidor), etc.",
                                    "Anote valores exatos em uma tabela para referência futura.",
                                    "Valide cálculos com fórmulas padrão de teoria de filas."
                                  ],
                                  "verification": "Tabela com valores analíticos calculados corretamente, confirmados por fórmula ou calculadora.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Fórmulas de teoria de filas (livro ou PDF)",
                                    "Calculadora ou planilha (Excel/Google Sheets)"
                                  ],
                                  "tips": "Use ρ = 0.7-0.9 para discrepâncias interessantes, mas evite ρ próximo de 1 para simulações rápidas.",
                                  "learningObjective": "Dominar fórmulas analíticas de steady-state para filas M/M/1.",
                                  "commonMistakes": "Confundir L (sistema) com Lq (fila); esquecer de verificar ρ < 1."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar e Implementar a Simulação de M/M/1",
                                  "subSteps": [
                                    "Escolha uma ferramenta de simulação (ex.: Python com SimPy, Arena, ou custom script).",
                                    "Defina geradores de chegada exponencial com taxa λ e serviço exponencial com μ.",
                                    "Implemente lógica de fila única com servidor FCFS.",
                                    "Configure warm-up period (ex.: 1000 unidades de tempo) e run length (ex.: 10000) para steady-state.",
                                    "Adicione coleta de estatísticas: contadores para número na fila/sistema, tempos de espera."
                                  ],
                                  "verification": "Código ou modelo de simulação compilado/executável sem erros e com parâmetros idênticos aos analíticos.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Linguagem de programação (Python/SimPy recomendado)",
                                    "Documentação de biblioteca de simulação"
                                  ],
                                  "tips": "Use sementes aleatórias fixas inicialmente para reproducibilidade.",
                                  "learningObjective": "Implementar corretamente um modelo de simulação discreta de eventos para M/M/1.",
                                  "commonMistakes": "Ignorar warm-up, levando a estatísticas transientes; erros em distribuições exponenciais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar Simulações e Coletar Estatísticas Steady-State",
                                  "subSteps": [
                                    "Execute múltiplas runs independentes (ex.: 30 réplicas) para reduzir variância.",
                                    "Descarte período de warm-up e calcule médias/confiança intervals para L, W, etc.",
                                    "Registre estatísticas simuladas em tabela, incluindo desvio padrão.",
                                    "Visualize com histogramas ou plots de tempo para confirmar steady-state.",
                                    "Ajuste run length se variância alta."
                                  ],
                                  "verification": "Tabela de estatísticas simuladas com intervalos de confiança sobrepostos entre runs.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": [
                                    "Computador para rodar simulações",
                                    "Ferramentas de plotagem (Matplotlib)"
                                  ],
                                  "tips": "Aumente número de runs se ICs > 5% do valor médio.",
                                  "learningObjective": "Coletar e analisar dados de simulação para estimar steady-state com precisão estatística.",
                                  "commonMistakes": "Não descartar warm-up; poucos runs levando a alta variância."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Resultados e Validar Precisão do Modelo",
                                  "subSteps": [
                                    "Compare médias simuladas com analíticas usando tabela lado a lado.",
                                    "Calcule erros relativos: |sim - analítico| / analítico * 100%.",
                                    "Teste hipóteses (ex.: t-test) para verificar se diferenças são estatisticamente significativas.",
                                    "Interprete discrepâncias: ajuste simulação se erro > 5%.",
                                    "Documente conclusões em relatório curto."
                                  ],
                                  "verification": "Relatório com tabela de comparação, erros < 5% e interpretação.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Planilha para cálculos de erro",
                                    "Software estatístico (Python SciPy ou R)"
                                  ],
                                  "tips": "Aceite erros até 5-10% como normais devido a amostragem.",
                                  "learningObjective": "Avaliar validade de modelo de simulação via comparação analítica.",
                                  "commonMistakes": "Ignorar intervalos de confiança nas comparações."
                                }
                              ],
                              "practicalExample": "Para uma fila de call center com λ=4 chamadas/hora e μ=5 atendimentos/hora (ρ=0.8), analítico: L=4. Valor simulado médio de 30 runs: 3.95 ± 0.12, erro relativo 1.25%.",
                              "finalVerifications": [
                                "Erros relativos das estatísticas principais < 5%.",
                                "Intervalos de confiança das simulações contêm valores analíticos.",
                                "Steady-state confirmado por plots de running average.",
                                "Múltiplas runs (≥20) com baixa variância.",
                                "Relatório documenta todos cálculos e código.",
                                "Nenhum bug evidente na simulação (testes de sanidade passam)."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Erros relativos ≤5% para L, W, Lq.",
                                "Robustez: Intervalos de confiança consistentes e estreitos.",
                                "Documentação: Tabelas claras, código comentado.",
                                "Análise: Interpretação estatística adequada de discrepâncias.",
                                "Eficiência: Tempo de simulação razoável (<1h por run).",
                                "Reprodutibilidade: Resultados iguais com mesma semente."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Intervalos de confiança e testes de hipótese.",
                                "Programação: Implementação de simulação discreta de eventos.",
                                "Probabilidade: Distribuições exponenciais e processos de Markov.",
                                "Engenharia de Software: Validação e verificação de modelos."
                              ],
                              "realWorldApplication": "Validar modelos de simulação em logística (filas de produção), TI (servidores web) ou saúde (UPAs), garantindo precisão antes de cenários complexos e caros."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.6",
                    "name": "Validação Preliminar",
                    "description": "Comparação inicial do modelo com o sistema real para confirmar representatividade.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.6.1",
                        "name": "Propósito e Importância da Validação Preliminar",
                        "description": "Compreensão do objetivo inicial da validação, que visa confirmar se o modelo conceitual representa adequadamente o sistema real antes de simulações extensas.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.6.1.1",
                            "name": "Definir Validação Preliminar",
                            "description": "Explicar a validação preliminar como a comparação inicial qualitativa e quantitativa simples entre o modelo e o sistema real para verificar representatividade básica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito e Propósito da Validação Preliminar",
                                  "subSteps": [
                                    "Leia a definição: comparação inicial qualitativa e quantitativa simples entre modelo e sistema real.",
                                    "Identifique o propósito: verificar representatividade básica de forma rápida e econômica.",
                                    "Compare com validação completa: preliminar é inicial e simples, não exaustiva.",
                                    "Anote exemplos de quando usar: antes de simulações complexas.",
                                    "Resuma em uma frase própria o que é validação preliminar."
                                  ],
                                  "verification": "Escreva uma definição em suas palavras e compare com a original (deve coincidir em 80%).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Definição oficial da habilidade",
                                    "Papel e caneta",
                                    "Vídeo introdutório sobre modelagem de simulação (5 min)"
                                  ],
                                  "tips": [
                                    "Foquem no 'porquê' antes do 'como'",
                                    "Use analogias cotidianas como prever tempo de fila"
                                  ],
                                  "learningObjective": "Entender o propósito e distinção da validação preliminar em simulações discretas.",
                                  "commonMistakes": [
                                    "Confundir com validação estatística avançada",
                                    "Ignorar o aspecto 'preliminar' e rápido"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a Comparação Qualitativa Inicial",
                                  "subSteps": [
                                    "Defina qualitativa: análise visual ou descritiva (forma, padrões, comportamento geral).",
                                    "Liste critérios: similaridade em tendências, ciclos, picos no gráfico modelo vs. real.",
                                    "Pratique desenhando gráficos simples de um sistema real e modelo hipotético.",
                                    "Avalie similaridade: use escala subjetiva (baixa/média/alta representatividade).",
                                    "Registre observações em tabela: 'O que parece igual/diferente?'."
                                  ],
                                  "verification": "Crie um gráfico comparativo simples e justifique se é representativo qualitativamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráficos de exemplo de filas ou tráfego",
                                    "Ferramenta de desenho como papel ou Draw.io",
                                    "Exemplos de simulações discretas"
                                  ],
                                  "tips": [
                                    "Comece com olhos treinados: procure padrões óbvios primeiro",
                                    "Evite detalhes numéricos aqui"
                                  ],
                                  "learningObjective": "Dominar análise qualitativa para validação inicial de modelos.",
                                  "commonMistakes": [
                                    "Misturar com quantitativa",
                                    "Ser muito subjetivo sem critérios claros"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar a Comparação Quantitativa Simples",
                                  "subSteps": [
                                    "Defina quantitativa simples: métricas básicas como média, mínimo/máximo, variância.",
                                    "Calcule métricas para dados reais e modelo: ex. tempo médio de espera.",
                                    "Compare valores: diferença percentual < 20% indica boa representatividade básica.",
                                    "Use fórmula simples: |real - modelo| / real * 100%.",
                                    "Tabule resultados e interprete: aceitável ou precisa ajustes."
                                  ],
                                  "verification": "Calcule diferença percentual para um conjunto de dados fornecido e decida se passa na preliminar.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets",
                                    "Dados de exemplo: 10 observações reais e simuladas",
                                    "Calculadora"
                                  ],
                                  "tips": [
                                    "Escolha métricas relevantes ao sistema",
                                    "Limite a 3-4 métricas para manter simples"
                                  ],
                                  "learningObjective": "Aplicar cálculos quantitativos básicos para validar modelos.",
                                  "commonMistakes": [
                                    "Usar testes estatísticos avançados (ex. t-test)",
                                    "Ignorar unidades de medida"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Comparações e Verificar Representatividade Básica",
                                  "subSteps": [
                                    "Combine qualitativa e quantitativa: ambas devem indicar OK para prosseguir.",
                                    "Crie checklist: 70% similaridade qualitativa + <20% diferença quantitativa.",
                                    "Avalie riscos: se falha, identifique possíveis causas (parâmetros errados).",
                                    "Documente relatório preliminar: definição, comparações e conclusão.",
                                    "Discuta importância: evita desperdício em modelos não representativos."
                                  ],
                                  "verification": "Produza um relatório de 1 página com conclusão sobre representatividade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Template de relatório",
                                    "Dados dos steps anteriores",
                                    "Checklist impresso"
                                  ],
                                  "tips": [
                                    "Seja decisiva: preliminar não é perfeita",
                                    "Sempre documente para rastreabilidade"
                                  ],
                                  "learningObjective": "Integrar abordagens para uma definição completa de validação preliminar.",
                                  "commonMistakes": [
                                    "Concluir sem ambas as abordagens",
                                    "Superestimar representatividade sem evidências"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado: qualitativamente, compare a formação de filas longas nos horários de pico (gráficos semelhantes); quantitativamente, tempo médio real=7min vs. modelo=6.8min (diferença 2.8%, aceitável). Conclusão: representatividade básica OK para prosseguir.",
                              "finalVerifications": [
                                "Define corretamente validação preliminar em suas palavras.",
                                "Distingue qualitativa (visual/padrões) de quantitativa (médias/diferenças).",
                                "Calcula diferença percentual corretamente em exemplo dado.",
                                "Avalia representatividade básica com critérios simples.",
                                "Explica por que é 'preliminar' e sua importância.",
                                "Produz relatório integrado de validação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição (90% alinhada à descritiva).",
                                "Correta diferenciação qualitativa/quantitativa.",
                                "Cálculos quantitativos sem erros matemáticos.",
                                "Uso de critérios claros para representatividade.",
                                "Relatório completo e lógico.",
                                "Criatividade em exemplos práticos."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: cálculo de médias e variâncias básicas.",
                                "Programação: implementação de simulações discretas em Python.",
                                "Engenharia: validação de modelos em sistemas reais como manufatura.",
                                "Física: simulação de eventos discretos em partículas."
                              ],
                              "realWorldApplication": "Engenheiros de software usam validação preliminar para testar modelos de tráfego em apps de navegação, comparando tempos simulados com dados GPS reais antes de deploy em produção, economizando tempo e recursos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.6.1.2",
                            "name": "Identificar Importância",
                            "description": "Discutir como a validação preliminar evita desperdício de recursos em modelos inválidos, detectando erros conceituais precocemente nas fases de modelagem de simulação discreta.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de validação preliminar",
                                  "subSteps": [
                                    "Ler a definição de validação preliminar como verificação inicial do modelo conceitual antes da implementação computacional.",
                                    "Identificar que ocorre nas fases iniciais de modelagem de simulação discreta.",
                                    "Diferenciar de validações posteriores, como estatística ou operacional.",
                                    "Anotar exemplos simples de modelagem discreta, como filas ou processos de produção.",
                                    "Resumir em uma frase o propósito principal: checar consistência conceitual."
                                  ],
                                  "verification": "Criar um mapa mental ou resumo escrito definindo validação preliminar e seu escopo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro-texto de simulação discreta, notas de aula, papel e caneta ou ferramenta digital como MindMeister.",
                                  "tips": "Use analogias cotidianas, como verificar ingredientes antes de cozinhar, para fixar o conceito.",
                                  "learningObjective": "Dominar a definição e o posicionamento da validação preliminar no ciclo de modelagem.",
                                  "commonMistakes": "Confundir com validação estatística final ou ignorar o foco conceitual."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar detecção precoce de erros conceituais",
                                  "subSteps": [
                                    "Listar tipos de erros conceituais comuns: suposições erradas sobre o sistema real, lógica de eventos incorreta.",
                                    "Analisar como a validação preliminar usa perguntas como 'O modelo representa fielmente o sistema?'",
                                    "Simular um erro conceitual em um exemplo simples e mostrar como detectá-lo cedo.",
                                    "Discutir impacto: erros não detectados propagam para codificação e testes caros.",
                                    "Registrar 3 perguntas chave para detecção preliminar."
                                  ],
                                  "verification": "Elaborar uma lista de 3 erros conceituais potenciais e como a validação os detectaria.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Exemplos de casos de simulação (PDF ou slides), quadro branco ou Google Docs.",
                                  "tips": "Pense em 'walkthrough' mental: percorra o modelo como se fosse o sistema real.",
                                  "learningObjective": "Reconhecer erros conceituais e o papel da validação em sua detecção precoce.",
                                  "commonMistakes": "Subestimar erros conceituais como 'meramente teóricos' quando afetam toda a simulação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar prevenção de desperdício de recursos",
                                  "subSteps": [
                                    "Calcular custos aproximados: tempo de programação, testes e hardware para modelos inválidos.",
                                    "Comparar cenários: com vs. sem validação preliminar (ex: horas vs. dias de trabalho).",
                                    "Quantificar benefícios: redução de 50-80% em retrabalho segundo literatura.",
                                    "Discutir recursos: tempo humano, computacional e financeiros poupados.",
                                    "Criar um fluxograma simples mostrando fluxo com e sem validação."
                                  ],
                                  "verification": "Produzir uma tabela comparativa de custos em um modelo inválido detectado cedo vs. tarde.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha Excel ou Google Sheets, artigos sobre custos em simulação (ex: Law & Kelton).",
                                  "tips": "Use números reais de projetos passados ou estimativas conservadoras para tornar concreto.",
                                  "learningObjective": "Quantificar o impacto econômico da validação preliminar na modelagem.",
                                  "commonMistakes": "Ignorar custos indiretos como perda de credibilidade do modelo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar a importância geral da validação preliminar",
                                  "subSteps": [
                                    "Combinar conceitos: detecção + economia = eficiência no ciclo de simulação.",
                                    "Redigir um parágrafo argumentativo sobre por que é essencial em simulação discreta.",
                                    "Relacionar com boas práticas de engenharia de software e modelagem.",
                                    "Preparar argumentos para discutir em grupo ou apresentação.",
                                    "Revisar e refinar o texto para clareza e persuasão."
                                  ],
                                  "verification": "Escrever e peer-review um texto de 150-200 palavras explicando a importância.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Processador de texto, exemplos de textos argumentativos.",
                                  "tips": "Estruture como: problema > solução > benefícios > conclusão.",
                                  "learningObjective": "Articular de forma convincente a importância estratégica da validação preliminar.",
                                  "commonMistakes": "Focar só em teoria sem ligar a prática ou benefícios mensuráveis."
                                }
                              ],
                              "practicalExample": "Em um modelo de simulação de fila de call center, a validação preliminar identifica que o conceito ignora 'abandono de chamadas', evitando codificação de um modelo inútil que desperdiçaria semanas de desenvolvimento e testes em software como Arena ou Simul8.",
                              "finalVerifications": [
                                "Explicar em 3 frases como a validação preliminar detecta erros conceituais.",
                                "Calcular estimativa de recursos poupados em um cenário hipotético.",
                                "Identificar 2 erros comuns em modelagem discreta preveníveis por ela.",
                                "Discutir diferenças entre validação preliminar e outras validações.",
                                "Produzir um argumento persuasivo em parágrafo único.",
                                "Aplicar o conceito a um exemplo real de simulação."
                              ],
                              "assessmentCriteria": [
                                "Clareza na explicação de conceitos chave (precisão terminológica).",
                                "Profundidade na análise de erros conceituais e desperdícios.",
                                "Uso de exemplos concretos e quantificações realistas.",
                                "Estrutura lógica no discurso ou texto produzido.",
                                "Capacidade de síntese e persuasão nos argumentos.",
                                "Conexão explícita com fases de modelagem de simulação discreta."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Software: Analogia com code review inicial e testes unitários.",
                                "Gestão de Projetos: Prevenção de scope creep e controle de custos (PMBOK).",
                                "Estatística: Base para validações posteriores como testes de hipóteses.",
                                "Economia: Análise custo-benefício em decisões de investimento em simulações."
                              ],
                              "realWorldApplication": "Na indústria logística, como na modelagem de armazéns da Amazon, a validação preliminar previne erros conceituais em fluxos de picking, economizando milhões em retrabalho e otimizando operações reais antes da implementação em escala."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.6.1.3",
                            "name": "Relacionar com Fases de Modelagem",
                            "description": "Associar a validação preliminar às fases iniciais de modelagem de simulação, conforme descrito em Banks et al. (2000) e Law & Kelton (1991).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar as fases padrão de modelagem de simulação",
                                  "subSteps": [
                                    "Ler as descrições das fases iniciais em Banks et al. (2000) e Law & Kelton (1991): formulação do problema, coleta de dados e construção do modelo conceitual.",
                                    "Listar as 3-5 primeiras fases em um diagrama ou tabela.",
                                    "Identificar características de cada fase, como objetivos e entregáveis.",
                                    "Comparar definições entre as duas referências principais.",
                                    "Anotar diferenças ou semelhanças entre autores."
                                  ],
                                  "verification": "Lista completa das fases iniciais com citações corretas das fontes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Cópias ou PDFs de Banks et al. (2000) e Law & Kelton (1991); papel ou software de diagramação como Draw.io.",
                                  "tips": "Use cores diferentes para destacar fases iniciais versus fases posteriores.",
                                  "learningObjective": "Compreender a sequência e propósitos das fases iniciais de modelagem.",
                                  "commonMistakes": "Confundir fases conceituais com implementação computacional."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o conceito de validação preliminar",
                                  "subSteps": [
                                    "Definir validação preliminar conforme as referências: verificação inicial do modelo conceitual.",
                                    "Identificar seu propósito: detectar erros grossos antes da codificação.",
                                    "Listar técnicas comuns: walkthroughs, comparações com sistemas reais.",
                                    "Relacionar com importância: economia de tempo e recursos.",
                                    "Extrair citações diretas das fontes sobre sua posição no processo."
                                  ],
                                  "verification": "Definição clara e lista de técnicas com referências.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Referências bibliográficas; caderno de anotações.",
                                  "tips": "Destaque frases chave das fontes para uso posterior.",
                                  "learningObjective": "Dominar o escopo e timing da validação preliminar.",
                                  "commonMistakes": "Equiparar validação preliminar à validação estatística final."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Mapear validação preliminar às fases iniciais",
                                  "subSteps": [
                                    "Criar um mapa ou fluxograma ligando validação preliminar à fase de construção do modelo conceitual.",
                                    "Explicar associações: após formulação e coleta, antes da codificação.",
                                    "Discutir como ela se integra: feedback loop para ajustes iniciais.",
                                    "Comparar visões de Banks et al. e Law & Kelton sobre essa integração.",
                                    "Identificar pré-requisitos de fases anteriores para a validação."
                                  ],
                                  "verification": "Fluxograma ou tabela de mapeamento com setas de relação.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Software de fluxogramas; resumo das fases do step 1.",
                                  "tips": "Use setas bidirecionais para loops de feedback.",
                                  "learningObjective": "Estabelecer relações precisas entre validação e fases.",
                                  "commonMistakes": "Posicionar validação muito tarde no processo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e documentar a relação",
                                  "subSteps": [
                                    "Escrever um parágrafo resumindo a associação com citações.",
                                    "Criar uma tabela comparativa: fase x validação preliminar.",
                                    "Testar compreensão respondendo perguntas como 'Por que nessa fase?'.",
                                    "Revisar por consistência com fontes originais.",
                                    "Preparar exemplo ilustrativo para aplicação prática."
                                  ],
                                  "verification": "Documento sintetizado de 200-300 palavras com referências.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Editor de texto; fontes bibliográficas.",
                                  "tips": "Inclua equações ou diagramas se aplicável às fases.",
                                  "learningObjective": "Articular a relação de forma clara e referenciada.",
                                  "commonMistakes": "Ignorar variações entre autores."
                                }
                              ],
                              "practicalExample": "Em um modelo de simulação de filas de um supermercado, após a fase de formulação do problema (definir chegada de clientes) e construção conceitual (diagrama de estados), realize validação preliminar comparando o diagrama com observações reais do supermercado, ajustando taxas de serviço iniciais conforme Banks et al., evitando erros grossos antes da programação.",
                              "finalVerifications": [
                                "Pode listar corretamente as fases iniciais com citações de Banks e Law & Kelton.",
                                "Explica a posição exata da validação preliminar no fluxo.",
                                "Identifica pelo menos 3 técnicas de validação preliminar.",
                                "Demonstra um mapa ou fluxograma coerente.",
                                "Relaciona corretamente com economia de recursos.",
                                "Citações são precisas e contextualizadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição das fases (90% de acerto com fontes).",
                                "Clareza no mapeamento de relações (fluxograma legível).",
                                "Uso correto de referências bibliográficas.",
                                "Profundidade na explicação de propósitos e importância.",
                                "Originalidade no exemplo prático.",
                                "Ausência de confusões conceituais comuns."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Uso de dados iniciais para validação.",
                                "Programação: Preparação para codificação do modelo.",
                                "Engenharia de Sistemas: Integração em ciclos de desenvolvimento.",
                                "Gestão de Projetos: Controle de fases e validação precoce."
                              ],
                              "realWorldApplication": "Na indústria manufatureira, relacionar validação preliminar à modelagem inicial de linhas de produção garante detecção precoce de falhas conceituais, otimizando simulações para redução de custos em projetos como os da Boeing ou fábricas automotivas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.6.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.6.2",
                        "name": "Técnicas de Comparação Inicial",
                        "description": "Métodos práticos e simples para comparar o comportamento do modelo com dados reais ou conhecimento do sistema.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.6.2.1",
                            "name": "Aplicar Comparação Gráfica",
                            "description": "Utilizar gráficos de trajetórias, histogramas iniciais ou plots de tempo médio para visualizar similaridades entre saídas do modelo e sistema real.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Coleta e Preparação de Dados",
                                  "subSteps": [
                                    "Obtenha dados do sistema real de fontes confiáveis (ex: sensores, logs históricos).",
                                    "Execute a simulação do modelo para gerar saídas equivalentes no mesmo intervalo de tempo.",
                                    "Limpe e pré-processe os dados: remova outliers, normalize escalas e alinhe séries temporais.",
                                    "Salve os dados em formato compatível (CSV, arrays NumPy ou similar).",
                                    "Verifique consistência entre conjuntos de dados reais e simulados."
                                  ],
                                  "verification": "Conjuntos de dados reais e simulados estão limpos, alinhados e salvos em arquivos acessíveis.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Dados reais (arquivos CSV ou banco de dados)",
                                    "Código de simulação executado",
                                    "Software: Python (Pandas, NumPy) ou MATLAB"
                                  ],
                                  "tips": "Sempre documente a fonte dos dados reais para rastreabilidade.",
                                  "learningObjective": "Preparar dados comparáveis para visualização gráfica precisa.",
                                  "commonMistakes": [
                                    "Não alinhar escalas de tempo entre dados reais e simulados",
                                    "Ignorar unidades de medida diferentes",
                                    "Manter outliers que distorcem a visualização"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Seleção do Tipo de Gráfico Adequado",
                                  "subSteps": [
                                    "Analise a natureza dos dados: trajetórias temporais, distribuições ou médias agregadas.",
                                    "Escolha gráfico de trajetórias para séries temporais (ex: plot de linha dupla).",
                                    "Opte por histogramas para distribuições de saídas (ex: tempos de resposta).",
                                    "Use plots de tempo médio para métricas agregadas ao longo do tempo.",
                                    "Justifique a escolha com base no objetivo de validação preliminar."
                                  ],
                                  "verification": "Tipo de gráfico selecionado e justificado em um documento ou comentário no código.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Dados preparados",
                                    "Referências teóricas sobre visualização (ex: livros de simulação)",
                                    "Ferramentas: Python (Matplotlib) ou Excel"
                                  ],
                                  "tips": "Priorize gráficos que destacam sobreposições visuais para similaridades.",
                                  "learningObjective": "Identificar o gráfico mais apropriado para visualizar similaridades entre modelo e real.",
                                  "commonMistakes": [
                                    "Escolher histograma para dados temporais",
                                    "Usar gráfico único em vez de sobreposto",
                                    "Ignorar o tipo de saída do sistema"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Geração dos Gráficos Comparativos",
                                  "subSteps": [
                                    "Configure o ambiente de plotagem (ex: importar bibliotecas Matplotlib ou ggplot).",
                                    "Crie eixos compartilhados para sobrepor curvas reais e simuladas.",
                                    "Adicione legendas, títulos, rótulos de eixos e grades para clareza.",
                                    "Gere múltiplos gráficos se necessário (um para cada métrica relevante).",
                                    "Exporte os gráficos em alta resolução (PNG/PDF)."
                                  ],
                                  "verification": "Gráficos gerados e salvos, com sobreposição clara de dados reais e simulados.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Dados preparados",
                                    "Software de plotagem: Python (Matplotlib/Seaborn), R ou MATLAB"
                                  ],
                                  "tips": "Use cores contrastantes para real (azul) vs simulado (vermelho) e transparência para sobreposições.",
                                  "learningObjective": "Produzir visualizações gráficas profissionais e comparativas.",
                                  "commonMistakes": [
                                    "Escalas de eixos não sincronizadas",
                                    "Falta de legendas ou títulos descritivos",
                                    "Resolução baixa para inspeção detalhada"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Análise Visual e Identificação de Similaridades",
                                  "subSteps": [
                                    "Inspecione visualmente sobreposições, desvios e padrões coincidentes.",
                                    "Meça qualitativamente similaridades (ex: curvas paralelas, picos alinhados).",
                                    "Identifique discrepâncias evidentes (ex: desvios em regimes transitórios).",
                                    "Anotações nos gráficos destacando regiões de boa/má concordância.",
                                    "Registre observações em um relatório inicial."
                                  ],
                                  "verification": "Relatório com anotações nos gráficos listando similaridades e discrepâncias principais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Gráficos gerados",
                                    "Ferramenta de edição de imagens (ex: Inkscape) ou Jupyter Notebook"
                                  ],
                                  "tips": "Amplie regiões críticas para análise detalhada.",
                                  "learningObjective": "Interpretar graficamente a validade preliminar do modelo.",
                                  "commonMistakes": [
                                    "Focar apenas em similaridades ignorando desvios",
                                    "Interpretação subjetiva sem anotações",
                                    "Não considerar ruído nos dados reais"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentação e Verificação Final da Comparação",
                                  "subSteps": [
                                    "Compile gráficos e análises em um relatório estruturado.",
                                    "Defina thresholds qualitativos para 'boa similaridade' (ex: sobreposição >80%).",
                                    "Compare com critérios de validação preliminar do contexto.",
                                    "Sugira ajustes no modelo baseados em discrepâncias visíveis.",
                                    "Arquive todos os artefatos para iterações futuras."
                                  ],
                                  "verification": "Relatório completo com conclusão sobre validade gráfica preliminar.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Gráficos e relatório inicial",
                                    "Template de relatório (Word/Google Docs)"
                                  ],
                                  "tips": "Use métricas visuais como RMSE qualitativo para suporte.",
                                  "learningObjective": "Documentar e validar a comparação gráfica de forma reprodutível.",
                                  "commonMistakes": [
                                    "Relatório vago sem evidências gráficas",
                                    "Não propor próximos passos",
                                    "Concluir validade sem análise quantitativa planejada"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de sistema de filas de um call center, colete tempos de espera reais de logs e simule com modelo M/M/1. Plote histogramas sobrepostos de tempos de espera e trajetórias de fila ao longo de um dia, identificando similaridades em picos de demanda.",
                              "finalVerifications": [
                                "Gráficos mostram sobreposição visual clara entre saídas reais e simuladas.",
                                "Discrepâncias são anotadas e quantificadas qualitativamente.",
                                "Escolha do tipo de gráfico é justificada e apropriada aos dados.",
                                "Relatório documenta similaridades em pelo menos 70% das métricas.",
                                "Artefatos (dados, código, gráficos) estão versionados e acessíveis.",
                                "Conclusão preliminar indica viabilidade para validação avançada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na preparação e alinhamento de dados (20%)",
                                "Adequação da escolha e geração de gráficos (25%)",
                                "Profundidade da análise visual e identificação de padrões (25%)",
                                "Clareza e completude da documentação (15%)",
                                "Identificação de erros comuns evitados (10%)",
                                "Aplicação correta no contexto de simulação discreta (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Análise de distribuições e testes visuais de hipóteses.",
                                "Programação: Uso de bibliotecas de visualização (Matplotlib, ggplot2).",
                                "Física/Engenharia: Validação de modelos dinâmicos em sistemas reais.",
                                "Ciência de Dados: Pré-processamento e visualização exploratória.",
                                "Gestão de Projetos: Documentação reprodutível de análises."
                              ],
                              "realWorldApplication": "Validação de modelos de simulação em engenharia de tráfego (trajetórias de veículos), previsão de estoques em supply chain (histogramas de demanda) e análise de performance de servidores (plots de tempo médio de resposta)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.6.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.6.2.2",
                            "name": "Realizar Testes de 'Cara ou Coroa'",
                            "description": "Executar testes informais como 'teste do extremo' ou 'teste de shutdown' para verificar se o modelo responde logicamente a condições boundary, conforme Pidd (1998).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir Condições Boundary e Selecionar Teste Adequado",
                                  "subSteps": [
                                    "Identifique condições boundary no modelo, como entradas mínimas/máximas ou estados shutdown (ex.: zero chegadas em fila).",
                                    "Escolha teste: 'cara ou coroa' para aleatoriedade simples, 'extreme' para valores limítrofes, ou 'shutdown' para parada do sistema.",
                                    "Defina hipóteses lógicas esperadas (ex.: em shutdown, fila vazia sem atrasos).",
                                    "Registre parâmetros iniciais do modelo conforme Pidd (1998).",
                                    "Crie um script ou planilha para registrar resultados."
                                  ],
                                  "verification": "Lista de condições boundary e teste selecionado documentada com hipóteses claras.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação do modelo, papel/caneta ou editor de texto, referência Pidd (1998).",
                                  "tips": "Comece com o teste mais simples (cara ou coroa) para ganhar confiança.",
                                  "learningObjective": "Compreender como mapear falhas lógicas em condições boundary.",
                                  "commonMistakes": "Ignorar estados transitórios ou confundir boundary com valores médios."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar e Executar Testes Iniciais",
                                  "subSteps": [
                                    "Configure o modelo com inputs boundary (ex.: probabilidade 0.5 para cara/coroa em simulação discreta).",
                                    "Execute 10-20 iterações manuais ou simuladas do teste de cara ou coroa.",
                                    "Aplique teste extreme: insira valores mínimos/máximos e observe saídas.",
                                    "Realize teste de shutdown: pare inputs e verifique estabilização.",
                                    "Registre saídas brutas em tabela."
                                  ],
                                  "verification": "Pelo menos 10 execuções registradas com inputs e saídas consistentes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de simulação (ex.: Python com NumPy, Excel), modelo de simulação pronto.",
                                  "tips": "Use seeds fixas em simulações para reprodutibilidade.",
                                  "learningObjective": "Executar testes informais com precisão e registrar dados raw.",
                                  "commonMistakes": "Poucas repetições levando a falsos positivos; não fixar random seeds."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Resultados e Verificar Lógica",
                                  "subSteps": [
                                    "Compare saídas com hipóteses lógicas (ex.: 50% cara/coroa em longo prazo).",
                                    "Calcule estatísticas simples: média, desvio, taxa de falhas lógicas.",
                                    "Identifique anomalias (ex.: fila negativa em shutdown).",
                                    "Ajuste modelo se necessário e reteste uma iteração.",
                                    "Classifique: passa/falha por teste."
                                  ],
                                  "verification": "Relatório com estatísticas e classificação de cada teste.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Planilha ou script para análise (ex.: Pandas), gráficos básicos.",
                                  "tips": "Visualize com histogramas para padrões intuitivos.",
                                  "learningObjective": "Interpretar resultados de testes informais contra expectativas lógicas.",
                                  "commonMistakes": "Aceitar resultados sem comparação explícita às hipóteses."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Documentar Conclusões e Recomendações",
                                  "subSteps": [
                                    "Resuma achados: quais testes passaram/falharam e por quê.",
                                    "Recomende próximos passos (ex.: validação formal se preliminar ok).",
                                    "Inclua lições aprendidas e referencie Pidd (1998).",
                                    "Atualize documentação do modelo com resultados.",
                                    "Compartilhe relatório para revisão."
                                  ],
                                  "verification": "Relatório final completo com sumário, tabelas e recomendações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de texto ou LaTeX, versão anterior do relatório.",
                                  "tips": "Use templates padronizados para consistência.",
                                  "learningObjective": "Comunicar efetivamente resultados de validação preliminar.",
                                  "commonMistakes": "Omitir evidências raw ou exagerar confiança em testes informais."
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila M/M/1, aplique teste de cara ou coroa para chegadas (50% probabilidade); em shutdown (λ=0), verifique se fila esvazia logicamente sem filas negativas após 100 iterações.",
                              "finalVerifications": [
                                "Resultados de cara/coroa convergem para 50% em ≥20 flips.",
                                "Teste extreme não produz valores impossíveis (ex.: tempos negativos).",
                                "Shutdown estabiliza em estado lógico esperado.",
                                "Todas hipóteses iniciais testadas e documentadas.",
                                "Estatísticas básicas calculadas e sem anomalias.",
                                "Relatório inclui evidências raw."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de boundaries (90% cobertura).",
                                "Número adequado de repetições (≥10 por teste).",
                                "Análise lógica coerente com Pidd (1998).",
                                "Documentação completa e clara.",
                                "Tempo total dentro do estimado (±20%).",
                                "Ausência de erros comuns identificados."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: Cálculo de frequências em testes aleatórios.",
                                "Programação Computacional: Implementação de simulações discretas.",
                                "Lógica e Raciocínio: Verificação de consistência comportamental.",
                                "Gestão de Projetos: Validação preliminar em ciclos ágeis."
                              ],
                              "realWorldApplication": "Validação rápida de modelos de simulação em logística (ex.: prever filas em aeroportos) ou finanças (testar crashes de mercado), evitando erros caros em implantações reais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.6.1.2"
                            ]
                          },
                          {
                            "id": "10.1.2.6.2.3",
                            "name": "Comparar Estatísticas Descritivas Básicas",
                            "description": "Calcular e comparar médias, variâncias e distribuições iniciais de variáveis chave entre modelo e dados reais para detecção preliminar de discrepâncias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Coletar e Preparar Dados do Modelo e Reais",
                                  "subSteps": [
                                    "Identifique as variáveis chave no modelo de simulação (ex: tempo de espera, throughput).",
                                    "Extraia amostras equivalentes de dados reais e do modelo simulado, garantindo o mesmo tamanho de amostra.",
                                    "Limpe os dados removendo outliers ou valores ausentes usando métodos estatísticos básicos.",
                                    "Organize os dados em estruturas comparáveis, como vetores ou dataframes.",
                                    "Documente metadados como período de coleta e fonte dos dados."
                                  ],
                                  "verification": "Verifique se os conjuntos de dados têm o mesmo número de observações e variáveis alinhadas via inspeção visual ou resumo estatístico.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilhas (Excel/Google Sheets), software de programação (Python com Pandas), dados reais e saída do modelo simulado.",
                                  "tips": "Use seeds fixas no modelo para reprodutibilidade dos dados simulados.",
                                  "learningObjective": "Preparar datasets comparáveis para análise estatística inicial.",
                                  "commonMistakes": "Ignorar diferenças de escala entre dados reais e simulados; não documentar fontes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Estatísticas Descritivas Básicas",
                                  "subSteps": [
                                    "Calcule a média aritmética para cada variável chave em ambos os datasets.",
                                    "Compute a variância e desvio padrão usando fórmulas padrão.",
                                    "Gere histogramas ou boxplots para visualizar distribuições iniciais.",
                                    "Calcule medidas de assimetria (skewness) e curtose para capturar forma da distribuição.",
                                    "Registre todos os valores em uma tabela comparativa."
                                  ],
                                  "verification": "Confirme cálculos cruzando com funções built-in de bibliotecas (ex: np.mean(), np.var() no NumPy) e visualize gráficos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python (NumPy, Matplotlib, SciPy), R ou Excel com funções STAT.",
                                  "tips": "Use amostras grandes (>100 observações) para estatísticas mais estáveis.",
                                  "learningObjective": "Dominar cálculo manual e automatizado de estatísticas descritivas.",
                                  "commonMistakes": "Confundir variância amostral com populacional; usar amostras pequenas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Estatísticas e Identificar Discrepâncias",
                                  "subSteps": [
                                    "Calcule diferenças absolutas e relativas entre médias (ex: |média_real - média_modelo| / média_real).",
                                    "Compare variâncias usando razão de variâncias e teste F preliminar.",
                                    "Analise visualmente histogramas superpostos para diferenças em distribuições.",
                                    "Defina thresholds de tolerância (ex: diferença <5% para médias).",
                                    "Classifique discrepâncias como menores, moderadas ou críticas."
                                  ],
                                  "verification": "Crie uma tabela de comparação com flags de discrepância (verde/amarelo/vermelho).",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Ferramentas de visualização (Matplotlib, Seaborn), calculadora ou script Python.",
                                  "tips": "Priorize variáveis com maior impacto no modelo para comparação inicial.",
                                  "learningObjective": "Aplicar métricas de comparação quantitativas e qualitativas.",
                                  "commonMistakes": "Definir thresholds arbitrários sem justificativa; ignorar distribuições não-normais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Resultados e Documentar Preliminar",
                                  "subSteps": [
                                    "Explique causas potenciais de discrepâncias (ex: suposições do modelo erradas).",
                                    "Recomende ajustes no modelo baseados nas discrepâncias encontradas.",
                                    "Gere relatório com tabelas, gráficos e conclusões preliminares.",
                                    "Valide interpretação com colega ou supervisor.",
                                    "Planeje testes estatísticos mais avançados se necessário."
                                  ],
                                  "verification": "O relatório deve incluir evidências visuais e quantitativas de todas as comparações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de texto ou Jupyter Notebook para relatório.",
                                  "tips": "Use templates de relatório para consistência.",
                                  "learningObjective": "Desenvolver habilidades de interpretação crítica e comunicação de resultados.",
                                  "commonMistakes": "Sobre-generalizar discrepâncias sem contexto; omitir limitações dos dados."
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado, compare a média de tempo de espera (modelo: 5.2 min; real: 6.1 min) e variância (modelo: 2.1; real: 3.5), identificando discrepância na variância devido a picos reais não modelados, visualizado via histogramas superpostos.",
                              "finalVerifications": [
                                "Todas estatísticas descritivas calculadas corretamente para ambos datasets.",
                                "Diferenças quantificadas com thresholds aplicados.",
                                "Gráficos de distribuição mostram alinhamento visual.",
                                "Relatório documenta discrepâncias e sugestões.",
                                "Reprodutibilidade confirmada com seeds fixas.",
                                "Nenhum erro comum detectado nos cálculos."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos cálculos estatísticos (erro <1%).",
                                "Qualidade das visualizações comparativas.",
                                "Correta identificação e classificação de discrepâncias.",
                                "Profundidade da interpretação e recomendações.",
                                "Clareza e completude do relatório final.",
                                "Eficiência no uso de tempo e recursos."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Fundamentos de inferência e testes de hipóteses.",
                                "Programação: Manipulação de dados com Python/R.",
                                "Ciência de Dados: Visualização e pré-processamento.",
                                "Engenharia de Sistemas: Validação de modelos simulados."
                              ],
                              "realWorldApplication": "Na indústria automotiva, validar simulações de tráfego comparando tempos médios de viagem e variâncias com dados GPS reais para calibrar modelos de planejamento urbano, evitando custos de redesign."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.6.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.6.3",
                        "name": "Critérios e Decisão de Representatividade",
                        "description": "Estabelecimento de critérios para julgar se o modelo é representativo o suficiente para prosseguir para validações mais rigorosas.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.6.3.1",
                            "name": "Definir Critérios de Aceitação",
                            "description": "Estabelecer thresholds qualitativos e quantitativos, como concordância em 80% das comparações gráficas ou desvios abaixo de 10% em estatísticas chave.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Objetivos do Modelo e Dados de Referência",
                                  "subSteps": [
                                    "Analise os objetivos principais da simulação, identificando variáveis chave como tempo médio, taxa de throughput ou distribuição de eventos.",
                                    "Colete e examine dados reais ou de referência para o sistema simulado, plotando gráficos iniciais para visualização.",
                                    "Identifique discrepâncias potenciais entre simulação preliminar e dados reais.",
                                    "Liste qualitativos (ex: padrões visuais) e quantitativos (ex: médias, desvios) relevantes.",
                                    "Documente suposições iniciais sobre tolerâncias aceitáveis."
                                  ],
                                  "verification": "Checklist completo dos objetivos e dados revisados, com pelo menos 3 variáveis chave listadas e graficadas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Dados reais do sistema",
                                    "Ferramentas de plotagem (Python Matplotlib ou Excel)",
                                    "Documentação do modelo"
                                  ],
                                  "tips": "Comece com visualizações gráficas para insights intuitivos antes de números.",
                                  "learningObjective": "Compreender como objetivos guiam a definição de critérios de aceitação.",
                                  "commonMistakes": [
                                    "Ignorar dados de referência de baixa qualidade",
                                    "Focar apenas em métricas quantitativas sem qualitativas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar Métricas de Validação Apropriadas",
                                  "subSteps": [
                                    "Escolha métricas quantitativas como erro absoluto médio (MAE), erro quadrático médio (MSE), coeficiente de correlação (R²).",
                                    "Defina métricas qualitativas como similaridade visual em histogramas ou Q-Q plots.",
                                    "Priorize métricas baseadas na criticidade das variáveis (ex: tempo de espera em simulações de filas).",
                                    "Calcule métricas preliminares rodando a simulação e comparando com dados reais.",
                                    "Crie uma tabela resumindo métricas selecionadas e seus significados."
                                  ],
                                  "verification": "Tabela de métricas com cálculos preliminares e justificativas para cada uma.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software de simulação (ex: Python SimPy)",
                                    "Bibliotecas estatísticas (NumPy, SciPy)",
                                    "Planilha para tabela"
                                  ],
                                  "tips": "Use métricas complementares: uma para tendência (correlação) e outra para magnitude (MAE).",
                                  "learningObjective": "Selecionar métricas alinhadas ao contexto da simulação para validação robusta.",
                                  "commonMistakes": [
                                    "Escolher métricas irrelevantes ao objetivo",
                                    "Não calibrar métricas com dados reais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estabelecer Thresholds Qualitativos e Quantitativos",
                                  "subSteps": [
                                    "Pesquise benchmarks da literatura ou padrões industriais para thresholds (ex: R² > 0.9, MAE < 10%).",
                                    "Defina thresholds quantitativos como 'desvio < 10% em estatísticas chave' ou 'concordância > 80% em comparações gráficas'.",
                                    "Estabeleça qualitativos como 'padrões gráficos visualmente indistinguíveis' ou 'distribuições sobrepostas em 90%'.",
                                    "Teste sensibilidade variando thresholds e simulando impactos.",
                                    "Ajuste iterativamente com base em trade-offs entre rigor e praticidade."
                                  ],
                                  "verification": "Lista de thresholds definidos com justificativas e testes de sensibilidade documentados.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Literatura acadêmica sobre validação de simulações",
                                    "Ferramentas de análise estatística",
                                    "Simulador do modelo"
                                  ],
                                  "tips": "Comece conservador (thresholds rigorosos) e relaxe se necessário para viabilidade.",
                                  "learningObjective": "Definir thresholds realistas e justificáveis para critérios de aceitação.",
                                  "commonMistakes": [
                                    "Thresholds arbitrários sem base",
                                    "Definir apenas quantitativos ignorando qualitativos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Documentar, Justificar e Planejar Revisão dos Critérios",
                                  "subSteps": [
                                    "Escreva uma declaração formal dos critérios, incluindo todos thresholds e métricas.",
                                    "Justifique cada threshold com referências, dados ou raciocínio lógico.",
                                    "Defina condições para revisão (ex: novos dados reais disponíveis).",
                                    "Crie um template para relatórios futuros de validação.",
                                    "Compartilhe draft com pares para feedback inicial."
                                  ],
                                  "verification": "Documento final de critérios com justificativas, template e feedback incorporado.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Editor de texto (Markdown ou Word)",
                                    "Referências bibliográficas"
                                  ],
                                  "tips": "Use linguagem clara e quantificável para evitar ambiguidades.",
                                  "learningObjective": "Documentar critérios de forma profissional e revisável.",
                                  "commonMistakes": [
                                    "Documentação vaga",
                                    "Falta de justificativas rastreáveis"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado, defina critérios como: tempo médio de espera com MAE < 5 minutos (quantitativo), histogramas de tempo de espera sobrepostos em >85% (qualitativo), e throughput diário com desvio <8% dos dados reais.",
                              "finalVerifications": [
                                "Critérios incluem pelo menos 2 métricas quantitativas e 1 qualitativa.",
                                "Todos thresholds são específicos (ex: porcentagens ou valores numéricos).",
                                "Justificativas baseadas em dados reais ou literatura.",
                                "Condições para revisão dos critérios definidas.",
                                "Documento permite aplicação direta em validação preliminar.",
                                "Testes preliminares confirmam viabilidade dos thresholds."
                              ],
                              "assessmentCriteria": [
                                "Completude: Todos elementos (métricas, thresholds, justificativas) presentes.",
                                "Precisão: Thresholds alinhados ao contexto da simulação e realistas.",
                                "Justificativa: Evidências claras para cada escolha.",
                                "Clareza: Linguagem acionável e sem ambiguidades.",
                                "Abrangência: Balanceamento qualitativo/quantitativo.",
                                "Inovação: Inclusão de testes de sensibilidade ou benchmarks."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Cálculo de métricas como MAE, R² e testes de hipótese.",
                                "Ciência de Dados: Visualização e comparação de distribuições.",
                                "Engenharia de Software: Documentação de requisitos e validação.",
                                "Gestão de Projetos: Definição de critérios de aceitação em entregas."
                              ],
                              "realWorldApplication": "Em indústrias como manufatura ou logística, define critérios para validar simulações de produção, garantindo que modelos sejam representativos antes de otimização, evitando custos com implementações falhas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.6.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.6.3.2",
                            "name": "Detectar e Classificar Discrepâncias",
                            "description": "Identificar tipos de discrepâncias (estruturais, paramétricas ou aleatórias) e decidir se requerem ajustes no modelo conceitual.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Tipos de Discrepâncias em Modelos de Simulação",
                                  "subSteps": [
                                    "Estude a definição de discrepância estrutural: diferenças fundamentais na estrutura do modelo vs. sistema real, como ausência de um mecanismo chave.",
                                    "Analise discrepância paramétrica: variações nos valores de parâmetros que causam desvios quantitativos, mas estrutura preservada.",
                                    "Examine discrepância aleatória: flutuações estocásticas ou ruído inerente aos dados reais ou simulações.",
                                    "Compare exemplos ilustrativos para cada tipo usando diagramas ou tabelas.",
                                    "Crie um fluxograma mental para diferenciar os tipos com base em sintomas observados."
                                  ],
                                  "verification": "Resuma em uma tabela os três tipos, com definição, causa e exemplo para cada um, sem erros conceituais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação teórica sobre modelagem de simulação",
                                    "Diagramas de exemplos de discrepâncias",
                                    "Planilha ou software de desenho (ex: Draw.io)"
                                  ],
                                  "tips": "Use mnemônicos como 'Estrutura=Forma, Parâmetros=Números, Aleatória=Sorte' para memorizar.",
                                  "learningObjective": "Diferenciar com precisão os três tipos de discrepâncias e identificar suas causas raiz.",
                                  "commonMistakes": [
                                    "Confundir paramétrica com aleatória por ignorar variância estatística",
                                    "Subestimar discrepâncias estruturais como meros ajustes numéricos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Coletar e Preparar Dados de Simulação e Real para Comparação",
                                  "subSteps": [
                                    "Obtenha dados reais do sistema (ex: histórico de eventos discretos) e execute simulação com o modelo atual.",
                                    "Gere métricas comparáveis: médias, desvios padrão, distribuições de eventos para ambos conjuntos.",
                                    "Visualize dados lado a lado usando gráficos (histogramas, séries temporais, QQ-plots).",
                                    "Calcule métricas de discrepância inicial: RMSE, KS-test ou chi-quadrado.",
                                    "Documente fontes de dados e pressupostos de coleta para rastreabilidade."
                                  ],
                                  "verification": "Produza gráficos comparativos e tabela de métricas mostrando pelo menos 3 indicadores numéricos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software de simulação (ex: Python com SimPy ou Arena)",
                                    "Dados reais de exemplo (dataset público de filas ou redes)",
                                    "Ferramentas de plotagem (Matplotlib, Excel)"
                                  ],
                                  "tips": "Padronize escalas nos gráficos para detecção visual imediata de desvios.",
                                  "learningObjective": "Preparar conjuntos de dados limpos e comparáveis para análise robusta de discrepâncias.",
                                  "commonMistakes": [
                                    "Usar escalas diferentes nos gráficos, mascarando discrepâncias",
                                    "Ignorar normalização de dados, levando a falsos positivos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detectar Discrepâncias Através de Análise Estatística e Visual",
                                  "subSteps": [
                                    "Inspecione visualmente gráficos para padrões de desvio: sistemático (tendência), oscilatório ou disperso.",
                                    "Aplique testes estatísticos: t-test para médias, teste de Kolmogorov-Smirnov para distribuições.",
                                    "Quantifique magnitude da discrepância com thresholds pré-definidos (ex: >10% de desvio relativo).",
                                    "Registre evidências fotográficas ou numéricas de cada detecção.",
                                    "Priorize discrepâncias por impacto no objetivo da simulação."
                                  ],
                                  "verification": "Liste 2-3 discrepâncias detectadas com evidências estatísticas (p-valor <0.05) e visual.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Bibliotecas Python: SciPy para testes, Pandas para manipulação",
                                    "Exemplos de datasets simulados vs. reais"
                                  ],
                                  "tips": "Comece sempre com visualizações; estatística confirma, mas olho humano detecta padrões sutis.",
                                  "learningObjective": "Identificar discrepâncias de forma objetiva usando ferramentas visuais e estatísticas.",
                                  "commonMistakes": [
                                    "Confiar só em visual sem testes estatísticos, causando subjetividade",
                                    "Definir thresholds arbitrários sem contexto do sistema"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Classificar Discrepâncias e Decidir Ajustes no Modelo Conceitual",
                                  "subSteps": [
                                    "Mapeie sintomas observados aos tipos: estrutura (qualitativo), paramétrica (quantitativo moderado), aleatória (alta variância sem bias).",
                                    "Classifique cada discrepância com justificativa baseada em evidências.",
                                    "Avalie impacto: se estrutural ou paramétrica grave, recomende reformulação conceitual; se aleatória, valide amostra.",
                                    "Proponha ações específicas: recalibrar parâmetros, adicionar estado, ou aceitar como inerente.",
                                    "Documente decisão em relatório com raciocínio lógico e próximos passos."
                                  ],
                                  "verification": "Crie relatório com classificação de pelo menos uma discrepância simulada e decisão justificada.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Template de relatório de validação",
                                    "Matriz de decisão (tabela tipos x ações)"
                                  ],
                                  "tips": "Use uma árvore de decisão para classificação sistemática e reduzir bias.",
                                  "learningObjective": "Classificar discrepâncias corretamente e formular decisões acionáveis para refinamento do modelo.",
                                  "commonMistakes": [
                                    "Classificar estrutural como paramétrica para evitar reformulação custosa",
                                    "Ignorar aleatórias que mascaram problemas reais"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado (M/M/1), dados reais mostram tempo médio de espera de 5min, mas simulação dá 3min com distribuição bimodal. Visualização revela desvio sistemático baixo; teste KS falha (p=0.01). Classificação: paramétrica (subestimação de taxa de chegada). Decisão: ajustar parâmetro λ para 12/hora.",
                              "finalVerifications": [
                                "Classifica corretamente 3 exemplos de discrepâncias simuladas em um quiz.",
                                "Produz relatório completo para um caso prático com evidências estatísticas.",
                                "Explica diferenças entre tipos em uma apresentação de 2 minutos.",
                                "Aplica processo em dataset novo com <10% erro de classificação.",
                                "Identifica decisão correta em cenários ambíguos com justificativa.",
                                "Gera fluxograma pessoal do processo de detecção e classificação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção de tipos de discrepâncias (>90% em testes).",
                                "Uso correto de métricas estatísticas e thresholds apropriados.",
                                "Qualidade das visualizações e documentação de evidências.",
                                "Lógica robusta nas decisões de ajuste, alinhada ao contexto.",
                                "Eficiência temporal: completa análise em <3 horas para casos médios.",
                                "Criatividade em conexões com aplicações reais."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Testes de hipótese e análise de variância.",
                                "Programação: Implementação de simulações e scripts de análise em Python/R.",
                                "Engenharia de Sistemas: Validação de modelos em controle e otimização.",
                                "Ciência de Dados: Detecção de anomalias em big data.",
                                "Gestão de Projetos: Decisões baseadas em evidências para iterações."
                              ],
                              "realWorldApplication": "Em engenharia de tráfego, detectar discrepâncias em simulações de semáforos permite classificar atrasos como paramétricos (ajustar tempos) ou estruturais (adicionar rotatórias), otimizando fluxo real e reduzindo congestionamentos em 20%."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.6.2.3"
                            ]
                          },
                          {
                            "id": "10.1.2.6.3.3",
                            "name": "Documentar Resultados Preliminares",
                            "description": "Registrar evidências da validação preliminar em relatórios, incluindo gráficos e conclusões, para transição ao planejamento de experimentos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Coletar e Organizar Evidências da Validação Preliminar",
                                  "subSteps": [
                                    "Reúna todos os dados brutos da validação, incluindo métricas de erro, comparações com dados reais e logs de simulação.",
                                    "Classifique as evidências em categorias: quantitativas (ex.: RMSE, precisão), qualitativas (ex.: padrões observados) e anomalias.",
                                    "Crie uma tabela ou planilha para resumir os dados chave, com colunas para métrica, valor simulado, valor real e diferença.",
                                    "Salve os dados em formato acessível (CSV ou Excel) e anote fontes e datas de coleta.",
                                    "Verifique a completude dos dados, garantindo que cubram todos os critérios de representatividade testados."
                                  ],
                                  "verification": "Conferir se existe uma tabela organizada com todas as evidências categorizadas e sem dados faltantes.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Dados brutos da simulação",
                                    "Planilha (Excel/Google Sheets)",
                                    "Logs de simulação"
                                  ],
                                  "tips": "Use cores para destacar discrepâncias significativas nas tabelas para facilitar a visualização rápida.",
                                  "learningObjective": "Organizar evidências de forma estruturada para facilitar análise e comunicação.",
                                  "commonMistakes": [
                                    "Ignorar anomalias ou outliers",
                                    "Não categorizar dados, levando a relatórios desorganizados",
                                    "Esquecer de anotar fontes, comprometendo rastreabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar Gráficos e Visualizações dos Resultados",
                                  "subSteps": [
                                    "Selecione tipos de gráficos apropriados: linha para tendências temporais, scatter para correlações, boxplot para distribuições.",
                                    "Gere os gráficos usando ferramentas como Matplotlib, Excel ou Tableau, plotando simulado vs. real.",
                                    "Adicione legendas, títulos descritivos, eixos rotulados e escalas consistentes em todos os gráficos.",
                                    "Inclua pelo menos 3-5 gráficos cobrindo métricas principais e valide visualmente se capturam padrões chave.",
                                    "Exporte gráficos em alta resolução (PNG/PDF) e organize-os em uma pasta dedicada."
                                  ],
                                  "verification": "Visualizar todos os gráficos para confirmar clareza, legendas e relevância aos critérios de validação.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Software de visualização (Matplotlib/Python, Excel)",
                                    "Dados organizados do Step 1"
                                  ],
                                  "tips": "Mantenha gráficos simples: evite sobrecarga de informação; foque em 1-2 variáveis por gráfico.",
                                  "learningObjective": "Produzir visualizações claras que comuniquem efetivamente resultados de validação.",
                                  "commonMistakes": [
                                    "Escalas inadequadas que distorcem dados",
                                    "Falta de legendas, confundindo o leitor",
                                    "Gráficos irrelevantes que não apoiam conclusões"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Redigir Análise e Conclusões Preliminares",
                                  "subSteps": [
                                    "Escreva uma seção de análise resumindo forças (ex.: boa precisão em cenários normais) e fraquezas (ex.: erro alto em picos).",
                                    "Formule conclusões claras sobre representatividade: 'Modelo representativo para X, mas requer ajustes para Y'.",
                                    "Inclua recomendações para próximos passos, como refinamentos no modelo ou experimentos adicionais.",
                                    "Use linguagem objetiva, suportada por referências a tabelas/gráficos (ex.: 'Conforme Figura 2...').",
                                    "Revise o texto para coerência lógica e ausência de jargões desnecessários."
                                  ],
                                  "verification": "Ler o texto para garantir que toda conclusão seja respaldada por evidências específicas.",
                                  "estimatedTime": "25-40 minutos",
                                  "materials": [
                                    "Editor de texto (Word/Google Docs)",
                                    "Gráficos e tabelas dos steps anteriores"
                                  ],
                                  "tips": "Estruture como: Introdução aos resultados > Análise > Conclusões > Recomendações para fluidez.",
                                  "learningObjective": "Interpretar resultados quantitativos em narrativas acionáveis e conclusivas.",
                                  "commonMistakes": [
                                    "Conclusões não suportadas por dados",
                                    "Linguagem subjetiva sem evidências",
                                    "Omitir recomendações, interrompendo transição para experimentos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Compilar e Revisar o Relatório Final",
                                  "subSteps": [
                                    "Estruture o relatório: Capa, Introdução, Evidências (tabelas/gráficos), Análise/Conclusões, Referências.",
                                    "Integre todos os elementos em um documento coeso, com numeração de páginas e sumário.",
                                    "Realize revisão: cheque gramática, consistência visual e fluxo lógico.",
                                    "Adicione seção de transição: 'Baseado nestes resultados, planejar experimentos em...'.",
                                    "Salve em PDF e compartilhe para feedback inicial."
                                  ],
                                  "verification": "Simular apresentação: o relatório permite decisão clara sobre representatividade?",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Editor de documentos (Word/Google Docs)",
                                    "Todos os outputs dos steps anteriores"
                                  ],
                                  "tips": "Use templates de relatório científico para padronização rápida.",
                                  "learningObjective": "Produzir relatórios profissionais prontos para transição em fluxos de modelagem.",
                                  "commonMistakes": [
                                    "Estrutura desorganizada",
                                    "Falta de sumário ou referências cruzadas",
                                    "Não incluir transição explícita para experimentos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado, colete métricas como tempo médio de espera (simulado: 5min, real: 4.8min). Crie gráfico de linha comparando esperas por hora, con clua 'Modelo representativo para horários normais (erro <5%), mas subestima picos de fim de semana', e recomende experimentos com cenários de pico.",
                              "finalVerifications": [
                                "Relatório contém tabelas, gráficos e conclusões interligadas.",
                                "Conclusões explicitam representatividade e próximos passos.",
                                "Visualizações são claras e profissionais.",
                                "Documento está completo, revisado e em PDF.",
                                "Transição para planejamento de experimentos é explícita.",
                                "Todas evidências são rastreáveis a fontes originais."
                              ],
                              "assessmentCriteria": [
                                "Completude: Todas evidências da validação incluídas (90%+ cobertura).",
                                "Clareza visual: Gráficos legíveis e informativos (sem ambiguidades).",
                                "Precisão analítica: Conclusões alinhadas a dados (erro interpretativo <10%).",
                                "Estrutura profissional: Fluxo lógico e formatação padrão.",
                                "Ação orientada: Recomendações claras para experimentos.",
                                "Eficiência: Tempo total dentro de 2 horas."
                              ],
                              "crossCurricularConnections": [
                                "Redação Técnica (Língua Portuguesa): Estrutura de relatórios científicos.",
                                "Programação Computacional: Geração de gráficos via Python/Matplotlib.",
                                "Estatística: Interpretação de métricas como RMSE e testes de representatividade.",
                                "Comunicação: Apresentação de dados para audiências não técnicas."
                              ],
                              "realWorldApplication": "Cientistas de dados em empresas como Google ou Petrobras documentam validações preliminares de modelos de simulação para aprovações regulatórias, otimizações industriais ou publicações acadêmicas, garantindo decisões baseadas em evidências antes de investimentos em experimentos caros."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.6.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.3",
                "name": "Métodos de Amostragem e Geração de Números Aleatórios",
                "description": "Aborda métodos para amostragem, geração de números pseudoaleatórios e variáveis aleatórias em simulações.",
                "totalSkills": 43,
                "atomicTopics": [
                  {
                    "id": "10.1.3.1",
                    "name": "Geradores de Números Pseudoaleatórios",
                    "description": "Métodos para gerar sequências numéricas uniformemente distribuídas que simulam aleatoriedade, como o gerador congruencial linear.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.1.1",
                        "name": "Gerador Congruencial Linear (GCL)",
                        "description": "Método fundamental para geração de números pseudoaleatórios baseado na recursão linear modular, definido pela fórmula X_{n+1} = (a * X_n + c) mod m, onde a é o multiplicador, c o incremento, m o módulo e X_0 a semente.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.1.1",
                            "name": "Compreender a fórmula do GCL",
                            "description": "Explicar os componentes da fórmula do gerador congruencial linear (multiplicador a, incremento c, módulo m e semente X_0) e como eles geram uma sequência pseudoaleatória uniforme no intervalo [0,1).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e explicar os componentes da fórmula do GCL",
                                  "subSteps": [
                                    "Estude a definição do Gerador Congruencial Linear (GCL): X_{n+1} = (a * X_n + c) mod m",
                                    "Descreva cada parâmetro: a (multiplicador, inteiro entre 1 e m-1), c (incremento, inteiro não-negativo), m (módulo, inteiro >1), X_0 (semente, inteiro inicial entre 0 e m-1)",
                                    "Explique o papel de cada um: a controla o 'salto', c evita ciclos curtos, m define o range, X_0 inicia a sequência",
                                    "Anote exemplos numéricos simples para cada parâmetro",
                                    "Compare com geradores sem c (multiplicativo) para destacar a importância do incremento"
                                  ],
                                  "verification": "Liste os quatro componentes com definições corretas e exemplos em um papel ou documento",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Referência: Wikipedia ou livro de Matemática Computacional sobre GCL"
                                  ],
                                  "tips": "Use mnemônicos como 'MACS' (Multiplicador, Additivo/Incremento, Constante/Módulo, Semente) para memorizar",
                                  "learningObjective": "Dominar os papéis e restrições de cada parâmetro na fórmula do GCL",
                                  "commonMistakes": [
                                    "Confundir a com c",
                                    "Esquecer que m deve ser >1",
                                    "Achar que X_0 pode ser qualquer número real"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender o processo recursivo de geração da sequência",
                                  "subSteps": [
                                    "Escreva a fórmula expandida: X_{n+1} = (a * X_n + c) mod m, onde mod m garante X_{n+1} em [0, m-1]",
                                    "Trace o cálculo passo a passo com valores fictícios: a=5, c=3, m=8, X_0=1 → X_1 = (5*1 + 3) mod 8 = 0",
                                    "Gere manualmente os próximos 3-5 termos da sequência para visualizar o ciclo",
                                    "Discuta por que é 'pseudoaleatório': determinístico mas aparenta aleatoriedade",
                                    "Identifique o período máximo possível (m) e condições para alcançá-lo (Hull-Dobell theorem basics)"
                                  ],
                                  "verification": "Calcule corretamente 5 termos consecutivos de uma sequência GCL dada",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora simples",
                                    "Planilha Excel ou papel quadriculado para traçar sequência"
                                  ],
                                  "tips": "Sempre compute o produto a*X_n primeiro para evitar erros de precedência",
                                  "learningObjective": "Aplicar a recursão da fórmula para gerar sequências manualmente",
                                  "commonMistakes": [
                                    "Esquecer o mod m após a soma",
                                    "Usar divisão em vez de módulo",
                                    "Não reduzir valores intermediários"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Normalizar a sequência para o intervalo [0,1)",
                                  "subSteps": [
                                    "Aprenda a transformação: U_n = X_n / m, onde U_n ∈ [0,1)",
                                    "Aplique à sequência anterior: se X_1=0, U_1=0/8=0; X_2=(5*0+3)mod8=3, U_2=3/8=0.375",
                                    "Gere 10 U_n e plote em gráfico para visualizar uniformidade aparente",
                                    "Explique propriedades: independência aparente, invariância de distribuição uniforme",
                                    "Teste com diferentes sementes para mostrar reprodutibilidade",
                                    "Discuta limitações: correlações em lags altos se parâmetros ruins"
                                  ],
                                  "verification": "Transforme 5 X_n em U_n corretamente e descreva a distribuição",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou Python/Jupyter para plot (opcional)",
                                    "Gráfico em papel"
                                  ],
                                  "tips": "Use frações exatas antes de decimalizar para precisão",
                                  "learningObjective": "Compreender como obter números pseudoaleatórios uniformes em [0,1)",
                                  "commonMistakes": [
                                    "Dividir por m-1 em vez de m",
                                    "Incluir 1.0 no intervalo",
                                    "Ignorar que é discreto aproximando contínuo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar qualidade e escolher bons parâmetros",
                                  "subSteps": [
                                    "Estude critérios para bons parâmetros: m potência de 2 ou primo, a=1+ k*m/4 (para m/4 primo), c coprimo com m",
                                    "Teste sequência ruim (a=1,c=0) vs boa (a=1664525,c=1013904223,m=2^32)",
                                    "Calcule período para exemplo simples e verifique ciclo completo",
                                    "Simule em código simples (pseudocódigo) para validar manual",
                                    "Reflita sobre trade-offs: simplicidade vs qualidade estatística"
                                  ],
                                  "verification": "Selecione e justifique parâmetros para um GCL com período full e gere 4 termos",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de parâmetros recomendados (online ou livro)",
                                    "Pseudocódigo editor"
                                  ],
                                  "tips": "Comece com m pequeno (ex:16) para testar ciclos manualmente",
                                  "learningObjective": "Selecionar parâmetros que maximizem período e uniformidade",
                                  "commonMistakes": [
                                    "Escolher a múltiplo de m",
                                    "c=0 levando a sequência aritmética",
                                    "Ignorar coprimos"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando a=7, c=0, m=10, X_0=3: X1=(7*3+0)mod10=1, X2=(7*1)mod10=7, X3=9, X4=3 (ciclo curto). Normalize: U0=0.3, U1=0.1, etc. Note ciclo ruim sem c adequado.",
                              "finalVerifications": [
                                "Explicar verbalmente os 4 componentes e fórmula recursiva",
                                "Gerar manualmente 6 termos de X_n e U_n com parâmetros dados",
                                "Identificar por que U_n é pseudo-uniforme em [0,1)",
                                "Listar 3 condições para período máximo",
                                "Comparar GCL com dado aleatório verdadeiro",
                                "Detectar ciclo em uma sequência ruim"
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de todos componentes (100%)",
                                "Correção nos cálculos recursivos e normalização (sem erros aritméticos)",
                                "Compreensão conceitual de pseudoaleatoriedade e uniformidade",
                                "Seleção adequada de parâmetros com justificativa",
                                "Capacidade de identificar limitações e erros comuns",
                                "Clareza na explicação de ciclos e período"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar GCL em Python ou C++ para simulações",
                                "Estatística: Testes de uniformidade (Chi-quadrado, Kolmogorov-Smirnov)",
                                "Criptografia: Uso em geradores para chaves pseudoaleatórias",
                                "Física Computacional: Simulações de Monte Carlo em sistemas discretos"
                              ],
                              "realWorldApplication": "GCL é base para rand() em linguagens como C/Python, usado em simulações financeiras (Monte Carlo), jogos (procedurais), modelagem de filas em redes e testes de software para cenários aleatórios."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.2",
                            "name": "Calcular sequências manualmente",
                            "description": "Aplicar a fórmula do GCL para gerar manualmente os primeiros termos de uma sequência pseudoaleatória, normalizando para obter valores uniformes em [0,1).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a fórmula do Gerador Congruencial Linear (GCL) e selecionar parâmetros iniciais",
                                  "subSteps": [
                                    "Estude a fórmula do GCL: X_{n+1} = (a * X_n + c) mod m, onde a é o multiplicador, c o incremento, m o módulo e X_0 a semente.",
                                    "Escolha parâmetros válidos: por exemplo, m=100 (para cálculos manuais simples), a=7, c=0, X_0=42.",
                                    "Verifique se os parâmetros atendem critérios básicos de qualidade (ex: a e m coprimos para bom período).",
                                    "Registre os parâmetros em uma tabela para referência.",
                                    "Explique em suas palavras o papel de cada parâmetro na geração pseudoaleatória."
                                  ],
                                  "verification": "Lista completa de parâmetros escolhidos e explicação escrita do seu papel.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora simples",
                                    "Tabela de referência de parâmetros GCL (impressa ou anotada)"
                                  ],
                                  "tips": "Comece com m pequeno (como 100) para evitar cálculos grandes; use parâmetros conhecidos como Hull-Dobell para prática avançada.",
                                  "learningObjective": "Identificar e justificar a escolha de parâmetros para um GCL funcional.",
                                  "commonMistakes": [
                                    "Escolher m=1 (sequência trivial)",
                                    "Confundir a com c",
                                    "Ignorar coprimos entre a e m"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular manualmente os primeiros 5 termos da sequência não normalizada",
                                  "subSteps": [
                                    "Calcule X_1 = (a * X_0 + c) mod m.",
                                    "Calcule X_2 = (a * X_1 + c) mod m.",
                                    "Continue até X_5, registrando cada passo em uma tabela (colunas: n, X_n, a*X_n, a*X_n + c, mod m).",
                                    "Realize multiplicações e somas com cuidado, verificando aritmética intermediária.",
                                    "Anote o valor final de cada X_n."
                                  ],
                                  "verification": "Tabela completa com cálculos corretos para X_0 a X_5.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Calculadora para verificação opcional",
                                    "Parâmetros do Step 1"
                                  ],
                                  "tips": "Faça cálculos em colunas verticais para evitar erros de transporte; divida grandes multiplicações em partes.",
                                  "learningObjective": "Aplicar iterativamente a fórmula GCL para gerar termos pseudoaleatórios.",
                                  "commonMistakes": [
                                    "Esquecer o mod m após soma",
                                    "Erro de ordem nas operações (multiplicar antes de somar)",
                                    "Reiniciar semente acidentalmente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Normalizar a sequência para obter valores uniformes em [0,1)",
                                  "subSteps": [
                                    "Para cada X_n, compute U_n = X_n / m.",
                                    "Registre U_0 a U_5 em uma nova tabela, arredondando se necessário mas mantendo precisão.",
                                    "Verifique que 0 ≤ U_n < 1 para todos os termos.",
                                    "Compare a distribuição visual dos U_n (plote em eixo numérico simples).",
                                    "Explique por que a divisão por m garante uniformidade aproximada."
                                  ],
                                  "verification": "Tabela de U_n com valores em [0,1) e confirmação de intervalos corretos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Tabela de X_n do Step 2",
                                    "Calculadora para divisões precisas"
                                  ],
                                  "tips": "Use frações exatas (ex: 42/100 = 0.42) para precisão; evite arredondamento prematuro.",
                                  "learningObjective": "Transformar sequência inteira em pseudoaleatória uniforme no intervalo unitário.",
                                  "commonMistakes": [
                                    "Dividir por (m-1) em vez de m",
                                    "Incluir 1.0 no intervalo",
                                    "Arredondar para cima incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e analisar a sequência gerada",
                                  "subSteps": [
                                    "Calcule a média dos U_n e compare com 0.5 (esperado para uniforme).",
                                    "Identifique se há repetições prematuras ou padrões óbvios.",
                                    "Gere mais 2 termos (X_6, X_7, U_6, U_7) se necessário para checar ciclo.",
                                    "Discuta limitações do GCL com esses parâmetros.",
                                    "Registre observações em um relatório curto."
                                  ],
                                  "verification": "Relatório com média, ausência de padrões curtos e análise de ciclo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabelas anteriores",
                                    "Papel para gráficos simples",
                                    "Calculadora"
                                  ],
                                  "tips": "Plote pontos U_n em uma linha reta para visualizar uniformidade; use soma rápida para média.",
                                  "learningObjective": "Avaliar a qualidade da sequência pseudoaleatória gerada manualmente.",
                                  "commonMistakes": [
                                    "Ignorar ciclo curto em parâmetros ruins",
                                    "Confundir pseudoaleatório com verdadeiramente aleatório",
                                    "Erro na média aritmética"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando m=100, a=7, c=0, X_0=42: X1=(7*42) mod 100=94 mod 100=94; X2=(7*94) mod 100=658 mod 100=58; U1=94/100=0.94; U2=58/100=0.58. Continue até X5 e normalize, obtendo [0.42, 0.94, 0.58, 0.06, 0.42] – note ciclo curto devido a c=0.",
                              "finalVerifications": [
                                "Sequência de pelo menos 5 X_n calculada corretamente sem erros aritméticos.",
                                "Todos U_n estão estritamente em [0,1).",
                                "Tabelas completas com passos intermediários visíveis.",
                                "Média dos U_n próxima de 0.5 (±0.1 para 5 termos).",
                                "Identificação correta de pelo menos um potencial problema (ex: ciclo).",
                                "Explicação escrita da normalização."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos modulares (100% correto).",
                                "Completude das tabelas e subpassos (todos 3-5 por step).",
                                "Compreensão conceitual demonstrada em explicações.",
                                "Análise de qualidade da sequência (média, padrões).",
                                "Tempo respeitado e organização clara.",
                                "Criatividade na escolha/justificativa de parâmetros."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar GCL em Python ou C++ para automação.",
                                "Estatística: Usar em simulações de Monte Carlo.",
                                "Criptografia: Bases para geradores em segurança digital.",
                                "Física: Modelagem de sistemas estocásticos discretos."
                              ],
                              "realWorldApplication": "Geração de números aleatórios em simulações financeiras (Monte Carlo para opções), jogos de vídeo (movimentos inimigos), testes estatísticos e criptografia básica, onde hardware RNG não está disponível."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.1.1.3",
                            "name": "Implementar GCL em programação",
                            "description": "Escrever um programa simples em uma linguagem como Python ou C para implementar o GCL, gerando uma sequência de N números pseudoaleatórios e salvando em arquivo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambiente e definir parâmetros do GCL",
                                  "subSteps": [
                                    "Instale Python 3.x se não estiver disponível no seu sistema.",
                                    "Crie um novo arquivo Python chamado 'gcl.py'.",
                                    "Defina os parâmetros: módulo m (ex: 2**32), multiplicador a (ex: 1664525), incremento c (ex: 1013904223), semente X0 (ex: 0) e comprimento N (ex: 100).",
                                    "Adicione comentários explicando cada parâmetro e sua importância para a qualidade pseudoaleatória.",
                                    "Teste a sintaxe inicial executando o arquivo vazio."
                                  ],
                                  "verification": "Arquivo 'gcl.py' criado sem erros de sintaxe ao executar 'python gcl.py'.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python 3.x instalado",
                                    "Editor de texto (VS Code, PyCharm ou IDLE)"
                                  ],
                                  "tips": [
                                    "Escolha parâmetros conhecidos por boa distribuição, como os de Numerical Recipes.",
                                    "Use variáveis com nomes descritivos como 'modulo_m' para clareza."
                                  ],
                                  "learningObjective": "Compreender e selecionar parâmetros ótimos para um GCL funcional.",
                                  "commonMistakes": [
                                    "Escolher m não potência de 2, levando a períodos curtos.",
                                    "Ignorar gcd(c, m) != 1, afetando período máximo.",
                                    "Não inicializar X0 adequadamente."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a fórmula do GCL em uma função",
                                  "subSteps": [
                                    "Defina uma função 'gerar_gcl(a, c, m, X0, N)' que inicialize X = X0.",
                                    "Use um loop for i in range(N) para calcular X = (a * X + c) % m e armazenar em uma lista 'sequencia'.",
                                    "Garanta que todas operações sejam com inteiros para evitar overflow (use int em Python).",
                                    "Retorne a lista de números pseudoaleatórios gerados.",
                                    "Adicione docstring à função explicando entrada/saída."
                                  ],
                                  "verification": "Chame a função com parâmetros de teste e imprima os primeiros 5 números; verifique se seguem a fórmula manualmente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Arquivo 'gcl.py' do passo anterior"
                                  ],
                                  "tips": [
                                    "Em Python, % opera corretamente com grandes inteiros; evite float.",
                                    "Teste com N=1 para verificar X1 = (a*X0 + c) % m."
                                  ],
                                  "learningObjective": "Implementar corretamente a recursão linear congruencial em código.",
                                  "commonMistakes": [
                                    "Usar / em vez de % para módulo.",
                                    "Overflow não tratado em linguagens como C (use unsigned long).",
                                    "Loop off-by-one no range(N)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar sequência e salvar em arquivo",
                                  "subSteps": [
                                    "No corpo principal do script, chame gerar_gcl com parâmetros definidos.",
                                    "Abra um arquivo 'gcl_output.txt' em modo 'w'.",
                                    "Escreva cada número da sequência em uma linha separada usando um loop for.",
                                    "Feche o arquivo adequadamente ou use with open para contexto automático.",
                                    "Adicione código para imprimir 'Sequência salva em gcl_output.txt' no console."
                                  ],
                                  "verification": "Execute o script e confirme que 'gcl_output.txt' existe com exatamente N linhas de números inteiros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Arquivo 'gcl.py' atualizado"
                                  ],
                                  "tips": [
                                    "Use '{}\\n'.format(num) para formatação limpa.",
                                    "with open garante fechamento mesmo em erros."
                                  ],
                                  "learningObjective": "Manipular listas, loops e E/S de arquivos em programação.",
                                  "commonMistakes": [
                                    "Esquecer de fechar arquivo, corrompendo dados.",
                                    "Escrever vírgulas ou espaços extras alterando formato.",
                                    "Não tratar exceções de escrita."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e validar a implementação",
                                  "subSteps": [
                                    "Reexecute o script múltiplas vezes com mesma semente; verifique se saída é idêntica (reprodutibilidade).",
                                    "Calcule manualmente os primeiros 3 números e compare com arquivo.",
                                    "Gere histograma simples (use collections.Counter) para checar distribuição.",
                                    "Teste com N=1000 e verifique todos números em [0, m-1).",
                                    "Adicione asserts no código para validação automática."
                                  ],
                                  "verification": "Todos testes passam: reprodutibilidade, bounds corretos e distribuição uniforme básica.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Script 'gcl.py' completo",
                                    "Calculadora para verificação manual"
                                  ],
                                  "tips": [
                                    "Para distribuição, imprima min, max e média da sequência.",
                                    "Considere período: rode até repetir X0."
                                  ],
                                  "learningObjective": "Validar corretude e propriedades pseudoaleatórias do GCL.",
                                  "commonMistakes": [
                                    "Confundir pseudoaleatório com verdadeiramente aleatório.",
                                    "Não checar overflow em cálculos manuais.",
                                    "Ignorar ciclo curto devido a maus parâmetros."
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente um GCL em Python com a=1664525, c=1013904223, m=4294967296 (2**32), X0=12345, N=100. Salve os 100 números em 'gcl_output.txt'. Os primeiros números devem ser: 2036923780, 4113631152, 1282017450 (verifique manualmente).",
                              "finalVerifications": [
                                "Arquivo 'gcl_output.txt' contém exatamente N números inteiros, um por linha.",
                                "Sequência é reproduzível com mesma semente.",
                                "Todos números estão no intervalo [0, m-1).",
                                "Primeiros números coincidem com cálculo manual da fórmula.",
                                "Distribuição aparenta uniformidade (min≈0, max≈m-1, média≈m/2).",
                                "Código executa sem erros ou warnings."
                              ],
                              "assessmentCriteria": [
                                "Correção da implementação da fórmula GCL (100% match com manual).",
                                "Qualidade do código: comentários, nomes variáveis, estrutura limpa.",
                                "Tratamento robusto de E/S de arquivos e parâmetros.",
                                "Validações incluídas (bounds, reprodutibilidade).",
                                "Eficiência: O(N) tempo, sem loops desnecessários.",
                                "Documentação: docstrings e prints informativos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular e teoria dos números.",
                                "Programação: Estruturas de controle, funções e manipulação de arquivos.",
                                "Estatística: Análise de uniformidade e testes de aleatoriedade.",
                                "Ciência da Computação: Algoritmos de PRNG e simulações.",
                                "Engenharia de Software: Testes unitários e validação."
                              ],
                              "realWorldApplication": "GCLs são usados em simulações Monte Carlo (ex: modelagem financeira), geração de mundos em jogos (Minecraft-like), sementes para criptografia básica e testes estatísticos em machine learning."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.1.1",
                              "10.1.3.1.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.1.2",
                        "name": "Propriedades dos Geradores Pseudoaleatórios",
                        "description": "Características essenciais como período, uniformidade, independência e correlação serial que determinam a qualidade de um gerador pseudoaleatório.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.2.1",
                            "name": "Calcular o período do GCL",
                            "description": "Determinar o período máximo de um GCL (m) usando os teoremas de Hull-Dobell e calcular o período para parâmetros específicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição de Gerador Congruencial Linear (GCL) e o conceito de período",
                                  "subSteps": [
                                    "Estude a fórmula recursiva do GCL: X_{n+1} = (a * X_n + c) mod m, onde m é o módulo, a o multiplicador, c o incremento e X_0 a semente.",
                                    "Defina o período como o menor k > 0 tal que X_{n+k} = X_n para todo n ≥ 0, com período máximo igual a m.",
                                    "Analise exemplos simples com m pequeno (ex: m=5) para visualizar sequências e detecção de ciclos.",
                                    "Diferencie período máximo (m) de períodos parciais causados por violações de condições.",
                                    "Registre anotações sobre o espaço de estados finito (0 a m-1) e inevitabilidade de ciclos."
                                  ],
                                  "verification": "Gere manualmente uma sequência para m=10, a=3, c=1, X0=0 e identifique o ciclo visualmente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta, calculadora básica, tabela para anotar sequências.",
                                  "tips": "Comece com sementes zero para simplificar e foque em padrões repetitivos.",
                                  "learningObjective": "Dominar a recursão do GCL e identificar o período em sequências curtas.",
                                  "commonMistakes": "Confundir período com o comprimento total da sequência sem detectar o ciclo mínimo; ignorar que o ciclo pode não incluir todos os estados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar os Teoremas de Hull-Dobell para período máximo",
                                  "subSteps": [
                                    "Memorize as condições necessárias e suficientes para período m: 1) gcd(c, m) = 1; 2) a-1 divisível por todos os fatores primos de m; 3) Se 4|m, então a ≡ 1 mod 4.",
                                    "Aprenda a fatorar m para identificar fatores primos e verificar divisibilidade.",
                                    "Estude provas conceituais ou exemplos ilustrativos dos teoremas.",
                                    "Classifique GCLs como 'bom' (período m) ou 'ruim' (período < m) com base nas condições.",
                                    "Pratique derivando as condições para casos especiais como m potência de 2 ou primo."
                                  ],
                                  "verification": "Liste as 3 condições de Hull-Dobell de cor e aplique a um exemplo dado.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Folha de fórmulas, calculadora para fatoração, vídeo tutorial sobre Hull-Dobell (opcional).",
                                  "tips": "Use fatoração prima de m primeiro; verifique gcd com algoritmo de Euclides.",
                                  "learningObjective": "Aplicar precisamente as condições de Hull-Dobell para prever período máximo.",
                                  "commonMistakes": "Esquecer a condição mod 4 para m divisível por 4; confundir 'necessário' com 'suficiente'."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar condições de Hull-Dobell para parâmetros específicos",
                                  "subSteps": [
                                    "Dado m, a, c: Calcule gcd(c, m) e confirme =1.",
                                    "Fatore m em primos p1, p2,... e verifique se (a-1) % pi == 0 para cada pi.",
                                    "Se m % 4 == 0, confirme (a-1) % 4 == 0.",
                                    "Conclua se o período é m ou inferior; se sim, pare aqui.",
                                    "Documente cada verificação com cálculos explícitos."
                                  ],
                                  "verification": "Para m=16, a=5, c=1: Aplique todas as condições e justifique se período é 16.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora científica, tabela de fatoração prima.",
                                  "tips": "Automatize gcd e mod com funções de calculadora; liste fatores primos de m antecipadamente.",
                                  "learningObjective": "Diagnosticar rapidamente se um GCL tem período máximo.",
                                  "commonMistakes": "Erro em fatoração de m levando a verificações erradas; ignorar c=0 (inválido para máximo)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular o GCL para calcular o período exato quando não máximo",
                                  "subSteps": [
                                    "Implemente a recursão em pseudocódigo ou código simples (ex: Python loop).",
                                    "Gere sequência até detectar repetição do estado inicial (use conjunto para rastrear vistos).",
                                    "Registre o comprimento do ciclo (período) como o primeiro retorno a X0 após partida.",
                                    "Teste múltiplas sementes para confirmar período global.",
                                    "Compare com previsão de Hull-Dobell e analise por que falhou."
                                  ],
                                  "verification": "Simule m=10, a=2, c=1, X0=0 e reporte o período encontrado (deve ser 5).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Editor de código (Python/IDLE), ou planilha Excel para simulação manual.",
                                  "tips": "Use loop while com set() em Python para eficiência; limite iterações a 2*m para segurança.",
                                  "learningObjective": "Computar período real via simulação empírica.",
                                  "commonMistakes": "Parar no primeiro repeat não-cíclico; confundir tau (pré-período) com período."
                                }
                              ],
                              "practicalExample": "Para m=7 (primo), a=5, c=3, X0=0: Verifique Hull-Dobell: gcd(3,7)=1; 5-1=4, 4%7? Não, mas 7 primo, a-1 deve ser div por 7? Não: para primo p, a≡1 mod p. 5≢1 mod7. Simule: 0,3,20mod7=6,33mod7=5,28mod7=0 → período 4 <7.",
                              "finalVerifications": [
                                "Recita corretamente as 3 condições de Hull-Dobell.",
                                "Verifica período máximo para 3 conjuntos de parâmetros dados.",
                                "Simula corretamente um GCL com período parcial e identifica o ciclo.",
                                "Explica por que um GCL falha em ter período m.",
                                "Compara previsão teórica vs. simulação em um exemplo."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas verificações matemáticas (gcd, mod, fatoração): 100% correto.",
                                "Correção na simulação (período exato identificado).",
                                "Explicação clara das condições violadas.",
                                "Eficiência na simulação (código ou manual sem erros).",
                                "Análise de exemplo prático com justificativa.",
                                "Uso correto de terminologia (período, módulo, etc.)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação de loops e estruturas de dados (sets para detecção de ciclo).",
                                "Probabilidade: Avaliação de uniformidade em sequências pseudoaleatórias.",
                                "Criptografia: Uso de GCLs em cifras stream primitivas.",
                                "Física Computacional: Simulações Monte Carlo em sistemas discretos."
                              ],
                              "realWorldApplication": "Em simulações científicas (ex: modelagem de partículas em física), jogos de azar digitais para RNGs, testes de software para validação de aleatoriedade, e bancos de dados para amostragem aleatória eficiente sem bibliotecas externas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.1.2.2",
                            "name": "Avaliar uniformidade e independência",
                            "description": "Analisar testes estatísticos básicos para verificar a distribuição uniforme e a ausência de correlação em sequências geradas por GCL.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Gerar sequência pseudoaleatória com Gerador Congruencial Linear (GCL)",
                                  "subSteps": [
                                    "Escolha parâmetros do GCL: módulo m (potência de 2 ou primo), multiplicador a (coprimo com m), incremento c (>0), semente x0 (0 ≤ x0 < m).",
                                    "Aplique a fórmula recursiva: X_{n+1} = (a * X_n + c) mod m, para gerar N valores (ex: N=10000).",
                                    "Normalize os valores para o intervalo [0,1): U_i = X_i / m.",
                                    "Armazene a sequência em uma lista ou array para análise posterior.",
                                    "Visualize a sequência com histograma inicial para inspeção visual."
                                  ],
                                  "verification": "Verifique se a sequência tem exatamente N elementos, todos em [0,1), e se a fórmula foi aplicada corretamente comparando os primeiros 10 termos manualmente.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Python com bibliotecas numpy e matplotlib; ou calculadora para testes manuais pequenos.",
                                  "tips": "Escolha m grande para melhor qualidade; teste com parâmetros conhecidos como m=2^31, a=1103515245, c=12345.",
                                  "learningObjective": "Implementar corretamente um GCL e gerar sequências pseudoaleatórias normalizadas.",
                                  "commonMistakes": "Esquecer o 'mod m' causando overflow; escolher parâmetros ruins levando a períodos curtos; não normalizar para [0,1)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar teste de uniformidade com Qui-Quadrado",
                                  "subSteps": [
                                    "Divida [0,1) em k bins iguais (ex: k=10, cada bin de largura 0.1).",
                                    "Conte a frequência observada O_i em cada bin: O_i = número de U_j no bin i.",
                                    "Calcule frequências esperadas E_i = N / k para cada bin.",
                                    "Compute estatística Qui-Quadrado: χ² = Σ (O_i - E_i)² / E_i.",
                                    "Determine o p-valor usando distribuição qui-quadrado com k-1 graus de liberdade (tabela ou função scipy.stats.chi2.sf)."
                                  ],
                                  "verification": "Confirme que Σ O_i = N, E_i iguais, e p-valor calculado corretamente; rejeite H0 se p < 0.05.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Python com scipy.stats; tabela de qui-quadrado impressa.",
                                  "tips": "Use k ≈ √N / 5 para bins adequados; ignore bins vazios ajustando df.",
                                  "learningObjective": "Aplicar teste qui-quadrado para validar distribuição uniforme da sequência.",
                                  "commonMistakes": "Usar k muito pequeno/grande; esquecer de subtrair 1 nos graus de liberdade; interpretar p-valor ao contrário."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar teste de independência com Teste de Runs",
                                  "subSteps": [
                                    "Transforme a sequência em binária: defina runs como sequências de +1 (U_i >=0.5) ou -1 (U_i <0.5).",
                                    "Conte o número total de runs R: trocas entre +1 e -1.",
                                    "Calcule estatísticas: n1 = número de +1, n2 = número de -1, N = n1 + n2.",
                                    "Compute Z = (R - μ) / σ, onde μ = (2 n1 n2 / N) + 1, σ = √(2 n1 n2 (2 n1 n2 - N) / (N² (N-1))).",
                                    "Avalie normalidade: |Z| < 1.96 para independência ao nível 5%."
                                  ],
                                  "verification": "Verifique contagem de runs manualmente nos primeiros 20 termos; confirme |Z| <1.96 indica independência.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Python com numpy para contagens; papel para contagem manual inicial.",
                                  "tips": "Use N par para equilíbrio; teste com lag-1 se runs falhar.",
                                  "learningObjective": "Detectar correlações seriais usando teste de runs em sequências binárias.",
                                  "commonMistakes": "Errar na definição de runs (contar blocos corretamente); fórmulas erradas para μ/σ; N pequeno demais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados e concluir sobre propriedades",
                                  "subSteps": [
                                    "Reúna resultados: p-valor qui-quadrado e Z do runs test.",
                                    "Interprete: uniformidade se p_χ² >0.05; independência se |Z|<1.96.",
                                    "Discuta limitações: tamanho N, parâmetros GCL; sugira melhorias (ex: Mersenne Twister).",
                                    "Gere relatório com gráficos (histograma, runs plot).",
                                    "Compare com sequência rand() do Python para benchmark."
                                  ],
                                  "verification": "Conclusão consistente com testes; relatório cobre todos aspectos.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Jupyter Notebook para relatórios; matplotlib para plots.",
                                  "tips": "Sempre reportar p-valores exatos; contextualize falhas.",
                                  "learningObjective": "Sintetizar testes estatísticos para avaliar qualidade de GNP.",
                                  "commonMistakes": "Ignorar limitações do GCL; super-generalizar resultados; pular gráficos."
                                }
                              ],
                              "practicalExample": "Use GCL com m=1000, a=221, c=97, x0=12. Gere N=5000 U_i. Bins=10: calcule χ²≈8.2 (p=0.51>0.05, uniforme). Runs: n1=2487, n2=2513, R=5020, Z=0.12<1.96 (independente). Conclusão: bom para simulações simples.",
                              "finalVerifications": [
                                "Sequência gerada corretamente com N elementos em [0,1).",
                                "Qui-quadrado calculado com p-valor >0.05 ou rejeição justificada.",
                                "Teste de runs com |Z|<1.96 ou análise de falha.",
                                "Gráficos mostram ausência de padrões visuais.",
                                "Relatório interpreta resultados corretamente.",
                                "Parâmetros GCL documentados e período verificado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na implementação do GCL (fórmula e normalização).",
                                "Correção matemática nos testes estatísticos (fórmulas qui-quadrado e runs).",
                                "Interpretação estatística adequada de p-valores e Z-scores.",
                                "Uso apropriado de N e k para testes robustos.",
                                "Relatório claro com evidências visuais e conclusões.",
                                "Identificação de limitações e sugestões de melhoria."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Testes de hipóteses e distribuições.",
                                "Programação: Implementação numérica e visualização de dados.",
                                "Probabilidade: Propriedades de variáveis aleatórias.",
                                "Análise de Dados: Validação de simulações.",
                                "Ciências da Computação: Algoritmos de geração aleatória."
                              ],
                              "realWorldApplication": "Avaliar GNP em simulações Monte Carlo para previsão financeira (ex: opções), jogos digitais (RNG justo), criptografia (chaves pseudoaleatórias) e modelagem científica (experimentos estocásticos), garantindo ausência de bias em resultados."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.1.3",
                              "10.1.3.1.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.1.3",
                        "name": "Outros Geradores Pseudoaleatórios",
                        "description": "Alternativas ao GCL, como geradores congruenciais multiplicativos e métodos combinados para melhorar o período e a qualidade da aleatoriedade.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.3.1",
                            "name": "Entender GCL Multiplicativo",
                            "description": "Descrever o gerador congruencial multiplicativo (c=0) e suas vantagens e limitações em comparação ao GCL completo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Definição e Fórmula do GCL Multiplicativo",
                                  "subSteps": [
                                    "Revise a fórmula geral do Gerador Congruencial Linear (GCL): X_{n+1} = (a * X_n + c) mod m.",
                                    "Identifique o GCL Multiplicativo como o caso especial onde c = 0, resultando em X_{n+1} = (a * X_n) mod m.",
                                    "Explique os parâmetros: semente inicial X_0, multiplicador a, módulo m.",
                                    "Escreva a fórmula explicitamente e memorize os termos chave.",
                                    "Observe que se X_n = 0, todos os subsequentes serão 0."
                                  ],
                                  "verification": "Recite a fórmula corretamente e distinga de GCL completo em uma explicação oral ou escrita.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora",
                                    "Referência de Matemática Computacional"
                                  ],
                                  "tips": [
                                    "Visualize a fórmula como uma multiplicação modular simples.",
                                    "Comece com valores pequenos para m para testar."
                                  ],
                                  "learningObjective": "Dominar a definição exata e os componentes do GCL Multiplicativo.",
                                  "commonMistakes": [
                                    "Confundir com GCL completo incluindo c ≠ 0.",
                                    "Esquecer que o módulo m define o range [0, m-1]."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Parâmetros e Gerar Sequências de Exemplo",
                                  "subSteps": [
                                    "Escolha parâmetros exemplo: X_0 = 1, a = 5, m = 16.",
                                    "Calcule manualmente os primeiros 5-10 termos da sequência.",
                                    "Analise o período da sequência (quando repete).",
                                    "Teste com diferentes sementes e observe padrões.",
                                    "Implemente uma iteração simples em pseudocódigo."
                                  ],
                                  "verification": "Gere uma sequência correta de 10 termos para parâmetros dados e identifique o período.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora gráfica ou planilha Excel",
                                    "Papel quadriculado"
                                  ],
                                  "tips": [
                                    "Use potências de 2 para m para facilitar análise de período.",
                                    "Registre cada passo para rastrear erros."
                                  ],
                                  "learningObjective": "Aplicar a fórmula para gerar e analisar sequências pseudoaleatórias.",
                                  "commonMistakes": [
                                    "Erro aritmético em multiplicação modular.",
                                    "Ignorar overflow em cálculos manuais grandes."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Vantagens do GCL Multiplicativo",
                                  "subSteps": [
                                    "Liste vantagens: simplicidade computacional (apenas mul e mod, sem adição).",
                                    "Discuta eficiência em hardware antigo ou embarcado.",
                                    "Compare custo computacional com GCL completo.",
                                    "Mencione casos onde período é bom (ex: m=2^k, a adequado).",
                                    "Pesquise referências históricas de uso (ex: RANDU é um GCLM famoso)."
                                  ],
                                  "verification": "Enumere pelo menos 3 vantagens específicas com justificativas breves.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Artigo ou capítulo sobre GCL",
                                    "Internet para exemplos históricos"
                                  ],
                                  "tips": [
                                    "Pense em cenários de baixa potência computacional.",
                                    "Compare contagem de operações: GCLM tem 2 vs 3 no GCL."
                                  ],
                                  "learningObjective": "Reconhecer cenários onde GCLM é preferível ao GCL completo.",
                                  "commonMistakes": [
                                    "Superestimar período sem condições específicas em a e m.",
                                    "Confundir simplicidade com qualidade aleatória."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Limitações e Comparar com GCL Completo",
                                  "subSteps": [
                                    "Descreva limitações: período no máximo m/4 para m par; sequências curtas se X_0=0.",
                                    "Compare com GCL completo: GCLM tem período pior em geral, mais correlações.",
                                    "Discuta testes de aleatoriedade (ex: runs test falha mais).",
                                    "Exemplo: RANDU (a=65539, m=2^31) tem problemas conhecidos.",
                                    "Conclua quando evitar GCLM (simulações críticas)."
                                  ],
                                  "verification": "Explique 3 limitações e dê um exemplo comparativo com GCL completo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos de código Python para testes",
                                    "Tabelas de períodos máximos"
                                  ],
                                  "tips": [
                                    "Use gráficos de pontos para visualizar correlações em sequências.",
                                    "Lembre: GCL completo permite períodos plenos mais facilmente."
                                  ],
                                  "learningObjective": "Avaliar criticamente GCLM vs GCL completo para escolhas informadas.",
                                  "commonMistakes": [
                                    "Ignorar que GCLM pode entrar em ciclo zero cedo.",
                                    "Generalizar bom desempenho sem parâmetros otimizados."
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente em Python um GCL Multiplicativo com X0=1, a=21, m=2**16. Gere 100 números, plote-os em um gráfico de dispersão para visualizar padrões lineares (limitação típica), e compare com um GCL completo (c=1) no mesmo gráfico.",
                              "finalVerifications": [
                                "Descreva corretamente a fórmula do GCLM e sua relação com GCL geral.",
                                "Gere uma sequência manual de 10 termos sem erros.",
                                "Liste 3 vantagens e 3 limitações específicas.",
                                "Explique condições para período próximo de m.",
                                "Compare qualidade pseudoaleatória com GCL completo.",
                                "Identifique um exemplo histórico como RANDU."
                              ],
                              "assessmentCriteria": [
                                "Exatidão na fórmula e parâmetros (20%)",
                                "Precisão em cálculos de sequências e períodos (25%)",
                                "Profundidade na análise de vantagens e limitações (25%)",
                                "Qualidade da comparação com GCL completo (15%)",
                                "Uso correto de exemplos práticos e verificações (15%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em linguagens como Python ou C para simulações.",
                                "Estatística: Testes de uniformidade e independência em números pseudoaleatórios.",
                                "Criptografia: Fundamentos de geradores em sistemas de chaves.",
                                "Ciência da Computação: Otimização de algoritmos em hardware limitado."
                              ],
                              "realWorldApplication": "Utilizado em simulações Monte Carlo simplificadas, jogos antigos para RNG rápidos (ex: pacotes BASIC), e protótipos de software embarcado onde simplicidade supera qualidade, como em microcontroladores IoT para amostragem não crítica."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.1.3.2",
                            "name": "Explorar geradores combinados",
                            "description": "Explicar como combinar múltiplos GCL para obter períodos maiores e melhor aleatoriedade, com exemplos práticos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Geradores Congruenciais Lineares (GCL) Individuais",
                                  "subSteps": [
                                    "Estude a fórmula básica de um GCL: X_{n+1} = (a * X_n + c) mod m.",
                                    "Identifique parâmetros chave: semente X_0, multiplicador a, incremento c, módulo m.",
                                    "Calcule manualmente 10 iterações de um GCL simples com m=100, a=7, c=0, X_0=1.",
                                    "Discuta limitações: período máximo m, correlações detectáveis.",
                                    "Compare com propriedades ideais de geradores aleatórios (uniformidade, independência)."
                                  ],
                                  "verification": "Gere uma sequência manual e valide contra implementação em código simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta; Jupyter Notebook com Python; documentação de GCL (ex: Wikipedia).",
                                  "tips": "Escolha parâmetros que maximizem o período (a coprimo com m, etc.).",
                                  "learningObjective": "Compreender estrutura e limitações de GCL isolados.",
                                  "commonMistakes": "Ignorar condições para período completo (ex: c=0 requer a-1 divisível por todos os fatores primos de m)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Técnicas de Combinação de GCL",
                                  "subSteps": [
                                    "Aprenda combinação por soma modular: Y_n = (X_n + Z_n) mod m, onde X e Z são GCL independentes.",
                                    "Explore multiplicação: Y_n = (X_n * Z_n) mod m.",
                                    "Analise combinação de XOR: Y_n = X_n XOR Z_n (para inteiros).",
                                    "Estude teoremas: período do combinado pode ser produto dos períodos individuais se GCLs forem independentes.",
                                    "Calcule teoricamente o período esperado para dois GCL com períodos p1 e p2."
                                  ],
                                  "verification": "Resuma em um diagrama as 3 técnicas e fórmulas; calcule período teórico para exemplo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Jupyter Notebook; referências acadêmicas (ex: Knuth 'The Art of Computer Programming').",
                                  "tips": "Use GCLs com módulos m iguais para simplificar soma/mod.",
                                  "learningObjective": "Dominar métodos matemáticos para combinar GCLs e prever melhorias.",
                                  "commonMistakes": "Assumir independência sem verificar parâmetros coprimos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar um Gerador Combinado em Python",
                                  "subSteps": [
                                    "Defina duas classes GCL com parâmetros diferentes (ex: GCL1: m=2^31-1, a=16807; GCL2: m=2^31-1, a=48271).",
                                    "Implemente combinação por soma modular em uma função generator().",
                                    "Gere 10000 números e normalize para [0,1].",
                                    "Visualize histograma e autoco correlação da sequência.",
                                    "Teste com seed diferente e compare com GCL único."
                                  ],
                                  "verification": "Execute código e confirme ausência de padrões visuais no histograma.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Python 3, bibliotecas: numpy, matplotlib, scipy.stats.",
                                  "tips": "Use random.seed() para reprodutibilidade.",
                                  "learningObjective": "Aplicar combinações em código prático.",
                                  "commonMistakes": "Overflow em multiplicações; não normalizar para [0,1]."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Período e Qualidade de Aleatoriedade",
                                  "subSteps": [
                                    "Calcule período empírico detectando ciclo via conjunto de estados (X_n, Z_n).",
                                    "Aplique teste chi-quadrado para uniformidade.",
                                    "Realize teste de runs para independência.",
                                    "Compare métricas com GCL individual (período, p-value dos testes).",
                                    "Otimize parâmetros se necessário e reteste."
                                  ],
                                  "verification": "Relatório com tabela: período, chi2 p-value >0.05, runs passados.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Python com scipy.stats; ferramenta online como DIEHARDER (opcional).",
                                  "tips": "Para período grande, sample 1e6 pontos.",
                                  "learningObjective": "Quantificar benefícios da combinação.",
                                  "commonMistakes": "Testes insuficientes; confundir pseudoaleatoriedade com verdadeira."
                                }
                              ],
                              "practicalExample": "Combine dois GCL (m=2147483647, GCL1: a=16807 c=0 X0=1; GCL2: a=48271 c=0 X0=2) via Y_n = (X_n + Z_n) mod m. Gere 1000 números, plote histograma uniforme e confirme período ~10^18 vs 2^31 individuais.",
                              "finalVerifications": [
                                "Sequência combinada exibe histograma uniforme sem gaps.",
                                "Período empírico excede produto dos períodos individuais mínimos.",
                                "Testes estatísticos (chi2, runs) passam com p-value >0.01.",
                                "Autocorrelação <0.05 para lags 1-20.",
                                "Implementação reproduz sequência idêntica com mesma seed.",
                                "Comparação mostra superioridade vs GCL único."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática das combinações implementadas.",
                                "Qualidade dos testes de aleatoriedade (múltiplos e apropriados).",
                                "Análise quantitativa de período e uniformidade.",
                                "Código limpo, comentado e modular.",
                                "Compreensão verbal das limitações e benefícios.",
                                "Exemplo prático personalizado e funcional."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação de classes e testes em Python.",
                                "Estatística: Testes de hipóteses (chi-quadrado, runs test).",
                                "Criptografia: Uso em chaves pseudoaleatórias.",
                                "Física Computacional: Simulações Monte Carlo."
                              ],
                              "realWorldApplication": "Em simulações Monte Carlo para finanças (preços de opções), jogos (geração de mundos procedurais) e machine learning (inicialização de pesos), onde longos períodos evitam repetições e melhor aleatoriedade melhora precisão."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.2.1",
                              "10.1.3.1.3.1"
                            ]
                          },
                          {
                            "id": "10.1.3.1.3.3",
                            "name": "Aplicar em simulações",
                            "description": "Integrar um gerador pseudoaleatório em um modelo simples de simulação discreta para gerar chegadas ou tempos de serviço.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e implementar um gerador pseudoaleatório",
                                  "subSteps": [
                                    "Estude os parâmetros de um gerador Linear Congruencial (LCG): multiplicador (a), incremento (c), módulo (m).",
                                    "Escolha valores padrão seguros, como a=1664525, c=1013904223, m=2^32.",
                                    "Implemente a função em Python que gera uma sequência de números uniformes [0,1).",
                                    "Teste a geração de 1000 números e visualize o histograma.",
                                    "Verifique a periodicidade e ausência de padrões visíveis."
                                  ],
                                  "verification": "Execute o código e confirme que gera números entre 0 e 1 sem repetições prematuras nos primeiros 1000 valores.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python (Jupyter Notebook ou IDE), bibliotecas numpy e matplotlib",
                                  "tips": "Use inteiros de 64 bits para evitar overflow em Python.",
                                  "learningObjective": "Compreender e codificar um LCG funcional para geração de pseudoaleatórios uniformes.",
                                  "commonMistakes": "Escolher parâmetros ruins que causem ciclo curto; esquecer de normalizar para [0,1)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o modelo simples de simulação discreta",
                                  "subSteps": [
                                    "Escolha um modelo de fila M/M/1 com taxa de chegada λ=0.5 e serviço μ=0.7 por unidade de tempo.",
                                    "Estruture a simulação em eventos: chegada e saída.",
                                    "Crie variáveis de estado: fila vazia/cheia, tempo atual, próximo evento.",
                                    "Implemente a lógica de avanço de tempo até o próximo evento.",
                                    "Defina duração da simulação em 1000 unidades de tempo."
                                  ],
                                  "verification": "Simule sem aleatoriedade (determinístico) e confirme que o código avança corretamente sem loops infinitos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python, código do Step 1",
                                  "tips": "Use uma lista ou fila para armazenar clientes na espera.",
                                  "learningObjective": "Modelar uma simulação de eventos discretos básica sem aleatoriedade.",
                                  "commonMistakes": "Confundir taxa de chegada com tempo médio entre chegadas; não tratar fila vazia corretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar o gerador para chegadas e tempos de serviço",
                                  "subSteps": [
                                    "Transforme uniformes do LCG em exponenciais usando -log(U)/λ para interarrivos de chegada.",
                                    "Gere tempos de serviço exponenciais com -log(U)/μ.",
                                    "Substitua tempos fixos pelos gerados no modelo de simulação.",
                                    "Inicialize o gerador com semente fixa para reprodutibilidade.",
                                    "Registre estatísticas: tempo na fila, tempo no sistema, comprimento médio da fila."
                                  ],
                                  "verification": "Execute uma simulação e verifique se as estatísticas médias aproximam valores teóricos (ex: Lq ≈ ρ^2/(1-ρ) para M/M/1).",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Código dos Steps 1 e 2, função math.log",
                                  "tips": "Mantenha o estado do gerador global para consistência entre chamadas.",
                                  "learningObjective": "Integrar pseudoaleatoriedade para modelar variabilidade estocástica em simulações.",
                                  "commonMistakes": "Gerar U=0 levando a log(0)=inf; não resetar o gerador entre simulações."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar, analisar e validar a simulação",
                                  "subSteps": [
                                    "Rode 10 réplicas da simulação variando a semente.",
                                    "Calcule intervalos de confiança para métricas (média ± 2*desvio padrão / sqrt(n)).",
                                    "Compare com teoria: utilização ρ=λ/μ ≈0.71, tempo na fila teórico.",
                                    "Plote histogramas de tempos na fila e comprimento da fila.",
                                    "Teste sensibilidade alterando λ ou parâmetros do LCG."
                                  ],
                                  "verification": "Resultados dentro de 10% dos valores teóricos e plots sem padrões artificiais.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código completo, numpy para estatísticas, matplotlib para plots",
                                  "tips": "Use múltiplas réplicas para reduzir variância.",
                                  "learningObjective": "Avaliar validade da simulação e interpretar resultados estocásticos.",
                                  "commonMistakes": "Poucas réplicas levando a variância alta; ignorar steady-state (descartar primeiros 10%)."
                                }
                              ],
                              "practicalExample": "Implemente uma simulação de fila de caixa de supermercado: use LCG para gerar interarrivos exponenciais (λ=2 clientes/hora) e tempos de serviço (μ=3 clientes/hora). Rode por 8 horas, calcule tempo médio na fila e valide contra teoria M/M/1.",
                              "finalVerifications": [
                                "Código executa sem erros e gera saídas reprodutíveis com semente fixa.",
                                "Distribuições de chegadas e serviços passam no teste de Kolmogorov-Smirnov para exponencial.",
                                "Estatísticas médias convergem para valores teóricos com 10+ réplicas.",
                                "Plots mostram comportamento realista sem correlações do LCG.",
                                "Simulação lida corretamente com fila vazia e sobrecarga.",
                                "Intervalos de confiança são razoáveis (largura <20% da média)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na implementação do LCG (período longo, uniformidade).",
                                "Correta transformação para distribuições exponenciais.",
                                "Lógica de eventos discretos sem bugs (ex: não pular eventos).",
                                "Análise estatística robusta com réplicas e steady-state.",
                                "Interpretação clara dos resultados vs. teoria.",
                                "Código limpo, comentado e modular."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: distribuições exponenciais e intervalos de confiança.",
                                "Programação: estruturas de dados (filas), OOP para gerador.",
                                "Física/Engenharia: modelagem de sistemas em filas (tráfego, manufatura).",
                                "Análise de Dados: visualização e testes de hipóteses."
                              ],
                              "realWorldApplication": "Em logística para simular filas de produção e otimizar alocação de recursos; em telecomunicações para modelar pacotes em redes e prever congestionamentos; em saúde para planejar atendimento em emergências."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.1.3",
                              "10.1.3.1.2.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.2",
                    "name": "Testes de Aleatoriedade",
                    "description": "Procedimentos estatísticos para avaliar a qualidade e independência dos números pseudoaleatórios gerados.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.2.1",
                        "name": "Testes de Uniformidade",
                        "description": "Procedimentos estatísticos que verificam se os números pseudoaleatórios gerados seguem uma distribuição uniforme contínua no intervalo [0,1], essencial para garantir a qualidade básica da sequência gerada.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.1.1",
                            "name": "Teste Qui-Quadrado de Ajuste",
                            "description": "Aplicar o teste qui-quadrado para comparar a frequência observada de números pseudoaleatórios em intervalos iguais com a frequência esperada sob uniformidade, calculando o estatístico χ² = Σ (O_i - E_i)² / E_i e comparando com a distribuição qui-quadrado com k-1 graus de liberdade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a amostra de números pseudoaleatórios",
                                  "subSteps": [
                                    "Obtenha ou gere uma sequência de N números pseudoaleatórios uniformemente distribuídos entre 0 e 1 (ex: N=1000).",
                                    "Registre a sequência em uma tabela ou array para análise.",
                                    "Defina o número de intervalos k (ex: k=10 para intervalos de largura 0.1).",
                                    "Crie uma tabela com colunas para intervalos, observados (O_i) e esperados (E_i).",
                                    "Calcule E_i = N / k para cada intervalo."
                                  ],
                                  "verification": "Verifique se a soma de todos O_i equals N e soma de E_i equals N.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Sequenciador de números pseudoaleatórios (ex: Python random module ou Excel RAND()), planilha ou papel para tabela"
                                  ],
                                  "tips": "Use N grande (≥300) para validade aproximada do teste; garanta que E_i ≥5 em todos intervalos.",
                                  "learningObjective": "Compreender a importância de uma amostra adequada para testes de uniformidade.",
                                  "commonMistakes": [
                                    "Escolher N muito pequeno",
                                    "Não garantir uniformidade inicial assumida",
                                    "Intervalos desiguais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Contar frequências observadas e calcular esperadas",
                                  "subSteps": [
                                    "Conte o número de pontos em cada intervalo i=1 a k, registrando como O_i.",
                                    "Confirme E_i = N/k para cada i.",
                                    "Preencha a tabela com O_i e E_i.",
                                    "Verifique se todos O_i e E_i são ≥0 e E_i ≥5.",
                                    "Ajuste k se necessário para atender critérios."
                                  ],
                                  "verification": "Soma( O_i ) = N e cada E_i ≥5; tabela completa sem erros de contagem.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha (Excel/Google Sheets) ou software de contagem (Python pandas histograma)"
                                  ],
                                  "tips": "Use função HISTOGRAM no Excel ou np.histogram no Python para automação.",
                                  "learningObjective": "Dominar a divisão em intervalos iguais e cálculo de frequências para teste de ajuste.",
                                  "commonMistakes": [
                                    "Erros de contagem manual",
                                    "Intervalos sobrepostos",
                                    "E_i <5 ignorado"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o estatístico qui-quadrado χ²",
                                  "subSteps": [
                                    "Para cada i, calcule (O_i - E_i)² / E_i.",
                                    "Some todos os termos: χ² = Σ (O_i - E_i)² / E_i de i=1 a k.",
                                    "Registre o valor exato de χ².",
                                    "Arredonde para 4 casas decimais se manual.",
                                    "Valide cálculo com fórmula em software."
                                  ],
                                  "verification": "Recalcule χ² independentemente ou use função chisquare em Python/R para comparar.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora científica, planilha com fórmulas ou Python (scipy.stats.chisquare)"
                                  ],
                                  "tips": "Automatize soma com =SUMPRODUCT((O-E)^2/E) no Excel.",
                                  "learningObjective": "Executar precisamente a fórmula do estatístico de qui-quadrado de ajuste.",
                                  "commonMistakes": [
                                    "Dividir por O_i em vez de E_i",
                                    "Esquecer o quadrado",
                                    "Incluir i com E_i=0"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar com distribuição qui-quadrado e interpretar",
                                  "subSteps": [
                                    "Determine graus de liberdade df = k - 1.",
                                    "Escolha nível de significância α (ex: 0.05).",
                                    "Encontre valor crítico χ²_{α, df} em tabela ou software.",
                                    "Compare: se χ² > crítico, rejeite H0 (não uniforme); senão, não rejeite.",
                                    "Calcule p-value se possível e interprete."
                                  ],
                                  "verification": "Conclusão lógica baseada em comparação; relatório escrito com df, α, decisão.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de qui-quadrado, software (Python scipy.stats.chi2.sf ou R pchisq)"
                                  ],
                                  "tips": "Use qchisq(1-0.05, df) no R para crítico; sempre reporte df explicitamente.",
                                  "learningObjective": "Aplicar teste de hipótese completo para validar uniformidade.",
                                  "commonMistakes": [
                                    "df = k em vez de k-1",
                                    "Confundir p-value com estatístico",
                                    "Ignorar α"
                                  ]
                                }
                              ],
                              "practicalExample": "Gere 1000 números pseudoaleatórios U[0,1] com linear congruential generator (ex: X_{n+1} = (a X_n + c) mod m). Divida em 10 bins de 0.1: O = [98, 105, 92, 110, 99, 102, 95, 108, 101, 90]; E_i=100 cada. χ² ≈ 2.47, df=9, crítico(0.05)=16.92 → Não rejeita H0, uniforme.",
                              "finalVerifications": [
                                "Tabela de O_i e E_i completa e soma correta.",
                                "χ² calculado matches fórmula exata.",
                                "df = k-1 correto.",
                                "Comparação com valor crítico ou p-value apropriada.",
                                "Conclusão sobre uniformidade justificada.",
                                "Relatório inclui todos componentes do teste."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de frequências (erro <1%).",
                                "Correção na fórmula χ² (valor exato).",
                                "Uso adequado de df e α.",
                                "Interpretação coerente da hipótese nula.",
                                "Automação ou verificação cruzada demonstrada.",
                                "Relatório claro e estruturado."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar gerador RNG em Python/R.",
                                "Estatística: Testes de hipótese e distribuições assintóticas.",
                                "Simulação: Modelagem de sistemas estocásticos.",
                                "Criptografia: Validação de PRNG para segurança."
                              ],
                              "realWorldApplication": "Testar qualidade de geradores de números aleatórios em software de simulação (ex: Monte Carlo), jogos de azar, criptografia (keys seguras) e pesquisas científicas para garantir suposição de uniformidade."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.1.2",
                            "name": "Teste de Kolmogorov-Smirnov",
                            "description": "Executar o teste KS para avaliar a máxima diferença absoluta entre a função de distribuição cumulativa empírica (ECDF) dos números gerados e a CDF teórica uniforme, rejeitando a hipótese nula se D_n > valor crítico tabelado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos Teóricos do Teste KS",
                                  "subSteps": [
                                    "Defina a Função de Distribuição Cumulativa Empírica (ECDF) como F_n(x) = (número de observações ≤ x) / n.",
                                    "Explique a CDF teórica uniforme U(0,1): F(x) = x para x em [0,1].",
                                    "Estabeleça a hipótese nula H0: os dados seguem distribuição uniforme U(0,1).",
                                    "Descreva a estatística D_n = sup |F_n(x) - F(x)| sobre todos x.",
                                    "Discuta o valor crítico tabelado baseado em n e nível de significância α (ex: 0.05)."
                                  ],
                                  "verification": "Resuma em suas palavras os conceitos de ECDF, D_n e H0, com um diagrama simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para anotações",
                                    "Tabela de valores críticos KS (impressa ou online)"
                                  ],
                                  "tips": "Visualize ECDF como degraus conectando pontos ordenados; compare com linha reta da uniforme.",
                                  "learningObjective": "Dominar os conceitos teóricos essenciais para aplicação do teste KS.",
                                  "commonMistakes": [
                                    "Confundir ECDF com PDF",
                                    "Ignorar que D_n é a máxima diferença absoluta",
                                    "Esquecer de normalizar por n na ECDF"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar e Preparar a Amostra de Dados",
                                  "subSteps": [
                                    "Gere uma amostra de n números pseudoaleatórios supostamente uniformes (ex: n=20 via Python random.uniform).",
                                    "Ordene a amostra em ordem crescente: X_{(1)} ≤ X_{(2)} ≤ ... ≤ X_{(n)}.",
                                    "Transforme para U(0,1) se necessário (já uniforme).",
                                    "Calcule os pontos ECDF: para i=1 a n, F_n(X_{(i)}) = i/n.",
                                    "Crie uma tabela com colunas: i, X_{(i)}, i/n."
                                  ],
                                  "verification": "Verifique se a amostra está ordenada e i/n calculados corretamente em uma tabela.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python com bibliotecas numpy e pandas",
                                    "Editor de código (Jupyter Notebook)"
                                  ],
                                  "tips": "Use np.sort() para ordenar; evite amostras muito pequenas (n<30 pode ser menos poderoso).",
                                  "learningObjective": "Preparar dados ordenados e computar valores ECDF iniciais.",
                                  "commonMistakes": [
                                    "Não ordenar a amostra",
                                    "Usar (i-1)/n em vez de i/n (variações existem, padronize)",
                                    "Incluir valores fora de [0,1] sem truncar"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a Estatística D_n",
                                  "subSteps": [
                                    "Para cada X_{(i)}, calcule |i/n - X_{(i)}| e | (i-1)/n - X_{(i)} | (para máxima precisão em pontos de salto).",
                                    "Encontre D_n como o máximo absoluto entre todos esses valores.",
                                    "Plote ECDF vs CDF teórica para visualização (opcional, mas recomendado).",
                                    "Implemente em código: use loop ou vetorizado com numpy.max(np.abs(np.concatenate(...))).",
                                    "Registre D_n observado."
                                  ],
                                  "verification": "Confirme D_n com cálculo manual para subamostra pequena e código.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python: numpy, matplotlib para plot",
                                    "Tabela de amostra gerada"
                                  ],
                                  "tips": "Verifique saltos da ECDF nos pontos X_{(i)}; D_n ocorre tipicamente ali.",
                                  "learningObjective": "Computar precisamente a máxima diferença D_n entre ECDF e CDF.",
                                  "commonMistakes": [
                                    "Calcular apenas em i/n sem (i-1)/n",
                                    "Não usar supremo (máximo) absoluto",
                                    "Erro de indexação em loops"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Determinar Valor Crítico e Tomar Decisão",
                                  "subSteps": [
                                    "Selecione α (ex: 0.05) e n; consulte tabela KS para c_α,n (ex: para n=20, α=0.05, c≈0.294).",
                                    "Compare: se D_n > c_α,n, rejeite H0 (não uniforme).",
                                    "Calcule p-value aproximado se possível (fórmula assintótica ou scipy.stats.kstest).",
                                    "Interprete: reporte D_n, decisão e implicações para aleatoriedade.",
                                    "Teste com scipy.stats.kstest para validação (dados, 'uniform')."
                                  ],
                                  "verification": "Execute teste em código e compare decisão manual vs. função built-in.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela KS crítica",
                                    "Python scipy.stats",
                                    "Documentação KS"
                                  ],
                                  "tips": "Para grandes n, use aproximação assintótica: D_n * sqrt(n) > 1.36 para α=0.05.",
                                  "learningObjective": "Finalizar o teste com decisão estatística e validação computacional.",
                                  "commonMistakes": [
                                    "Usar valor crítico errado para n ou α",
                                    "Rejeitar H0 incorretamente (D_n ≤ c mantém H0)",
                                    "Ignorar p-value como evidência complementar"
                                  ]
                                }
                              ],
                              "practicalExample": "Gere 20 números uniformes em Python: np.random.uniform(0,1,20). Ordene: [0.12, 0.23, ..., 0.89]. Calcule ECDF: 1/20=0.05, 2/20=0.10, etc. D_n = max(|0.05-0.12|, |0.10-0.23|, ..., |1.0-0.89|) ≈ 0.15. Para n=20, α=0.05, c=0.294; 0.15 < 0.294 → não rejeita H0.",
                              "finalVerifications": [
                                "Calcula corretamente ECDF para amostra dada.",
                                "Identifica D_n preciso com diferenças em saltos.",
                                "Compara adequadamente com valor crítico tabelado.",
                                "Implementa teste em Python com resultados consistentes.",
                                "Interpreta decisão corretamente (rejeitar/manter H0).",
                                "Valida com scipy.stats.kstest."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de D_n (erro <0.01).",
                                "Correta preparação e ordenação da amostra.",
                                "Uso apropriado de tabela crítica ou p-value.",
                                "Clareza na interpretação e relatório.",
                                "Eficiência e correção do código implementado.",
                                "Visualização opcional de ECDF vs CDF."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Testes de hipóteses não-paramétricos.",
                                "Programação: Manipulação de arrays em Python/NumPy.",
                                "Ciência de Dados: Validação de dados simulados.",
                                "Probabilidade: Propriedades de distribuições uniformes."
                              ],
                              "realWorldApplication": "Validar geradores de números aleatórios em criptografia (ex: testes em blockchain), simulações Monte Carlo em finanças (qualidade de cenários), controle de qualidade em manufatura (uniformidade de processos)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.1.3",
                            "name": "Interpretação de Resultados de Uniformidade",
                            "description": "Analisar p-valores e estatísticos de testes de uniformidade para determinar se a sequência é adequada, considerando tamanho da amostra (mínimo 10.000) e múltiplos testes para evitar falsos positivos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Verificar Pré-requisitos dos Dados",
                                  "subSteps": [
                                    "Confirme que o tamanho da amostra n é pelo menos 10.000 observações.",
                                    "Verifique se os dados estão no intervalo [0,1) e sem valores ausentes ou inválidos.",
                                    "Realize uma inspeção visual inicial com histograma ou QQ-plot para uniformidade aparente.",
                                    "Registre estatísticas descritivas básicas (média, variância) e compare com valores teóricos (0.5 e 1/12).",
                                    "Documente qualquer pré-processamento aplicado aos dados."
                                  ],
                                  "verification": "Relatório confirma n >= 10.000, histograma uniforme e estatísticas próximas ao teórico.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Sequência de números aleatórios",
                                    "Software de análise (Python com SciPy/Matplotlib ou R)",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Use log escala para n exato e salve plots para referência futura.",
                                  "learningObjective": "Garantir validade dos dados antes da interpretação para evitar conclusões enviesadas.",
                                  "commonMistakes": [
                                    "Prosseguir com n < 10.000",
                                    "Ignorar outliers ou valores fora de [0,1)",
                                    "Confundir variância teórica (1/12 ≈ 0.0833)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Examinar Estatísticos dos Testes de Uniformidade",
                                  "subSteps": [
                                    "Identifique os testes usados (ex: Kolmogorov-Smirnov (KS), Chi-Quadrado, Anderson-Darling).",
                                    "Registre o valor do estatístico para cada teste (ex: D para KS, χ² para Chi-Quadrado).",
                                    "Compare estatísticos com valores de referência ou tabelas críticas para n dado.",
                                    "Note se o estatístico indica desvio grande (ex: D próximo de 1 sugere não-uniformidade).",
                                    "Crie uma tabela resumindo estatísticos de todos os testes aplicados."
                                  ],
                                  "verification": "Tabela de estatísticos criada e comparada com thresholds esperados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Resultados de testes (output de SciPy.stats.kstest ou equivalente)",
                                    "Tabelas críticas de KS/Chi2",
                                    "Planilha ou Markdown para tabela"
                                  ],
                                  "tips": "Priorize KS para sensibilidade a desvios nas caudas; Chi2 para bins centrais.",
                                  "learningObjective": "Compreender o significado intuitivo dos estatísticos além dos p-valores.",
                                  "commonMistakes": [
                                    "Focar só em p-valores ignorando magnitude do estatístico",
                                    "Usar bins inadequados em Chi2 (regra: >5 por bin esperados)",
                                    "Confundir estatístico com p-valor"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar P-valores Individuais",
                                  "subSteps": [
                                    "Defina nível de significância α padrão (ex: 0.05).",
                                    "Para cada p-valor: se p > α, não rejeite H0 (uniformidade); se p ≤ α, rejeite.",
                                    "Avalie força da evidência: p > 0.1 (boa), 0.05-0.1 (marginal), <0.01 (forte rejeição).",
                                    "Considere poder do teste: para n=10k, poder alto contra desvios moderados.",
                                    "Anote p-valores em ordem crescente para priorizar testes falhos."
                                  ],
                                  "verification": "Lista de interpretações por teste com decisões claras de aceitação/rejeição.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Lista de p-valores dos testes",
                                    "Calculadora ou código para ordenação"
                                  ],
                                  "tips": "Pense em p-valor como probabilidade de dados tão extremos sob H0, não probabilidade de H0.",
                                  "learningObjective": "Aplicar regras de decisão baseadas em p-valores para inferência estatística.",
                                  "commonMistakes": [
                                    "Interpretar p alto como 'provadamente uniforme'",
                                    "Usar α=0.01 sem justificativa",
                                    "Ignorar contexto de n no poder do teste"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Corrigir por Múltiplos Testes e Decidir Adequação",
                                  "subSteps": [
                                    "Conte o número de testes k realizados.",
                                    "Aplique correção (ex: Bonferroni: α_corr = α/k; ou FDR se aplicável).",
                                    "Reavalie p-valores ajustados: rejeite se algum p_adj ≤ α_corr.",
                                    "Decida globalmente: sequência adequada se nenhum teste rejeita após correção.",
                                    "Documente decisão com justificativa e sugestões (ex: refazer geração se falha)."
                                  ],
                                  "verification": "Relatório final com p-ajustados, decisão e raciocínio.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Lista de p-valores",
                                    "Fórmula/código para Bonferroni (p_adj = min(1, p*k))"
                                  ],
                                  "tips": "Bonferroni é conservador; use Holm para menos estrito se k pequeno.",
                                  "learningObjective": "Controlar taxa de falsos positivos em cenários de múltiplos testes.",
                                  "commonMistakes": [
                                    "Esquecer correção levando a falsos positivos",
                                    "Aplicar correção errada (ex: dividir α por n em vez de k)",
                                    "Decidir baseado em um teste só"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar e Comunicar Resultados",
                                  "subSteps": [
                                    "Resuma achados em parágrafo: n, testes, p-valores chave, decisão.",
                                    "Inclua plots/visualizações de suporte (histograma, p-value plot).",
                                    "Discuta limitações (ex: poder contra desvios específicos).",
                                    "Recomende próximos passos se inadequada (nova semente, algoritmo diferente).",
                                    "Salve relatório em formato compartilhável."
                                  ],
                                  "verification": "Relatório completo gerado e compreensível para pares.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Templates de relatório",
                                    "Ferramentas de plotagem",
                                    "Exportador PDF/Markdown"
                                  ],
                                  "tips": "Use linguagem clara: 'Não rejeitamos uniformidade a 5% (p=0.45)' vs jargão.",
                                  "learningObjective": "Comunicar resultados estatísticos de forma profissional e acionável.",
                                  "commonMistakes": [
                                    "Relatório vago sem números",
                                    "Omitir contexto de múltiplos testes",
                                    "Exagerar confiança em p alto"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma sequência de 12.000 números pseudo-aleatórios testada com KS (D=0.015, p=0.28) e Chi2 (χ²=12.3, p=0.42), k=2 testes. α=0.05, Bonferroni α_corr=0.025. Ambos p > 0.025 → sequência adequada para simulações Monte Carlo.",
                              "finalVerifications": [
                                "Explicar corretamente por que n mínimo 10.000 é crucial para poder estatístico.",
                                "Interpretar um p=0.03 com k=4 usando Bonferroni (p_adj=0.12 >0.05/4=0.0125 → OK).",
                                "Identificar falha: KS p=0.01 com n=5.000 (inválido por tamanho).",
                                "Criar tabela resumindo 3 testes com decisão global.",
                                "Discutir risco de falsos positivos sem correção.",
                                "Propor visualização para validar uniformidade visual."
                              ],
                              "assessmentCriteria": [
                                "Precisão na verificação de n >=10.000 e limpeza de dados (20%).",
                                "Correta interpretação de estatísticos e p-valores individuais (25%).",
                                "Aplicação precisa de correção múltipla e decisão final (25%).",
                                "Qualidade da documentação e comunicação (15%).",
                                "Identificação de erros comuns e limitações (10%).",
                                "Uso de exemplos/visualizações relevantes (5%)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística Inferencial: Hipótese nula de uniformidade e controle de erro Tipo I.",
                                "Programação Científica: Implementação de testes em Python/R (SciPy.stats).",
                                "Simulações e Modelagem: Validação de RNG em Monte Carlo e sistemas discretos.",
                                "Probabilidade: Distribuições uniformes contínuas e propriedades teóricas.",
                                "Ciência de Dados: Visualização e múltiplos testes em análise exploratória."
                              ],
                              "realWorldApplication": "Em criptografia, validar geradores de números aleatórios para chaves seguras (ex: AES); em finanças, simulações de risco sem bias; em jogos, geração justa de eventos randômicos; em física computacional, modelagem de partículas sem artefatos estatísticos."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.2.2",
                        "name": "Testes de Independência Sequencial",
                        "description": "Testes que examinam a independência entre números pseudoaleatórios consecutivos, detectando dependências locais que violam a propriedade de aleatoriedade em simulações discretas.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.2.1",
                            "name": "Teste de Corridas (Runs Test)",
                            "description": "Realizar o teste de corridas acima/abaixo da mediana, contando sequências de runs (corridas) de 0s e 1s, calculando Z = (R - μ_R) / σ_R onde μ_R = (2n_0 n_1)/N + 1 e comparando com normal padrão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparação da Sequência de Dados",
                                  "subSteps": [
                                    "Obtenha uma sequência de N números pseudoaleatórios (ex: N=20-50 para prática).",
                                    "Ordene a sequência para calcular a mediana (valor central ou média dos dois centrais se N par).",
                                    "Binarize a sequência: atribua 0 para valores abaixo ou igual à mediana, 1 para valores acima.",
                                    "Conte o número de 0s (n₀) e 1s (n₁), verificando que N = n₀ + n₁.",
                                    "Registre a sequência binária resultante (ex: 0,1,0,0,1,...)."
                                  ],
                                  "verification": "Sequência binária correta com n₀ e n₁ contados precisamente; mediana calculada sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Sequência de números aleatórios (papel ou planilha Excel/Python)",
                                    "Calculadora ou software de planilha"
                                  ],
                                  "tips": [
                                    "Use planilhas para ordenação automática.",
                                    "Evite arredondamentos prematuros na mediana."
                                  ],
                                  "learningObjective": "Compreender e preparar dados para teste de runs, garantindo binarização precisa.",
                                  "commonMistakes": [
                                    "Confundir mediana com média.",
                                    "Incluir o valor da mediana incorretamente como 0 ou 1.",
                                    "Erros de contagem em n₀ e n₁."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificação e Contagem de Runs",
                                  "subSteps": [
                                    "Examine a sequência binária e identifique uma 'run' como sequência consecutiva de 0s ou 1s.",
                                    "Comece contando a primeira run (ex: se inicia com dois 0s, run=1 de 0s).",
                                    "Marque cada mudança de 0 para 1 ou 1 para 0 como início de nova run.",
                                    "Conte o total de runs (R), garantindo que runs isoladas (um único 0 ou 1) sejam contadas como 1.",
                                    "Valide contando manualmente e visualizando a sequência com marcações."
                                  ],
                                  "verification": "Número total de runs (R) coincide com contagem manual e regras de definição.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Sequência binária impressa ou digital",
                                    "Lápis e papel para marcações"
                                  ],
                                  "tips": [
                                    "Desenhe linhas entre runs para visualização.",
                                    "Pratique com sequências curtas primeiro."
                                  ],
                                  "learningObjective": "Dominar a detecção precisa de sequências consecutivas em dados binários.",
                                  "commonMistakes": [
                                    "Não contar runs de comprimento 1.",
                                    "Confundir trocas adjacentes como múltiplas runs.",
                                    "Ignorar o início ou fim da sequência."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Cálculo das Estatísticas Esperadas μ_R e σ_R",
                                  "subSteps": [
                                    "Calcule N = n₀ + n₁ (total de observações).",
                                    "Compute μ_R = (2 * n₀ * n₁ / N) + 1 (média esperada de runs).",
                                    "Calcule σ_R = √[ (2 * n₀ * n₁ * (2 * n₀ * n₁ - N)) / (N² * (N - 1)) ] (desvio padrão).",
                                    "Verifique condições: n₀, n₁ ≥ 10 para aproximação normal ser válida.",
                                    "Registre valores com precisão decimal (ex: 4 casas)."
                                  ],
                                  "verification": "Fórmulas aplicadas corretamente, com σ_R positiva e valores condizentes com N.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Planilha Excel ou Python para fórmulas"
                                  ],
                                  "tips": [
                                    "Implemente fórmulas em células de planilha para reutilização.",
                                    "Confira divisão por (N-1) no denominador de σ_R."
                                  ],
                                  "learningObjective": "Aplicar fórmulas estatísticas paramétricas para testes de aleatoriedade.",
                                  "commonMistakes": [
                                    "Esquecer o '+1' em μ_R.",
                                    "Erro no radicando de σ_R (falta de parênteses).",
                                    "Usar N em vez de N² no denominador."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Cálculo do Estatístico Z e Comparação com Normal Padrão",
                                  "subSteps": [
                                    "Calcule Z = (R - μ_R) / σ_R.",
                                    "Determine nível de significância α (ex: 0.05) e valores críticos da normal padrão (±1.96 para bilateral).",
                                    "Compare |Z| com valor crítico: se |Z| > crítico, rejeite H₀ (não aleatória).",
                                    "Calcule p-valor aproximado usando tabela Z ou software.",
                                    "Anote decisão: aceitar ou rejeitar independência sequencial."
                                  ],
                                  "verification": "Z calculado corretamente e decisão de hipótese alinhada com comparação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de normal padrão",
                                    "Software como Python (scipy.stats.norm) ou Excel"
                                  ],
                                  "tips": [
                                    "Use função NORM.S.INV no Excel para críticos.",
                                    "Sempre verifique σ_R ≠ 0."
                                  ],
                                  "learningObjective": "Executar teste de hipótese usando aproximação normal para runs test.",
                                  "commonMistakes": [
                                    "Dividir por σ_R zero ou negativa.",
                                    "Confundir teste unilateral/bilateral.",
                                    "Ignorar aproximação normal (n₀,n₁ <10)."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretação e Relatório dos Resultados",
                                  "subSteps": [
                                    "Resuma: sequência, R, μ_R, σ_R, Z, decisão e p-valor.",
                                    "Discuta implicações: se falha, sugere dependência sequencial.",
                                    "Compare com outros testes de aleatoriedade (ex: poker test).",
                                    "Gere relatório curto com gráficos (sequência binária plotada).",
                                    "Teste com nova sequência para validação prática."
                                  ],
                                  "verification": "Relatório completo, lógico e com conclusões corretas baseadas em cálculos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta de plotagem (Python matplotlib ou Excel)",
                                    "Modelo de relatório"
                                  ],
                                  "tips": [
                                    "Inclua visual de runs para clareza.",
                                    "Explique limitações do teste."
                                  ],
                                  "learningObjective": "Interpretar resultados estatísticos no contexto de aleatoriedade.",
                                  "commonMistakes": [
                                    "Concluir aleatoriedade sem verificar condições.",
                                    "Omitir p-valor ou gráfico.",
                                    "Generalizar falha para todo gerador."
                                  ]
                                }
                              ],
                              "practicalExample": "Sequência: [0.23, 0.45, 0.12, 0.67, 0.34, 0.89, 0.56, 0.78, 0.11, 0.92]. Mediana: 0.56. Binária: [0,0,0,1,0,1,1,1,0,1]. Runs: 0s(3),1(1),0(1),1(2),0(1),1(1) → R=6. n₀=5, n₁=5, N=10. μ_R=(2*5*5/10)+1=6. σ_R=√[(2*5*5*(50-10))/(100*9)]≈1.82. Z=(6-6)/1.82=0. Não rejeita H₀ (aleatória).",
                              "finalVerifications": [
                                "Binarização e contagem de runs precisa para sequências de 20+ itens.",
                                "Cálculos de μ_R, σ_R e Z sem erros aritméticos.",
                                "Decisão de hipótese correta com α=0.05.",
                                "Relatório inclui interpretação e limitações.",
                                "Aplicação bem-sucedida em pelo menos 3 sequências diferentes.",
                                "Condições do teste (n₀,n₁≥10) verificadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos (erro <1% em Z).",
                                "Completude da binarização e contagem de runs.",
                                "Correta aplicação de fórmulas paramétricas.",
                                "Interpretação contextualizada e sem ambiguidades.",
                                "Uso eficiente de ferramentas e verificações.",
                                "Criatividade em exemplos práticos e relatórios."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Testes de hipótese e aproximações normais.",
                                "Programação: Implementação em Python/R para automação.",
                                "Probabilidade: Modelos de sequências binárias independentes.",
                                "Ciência de Dados: Validação de dados em machine learning.",
                                "Criptografia: Testes de RNG para segurança."
                              ],
                              "realWorldApplication": "Em criptografia para validar geradores de números aleatórios (ex: /dev/random no Linux); simulações Monte Carlo em finanças; controle de qualidade em manufatura para detectar padrões não aleatórios em processos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.2.2",
                            "name": "Teste de Poker",
                            "description": "Aplicar o teste de poker agrupando dígitos em mãos de 5 cartas (0-9), calculando probabilidades para padrões como pares, sequências, etc., e usando qui-quadrado para testar desvios das probabilidades teóricas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as categorias de mãos de poker e probabilidades teóricas",
                                  "subSteps": [
                                    "Liste as 10 categorias padrão do teste de poker: (1) Cinco iguais, (2) Quadra, (3) Full house (3+2), (4) Trinca (3 iguais + 2 distintos), (5) Dois pares + 1 distinto, (6) Um par + 3 distintos, (7) Todas distintas, (8) Straight (sequência consecutiva de 5 dígitos), (9) Straight com par (sequência com repetição parcial), (10) Outros padrões raros.",
                                    "Aprenda o procedimento de classificação: ordene os 5 dígitos e analise as frequências e ordem.",
                                    "Memorize ou derive as probabilidades teóricas aproximadas: ex. um par ~0.3024, dois pares ~0.1512, trinca ~0.091, full house ~0.0095, quadra ~0.009, cinco iguais ~0.001, straight ~0.0105, etc. (totalizando 1).",
                                    "Calcule frequências esperadas para uma sequência de N mãos: E_i = N * p_i.",
                                    "Pratique classificando 5 mãos de exemplo manualmente."
                                  ],
                                  "verification": "Classifique corretamente 10 mãos de 5 dígitos aleatórios fornecidas, com 100% de acerto.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Tabela de probabilidades do teste de poker (impressa ou digital)",
                                    "Papel e caneta para anotações",
                                    "Calculadora"
                                  ],
                                  "tips": "Sempre ordene os dígitos em ordem crescente antes de classificar para facilitar a identificação de padrões.",
                                  "learningObjective": "Dominar as 10 categorias de mãos e calcular frequências esperadas baseadas em probabilidades teóricas.",
                                  "commonMistakes": [
                                    "Confundir full house (3+2) com trinca + par separado",
                                    "Ignorar straights ao focar só em repetições",
                                    "Usar probabilidades erradas de poker com naipes reais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar a sequência de números pseudo-aleatórios",
                                  "subSteps": [
                                    "Gere ou obtenha uma longa sequência de dígitos (0-9), com pelo menos 20.000 dígitos para 4.000 mãos.",
                                    "Use um gerador de números aleatórios (ex: random module em Python, ou Excel RAND*10).",
                                    "Verifique se a sequência tem comprimento múltiplo de 5.",
                                    "Salve a sequência em arquivo texto ou array para processamento.",
                                    "Documente a fonte do gerador (ex: linear congruential generator)."
                                  ],
                                  "verification": "Confirme que a sequência tem N dígitos, com N/5 mãos, e visualize os primeiros 50 dígitos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python ou Excel com funções RAND",
                                    "Editor de texto para salvar sequência"
                                  ],
                                  "tips": "Teste com sequências curtas primeiro para depuração antes de gerar longa.",
                                  "learningObjective": "Gerar sequências candidatas a aleatórias adequadas para testes estatísticos.",
                                  "commonMistakes": [
                                    "Gerar sequências curtas insuficientes para teste qui-quadrado",
                                    "Incluir dígitos fora de 0-9",
                                    "Usar geradores não-uniformes sem testar"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Dividir a sequência em mãos e classificar cada uma",
                                  "subSteps": [
                                    "Divida a sequência em grupos consecutivos de 5 dígitos (mãos sobrepostas ou não, conforme padrão: geralmente não sobrepostas).",
                                    "Para cada mão, ordene os dígitos e identifique a categoria baseada nas regras.",
                                    "Implemente uma função de classificação (manual para poucas, código para muitas).",
                                    "Registre a categoria de cada mão em uma lista ou contador inicial.",
                                    "Valide com 10 mãos manuais vs. código."
                                  ],
                                  "verification": "Classifique 50 mãos iniciais manualmente e compare com implementação automatizada (acordo >95%).",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Código Python ou pseudocódigo para classificador",
                                    "Sequência gerada do step 2"
                                  ],
                                  "tips": "Escreva uma função que retorna um inteiro 1-10 para cada categoria para facilitar contagem.",
                                  "learningObjective": "Implementar logicamente a classificação de mãos de poker para grandes volumes de dados.",
                                  "commonMistakes": [
                                    "Sobrepor mãos incorretamente (use stride=5)",
                                    "Erro em lógica de straight: verifique diferenças consecutivas ==1 após ordenar",
                                    "Classificações ambíguas sem ordenação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Contar frequências observadas e preparar tabela de contingência",
                                  "subSteps": [
                                    "Conte o número de ocorrências O_i para cada uma das 10 categorias.",
                                    "Crie uma tabela com O_i, E_i = N*p_i, onde N é número de mãos.",
                                    "Verifique que soma O_i = N e soma E_i ≈ N.",
                                    "Calcule contribuições parciais (O_i - E_i)^2 / E_i para cada i.",
                                    "Identifique categorias com desvios grandes visualmente."
                                  ],
                                  "verification": "Tabela de contingência balanceada com somas corretas e sem erros de contagem.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Excel ou array NumPy em Python",
                                    "Tabela de p_i do step 1"
                                  ],
                                  "tips": "Use dicionário ou array de contadores para eficiência em código.",
                                  "learningObjective": "Construir tabela de contingência para teste de bondade de ajuste.",
                                  "commonMistakes": [
                                    "Arredondar E_i incorretamente (use float)",
                                    "Esquecer categorias raras com E_i baixo",
                                    "Somar O_i errado por off-by-one"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Calcular estatística qui-quadrado e interpretar resultados",
                                  "subSteps": [
                                    "Some as contribuições: χ² = Σ (O_i - E_i)^2 / E_i para i=1 a 10.",
                                    "Determine graus de liberdade (df=10-1=9, ou ajustado se probs estimadas).",
                                    "Calcule p-valor usando distribuição qui-quadrado (tabela ou função scipy.stats.chi2.sf).",
                                    "Interprete: p > 0.01 aceita aleatoriedade; rejeita se pequeno.",
                                    "Repita teste com outra sequência para comparação."
                                  ],
                                  "verification": "χ² calculado manual vs. código coincide, e interpretação escrita corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Tabela qui-quadrado df=9",
                                    "Python com scipy.stats ou calculadora estatística"
                                  ],
                                  "tips": "Para E_i <5 em categorias raras, agrupe-as em 'outros' e ajuste df.",
                                  "learningObjective": "Aplicar teste qui-quadrado para validar hipóteses de aleatoriedade.",
                                  "commonMistakes": [
                                    "Usar df errado (não subtrair 1 por categoria)",
                                    "Interpretar p-valor como probabilidade de aleatoriedade ao invés de não-rejeição",
                                    "Ignorar aproximações para amostras finitas"
                                  ]
                                }
                              ],
                              "practicalExample": "Gere sequência de 5000 dígitos com Python: ''.join(str(random.randint(0,9)) for _ in range(5000)). Divida em 1000 mãos. Exemplo primeiras mãos: '12345' -> straight (cat.8), '67890' -> straight (cat.8), '11234' -> one pair (cat.6). Contagens: O = [0,1,0,2,0,50,800,120,25,2] (exemplo fictício). E_i = 1000 * p_i. χ² ≈ 12.5, df=9, p=0.19 -> passa o teste.",
                              "finalVerifications": [
                                "Classifica corretamente 20 mãos aleatórias em <2 minutos.",
                                "Calcula E_i e χ² para dataset de 1000 mãos sem erros.",
                                "Implementa código completo funcional em Python.",
                                "Interpreta p-valor corretamente para 3 cenários (passa/falha/borderline).",
                                "Compara resultados de dois geradores diferentes.",
                                "Explica limitações do teste (ex: detecta dependências locais)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na classificação de mãos: 95%+",
                                "Correção matemática em χ² e p-valor: erro <1%",
                                "Eficiência da implementação computacional: processa 10k mãos em <10s",
                                "Profundidade da interpretação: inclui df, aproximações e conclusões",
                                "Documentação clara do processo e código",
                                "Criatividade em testes adicionais (ex: sequências não-aleatórias)"
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Teste qui-quadrado de bondade de ajuste",
                                "Probabilidade: Cálculo de distribuições multinomiais",
                                "Programação: Algoritmos de classificação e loops eficientes",
                                "Ciência da Computação: Validação de PRNGs",
                                "Matemática Discreta: Combinatória de multisets"
                              ],
                              "realWorldApplication": "Testar geradores de números pseudo-aleatórios (PRNGs) em criptografia (chaves seguras), simulações Monte Carlo (finanças, física), jogos de azar online (fairness de slots/poker virtual), e auditorias de software de cassinos para garantir independência sequencial."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.2.3",
                        "name": "Testes de Padrões e Ciclos",
                        "description": "Testes avançados para detectar padrões periódicos, autocorrelações em lags ou ciclos em sequências longas de números pseudoaleatórios, cruciais para simulações de sistemas discretos com alto volume de amostras.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.3.1",
                            "name": "Teste de Séries (Serial Test)",
                            "description": "Executar o teste serial considerando pares consecutivos (u_i, u_{i+1}) em uma grade 10x10, testando uniformidade bidimensional via qui-quadrado para independência em lags de 1.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais do Teste Serial",
                                  "subSteps": [
                                    "Estude a definição do teste serial: análise de pares consecutivos (u_i, u_{i+1}) para verificar independência em lags de 1.",
                                    "Revise a uniformidade bidimensional em uma grade 10x10, onde cada u é mapeado para decil (0-9).",
                                    "Entenda o teste qui-quadrado para independência: H0 (pares independentes) vs. H1 (dependentes).",
                                    "Aprenda a fórmula do qui-quadrado: χ² = Σ (O_ij - E_ij)² / E_ij, com E_ij = n/100.",
                                    "Conheça graus de liberdade (90) e valores críticos para α=0.05."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o propósito do teste e a hipótese nula.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação sobre testes de aleatoriedade (Marsaglia ou Knuth)",
                                    "Tabela de distribuição qui-quadrado"
                                  ],
                                  "tips": "Visualize a grade 10x10 como uma matriz de transições de dígitos decimais.",
                                  "learningObjective": "Dominar os fundamentos teóricos do teste serial e qui-quadrado para independência.",
                                  "commonMistakes": [
                                    "Confundir lag 1 com outros lags",
                                    "Ignorar a discretização em 10 intervalos iguais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar e Discretizar a Sequência de Números Pseudo-Aleatórios",
                                  "subSteps": [
                                    "Gere ou obtenha uma sequência longa de U[0,1] com pelo menos 10.000 pontos (ideal: 100.000).",
                                    "Discretize cada u_i em d_i = floor(10 * u_i), resultando em valores de 0 a 9.",
                                    "Forme pares consecutivos (d_i, d_{i+1}) para i=1 até n-1.",
                                    "Conte o número total de pares: m = n-1.",
                                    "Verifique se não há valores fora de 0-9."
                                  ],
                                  "verification": "Produza uma lista de 100 pares discretizados e confirme contagens uniformes aproximadas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software de programação (Python com NumPy ou R)",
                                    "Gerador de RNG (ex: Mersenne Twister)"
                                  ],
                                  "tips": "Use funções vetorizadas para eficiência em sequências grandes.",
                                  "learningObjective": "Preparar dados adequadamente para análise bidimensional.",
                                  "commonMistakes": [
                                    "Incluir u_n sem par",
                                    "Arredondamento incorreto levando a >9"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a Tabela de Contingência 10x10 e Calcular Frequências Observadas",
                                  "subSteps": [
                                    "Inicialize uma matriz 10x10 zerada para frequências observadas O_ij.",
                                    "Para cada par (d_i, d_{i+1}), incremente O[d_i][d_{i+1}].",
                                    "Calcule frequências esperadas E_ij = m / 100 para cada célula.",
                                    "Verifique soma de O_ij = m e soma de linhas/colunas ≈ m/10.",
                                    "Identifique células com O_ij <5 para considerar correções (se necessário)."
                                  ],
                                  "verification": "Exiba a matriz 10x10 com somas marginais corretas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Planilha Excel ou Jupyter Notebook",
                                    "Biblioteca Pandas/Matplotlib para visualização"
                                  ],
                                  "tips": "Plote um heatmap da matriz para detectar padrões visuais.",
                                  "learningObjective": "Construir empiricamente a distribuição conjunta de pares.",
                                  "commonMistakes": [
                                    "Índices errados na matriz (linhas vs. colunas)",
                                    "Esquecer de subtrair 1 no total de pares"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular o Estatístico Qui-Quadrado, Interpretar e Concluir",
                                  "subSteps": [
                                    "Compute χ² = Σ_{i=0}^9 Σ_{j=0}^9 (O_ij - E_ij)² / E_ij.",
                                    "Ignore células com E_ij <5 ou aplique correção Yates se aplicável.",
                                    "Compare χ² com valor crítico qui-quadrado(90, 0.05) ≈ 123.225.",
                                    "Decida: se χ² > crítico, rejeite H0 (não aleatório); senão, aceite.",
                                    "Calcule p-valor usando função qui-quadrado CDF para precisão."
                                  ],
                                  "verification": "Forneça χ², p-valor e conclusão para um exemplo dado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Tabela qui-quadrado ou função scipy.stats.chi2",
                                    "Calculadora ou código"
                                  ],
                                  "tips": "Automatize o cálculo em loop duplo para evitar erros manuais.",
                                  "learningObjective": "Executar o teste completo e interpretar resultados estatísticos.",
                                  "commonMistakes": [
                                    "Usar gl=100 em vez de 81 ou 90",
                                    "Confundir rejeição com aceitação"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Implementar o Teste Serial em Código e Validar",
                                  "subSteps": [
                                    "Escreva uma função em Python/R que receba sequência U e retorne χ², p-valor e conclusão.",
                                    "Teste com sequência conhecida aleatória (deve passar) e não-aleatória (falhar).",
                                    "Gere relatório com matriz, χ² e visualizações.",
                                    "Compare resultados com bibliotecas padrão (ex: NIST STS).",
                                    "Otimize para sequências muito longas."
                                  ],
                                  "verification": "Execute o código em duas sequências e produza relatório correto.",
                                  "estimatedTime": "1,5 horas",
                                  "materials": [
                                    "Python (numpy, scipy, matplotlib)",
                                    "Exemplos de sequências de teste (NIST)"
                                  ],
                                  "tips": "Use np.histogram2d para construção rápida da matriz.",
                                  "learningObjective": "Automatizar o teste para uso prático em simulações.",
                                  "commonMistakes": [
                                    "Overflow em somas para n muito grande",
                                    "Erro em normalização de U"
                                  ]
                                }
                              ],
                              "practicalExample": "Gere sequência U = [0.1, 0.23, 0.45, 0.67, 0.89, 0.12, ...] (n=1001). Discretize: pares como (1,2), (2,4), etc. Construa matriz 10x10, calcule χ² ≈ 95.3 (p>0.05), conclua: aleatório.",
                              "finalVerifications": [
                                "Explica corretamente a discretização e formação de pares.",
                                "Constrói matriz 10x10 sem erros para sequência de 5000 pontos.",
                                "Calcula χ² preciso e compara com crítico.",
                                "Implementa código funcional que passa em testes conhecidos.",
                                "Interpreta resultados em contexto de aleatoriedade.",
                                "Identifica padrões não-aleatórios em sequências enviesadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de χ² (erro <1%).",
                                "Correta interpretação de p-valor e decisão.",
                                "Eficiência e legibilidade do código implementado.",
                                "Visualizações claras da matriz de contingência.",
                                "Tratamento de edge cases (sequências curtas ou enviesadas).",
                                "Conexão teórica com independência de lags."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Testes qui-quadrado de independência e bondade de ajuste.",
                                "Programação: Manipulação de arrays multidimensionais e funções estatísticas.",
                                "Probabilidade: Distribuição uniforme bidimensional e Markov chains.",
                                "Criptografia: Validação de PRNGs para chaves seguras.",
                                "Simulação Computacional: Qualidade de amostras em Monte Carlo."
                              ],
                              "realWorldApplication": "Validar geradores de números pseudo-aleatórios em simulações financeiras (Monte Carlo), jogos de azar, criptomoedas e testes de software de segurança (NIST STS suite)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.3.2",
                            "name": "Teste de Autocorrelação",
                            "description": "Calcular o coeficiente de autocorrelação em lag k como r_k = [Σ (u_i - μ)(u_{i+k} - μ)] / [Σ (u_i - μ)²], testando se |r_k| < 2/√N para independência em múltiplos lags.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a Sequência de Dados e Calcular a Média",
                                  "subSteps": [
                                    "Obtenha uma sequência de números pseudoaleatórios u_1, u_2, ..., u_N com N ≥ 50 para confiabilidade.",
                                    "Calcule a média amostral μ = (1/N) Σ u_i de i=1 a N.",
                                    "Compute os desvios centrados d_i = u_i - μ para cada i.",
                                    "Verifique se a soma dos desvios é aproximadamente zero (erro numérico aceitável).",
                                    "Armazene os desvios em uma lista ou array para uso posterior."
                                  ],
                                  "verification": "Confirme que μ está correto comparando com cálculo manual de subamostra e que soma(d_i) ≈ 0.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Sequência de números aleatórios (gerada via Python/R/Excel)",
                                    "Calculadora ou software (NumPy, Excel)"
                                  ],
                                  "tips": "Use funções built-in como np.mean() no Python para precisão; arredonde μ para 4 casas decimais.",
                                  "learningObjective": "Compreender e calcular estatísticas descritivas básicas para preparar dados em testes de autocorrelação.",
                                  "commonMistakes": [
                                    "Esquecer de centralizar os dados (subtrair μ)",
                                    "Usar N pequeno (<30), levando a testes instáveis",
                                    "Confundir média populacional com amostral"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o Coeficiente de Autocorrelação r_k para Lag k Específico",
                                  "subSteps": [
                                    "Escolha um lag k (ex: k=1) com k < N/2.",
                                    "Compute o numerador: Σ (d_i * d_{i+k}) para i=1 a N-k.",
                                    "Compute o denominador: Σ d_i² para i=1 a N.",
                                    "Calcule r_k = numerador / denominador.",
                                    "Repita para validar com k=0 (deve ser ≈1)."
                                  ],
                                  "verification": "Verifique se r_0 ≈ 1 e |r_k| ≤ 1; compare com função autocorr() em software.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Lista de desvios d_i",
                                    "Software de cálculo (Python: numpy.corrcoef, Excel fórmulas)"
                                  ],
                                  "tips": "Implemente em loop para evitar erros de indexação; normalize dividindo por N ou N-k conforme convenção.",
                                  "learningObjective": "Dominar o cálculo exato da fórmula de autocorrelação para um lag único.",
                                  "commonMistakes": [
                                    "Usar soma de N em vez de N-k no numerador",
                                    "Não centralizar antes (r_k enviesado)",
                                    "Dividir por variância em vez de soma de quadrados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar Teste de Significância para Múltiplos Lags",
                                  "subSteps": [
                                    "Calcule r_k para lags k=1 a m, onde m ≈ N/4.",
                                    "Para cada k, compute o limite crítico 2/√N.",
                                    "Teste se |r_k| < 2/√N para cada k.",
                                    "Conte o número de falhas (lags onde |r_k| ≥ 2/√N).",
                                    "Registre resultados em tabela: k, r_k, limite, passa/falha."
                                  ],
                                  "verification": "Tabela completa sem erros aritméticos; pelo menos 80% dos lags passam para RNG bom.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Resultados de r_k de steps anteriores",
                                    "Planilha para tabela (Excel/Google Sheets)",
                                    "Script Python para automação"
                                  ],
                                  "tips": "Use √N exato (np.sqrt(N)); plote r_k vs k para visualização intuitiva.",
                                  "learningObjective": "Aplicar critério de independência em múltiplos lags para avaliar aleatoriedade.",
                                  "commonMistakes": [
                                    "Usar 1/√N em vez de 2/√N",
                                    "Testar lags muito altos (k próximo a N)",
                                    "Ignorar que falhas isoladas podem ocorrer por acaso"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Resultados e Concluir sobre Independência",
                                  "subSteps": [
                                    "Analise a proporção de lags que falham (<5-10% esperado).",
                                    "Discuta implicações: autocorrelação indica padrões/ciclos no gerador.",
                                    "Compare com sequências conhecidas (aleatória vs. linear congruente ruim).",
                                    "Documente conclusão: 'Independente' se poucas falhas.",
                                    "Sugira melhorias se falhar (novo seed ou algoritmo)."
                                  ],
                                  "verification": "Relatório escrito com tabela, gráfico e conclusão justificada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de testes",
                                    "Ferramenta de plotagem (Matplotlib, Excel charts)"
                                  ],
                                  "tips": "Gráfico de autocorrelação (ACF plot) facilita interpretação visual.",
                                  "learningObjective": "Interpretar testes estatísticos no contexto de validação de RNG.",
                                  "commonMistakes": [
                                    "Concluir falha por uma única violação",
                                    "Não considerar tamanho de N no limite",
                                    "Confundir autocorrelação com não-estacionaridade"
                                  ]
                                }
                              ],
                              "practicalExample": "Gere 100 números uniformes [0,1] com Python (np.random.uniform). Calcule μ ≈0.5, r_1 ≈0.02 < 2/√100=0.2 (passa); teste lags 1-20, confirme <5 falhas para aleatoriedade.",
                              "finalVerifications": [
                                "Fórmula de r_k implementada corretamente sem erros numéricos.",
                                "Limite 2/√N calculado para todos lags testados.",
                                "Tabela de resultados completa com pelo menos 10 lags.",
                                "Proporção de falhas <10% em sequência aleatória boa.",
                                "Gráfico ACF mostra decay rápido para zero.",
                                "Conclusão escrita justifica independência ou detecta padrões."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de r_k (erro <0.01).",
                                "Correta aplicação do teste |r_k| < 2/√N em múltiplos lags.",
                                "Interpretação estatística adequada (p-valor implícito).",
                                "Uso eficiente de ferramentas computacionais.",
                                "Identificação de padrões em sequências não-aleatórias.",
                                "Relatório claro com visualizações."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Séries temporais e testes de hipóteses.",
                                "Programação: Implementação numérica em Python/R (loops, arrays).",
                                "Finanças: Detecção de autocorrelação em retornos de ativos.",
                                "Física: Validação de simulações Monte Carlo.",
                                "Ciência de Dados: Pré-processamento para ML (testar independência de features)."
                              ],
                              "realWorldApplication": "Em criptografia e jogos, testa geradores de números aleatórios para evitar padrões previsíveis; em finanças, verifica independência de resíduos em modelos ARIMA para previsões confiáveis."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.3.3",
                            "name": "Bateria de Testes e Validação Geral",
                            "description": "Implementar e interpretar uma suíte de testes (ex: Diehard ou NIST) para validar geradores pseudoaleatórios, considerando tamanho de sequência, poder dos testes e critérios de aceitação para uso em simulações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Pesquisa e Seleção da Bateria de Testes Adequada",
                                  "subSteps": [
                                    "Estude as principais baterias de testes para RNGs: NIST STS, Dieharder e TestU01.",
                                    "Compare critérios como cobertura de testes (padrões, ciclos, independência), tamanho mínimo de sequência e poder estatístico.",
                                    "Selecione uma suíte baseada no contexto (ex: NIST para criptografia, Dieharder para simulações gerais).",
                                    "Revise documentação oficial e papers acadêmicos sobre critérios de aceitação (p-valores > 0.01).",
                                    "Defina parâmetros iniciais: comprimento da sequência (mínimo 10^6 bits) e número de testes."
                                  ],
                                  "verification": "Crie um relatório de 1 página resumindo a seleção, com tabela comparativa e justificativa.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Documentação NIST STS (nist.gov)",
                                    "Dieharder manual (web.math.pbs.org)",
                                    "Python/Jupyter Notebook"
                                  ],
                                  "tips": "Priorize suítes open-source para facilitar implementação; comece com NIST por ser padrão em simulações.",
                                  "learningObjective": "Compreender as diferenças entre baterias de testes e selecionar a apropriada para validação de RNGs.",
                                  "commonMistakes": [
                                    "Ignorar requisitos de tamanho de sequência",
                                    "Escolher suíte sem considerar poder dos testes",
                                    "Não verificar compatibilidade com o RNG"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configuração do Gerador Pseudoaleatório e Geração de Sequências",
                                  "subSteps": [
                                    "Implemente ou importe um PRNG (ex: Mersenne Twister via NumPy random ou PCG).",
                                    "Gere sequências binárias ou de inteiros conforme exigido pela suíte (ex: 10^7 bits para NIST).",
                                    "Salve sequências em formato compatível (txt ou binário).",
                                    "Teste integridade da sequência com checksums básicos (ex: soma modular).",
                                    "Documente semente, parâmetros e versão do PRNG."
                                  ],
                                  "verification": "Execute script para gerar e validar sequência; confirme tamanho e ausência de padrões óbvios via plot.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Python 3.x",
                                    "NumPy/SciPy",
                                    "Biblioteca PCG ou Mersenne Twister"
                                  ],
                                  "tips": "Use seeds fixas para reprodutibilidade; gere múltiplas sequências para testes paralelos.",
                                  "learningObjective": "Configurar e preparar dados de entrada robustos para testes de aleatoriedade.",
                                  "commonMistakes": [
                                    "Sequências curtas insuficientes",
                                    "Formato de arquivo incompatível",
                                    "Não fixar semente para debug"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementação e Execução da Suíte de Testes",
                                  "subSteps": [
                                    "Instale a suíte selecionada (ex: pip install dieharder ou clone NIST STS).",
                                    "Configure parâmetros: número de amostras, testes específicos (foco em padrões e ciclos).",
                                    "Execute a bateria completa em batch mode no terminal ou script.",
                                    "Registre logs de saída, incluindo p-valores para cada teste.",
                                    "Repita execução com diferentes seeds para estatística agregada."
                                  ],
                                  "verification": "Obtenha relatório de saída com todos p-valores; nenhum teste falha criticamente.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": [
                                    "Dieharder/NIST STS suite",
                                    "Terminal/Linux ou WSL",
                                    "Sequências geradas no step 2"
                                  ],
                                  "tips": "Monitore uso de CPU/memória para sequências longas; use --list para ver testes disponíveis.",
                                  "learningObjective": "Executar suítes de testes de forma automatizada e eficiente.",
                                  "commonMistakes": [
                                    "Instalação falha por dependências",
                                    "Ignorar warnings de input inválido",
                                    "Executar testes isolados sem bateria completa"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Análise e Interpretação dos Resultados",
                                  "subSteps": [
                                    "Colete p-valores e estatísticas (média, desvios, falhas).",
                                    "Aplique critérios de aceitação: >95% testes passam (p > 0.01), sem falhas em testes críticos.",
                                    "Visualize resultados com histogramas de p-valores (uniformidade esperada).",
                                    "Avalie poder dos testes para padrões/ciclos (ex: runs test, serial correlation).",
                                    "Compare com benchmarks de PRNGs conhecidos (ex: resultados públicos de MT19937)."
                                  ],
                                  "verification": "Gere gráfico e tabela de p-valores; interprete se PRNG é aceitável para simulações.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Matplotlib/Seaborn para plots",
                                    "Pandas para análise de logs",
                                    "Excel ou Jupyter"
                                  ],
                                  "tips": "p-valores uniformes [0,1] indicam boa aleatoriedade; outliers isolados ok, clusters não.",
                                  "learningObjective": "Interpretar métricas estatísticas para validar qualidade de RNGs.",
                                  "commonMistakes": [
                                    "Confundir p-valor baixo com falha sempre",
                                    "Não normalizar múltiplos testes (Bonferroni)",
                                    "Ignorar testes de padrões/ciclos"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validação Geral, Relatório e Decisão de Aceitação",
                                  "subSteps": [
                                    "Sintetize achados: taxa de aprovação, forças/fraquezas.",
                                    "Defina thresholds para uso em simulações (ex: >99% pass para crítica).",
                                    "Teste em cenário simulado (ex: Monte Carlo com o PRNG).",
                                    "Escreva relatório com recomendações (aceitar/rejeitar/iterar).",
                                    "Arquive código, dados e resultados para reprodutibilidade."
                                  ],
                                  "verification": "Relatório final com decisão clara e evidências; simulação confirma performance.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Template de relatório LaTeX/Markdown",
                                    "Código de simulação simples"
                                  ],
                                  "tips": "Considere custo computacional vs. qualidade; valide contra RNGs certificados.",
                                  "learningObjective": "Tomar decisões baseadas em evidências para deployment de RNGs.",
                                  "commonMistakes": [
                                    "Decisão subjetiva sem thresholds",
                                    "Não testar em aplicação real",
                                    "Relatório incompleto"
                                  ]
                                }
                              ],
                              "practicalExample": "Teste o PRNG Mersenne Twister (NumPy) com NIST STS: gere 10^7 bits, execute 15 testes (foco em frequency, runs, cycles), analise p-valores (todos >0.01), visualize uniformidade e conclua aceitável para simulação de Monte Carlo em finanças.",
                              "finalVerifications": [
                                "Relatório completo com seleção, execução, análise e decisão.",
                                "Todos p-valores documentados e plots de uniformidade.",
                                "Código reprodutível gera mesmos resultados.",
                                "Simulação prática confirma ausência de bias.",
                                "Comparação com benchmarks públicos.",
                                "Thresholds de aceitação explicitados e aplicados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na seleção e configuração da suíte (30%).",
                                "Qualidade da execução e dados gerados (20%).",
                                "Profundidade da interpretação estatística (25%).",
                                "Clareza do relatório e visualizações (15%).",
                                "Decisão justificada com aplicação real (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Análise de p-valores e testes de hipóteses.",
                                "Programação: Automatização de pipelines em Python/C.",
                                "Criptografia: Validação para chaves e protocolos seguros.",
                                "Simulações Computacionais: Uso em Monte Carlo e modelagem.",
                                "Ciência de Dados: Visualização e análise de grandes datasets."
                              ],
                              "realWorldApplication": "Em simulações científicas (ex: física de partículas no CERN), finanças (modelos de risco Monte Carlo) e jogos (geração procedural), garantindo RNGs passem testes para evitar bias em resultados críticos, prevenindo erros caros ou falhas de segurança."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.3",
                    "name": "Geração de Variáveis Aleatórias Contínuas",
                    "description": "Técnicas como método da inversa transformada e método de rejeição para obter amostras de distribuições contínuas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.3.1",
                        "name": "Método da Inversa Transformada",
                        "description": "Técnica que utiliza a função de distribuição cumulativa (FDC) inversa para gerar variáveis aleatórias contínuas a partir de números aleatórios uniformes no intervalo [0,1].",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.1.1",
                            "name": "Entender o princípio do método da inversa transformada",
                            "description": "Compreender que se U ~ Uniforme(0,1), então X = F^{-1}(U) segue a distribuição com FDC F, incluindo prova matemática básica e condições de aplicabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de Distribuição Uniforme e Função de Distribuição Cumulativa (FDC)",
                                  "subSteps": [
                                    "Defina a distribuição uniforme U ~ Uniform(0,1) e suas propriedades principais (densidade constante entre 0 e 1).",
                                    "Explique o que é uma Função de Distribuição Cumulativa (FDC) F(x) = P(X ≤ x) para uma variável aleatória contínua X.",
                                    "Discuta propriedades da FDC: não-decrescente, F(-∞)=0, F(∞)=1, contínua e diferenciável onde a densidade existe.",
                                    "Ilustre com gráficos simples: densidade uniforme vs. FDC linear (F(u)=u para U).",
                                    "Pratique calculando F(u) para distribuições comuns como exponencial."
                                  ],
                                  "verification": "Construa gráficos manuais ou via software e confirme que F(U) ~ Uniform(0,1) para qualquer F contínua.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e lápis para gráficos",
                                    "Calculadora ou software como Python (matplotlib, scipy.stats)",
                                    "Referência: Livro de Probabilidade básica"
                                  ],
                                  "tips": "Sempre normalize U para [0,1]; use simulações rápidas em Python para visualizar.",
                                  "learningObjective": "Compreender os fundamentos probabilísticos necessários para o método.",
                                  "commonMistakes": [
                                    "Confundir PDF com CDF",
                                    "Esquecer que U deve ser estritamente entre 0 e 1",
                                    "Ignorar continuidade da F"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Conceito de Função Inversa da FDC",
                                  "subSteps": [
                                    "Defina a inversa generalizada F^{-1}(u) = inf{x | F(x) ≥ u} para u em (0,1).",
                                    "Mostre que para F estritamente crescente e contínua, F^{-1} é única e F(F^{-1}(u)) = u.",
                                    "Discuta por que aplicar F^{-1} a uma uniforme gera a distribuição desejada.",
                                    "Calcule inversas analíticas para exemplos: exponencial (F^{-1}(u) = -ln(1-u)/λ), uniforme(a,b).",
                                    "Verifique numericamente com valores de u=0.25, 0.5, 0.75."
                                  ],
                                  "verification": "Resolva F(F^{-1}(u)) = u para pelo menos duas distribuições e confira numericamente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Folha de exercícios com FDCs comuns",
                                    "Python ou R para plotar F e F^{-1}",
                                    "Tabela de integrais para exponencial"
                                  ],
                                  "tips": "Use 1-u em vez de u para evitar log(0); plotar F e F^{-1} ajuda a visualizar.",
                                  "learningObjective": "Dominar a definição e cálculo da inversa da FDC.",
                                  "commonMistakes": [
                                    "Usar inversa comum em vez de generalizada",
                                    "Não lidar com F não estritamente crescente",
                                    "Erros em cálculos logarítmicos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Prova Matemática Básica do Método",
                                  "subSteps": [
                                    "Enuncie o teorema: Se U~Uniform(0,1), então X=F^{-1}(U) tem CDF F.",
                                    "Prove P(X ≤ x) = P(F^{-1}(U) ≤ x) = P(U ≤ F(x)) = F(x), assumindo F contínua e estritamente crescente.",
                                    "Estenda para F generalizada usando propriedades da inversa.",
                                    "Discuta densidade: f_X(x) = f_U(F(x)) * |dF/dx| = 1 * f(x) onde f é PDF de F.",
                                    "Resolva a prova passo a passo em um quadro ou papel."
                                  ],
                                  "verification": "Escreva a prova completa e derive a PDF de X a partir da transformação.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Quadro branco ou papel para derivações",
                                    "Software LaTeX ou notebook Jupyter para formalizar",
                                    "Referência: Teorema de transformação de variáveis"
                                  ],
                                  "tips": "Comece com o caso simples estritamente crescente; use notação probabilística P(.) claramente.",
                                  "learningObjective": "Provar rigorosamente por que o método funciona.",
                                  "commonMistakes": [
                                    "Pular passos na desigualdade P(F^{-1}(U) ≤ x)",
                                    "Confundir CDF com PDF na prova",
                                    "Ignorar monotonicidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Condições de Aplicabilidade e Limitações",
                                  "subSteps": [
                                    "Liste condições: F contínua, F^{-1} computacionalmente viável (analítica ou numérica).",
                                    "Discuta limitações: Inversas não analíticas (normal requer métodos numéricos como Newton).",
                                    "Compare com outros métodos (rejeição, composição) em termos de eficiência.",
                                    "Implemente um exemplo numérico em código para gerar 1000 amostras exponenciais.",
                                    "Avalie histograma vs. PDF teórica."
                                  ],
                                  "verification": "Gere amostras e confirme via QQ-plot ou teste Kolmogorov-Smirnov que seguem F.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Python com numpy.random.uniform e scipy.stats",
                                    "Gráficos de histograma e QQ-plot"
                                  ],
                                  "tips": "Para inversas difíceis, mencione bissecção; teste com λ=1 para exponencial.",
                                  "learningObjective": "Identificar quando e por que usar o método.",
                                  "commonMistakes": [
                                    "Aplicar a distribuições discretas sem adaptação",
                                    "Subestimar custo computacional de inversas numéricas",
                                    "Não verificar amostras geradas"
                                  ]
                                }
                              ],
                              "practicalExample": "Para gerar X ~ Exponencial(λ=1), use U~Uniform(0,1), X = -ln(1-U). Gere 1000 U's, aplique transformação, plote histograma (deve aproximar PDF e^{-x}) e QQ-plot vs. teórica.",
                              "finalVerifications": [
                                "Explicar verbalmente o teorema e prova em 2 minutos.",
                                "Calcular F^{-1}(u) para 3 distribuições diferentes.",
                                "Implementar código para gerar e visualizar amostras de exponencial.",
                                "Identificar 2 condições necessárias e 1 limitação.",
                                "Provar P(X ≤ x) = F(x) para caso geral.",
                                "Comparar eficiência com método de rejeição em um exemplo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de F^{-1} e propriedades (correta/incompleta/errada).",
                                "Correção da prova matemática (completa com passos lógicos/com parcial/erros).",
                                "Qualidade da implementação prática (funciona/visualiza bem/falha).",
                                "Compreensão de condições e limitações (lista completa/reduzida/ausente).",
                                "Capacidade de generalização para outras distribuições (boa/parcial/nenhuma).",
                                "Clareza na explicação verbal e escrita."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Inferência e testes de hipóteses com simulações Monte Carlo.",
                                "Programação: Implementação numérica em Python/R para otimização e raízes.",
                                "Física: Simulação de processos estocásticos como decaimento radioativo.",
                                "Finanças: Modelagem de tempos de chegada em filas ou retornos de ativos."
                              ],
                              "realWorldApplication": "Em simulações financeiras para precificar opções (gerar retornos lognormais via inversa), modelagem de tráfego de redes (tempos exponenciais de chegada), ou simulações físicas de partículas em colisões (distribuições de energia via Monte Carlo)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.2",
                            "name": "Derivar funções inversas para distribuições comuns",
                            "description": "Calcular explicitamente a inversa da FDC para distribuições como exponencial, uniforme contínua e triangular, resolvendo equações como F^{-1}(u) = -ln(1-u)/λ para exponencial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Método da Inversa Transformada e Aplicar à Uniforme Contínua",
                                  "subSteps": [
                                    "Revise a definição da Função Distribuição Cumulativa (FDC) F(x) = P(X ≤ x).",
                                    "Explique que o método resolve F^{-1}(U) = x onde U ~ Uniforme(0,1).",
                                    "Para uniforme contínua U(a,b): derive F(x) = (x - a)/(b - a), então F^{-1}(u) = a + (b - a)u.",
                                    "Teste com a=0, b=1: F^{-1}(u) = u.",
                                    "Verifique invertibilidade: F é estritamente crescente."
                                  ],
                                  "verification": "Derive corretamente F^{-1}(u) para U(0,1) e U(2,5), e confirme que F(F^{-1}(u)) = u.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, calculadora, tabela de FDC básica",
                                  "tips": "Sempre verifique se F é contínua e estritamente crescente antes de inverter.",
                                  "learningObjective": "Compreender os princípios do método e derivar inversa para uniforme contínua.",
                                  "commonMistakes": "Confundir FDC com densidade; esquecer limites a e b na uniforme."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar Função Inversa para Distribuição Exponencial",
                                  "subSteps": [
                                    "Lembre a FDC da exponencial: F(x) = 1 - e^{-λx} para x ≥ 0.",
                                    "Resolva F(x) = u: 1 - e^{-λx} = u → e^{-λx} = 1 - u → -λx = ln(1 - u) → x = -ln(1 - u)/λ.",
                                    "Simplifique para F^{-1}(u) = -ln(1 - u)/λ.",
                                    "Verifique com λ=1: média 1, simule u=0.5 → x ≈ 0.693.",
                                    "Confirme propriedades: E[X] = 1/λ via simulação mental."
                                  ],
                                  "verification": "Calcule F^{-1}(0.5) para λ=2 e aplique F para obter 0.5.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora com ln, software como Python (scipy.stats.expon.ppf)",
                                  "tips": "Use 1-u em vez de u para evitar ln(0); pratique com diferentes λ.",
                                  "learningObjective": "Calcular explicitamente a inversa exponencial e validar.",
                                  "commonMistakes": "Esquecer o sinal negativo ou usar ln(u) em vez de ln(1-u); inverter λ."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar Função Inversa para Distribuição Triangular",
                                  "subSteps": [
                                    "Defina triangular(a,b,c) com a < b < c; F(x) piecewise: para a≤x≤b, F(x)=(x-a)^2/((b-a)(c-a)); para b≤x≤c, F(x)=1 - (c-x)^2/((c-b)(c-a)).",
                                    "Resolva F(x)=u para x em [a,b]: x = a + sqrt(u*(b-a)*(c-a)).",
                                    "Para x em [b,c]: x = c - sqrt((1-u)*(c-b)*(c-a)).",
                                    "Implemente lógica if u ≤ (b-a)/(c-a) then primeiro caso else segundo.",
                                    "Teste com a=0,b=1,c=2, u=0.5: calcule x."
                                  ],
                                  "verification": "Derive piecewise inversa e verifique F(F^{-1}(u))=u para 3 valores de u.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel quadriculado, calculadora gráfica, código Python para triangular.ppf",
                                  "tips": "Divida em casos baseados no modo b; use sqrt com cuidado para domínios.",
                                  "learningObjective": "Lidar com FDC piecewise e derivar inversa condicional.",
                                  "commonMistakes": "Erros em fórmulas piecewise; confundir a,b,c; sqrt de negativo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Generalizar Derivações",
                                  "subSteps": [
                                    "Compare inversas derivadas com tabelas ou software (ex: R qexp, qunif, qtriang).",
                                    "Gere U~Unif(0,1) e aplique F^{-1} para simular 10 amostras por distribuição.",
                                    "Calcule estatísticas amostrais (média, var) e compare com teóricas.",
                                    "Discuta quando método falha (F não invertível estritamente).",
                                    "Pratique derivação para gamma(α=2) como extensão."
                                  ],
                                  "verification": "Simulações coincidem com parâmetros teóricos em 90% dos casos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Python/R com numpy.random.uniform e stats, histogramas",
                                  "tips": "Use seed para reprodutibilidade; plote QQ-plot para validação visual.",
                                  "learningObjective": "Validar derivações via simulação e identificar limitações.",
                                  "commonMistakes": "Amostras insuficientes para validação; ignorar discretização numérica."
                                }
                              ],
                              "practicalExample": "Para gerar X ~ Exp(λ=0.5) usando U=0.3679: F^{-1}(0.3679) = -ln(1-0.3679)/0.5 ≈ -ln(0.6321)/0.5 ≈ 1.2/0.5 = 2.4, que é plausível pois E[X]=2.",
                              "finalVerifications": [
                                "Deriva corretamente F^{-1}(u) para uniforme, exponencial e triangular.",
                                "Valida inversas aplicando F e obtendo u de volta.",
                                "Implementa simulação em código e verifica histograma.",
                                "Explica limitações para distribuições não invertíveis.",
                                "Calcula estatísticas amostrais próximas às teóricas.",
                                "Discute generalização para outras distribuições comuns."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas fórmulas derivadas (sem erros algébricos).",
                                "Correta manipulação de piecewise para triangular.",
                                "Validação numérica com exemplos concretos.",
                                "Clareza na explicação de passos e verificações.",
                                "Identificação de erros comuns e dicas preventivas.",
                                "Criatividade em extensões ou simulações."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Geração de amostras para testes de hipóteses.",
                                "Programação: Implementação em Python/R para simulações Monte Carlo.",
                                "Física: Modelagem de tempos de falha em engenharia de confiabilidade.",
                                "Finanças: Simulação de preços de ativos via processos estocásticos."
                              ],
                              "realWorldApplication": "Em simulações de filas (exponencial para tempos de serviço), modelagem de riscos financeiros (triangular para cenários incertos) ou geração de cenários em machine learning para dados sintéticos contínuos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.3",
                            "name": "Implementar o método em pseudocódigo",
                            "description": "Escrever algoritmo passo a passo para gerar amostras de uma distribuição específica usando inversa transformada, incluindo geração de U uniforme e aplicação da inversa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar a distribuição alvo e derivar a função inversa da CDF",
                                  "subSteps": [
                                    "Escolha uma distribuição contínua específica (ex: exponencial com parâmetro λ).",
                                    "Escreva a função de distribuição cumulativa (CDF) F(x).",
                                    "Resolva a equação U = F(X) para X, obtendo a inversa F^{-1}(U).",
                                    "Simplifique a expressão da inversa e anote os domínios válidos.",
                                    "Verifique a monotonicidade crescente da CDF para garantir inversa única."
                                  ],
                                  "verification": "Confirme que a inversa produz valores no suporte da distribuição para U entre 0 e 1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, tabela de distribuições probabilísticas, calculadora.",
                                  "tips": "Comece com distribuições simples como exponencial ou uniforme para praticar.",
                                  "learningObjective": "Dominar a derivação analítica da inversa da CDF para qualquer distribuição contínua.",
                                  "commonMistakes": "Esquecer de considerar o domínio de U (0,1) ou não verificar se F é estritamente crescente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o gerador de números uniformes aleatórios",
                                  "subSteps": [
                                    "Descreva o algoritmo para gerar U ~ Uniform(0,1), como usando rand() em pseudocódigo.",
                                    "Especifique o número de amostras N a gerar.",
                                    "Inclua um loop para múltiplas gerações.",
                                    "Adicione semente para reprodutibilidade (opcional).",
                                    "Garanta que U esteja estritamente entre 0 e 1 (evite 0 e 1 exatos)."
                                  ],
                                  "verification": "Gere manualmente 5 valores de U e confirme que estão em (0,1).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de texto para pseudocódigo, documentação de funções rand().",
                                  "tips": "Use pseudocódigo genérico como 'U ← random(0,1)' para portabilidade.",
                                  "learningObjective": "Entender a dependência em geradores uniformes para métodos de inversa.",
                                  "commonMistakes": "Gerar U incluindo 0 ou 1, o que pode causar problemas na inversa."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir o pseudocódigo completo do algoritmo",
                                  "subSteps": [
                                    "Inicie com declaração de variáveis: N, λ (parâmetro), array de amostras.",
                                    "Crie loop principal: para i de 1 a N, gere U, aplique X = F^{-1}(U), armazene X.",
                                    "Inclua comentários explicativos em cada linha.",
                                    "Adicione tratamento de erros (ex: parâmetro inválido).",
                                    "Formate o pseudocódigo de forma legível com indentação."
                                  ],
                                  "verification": "Leia o pseudocódigo em voz alta simulando execução para 1 amostra.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de texto ou IDE para pseudocódigo.",
                                  "tips": "Use estruturas como ALGORITMO, INICIO, FIM para clareza.",
                                  "learningObjective": "Escrever pseudocódigo estruturado e modular para geração de amostras.",
                                  "commonMistakes": "Esquecer o loop para múltiplas amostras ou erros na fórmula da inversa."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e refinar o pseudocódigo",
                                  "subSteps": [
                                    "Simule execução manual com U conhecidos e verifique saídas.",
                                    "Compare histograma conceitual das amostras com a PDF da distribuição.",
                                    "Teste com diferentes parâmetros (ex: λ variando).",
                                    "Revise comentários e melhore legibilidade.",
                                    "Documente limitações (ex: só para CDFs invertíveis analiticamente)."
                                  ],
                                  "verification": "As amostras geradas devem seguir aproximadamente a distribuição teórica.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel para simulação manual, software como Python para protótipo rápido.",
                                  "tips": "Use U=0.5 para checar mediana esperada.",
                                  "learningObjective": "Garantir correção e robustez do algoritmo via validação.",
                                  "commonMistakes": "Não testar com valores extremos de U próximos a 0 ou 1."
                                }
                              ],
                              "practicalExample": "Para distribuição exponencial λ=1: Pseudocódigo: INICIO; N ← 1000; para i=1 a N { U ← random(0,1); X[i] ← -ln(1-U); } FIM. Simule: U=0.3 → X≈1.20, que está no suporte [0,∞).",
                              "finalVerifications": [
                                "Pseudocódigo gera X no suporte correto da distribuição.",
                                "Loop produz N amostras independentes.",
                                "Fórmula da inversa está correta e simplificada.",
                                "Comentários explicam cada passo claramente.",
                                "Simulação manual com 3 U's produz saídas plausíveis.",
                                "Limitações documentadas (ex: requer inversa fechada)."
                              ],
                              "assessmentCriteria": [
                                "Precisão da derivação da inversa (100% correta).",
                                "Estrutura do pseudocódigo: legível, indentado, comentado.",
                                "Inclusão de geração uniforme e aplicação da inversa.",
                                "Validação via simulação manual demonstrada.",
                                "Tratamento de parâmetros e erros considerado.",
                                "Tempo de execução conceitual eficiente (O(N))."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade: Compreensão profunda de CDFs e transformações.",
                                "Programação: Estruturas de loop, funções rand() e modularidade.",
                                "Estatística: Validação via QQ-plots ou testes de aderência.",
                                "Matemática Aplicada: Simulações em processos estocásticos."
                              ],
                              "realWorldApplication": "Em finanças, gerar tempos entre chegadas de clientes em filas (exponencial) para simular call centers; em física, modelar decaimento radioativo; em machine learning, bootstrap sampling para validação de modelos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.3.2",
                        "name": "Método de Rejeição",
                        "description": "Técnica de geração de amostras de distribuições contínuas difíceis via proposta de uma distribuição auxiliar mais simples, aceitando ou rejeitando com base em uma probabilidade proporcional à densidade alvo.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.2.1",
                            "name": "Compreender o algoritmo do método de rejeição",
                            "description": "Explicar os passos: gerar candidato Y da auxiliar g(y), calcular aceitação com c*g(y) >= f(y), onde f é a densidade alvo e c constante tal que f(y) <= c g(y) para todo y.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os componentes fundamentais: f(y), g(y) e c",
                                  "subSteps": [
                                    "Identificar f(y) como a densidade de probabilidade alvo, que é difícil de amostrar diretamente.",
                                    "Selecionar g(y) como uma densidade auxiliar fácil de amostrar (ex: uniforme ou exponencial).",
                                    "Determinar a constante c ≥ sup{f(y)/g(y)}, garantindo que f(y) ≤ c g(y) para todo y.",
                                    "Visualizar graficamente f(y) e c g(y), onde c g(y) forma um 'envelope' sobre f(y).",
                                    "Verificar que ∫ g(y) dy = 1 e c é finito."
                                  ],
                                  "verification": "Desenhar gráficos de f(y), g(y) e c g(y) e confirmar que f(y) ≤ c g(y) em todos os pontos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis para gráficos",
                                    "Software de plotagem como Desmos ou Python (Matplotlib)"
                                  ],
                                  "tips": "Sempre normalize g(y) para ser uma densidade válida; teste c computando sup{f/g}.",
                                  "learningObjective": "Compreender as propriedades matemáticas de f, g e c no método de rejeição.",
                                  "commonMistakes": [
                                    "Escolher c muito pequeno, violando f ≤ c g",
                                    "Confundir g(y) com a cumulativa de g"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar o candidato Y a partir de g(y)",
                                  "subSteps": [
                                    "Gerar uma amostra Y da distribuição g(y) usando métodos conhecidos (ex: inversa da CDF para uniforme).",
                                    "Explicar que Y é proposto independentemente a cada iteração.",
                                    "Garantir que a geração de Y seja eficiente e exata.",
                                    "Registrar o valor de Y gerado para uso no próximo passo.",
                                    "Repetir este processo até que o teste de aceitação passe."
                                  ],
                                  "verification": "Simular manualmente 3 gerações de Y e confirmar que seguem g(y) (ex: histograma mental).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Gerador de números aleatórios (calculadora ou Python random)"
                                  ],
                                  "tips": "Use distribuições simples como uniforme [0,1] para g(y) em exemplos iniciais.",
                                  "learningObjective": "Dominar a geração exata de amostras da auxiliar g(y).",
                                  "commonMistakes": [
                                    "Gerar Y da uniforme sem ajustar para g",
                                    "Não repetir independentemente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar o teste de aceitação/rejeição",
                                  "subSteps": [
                                    "Gerar U ~ Uniforme(0,1) independente de Y.",
                                    "Calcular a razão de aceitação: f(Y) / (c g(Y)).",
                                    "Aceitar Y se U ≤ f(Y) / (c g(Y)); caso contrário, rejeitar e voltar ao passo 2.",
                                    "Explicar probabilisticamente por que os Y aceitos seguem f(y).",
                                    "Interpretar: a probabilidade condicional de aceitação é f(Y)/(c g(Y))."
                                  ],
                                  "verification": "Executar 5 iterações manuais e listar quais foram aceitas, justificando cada decisão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel para cálculos",
                                    "Funções f e g definidas numericamente"
                                  ],
                                  "tips": "Evite divisão por zero avaliando g(Y)>0; use log para estabilidade numérica em código.",
                                  "learningObjective": "Aplicar corretamente o critério de aceitação e entender sua justificativa probabilística.",
                                  "commonMistakes": [
                                    "Usar U > razão em vez de ≤",
                                    "Esquecer de gerar U novo a cada tentativa"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar o processo iterativo e propriedades do método",
                                  "subSteps": [
                                    "Executar o loop até obter uma amostra aceita.",
                                    "Calcular a taxa de aceitação esperada: 1/c.",
                                    "Verificar que as amostras aceitas são i.i.d. de f(y).",
                                    "Discutir eficiência: c próximo de 1 é ideal.",
                                    "Comparar com outros métodos como inversa da CDF."
                                  ],
                                  "verification": "Gerar 10 amostras completas e plotar histograma para validar contra f(y).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python ou R para simulação",
                                    "Gráficos de densidade"
                                  ],
                                  "tips": "Monitore o número de rejeições para diagnosticar c ruim.",
                                  "learningObjective": "Avaliar a eficiência e corretude teórica do algoritmo completo.",
                                  "commonMistakes": [
                                    "Ignorar que taxa de aceitação é 1/c",
                                    "Achar que rejeitadas são perdidas sem bias"
                                  ]
                                }
                              ],
                              "practicalExample": "Para gerar de f(y) = 2y em [0,1] (triangular), use g(y)=1 (uniforme [0,1]), c=2. Gere Y~U[0,1], U~U[0,1]; aceite se U ≤ 2Y/2 = Y. As aceitas têm densidade proporcional a y, normalizando para 2y.",
                              "finalVerifications": [
                                "Explicar verbalmente os 4 passos principais do algoritmo.",
                                "Desenhar envelope gráfico f(y) ≤ c g(y) para um exemplo.",
                                "Simular 20 amostras e confirmar histograma próximo a f(y).",
                                "Calcular taxa de aceitação observada e compará-la com 1/c.",
                                "Provar intuitivamente por que Y aceito ~ f(y).",
                                "Identificar um caso onde c é ineficiente (ex: caudas pesadas)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição dos passos e fórmulas (f(Y)/(c g(Y))).",
                                "Corretude na geração de Y e U independentes.",
                                "Compreensão da prova de corretude (aceitação condicional).",
                                "Análise qualitativa de eficiência baseada em c.",
                                "Capacidade de aplicar a um exemplo concreto sem erros.",
                                "Visualização gráfica clara e precisa."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em Python com numpy.random para simulações.",
                                "Estatística: Amostragem por rejeição em métodos Monte Carlo.",
                                "Física: Geração de eventos raros em simulações de partículas.",
                                "Ciência de Dados: Bootstrap e amostragem em machine learning."
                              ],
                              "realWorldApplication": "Em simulações Monte Carlo para finanças (preços de opções com distribuições skew), física computacional (colisões de partículas com densidades irregulares) e bioinformática (gerar sequências com probabilidades não-uniformes), onde distribuições alvo são complexas mas envelopes simples existem."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.2.2",
                            "name": "Escolher distribuição auxiliar e calcular constante c",
                            "description": "Para uma densidade alvo f, selecionar g (ex: exponencial ou uniforme) e determinar o menor c >= sup{f(y)/g(y)}, ilustrando com exemplo para distribuição beta ou gamma.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar a densidade alvo f e suas propriedades",
                                  "subSteps": [
                                    "Identifique a função densidade de probabilidade alvo f(y) no domínio de suporte relevante.",
                                    "Determine as propriedades chave de f, como forma (unimodal, assimétrica), supremo e comportamento nas caudas.",
                                    "Plote ou esboce graficamente f(y) para visualizar picos e decaimentos.",
                                    "Calcule ou estime o valor máximo de f(y), se aplicável.",
                                    "Documente restrições ou características que influenciam a escolha de g."
                                  ],
                                  "verification": "Confirme que o esboço ou plot de f(y) reflete corretamente a densidade e lista propriedades chave em um relatório.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e lápis ou software de plotagem (ex: Python Matplotlib, R ggplot)",
                                    "Referência à definição de f (artigo ou livro de probabilidade)"
                                  ],
                                  "tips": "Comece sempre pelo plot para intuição visual; isso facilita a escolha de g.",
                                  "learningObjective": "Compreender as características da densidade alvo para guiar a seleção de g.",
                                  "commonMistakes": "Ignorar o comportamento nas caudas, levando a g inadequada; confundir f com sua CDF."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar a distribuição auxiliar g apropriada",
                                  "subSteps": [
                                    "Escolha g(y) simples e fácil de amostrar, como exponencial, uniforme ou gamma, que envolva f(y).",
                                    "Verifique se o suporte de g cobre completamente o de f.",
                                    "Avalie se g aproxima bem f nos picos e caudas para minimizar c.",
                                    "Justifique a escolha comparando graficamente f e g.",
                                    "Teste alternativas brevemente (ex: uniforme vs. exponencial) para otimização."
                                  ],
                                  "verification": "Registre a justificativa escrita e um plot comparativo de f e g mostrando sobreposição adequada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de plotagem",
                                    "Tabelas de distribuições comuns (ex: Wikipedia ou livro texto)"
                                  ],
                                  "tips": "Prefira g com PDF explícita e amostragem conhecida; exponencial para caudas pesadas.",
                                  "learningObjective": "Selecionar g que minimize c enquanto mantém simplicidade de amostragem.",
                                  "commonMistakes": "Escolher g com suporte menor que f, invalidando o método; ignorar facilidade de amostragem."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a constante c como o menor supremo de f(y)/g(y)",
                                  "subSteps": [
                                    "Defina a função r(y) = f(y)/g(y) para y no suporte comum.",
                                    "Analise analiticamente r(y) para encontrar seu máximo ou supremo (limites, derivadas).",
                                    "Se analítico difícil, use métodos numéricos: avalie r(y) em grade fina ou otimize numericamente.",
                                    "Verifique c >= r(y) para todo y, provando ou plotando.",
                                    "Arredonde c ligeiramente para cima se necessário para segurança numérica."
                                  ],
                                  "verification": "Plot de r(y) vs y mostrando que c é o mínimo tal que c >= r(y) em todos os pontos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Calculadora simbólica (ex: SymPy, Mathematica)",
                                    "Software numérico (Python SciPy.optimize)"
                                  ],
                                  "tips": "Para distribuições comuns como beta/gamma, busque fórmulas conhecidas para sup r(y).",
                                  "learningObjective": "Determinar precisamente c minimizando ineficiência do método de rejeição.",
                                  "commonMistakes": "Subestimar sup em caudas; não verificar numericamente após análise analítica."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ilustrar e validar com exemplo concreto (distribuição beta ou gamma)",
                                  "subSteps": [
                                    "Escolha exemplo: f ~ Beta(2,5) ou Gamma(2,1); defina parâmetros explicitamente.",
                                    "Aplique passos 1-3 para este f, calculando g e c explicitamente.",
                                    "Implemente simulação simples para gerar amostras via rejeição e verifique histograma.",
                                    "Compare amostras geradas com f verdadeira via teste KS ou QQ-plot.",
                                    "Documente c encontrado e eficiência observada (taxa de aceitação ~1/c)."
                                  ],
                                  "verification": "Histograma de amostras geradas sobreposto a f, com taxa de aceitação próxima a 1/c.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Linguagem de programação (Python com NumPy/SciPy, R)",
                                    "Notebook Jupyter para reprodutibilidade"
                                  ],
                                  "tips": "Use seed fixa para reprodutibilidade; mire 10k amostras para validação visual.",
                                  "learningObjective": "Aplicar o processo completo em exemplo real, validando o método.",
                                  "commonMistakes": "Erro em implementação de g ou rejeição; não validar amostras geradas."
                                }
                              ],
                              "practicalExample": "Para f(y) = densidade Beta(0.5, 0.5) em [0,1] (U-invertida), escolha g(y) = Uniforme[0,1]. Então r(y) = f(y)/1 = 2/π / sqrt(y(1-y)), sup r(y)=1 no modo y=0.5? Não, max é 1/sqrt(0.25)=2/π? Calcule: sup f(y)=1/π ≈0.318, então c=1 (pois g=1 domina). Simule: gere U~Unif, V~Beta prop, aceite se V < c*U*f(V)/g(U).",
                              "finalVerifications": [
                                "c calculado satisfaz c >= f(y)/g(y) para todo y no suporte.",
                                "Plot de f(y)/g(y) não excede c em nenhum ponto amostrado.",
                                "Simulação gera amostras com histograma coincidente com f.",
                                "Taxa de aceitação empírica ≈ 1/c.",
                                "Justificativa de escolha de g é clara e otimizada.",
                                "Exemplo ilustrativo (beta/gamma) implementado e validado."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de sup{f(y)/g(y)} (erro <1%).",
                                "Adequação da escolha de g (simples, suporte correto, c razoável <10).",
                                "Completude da análise analítica/numérica de r(y).",
                                "Qualidade da validação via simulação (teste estatístico passado).",
                                "Clareza na documentação e ilustração com exemplo específico.",
                                "Eficiência demonstrada (taxa aceitação >0.1)."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: Compreensão de PDFs e amostragem.",
                                "Programação Computacional: Implementação numérica e otimização.",
                                "Análise Numérica: Encontrar máximos e integração simulada.",
                                "Simulação e Modelagem: Aplicações em Monte Carlo."
                              ],
                              "realWorldApplication": "Em simulações Monte Carlo para finanças (gerar retornos assimétricos como gamma para opções), bioinformática (amostrar distribuições beta para proporções alélicas), e física (gerar tempos de chegada exponenciais rejeitados para precisão)."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.2.3",
                            "name": "Implementar e analisar eficiência do método",
                            "description": "Codificar pseudocódigo para método de rejeição, calcular taxa de aceitação 1/c e discutir eficiência computacional, comparando com inversa transformada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender e Codificar Pseudocódigo do Método de Rejeição",
                                  "subSteps": [
                                    "Revise a definição do método de rejeição: gere U ~ Uniform(0,1), proponha candidato X de uma distribuição auxiliar g(x), aceite com probabilidade f(x)/(c g(x)) onde c >= sup f(x)/g(x).",
                                    "Escolha uma densidade alvo f(x), como exponencial, e uma g(x) simples como uniforme ou exponencial.",
                                    "Escreva o pseudocódigo passo a passo: loop de geração de U1, U2, cálculo de X = G^{-1}(U1), aceitação se U2 <= f(X)/(c g(X)).",
                                    "Teste logicamente o pseudocódigo com valores fixos para U1 e U2.",
                                    "Documente os símbolos usados (f, g, c) no pseudocódigo."
                                  ],
                                  "verification": "Pseudocódigo roda sem erros lógicos em simulação manual e gera amostras válidas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta, editor de texto ou Jupyter Notebook",
                                  "tips": "Comece com f(x) exponencial padrão para simplicidade.",
                                  "learningObjective": "Dominar a estrutura algorítmica do método de rejeição.",
                                  "commonMistakes": "Esquecer o loop while para rejeições ou calcular c incorretamente como inf."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a Constante c e Taxa de Aceitação 1/c",
                                  "subSteps": [
                                    "Identifique sup f(x)/g(x) para as densidades escolhidas; por exemplo, para f exponencial e g uniforme em [0,b], calcule c = b * lambda * e.",
                                    "Derive analiticamente ou numericamente o valor exato de c.",
                                    "Explique que a taxa de aceitação esperada é 1/c, significando fração média de propostas aceitas.",
                                    "Simule 1000 iterações para estimar empiricamente a taxa de aceitação e compare com 1/c teórico.",
                                    "Registre discrepâncias e razões (ex: variância amostral)."
                                  ],
                                  "verification": "Valor de c calculado corretamente e simulação empírica converge para 1/c dentro de 5%.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora ou Python com numpy para simulação rápida",
                                  "tips": "Use g(x) que sobrepõe bem f(x) para c próximo de 1 e alta eficiência.",
                                  "learningObjective": "Calcular e validar a eficiência teórica do método.",
                                  "commonMistakes": "Subestimar sup f/g levando a rejeições inválidas ou c=1 incorreto."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Eficiência Computacional do Método de Rejeição",
                                  "subSteps": [
                                    "Meça custo por amostra: número médio de iterações no loop (1/(1/c) = c tentativas).",
                                    "Calcule tempo de CPU para gerar N=10^5 amostras usando implementação simples.",
                                    "Discuta trade-offs: custo fixo por tentativa vs simplicidade de implementação.",
                                    "Compare overhead com geração direta: custo rejeição = c * custo_proposta.",
                                    "Grave gráfico de taxa de aceitação vs c para diferentes escolhas de g."
                                  ],
                                  "verification": "Análise inclui métricas numéricas e gráfico mostrando dependência em c.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Python com matplotlib e timeit para benchmarking",
                                  "tips": "Otimize código vetorizado para benchmarks precisos.",
                                  "learningObjective": "Quantificar eficiência em termos de tempo e tentativas.",
                                  "commonMistakes": "Ignorar custo de avaliação f(x)/g(x) no total."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar com o Método da Inversa Transformada",
                                  "subSteps": [
                                    "Implemente pseudocódigo para inversa transformada: para exponencial, X = -log(1-U)/lambda.",
                                    "Benchmark ambos métodos para N=10^5 amostras: tempo, qualidade (histograma KS test).",
                                    "Compare: rejeição universal mas ineficiente se c>>1; inversa rápida mas requer CDF invertível.",
                                    "Discuta cenários: use rejeição quando inversa difícil (ex: densidades irregulares).",
                                    "Conclua com tabela: eficiência, aplicabilidade, limitações."
                                  ],
                                  "verification": "Tabela de comparação completa com dados empíricos e discussão qualitativa.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Python com scipy.stats para KS test",
                                  "tips": "Escolha mesma semente RNG para comparações justas.",
                                  "learningObjective": "Avaliar trade-offs entre métodos de geração aleatória.",
                                  "commonMistakes": "Comparar sem normalizar por qualidade de amostras geradas."
                                }
                              ],
                              "practicalExample": "Gere 10.000 amostras de uma exponencial(1) usando rejeição com g uniforme[0,2] (c≈1.718), meça taxa aceitação ~0.58, compare tempo com inversa: rejeição leva ~1.7x mais tempo mas funciona para densidades sem inversa fechada.",
                              "finalVerifications": [
                                "Pseudocódigo do método de rejeição está correto e comentado.",
                                "c calculado analiticamente e validado por simulação.",
                                "Taxa de aceitação empírica bate com 1/c teórico.",
                                "Análise de eficiência inclui benchmarks numéricos.",
                                "Comparação com inversa transformada é equilibrada e evidenciada.",
                                "Gráficos e tabelas suportam conclusões."
                              ],
                              "assessmentCriteria": [
                                "Correção do pseudocódigo e cálculo de c (30%).",
                                "Precisão da análise de eficiência e simulações (25%).",
                                "Profundidade da comparação com inversa (20%).",
                                "Clareza de documentação e visualizações (15%).",
                                "Insight sobre trade-offs práticos (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação de algoritmos em Python.",
                                "Estatística: Testes de bondade de ajuste como KS.",
                                "Probabilidade: Propriedades de densidades e esperanças.",
                                "Otimização: Escolha de g para minimizar c."
                              ],
                              "realWorldApplication": "Em simulações Monte Carlo para finanças (preços de opções), física de partículas (gerar eventos raros) ou machine learning (amostragem em MCMC onde CDFs não têm inversa fechada), onde eficiência afeta tempo de computação em larga escala."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.4",
                    "name": "Geração de Variáveis Aleatórias Discretas",
                    "description": "Métodos para simular distribuições discretas utilizando números uniformes pseudoaleatórios.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.4.1",
                        "name": "Método da Transformação Inversa para Distribuições Discretas",
                        "description": "Técnica fundamental que utiliza a função de distribuição cumulativa inversa (CDF inversa) para gerar variáveis aleatórias discretas a partir de números uniformes pseudoaleatórios no intervalo [0,1].",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.1.1",
                            "name": "Compreender o princípio da transformação inversa",
                            "description": "Explicar como a CDF inversa mapeia um valor uniforme U ~ Uniform(0,1) para uma variável discreta X com probabilidades p_i, garantindo que P(X ≤ k) = F(k) seja respeitada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a Função de Distribuição Cumulativa (CDF) para Variáveis Discretas",
                                  "subSteps": [
                                    "Defina a CDF F(k) = P(X ≤ k) para uma variável discreta X com probabilidades p_i = P(X = i).",
                                    "Calcule a CDF cumulativa somando as probabilidades: F(k) = sum_{i=1 to k} p_i.",
                                    "Desenhe o gráfico em degraus da CDF, mostrando saltos em cada valor possível de X.",
                                    "Identifique que F(k) é não-decrescente e vai de 0 a 1.",
                                    "Pratique com um exemplo simples de 3 outcomes."
                                  ],
                                  "verification": "Construa a tabela de CDF para uma distribuição dada e verifique se soma para 1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, calculadora",
                                  "tips": "Comece sempre pela lista de p_i para evitar erros de soma.",
                                  "learningObjective": "Compreender como a CDF acumula probabilidades em variáveis discretas.",
                                  "commonMistakes": "Confundir PMF (p_i) com CDF (F(k)); esquecer de normalizar probabilidades."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar Valores Uniformes U ~ Uniform(0,1)",
                                  "subSteps": [
                                    "Explique que U é uma variável contínua uniforme entre 0 e 1, com PDF constante 1.",
                                    "Discuta como geradores de números pseudo-aleatórios (RNG) produzem U em computadores.",
                                    "Gere manualmente U simulando um RNG simples (ex: fração de um número grande).",
                                    "Verifique propriedades: média 0.5, variância 1/12, P(U < u) = u para u em [0,1].",
                                    "Gere 5 valores de U e plote em um histograma mental."
                                  ],
                                  "verification": "Confirme que valores gerados estão em (0,1) e parecem uniformes.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora ou Python (random.uniform(0,1))",
                                  "tips": "Use intervalos abertos (0,1) para evitar U=0 ou U=1 em casos discretos.",
                                  "learningObjective": "Dominar a geração e propriedades da uniforme contínua base para transformações.",
                                  "commonMistakes": "Gerar U incluindo 0 ou 1, o que pode causar problemas em mapeamentos discretos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a Transformação Inversa: Encontrar X tal que F(X) >= U",
                                  "subSteps": [
                                    "Defina o algoritmo: X = min {k : F(k) >= U}.",
                                    "Para um U dado, compare sequencialmente com os valores cumulativos F(1), F(2), ... até achar o primeiro >= U.",
                                    "Implemente em pseudocódigo: loop for k=1 to n, if U <= F(k) then return k.",
                                    "Teste com múltiplos U para a mesma distribuição.",
                                    "Note que é estritamente crescente em saltos, garantindo unicidade."
                                  ],
                                  "verification": "Execute o algoritmo para 10 U's e tabule os X resultantes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel, tabela de CDF pré-calculada, planilha Excel",
                                  "tips": "Ordene os valores possíveis de X crescentemente para eficiência.",
                                  "learningObjective": "Executar o mapeamento inverso corretamente para gerar X discreta.",
                                  "commonMistakes": "Usar > em vez de >=, levando a probabilidades incorretas; pular valores de k."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Preservação das Probabilidades: P(X = k) = p_k",
                                  "subSteps": [
                                    "Mostre que P(X <= k) = P(U <= F(k)) = F(k), pois U é uniforme.",
                                    "Derive P(X = k) = P(X <= k) - P(X <= k-1) = F(k) - F(k-1) = p_k.",
                                    "Simule muitas amostras e compare frequências empíricas com p_k.",
                                    "Discuta generalização para qualquer CDF contínua ou discreta.",
                                    "Analise complexidade: O(n) no pior caso para n outcomes."
                                  ],
                                  "verification": "Prove matematicamente e valide com simulação de 1000 U's.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python ou R para simulação, papel para prova",
                                  "tips": "Use intervalos [F(k-1), F(k)) para visualizar o mapeamento.",
                                  "learningObjective": "Provar que a transformação preserva a distribuição original de X.",
                                  "commonMistakes": "Ignorar que para discretas, usamos >= para cobrir os saltos corretamente."
                                }
                              ],
                              "practicalExample": "Considere uma moeda viciada: P(X=0)=0.4 (cara), P(X=1)=0.6 (coroa). CDF: F(0)=0.4, F(1)=1.0. Para U=0.3, X=0 (0.3 <=0.4); U=0.5, X=1 (0.5 >0.4 e <=1.0). Simule 100 U's: ~40% X=0, ~60% X=1.",
                              "finalVerifications": [
                                "Construir CDF correta para distribuição dada.",
                                "Gerar U e mapear para X usando inversa.",
                                "Simular 500 amostras e verificar frequências próximas a p_i (erro <5%).",
                                "Provar P(X<=k)=F(k).",
                                "Explicar algoritmo em pseudocódigo.",
                                "Identificar erro em mapeamento incorreto."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção da CDF (100% soma correta).",
                                "Correta aplicação do min{k: F(k)>=U} em exemplos.",
                                "Prova matemática clara de preservação de probabilidades.",
                                "Simulação empírica com resultados convergentes.",
                                "Explicação fluida do princípio sem confusões PMF/CDF.",
                                "Pseudocódigo funcional e eficiente."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em Python (numpy.random.uniform).",
                                "Estatística: Validação via testes qui-quadrado.",
                                "Ciência da Computação: Análise de complexidade O(n).",
                                "Probabilidade: Extensão a contínuas e mixtures."
                              ],
                              "realWorldApplication": "Em simulações Monte Carlo para modelar falhas em sistemas (ex: Poisson discreto para contagens de eventos), geração de clientes em filas de supermercado, ou risco em finanças (distribuições de default binomial)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.1.2",
                            "name": "Derivar a CDF inversa para distribuições simples",
                            "description": "Calcular manualmente a função inversa para distribuições como Bernoulli e Geométrica, identificando os intervalos de probabilidade cumulativa para cada valor possível de X.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as Distribuições Discretas Simples (Bernoulli e Geométrica)",
                                  "subSteps": [
                                    "Defina a função de massa de probabilidade (PMF) da Bernoulli: P(X=0) = 1-p, P(X=1) = p, onde p é a probabilidade de sucesso.",
                                    "Defina a PMF da Geométrica (número de tentativas até o primeiro sucesso): P(X=k) = (1-p)^{k-1} * p, para k = 1, 2, 3, ...",
                                    "Escolha um valor específico de p (ex: p=0.3) e liste os valores possíveis de X com suas probabilidades para as primeiras 5 ocorrências na Geométrica.",
                                    "Identifique os valores possíveis de X para cada distribuição e verifique que somam 1.",
                                    "Compare as duas: note que Bernoulli é um caso especial da Geométrica com máximo 1 tentativa após o sucesso."
                                  ],
                                  "verification": "Liste corretamente as PMFs e pelo menos 5 probabilidades para Geométrica, confirmando soma ≈1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora para potências"
                                  ],
                                  "tips": "Use p=0.5 inicialmente para simplificar cálculos mentais.",
                                  "learningObjective": "Parametrizar e listar probabilidades de distribuições Bernoulli e Geométrica.",
                                  "commonMistakes": [
                                    "Confundir Geométrica com número de falhas (use definição de tentativas até sucesso)",
                                    "Esquecer que probabilidades devem somar exatamente 1"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a Função de Distribuição Cumulativa (CDF)",
                                  "subSteps": [
                                    "Para Bernoulli(p): calcule F(x) = P(X ≤ x): F(x)=0 para x<0, F(x)=1-p para 0≤x<1, F(x)=1 para x≥1.",
                                    "Liste explicitamente F(0) e F(1) para p=0.3: F(0)=0.7, F(1)=1.",
                                    "Para Geométrica(p): F(x) = 1 - (1-p)^x para x=1,2,...; compute para x=1 a 5 com p=0.3.",
                                    "Desenhe graficamente a CDF como uma escada (função em degraus) marcando os saltos em cada valor possível de X.",
                                    "Verifique monotonicidade: F(x) é não-decrescente e atinge 1 no infinito para Geométrica."
                                  ],
                                  "verification": "Apresente tabela ou gráfico da CDF com valores corretos para ambos exemplos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado para gráfico",
                                    "Calculadora"
                                  ],
                                  "tips": "Some probabilidades sequencialmente para CDF em vez de fórmula fechada inicialmente.",
                                  "learningObjective": "Calcular e visualizar a CDF acumulada para distribuições discretas simples.",
                                  "commonMistakes": [
                                    "Erro em potências para Geométrica (use (1-p)^k com cuidado)",
                                    "Confundir F(x) com PMF"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a Função Inversa da CDF (Função Quantil)",
                                  "subSteps": [
                                    "Lembre a definição: F^{-1}(u) = inf {x : F(x) ≥ u}, para u ~ Uniform(0,1).",
                                    "Para Bernoulli: identifique intervalos - se 0 ≤ u < 1-p, X=0; se 1-p ≤ u < 1, X=1.",
                                    "Para Geométrica: encontre o menor k tal que 1 - (1-p)^k ≥ u, ou equivalentemente k = min {j : u ≤ F(j)}.",
                                    "Escreva os intervalos cumulativos: para cada k, intervalo [(F(k-1)), F(k)).",
                                    "Teste com u=0.2 e u=0.8 para Bernoulli(p=0.3), confirmando X=0 e X=1 respectivamente."
                                  ],
                                  "verification": "Escreva a regra de mapeamento u → X para ambas distribuições com intervalos explícitos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel",
                                    "Calculadora",
                                    "Tabela de CDF do passo anterior"
                                  ],
                                  "tips": "Pense em 'preencher os intervalos' como fatias de uma pizza onde cada fatia corresponde a um X.",
                                  "learningObjective": "Construir explicitamente a CDF inversa definindo intervalos probabilísticos.",
                                  "commonMistakes": [
                                    "Inverter limites de intervalos (use < F(x) para o próximo)",
                                    "Esquecer u=0 ou u=1 edge cases"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar a Derivação e Confirmar Propriedades",
                                  "subSteps": [
                                    "Gere 10 valores fictícios de u (ex: 0.1, 0.4, ...) e aplique F^{-1} para Bernoulli e Geométrica.",
                                    "Conte a frequência de cada X e compare com probabilidades teóricas (deve aproximar p).",
                                    "Verifique se a inversa preserva probabilidades: P(F^{-1}(U)=x) = P(X=x).",
                                    "Repita para Geométrica com p=0.4, listando primeiros intervalos.",
                                    "Documente a função inversa em pseudocódigo: if u < F(0) then 0 else find k."
                                  ],
                                  "verification": "Simule 10 u's e mostre que frequências batem com PMF (erro <10%).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Folha para simulação"
                                  ],
                                  "tips": "Use gerador mental de u ou app simples; foque em uniformidade.",
                                  "learningObjective": "Validar a CDF inversa através de simulação manual.",
                                  "commonMistakes": [
                                    "Arredondamento em comparações de u",
                                    "Não testar edge cases como u=0.999"
                                  ]
                                }
                              ],
                              "practicalExample": "Para Bernoulli(p=0.3): CDF F(0)=0.7, F(1)=1. A inversa é: se u ∈ [0, 0.7) → X=0; [0.7, 1) → X=1. Exemplo: u=0.5 → X=0; u=0.8 → X=1. Para Geométrica(p=0.3), intervalos: [0, 0.3)→1, [0.3, 0.51)→2, [0.51, 0.657)→3, etc.",
                              "finalVerifications": [
                                "Derivação correta da CDF inversa para Bernoulli com qualquer p ∈ (0,1).",
                                "Lista precisa de intervalos iniciais para Geométrica (pelo menos 5).",
                                "Simulação manual com 10 u's reproduz probabilidades teóricas.",
                                "Gráfico da CDF em degraus com inversa sobreposta.",
                                "Pseudocódigo funcional para implementação computacional.",
                                "Tratamento correto de casos edge (u=0, u=1)."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos de CDF e intervalos (100% correto).",
                                "Clareza na identificação e notação dos intervalos probabilísticos.",
                                "Validação via simulação: frequências dentro de 10% da PMF.",
                                "Completude: todos valores possíveis de X cobertos sem sobreposição.",
                                "Generalização: funciona para p arbitrário, não só numérico.",
                                "Visualização: gráfico ou tabela auxiliares claros."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: Base para testes de hipóteses e bootstrap.",
                                "Programação Computacional: Implementação em Python (numpy.random) para simulações.",
                                "Ciência de Dados: Geração de datasets sintéticos para machine learning.",
                                "Engenharia: Modelagem de falhas em sistemas de confiabilidade.",
                                "Física Computacional: Simulações estocásticas em processos Markovianos."
                              ],
                              "realWorldApplication": "Em simulações Monte Carlo para prever falhas em testes de software (Bernoulli para sucesso/falha), ou modelar tempo até detecção de defeitos em manufatura (Geométrica), gerando milhares de cenários realistas em ferramentas como R ou Python para otimizar processos industriais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.1.3",
                            "name": "Implementar algoritmo em pseudocódigo",
                            "description": "Escrever pseudocódigo que gera uma amostra de uma distribuição discreta genérica usando transformação inversa, incluindo geração de U e comparação com probabilidades cumulativas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir os parâmetros da distribuição discreta",
                                  "subSteps": [
                                    "Identifique os valores possíveis da variável aleatória discreta (ex: x1, x2, ..., xn).",
                                    "Liste as probabilidades associadas a cada valor (p1, p2, ..., pn), garantindo que somem 1.",
                                    "Valide que a soma das probabilidades é exatamente 1.0.",
                                    "Documente os valores e probabilidades em arrays ou estruturas no pseudocódigo.",
                                    "Considere casos especiais como distribuições finitas ou com suporte infinito truncado."
                                  ],
                                  "verification": "Verifique se os arrays de valores e probabilidades estão corretamente definidos e somam 1.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel e caneta ou editor de texto para listar valores e probs; calculadora para soma.",
                                  "tips": "Use índices baseados em 1 para facilitar a intuição probabilística.",
                                  "learningObjective": "Compreender e representar formalmente uma distribuição discreta genérica.",
                                  "commonMistakes": "Esquecer de normalizar probabilidades ou incluir valores com probabilidade zero desnecessariamente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a função de distribuição cumulativa (CDF)",
                                  "subSteps": [
                                    "Crie um array cumulativo iniciando com p1 para o primeiro valor.",
                                    "Para cada i subsequente, compute CDF[i] = CDF[i-1] + p_i.",
                                    "Garanta precisão numérica somando em ordem crescente para minimizar erros de ponto flutuante.",
                                    "Armazene o CDF em um array paralelo aos valores x.",
                                    "Teste manualmente com soma para confirmar que CDF[n] ≈ 1.0."
                                  ],
                                  "verification": "Confirme que o último valor do CDF é aproximadamente 1.0 e valores são não-decrescentes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de pseudocódigo ou planilha para cálculos iniciais.",
                                  "tips": "Use loop for para acumular somas de forma eficiente.",
                                  "learningObjective": "Construir a CDF cumulativa necessária para o método de inversão.",
                                  "commonMistakes": "Inverter a ordem de acumulação ou usar probabilidades não normalizadas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar o número aleatório uniforme U",
                                  "subSteps": [
                                    "Inclua uma função para gerar U ~ Uniform(0,1), excluindo 1.",
                                    "Especifique que U deve ser no intervalo [0,1).",
                                    "No pseudocódigo, use uma chamada como 'U ← RandomUniform(0,1)'.",
                                    "Discuta dependência de gerador de números aleatórios de qualidade.",
                                    "Adicione comentário sobre sementes para reprodutibilidade em testes."
                                  ],
                                  "verification": "Simule geração de U e confirme que está entre 0 e 1 (exclusivo de 1).",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Documentação de geradores aleatórios ou simulador online.",
                                  "tips": "Evite U=1 para prevenir loops infinitos em distribuições com cauda infinita.",
                                  "learningObjective": "Integrar geração de uniforme como base para transformação.",
                                  "commonMistakes": "Gerar U incluindo 1.0 ou usar inteiro em vez de contínuo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar a lógica de inversão e seleção",
                                  "subSteps": [
                                    "Inicie um loop ou use busca linear para encontrar o menor i tal que CDF[i] >= U.",
                                    "Para cada i de 1 a n, compare U com CDF[i] e retorne x_i quando verdadeiro.",
                                    "Trate casos onde U > CDF[n] (raros devido a precisão).",
                                    "Saia do loop retornando o valor x_i selecionado.",
                                    "Adicione tratamento para distribuições com suporte infinito se aplicável."
                                  ],
                                  "verification": "Trace o algoritmo com U específico e confirme seleção correta pelo CDF.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel para traçar fluxogramas; debugger mental.",
                                  "tips": "Use busca binária para eficiência em n grande, mas linear para simplicidade.",
                                  "learningObjective": "Aplicar inversão da CDF para amostragem discreta.",
                                  "commonMistakes": "Usar > em vez de >= ou indexação off-by-one."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Escrever e formatar o pseudocódigo completo",
                                  "subSteps": [
                                    "Combine todos os elementos em uma função coesa, ex: function InverseTransformSample().",
                                    "Adicione comentários explicativos em cada seção.",
                                    "Inclua entrada (arrays x e p) e saída (amostra gerada).",
                                    "Formate com indentação clara e convenções de pseudocódigo padrão.",
                                    "Teste logicamente com 3-5 valores de U diferentes."
                                  ],
                                  "verification": "Revise o pseudocódigo inteiro por completude e ausência de erros lógicos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de texto com sintaxe highlight para pseudocódigo.",
                                  "tips": "Use palavras-chave como ALGORITMO, INÍCIO, FIM para clareza.",
                                  "learningObjective": "Produzir pseudocódigo legível e implementável.",
                                  "commonMistakes": "Faltarem comentários ou estrutura desorganizada."
                                }
                              ],
                              "practicalExample": "Para distribuição com valores [1,2,3] e probs [0.2, 0.5, 0.3], CDF = [0.2, 0.7, 1.0]. Se U=0.4, encontre i=2 pois 0.4 < 0.7 mas >=0.2? Não: menor i com CDF[i]>=0.4 é i=2 (0.7>=0.4). Retorne 2.",
                              "finalVerifications": [
                                "Pseudocódigo gera amostras que respeitam as probabilidades originais em múltiplas runs.",
                                "Lógica de loop para corretamente no pior caso (U próximo de 1).",
                                "Tratamento de precisão numérica (CDF[n]=1.0).",
                                "Comentários cobrem cada seção crítica.",
                                "Teste com U=0.0 retorna primeiro valor; U próximo de 1 retorna último.",
                                "Sem loops infinitos ou condições de parada falhas."
                              ],
                              "assessmentCriteria": [
                                "Correção lógica: Inversão da CDF implementada precisamente (peso 30%).",
                                "Clareza e legibilidade do pseudocódigo (peso 25%).",
                                "Completude: Todos parâmetros e casos edge tratados (peso 20%).",
                                "Eficiência: Busca apropriada para tamanho n (peso 15%).",
                                "Documentação: Comentários explicativos úteis (peso 10%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Estruturas de loop e arrays em linguagens como Python/R.",
                                "Probabilidade: Compreensão de CDF e propriedades de distribuições.",
                                "Estatística: Validação de amostras via testes qui-quadrado.",
                                "Ciências de Computação: Algoritmos de simulação e geradores aleatórios."
                              ],
                              "realWorldApplication": "Usado em simulações Monte Carlo para modelar eventos discretos como falhas em sistemas (engenharia de confiabilidade), geração de cenários em finanças (modelos de risco), ou simulações em jogos (probabilidades de eventos raros)."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.2",
                        "name": "Método da Tabela de Frequências Cumulativas",
                        "description": "Abordagem prática para distribuições discretas com suporte finito, construindo uma tabela de probabilidades cumulativas e usando comparação direta com números uniformes.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.2.1",
                            "name": "Construir tabela de probabilidades cumulativas",
                            "description": "Para uma distribuição discreta dada (ex: dados viciados), calcular e organizar a tabela com valores de X, p(X) e F(X), verificando que a soma das probabilidades seja 1.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar os valores possíveis de X e suas probabilidades p(X)",
                                  "subSteps": [
                                    "Analise a descrição da distribuição discreta fornecida (ex: dados viciados com faces 1-6).",
                                    "Liste todos os valores possíveis de X em ordem crescente.",
                                    "Atribua ou extraia as probabilidades p(X) para cada valor de X.",
                                    "Registre as probabilidades em uma tabela inicial com colunas X e p(X).",
                                    "Confirme que todas as probabilidades são valores entre 0 e 1."
                                  ],
                                  "verification": "Verifique se a lista de X está completa, ordenada e sem duplicatas, e se p(X) somam inicialmente sem erros óbvios.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta ou planilha Excel/Google Sheets",
                                    "Descrição da distribuição discreta"
                                  ],
                                  "tips": "Sempre ordene X do menor para o maior para facilitar cálculos cumulativos.",
                                  "learningObjective": "Compreender e extrair os componentes básicos de uma distribuição discreta.",
                                  "commonMistakes": [
                                    "Esquecer valores de X improváveis mas possíveis",
                                    "Confundir p(X) com frequências absolutas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar a soma total das probabilidades p(X)",
                                  "subSteps": [
                                    "Some todas as probabilidades p(X) listadas.",
                                    "Calcule a soma usando adição manual ou calculadora.",
                                    "Compare o resultado com 1 (ou 100%).",
                                    "Se não for exatamente 1, identifique e corrija erros nas p(X).",
                                    "Registre a soma verificada na tabela."
                                  ],
                                  "verification": "A soma deve ser exatamente 1; teste com uma soma alternativa para confirmação.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Calculadora ou software de planilhas",
                                    "Tabela inicial de X e p(X)"
                                  ],
                                  "tips": "Use precisão decimal (ex: 0.333 em vez de 1/3) para evitar erros de arredondamento.",
                                  "learningObjective": "Garantir a validade probabilística da distribuição.",
                                  "commonMistakes": [
                                    "Arredondamentos que desviam a soma de 1",
                                    "Esquecer de somar todas as p(X)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular as probabilidades cumulativas F(X)",
                                  "subSteps": [
                                    "Para o primeiro X (menor), F(X1) = p(X1).",
                                    "Para cada X subsequente, F(Xi) = F(Xi-1) + p(Xi).",
                                    "Calcule sequencialmente até o último X.",
                                    "Verifique que F(X) é não decrescente e F(X_final) = 1.",
                                    "Adicione a coluna F(X) à tabela."
                                  ],
                                  "verification": "F(X) deve aumentar ou permanecer igual, culminando em 1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela com X e p(X)",
                                    "Calculadora"
                                  ],
                                  "tips": "Pense em F(X) como a probabilidade de X ser menor ou igual ao valor atual.",
                                  "learningObjective": "Dominar o cálculo da função de distribuição cumulativa (CDF).",
                                  "commonMistakes": [
                                    "Reiniciar a soma em vez de acumular",
                                    "Usar subtração em vez de adição"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Organizar a tabela final e realizar verificações finais",
                                  "subSteps": [
                                    "Formate a tabela com colunas: X, p(X), F(X).",
                                    "Alinhe valores numericamente e adicione rótulos claros.",
                                    "Verifique soma de p(X) = 1 e F(X_last) = 1.",
                                    "Confirme monotonicidade: F(Xi) >= F(Xi-1).",
                                    "Teste com um exemplo simples para validar."
                                  ],
                                  "verification": "Tabela legível, somas corretas e propriedades probabilísticas atendidas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Planilha ou papel quadriculado",
                                    "Tabela parcial completa"
                                  ],
                                  "tips": "Use formatação condicional em planilhas para destacar desvios.",
                                  "learningObjective": "Apresentar resultados de forma profissional e verificável.",
                                  "commonMistakes": [
                                    "Tabela desorganizada ou sem rótulos",
                                    "Ignorar verificações de monotonicidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Para dados viciados: X = [1,2,3,4,5,6], p(X) = [0.1, 0.15, 0.2, 0.25, 0.2, 0.1]. Soma p(X)=1. F(X): 0.1, 0.25, 0.45, 0.70, 0.90, 1.00. Tabela: | X | p(X) | F(X) | etc.",
                              "finalVerifications": [
                                "Soma de todas p(X) equals 1.",
                                "F(X) é não decrescente para X crescentes.",
                                "F(X_last) = 1.",
                                "Todos p(X) >= 0 e <=1.",
                                "Tabela organizada com colunas corretas e ordenada por X.",
                                "Nenhum valor de X duplicado ou faltante."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de p(X) e F(X) (sem erros aritméticos).",
                                "Verificação completa da soma e propriedades cumulativas.",
                                "Clareza e formatação da tabela final.",
                                "Explicação correta do processo em palavras.",
                                "Aplicação correta a um exemplo não fornecido.",
                                "Identificação e correção de erros hipotéticos."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar em Python com pandas para simulações.",
                                "Estatística: Usar em testes de hipóteses e modelagem.",
                                "Ciência de Dados: Base para geração de amostras aleatórias.",
                                "Física: Modelar distribuições em experimentos quânticos discretos."
                              ],
                              "realWorldApplication": "Em simulações de Monte Carlo para previsão de falhas em sistemas (ex: probabilidade cumulativa de defeitos em produção), ou em jogos de azar para análise de distribuições viciadas, permitindo geração eficiente de variáveis aleatórias discretas em software de simulação."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.2.2",
                            "name": "Aplicar comparação sequencial com U",
                            "description": "Dado um U gerado, percorrer a tabela cumulativa para encontrar o menor k tal que F(k) ≥ U, simulando múltiplas amostras e analisando a distribuição gerada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Construir a Tabela de Frequências Cumulativas (F(k))",
                                  "subSteps": [
                                    "Liste todos os valores possíveis discretos k de X e suas probabilidades p(k), garantindo que ∑p(k)=1.",
                                    "Inicialize F(0)=0.",
                                    "Calcule F(k) = F(k-1) + p(k) para cada k em ordem crescente.",
                                    "Verifique se F(max k)=1 e se a tabela é estritamente crescente ou não-decrescente.",
                                    "Registre a tabela em uma planilha ou papel para uso posterior."
                                  ],
                                  "verification": "Confirme que todos F(k) estão corretos, somam a 1 no final e são não-decrescentes.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel e caneta, planilha (Excel/Google Sheets) ou editor de código simples.",
                                  "tips": "Use frações exatas para probabilidades para evitar erros de arredondamento.",
                                  "learningObjective": "Compreender e construir a função de distribuição cumulativa (CDF) para variáveis discretas.",
                                  "commonMistakes": "Esquecer de inicializar F(0)=0; somar probabilidades incorretamente; inverter ordem dos k."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar U e Aplicar Comparação Sequencial para Uma Amostra",
                                  "subSteps": [
                                    "Gere um número aleatório U ~ Uniforme(0,1) usando calculadora, software ou gerador randômico.",
                                    "Comece com k=1 e percorra a tabela sequencialmente.",
                                    "Encontre o menor k tal que F(k) ≥ U.",
                                    "Registre o valor de k gerado e o U usado.",
                                    "Repita uma vez manualmente para prática."
                                  ],
                                  "verification": "Verifique se o k encontrado satisfaz F(k-1) < U ≤ F(k), ou F(0)<U≤F(1) para k=1.",
                                  "estimatedTime": "8 minutos",
                                  "materials": "Calculadora com função rand (ou Python random.uniform(0,1)), tabela do Step 1.",
                                  "tips": "Lembre-se: U está em (0,1], então sempre haverá um k válido.",
                                  "learningObjective": "Aplicar o algoritmo de comparação sequencial para gerar uma única observação discreta.",
                                  "commonMistakes": "Parar no primeiro F(k) > U em vez de ≥; confundir com método da inversa exata."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular Múltiplas Amostras Usando o Método",
                                  "subSteps": [
                                    "Defina o número de simulações N (ex: 100 ou 1000).",
                                    "Para cada i=1 a N: gere U_i, aplique comparação sequencial para obter k_i.",
                                    "Registre todos os k_i em uma lista ou tabela de contagens.",
                                    "Use um loop manual para N pequeno ou script para N grande.",
                                    "Salve os resultados em formato tabular (k e frequência)."
                                  ],
                                  "verification": "Confirme que todas as N amostras foram geradas sem erros e contagens somam N.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Software de programação (Python com random e listas), ou planilha com RAND().",
                                  "tips": "Para eficiência, implemente em loop; teste com N=10 primeiro.",
                                  "learningObjective": "Executar simulações em massa para aproximar a distribuição original via Lei dos Grandes Números.",
                                  "commonMistakes": "Gerar U's não-uniformes; erros de indexação em loops; não resetar contadores."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar a Distribuição Gerada e Validar",
                                  "subSteps": [
                                    "Calcule as frequências relativas: freq(k)/N para cada k.",
                                    "Compare com as p(k) originais (diferença absoluta ou qui-quadrado simples).",
                                    "Plote histograma das amostras vs. barras de p(k).",
                                    "Calcule média e variância das amostras e compare com teóricas.",
                                    "Conclua se a simulação converge para a distribuição alvo."
                                  ],
                                  "verification": "Frequências relativas aproximam p(k) dentro de ±5% para N=1000.",
                                  "estimatedTime": "12 minutos",
                                  "materials": "Planilha ou Python (matplotlib para plots, numpy para stats).",
                                  "tips": "Aumente N se a aproximação for ruim; use semente randômica para reprodutibilidade.",
                                  "learningObjective": "Avaliar a qualidade da simulação e entender convergência empírica.",
                                  "commonMistakes": "Ignorar flutuações para N pequeno; comparar frequências absolutas em vez de relativas."
                                }
                              ],
                              "practicalExample": "Considere X com P(X=1)=0.2, P(X=2)=0.3, P(X=3)=0.5. Tabela: F(1)=0.2, F(2)=0.5, F(3)=1.0. Para U=0.4, percorra: F(1)=0.2 <0.4, F(2)=0.5 ≥0.4 → k=2. Simule N=100: conte freqs ≈20% k=1, 30% k=2, 50% k=3.",
                              "finalVerifications": [
                                "Tabela F(k) correta e completa.",
                                "Todas amostras k válidas com F(k) ≥ U > F(k-1).",
                                "Frequências relativas das simulações aproximam p(k) originais.",
                                "Análise estatística (média/variância) consistente com teórica.",
                                "Gráfico visual confirma convergência.",
                                "Nenhuma amostra inválida ou fora do suporte."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção da tabela cumulativa (100% correto).",
                                "Correta implementação do algoritmo sequencial sem erros lógicos.",
                                "Eficiência e escalabilidade na simulação de múltiplas amostras.",
                                "Qualidade da análise comparativa (métricas quantitativas usadas).",
                                "Interpretação clara da convergência e limitações.",
                                "Uso adequado de ferramentas e documentação dos resultados."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em loops e funções (Python/R).",
                                "Estatística: Validação via teste qui-quadrado e Lei dos Grandes Números.",
                                "Ciência de Dados: Simulações Monte Carlo para modelagem.",
                                "Probabilidade: Entendimento profundo de CDF e geração aleatória."
                              ],
                              "realWorldApplication": "Em simulações de risco financeiro (gerar defaults de empréstimos discretos), modelagem de tráfego (eventos discretos), jogos de azar (dados/cartas), e bioinformática (sequências genéticas discretas)."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.2.3",
                            "name": "Avaliar eficiência computacional",
                            "description": "Comparar o tempo de execução com o método inverso para suportes grandes, discutindo otimizações como busca binária na tabela.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender e Implementar o Método da Tabela de Frequências Cumulativas",
                                  "subSteps": [
                                    "Revise a definição de frequências cumulativas para uma variável aleatória discreta com suporte finito.",
                                    "Construa a tabela de frequências cumulativas normalizadas (probabilidades cumulativas).",
                                    "Implemente o algoritmo em Python: gere U ~ Uniform(0,1) e encontre o menor i tal que F(i) >= U via busca linear.",
                                    "Teste com um suporte pequeno (ex: 10 valores) para validar a geração correta.",
                                    "Registre o código fonte e saídas iniciais."
                                  ],
                                  "verification": "Execute o código com 1000 amostras e verifique se a distribuição empírica das amostras corresponde às probabilidades teóricas (use histograma e teste qui-quadrado básico).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com NumPy e Matplotlib",
                                    "Editor de código (Jupyter Notebook recomendado)",
                                    "Documentação de distribuições discretas (ex: Poisson)"
                                  ],
                                  "tips": "Use loops simples para busca linear inicialmente; normalize probabilidades para somar 1.",
                                  "learningObjective": "Implementar corretamente o método da tabela cumulativa e validar sua saída.",
                                  "commonMistakes": [
                                    "Não normalizar probabilidades (soma !=1)",
                                    "Índice off-by-one na busca",
                                    "Usar busca binária prematuramente sem entender linear"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o Método da Função Inversa para Comparação",
                                  "subSteps": [
                                    "Defina a função cumulativa F(x) e sua inversa F^{-1}(u) para a mesma distribuição discreta.",
                                    "Implemente o algoritmo inverso: gere U e encontre F^{-1}(U) diretamente.",
                                    "Para suporte discreto, compute a inversa via busca ou fórmula explícita se possível.",
                                    "Teste com o mesmo suporte pequeno usado no Step 1 para igualar condições.",
                                    "Compare qualitativamente as implementações lado a lado."
                                  ],
                                  "verification": "Gere 1000 amostras com ambos métodos e confirme que as distribuições empíricas são estatisticamente idênticas (teste Kolmogorov-Smirnov).",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Mesmo ambiente Python do Step 1",
                                    "Funções SciPy para testes estatísticos (opcional)"
                                  ],
                                  "tips": "Para inversa discreta, use a definição: menor x tal que F(x) >= u, similar ao cumulativo mas otimizado.",
                                  "learningObjective": "Dominar o método inverso e preparar base para comparação de eficiência.",
                                  "commonMistakes": [
                                    "Confundir inversa contínua com discreta",
                                    "Implementar busca ineficiente no inverso",
                                    "Ignorar normalização"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Medir e Comparar Tempos de Execução para Suportes Grandes",
                                  "subSteps": [
                                    "Gere uma distribuição com suporte grande (ex: 10^4 a 10^5 valores, como Poisson com λ alto).",
                                    "Meça tempo de execução de ambos métodos para N=10^6 amostras usando timeit ou %timeit no Jupyter.",
                                    "Repita medições 10 vezes e compute média, desvio padrão dos tempos.",
                                    "Plote tempos vs. tamanho do suporte (varie de 10^2 a 10^5).",
                                    "Analise: O(n) linear no cumulativo vs. O(log n) potencial no inverso."
                                  ],
                                  "verification": "Tabela ou gráfico mostrando tempo cumulativo ~ k*n (linear em n=suporte) vs. inverso mais estável; diferença significativa para n>10^4.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python timeit module",
                                    "Pandas para tabulação de resultados",
                                    "Matplotlib para gráficos"
                                  ],
                                  "tips": "Use np.random.uniform em vetorizado para fair comparison; isole o loop de busca.",
                                  "learningObjective": "Quantificar empiricamente a ineficiência do método cumulativo linear para suportes grandes.",
                                  "commonMistakes": [
                                    "Não isolar o tempo da busca (incluir geração U)",
                                    "Amostras insuficientes para medição precisa",
                                    "Ignorar overhead de Python em loops"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir Otimizações como Busca Binária na Tabela Cumulativa",
                                  "subSteps": [
                                    "Modifique o método cumulativo para usar bisect (busca binária) na tabela cumulativa ordenada.",
                                    "Implemente com bisect.bisect_left do módulo bisect.",
                                    "Meça tempos novamente para o cumulativo otimizado vs. original e inverso.",
                                    "Compare complexidades: O(log n) vs. O(n) e discuta trade-offs (memória vs. tempo).",
                                    "Documente relatório com gráficos, tabelas e conclusões."
                                  ],
                                  "verification": "Tempo do cumulativo binário próximo ao inverso, ambos O(log n), com speedup >10x para n=10^5 vs. linear.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Módulo bisect do Python stdlib",
                                    "Mesmos tools de medição"
                                  ],
                                  "tips": "Mantenha tabela cumulativa como array NumPy ordenado; bisect funciona perfeitamente.",
                                  "learningObjective": "Aplicar e validar otimizações computacionais para melhorar eficiência.",
                                  "commonMistakes": [
                                    "Não ordenar tabela",
                                    "Usar bisect em lista não-numérica",
                                    "Esquecer import bisect"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere gerar 1 milhão de amostras de uma distribuição Poisson(λ=20) com suporte efetivo ~100 valores. Método linear cumulativo leva ~5s, inverso ~0.1s, binário ~0.15s em hardware padrão. Ploteu tempos confirmando escalabilidade.",
                              "finalVerifications": [
                                "Implementações de ambos métodos geram distribuições corretas (teste KS p>0.05).",
                                "Medições mostram degradação linear no cumulativo para n>10^4.",
                                "Otimizado com binário atinge speedup mensurável (>5x).",
                                "Relatório escrito explica Big-O e resultados empíricos.",
                                "Código reproduzível e versionado (ex: GitHub snippet).",
                                "Gráficos de tempo vs. suporte visualizam diferenças."
                              ],
                              "assessmentCriteria": [
                                "Precisão das implementações (distribuições corretas: 25%)",
                                "Qualidade das medições de tempo (repetições, estatísticas: 25%)",
                                "Análise de complexidade e otimizações (25%)",
                                "Clareza do relatório e visualizações (15%)",
                                "Código limpo, comentado e eficiente (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Ciência da Computação: Análise de Algoritmos (Big-O, busca binária)",
                                "Estatística: Validação de geradores pseudo-aleatórios",
                                "Programação: Otimização de performance em Python/NumPy",
                                "Física Computacional: Simulações Monte Carlo eficientes"
                              ],
                              "realWorldApplication": "Em simulações financeiras (modelos de risco com estados discretos grandes), jogos (geração de eventos raros), bioinformática (sequências genéticas discretas), onde suportes grandes demandam eficiência para bilhões de amostras."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.3",
                        "name": "Métodos Específicos para Distribuições Discretas Comuns",
                        "description": "Algoritmos otimizados para gerar variáveis de distribuições como Binomial, Poisson e Multinomial usando combinações de uniformes e recursões eficientes.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.3.1",
                            "name": "Gerar variáveis Bernoulli e Binomial",
                            "description": "Implementar geração de Bernoulli via comparação U < p e extensão para Binomial via soma de Bernoullis independentes ou método proporcional.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender e implementar geração de variável Bernoulli",
                                  "subSteps": [
                                    "Estude a definição: Bernoulli(p) gera 1 com probabilidade p e 0 com 1-p.",
                                    "Aprenda o método inverso: Gere U ~ Uniforme(0,1), se U < p então X=1, senão X=0.",
                                    "Implemente uma função em Python usando random.uniform(0,1).",
                                    "Teste manualmente com p=0.3, gere 10 amostras e observe a frequência aproximada.",
                                    "Registre os resultados em uma lista para análise posterior."
                                  ],
                                  "verification": "Execute a função 100 vezes e verifique se a proporção de 1's está próxima de p (erro <5%).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python instalado",
                                    "Biblioteca random (import random)"
                                  ],
                                  "tips": "Sempre normalize U para (0,1) excluindo 0 e 1 para evitar ambiguidades.",
                                  "learningObjective": "Implementar corretamente o gerador de Bernoulli usando método de inversa da CDF.",
                                  "commonMistakes": [
                                    "Usar random.random() sem verificar range",
                                    "Confundir p com 1-p",
                                    "Não importar random"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Validar o gerador Bernoulli empiricamente",
                                  "subSteps": [
                                    "Gere N=1000 amostras de Bernoulli(p=0.5).",
                                    "Calcule a média empírica e compare com E[X]=p.",
                                    "Calcule variância empírica e compare com Var(X)=p(1-p).",
                                    "Crie um histograma simples com matplotlib.",
                                    "Analise desvios e discuta lei dos grandes números."
                                  ],
                                  "verification": "Média empírica dentro de ±0.05 de p e variância próxima da teórica.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python",
                                    "matplotlib (pip install matplotlib)",
                                    "numpy opcional"
                                  ],
                                  "tips": "Use seed para reproducibilidade: random.seed(42).",
                                  "learningObjective": "Validar propriedades estatísticas do gerador via simulação.",
                                  "commonMistakes": [
                                    "Amostra pequena (N<1000)",
                                    "Erro em cálculo de variância (use np.var com ddof=1)",
                                    "Ignorar seed"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estender para Binomial via soma de Bernoullis independentes",
                                  "subSteps": [
                                    "Defina Binomial(n,p) como soma de n Bernoullis independentes.",
                                    "Implemente função binomial_indep(n,p): loop n vezes chamando bernoulli(p).",
                                    "Teste com n=10, p=0.5, gere 1000 amostras.",
                                    "Calcule média empírica (deve ≈ np) e variância (≈np(1-p)).",
                                    "Compare histograma com PMF teórica."
                                  ],
                                  "verification": "Propriedades empíricas coincidem com teóricas dentro de 5% para N=1000.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Código do Step 1 e 2",
                                    "matplotlib"
                                  ],
                                  "tips": "Para eficiência, vetorize com numpy.random.binomial se disponível, mas implemente manual primeiro.",
                                  "learningObjective": "Construir Binomial a partir de Bernoullis para entender independência.",
                                  "commonMistakes": [
                                    "Corrigir independência (use loops separados)",
                                    "Exceder tempo computacional com n grande",
                                    "Confundir soma com multiplicação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar método proporcional (CDF inversa) para Binomial",
                                  "subSteps": [
                                    "Calcule a CDF cumulativa F(k) = P(X≤k) para k=0 a n.",
                                    "Gere U~Uniform(0,1), encontre menor k tal que F(k) ≥ U.",
                                    "Implemente em código: pré-calcule pmf e cdf arrays.",
                                    "Teste com n=20, p=0.3, compare com método soma.",
                                    "Meça tempo de execução para eficiência."
                                  ],
                                  "verification": "Resultados idênticos aos do método soma em distribuições empíricas.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "numpy para arrays",
                                    "scipy.stats.binom opcional para validação"
                                  ],
                                  "tips": "Use loop cumulativo para cdf: cdf[k] = cdf[k-1] + pmf[k].",
                                  "learningObjective": "Dominar método geral de inversa CDF para discretas.",
                                  "commonMistakes": [
                                    "Erro de arredondamento em pmf (use log para grandes n)",
                                    "Índice off-by-one no loop de busca",
                                    "Não normalizar pmf"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Comparar métodos e otimizar",
                                  "subSteps": [
                                    "Gere 10k amostras com ambos métodos para n=50.",
                                    "Compare tempo (timeit) e qualidade (KS test se possível).",
                                    "Discuta trade-offs: soma simples mas lenta para n grande.",
                                    "Otimize soma vetorizando com numpy.",
                                    "Documente código em notebook Jupyter."
                                  ],
                                  "verification": "Códigos funcionam, tempos medidos, relatório de comparação escrito.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Jupyter notebook",
                                    "timeit module"
                                  ],
                                  "tips": "Para KS: from scipy.stats import kstest.",
                                  "learningObjective": "Avaliar e escolher métodos baseados em eficiência e precisão.",
                                  "commonMistakes": [
                                    "Ignorar vetorização",
                                    "Amostras insuficientes para comparação",
                                    "Não usar seed consistente"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule o número de sucessos em 10 tentativas de um teste A/B onde p=0.4 é taxa de conversão. Gere 500 simulações Binomial(10,0.4) para estimar distribuição de conversões semanais em marketing digital.",
                              "finalVerifications": [
                                "Gerar 5000 amostras Bernoulli(p=0.7): média ≈0.7, var≈0.21.",
                                "Binomial(20,0.5) via soma: histograma bimodal centrado em 10.",
                                "Método proporcional reproduz soma com KS p-value >0.05.",
                                "Tempo soma <1s para 10k amostras n=10; proporcional mais rápido para n=100.",
                                "Código modular: funções bernoulli(), binomial_soma(), binomial_cdf().",
                                "Relatório com plots e métricas salvas."
                              ],
                              "assessmentCriteria": [
                                "Código executável sem erros e comentado.",
                                "Propriedades empíricas dentro de 3% das teóricas para N≥1000.",
                                "Ambos métodos implementados corretamente.",
                                "Uso eficiente de loops e vetorização.",
                                "Análise comparativa com evidências (plots/tempos).",
                                "Entendimento demonstrado em verificações finais."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Estruturas de loop, funções, vetores NumPy.",
                                "Estatística: Lei dos Grandes Números, propriedades de momentos.",
                                "Simulações: Base para Monte Carlo em Física/Finanças.",
                                "Ciência de Dados: Geração de dados sintéticos para ML.",
                                "Probabilidade: CDF inversa aplicável a Poisson, etc."
                              ],
                              "realWorldApplication": "Em análise de risco financeiro para simular defaults em portfólios (Binomial para número de inadimplentes); em controle de qualidade para modelar defeitos em lotes de produção; em epidemiologia para simular infecções binárias em populações."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.3.2",
                            "name": "Simular distribuição de Poisson",
                            "description": "Usar o método dos intervalos exponenciais (produto de uniformes até exceder λ) ou tabela cumulativa para gerar amostras de Poisson(λ).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Teoria dos Métodos para Simular Poisson(λ)",
                                  "subSteps": [
                                    "Revise a função massa de probabilidade da distribuição Poisson(λ): P(X=k) = e^{-λ} λ^k / k!.",
                                    "Estude o processo de Poisson como número de eventos em tempo λ com taxa 1, baseado em interarrivos exponenciais.",
                                    "Aprenda o método dos intervalos exponenciais: gere U_i ~ Uniform(0,1), compute produto P = ∏ U_i até P < e^{-λ}, retorne k-1.",
                                    "Entenda o método da inversa cumulativa: compute CDF F(k;λ) para k=0,1,... até encontrar menor k com F(k) >= U.",
                                    "Compare eficiência: produtos para λ grande, inversa para λ pequeno."
                                  ],
                                  "verification": "Descreva os dois métodos em pseudocódigo e explique por que funcionam probabilisticamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Notas de probabilidade",
                                    "Referência: Devroye 'Non-Uniform Random Variate Generation'",
                                    "Calculadora para e^{-λ}"
                                  ],
                                  "tips": [
                                    "Desenhe um diagrama temporal para o processo de Poisson.",
                                    "Teste manual para λ=1 com 2-3 U_i."
                                  ],
                                  "learningObjective": "Dominar a fundamentação teórica dos métodos de geração de Poisson.",
                                  "commonMistakes": [
                                    "Confundir retorno k vs k-1 no método de produtos.",
                                    "Usar Uniform(0,1) inclusive em 0 ou 1 causando log(0).",
                                    "Ignorar overflow em produtos para λ muito grande."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o Método dos Produtos de Uniformes",
                                  "subSteps": [
                                    "Escreva uma função geradora de Uniform(0,1) confiável.",
                                    "Inicialize k=0, P=1.0; gere U ~ Uniform(0,1), multiplique P *= U, incremente k até P < exp(-λ).",
                                    "Retorne k-1 como amostra X.",
                                    "Adicione tratamento para λ=0 (retorne 0) e λ muito pequeno.",
                                    "Teste com λ=2, gere 20 amostras manualmente ou em código simples."
                                  ],
                                  "verification": "Execute a função 50 vezes para λ=3 e verifique se amostras estão entre 0 e 10 tipicamente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python ou R com random.uniform",
                                    "Editor de código (Jupyter Notebook)",
                                    "Biblioteca math para exp"
                                  ],
                                  "tips": [
                                    "Use while P >= math.exp(-lambda_): para evitar underflow.",
                                    "Evite U=0 com uniform(1e-10,1)."
                                  ],
                                  "learningObjective": "Codificar corretamente o algoritmo eficiente para qualquer λ.",
                                  "commonMistakes": [
                                    "Loop infinito se U=1 sempre.",
                                    "Erro de arredondamento em P muito pequeno.",
                                    "Retornar k em vez de k-1."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o Método da Tabela Cumulativa (Inversa)",
                                  "subSteps": [
                                    "Compute CDF cumulativa F(k) = sum_{i=0}^k e^{-λ} λ^i / i! até F(k) ≈1 ou k_max=3λ+10.",
                                    "Gere U ~ Uniform(0,1), encontre menor k tal que F(k) >= U via loop ou busca.",
                                    "Otimize pré-computando tabela para λ fixo.",
                                    "Implemente função recursiva ou iterativa para fatoriais e potências.",
                                    "Gere 20 amostras para λ=1 e compare com método anterior."
                                  ],
                                  "verification": "Para λ=5, verifique F(10) >0.99 e gere amostras válidas.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Mesma linguagem de programação",
                                    "Biblioteca scipy para validação (mas não use para gerar)"
                                  ],
                                  "tips": [
                                    "Use loop while cumul < U para eficiência.",
                                    "Pré-calcule tabela para múltiplas amostras."
                                  ],
                                  "learningObjective": "Aplicar método de inversa para distribuições discretas.",
                                  "commonMistakes": [
                                    "Erro numérico em fatoriais grandes (use log-gamma).",
                                    "CDF não normalizado exatamente a 1.",
                                    "Busca errada: menor k com F(k)>=U."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar Simulações e Analisar Propriedades",
                                  "subSteps": [
                                    "Gere 10000 amostras com cada método para λ=4.",
                                    "Compute estatísticas: média, variância, P(X=0), histograma.",
                                    "Compare com valores teóricos: E[X]=λ, Var=λ, P(0)=e^{-λ}.",
                                    "Plote histogramas e QQ-plot contra Poisson teórica.",
                                    "Meça tempo de execução e discuta trade-offs."
                                  ],
                                  "verification": "Relatório com tabelas: |média - λ| < 0.05, |var - λ| < 0.1.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Bibliotecas de plot: matplotlib ou ggplot",
                                    "numpy para arrays"
                                  ],
                                  "tips": [
                                    "Use seed para reprodutibilidade: random.seed(42).",
                                    "N=10000 para boa aproximação."
                                  ],
                                  "learningObjective": "Verificar corretude estatística das simulações.",
                                  "commonMistakes": [
                                    "Amostra pequena levando a viés.",
                                    "Escala errada no histograma.",
                                    "Comparar métodos sem seed igual."
                                  ]
                                }
                              ],
                              "practicalExample": "Simule o número de emails recebidos por hora em um servidor com λ=6. Gere 5000 amostras usando método de produtos, compute a probabilidade de overload (X>10) e plote histograma para visualizar picos de tráfego.",
                              "finalVerifications": [
                                "Média de 10000 amostras está dentro de 1% de λ.",
                                "Variância aproximada a λ com erro <5%.",
                                "P(X=0) estimado ≈ e^{-λ} com erro <0.02.",
                                "Histogramas dos dois métodos sobrepostos visualmente.",
                                "Tempo para 10^5 amostras <1 segundo.",
                                "Sem erros numéricos (NaN ou inf)."
                              ],
                              "assessmentCriteria": [
                                "Código executável e comentado corretamente.",
                                "Explicação teórica precisa sem falhas conceituais.",
                                "Validações estatísticas quantitativas com thresholds.",
                                "Comparação justa entre métodos com métricas.",
                                "Visualizações claras e interpretáveis.",
                                "Eficiência computacional demonstrada."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Testes de bondade de ajuste (Chi-quadrado para histograma).",
                                "Programação: Otimização de loops e vetores (numpy).",
                                "Física: Contadores Geiger para decaimento radioativo.",
                                "Engenharia: Modelagem de filas em telecomunicações.",
                                "Biologia: Número de mutações em sequências genéticas."
                              ],
                              "realWorldApplication": "Simulação de eventos raros como falhas em sistemas (ex: crashes de software), tráfego de pacotes em redes, chegadas de clientes em lojas ou chamadas em call centers para planejamento de recursos e previsão de picos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.3.3",
                            "name": "Gerar variáveis Multinomiais",
                            "description": "Aplicar método Dirichlet-Multinomial ou decomposição sequencial de uniformes para simular vetores multinomiais com probabilidades dadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Distribuição Multinomial",
                                  "subSteps": [
                                    "Defina a distribuição multinomial: um vetor X = (X1, ..., Xk) onde soma Xi = n e P(X=x) = [n! / (x1! ... xk!)] * (p1^{x1} * ... * pk^{xk}).",
                                    "Compare com binomial (k=2) e categórica (n=1).",
                                    "Discuta propriedades: E[Xi] = n*pi, Var(Xi) = n*pi*(1-pi), covariâncias negativas.",
                                    "Explore quando usar: modelagem de contagens em k categorias independentes.",
                                    "Revise geração de uniformes e binomiais como blocos de construção."
                                  ],
                                  "verification": "Resuma em um parágrafo as propriedades chave e dê um exemplo simples com k=3, n=10.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Livro de probabilidade (ex: Ross), notebook Jupyter, calculadora.",
                                  "tips": "Visualize com histogramas de amostras simuladas para intuitar a forma.",
                                  "learningObjective": "Entender conceitualmente a multinomial e suas relações com outras distribuições discretas.",
                                  "commonMistakes": "Confundir com distribuição conjunta de independentes categóricas sem normalizar soma para n."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o Método de Decomposição Sequencial de Uniformes via Binomiais Condicionados",
                                  "subSteps": [
                                    "Gere X1 ~ Binomial(n, p1 / (p1+...+pk)) usando scipy.stats.binom.rvs ou inverse CDF com uniforms.",
                                    "Atualize n_remaining = n - X1, probs_remaining = p2..pk normalizadas para somar 1.",
                                    "Repita sequencialmente para X2 ~ Binomial(n_remaining, p2/sum_remaining), até Xk = n_remaining.",
                                    "Codifique em função Python: def sequential_multinomial(n, p): ...",
                                    "Teste com n=100, p=[0.4,0.3,0.3], verifique soma==n."
                                  ],
                                  "verification": "Execute 1000 simulações, cheque se médias de Xi aproximam n*pi (erro <5%).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Python com NumPy, SciPy, Jupyter Notebook.",
                                  "tips": "Use loop while com k categorias, normalize probs restantes com np.cumsum ou divisão.",
                                  "learningObjective": "Dominar o algoritmo sequencial eficiente para gerar multinomiais exatas sem loops de n trials.",
                                  "commonMistakes": "Esquecer de normalizar probabilidades restantes ou usar probs originais sem atualizar."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o Método Dirichlet-Multinomial para Geração Composta",
                                  "subSteps": [
                                    "Revise Dirichlet(alpha): gera p ~ Dir(alpha), então X| p ~ Mult(n,p).",
                                    "Para probs fixas, use alpha_i proporcional a pi (ex: alpha_i = lambda * pi para grande lambda).",
                                    "Gere p via Gamma(alpha_i,1) normalizadas (pois Dir é Gamma independente normalizado).",
                                    "Amostre X ~ Mult(n, p) via método sequencial ou naive (n categóricas).",
                                    "Implemente função: def dirichlet_mult(n, alpha): p = dirichlet(alpha); return multinomial(n,p)."
                                  ],
                                  "verification": "Compare histograma de marginal de Xi com multinomial fixa; deve aproximar para alpha grandes.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Python SciPy (stats.dirichlet, stats.multinomial), NumPy.",
                                  "tips": "Para probs fixas, use alpha muito grandes para p se aproximar de fixa.",
                                  "learningObjective": "Aplicar composição Dirichlet-Multinomial para simulações bayesianas ou aproximações.",
                                  "commonMistakes": "Usar Dirichlet sem normalizar Gammas ou confundir com multinomial fixa."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar, Comparar e Otimizar Implementações",
                                  "subSteps": [
                                    "Compare tempos: naive (n categoricals), sequencial, Dirichlet-Mult vs scipy.stats.multinomial.rvs.",
                                    "Gere 10^4 amostras, plote QQ-plots vs teórico.",
                                    "Calcule estatísticas: média, variância, teste qui-quadrado para goodness-of-fit.",
                                    "Otimize código: vetorize com NumPy onde possível.",
                                    "Documente função final com docstring e exemplos."
                                  ],
                                  "verification": "Código passa testes unitários: soma sempre n, médias dentro de 2*sqrt(var/n).",
                                  "estimatedTime": "1 hora",
                                  "materials": "Python, Matplotlib/Seaborn para plots, SciPy para testes.",
                                  "tips": "Use %timeit no Jupyter para benchmarks.",
                                  "learningObjective": "Avaliar e refinar métodos de simulação para precisão e eficiência.",
                                  "commonMistakes": "Ignorar dependências entre Xi (soma fixa afeta variâncias)."
                                }
                              ],
                              "practicalExample": "Simule eleições com 1000 eleitores e probs [0.45, 0.35, 0.20] para 3 partidos. Gere 1000 simulações, estime probs vencedoras e intervalos de confiança para assentos proporcionais.",
                              "finalVerifications": [
                                "Soma dos componentes do vetor sempre igual a n.",
                                "Médias empíricas de Xi próximas a n*pi (erro relativo < 2%).",
                                "Variâncias empíricas aproximam n*pi*(1-pi).",
                                "Teste qui-quadrado aceita H0: dados ~ Mult(n,p).",
                                "Tempo de execução < 1s para 10^5 simulações.",
                                "QQ-plot linear entre quantis empíricos e teóricos."
                              ],
                              "assessmentCriteria": [
                                "Correção: soma exata n e distribuição marginal correta.",
                                "Eficiência: método sequencial mais rápido que naive para n grande.",
                                "Flexibilidade: funciona para qualquer k>=2, p soma=1.",
                                "Robustez: lida com pi=0 ou pi próximo 0 sem erros numéricos.",
                                "Documentação: código comentado com explicação dos métodos.",
                                "Validação: inclui testes automatizados."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Inferência bayesiana com Dirichlet priors.",
                                "Programação: Algoritmos numéricos e vetorização em Python.",
                                "Ciência de Dados: Simulação Monte Carlo para modelagem.",
                                "Física: Processos estocásticos em partículas (ex: decaimentos por canal)."
                              ],
                              "realWorldApplication": "Em epidemiologia, simular casos COVID por variantes (probs de transmissão); em marketing, alocar vendas por canal online/offline; em finanças, distribuir portfólio retornos por ativos com restrição total."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.3.4",
                            "name": "Validar as amostras geradas",
                            "description": "Usar testes qui-quadrado ou Kolmogorov-Smirnov para verificar se as amostras simuladas seguem a distribuição teórica alvo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a amostra simulada e a distribuição teórica",
                                  "subSteps": [
                                    "Colete ou gere a amostra simulada usando o método de geração apropriado (ex: inversa da CDF para discretas).",
                                    "Defina os parâmetros da distribuição teórica alvo (ex: para binomial, especifique n e p).",
                                    "Calcule as frequências observadas na amostra e as probabilidades teóricas esperadas para cada categoria/bin.",
                                    "Garanta que o tamanho da amostra seja suficiente (N >= 30 para qui-quadrado; maior para KS).",
                                    "Crie uma tabela comparativa de observados vs esperados."
                                  ],
                                  "verification": "Verifique se a tabela de observados e esperados soma corretamente ao tamanho da amostra e se as probabilidades teóricas somam 1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Software de programação (Python com numpy/scipy, R), dados simulados salvos em array ou CSV.",
                                  "tips": "Use funções prontas como np.random.binomial() para gerar amostras rapidamente e validar manualmente os parâmetros.",
                                  "learningObjective": "Compreender a preparação de dados para testes de adequação.",
                                  "commonMistakes": "Esquecer de normalizar probabilidades teóricas ou usar amostra muito pequena."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escolher e configurar o teste estatístico apropriado",
                                  "subSteps": [
                                    "Decida entre teste qui-quadrado (para discretas com bins) ou Kolmogorov-Smirnov (KS, para contínuas ou discretas sem bins).",
                                    "Para qui-quadrado: Defina número de bins (k >=5, esperados >=5 por bin; use regra de Sturges se necessário).",
                                    "Para KS: Ordene a amostra e compute a CDF empírica vs teórica.",
                                    "Defina nível de significância alpha (ex: 0.05).",
                                    "Implemente a fórmula ou use bibliotecas (scipy.stats.chisquare ou ks_2samp)."
                                  ],
                                  "verification": "Confirme a escolha do teste com base no tipo de distribuição e visualize bins/CDF graficamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Bibliotecas scipy.stats, matplotlib para plots; calculadora para fórmulas manuais.",
                                  "tips": "Prefira qui-quadrado para discretas com poucas categorias; KS é mais geral mas sensível a laços.",
                                  "learningObjective": "Selecionar o teste correto com base nas propriedades da distribuição.",
                                  "commonMistakes": "Usar qui-quadrado com esperados <5 em bins ou KS em dados com laços."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar o teste e calcular estatísticas",
                                  "subSteps": [
                                    "Calcule a estatística qui-quadrado: soma((O_i - E_i)^2 / E_i) para i=1 a k.",
                                    "Ou para KS: D = sup |F_n(x) - F(x)|, onde F_n é CDF empírica.",
                                    "Obtenha o p-value usando distribuição qui-quadrado com df=k-1 ou tabela KS crítica.",
                                    "Execute via código: result = chisquare(observed, expected) ou kstest(sample, 'binom', args=(n,p)).",
                                    "Registre estatística, graus de liberdade e p-value."
                                  ],
                                  "verification": "Reexecute o código ou cálculo manual para matching dos valores.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Código Python/R pronto, tabelas de distribuição qui-quadrado/KS.",
                                  "tips": "Sempre plote histograma vs PDF teórica para inspeção visual antes do teste.",
                                  "learningObjective": "Executar computações precisas de testes de adequação.",
                                  "commonMistakes": "Erro em df (esquecer -1 para qui-quadrado) ou argumentos errados na função."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados e concluir validade",
                                  "subSteps": [
                                    "Compare p-value com alpha: se p > alpha, não rejeite H0 (amostra segue distribuição).",
                                    "Analise tamanho da estatística: valores altos indicam discrepâncias específicas.",
                                    "Visualize Q-Q plot ou histograma para insights qualitativos.",
                                    "Discuta limitações (ex: qui-quadrado sensível a bins; KS a desvios nas caudas).",
                                    "Reduza parâmetros se rejeitar e reteste (ex: ajuste seed ou método)."
                                  ],
                                  "verification": "Escreva uma conclusão em 1-2 frases com p-value e decisão explícita.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Plots gerados (matplotlib/seaborn), relatório em Markdown ou notebook.",
                                  "tips": "Combine testes com gráficos: p-value alto + bom fit visual = validação forte.",
                                  "learningObjective": "Interpretar resultados estatísticos no contexto de simulação.",
                                  "commonMistakes": "Rejeitar H0 incorretamente ou ignorar múltiplos testes (ajuste Bonferroni)."
                                }
                              ],
                              "practicalExample": "Gere 1000 amostras de uma Binomial(n=10, p=0.3) usando np.random.binomial. Calcule frequências observadas (0 a 10). Use chisquare para comparar com esperados = N * binom.pmf(k,10,0.3). Se p-value=0.45 >0.05, valide; senão, investigue.",
                              "finalVerifications": [
                                "p-value > alpha (ex: 0.05) para não rejeição de H0.",
                                "Histograma da amostra sobrepõe bem à PDF teórica.",
                                "Q-Q plot mostra pontos próximos à linha diagonal.",
                                "Estatística qui-quadrado ou D_KS abaixo do crítico.",
                                "Conclusão escrita justifica decisão com evidências.",
                                "Código reproduzível gera mesmos resultados."
                              ],
                              "assessmentCriteria": [
                                "Correção na preparação de observados/esperados (100% soma).",
                                "Escolha adequada do teste com justificativa.",
                                "Cálculo preciso de estatística e p-value (erro <1%).",
                                "Interpretação correta da hipótese nula e decisão.",
                                "Uso de visualizações para suporte qualitativo.",
                                "Identificação e correção de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Hipótese testing e distribuições assintóticas.",
                                "Programação: Implementação numérica em Python/R (numpy, scipy).",
                                "Ciência de Dados: Validação de dados sintéticos em ML.",
                                "Probabilidade: Propriedades de convergência (LLN, CLT).",
                                "Física/Engenharia: Validação de simulações Monte Carlo."
                              ],
                              "realWorldApplication": "Em finanças, validar simulações de retornos de ações contra distribuições históricas para modelos de risco; em qualidade industrial, testar se defeitos seguem Poisson teórico; em bioinformática, verificar amostras genéticas contra modelos evolutivos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.5",
                    "name": "Métodos de Amostragem em Simulações",
                    "description": "Técnicas de seleção de amostras, como amostragem por importância e estratificada, para eficiência em simulações.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.5.1",
                        "name": "Amostragem Estratificada",
                        "description": "Técnica de amostragem que divide a população em subgrupos homogêneos (estratos) e seleciona amostras de cada estrato de forma proporcional ou desproporcional, visando reduzir a variância das estimativas em simulações de sistemas discretos.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.1.1",
                            "name": "Compreender os princípios da amostragem estratificada",
                            "description": "Explicar como a divisão em estratos melhora a precisão das estimativas em comparação à amostragem aleatória simples, incluindo fórmulas para variância reduzida em simulações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Amostragem Aleatória Simples (SAS)",
                                  "subSteps": [
                                    "Defina amostragem aleatória simples e sua aplicação em simulações.",
                                    "Calcule a variância da média amostral para SAS: Var(ȳ) = σ²/n.",
                                    "Discuta limitações da SAS em populações heterogêneas.",
                                    "Realize uma simulação simples em Python ou Excel para demonstrar variância alta.",
                                    "Compare com cenários reais de populações não uniformes."
                                  ],
                                  "verification": "Simulação executada mostrando variância da estimativa; explique resultados em um parágrafo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora ou software (Python/R/Excel)",
                                    "Dados de exemplo de população heterogênea"
                                  ],
                                  "tips": "Use geradores de números aleatórios para simulações realistas; foque em variância como métrica chave.",
                                  "learningObjective": "Entender as bases e limitações da SAS para contextualizar melhorias.",
                                  "commonMistakes": [
                                    "Confundir variância populacional com amostral",
                                    "Ignorar heterogeneidade da população"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Conceito de Amostragem Estratificada",
                                  "subSteps": [
                                    "Defina estratos como subgrupos homogêneos dentro da população heterogênea.",
                                    "Explique alocação proporcional: n_h = (N_h / N) * n, onde N_h é tamanho do estrato.",
                                    "Discuta benefícios: redução de variância ao garantir representação proporcional.",
                                    "Identifique estratos em um dataset exemplo (ex: idade em enquetes).",
                                    "Desenhe um fluxograma do processo de amostragem estratificada."
                                  ],
                                  "verification": "Crie um diagrama de estratificação para um dataset fornecido.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta para fluxograma",
                                    "Dataset exemplo (CSV com variáveis categóricas)"
                                  ],
                                  "tips": "Escolha estratos baseados em variáveis que expliquem variabilidade; teste proporcionalidade.",
                                  "learningObjective": "Dominar a definição e mecânica de divisão em estratos.",
                                  "commonMistakes": [
                                    "Estratos muito amplos ou sobrepostos",
                                    "Ignorar proporções populacionais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar e Comparar Fórmulas de Variância",
                                  "subSteps": [
                                    "Derive variância para amostragem estratificada: Var(ȳ_st) = Σ (W_h² * σ_h² / n_h), onde W_h = N_h/N.",
                                    "Compare com SAS: mostre matematicamente que Var(ȳ_st) ≤ Var(ȳ_sas) quando estratos são homogêneos.",
                                    "Calcule ganho de precisão: 1 - Var(ȳ_st)/Var(ȳ_sas).",
                                    "Resolva exercícios analíticos com números hipotéticos.",
                                    "Implemente fórmulas em código para verificação."
                                  ],
                                  "verification": "Resolva problema com cálculo correto de variâncias comparadas (erro <5%).",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Folha de fórmulas",
                                    "Software de programação (Python com numpy)"
                                  ],
                                  "tips": "Lembre-se: variância intra-estrato é chave para redução; use aproximações se σ_h desconhecida.",
                                  "learningObjective": "Explicar matematicamente por que estratificada é superior.",
                                  "commonMistakes": [
                                    "Erro em pesos W_h",
                                    "Confundir variância condicional com total"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular e Demonstrar Redução de Variância",
                                  "subSteps": [
                                    "Gere população simulada com estratos (ex: 3 grupos com médias diferentes).",
                                    "Execute 1000 simulações SAS vs. estratificada, calculando variâncias empíricas.",
                                    "Plote histogramas de estimativas para visualização.",
                                    "Analise resultados: quantifique redução percentual na variância.",
                                    "Discuta otimizações como alocação ótima (Neyman)."
                                  ],
                                  "verification": "Relatório com plots e cálculos mostrando redução >20% na variância.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Python (numpy, matplotlib, pandas)",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Use semente fixa para reprodutibilidade; aumente simulações para precisão.",
                                  "learningObjective": "Validar teoricamente através de evidência empírica em simulações.",
                                  "commonMistakes": [
                                    "Amostras insuficientes em simulações",
                                    "Escala errada nos plots"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma fábrica, estimar taxa de defeitos em produtos. População: 60% turno diurno (baixa defeito), 40% noturno (alta). SAS pode sub-representar noturno; estratificada garante 60/40, reduzindo variância da estimativa em 30%, melhorando decisões de qualidade.",
                              "finalVerifications": [
                                "Explica corretamente divisão em estratos e alocação proporcional.",
                                "Deriva e compara fórmulas de variância SAS vs. estratificada.",
                                "Executa simulação demonstrando redução empírica de variância.",
                                "Identifica estratos adequados em cenários reais.",
                                "Calcula ganho de precisão com números corretos.",
                                "Discute limitações como custo de estratificação."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas fórmulas (100% correto).",
                                "Clareza na explicação conceitual (linguagem acessível).",
                                "Qualidade da simulação (reprodutível, visualizações claras).",
                                "Profundidade da comparação (quantitativa e qualitativa).",
                                "Aplicação a exemplos reais (relevância contextual).",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Estatística Descritiva: Medidas de variabilidade.",
                                "Programação Computacional: Simulações em Python/R.",
                                "Pesquisa Científica: Design experimental.",
                                "Economia/Gestão: Amostragem em pesquisas de mercado.",
                                "Engenharia: Controle de qualidade e processos."
                              ],
                              "realWorldApplication": "Enquetes eleitorais estratificadas por região/idade para previsões precisas (ex: reduziu erro em 15% nas eleições de 2020); controle de qualidade em indústrias farmacêuticas, amostrando lotes por máquinas para estimativas confiáveis de pureza."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.1.2",
                            "name": "Calcular tamanhos de amostra por estrato",
                            "description": "Aplicar fórmulas para determinar o número de amostras em cada estrato, considerando alocação proporcional e ótima (Neyman), com exemplos numéricos em contextos de simulação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos fundamentais da amostragem estratificada",
                                  "subSteps": [
                                    "Defina amostragem estratificada e seus componentes: população total N, estratos Nh, variâncias sigma_h².",
                                    "Explique alocação proporcional: nh = n * (Nh / N), onde n é tamanho total da amostra.",
                                    "Descreva alocação ótima de Neyman: nh = n * (Nh * sigma_h) / Σ(Ni * sigma_i).",
                                    "Discuta vantagens em simulações: reduz variância em populações heterogêneas.",
                                    "Identifique quando usar cada alocação em contextos de simulação discreta."
                                  ],
                                  "verification": "Liste corretamente as fórmulas de alocação proporcional e Neyman, com definições de variáveis.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel e caneta",
                                    "Calculadora básica",
                                    "Referência teórica de amostragem (PDF ou livro)"
                                  ],
                                  "tips": "Memorize as fórmulas visualizando um diagrama de estratos proporcionais à população.",
                                  "learningObjective": "Dominar os conceitos teóricos e fórmulas para alocações em amostragem estratificada.",
                                  "commonMistakes": [
                                    "Confundir sigma_h com desvio padrão em vez de desvio",
                                    "Ignorar normalização para soma nh = n",
                                    "Não diferenciar variância entre estratos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular tamanhos de amostra com alocação proporcional",
                                  "subSteps": [
                                    "Colete dados: N total, Nh por estrato, tamanho desejado n.",
                                    "Calcule proporções: Wh = Nh / N para cada estrato.",
                                    "Aplique fórmula: nh = n * Wh, arredondando para inteiros.",
                                    "Verifique soma: Σ nh deve igualar n (ajuste se necessário).",
                                    "Registre resultados em tabela."
                                  ],
                                  "verification": "Cálculos resultam em Σ nh = n e proporções corretas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou Excel",
                                    "Tabela de dados de exemplo"
                                  ],
                                  "tips": "Use Excel para automação: =n * (Nh/N), e função SOMAR para verificação.",
                                  "learningObjective": "Aplicar fórmula proporcional com precisão numérica.",
                                  "commonMistakes": [
                                    "Arredondamento prematuro levando a soma errada",
                                    "Usar frações decimais sem ajustar para inteiros",
                                    "Confundir Nh com nh"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular tamanhos de amostra com alocação ótima de Neyman",
                                  "subSteps": [
                                    "Colete dados adicionais: sigma_h (desvio padrão) por estrato.",
                                    "Calcule numerador: Nh * sigma_h para cada estrato.",
                                    "Some denominador: Σ(Ni * sigma_i).",
                                    "Aplique: nh = n * (Nh * sigma_h) / denominador, arredondando.",
                                    "Verifique soma nh = n e compare com proporcional."
                                  ],
                                  "verification": "Resultados Neyman alocam mais amostras a estratos com alta variância.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Planilha Excel ou Google Sheets"
                                  ],
                                  "tips": "Priorize estratos com maior Nh * sigma_h para eficiência.",
                                  "learningObjective": "Implementar alocação ótima considerando variância para redução de erro.",
                                  "commonMistakes": [
                                    "Usar variância sigma² em vez de sigma",
                                    "Esquecer multiplicar por Nh",
                                    "Não normalizar o denominador"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e comparar alocações em contexto de simulação",
                                  "subSteps": [
                                    "Escolha cenário de simulação: e.g., simular tempos de serviço em filas com estratos por turno.",
                                    "Calcule nh proporcional e Neyman para o exemplo.",
                                    "Simule amostragem (manual ou software) e estime média/variância.",
                                    "Compare precisão: calcule variância amostral para cada alocação.",
                                    "Conclua qual alocação é melhor para o contexto."
                                  ],
                                  "verification": "Tabela comparativa mostra Neyman com menor variância em estratos heterogêneos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Software de simulação (R, Python ou Excel)",
                                    "Dados de exemplo numérico"
                                  ],
                                  "tips": "Use Python (numpy.random) para simular 1000 repetições e comparar erros médios.",
                                  "learningObjective": "Integrar cálculos em simulações discretas e avaliar eficiência.",
                                  "commonMistakes": [
                                    "Não simular repetições suficientes",
                                    "Ignorar contexto de simulação discreta",
                                    "Comparar sem métricas de variância"
                                  ]
                                }
                              ],
                              "practicalExample": "População N=1000 unidades de simulação de filas: Estrato 1 (alta demanda, N1=400, sigma1=5), Estrato 2 (média, N2=300, sigma2=3), Estrato 3 (baixa, N3=300, sigma3=2). n=100. Proporcional: n1=40, n2=30, n3=30. Neyman: n1≈55, n2≈26, n3≈19 (ajustado). Simule tempos médios de espera por estrato.",
                              "finalVerifications": [
                                "Fórmulas de alocação proporcional e Neyman recitadas corretamente.",
                                "Cálculos numéricos para exemplo batem com resultados esperados.",
                                "Soma de nh equals n em ambas alocações.",
                                "Comparação mostra Neyman eficiente em variância alta.",
                                "Aplicação em simulação discreta demonstrada com números.",
                                "Identificação correta de quando usar cada método."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos (erro <1%).",
                                "Explicação clara das fórmulas e variáveis.",
                                "Uso adequado de arredondamento e normalização.",
                                "Análise comparativa com métricas de variância.",
                                "Integração contextual em simulações discretas.",
                                "Clareza na tabela de resultados e simulação."
                              ],
                              "crossCurricularConnections": [
                                "Estatística Inferencial: Estimadores e variância amostral.",
                                "Programação Computacional: Simulações em Python/R com numpy/random.",
                                "Pesquisa de Operações: Otimização em sistemas de filas.",
                                "Ciência de Dados: Amostragem em big data heterogêneo.",
                                "Matemática Aplicada: Álgebra linear para alocações ótimas."
                              ],
                              "realWorldApplication": "Em simulações de call centers, estratificar por horários (alta/baixa demanda) para calcular nh ótimo, otimizando amostras para estimar tempos de atendimento com menor custo e maior precisão em previsões de staffing."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.1.3",
                            "name": "Implementar amostragem estratificada em simulações",
                            "description": "Codificar um exemplo simples em pseudocódigo ou linguagem de simulação (ex.: Python com NumPy) para gerar amostras estratificadas e estimar médias em modelos de sistemas discretos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a população e estratificar os dados",
                                  "subSteps": [
                                    "Identifique a população total do sistema discreto (ex.: lista de valores ou eventos simulados).",
                                    "Defina critérios claros para os estratos baseados em características relevantes (ex.: intervalos de valores ou categorias).",
                                    "Calcule o tamanho proporcional de cada estrato com base na distribuição da população.",
                                    "Crie arrays ou listas separadas para cada estrato usando NumPy.",
                                    "Verifique se a soma dos tamanhos dos estratos equals o tamanho da população."
                                  ],
                                  "verification": "Confirme que os estratos cobrem toda a população sem sobreposições e que as proporções estão corretas (use soma e print dos tamanhos).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python com NumPy instalado",
                                    "Jupyter Notebook ou IDE como VS Code"
                                  ],
                                  "tips": "Use np.histogram ou np.digitize para automatizar a divisão em estratos numéricos.",
                                  "learningObjective": "Compreender como dividir uma população em subgrupos homogêneos para reduzir variância.",
                                  "commonMistakes": [
                                    "Ignorar proporções desiguais entre estratos",
                                    "Permitir sobreposições nos limites dos estratos",
                                    "Não normalizar os pesos das amostras"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a função de amostragem estratificada",
                                  "subSteps": [
                                    "Crie uma função que recebe a população, estratos e tamanho da amostra desejada.",
                                    "Use np.random.choice com replace=False e probabilidades proporcionais para cada estrato.",
                                    "Gere índices aleatórios para cada estrato separadamente e concatene as amostras.",
                                    "Retorne a amostra estratificada como um array NumPy.",
                                    "Teste a função com dados sintéticos simples (ex.: população [1,2,3,4,5] em 2 estratos)."
                                  ],
                                  "verification": "Execute a função e verifique se o número de amostras por estrato é proporcional via contagem (np.bincount).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Biblioteca NumPy",
                                    "Exemplos de código em documentação NumPy"
                                  ],
                                  "tips": "Para amostragem sem reposição, certifique-se de que o tamanho da amostra por estrato não exceda o tamanho do estrato.",
                                  "learningObjective": "Desenvolver uma função reutilizável para geração de amostras estratificadas.",
                                  "commonMistakes": [
                                    "Usar amostragem com reposição quando não é desejado",
                                    "Não ponderar corretamente as amostras finais",
                                    "Esquecer de embaralhar as amostras dentro de cada estrato"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar em uma simulação de sistema discreto",
                                  "subSteps": [
                                    "Gere uma população simulada de um sistema discreto (ex.: tempos de chegada em uma fila com distribuições diferentes por tipo).",
                                    "Execute múltiplas rodadas de simulação usando amostragem estratificada para estimar a média geral.",
                                    "Calcule a média da amostra ponderada pelos pesos dos estratos.",
                                    "Repita o processo N vezes (ex.: 1000) para estimar variância e intervalo de confiança.",
                                    "Compare visualmente com histogramas da população original."
                                  ],
                                  "verification": "A média estimada converge para a média populacional verdadeira em rodadas suficientes (erro < 5%).",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "NumPy para simulações",
                                    "Matplotlib para gráficos opcionais"
                                  ],
                                  "tips": "Use np.mean(amostra_ponderada) onde pesos são as proporções dos estratos.",
                                  "learningObjective": "Integrar amostragem estratificada em loops de simulação Monte Carlo.",
                                  "commonMistakes": [
                                    "Não ponderar a média final pelos tamanhos dos estratos",
                                    "Confundir amostragem estratificada com amostragem por conglomerados",
                                    "Usar poucos estratos levando a pouca redução de variância"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e comparar com amostragem simples",
                                  "subSteps": [
                                    "Implemente uma função de amostragem aleatória simples (SRS) para o mesmo cenário.",
                                    "Execute simulações paralelas: estratificada vs. SRS, coletando médias e variâncias.",
                                    "Calcule a redução percentual na variância (var_SRS / var_estratificada).",
                                    "Gere um relatório com estatísticas descritivas e gráficos de convergência.",
                                    "Documente insights sobre quando usar cada método."
                                  ],
                                  "verification": "A variância da estimativa estratificada é pelo menos 20-50% menor que a SRS.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "NumPy.random para comparações",
                                    "Pandas para tabelas de resultados"
                                  ],
                                  "tips": "Use seeds fixas (np.random.seed) para reprodutibilidade nas comparações.",
                                  "learningObjective": "Avaliar a superioridade da amostragem estratificada em termos de precisão.",
                                  "commonMistakes": [
                                    "Não usar o mesmo tamanho de amostra nas comparações",
                                    "Ignorar o custo computacional extra da estratificação",
                                    "Concluir superioridade sem testes estatísticos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de supermercado, gere uma população de 10.000 tempos de checkout (normal rápida: mu=2min, lenta: mu=10min). Estrafique por tipo de cliente (rápido 60%, lento 40%). Amostre 1.000 itens estratificados, estime média geral e compare variância com amostragem simples.",
                              "finalVerifications": [
                                "O código executa sem erros e gera amostras de todos os estratos.",
                                "Proporções das amostras por estrato batem com a população (±5%).",
                                "Média estimada está dentro de 1-2% da média populacional real.",
                                "Variância da estratificada é menor que a de amostragem simples.",
                                "Função é reutilizável e testada com dados variados.",
                                "Documentação inclui comentários explicando pesos e ponderação."
                              ],
                              "assessmentCriteria": [
                                "Correção algorítmica: amostras geradas corretamente sem reposição.",
                                "Precisão: erro quadrático médio < 5% em 100 simulações.",
                                "Eficiência: tempo de execução razoável para populações grandes (>10k).",
                                "Clareza do código: funções modulares com docstrings.",
                                "Robustez: lida com estratos desiguais e tamanhos de amostra inválidos.",
                                "Análise comparativa: demonstra redução de variância quantitativamente."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: conceitos de variância amostral e estimadores não viesados.",
                                "Programação: manipulação eficiente de arrays com NumPy e vetores.",
                                "Ciência de Dados: simulações Monte Carlo e validação de modelos.",
                                "Matemática Aplicada: distribuições discretas e integração numérica.",
                                "Engenharia de Software: testes unitários para funções de amostragem."
                              ],
                              "realWorldApplication": "Em simulações de risco em finanças, estratificar portfólios por classes de ativos (baixo/alto risco) para estimativas mais precisas de VaR (Value at Risk), reduzindo capital alocado desnecessariamente em bancos e fundos de investimento."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.5.1.4",
                            "name": "Avaliar a redução de variância",
                            "description": "Comparar a variância de estimativas com e sem estratificação, usando intervalos de confiança e métricas de eficiência relativa em experimentos de simulação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar e executar simulação de amostragem simples aleatória",
                                  "subSteps": [
                                    "Defina uma população simulada heterogênea com estratos claros (ex: 3 estratos de tamanhos desiguais).",
                                    "Gere múltiplas amostras aleatórias simples (ex: 1000 replicatas de tamanho n=100).",
                                    "Calcule a estimativa pontual da média para cada replicata.",
                                    "Calcule a variância amostral das estimativas e o intervalo de confiança de 95%.",
                                    "Registre os resultados em uma tabela ou gráfico."
                                  ],
                                  "verification": "Verifique se as estimativas variam em torno da média populacional verdadeira e se o IC cobre consistentemente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python/R com bibliotecas numpy/random/statsmodels; notebook Jupyter.",
                                  "tips": "Fixe a semente aleatória (np.random.seed(42)) para reprodutibilidade.",
                                  "learningObjective": "Compreender o impacto da variabilidade na amostragem simples aleatória.",
                                  "commonMistakes": "Ignorar a heteroscedasticidade da população, levando a subestimação da variância."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar e executar simulação de amostragem estratificada",
                                  "subSteps": [
                                    "Divida a população nos estratos previamente definidos e calcule proporções.",
                                    "Gere amostras estratificadas proporcionais (ex: alocação proporcional, n_h = n * N_h / N).",
                                    "Calcule a estimativa ponderada da média para cada replicata.",
                                    "Calcule a variância das estimativas estratificadas e o IC de 95%.",
                                    "Compare visualmente as distribuições de estimativas com a amostragem simples."
                                  ],
                                  "verification": "Confirme que as amostras em cada estrato respeitam as proporções populacionais.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Mesmo ambiente do Step 1; função stratified_sample em Python.",
                                  "tips": "Use alocação ótima se variâncias intra-estratos forem conhecidas para maximizar redução.",
                                  "learningObjective": "Dominar a implementação prática da amostragem estratificada.",
                                  "commonMistakes": "Erro na ponderação das médias estratificadas, resultando em viés."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular métricas de variância e intervalos de confiança",
                                  "subSteps": [
                                    "Compute a variância amostral para ambas as abordagens (Var_simples e Var_estrat).",
                                    "Calcule os intervalos de confiança usando a fórmula t ou normal aproximada.",
                                    "Gere histogramas ou boxplots das estimativas para visualização.",
                                    "Calcule a largura média dos ICs para comparação.",
                                    "Teste estatisticamente a diferença de variâncias (ex: teste F)."
                                  ],
                                  "verification": "Os ICs estratificados devem ser consistentemente mais estreitos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Bibliotecas scipy.stats para testes e matplotlib/seaborn para plots.",
                                  "tips": "Use bootstrap para ICs não paramétricos se distribuição for desconhecida.",
                                  "learningObjective": "Aplicar fórmulas precisas para variância em amostragem estratificada.",
                                  "commonMistakes": "Confundir variância da estimativa com variância populacional."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar redução de variância e eficiência relativa",
                                  "subSteps": [
                                    "Calcule a métrica de eficiência relativa: RE = Var_simples / Var_estrat.",
                                    "Interprete o RE: valores >1 indicam redução de variância.",
                                    "Quantifique a redução percentual: (1 - 1/RE) * 100%.",
                                    "Analise sensibilidade variando n ou número de estratos.",
                                    "Documente conclusões em relatório com gráficos comparativos."
                                  ],
                                  "verification": "RE >1 e redução significativa confirmada por simulações.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Planilha ou código para métricas; LaTeX/Markdown para relatório.",
                                  "tips": "Simule cenários com mais/menos estratos para otimização.",
                                  "learningObjective": "Interpretar quantitativamente os ganhos da estratificação.",
                                  "commonMistakes": "Não considerar custo de estratificação (mais esforço na amostragem)."
                                }
                              ],
                              "practicalExample": "Simule uma população de 10.000 famílias com estratos de renda: baixo (60%, média 20k), médio (30%, 50k), alto (10%, 100k). Estime a renda média com n=300: sem estratificação, variância alta devido a subamostragem de altos; com estratificação proporcional, variância reduz em 40%, IC de [45k-55k] vs [40k-60k].",
                              "finalVerifications": [
                                "Variância estratificada é menor que a simples (teste F p<0.05).",
                                "Largura média do IC estratificado < 70% da simples.",
                                "Eficiência relativa RE > 1.2 em todas replicatas.",
                                "Estimativas não enviesadas em ambas abordagens.",
                                "Gráficos mostram sobreposição menor nas estimativas estratificadas.",
                                "Redução de variância aumenta com heteroscedasticidade intra-estratos."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de variância e IC (erro <1%).",
                                "Implementação correta de amostragem estratificada sem viés.",
                                "Interpretação adequada da eficiência relativa e redução.",
                                "Visualizações claras e informativas (histogramas, boxplots).",
                                "Análise de sensibilidade e limitações discutidas.",
                                "Relatório estruturado com conclusões acionáveis."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Testes de hipóteses para variâncias (F-test).",
                                "Programação: Simulações Monte Carlo em Python/R.",
                                "Ciência de Dados: Otimização de amostras em machine learning.",
                                "Probabilidade: Geração de variáveis aleatórias estratificadas."
                              ],
                              "realWorldApplication": "Em pesquisas eleitorais, estratificar por região/idade reduz variância nas estimativas de intenção de voto, permitindo amostras menores e mais precisas; em controle de qualidade industrial, estratificar por turnos/lotes minimiza variância em médias de defeitos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.5.2",
                        "name": "Amostragem por Importância",
                        "description": "Método de redução de variância que utiliza uma distribuição de importância para amostrar preferencialmente regiões de alta contribuição, ajustando o estimador para manter a imparcialidade em simulações Monte Carlo.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.2.1",
                            "name": "Entender o conceito de distribuição de importância",
                            "description": "Descrever como escolher e aplicar uma distribuição de importância q(x) que aproxima a densidade original p(x) para minimizar a variância do estimador em integrações simuladas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Integração Monte Carlo Padrão e Seu Problema de Variância",
                                  "subSteps": [
                                    "Lembre-se da fórmula básica da integração Monte Carlo: estimar ∫ f(x) p(x) dx ≈ (1/N) Σ f(X_i) onde X_i ~ p(x).",
                                    "Calcule a variância do estimador: Var[(1/N) Σ f(X_i)] = (1/N) Var[f(X)] com X ~ p.",
                                    "Identifique cenários onde Var[f(X)] é alta, como em eventos raros ou funções com picos.",
                                    "Discuta limitações: convergência lenta quando p(x) não cobre bem a região de interesse de f(x).",
                                    "Pratique com um exemplo simples numérico em papel."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que a variância é alta em integrações com eventos raros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora"
                                  ],
                                  "tips": "Comece com distribuições uniformes para visualizar o problema claramente.",
                                  "learningObjective": "Compreender as limitações da amostragem direta de p(x) na redução de variância.",
                                  "commonMistakes": [
                                    "Confundir variância do estimador com variância de f(x)",
                                    "Ignorar o papel de p(x) na amostragem"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Conceito de Amostragem por Importância",
                                  "subSteps": [
                                    "Defina o estimador de importância: ∫ f(x) p(x) dx ≈ (1/N) Σ [f(X_i) p(X_i)/q(X_i)] onde X_i ~ q(x).",
                                    "Derive matematicamente a expectativa: E_q [f(X) p(X)/q(X)] = ∫ f(x) p(x) dx.",
                                    "Explique que q(x) deve ser escolhida para que p(x)/q(x) seja limitada e f(x) p(x)/q(x) tenha baixa variância.",
                                    "Compare com Monte Carlo padrão: q(x) = p(x) recupera o caso original.",
                                    "Esboce um fluxograma do processo de amostragem."
                                  ],
                                  "verification": "Escreva a fórmula do estimador e prove sua imparcialidade em 2-3 linhas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Notebook com Python/NumPy para simulação rápida"
                                  ],
                                  "tips": "Use notação clara: destaque w(x) = p(x)/q(x) como peso.",
                                  "learningObjective": "Dominar a formulação matemática da amostragem por importância.",
                                  "commonMistakes": [
                                    "Esquecer que o estimador é imparcial apenas se q(x) > 0 onde p(x) > 0",
                                    "Confundir q(x) com a densidade alvo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Critérios para Escolher q(x) que Aproxima p(x)",
                                  "subSteps": [
                                    "Estabeleça o objetivo: minimizar Var_q [f(X) p(X)/q(X)] ≈ E_q [(f p/q)^2] - [∫ f p dx]^2.",
                                    "Identifique heurística ideal: q(x) ∝ |f(x)| p(x), para tornar pesos constantes.",
                                    "Discuta aproximações práticas: use distribuições conhecidas (normal, exponencial) que cubram suportes similares a p(x) f(x).",
                                    "Avalie trade-offs: q(x) deve ser fácil de amostrar e suportar p(x)/q(x) < ∞.",
                                    "Teste com plotagens: grafique p(x), f(x) p(x) e proposta q(x)."
                                  ],
                                  "verification": "Proponha uma q(x) para um f(x) dado e justifique por que minimiza variância.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software de plotagem (Python Matplotlib ou similar)",
                                    "Tabela de distribuições padrão"
                                  ],
                                  "tips": "Sempre verifique suporte: q deve cobrir onde f p > 0.",
                                  "learningObjective": "Aprender a selecionar q(x) ótima ou boa aproximação para baixa variância.",
                                  "commonMistakes": [
                                    "Escolher q(x) com variância zero mas sem suporte adequado",
                                    "Ignorar custo computacional de amostrar q(x)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e Verificar Redução de Variância",
                                  "subSteps": [
                                    "Calcule variância teórica para MC padrão vs. importância: compare fórmulas.",
                                    "Implemente simulação numérica: gere N amostras, compute estimadores e variâncias empíricas.",
                                    "Compare curvas de convergência (erro vs. N) para ambos métodos.",
                                    "Ajuste q(x) iterativamente se variância ainda alta.",
                                    "Documente resultados em tabela: média, desvio padrão, tempo de computação."
                                  ],
                                  "verification": "Execute simulação e mostre que variância da importância é menor que MC padrão.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Use N=10^4-10^5 para resultados estáveis; plote histogramas de pesos para diagnósticos.",
                                  "learningObjective": "Validar empiricamente a minimização de variância com q(x) bem escolhida.",
                                  "commonMistakes": [
                                    "Usar N muito pequeno para comparações",
                                    "Não normalizar densidades adequadamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Estime ∫_0^∞ exp(-x) / (1 + x)^2 dx usando MC padrão (q(x)=exp(-x)) vs. importância com q(x)= normalizada para aproximar p(x) f(x) ∝ exp(-x)/(1+x)^2. Simule N=10^5 amostras e compare variâncias: a importância reduz variância em >90%.",
                              "finalVerifications": [
                                "Explica corretamente a fórmula do estimador de importância e sua imparcialidade.",
                                "Propõe q(x) adequada para um problema dado, justificando com análise de variância.",
                                "Implementa simulação numérica comparando MC vs. importância.",
                                "Identifica quando pesos são efectivamente constantes (ideal).",
                                "Discute limitações como viés zero mas variância potencialmente alta se q mal escolhida.",
                                "Grafica densidades e pesos para diagnóstico visual."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação matemática (imparcialidade e variância).",
                                "Qualidade da escolha de q(x): proximidade a |f|p e facilidade de amostragem.",
                                "Resultados numéricos: redução quantificável de variância (>50%).",
                                "Análise de erros: identificação de problemas comuns como suporte inadequado.",
                                "Clareza na comunicação: explicação verbal/escrita concisa.",
                                "Criatividade em exemplos: adaptação a contextos reais."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade: geração de variáveis aleatórias e teorema do limite central.",
                                "Estatística: redução de variância em estimadores (controle de variância).",
                                "Machine Learning: importance sampling em Variational Inference e MCMC.",
                                "Física Computacional: simulações de Monte Carlo em mecânica quântica.",
                                "Finanças: estimação de riscos raros (Value at Risk)."
                              ],
                              "realWorldApplication": "Em simulações de partículas em detectores de física (CERN), usa-se importance sampling para estimar probabilidades de eventos raros, reduzindo tempo de computação de semanas para horas ao focar amostras em regiões de alta importância."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.2.2",
                            "name": "Derivar o estimador não viesado",
                            "description": "Derivar matematicamente o estimador de importância ∫ f(x) p(x) dx ≈ Σ [f(X_i) p(X_i)/q(X_i)] / n, com exemplos em simulações de sistemas discretos como filas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Expectativa e Amostragem Monte Carlo Padrão",
                                  "subSteps": [
                                    "Defina a expectativa E_p[f(X)] = ∫ f(x) p(x) dx para uma função f sob distribuição p.",
                                    "Explique o estimador Monte Carlo padrão: amostrando X_i ~ p, estimar como (1/n) Σ f(X_i).",
                                    "Discuta limitações quando p é difícil de amostrar, especialmente em caudas raras.",
                                    "Calcule variância do estimador padrão para ilustrar ineficiência.",
                                    "Prepare notação: denote amostras de q como X_i ~ q(x)."
                                  ],
                                  "verification": "Escreva a fórmula da expectativa e do estimador MC padrão corretamente, sem erros de notação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Caderno de anotações, calculadora, referência de probabilidade (ex: livro de Monte Carlo methods).",
                                  "tips": "Use diagramas para visualizar a integral como área ponderada.",
                                  "learningObjective": "Compreender a base teórica da estimação de expectativas e identificar quando amostragem direta falha.",
                                  "commonMistakes": "Confundir p(x) com densidade conjunta ou esquecer normalização de p."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Amostragem por Importância e Mudança de Medida",
                                  "subSteps": [
                                    "Defina amostragem por importância: amostrar de q(x) onde q tem suporte similar a p|f|.",
                                    "Mostre a identidade: ∫ f(x) p(x) dx = ∫ f(x) [p(x)/q(x)] q(x) dx = E_q[ f(X) w(X) ] onde w(X) = p(X)/q(X).",
                                    "Derive algebricamente a mudança de medida passo a passo.",
                                    "Discuta escolha de q para reduzir variância (q próxima de p|f|).",
                                    "Calcule w(X_i) para amostras simuladas simples."
                                  ],
                                  "verification": "Derive corretamente E_q[ f(X) p(X)/q(X) ] = ∫ f(x) p(x) dx em papel.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel e lápis para derivações, software como Python/Jupyter para plots de p e q.",
                                  "tips": "Sempre verifique dimensões: w(x) deve ser adimensional.",
                                  "learningObjective": "Dominar a mudança de medida probabilística fundamental para amostragem por importância.",
                                  "commonMistakes": "Esquecer que q deve ter suporte contido em p para w finito; dividir por q(X_i)=0."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar o Estimador Não Viesado de Importância",
                                  "subSteps": [
                                    "Pelo LLN (Lei dos Grandes Números), E_q[ f(X) w(X) ] ≈ (1/n) Σ f(X_i) w(X_i) para X_i ~ q.",
                                    "Escreva explicitamente: ∫ f p ≈ (1/n) Σ [f(X_i) p(X_i)/q(X_i)].",
                                    "Prove não viesado: E[estimador] = E_q[ f(X) w(X) ] = integral exata.",
                                    "Discuta consistência: variância →0 quando n→∞ se Var_q(f w)<∞.",
                                    "Compare variância com MC padrão via fórmula analítica simples."
                                  ],
                                  "verification": "Escreva a prova de não viesado em 3-4 linhas e compute E[estimador] explicitamente.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Folha de derivações, tabela comparativa de variâncias.",
                                  "tips": "Use expectativa condicional para provar: E[ f(X_i) w(X_i) ] = ∫ f p.",
                                  "learningObjective": "Derivar e provar propriedades do estimador de importância de forma rigorosa.",
                                  "commonMistakes": "Confundir o estimador com média de w; ignorar normalização de q."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em Simulação Discreta: Exemplo em Sistemas de Filas",
                                  "subSteps": [
                                    "Escolha exemplo: estimar P(buffer overflow) em fila M/M/1 com ρ próximo de 1 (raro).",
                                    "Defina p(k) = probabilidade estacionária de k clientes, f(k)=1 se k>threshold.",
                                    "Proponha q(k) = geometrica shifted para caudas pesadas.",
                                    "Implemente simulação: gere n=10^4 amostras de q, compute pesos w(k)=p(k)/q(k), estimador.",
                                    "Compare com MC padrão (n muito maior necessário)."
                                  ],
                                  "verification": "Rode simulação e verifique que estimador converge para valor conhecido/teórico.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Python com NumPy/SciPy, código template para filas M/M/1.",
                                  "tips": "Normalize q se necessário; plot histograma de pesos para checar estabilidade.",
                                  "learningObjective": "Implementar e validar o estimador em contexto prático de simulação discreta.",
                                  "commonMistakes": "Amostrar de p em vez de q; overflow numérico em w grandes."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar e Generalizar para Outros Contextos",
                                  "subSteps": [
                                    "Calcule variância efetiva: 1 + cv^2 onde cv=sd(w)/mean(w).",
                                    "Teste sensibilidade a escolha de q via experimentos.",
                                    "Generalize para integrais multi-dimensionais ou contínuas.",
                                    "Discuta extensões: importance sampling adaptativo.",
                                    "Resuma vantagens em simulações de sistemas discretos."
                                  ],
                                  "verification": "Produza relatório com plots de convergência MC vs IS, variâncias comparadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Jupyter notebook com simulações, gráficos de erro vs n.",
                                  "tips": "Use log-scale para plots de variância em eventos raros.",
                                  "learningObjective": "Avaliar performance e estender o método criticamente.",
                                  "commonMistakes": "Atribuir baixa variância só a n grande, ignorando papel de q."
                                }
                              ],
                              "practicalExample": "Em uma fila M/M/1 com taxa chegada λ=0.95, serviço μ=1, estimar P(N>20). p(k)=(1-ρ)ρ^k, mas cauda rara. Use q(k)=Geometrica(0.1) shifted para k>=0. Gere X_i ~ q, w_i = p(X_i)/q(X_i), estimador = mean( f(X_i) w_i ) onde f=1 se X_i>20. Com n=10k, erro <1% vs MC padrão precisando 10M amostras.",
                              "finalVerifications": [
                                "Derivação da mudança de medida E_q[f w] = ∫ f p correta.",
                                "Prova de não viesado: E[ (1/n) Σ f(X_i) w(X_i) ] = integral.",
                                "Simulação em fila converge ao valor teórico exato.",
                                "Variância do IS menor que MC padrão em pelo menos 10x.",
                                "Pesos w_i estáveis (cv(w)<10).",
                                "Código reproduzível sem erros numéricos."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação (sem erros algébricos).",
                                "Correta implementação e interpretação da simulação.",
                                "Análise quantitativa de variância e eficiência.",
                                "Clareza na explicação de passos e justificativas.",
                                "Criatividade na escolha/extensão do exemplo.",
                                "Identificação e correção de potenciais pitfalls."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Teoria de estimação e teoremas limite (LLN, CLT).",
                                "Programação: Simulações numéricas em Python/NumPy.",
                                "Física/Engenharia: Modelagem de filas em telecomunicações/rede.",
                                "Finanças: Precificação de opções raras via risco neutro.",
                                "Machine Learning: Variational inference e REINFORCE."
                              ],
                              "realWorldApplication": "Em engenharia de confiabilidade, estimar probabilidade de falha rara em sistemas de filas (ex: redes 5G sobrecarregadas) sem simular bilhões de runs; acelera design e otimização em telecom, logística e cloud computing."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.2.1"
                            ]
                          },
                          {
                            "id": "10.1.3.5.2.3",
                            "name": "Implementar amostragem por importância",
                            "description": "Desenvolver um algoritmo em pseudocódigo para gerar amostras de q(x), calcular pesos e estimar quantidades de interesse, testando em cenários de simulação com variância alta.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os princípios fundamentais da amostragem por importância",
                                  "subSteps": [
                                    "Revise a fórmula básica: E_p[f(X)] ≈ Σ w_i f(x_i) onde w_i = p(x_i)/q(x_i)",
                                    "Estude por que q(x) deve ser próxima de p(x)f(x) para reduzir variância",
                                    "Analise exemplos simples de amostragem direta vs. por importância",
                                    "Identifique cenários onde variância alta ocorre (caudas pesadas)",
                                    "Derive matematicamente a expectativa dos pesos"
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como os pesos corrigem o viés da distribuição q(x)",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Monte Carlo ou notas de aula",
                                    "Calculadora ou papel para derivações"
                                  ],
                                  "tips": [
                                    "Visualize distribuições com gráficos para entender sobreposição",
                                    "Comece com exemplos unidimensionais simples"
                                  ],
                                  "learningObjective": "Dominar a teoria por trás da amostragem por importância e sua vantagem em reduzir variância",
                                  "commonMistakes": [
                                    "Confundir p(x) com q(x)",
                                    "Ignorar normalização dos pesos",
                                    "Subestimar impacto da escolha de q(x)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o problema de simulação e selecionar distribuições p(x) e q(x)",
                                  "subSteps": [
                                    "Escolha uma quantidade de interesse, como P(X > threshold) em simulação discreta",
                                    "Defina a distribuição alvo p(x) (ex: binomial com parâmetros de alta variância)",
                                    "Proponha q(x) como uma distribuição que enfatize regiões de alta contribuição (ex: shifted geometric)",
                                    "Verifique se q(x) é fácil de amostrar e suporta p(x)/q(x) finita",
                                    "Calcule analiticamente E_q[w(X)] para validar =1"
                                  ],
                                  "verification": "Documente p(x), q(x), f(x) e mostre que a importância sampling é não viesada",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software de plotagem como Python/Matplotlib",
                                    "Tabela de distribuições probabilísticas"
                                  ],
                                  "tips": [
                                    "Use trial-and-error com plots para escolher boa q(x)",
                                    "Priorize q(x) com suporte similar a p(x)"
                                  ],
                                  "learningObjective": "Selecionar distribuições adequadas para minimizar variância efetiva",
                                  "commonMistakes": [
                                    "Escolher q(x) com caudas mais leves que p(x)f(x)",
                                    "Não verificar se raios de suporte coincidem",
                                    "Ignorar computabilidade de amostras de q(x)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolver pseudocódigo para geração de amostras e cálculo de pesos",
                                  "subSteps": [
                                    "Escreva loop para gerar N amostras independentes de q(x)",
                                    "Para cada x_i, compute w_i = p(x_i) * f(x_i) / q(x_i)",
                                    "Inclua normalização self-normalized se necessário: ŵ_i = w_i / Σ w_j",
                                    "Adicione comentários explicando cada linha",
                                    "Teste sintaxe e lógica com N=5 manualmente"
                                  ],
                                  "verification": "Execute pseudocódigo à mão para N=10 e verifique pesos positivos e soma próxima de 1",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Editor de texto para pseudocódigo",
                                    "Exemplo de dados simulados"
                                  ],
                                  "tips": [
                                    "Use funções auxiliares para densidades p e q",
                                    "Vectorize loops em mente para eficiência"
                                  ],
                                  "learningObjective": "Criar um algoritmo claro e correto em pseudocódigo para sampling e weighting",
                                  "commonMistakes": [
                                    "Esquecer de multiplicar por f(x) nos pesos",
                                    "Dividir por q(x)=0",
                                    "Não tratar amostras fora do suporte de p"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar estimativa de quantidades de interesse e análise de variância",
                                  "subSteps": [
                                    "Compute estimativa: θ̂ = Σ w_i f(x_i) / N ou self-normalized",
                                    "Calcule variância amostral: Var(θ̂) ≈ (Σ w_i^2 f(x_i)^2 / N) - θ̂^2",
                                    "Compare com amostragem direta (mesmo N)",
                                    "Repita experimento M vezes para IC bootstrap",
                                    "Plote histograma de estimativas para visualizar redução de variância"
                                  ],
                                  "verification": "Mostre que Var_importance < Var_direct em pelo menos 50%",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Python ou R para simulação numérica",
                                    "Bibliotecas como NumPy/SciPy"
                                  ],
                                  "tips": [
                                    "Use N=10^4 para precisão",
                                    "Log-scale para variâncias extremas"
                                  ],
                                  "learningObjective": "Estimar quantidades e quantificar ganhos em eficiência",
                                  "commonMistakes": [
                                    "Usar N pequeno levando a estimativas instáveis",
                                    "Confundir variância da estimativa com variância dos pesos",
                                    "Não comparar com baseline"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar em cenários de simulação com alta variância e validar resultados",
                                  "subSteps": [
                                    "Configure cenário: ex. probabilidade rara em Poisson com λ alto",
                                    "Execute algoritmo completo 100 vezes",
                                    "Analise convergência (erro vs. N)",
                                    "Ajuste q(x) iterativamente se variância ainda alta",
                                    "Documente relatório com tabelas e gráficos"
                                  ],
                                  "verification": "Relatório mostra redução consistente de variância e estimativa precisa",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Jupyter Notebook para experimentos reprodutíveis",
                                    "Gráficos de convergência"
                                  ],
                                  "tips": [
                                    "Salve seeds para reprodutibilidade",
                                    "Teste múltiplas q(x)"
                                  ],
                                  "learningObjective": "Aplicar e validar o método em problemas desafiadores",
                                  "commonMistakes": [
                                    "Não aumentar N o suficiente",
                                    "Overfitting q(x) a um cenário",
                                    "Ignorar tempo computacional"
                                  ]
                                }
                              ],
                              "practicalExample": "Em simulação de filas M/M/1, estime P(queue length > 100) onde eventos raros têm alta variância. Use q(x) = geometrica shifted para regiões altas, gere 10^5 amostras, compute pesos e mostre redução de 90% na variância vs. amostragem direta.",
                              "finalVerifications": [
                                "Pseudocódigo gera amostras válidas de q(x) e pesos não viesados",
                                "Estimativa converge para valor verdadeiro conhecido",
                                "Variância efetiva reduzida em >70% vs. método direto",
                                "Pesos têm média 1 e variância finita",
                                "Código roda em <1 min para N=10^5",
                                "Gráficos mostram sobreposição ótima de q(x) com p(x)f(x)"
                              ],
                              "assessmentCriteria": [
                                "Correção teórica do algoritmo (sem viés)",
                                "Eficiência na redução de variância (medida quantitativamente)",
                                "Clareza e completude do pseudocódigo",
                                "Validação empírica em cenários de alta variância",
                                "Análise comparativa com baseline",
                                "Documentação de escolhas de distribuições"
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Inferência bayesiana e MCMC",
                                "Programação: Algoritmos numéricos e simulação",
                                "Física: Métodos Monte Carlo para integrais",
                                "Finanças: Simulação de risco e Value-at-Risk",
                                "Engenharia: Análise de confiabilidade de sistemas"
                              ],
                              "realWorldApplication": "Aplicado em finanças para estimar riscos raros em portfólios (ex: crash de mercado), em física de partículas para simular eventos raros no LHC, e em telecomunicações para modelar perdas de pacotes em redes com tráfego bursty, reduzindo tempo de simulação em ordens de magnitude."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.2.2"
                            ]
                          },
                          {
                            "id": "10.1.3.5.2.4",
                            "name": "Diagnosticar e otimizar escolhas de q(x)",
                            "description": "Analisar diagnósticos de variância efetiva (ESS) e otimizar q(x) iterativamente para maximizar eficiência em simulações complexas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Effective Sample Size (ESS) e seu cálculo",
                                  "subSteps": [
                                    "Estudar a definição de ESS como métrica de eficiência em amostragem por importância: ESS = n / (1 + Var(w)), onde w são os pesos normalizados.",
                                    "Implementar o cálculo de ESS em código para uma simulação simples com distribuições conhecidas (ex: normal vs. t-student).",
                                    "Interpretar valores de ESS: alto ESS (>0.8n) indica boa q(x); baixo ESS sugere variância excessiva nos pesos.",
                                    "Visualizar histograma de pesos para diagnosticar degenerescência.",
                                    "Praticar com 3 exemplos variados de funções alvo p(x)f(x)."
                                  ],
                                  "verification": "Gerar um relatório com cálculos de ESS para 3 cenários e gráficos de pesos, confirmando interpretação correta.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Jupyter Notebook",
                                    "Bibliotecas NumPy, SciPy, Matplotlib",
                                    "Documentação de métodos Monte Carlo"
                                  ],
                                  "tips": "Sempre normalize os pesos antes de calcular variância para evitar erros numéricos.",
                                  "learningObjective": "Calcular e interpretar ESS para diagnosticar eficiência de q(x).",
                                  "commonMistakes": [
                                    "Não normalizar pesos",
                                    "Confundir ESS com tamanho de amostra n",
                                    "Ignorar caudas pesadas nos pesos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diagnosticar problemas na escolha inicial de q(x)",
                                  "subSteps": [
                                    "Executar simulação com q(x) inicial simples (ex: uniforme ou normal ampla) e estimar integral alvo.",
                                    "Calcular estatísticas de diagnóstico: ESS, variância dos pesos, bias na estimativa.",
                                    "Analisar diagnósticos: identificar se pesos são degenerados (poucos amostras dominam) ou uniformes.",
                                    "Comparar ESS com baseline teórico e quantificar perda de eficiência (% de variância extra).",
                                    "Documentar padrões de falha comuns para diferentes tipos de p(x)f(x) (ex: multimodal)."
                                  ],
                                  "verification": "Produzir tabela comparativa de diagnósticos para 2 q(x) iniciais vs. ideal, com ESS < 0.3n sinalizando problema.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código Python para IS",
                                    "Funções teste (ex: exp(-x^2/2) * exp(-x^4))",
                                    "Ferramentas de plotagem"
                                  ],
                                  "tips": "Use amostras grandes (n=10^4+) para diagnósticos confiáveis; rode múltiplas seeds.",
                                  "learningObjective": "Identificar falhas qualitativas e quantitativas em q(x) via ESS e pesos.",
                                  "commonMistakes": [
                                    "Amostras insuficientes levando a diagnósticos errôneos",
                                    "Não testar múltiplas runs",
                                    "Ignorar correlação entre bias e variância"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estratégias iterativas para otimizar q(x)",
                                  "subSteps": [
                                    "Explorar ajustes paramétricos: otimizar parâmetros de q(x) (ex: média/variância de Gaussiana) via maximização de ESS.",
                                    "Implementar métodos adaptativos: atualizar q(x) baseada em pesos da iteração anterior (ex: mistura de Gaussianas).",
                                    "Testar aproximações: usar momentos dos pesos para ajustar q(x) próxima a p(x)f(x)/Z.",
                                    "Iterar 3-5 ciclos: diagnosticar, ajustar, re-simular e comparar ESS.",
                                    "Avaliar trade-offs: complexidade computacional vs. ganho em ESS."
                                  ],
                                  "verification": "Demonstrar aumento de ESS > 2x após 3 iterações em um caso multimodal.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Otimizadores SciPy (minimize)",
                                    "Biblioteca para misturas (ex: sklearn GMM)",
                                    "Código base de IS adaptativo"
                                  ],
                                  "tips": "Comece com famílias paramétricas simples; evite overfitting a uma run única.",
                                  "learningObjective": "Aplicar iterações baseadas em ESS para refinar q(x).",
                                  "commonMistakes": [
                                    "Atualizações muito agressivas causando instabilidade",
                                    "Não re-normalizar após ajustes",
                                    "Parar iterações prematuramente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar e validar a otimização em simulações complexas",
                                  "subSteps": [
                                    "Aplicar q(x) otimizada em problema complexo (ex: integral em alta dimensão ou rara-eventos).",
                                    "Comparar métricas finais: ESS, variância da estimativa, tempo de convergência vs. baseline.",
                                    "Realizar testes de robustez: variar seeds, n, e perturbar p(x).",
                                    "Documentar pipeline completo: diagnóstico → otimização → validação.",
                                    "Generalizar lições para famílias de problemas semelhantes."
                                  ],
                                  "verification": "Relatório final com gráficos de convergência mostrando ESS > 0.7n e variância reduzida >50%.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Problemas teste complexos (ex: Rosenbrock em 10D)",
                                    "Profiler de tempo (timeit)",
                                    "LaTeX/Jupyter para relatório"
                                  ],
                                  "tips": "Automatize o loop diagnóstico-otimização em função reutilizável.",
                                  "learningObjective": "Validar otimizações em contextos realistas e quantificar ganhos.",
                                  "commonMistakes": [
                                    "Falta de validação cruzada",
                                    "Comparações injustas (diferentes n)",
                                    "Sobreestimar ganhos sem erro padrão"
                                  ]
                                }
                              ],
                              "practicalExample": "Em simulação para estimar P(X > 5) onde X ~ N(0,1) mas com rare-event (tail pesado), iniciar com q(x)=N(0,1), diagnosticar ESS=200/10000=0.02 (degenerado), otimizar para q(x)= mistura Gaussiana tilted para cauda direita, alcançando ESS=6000 após 3 iterações, reduzindo variância em 80%.",
                              "finalVerifications": [
                                "Calcular ESS corretamente para qualquer conjunto de pesos normalizados.",
                                "Diagnosticar baixa ESS (<0.3n) e propor pelo menos 2 ajustes viáveis para q(x).",
                                "Implementar loop iterativo que aumenta ESS consistentemente (>1.5x).",
                                "Comparar estimativas otimizadas vs. métodos alternativos (ex: MCMC) com erro <5%.",
                                "Produzir visualizações claras de pesos antes/depois otimização.",
                                "Aplicar em problema novo com sucesso (ESS >0.5n)"
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de ESS e diagnósticos (erro <1%).",
                                "Efetividade da otimização: ganho em ESS >2x e redução de variância >50%.",
                                "Robustez: performance consistente em 5+ runs independentes.",
                                "Eficiência computacional: tempo total < 2x do baseline não-otimizado.",
                                "Clareza da documentação: gráficos, tabelas e explicações lógicas.",
                                "Generalização: adaptação bem-sucedida a problema não-visto."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Inferência Bayesiana e controle de variância.",
                                "Programação Numérica: Otimização não-linear e simulações estocásticas.",
                                "Machine Learning: Variational Inference e aproximações de distribuições posteriores.",
                                "Física Computacional: Simulações de partículas e rare-events.",
                                "Finanças Quantitativas: Precificação de derivativos via Monte Carlo."
                              ],
                              "realWorldApplication": "Em modelagem de risco financeiro, otimizar q(x) para simular cenários extremos de mercado (Value-at-Risk), reduzindo tempo de computação de dias para horas em clusters, permitindo análises em tempo real para traders."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.2.3"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.5.3",
                        "name": "Comparação e Aplicação em Simulações Discretas",
                        "description": "Análise comparativa entre métodos de amostragem e sua integração em experimentos de simulação para otimizar o planejamento e reduzir tempo computacional.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.3.1",
                            "name": "Comparar eficiência de métodos de amostragem",
                            "description": "Calcular a razão de variâncias e ganhos de eficiência entre amostragem aleatória simples, estratificada e por importância em cenários de simulação de eventos discretos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Métodos de Amostragem",
                                  "subSteps": [
                                    "Definir amostragem aleatória simples (SRS) e sua variância associada em estimadores de simulação.",
                                    "Explicar amostragem estratificada, incluindo divisão da população em estratos homogêneos e redução de variância.",
                                    "Descrever amostragem por importância, destacando pesos de probabilidade e ajuste no estimador.",
                                    "Comparar teoricamente como cada método afeta a variância em eventos discretos raros."
                                  ],
                                  "verification": "Escrever um resumo de 1 página comparando os três métodos, incluindo fórmulas de variância.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Notas de aula sobre simulações de Monte Carlo",
                                    "Referências online sobre métodos de amostragem (ex: Wikipedia ou livros de Ross)",
                                    "Calculadora ou software simbólico como SymPy"
                                  ],
                                  "tips": "Use diagramas para visualizar estratos e pesos de importância.",
                                  "learningObjective": "Compreender as bases teóricas que justificam diferenças de eficiência.",
                                  "commonMistakes": [
                                    "Confundir amostragem estratificada com amostragem por conglomerados",
                                    "Ignorar o ajuste de pesos na amostragem por importância"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar e Implementar Simulações para Cada Método",
                                  "subSteps": [
                                    "Definir um cenário de simulação discreta, como estimar probabilidade de falha em 10.000 eventos Bernoulli.",
                                    "Implementar SRS em Python/R: gerar amostras uniformes e calcular estimador.",
                                    "Adaptar para estratificada: dividir em estratos (ex: alto/baixo risco) e amostrar proporcionalmente.",
                                    "Implementar amostragem por importância: atribuir probabilidades maiores a eventos raros e codificar pesos."
                                  ],
                                  "verification": "Executar código e gerar 1000 réplicas para cada método, salvando saídas em CSV.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy ou R",
                                    "Editor de código (Jupyter Notebook)",
                                    "Dados simulados de eventos discretos"
                                  ],
                                  "tips": "Use funções vetorizadas para eficiência computacional.",
                                  "learningObjective": "Dominar a implementação prática dos métodos em código.",
                                  "commonMistakes": [
                                    "Número insuficiente de réplicas levando a variâncias instáveis",
                                    "Erro na normalização de pesos na amostragem por importância"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Variâncias e Métricas de Eficiência",
                                  "subSteps": [
                                    "Para cada método, calcular variância amostral das réplicas do estimador.",
                                    "Computar razão de variâncias: Var(SRS)/Var(Método) para quantificar ganho.",
                                    "Calcular tempo de computação médio por réplica e eficiência relativa (redução de variância por tempo).",
                                    "Gerar gráficos de distribuições de estimadores e boxplots de variâncias."
                                  ],
                                  "verification": "Tabela com variâncias, razões e ganhos de eficiência para os três métodos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software estatístico (Python Pandas/Matplotlib ou R ggplot2)",
                                    "Planilha Excel para validação manual"
                                  ],
                                  "tips": "Use a fórmula exata Var = E[(X - μ)^2] nas réplicas.",
                                  "learningObjective": "Aplicar fórmulas estatísticas para quantificar eficiência.",
                                  "commonMistakes": [
                                    "Usar desvio padrão em vez de variância nas razões",
                                    "Ignorar viés introduzido por pesos incorretos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e Comparar Resultados",
                                  "subSteps": [
                                    "Interpretar razões de variância: ganhos esperados (ex: estratificada >2x, importância >10x para raros).",
                                    "Discutir cenários onde cada método é superior em eventos discretos.",
                                    "Realizar teste estatístico (ex: F-test) para significância das diferenças de variância.",
                                    "Documentar conclusões em relatório com gráficos e tabelas."
                                  ],
                                  "verification": "Relatório de 2 páginas com análise qualitativa e quantitativa.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Ferramentas de relatório (Markdown ou LaTeX)",
                                    "Biblioteca SciPy.stats para testes"
                                  ],
                                  "tips": "Relacione resultados teóricos com práticos.",
                                  "learningObjective": "Desenvolver habilidades de interpretação crítica de simulações.",
                                  "commonMistakes": [
                                    "Generalizar resultados sem considerar o cenário específico",
                                    "Omitir testes de significância"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Refinar a Comparação",
                                  "subSteps": [
                                    "Repetir simulação com parâmetros variados (ex: p=0.01 vs 0.1) para robustez.",
                                    "Comparar com literatura teórica ou benchmarks conhecidos.",
                                    "Identificar limitações e sugestões de melhorias (ex: combinações híbridas).",
                                    "Preparar apresentação resumida dos achados."
                                  ],
                                  "verification": "Checklist de validação assinado e código versionado (Git).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Git para versionamento",
                                    "Referências acadêmicas sobre eficiência em Monte Carlo"
                                  ],
                                  "tips": "Varie sementes aleatórias para reprodutibilidade.",
                                  "learningObjective": "Garantir rigor científico na comparação.",
                                  "commonMistakes": [
                                    "Sobreajuste a um cenário único",
                                    "Falta de reprodutibilidade no código"
                                  ]
                                },
                                {
                                  "practicalExample": "Em uma simulação de sistema de filas discretas (M/M/1), estime a probabilidade de tempo de espera >10 unidades usando SRS (uniforme), estratificada (por carga do sistema) e por importância (pesos altos para filas longas). Calcule variâncias após 5000 réplicas: espere Var(SRS)/Var(Importância) ≈ 50.",
                                  "finalVerifications": [
                                    "Variâncias calculadas corretamente para todos os métodos.",
                                    "Razões de variância >1 confirmando ganhos de eficiência.",
                                    "Gráficos mostram redução visual de variância.",
                                    "Testes estatísticos rejeitam H0 de variâncias iguais.",
                                    "Conclusões alinhadas com teoria.",
                                    "Código executável e reprodutível.",
                                    "Relatório completo sem erros matemáticos."
                                  ],
                                  "assessmentCriteria": [
                                    "Precisão dos cálculos de variância (erro <5%).",
                                    "Eficiência relativa quantificada corretamente (>2x para estratificada).",
                                    "Análise inclui interpretação contextual.",
                                    "Gráficos claros e informativos.",
                                    "Código limpo, comentado e eficiente.",
                                    "Relatório lógico e bem estruturado.",
                                    "Demonstração de compreensão teórica-prática."
                                  ],
                                  "crossCurricularConnections": [
                                    "Estatística: Inferência e testes de variância.",
                                    "Programação: Simulações numéricas em Python/R.",
                                    "Ciência de Dados: Otimização de Monte Carlo.",
                                    "Engenharia: Modelagem de sistemas estocásticos.",
                                    "Física Computacional: Simulações de partículas discretas."
                                  ],
                                  "realWorldApplication": "Em finanças, otimizar simulações de risco (Value-at-Risk) para eventos raros como crashes de mercado, reduzindo tempo de computação de dias para horas com amostragem por importância, permitindo análises em tempo real para traders.",
                                  "stepNumber": 4,
                                  "title": "Implementação e Comparação de Técnicas de Redução de Variância em Simulação M/M/1",
                                  "subSteps": [
                                    "Implementar simulação básica de sistema de filas M/M/1 (chegadas Poisson, serviços exponenciais).",
                                    "Desenvolver estimador via SRS (amostragem aleatória simples uniforme) para P(tempo de espera > 10).",
                                    "Implementar amostragem estratificada, estratificando por carga do sistema (ρ).",
                                    "Implementar amostragem por importância, atribuindo pesos altos a configurações com filas longas.",
                                    "Executar 5000 réplicas independentes para cada método e calcular variâncias das estimativas.",
                                    "Gerar gráficos comparativos de variâncias e realizar testes estatísticos (ex: F-test para variâncias)."
                                  ],
                                  "verification": [
                                    "Variâncias calculadas corretamente para os três métodos.",
                                    "Razão Var(SRS)/Var(Importância) ≈ 50.",
                                    "Gráficos exibem redução clara de variância.",
                                    "Código roda sem erros e é reprodutível."
                                  ],
                                  "estimatedTime": "6-8 horas",
                                  "materials": [
                                    "Python 3.x com bibliotecas NumPy, SciPy e Matplotlib.",
                                    "Ambiente Jupyter Notebook ou Google Colab.",
                                    "Documentação de simulações estocásticas (opcional)."
                                  ],
                                  "tips": [
                                    "Fixe sementes aleatórias (np.random.seed) para reprodutibilidade.",
                                    "Descarte período transiente (warm-up) na simulação de filas para regime estacionário.",
                                    "Normalize pesos na amostragem por importância para evitar bias.",
                                    "Use vetores NumPy para eficiência computacional em réplicas.",
                                    "Valide o modelo M/M/1 com fórmulas analíticas conhecidas (ex: L = ρ/(1-ρ))."
                                  ],
                                  "learningObjective": "Implementar e comparar métodos de redução de variância (SRS, estratificada e por importância) em simulações Monte Carlo de sistemas de filas discretas, quantificando ganhos de eficiência (razões de variância) e demonstrando aplicação prática em modelagem estocástica.",
                                  "commonMistakes": [
                                    "Não descartar o período transiente, levando a estimativas enviesadas.",
                                    "Cálculo incorreto de variância (confundir variância amostral com populacional).",
                                    "Falta de normalização nos pesos da amostragem por importância, causando bias.",
                                    "Réplicas não independentes (não regenerar o sistema entre runs).",
                                    "Escolha inadequada de strata ou função de importância, sem ganho de variância."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de 10.000 eventos Bernoulli independentes com p=0.001 (falha rara), estime a probabilidade de pelo menos uma falha usando SRS (amostragem uniforme), estratificada (estratos de alto/baixo risco com oversampling) e por importância (distribuição inclinada para falhas com pesos ajustados). Execute 5000 réplicas e calcule variâncias: espere Var(SRS)/Var(Importância) ≈ 100.",
                              "finalVerifications": [
                                "Variâncias calculadas corretamente para SRS, estratificada e importância.",
                                "Razões de variância >1, confirmando redução de variância.",
                                "Gráficos (histogramas/boxplots) evidenciam diferenças visuais.",
                                "Testes estatísticos (ex: F-test) rejeitam igualdade de variâncias.",
                                "Resultados alinhados com teoria (ganhos maiores para eventos raros).",
                                "Código executável, versionado e reprodutível com sementes fixas.",
                                "Relatório completo, sem erros em fórmulas ou interpretações."
                              ],
                              "assessmentCriteria": [
                                "Cálculos de variância precisos (erro relativo <5%).",
                                "Quantificação correta de eficiência (ex: >2x estratificada, >10x importância).",
                                "Interpretação crítica relacionando teoria e prática.",
                                "Gráficos profissionais, legíveis e informativos.",
                                "Código limpo, modular, comentado e otimizado.",
                                "Relatório estruturado com introdução, métodos, resultados e conclusões.",
                                "Evidência de compreensão integrada teórico-prática."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Redução de variância e inferência em simulações.",
                                "Programação: Implementação eficiente de simulações em Python/R.",
                                "Ciência de Dados: Técnicas de Monte Carlo para big data estocástico.",
                                "Engenharia: Análise de confiabilidade em sistemas discretos.",
                                "Física Computacional: Simulações de processos estocásticos discretos."
                              ],
                              "realWorldApplication": "Na indústria aeroespacial, simular falhas raras em componentes (ex: probabilidade de falha em missões espaciais) usando amostragem por importância para reduzir variância de 10^6 para 10^3 réplicas, acelerando certificações de segurança de semanas para dias."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.1.1",
                              "10.1.3.5.2.1"
                            ]
                          },
                          {
                            "id": "10.1.3.5.3.2",
                            "name": "Planejar experimentos com métodos de amostragem",
                            "description": "Integrar técnicas de amostragem em projetos de simulação, definindo critérios para escolha do método baseado em custo computacional e precisão desejada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar o Problema e Definir Requisitos do Experimento",
                                  "subSteps": [
                                    "Descreva o sistema discreto a ser simulado (ex.: processo de fila, rede de eventos).",
                                    "Especifique os objetivos principais: o que medir (ex.: tempo médio de espera)?",
                                    "Defina métricas de precisão desejada (ex.: erro < 5%) e restrições de custo computacional (ex.: < 10^6 amostras).",
                                    "Liste variáveis de entrada e saída relevantes.",
                                    "Documente suposições iniciais sobre a distribuição dos eventos."
                                  ],
                                  "verification": "Checklist preenchido com problema, objetivos, precisão e custo documentados.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Referências sobre o sistema discreto"
                                  ],
                                  "tips": "Comece com um diagrama simples do sistema para visualizar fluxos.",
                                  "learningObjective": "Compreender como alinhar requisitos do experimento com o problema real.",
                                  "commonMistakes": [
                                    "Ignorar restrições computacionais realistas",
                                    "Definir precisão vaga sem métricas numéricas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar e Listar Métodos de Amostragem Aplicáveis",
                                  "subSteps": [
                                    "Liste métodos relevantes: amostragem aleatória simples, rejeição, importância, MCMC para discretos.",
                                    "Resuma prós e contras de cada um em termos de precisão e custo (ex.: tabela comparativa).",
                                    "Identifique dependências do sistema (ex.: eventos raros favorecem amostragem por importância).",
                                    "Consulte literatura ou exemplos prévios para cada método.",
                                    "Classifique métodos por adequação inicial ao problema."
                                  ],
                                  "verification": "Tabela comparativa completa com pelo menos 4 métodos listados.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro ou notas sobre métodos de amostragem",
                                    "Planilha ou tabela em software como Excel/Google Sheets"
                                  ],
                                  "tips": "Use uma matriz de decisão para organizar prós/contras visualmente.",
                                  "learningObjective": "Dominar o repertório de métodos de amostragem para simulações discretas.",
                                  "commonMistakes": [
                                    "Limitar a lista a métodos familiares",
                                    "Não considerar adaptações para eventos discretos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar Trade-offs e Selecionar Método Ótimo",
                                  "subSteps": [
                                    "Calcule estimativas aproximadas de custo (ex.: tempo de CPU por amostra) e variância para cada método.",
                                    "Aplique critérios quantitativos: custo * variância < threshold definido.",
                                    "Simule cenários hipotéticos para testar sensibilidade (ex.: variar tamanho de amostra).",
                                    "Justifique a escolha com argumentos baseados em precisão vs. custo.",
                                    "Considere métodos híbridos se necessário (ex.: amostragem estratificada + importância)."
                                  ],
                                  "verification": "Relatório de 1 página com cálculos, gráficos de trade-off e justificativa da escolha.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Calculadora ou Python/Jupyter para estimativas rápidas",
                                    "Gráficos de variância vs. custo"
                                  ],
                                  "tips": "Priorize métodos com variância reduzida para eventos raros.",
                                  "learningObjective": "Aprender a quantificar e otimizar trade-offs em amostragem.",
                                  "commonMistakes": [
                                    "Escolha subjetiva sem cálculos",
                                    "Subestimar custo em cenários de alta dimensionalidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Projetar e Documentar o Plano do Experimento",
                                  "subSteps": [
                                    "Defina tamanho da amostra baseado em análise de poder estatístico.",
                                    "Especifique replicações (ex.: 100 runs) e intervalos de confiança.",
                                    "Descreva pipeline de implementação: geração de amostras, simulação, agregação.",
                                    "Inclua plano de validação (ex.: teste com dados conhecidos).",
                                    "Crie cronograma e orçamento computacional."
                                  ],
                                  "verification": "Plano completo em formato de documento com todas seções preenchidas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Template de plano de experimento",
                                    "Software de diagramação como Draw.io"
                                  ],
                                  "tips": "Use fluxogramas para ilustrar o pipeline de simulação.",
                                  "learningObjective": "Estruturar um plano executável e reprodutível.",
                                  "commonMistakes": [
                                    "Omitir replicações levando a resultados instáveis",
                                    "Plano vago sem detalhes implementáveis"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado (sistema discreto com chegadas Poisson e serviço exponencial), planeje usar amostragem por importância para estimar probabilidade de fila >10 clientes (evento raro), escolhendo-a sobre aleatória simples pois reduz variância em 80% com custo 2x maior, visando precisão de 2% com 10^5 amostras.",
                              "finalVerifications": [
                                "O plano inclui tabela comparativa de métodos com trade-offs quantificados.",
                                "Justificativa da escolha demonstra equilíbrio custo-precisão.",
                                "Tamanho de amostra calculado com base em variância esperada.",
                                "Pipeline documentado é reprodutível por terceiros.",
                                "Validações preliminares propostas para sanity check.",
                                "Cronograma realista considerando recursos computacionais."
                              ],
                              "assessmentCriteria": [
                                "Clareza na identificação de requisitos (precisão e custo).",
                                "Profundidade na comparação de métodos (quantitativa).",
                                "Justificativa robusta da seleção baseada em evidências.",
                                "Completude do design experimental (amostras, replicações).",
                                "Qualidade da documentação e visualizações.",
                                "Viabilidade prática e inovação em trade-offs."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Cálculo de variância e intervalos de confiança.",
                                "Programação: Implementação em Python (NumPy, SciPy para simulações).",
                                "Otimização: Técnicas de minimização custo-precisão.",
                                "Gestão de Projetos: Planejamento e cronogramas.",
                                "Ciência de Dados: Análise de sensibilidade e validação."
                              ],
                              "realWorldApplication": "Em finanças, planejar simulações Monte Carlo para risco de portfólio usando amostragem de importância para cenários extremos de mercado, otimizando precisão para relatórios regulatórios sem exceder limites de computação em nuvem."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.3.1"
                            ]
                          },
                          {
                            "id": "10.1.3.5.3.3",
                            "name": "Validar resultados de simulações otimizadas",
                            "description": "Aplicar testes estatísticos para validar modelos simulados com amostragem avançada, garantindo robustez contra viés e variância residual.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e revisar dados da simulação otimizada",
                                  "subSteps": [
                                    "Colete os resultados da simulação com amostragem avançada (ex: MCMC ou importance sampling).",
                                    "Verifique a convergência da simulação usando diagnósticos como trace plots e Gelman-Rubin statistic.",
                                    "Calcule estatísticas descritivas básicas: média, variância, histogramas e Q-Q plots.",
                                    "Identifique potenciais fontes de viés na amostragem (ex: autocorrelação).",
                                    "Documente parâmetros da simulação para reproducibilidade."
                                  ],
                                  "verification": "Dados limpos e diagnósticos de convergência confirmados (R-hat < 1.1).",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Software de análise (Python com PyMC3/Stan ou R com coda)",
                                    "Dados da simulação em CSV ou formato nativo"
                                  ],
                                  "tips": [
                                    "Use funções prontas como arviz para plots de diagnóstico.",
                                    "Salve checkpoints para evitar perda de dados."
                                  ],
                                  "learningObjective": "Garantir que os dados da simulação estejam prontos para testes estatísticos sem artefatos iniciais.",
                                  "commonMistakes": [
                                    "Ignorar autocorrelação, levando a variância subestimada.",
                                    "Não verificar convergência, invalidando resultados."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e configurar testes estatísticos apropriados",
                                  "subSteps": [
                                    "Escolha testes para viés: Kolmogorov-Smirnov (KS) ou Anderson-Darling para goodness-of-fit contra distribuição teórica.",
                                    "Selecione testes para variância residual: teste de Levene ou Bartlett para homogeneidade de variâncias.",
                                    "Para independência em simulações discretas: teste de runs ou Durbin-Watson para autocorrelação.",
                                    "Defina hipóteses nulas (H0: sem viés/variância excessiva) e níveis de significância (α=0.05).",
                                    "Prepare subconjuntos de dados se necessário (ex: thinning para reduzir autocorrelação)."
                                  ],
                                  "verification": "Lista de testes selecionados com justificativa e código configurado pronto para execução.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação de testes (SciPy.stats em Python ou stats em R)",
                                    "Notebooks Jupyter para prototipagem"
                                  ],
                                  "tips": [
                                    "Priorize testes não-paramétricos para distribuições desconhecidas.",
                                    "Considere poder estatístico com simulações piloto."
                                  ],
                                  "learningObjective": "Dominar a escolha de testes que detectem especificamente viés e variância em simulações.",
                                  "commonMistakes": [
                                    "Usar testes paramétricos em dados não-normais.",
                                    "Escolher testes inadequados para o tipo de simulação discreta."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar testes e analisar resultados iniciais",
                                  "subSteps": [
                                    "Implemente e rode os testes selecionados em código.",
                                    "Calcule estatísticas: p-values, estatísticas de teste e intervalos de confiança.",
                                    "Gere visualizações: plots de resíduos, boxplots comparativos e heatmaps de correlação.",
                                    "Compare resultados simulados com benchmarks analíticos ou dados reais.",
                                    "Registre discrepâncias quantitativamente (ex: KS distance < 0.05)."
                                  ],
                                  "verification": "Relatório com p-values e plots gerados, sem erros de execução.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Bibliotecas: SciPy, NumPy, Matplotlib/Seaborn",
                                    "Dados preparados do Step 1"
                                  ],
                                  "tips": [
                                    "Automatize com funções wrapper para múltiplos testes.",
                                    "Use seed para reproducibilidade em re-runs."
                                  ],
                                  "learningObjective": "Executar testes com precisão e interpretar saídas estatísticas corretamente.",
                                  "commonMistakes": [
                                    "Interpretar p-value baixo como 'viés sempre ruim' sem contexto.",
                                    "Não ajustar por múltiplos testes (Bonferroni)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados e validar robustez geral",
                                  "subSteps": [
                                    "Avalie se p-values > α indicam ausência de viés/variância significativa.",
                                    "Quantifique robustez: effective sample size (ESS) > 1000 por parâmetro.",
                                    "Teste sensibilidade variando sementes ou tamanhos de amostra.",
                                    "Recomende ajustes se falhar (ex: mais iterações, melhor amostragem).",
                                    "Gere relatório final com conclusões e métricas de confiança."
                                  ],
                                  "verification": "Conclusão clara: 'Validado' ou 'Rejeitado com recomendações', suportada por evidências.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Templates de relatório (Markdown ou LaTeX)",
                                    "Ferramentas de ESS como coda em R"
                                  ],
                                  "tips": [
                                    "Use posterior predictive checks para validação extra.",
                                    "Documente decisões para auditoria."
                                  ],
                                  "learningObjective": "Integrar análises para uma validação holística da simulação.",
                                  "commonMistakes": [
                                    "Sobre-generalizar de um teste falho.",
                                    "Ignorar variância em subpopulações."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação Monte Carlo para estimar o risco de falha em uma rede elétrica discreta usando importance sampling, aplique KS test para validar se a distribuição de tempos de falha simulados matches a teórica exponencial, e teste de Levene para variância residual entre runs, garantindo que o modelo otimizado seja robusto para decisões de manutenção preditiva.",
                              "finalVerifications": [
                                "Todos p-values dos testes principais > 0.05.",
                                "Effective sample size (ESS) > 1000 para parâmetros chave.",
                                "KS distance ou equivalente < threshold contextual (ex: 0.03).",
                                "Ausência de autocorrelação significativa (Durbin-Watson ~2).",
                                "Visualizações confirmam ausência de padrões anômalos em resíduos.",
                                "Relatório reproduzível gera os mesmos resultados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na seleção e justificativa de testes (80% adequados).",
                                "Correta implementação e ausência de erros computacionais.",
                                "Interpretação estatística rigorosa com thresholds claros.",
                                "Cobertura completa de viés e variância em múltiplas dimensões.",
                                "Relatório claro, visual e acionável.",
                                "Sensibilidade testada com variações de parâmetros."
                              ],
                              "crossCurricularConnections": [
                                "Estatística Inferencial: Testes de hipóteses e p-values.",
                                "Programação Científica: Implementação em Python/R para simulações.",
                                "Ciência de Dados: Análise exploratória e diagnósticos MCMC.",
                                "Engenharia de Sistemas: Validação de modelos em simulações discretas.",
                                "Probabilidade Avançada: Teoria de amostragem e convergência."
                              ],
                              "realWorldApplication": "Na indústria farmacêutica, validar simulações otimizadas de ensaios clínicos discretos para prever eficácia de drogas, detectando viés em amostragem para aprovações regulatórias da FDA; ou em finanças, confirmando robustez de modelos de risco Value-at-Risk contra variância residual para compliance Basel III."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.4",
                "name": "Linguagens e Avaliação de Software de Simulação",
                "description": "Discute linguagens específicas para simulação e critérios para avaliar softwares de simulação.",
                "totalSkills": 51,
                "atomicTopics": [
                  {
                    "id": "10.1.4.1",
                    "name": "Linguagens Especializadas de Simulação",
                    "description": "Linguagens dedicadas como GPSS, SIMSCRIPT e SLAM para modelagem de eventos discretos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.1.1.1",
                        "name": "GPSS (General Purpose Simulation System)",
                        "description": "Linguagem especializada para modelagem de simulação de eventos discretos, focada em sistemas de filas e transações.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.1.1.1",
                            "name": "Compreender blocos básicos do GPSS",
                            "description": "Identificar e explicar blocos fundamentais como GENERATE, QUEUE, SEIZE, DEPART e TERMINATE para modelar fluxos de transações em sistemas discretos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender conceitos fundamentais de transações e blocos em GPSS",
                                  "subSteps": [
                                    "Estude o conceito de 'transação' como entidade que flui pelo modelo de simulação.",
                                    "Identifique o papel dos blocos como instruções que controlam o movimento das transações.",
                                    "Revise a estrutura básica de um programa GPSS: statements sequenciais.",
                                    "Analise diagramas de fluxo para visualizar transações passando por blocos.",
                                    "Diferencie simulação discreta de contínua, focando em eventos discretos."
                                  ],
                                  "verification": "Explique em suas palavras o que é uma transação e liste 3 funções de blocos em GPSS.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação oficial GPSS (capítulo introdutório)",
                                    "Vídeo tutorial sobre conceitos básicos de GPSS",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Comece desenhando um fluxo simples para visualizar melhor.",
                                  "learningObjective": "Compreender transações e blocos como base para modelagem.",
                                  "commonMistakes": [
                                    "Confundir transações com processos reais",
                                    "Ignorar a natureza sequencial dos blocos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar blocos de criação e término: GENERATE e TERMINATE",
                                  "subSteps": [
                                    "Aprenda GENERATE: sintaxe, parâmetros (tempo médio, desvio, etc.) e como inicia transações.",
                                    "Pratique exemplos de GENERATE com distribuições Poisson e fixa.",
                                    "Entenda TERMINATE: como finaliza transações e libera recursos.",
                                    "Compare GENERATE e TERMINATE em termos de fluxo de entrada/saída.",
                                    "Simule mentalmente um ciclo simples: GENERATE -> ... -> TERMINATE."
                                  ],
                                  "verification": "Escreva um snippet de código GPSS usando apenas GENERATE e TERMINATE que gere 10 transações por hora.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Simulador GPSS online ou GPSS World Student Edition",
                                    "Exemplos de código GPSS básicos",
                                    "Planilha para calcular taxas de geração"
                                  ],
                                  "tips": "Use o simulador para rodar códigos curtos e observar saídas.",
                                  "learningObjective": "Dominar blocos de controle de fluxo de transações.",
                                  "commonMistakes": [
                                    "Esquecer parâmetros de distribuição em GENERATE",
                                    "Usar TERMINATE prematuramente sem processar"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar blocos de fila e recursos: QUEUE, SEIZE e DEPART",
                                  "subSteps": [
                                    "Estude QUEUE: entrada em fila, parâmetros de localização e como monitora esperas.",
                                    "Aprenda SEIZE: alocação de recursos (facilities), bloqueio se indisponível.",
                                    "Entenda DEPART: saída da fila, atualização de contadores.",
                                    "Integre os três: QUEUE -> SEIZE -> DEPART para modelar contenção.",
                                    "Analise relatórios de simulação para métricas de fila e utilização."
                                  ],
                                  "verification": "Descreva o fluxo de uma transação passando por QUEUE, SEIZE e DEPART.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Documentação GPSS sobre facilities e queues",
                                    "Exemplos de modelos de fila única",
                                    "Ferramenta de simulação GPSS"
                                  ],
                                  "tips": "Sempre associe nomes lógicos a queues e facilities para clareza.",
                                  "learningObjective": "Modelar esperas e alocação de recursos limitados.",
                                  "commonMistakes": [
                                    "Confundir QUEUE com STORAGE",
                                    "Esquecer DEPART correspondente ao QUEUE"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar blocos em um modelo completo e analisar",
                                  "subSteps": [
                                    "Monte um programa GPSS simples: GENERATE -> QUEUE -> SEIZE -> DEPART -> TERMINATE.",
                                    "Execute a simulação e interprete relatórios (tempo médio na fila, utilização).",
                                    "Varie parâmetros (ex: mais transações) e observe impactos.",
                                    "Debugue erros comuns como loops infinitos ou filas vazias.",
                                    "Documente o modelo com comentários explicativos."
                                  ],
                                  "verification": "Rode o modelo e produza um relatório resumindo métricas chave.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Editor de texto ou IDE GPSS",
                                    "Simulador completo GPSS",
                                    "Templates de modelos básicos"
                                  ],
                                  "tips": "Comece com poucos recursos para evitar complexidade inicial.",
                                  "learningObjective": "Construir e analisar fluxos discretos completos.",
                                  "commonMistakes": [
                                    "Não definir START e STOP adequadamente",
                                    "Ignorar escalas de tempo nas simulações"
                                  ]
                                }
                              ],
                              "practicalExample": "Modelar uma fila de caixa em supermercado: GENERATE cria clientes a cada 2 minutos (Poisson), QUEUE para fila, SEIZE para o caixa (1 recurso), DEPART após atendimento, TERMINATE ao sair.",
                              "finalVerifications": [
                                "Explique a sequência exata de blocos para uma transação típica.",
                                "Identifique métricas reportadas por cada bloco (ex: Q-table para QUEUE).",
                                "Modifique um modelo para dobrar a chegada e preveja impactos.",
                                "Debugue um código com erro de SEIZE sem RELEASE.",
                                "Compare GPSS com pseudocódigo equivalente.",
                                "Gere relatório de simulação com pelo menos 1000 transações."
                              ],
                              "assessmentCriteria": [
                                "Precisão na sintaxe e parâmetros dos blocos (90% correto).",
                                "Capacidade de explicar funções e interações (detalhes lógicos).",
                                "Análise correta de relatórios de simulação (métricas interpretadas).",
                                "Modelo funcional sem erros de compilação/execução.",
                                "Criatividade em variações paramétricas e impactos.",
                                "Documentação clara com comentários e diagramas."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: distribuições em GENERATE.",
                                "Programação: estruturas sequenciais e controle de fluxo.",
                                "Gestão de Operações: modelagem de filas e gargalos.",
                                "Computação: simulação discreta vs. orientada a objetos.",
                                "Matemática Aplicada: teoria de filas (M/M/1)."
                              ],
                              "realWorldApplication": "Usado em manufatura para simular linhas de produção (ex: alocação de máquinas via SEIZE), logística para filas de carregamento, ou call centers para modelar atendimentos e esperas, otimizando recursos reais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.1.2",
                            "name": "Modelar sistemas de filas com GPSS",
                            "description": "Construir modelos simples de filas M/M/1 e M/G/1 utilizando comandos GPSS para simular chegadas, serviços e estatísticas de desempenho.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o Ambiente GPSS e Entender Conceitos Básicos de Filas",
                                  "subSteps": [
                                    "Instale o GPSS World Student Edition ou versão compatível gratuita.",
                                    "Crie um novo arquivo .gps e compile um programa de teste simples com GENERATE e TERMINATE.",
                                    "Estude os conceitos de M/M/1 (chegadas Poisson, serviço exponencial, 1 servidor) e M/G/1 (serviço de distribuição geral).",
                                    "Defina parâmetros iniciais: taxa de chegada λ (ex: 0.2 por minuto), taxa de serviço μ (ex: 0.25 por minuto).",
                                    "Revise blocos GPSS chave: GENERATE, SEIZE, ADVANCE, RELEASE, QUEUE, DEPART."
                                  ],
                                  "verification": "Programa de teste compila e executa sem erros, exibindo estatísticas básicas de transações.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "GPSS World Student Edition",
                                    "Manual GPSS/H",
                                    "Documentação online GPSS"
                                  ],
                                  "tips": "Use o editor integrado do GPSS para sintaxe highlighting e debugging.",
                                  "learningObjective": "Preparar ambiente e compreender fundamentos teóricos para modelagem de filas.",
                                  "commonMistakes": [
                                    "Ignorar unidades de tempo consistentes (minutos vs horas)",
                                    "Confundir λ e μ",
                                    "Não definir STORAGE ou FACILITY corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar Chegadas e Entrada na Fila (Componente M/ )",
                                  "subSteps": [
                                    "Use GENERATE para simular chegadas Poisson com intervalo médio 1/λ (ex: FUNCTION para variabilidade).",
                                    "Adicione QUEUE para registrar entrada na fila de espera.",
                                    "Implemente SEIZE para capturar o servidor (FACILITY Server).",
                                    "Teste o modelo parcial rodando 1000 transações e verificando taxa de chegada.",
                                    "Adicione comentários no código explicando cada bloco."
                                  ],
                                  "verification": "Estatísticas mostram taxa de chegada próxima a λ e fila se formando corretamente.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Editor GPSS",
                                    "Exemplos de código GPSS de filas",
                                    "Calculadora para validar λ"
                                  ],
                                  "tips": "Defina uma FUNCTION exponencial para intervalos de chegada realistas.",
                                  "learningObjective": "Implementar geração de transações e enfileiramento inicial.",
                                  "commonMistakes": [
                                    "Usar tempo fixo em GENERATE ao invés de exponencial",
                                    "Esquecer de nomear QUEUE corretamente",
                                    "SEIZE sem FACILITY pré-definido"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Serviço e Saída para M/M/1",
                                  "subSteps": [
                                    "Adicione ADVANCE com distribuição exponencial para tempo de serviço (média 1/μ).",
                                    "Inclua DEPART da fila após SEIZE e RELEASE do servidor após ADVANCE.",
                                    "Configure contadores: SAVEVALUE para estatísticas personalizadas, TABLE para histogramas de espera.",
                                    "Rode simulação com 5000 transações e colete métricas: utilização, comprimento fila médio.",
                                    "Compare resultados com fórmulas teóricas: Lq = ρ²/(1-ρ), onde ρ=λ/μ."
                                  ],
                                  "verification": "Utilização do servidor ≈ ρ (ex: 80%) e comprimento fila próximo à teoria.",
                                  "estimatedTime": "2.5 hours",
                                  "materials": [
                                    "GPSS Reference Manual",
                                    "Planilhas para fórmulas de filas",
                                    "Amostras de código M/M/1"
                                  ],
                                  "tips": "Use X$TRANTIN para tempo total e calcular esperas como (X$TRANTIN - tempo chegada - serviço).",
                                  "learningObjective": "Completar modelo M/M/1 com serviço exponencial e coleta de dados.",
                                  "commonMistakes": [
                                    "RELEASE antes de DEPART",
                                    "Distribuição errada em ADVANCE (uniforme ao invés de expo)",
                                    "Número insuficiente de transações para convergência"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estender para M/G/1 e Análise de Estatísticas",
                                  "subSteps": [
                                    "Modifique ADVANCE para distribuição geral (ex: FUNCTION com Erlang ou hyperexponential para G).",
                                    "Adicione mais TABLES para tempo na sistema, espera e serviço.",
                                    "Implemente START e STOP para controlar duração da simulação (ex: tempo fixo ou número de transações).",
                                    "Execute múltiplas runs (warm-up period de 1000 transações) e gere relatório com médias/confiança.",
                                    "Valide contra teoria: Pollaczek-Khinchine para Lq em M/G/1."
                                  ],
                                  "verification": "Modelo M/G/1 roda, estatísticas variam com mudança na distribuição de serviço.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Livro 'Simulation Modeling with GPSS'",
                                    "Ferramentas de plotagem (Excel para exportar stats)"
                                  ],
                                  "tips": "Defina múltiplas FUNCTIONS para testar diferentes G (ex: constante, Erlang-2).",
                                  "learningObjective": "Adaptar modelo para serviço geral e analisar desempenho.",
                                  "commonMistakes": [
                                    "Não resetar contadores entre runs",
                                    "Ignorar warm-up para eliminar bias inicial",
                                    "Função de serviço mal parametrizada"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Otimizar, Debuggar e Documentar o Modelo",
                                  "subSteps": [
                                    "Debugue erros comuns: overflow de transações, filas infinitas (se ρ>1).",
                                    "Otimize código com loops ou sub-rotinas para cenários múltiplos.",
                                    "Gere relatório: gráficos de stats, comparação teórica vs simulada.",
                                    "Documente o código com ; comentários e seção de parâmetros editáveis.",
                                    "Teste sensibilidade variando λ e μ."
                                  ],
                                  "verification": "Modelo documentado roda para diferentes parâmetros com resultados consistentes.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Debugger GPSS",
                                    "Templates de relatório de simulação"
                                  ],
                                  "tips": "Salve versões incrementais do arquivo .gps.",
                                  "learningObjective": "Finalizar modelo robusto e interpretável.",
                                  "commonMistakes": [
                                    "ρ >=1 causando instabilidade",
                                    "Falta de normalização em médias",
                                    "Comentários insuficientes"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule uma fila de caixa em supermercado: λ=12 clientes/hora (Poisson), serviço exponencial μ=15/hora para M/M/1; para M/G/1, serviço Erlang-2 com média 15/hora. Rode 8 horas simuladas e analise tempo médio de espera (deve ser ~4 min em M/M/1).",
                              "finalVerifications": [
                                "Simulação executa 5000+ transações sem erros ou crashes.",
                                "Utilização do servidor está entre 70-90% para ρ=0.8.",
                                "Comprimento médio da fila Lq próximo a fórmula teórica (erro <5%).",
                                "Histogramas de tempo de espera mostram distribuição plausível.",
                                "Mudança para M/G/1 aumenta variância corretamente.",
                                "Relatório exportado com médias, desvios e intervalos de confiança."
                              ],
                              "assessmentCriteria": [
                                "Precisão das estatísticas simuladas vs teóricas (erro <10%).",
                                "Código GPSS limpo, comentado e modular.",
                                "Uso correto de blocos GPSS para filas (QUEUE/SEIZE/ADVANCE/RELEASE).",
                                "Análise inclui warm-up e múltiplas runs para confiabilidade.",
                                "Documentação explica parâmetros, resultados e limitações.",
                                "Capacidade de adaptar modelo para novos cenários."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: Distribuições Poisson, exponencial e geral.",
                                "Programação: Lógica de eventos discretos e blocos de simulação.",
                                "Pesquisa Operacional: Teoria de filas e fórmulas como Little's Law.",
                                "Engenharia de Software: Debugging e validação de modelos.",
                                "Análise de Dados: Interpretação de histogramas e intervalos de confiança."
                              ],
                              "realWorldApplication": "Otimizar dimensionamento de servidores em call centers, reduzir esperas em aeroportos de check-in ou filas de atendimento em hospitais, permitindo testes de 'what-if' sem disrupção real."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.1.3",
                            "name": "Analisar saídas e estatísticas no GPSS",
                            "description": "Interpretar relatórios gerados pelo GPSS, incluindo tabelas de tempo no sistema, utilização de recursos e comprimento de filas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Acessar e revisar o relatório principal gerado pelo GPSS",
                                  "subSteps": [
                                    "Execute o programa de simulação GPSS para gerar o relatório de saída padrão.",
                                    "Localize a seção 'Simulation Report' ou equivalente no output.",
                                    "Identifique as principais seções: Summary, Time in System, Utilization, Queue Lengths.",
                                    "Anote o número de transações processadas e o tempo de simulação total.",
                                    "Verifique se a simulação convergiu sem erros (ex: número de eventos esperados)."
                                  ],
                                  "verification": "Confirme que o relatório foi gerado sem erros e todas as seções principais estão presentes.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Software GPSS/H ou GPSS World instalado",
                                    "Programa de simulação de exemplo salvo (.gps)",
                                    "Manual de referência GPSS para estrutura de relatórios"
                                  ],
                                  "tips": "Sempre salve o relatório em arquivo texto para análise posterior; use busca por palavras-chave como 'UTILIZATION' ou 'QUEUE'.",
                                  "learningObjective": "Compreender a estrutura geral do relatório GPSS e identificar seções chave.",
                                  "commonMistakes": [
                                    "Ignorar mensagens de erro no início do relatório",
                                    "Confundir simulações múltiplas em um output concatenado",
                                    "Não notar o tempo de relógio de simulação final"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Interpretar a tabela de tempo no sistema (Time in System)",
                                  "subSteps": [
                                    "Localize a tabela 'Time in System Statistics' para entidades/transações.",
                                    "Identifique métricas chave: Average Time, Minimum Time, Maximum Time, Entries.",
                                    "Calcule manualmente a variância aproximada se necessário (usando fórmula básica).",
                                    "Compare com benchmarks esperados baseados no modelo (ex: tempo teórico de fila M/M/1).",
                                    "Registre percentis (ex: 90th percentile) para entender distribuição."
                                  ],
                                  "verification": "Explique em palavras o que significa o tempo médio no sistema e cite valores exatos da tabela.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Relatório GPSS gerado",
                                    "Calculadora ou planilha Excel para cálculos auxiliares",
                                    "Tabelas de distribuição de probabilidade para comparação"
                                  ],
                                  "tips": "Foquem em 'Average Time in System' como métrica principal para performance; plote histogramas se disponível.",
                                  "learningObjective": "Analisar e interpretar estatísticas de tempo no sistema para avaliar eficiência do modelo.",
                                  "commonMistakes": [
                                    "Confundir 'Time in System' com 'Response Time'",
                                    "Ignorar o número de entradas para normalizar médias",
                                    "Não considerar unidades de tempo (horas, minutos)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar utilização de recursos e facilities",
                                  "subSteps": [
                                    "Encontre a seção 'Facility Utilization' listando cada facility (ex: SEIZE/RELEASE).",
                                    "Registre % Utilization, Average Queue, Maximum Queue para cada uma.",
                                    "Identifique facilities com utilização >80% como potenciais gargalos.",
                                    "Calcule taxa de ociosidade (100% - Utilization) e discuta implicações.",
                                    "Compare utilizações entre facilities para balanceamento."
                                  ],
                                  "verification": "Liste facilities com alta utilização e proponha ajustes no modelo para reduzi-la.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Relatório GPSS",
                                    "Gráfico de barras em Excel para visualização de utilizações",
                                    "Referência GPSS para comandos FACILITY"
                                  ],
                                  "tips": "Utilização ideal está entre 70-90%; abaixo indica subutilização, acima indica congestionamento.",
                                  "learningObjective": "Avaliar o uso eficiente de recursos simulados e detectar gargalos.",
                                  "commonMistakes": [
                                    "Interpretar 100% utilization como erro (é possível em picos)",
                                    "Não diferenciar entre facilities e storages",
                                    "Esquecer de multiplicar por número de réplicas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Examinar comprimento de filas e sintetizar resultados",
                                  "subSteps": [
                                    "Localize 'Queue Statistics' para cada QUEUE block.",
                                    "Analise Average Length, Maximum Length, Zero Entries para cada fila.",
                                    "Calcule taxa de espera vazia (Zero Entries / Total Entries).",
                                    "Sintetize achados: relacione filas longas com utilizações altas.",
                                    "Gere um resumo executivo com recomendações baseadas nas estatísticas."
                                  ],
                                  "verification": "Produza um relatório de 1 página resumindo métricas chave e insights acionáveis.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Relatório GPSS completo",
                                    "Template de relatório em Word/Google Docs",
                                    "Ferramentas de visualização como Tableau Public (opcional)"
                                  ],
                                  "tips": "Use Little's Law (L = λW) para validar: comprimento médio = chegada * tempo médio no sistema.",
                                  "learningObjective": "Integrar análises de filas, tempos e utilizações para conclusões holísticas.",
                                  "commonMistakes": [
                                    "Confundir queue length com system time",
                                    "Não contextualizar com taxa de chegada",
                                    "Ignorar estatísticas de storages se aplicável"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de um call center com 5 atendentes (facilities), 1000 chamadas chegando a cada 2 minutos: analise o relatório GPSS para ver tempo médio de espera (ex: 3.2 min), utilização média dos atendentes (75%), e comprimento médio da fila (2.1 chamadas), identificando necessidade de mais staff.",
                              "finalVerifications": [
                                "Pode localizar e citar corretamente as tabelas de tempo no sistema, utilização e filas em um relatório GPSS?",
                                "Calcula e interpreta corretamente médias, mínimos e máximos das estatísticas?",
                                "Identifica gargalos (ex: fila >5 ou util >90%) e propõe soluções?",
                                "Valida resultados usando leis de fila básicas como Little's Law?",
                                "Gera um resumo coerente conectando todas as métricas?",
                                "Explica implicações de variância alta em tempos ou filas?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação e citação de métricas do relatório (90%+ correto)",
                                "Profundidade na interpretação (inclui cálculos derivados e comparações)",
                                "Detecção correta de gargalos e recomendações viáveis",
                                "Uso adequado de terminologia GPSS (ex: Facility, Queue, Transaction)",
                                "Clareza e estrutura no resumo final",
                                "Aplicação de conceitos estatísticos básicos sem erros"
                              ],
                              "crossCurricularConnections": [
                                "Estatística Descritiva: cálculo de médias, variâncias e distribuições",
                                "Teoria de Filas: aplicação de M/M/c e Little's Law",
                                "Programação: depuração e análise de outputs de simulação",
                                "Gestão de Operações: otimização de recursos e processos",
                                "Análise de Dados: visualização e síntese de relatórios"
                              ],
                              "realWorldApplication": "Em logística de manufatura, analisa saídas GPSS de linhas de produção para reduzir tempos de ciclo, balancear máquinas (utilização) e minimizar estoques em filas, otimizando throughput e custos operacionais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.1.1.2",
                        "name": "SIMSCRIPT",
                        "description": "Linguagem de simulação orientada a eventos discretos com ênfase em estruturas de programação de alto nível e definição de entidades.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.1.2.1",
                            "name": "Definir entidades e classes no SIMSCRIPT",
                            "description": "Criar definições de entidades como clientes e servidores, utilizando comandos DEFINE e CLASS para modelar atributos e comportamentos em simulações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos fundamentais de entidades e classes em SIMSCRIPT",
                                  "subSteps": [
                                    "Ler a documentação oficial do SIMSCRIPT sobre comandos DEFINE e CLASS.",
                                    "Identificar diferenças: DEFINE para entidades simples com atributos estáticos; CLASS para estruturas orientadas a objetos com herança e métodos.",
                                    "Analisar exemplos básicos de entidades como CLIENTE (fila) e SERVIDOR (processador).",
                                    "Mapear atributos comuns: tempo de chegada, estado, prioridades.",
                                    "Estudar sintaxe básica: DEFINE NOME (ATRIBUTO1, ATRIBUTO2); CLASS NOME ATTRIBUTES ... END;"
                                  ],
                                  "verification": "Escrever um resumo de 5 linhas explicando diferenças entre DEFINE e CLASS, com exemplos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação SIMSCRIPT (manual PDF)",
                                    "Editor de texto como VS Code"
                                  ],
                                  "tips": "Compare com conceitos de OOP em linguagens como Python para facilitar compreensão.",
                                  "learningObjective": "Dominar os conceitos teóricos para modelagem correta de simulações.",
                                  "commonMistakes": [
                                    "Confundir DEFINE com declarações de variáveis comuns",
                                    "Ignorar suporte a herança em CLASS",
                                    "Esquecer ponto e vírgula no final das definições"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir entidades simples utilizando o comando DEFINE",
                                  "subSteps": [
                                    "Abrir um novo arquivo .sim em um compilador SIMSCRIPT.",
                                    "Escrever: DEFINE CLIENTE (TEMPO_CHEGADA REAL, ESTADO INTEGER, PRIORIDADE INTEGER);",
                                    "Adicionar múltiplos atributos lógicos para o contexto de simulação de filas.",
                                    "Salvar e validar sintaxe básica sem instanciar.",
                                    "Testar declaração isolada em um programa mínimo."
                                  ],
                                  "verification": "Compilar o snippet isolado sem erros de sintaxe para DEFINE.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Compilador SIMSCRIPT instalado",
                                    "Ambiente de desenvolvimento como SIMSCRIPT II.5"
                                  ],
                                  "tips": "Use atributos REAL para tempos e INTEGER para estados discretos.",
                                  "learningObjective": "Criar definições funcionais de entidades para simulações discretas.",
                                  "commonMistakes": [
                                    "Omitir parênteses nos atributos",
                                    "Usar tipos inválidos como STRING sem suporte",
                                    "Esquecer de especificar tipo de dado"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir classes complexas utilizando o comando CLASS",
                                  "subSteps": [
                                    "Estruturar CLASS SERVIDOR ATTRIBUTES (CAPACIDADE INTEGER, TEMPO_SERVICO REAL) METHODS ... END;",
                                    "Incluir herança se aplicável: CLASS FILA_SIMPLES ISA CLIENTE ...",
                                    "Definir comportamentos iniciais com funções como ENTRADA_FILA e SAIDA_FILA.",
                                    "Adicionar atributos dinâmicos e relacionamentos entre classes.",
                                    "Validar estrutura com comentários explicativos."
                                  ],
                                  "verification": "Executar compilação parcial e verificar se classes são reconhecidas pelo simulador.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Compilador SIMSCRIPT",
                                    "Exemplos de código de simulação de filas"
                                  ],
                                  "tips": "Sempre termine com END; para evitar erros de escopo.",
                                  "learningObjective": "Modelar objetos complexos com atributos e comportamentos em simulações OO.",
                                  "commonMistakes": [
                                    "Não usar ISA para herança",
                                    "Misturar atributos de DEFINE em CLASS",
                                    "Definir métodos sem corpo inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar, testar e refinar definições de entidades e classes",
                                  "subSteps": [
                                    "Combinar DEFINE e CLASS em um programa de simulação completo.",
                                    "Instanciar entidades: NEW CLIENTE (C1); e simular eventos básicos.",
                                    "Executar simulação e monitorar atributos via REPORT.",
                                    "Debugar erros comuns de definição e ajustar atributos.",
                                    "Documentar o código com comentários sobre cada entidade."
                                  ],
                                  "verification": "Simulação roda sem crashes e atributos são atualizados corretamente.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Simulador SIMSCRIPT completo",
                                    "Terminal para execução"
                                  ],
                                  "tips": "Use PRINT para debugar valores de atributos durante runtime.",
                                  "learningObjective": "Aplicar definições em um fluxo de simulação funcional.",
                                  "commonMistakes": [
                                    "Instanciar sem NEW",
                                    "Conflitos de nomes entre entidades",
                                    "Ignorar inicialização de atributos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de call center: DEFINE CHAMADA (TEMPO_CHEGADA REAL, DURACAO INTEGER); CLASS ATENDENTE ATTRIBUTES (ID INTEGER, OCUPADO BOOLEAN) METHODS ATENDER(CHAMADA C) { ... } END; Instancie chamadas e atenda via eventos para modelar filas.",
                              "finalVerifications": [
                                "Compilação bem-sucedida sem erros de sintaxe em DEFINE e CLASS.",
                                "Instanciação correta de pelo menos 2 entidades/classes via NEW.",
                                "Atributos acessíveis e modificáveis durante simulação.",
                                "Relatórios mostram valores coerentes de atributos.",
                                "Sem warnings sobre herança ou escopo em CLASS.",
                                "Simulação executa 100 eventos sem falhas."
                              ],
                              "assessmentCriteria": [
                                "Sintaxe precisa nos comandos DEFINE e CLASS (100% conformidade).",
                                "Atributos relevantes e tipados corretamente para o domínio.",
                                "Uso apropriado de herança e métodos em CLASS.",
                                "Integração lógica em simulação discreta.",
                                "Documentação clara com comentários.",
                                "Eficiência: definições otimizadas sem redundâncias."
                              ],
                              "crossCurricularConnections": [
                                "Programação Orientada a Objetos (herança e encapsulamento).",
                                "Modelagem de Sistemas (UML para entidades).",
                                "Teoria de Filas (atributos como tempo de espera).",
                                "Matemática Discreta (eventos e estados).",
                                "Engenharia de Software (abstração em simulações)."
                              ],
                              "realWorldApplication": "Modelar sistemas de atendimento em call centers, logística de manufatura ou redes de telecomunicações, otimizando alocação de recursos via simulações precisas de entidades como clientes, servidores e filas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.2.2",
                            "name": "Implementar lógica de eventos no SIMSCRIPT",
                            "description": "Programar rotinas de eventos como chegada e partida, usando SCHEDULE e REQUEST para gerenciar agendas de eventos discretos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Fundamentais de Eventos Discretos no SIMSCRIPT",
                                  "subSteps": [
                                    "Estude a documentação oficial do SIMSCRIPT sobre eventos discretos, focando em rotinas de eventos (event routines).",
                                    "Identifique os componentes chave: agenda de eventos futuros (Future Event List - FEL), tempo atual (TNOW) e mecanismos de agendamento.",
                                    "Revise exemplos básicos de simulações de eventos discretos, como filas simples.",
                                    "Anote definições de SCHEDULE (agendar evento futuro) e REQUEST (suspender processo até evento ocorrer).",
                                    "Compile um glossário pessoal com termos como 'atividade', 'entidade' e 'recurso'."
                                  ],
                                  "verification": "Crie um diagrama de fluxo explicando como eventos são processados na FEL e confirme com um colega ou simulador online.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Documentação SIMSCRIPT II.5 ou III",
                                    "Editor de texto ou IDE compatível com SIMSCRIPT",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Comece com exemplos simples para evitar sobrecarga; foque em como o tempo avança via eventos.",
                                  "learningObjective": "Compreender a arquitetura de eventos discretos e os papéis de SCHEDULE e REQUEST.",
                                  "commonMistakes": [
                                    "Confundir SCHEDULE com chamadas síncronas",
                                    "Ignorar o impacto do TNOW no processamento de eventos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Rotina de Evento de Chegada Usando SCHEDULE",
                                  "subSteps": [
                                    "Defina a rotina de evento ARRIVAL no SIMSCRIPT usando o bloco EVENT.",
                                    "Dentro da rotina, capture atributos da entidade chegando (ex: tempo de chegada).",
                                    "Use SCHEDULE para agendar a próxima chegada com delay exponencial ou fixo.",
                                    "Atualize estatísticas iniciais, como número de chegadas.",
                                    "Teste compilação isolada da rotina."
                                  ],
                                  "verification": "Execute o código e verifique se múltiplas chegadas são agendadas corretamente na FEL via log de saída.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Compilador SIMSCRIPT",
                                    "Exemplos de código de filas M/M/1",
                                    "Debugger ou trace tool do SIMSCRIPT"
                                  ],
                                  "tips": "Use distribuições randômicas para delays realistas; sempre verifique se o tempo agendado é TNOW + delay > 0.",
                                  "learningObjective": "Programar uma rotina de chegada que auto-agende eventos subsequentes.",
                                  "commonMistakes": [
                                    "Esquecer de avançar TNOW",
                                    "Agendar com delay zero causando loops infinitos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Rotina de Partida e Integração com REQUEST",
                                  "subSteps": [
                                    "Crie a rotina DEPARTURE para liberar recursos após serviço.",
                                    "Na rotina de chegada, use REQUEST para aguardar servidor livre se ocupado.",
                                    "Agende partida futura via SCHEDULE com tempo de serviço.",
                                    "Libere o servidor na partida e sinalize para próxima REQUEST pendente.",
                                    "Integre ambas rotinas no modelo principal com INITIALIZE e TERMINATE."
                                  ],
                                  "verification": "Simule 100 chegadas e confirme que partidas ocorrem após serviços sem sobreposições de servidor.",
                                  "estimatedTime": "2.5 hours",
                                  "materials": [
                                    "Código base da Step 2",
                                    "Ferramentas de profiling SIMSCRIPT",
                                    "Planilhas para validar estatísticas"
                                  ],
                                  "tips": "REQUEST é bloqueante; certifique-se de que libera corretamente com RELEASE.",
                                  "learningObjective": "Gerenciar concorrência de recursos via REQUEST/SCHEDULE em eventos de partida.",
                                  "commonMistakes": [
                                    "Não liberar recursos após REQUEST",
                                    "Agendar partidas sem verificar disponibilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Otimizar a Lógica de Eventos Completos",
                                  "subSteps": [
                                    "Execute simulações completas com diferentes cargas (alta/baixa utilização).",
                                    "Colete métricas: tempo de espera, comprimento de fila, utilização do servidor.",
                                    "Debug erros comuns como eventos perdidos ou deadlocks na FEL.",
                                    "Otimize código removendo redundâncias e adicionando logs.",
                                    "Valide contra resultados analíticos de filas M/M/1."
                                  ],
                                  "verification": "Gere relatório com estatísticas que batem com fórmulas teóricas (ex: Lq = λ²σ² / 2(1-ρ)).",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Simulador SIMSCRIPT completo",
                                    "Calculadora ou Python para validação teórica",
                                    "Templates de relatório"
                                  ],
                                  "tips": "Use REPLICATE para runs múltiplos e médias confiáveis.",
                                  "learningObjective": "Validar e refinar simulações de eventos discretos para precisão.",
                                  "commonMistakes": [
                                    "Ignorar variância em distribuições",
                                    "Não resetar estatísticas entre runs"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule uma fila de caixa de supermercado: clientes chegam a cada 5-10 min (exponencial), serviço leva 4-7 min. Use SCHEDULE para próximas chegadas/partidas e REQUEST para servidor (caixa). Monitore fila máxima e tempo médio de espera.",
                              "finalVerifications": [
                                "Todos os eventos são processados na ordem cronológica correta pela FEL.",
                                "REQUEST suspende corretamente processos até recursos livres.",
                                "Estatísticas finais (chegadas, partidas, utilização) são precisas e sem vazamentos.",
                                "Simulação roda sem deadlocks ou eventos pendentes indefinidamente.",
                                "Logs mostram agendamentos via SCHEDULE com tempos futuros válidos.",
                                "Validação contra modelo analítico dentro de 5% de erro."
                              ],
                              "assessmentCriteria": [
                                "Código compila e executa sem erros de sintaxe ou runtime.",
                                "Lógica de eventos gerencia corretamente FEL com múltiplas entidades.",
                                "Integração de SCHEDULE e REQUEST simula dinâmicas realistas de fila.",
                                "Estatísticas coletadas são computadas e reportadas precisamente.",
                                "Código é modular, comentado e otimizado para performance.",
                                "Testes com cenários variados (alta carga, baixa carga) passam."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: Uso de distribuições exponenciais para tempos inter-evento.",
                                "Programação Orientada a Objetos: Entidades e recursos como classes em linguagens modernas.",
                                "Algoritmos: Heaps para gerenciamento eficiente da FEL.",
                                "Análise de Sistemas: Modelagem de filas em operações industriais.",
                                "Engenharia de Software: Debugging e validação de simulações."
                              ],
                              "realWorldApplication": "Em logística para simular centros de distribuição (chegadas de caminhões, processamento de pedidos), telecomunicações para modelar pacotes em redes (chegadas/partidas de queues), ou saúde para ERs (pacientes chegando, sendo atendidos e saindo), otimizando recursos e reduzindo esperas."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.2.3",
                            "name": "Coletar e reportar estatísticas no SIMSCRIPT",
                            "description": "Utilizar funções de coleta de dados como ACCUMULATE e TABLE para gerar histogramas e médias em simulações de sistemas discretos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Básicos de Coleta de Estatísticas no SIMSCRIPT",
                                  "subSteps": [
                                    "Revise a documentação do SIMSCRIPT para funções ACCUMULATE e TABLE.",
                                    "Identifique variáveis de estatística como soma, contagem, mínimo e máximo.",
                                    "Estude exemplos simples de simulações discretas, como filas M/M/1.",
                                    "Defina o que são histogramas em contexto de simulação (distribuição de frequências).",
                                    "Anote diferenças entre estatísticas de ponto único (média) e distribucionais (histograma)."
                                  ],
                                  "verification": "Crie um diagrama conceitual ligando ACCUMULATE/TABLE a métricas de simulação e explique oralmente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação SIMSCRIPT II.5",
                                    "Manual de referência de funções estatísticas",
                                    "Editor de texto para SIMSCRIPT"
                                  ],
                                  "tips": "Comece com exemplos oficiais para evitar confusões com sintaxe proprietária.",
                                  "learningObjective": "Compreender o propósito e sintaxe inicial de ACCUMULATE e TABLE para coleta de dados em simulações.",
                                  "commonMistakes": [
                                    "Confundir ACCUMULATE com contadores simples",
                                    "Ignorar inicialização de acumuladores",
                                    "Não diferenciar TABLE de arrays comuns"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar ACCUMULATE para Estatísticas de Ponto Único",
                                  "subSteps": [
                                    "Declare um ACCUMULATE para uma variável de interesse, ex: tempo de espera.",
                                    "Inicialize o acumulador no bloco INITIALIZE.",
                                    "Atualize o ACCUMULATE em eventos relevantes com ACCUMULATE nome_var, valor.",
                                    "Compile e execute uma simulação simples para testar soma e contagem.",
                                    "Calcule manualmente a média para validar: soma / contagem."
                                  ],
                                  "verification": "Execute a simulação e confirme que relatório mostra média correta comparada a cálculo manual.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Compilador SIMSCRIPT",
                                    "Exemplo de código de fila simples",
                                    "Calculadora para validação manual"
                                  ],
                                  "tips": "Use ACCUMULATE com múltiplas estatísticas (SUM, COUNT, MIN, MAX) no mesmo bloco para eficiência.",
                                  "learningObjective": "Implementar e validar coleta de médias, somas e extremos usando ACCUMULATE.",
                                  "commonMistakes": [
                                    "Esquecer de chamar ACCUMULATE em todos os eventos",
                                    "Não inicializar corretamente",
                                    "Usar variáveis erradas no update"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar TABLE para Geração de Histogramas",
                                  "subSteps": [
                                    "Declare uma TABLE com número de buckets e intervalos apropriados.",
                                    "Inicialize a TABLE no setup da simulação.",
                                    "Colete dados com TABLE nome_table, valor em pontos de interesse.",
                                    "Execute rodadas de simulação para preencher a tabela.",
                                    "Gere relatório com PRINT TABLE para visualizar frequências."
                                  ],
                                  "verification": "Inspecione o histograma gerado e confirme que soma das frequências equals ao número de observações.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Compilador SIMSCRIPT",
                                    "Código base da Step 2",
                                    "Papel para esboçar buckets manualmente"
                                  ],
                                  "tips": "Escolha intervalos de buckets baseados em distribuição esperada para evitar skew.",
                                  "learningObjective": "Criar e popular tabelas para histogramas, entendendo distribuição de dados simulados.",
                                  "commonMistakes": [
                                    "Buckets muito largos ou estreitos",
                                    "Não zerar TABLE entre runs",
                                    "Esquecer PRINT TABLE no relatório"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Gerar Relatórios Integrados e Interpretar Resultados",
                                  "subSteps": [
                                    "Integre ACCUMULATE e TABLE no mesmo modelo de simulação.",
                                    "Adicione comandos PRINT para ACCUMULATE e TABLE no bloco TERMINATE.",
                                    "Execute múltiplas runs e compare estatísticas.",
                                    "Interprete resultados: valide se média alinha com histograma.",
                                    "Documente insights, como variância observada."
                                  ],
                                  "verification": "Gere um relatório completo e escreva um parágrafo resumindo métricas chave e sua confiabilidade.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Compilador SIMSCRIPT",
                                    "Código integrado das steps anteriores",
                                    "Template de relatório"
                                  ],
                                  "tips": "Use rodadas de aquecimento (warm-up) para descartar transients em estatísticas.",
                                  "learningObjective": "Produzir relatórios profissionais de estatísticas e interpretar para decisões de simulação.",
                                  "commonMistakes": [
                                    "Relatórios sem formatação clara",
                                    "Ignorar steady-state vs transient",
                                    "Não rodar reps suficientes"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado, use ACCUMULATE para tempo médio de espera no caixa (chegada de 5 min, serviço 3 min) e TABLE para histograma de tempos de espera em buckets de 0-2, 2-4, etc. min. Após 1000 clientes, relatório mostra média 1.8 min e 60% dos clientes <2 min.",
                              "finalVerifications": [
                                "Código compila sem erros de sintaxe em ACCUMULATE/TABLE.",
                                "Relatório exibe média, desvio padrão e histograma corretos.",
                                "Validação manual de 10 observações matches estatísticas reportadas.",
                                "Múltiplas runs mostram consistência (±5% na média).",
                                "Interpretação escrita identifica gargalos na simulação.",
                                "Histograma soma a 100% das observações."
                              ],
                              "assessmentCriteria": [
                                "Precisão na implementação de ACCUMULATE (soma/contagem corretas).",
                                "Adequação de buckets no TABLE para distribuição de dados.",
                                "Qualidade e completude do relatório gerado.",
                                "Validação e interpretação correta dos resultados.",
                                "Eficiência do código (sem redundâncias).",
                                "Uso apropriado de initialização e terminate."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Cálculo de médias, desvios e distribuições empíricas.",
                                "Programação: Manipulação de estruturas de dados especializadas.",
                                "Engenharia de Sistemas: Análise de performance em filas e processos.",
                                "Análise de Dados: Visualização via histogramas para insights.",
                                "Matemática Computacional: Validação de modelos estocásticos."
                              ],
                              "realWorldApplication": "Em logística, simular tempos de processamento em armazéns para otimizar alocação de recursos; em telecomunicações, analisar latência de pacotes para dimensionar redes; em manufatura, reportar throughput e bottlenecks em linhas de produção para lean manufacturing."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.1.1.3",
                        "name": "SLAM (Simulation Language for Alternative Modeling)",
                        "description": "Linguagem híbrida para modelagem de eventos discretos e contínuos, com suporte a redes de filas e diagramas de blocos.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.1.3.1",
                            "name": "Construir modelos de rede no SLAM",
                            "description": "Utilizar nós e arcos para representar redes de filas em simulações discretas, definindo atributos como taxas de chegada e tempos de serviço.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Fundamentais de Nós e Arcos no SLAM",
                                  "subSteps": [
                                    "Estude a documentação do SLAM para identificar tipos de nós (CREATE, QUEUE, FACILITY, etc.) e arcos (A-arcs para lógica, T-arcs para tempo).",
                                    "Revise conceitos de redes de filas: chegada, serviço, roteamento.",
                                    "Desenhe um diagrama simples de rede de filas à mão para um sistema básico como uma fila única.",
                                    "Identifique atributos chave: taxa de chegada (ex: Poisson), tempo de serviço (ex: exponencial).",
                                    "Compare SLAM com outras linguagens como GPSS para destacar diferenças em nós/arcos."
                                  ],
                                  "verification": "Crie um resumo de 1 página listando 5 nós principais e 3 tipos de arcos com exemplos de uso.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação SLAM (manual PDF), papel e caneta para diagrama, software SLAM instalado.",
                                  "tips": "Use diagramas visuais para mapear fluxos antes de codificar.",
                                  "learningObjective": "Compreender a semântica de nós e arcos para modelagem de redes de filas.",
                                  "commonMistakes": "Confundir nós lógicos com físicos; ignorar distribuição de probabilidades."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e Configurar Nós no Modelo de Rede",
                                  "subSteps": [
                                    "Inicie o ambiente SLAM e crie um nó CREATE para geração de entidades (defina taxa de chegada).",
                                    "Adicione nó QUEUE para filas de espera e FACILITY para servidores.",
                                    "Configure atributos iniciais: capacidade da fila, prioridade de entidades.",
                                    "Teste nós isolados com uma simulação mínima (rode 100 iterações).",
                                    "Registre estatísticas iniciais como tempo médio na fila."
                                  ],
                                  "verification": "Execute simulação isolada dos nós e confirme que estatísticas são geradas sem erros.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Editor SLAM, compilador SLAM, exemplos de código de nós básicos.",
                                  "tips": "Comece com configurações determinísticas para depuração antes de probabilísticas.",
                                  "learningObjective": "Configurar nós independentes com atributos precisos para representar estações de serviço.",
                                  "commonMistakes": "Definir capacidades infinitas sem limite realista; esquecer inicialização de filas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Conectar Nós com Arcos e Definir Roteamento",
                                  "subSteps": [
                                    "Desenhe arcos entre nós: use A-arcs para lógica condicional e T-arcs para delays.",
                                    "Implemente roteamento probabilístico (ex: 70% para fila A, 30% para B).",
                                    "Adicione lógica de decisão com nós DECIDE.",
                                    "Valide conectividade compilando o modelo parcial.",
                                    "Ajuste arcos para evitar loops infinitos."
                                  ],
                                  "verification": "Compile o modelo e trace o caminho de 10 entidades simuladas.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Editor gráfico SLAM (se disponível), código fonte parcial dos steps anteriores.",
                                  "tips": "Use labels em arcos para rastrear fluxos durante debug.",
                                  "learningObjective": "Estabelecer conexões dinâmicas entre nós para fluxos realistas.",
                                  "commonMistakes": "Arcos unidirecionais em redes que precisam de feedback; probabilidades não somando 100%."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Atribuir Atributos Detalhados e Executar Simulação Completa",
                                  "subSteps": [
                                    "Defina tempos de serviço (ex: EXPO(5) para médio 5 unidades) e taxas de chegada em todos nós.",
                                    "Incorpore variáveis aleatórias e seeds para reprodutibilidade.",
                                    "Configure relatórios de saída: tempo na sistema, utilização de facilities.",
                                    "Rode simulação completa (1000+ entidades) e analise resultados.",
                                    "Ajuste parâmetros baseado em métricas iniciais."
                                  ],
                                  "verification": "Gere relatório com estatísticas chave (utilização >80%, filas estáveis).",
                                  "estimatedTime": "70 minutos",
                                  "materials": "Compilador SLAM, planilha para registrar métricas, documentação de distribuições.",
                                  "tips": "Salve múltiplas versões do modelo para comparações.",
                                  "learningObjective": "Integrar atributos probabilísticos para simulações realistas de redes de filas.",
                                  "commonMistakes": "Usar distribuições erradas (ex: fixa em vez de exponencial); seeds não fixadas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Refinar o Modelo de Rede",
                                  "subSteps": [
                                    "Compare saídas com teoria de filas (ex: Little's Law).",
                                    "Teste cenários de sensibilidade alterando taxas.",
                                    "Identifique gargalos via animação SLAM.",
                                    "Documente o modelo com comentários no código.",
                                    "Prepare apresentação dos resultados."
                                  ],
                                  "verification": "Modelo satisfaz pelo menos 4 verificações finais e roda consistentemente.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Animação SLAM, calculadora para fórmulas teóricas.",
                                  "tips": "Use warm-up periods para descartar transientes.",
                                  "learningObjective": "Refinar modelo para precisão e robustez em simulações discretas.",
                                  "commonMistakes": "Ignorar período de aquecimento; não validar contra benchmarks analíticos."
                                }
                              ],
                              "practicalExample": "Modele uma rede de call center com 3 filas paralelas: chamadas chegam a 10/hora (Poisson), roteadas por tipo (60% suporte técnico - QUEUE1/FAC1 tempo EXPO(4min), 30% vendas - QUEUE2/FAC2 EXPO(3min), 10% billing - QUEUE3/FAC3 EXPO(2min)). Use arcos para roteamento probabilístico e meça tempo médio na sistema <15min.",
                              "finalVerifications": [
                                "Modelo compila e executa sem erros de sintaxe.",
                                "Estatísticas mostram utilização de facilities entre 60-90%.",
                                "Tempo médio no sistema alinha com expectativas teóricas (±10%).",
                                "Animação visualiza fluxos sem deadlocks ou loops infinitos.",
                                "Relatório de saída inclui pelo menos 5 métricas chave (fila, serviço, throughput).",
                                "Sensibilidade a ±20% na taxa de chegada mantém estabilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de nós e arcos (100% corretos).",
                                "Atributos probabilísticos realistas e bem documentados (nota 4/5).",
                                "Simulação produz resultados válidos e interpretáveis (completa).",
                                "Validação contra teoria (ex: Little's Law) demonstrada.",
                                "Código limpo com comentários e estrutura modular.",
                                "Exemplo prático executado com métricas quantificadas."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: Distribuições para chegadas/serviços.",
                                "Programação: Sintaxe de linguagens de simulação como pseudocódigo.",
                                "Gestão de Operações: Otimização de filas em processos industriais.",
                                "Análise de Dados: Interpretação de relatórios estatísticos de simulação."
                              ],
                              "realWorldApplication": "Em logística, modelar redes de filas em armazéns para otimizar alocação de empacotadores, reduzindo tempos de espera em 25%; em saúde, simular emergências hospitalares para dimensionar staff e minimizar overcrowding."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.3.2",
                            "name": "Integrar modelagem discreta e contínua no SLAM",
                            "description": "Combinar elementos discretos (CREATE, QUEUE) com equações diferenciais contínuas para modelar sistemas híbridos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Modelagem Discreta e Contínua no SLAM",
                                  "subSteps": [
                                    "Estude comandos discretos como CREATE (criação de entidades) e QUEUE (gerenciamento de filas).",
                                    "Revise notação para modelagem contínua, incluindo equações diferenciais (,C para contínuo).",
                                    "Identifique diferenças chave: eventos discretos vs. derivadas contínuas.",
                                    "Analise exemplos básicos de modelos puramente discretos e puramente contínuos do manual SLAM.",
                                    "Anote limitações de modelos puros e necessidade de híbridos."
                                  ],
                                  "verification": "Criar um resumo de 1 página comparando discreto vs. contínuo, com exemplos de código SLAM.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Manual SLAM (capítulos sobre CREATE, QUEUE e ,C)",
                                    "Editor de texto para anotações"
                                  ],
                                  "tips": "Use diagramas de fluxo para visualizar eventos discretos e curvas contínuas.",
                                  "learningObjective": "Compreender os blocos de construção discretos e contínuos para integração.",
                                  "commonMistakes": [
                                    "Confundir tempo discreto com contínuo",
                                    "Ignorar taxa de amostragem em híbridos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender Sintaxe para Integração Híbrida no SLAM",
                                  "subSteps": [
                                    "Estude diretivas híbridas como ,DRA (discreto-random-access) e integração de ,C dentro de blocos discretos.",
                                    "Pratique declarar variáveis híbridas (discretas e contínuas no mesmo modelo).",
                                    "Aprenda a embedar equações diferenciais em eventos discretos (ex: dX/dt dentro de QUEUE).",
                                    "Teste sintaxe com snippets simples: combine CREATE com derivada linear.",
                                    "Revise regras de inicialização para estados híbridos."
                                  ],
                                  "verification": "Escrever 3 snippets de código válidos integrando um comando discreto com uma equação diferencial.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Documentação SLAM sobre modelagem híbrida",
                                    "Compilador/Interpretador SLAM",
                                    "Exemplos de código online"
                                  ],
                                  "tips": "Sempre termine equações ,C com ponto e vírgula; teste compilação antes de simular.",
                                  "learningObjective": "Dominar a sintaxe para combinar elementos discretos e contínuos.",
                                  "commonMistakes": [
                                    "Esquecer delimitadores ,C ou ,D",
                                    "Definir variáveis sem tipo híbrido"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir um Modelo Híbrido Simples",
                                  "subSteps": [
                                    "Defina um sistema: fila (QUEUE) com taxa de serviço contínua (dS/dt = -k*S).",
                                    "Implemente CREATE para chegada de entidades discretas.",
                                    "Integre equação diferencial no bloco QUEUE para modelar processamento híbrido.",
                                    "Adicione lógica de eventos para transições discreto-contínuo.",
                                    "Compile e corrija erros de sintaxe."
                                  ],
                                  "verification": "Modelo compila sem erros e gera saída inicial de simulação.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Software SLAM instalado",
                                    "Manual de referência SLAM",
                                    "Notebook para debugging"
                                  ],
                                  "tips": "Comece com parâmetros simples (k=0.1) e incremente complexidade.",
                                  "learningObjective": "Aplicar sintaxe para criar um modelo funcional híbrido.",
                                  "commonMistakes": [
                                    "Loop infinito em eventos discretos",
                                    "Inicialização errada de integradores contínuos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular, Validar e Otimizar o Modelo Híbrido",
                                  "subSteps": [
                                    "Execute simulação com diferentes sementes randômicas.",
                                    "Analise saídas: comprimento de fila (discreto) vs. estado contínuo (ex: nível de recurso).",
                                    "Valide contra modelo analítico ou simulação separada.",
                                    "Otimize: ajuste passos de integração e tolerâncias.",
                                    "Documente resultados e sensibilidade a parâmetros."
                                  ],
                                  "verification": "Gerar relatório com gráficos mostrando integração correta (ex: fila afetando derivada).",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "SLAM com visualizador de saída",
                                    "Ferramentas de plotagem (Matlab/Gnuplot)",
                                    "Dados de benchmark"
                                  ],
                                  "tips": "Use .REPORT para outputs automáticos; compare com simulações puras.",
                                  "learningObjective": "Verificar e refinar modelos híbridos para precisão.",
                                  "commonMistakes": [
                                    "Ignorar divergência numérica em integradores",
                                    "Não testar múltiplas runs"
                                  ]
                                }
                              ],
                              "practicalExample": "Modelar uma linha de produção: entidades discretas (peças) chegam via CREATE, entram em QUEUE de máquinas; desgaste da máquina segue dW/dt = -a*W + b*uso, onde uso é discreto (número de peças). Simulação mostra fila crescendo quando W->0.",
                              "finalVerifications": [
                                "Modelo compila e roda sem crashes por 1000 unidades de tempo.",
                                "Gráficos exibem correlação entre eventos discretos e trajetórias contínuas.",
                                "Alteração em parâmetro discreto afeta estado contínuo de forma esperada.",
                                "Validação numérica: erro <5% vs. solução analítica aproximada.",
                                "Código é modular e comentado para reutilização.",
                                "Relatório inclui análise de sensibilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão da sintaxe híbrida (sem erros de compilação).",
                                "Correta representação de interações discreto-contínuo.",
                                "Qualidade da validação e análise de resultados.",
                                "Eficiência computacional (tempo de simulação razoável).",
                                "Documentação clara e reprodutível.",
                                "Criatividade na extensão para cenários reais."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Sistemas: Modelagem de processos industriais.",
                                "Física: Dinâmica híbrida em sistemas mecânicos.",
                                "Programação: Paradigmas event-driven vs. ODE solvers.",
                                "Estatística: Análise de simulações Monte Carlo híbridas."
                              ],
                              "realWorldApplication": "Simulação de sistemas de manufatura onde eventos discretos (chegada de jobs) interagem com degradação contínua de equipamentos, otimizando manutenção preditiva em fábricas inteligentes."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.3.3",
                            "name": "Avaliar desempenho com ferramentas do SLAM",
                            "description": "Gerar relatórios de simulação analisando métricas como tempo de espera, throughput e utilização de recursos em modelos SLAM.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o Ambiente SLAM e Criar Modelo de Simulação Básico",
                                  "subSteps": [
                                    "Instalar o software SLAM e verificar dependências do sistema.",
                                    "Criar um modelo simples de sistema de fila única com chegadas Poisson e serviço exponencial.",
                                    "Definir parâmetros iniciais como taxa de chegada (λ=5/hora) e taxa de serviço (μ=6/hora).",
                                    "Compilar e executar o modelo para validação inicial.",
                                    "Salvar o modelo com nome descritivo para futuras análises."
                                  ],
                                  "verification": "O modelo compila e executa sem erros, produzindo saída inicial de simulação.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software SLAM instalado",
                                    "Documentação oficial SLAM",
                                    "Computador com Windows/Unix compatível"
                                  ],
                                  "tips": "Use templates de exemplo do SLAM para acelerar a configuração inicial.",
                                  "learningObjective": "Dominar a instalação e criação de modelos básicos em SLAM.",
                                  "commonMistakes": [
                                    "Esquecer de definir distribuições probabilísticas corretas",
                                    "Ignorar unidades de tempo inconsistentes",
                                    "Não validar parâmetros iniciais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar Simulação e Coletar Métricas Principais",
                                  "subSteps": [
                                    "Executar simulação com pelo menos 10.000 iterações para estabilidade estatística.",
                                    "Ativar coleta de métricas: tempo de espera na fila (Wq), throughput (X) e utilização de recursos (U).",
                                    "Configurar relatórios automáticos no SLAM para exportar dados brutos em CSV.",
                                    "Executar múltiplas réplicas (runs) para calcular intervalos de confiança.",
                                    "Verificar convergência das métricas ao longo das iterações."
                                  ],
                                  "verification": "Arquivo CSV gerado com colunas para Wq, X e U, com valores numéricos consistentes.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Modelo SLAM salvo do Step 1",
                                    "Planilha para análise inicial (Excel/Google Sheets)"
                                  ],
                                  "tips": "Aumente o número de runs se a variância for alta para maior precisão.",
                                  "learningObjective": "Executar simulações robustas e extrair dados métricos chave.",
                                  "commonMistakes": [
                                    "Número insuficiente de iterações levando a resultados instáveis",
                                    "Não ativar réplicas independentes",
                                    "Confundir métricas de fila com sistema"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Métricas de Desempenho",
                                  "subSteps": [
                                    "Calcular estatísticas descritivas: média, desvio padrão e intervalos de confiança para Wq, X e U.",
                                    "Identificar gargalos comparando U > 0.85 como sinal de sobrecarga.",
                                    "Visualizar dados com gráficos de histogramas para Wq e séries temporais para X.",
                                    "Realizar análise de sensibilidade variando λ em ±20%.",
                                    "Interpretar resultados: e.g., alto Wq indica necessidade de mais servidores."
                                  ],
                                  "verification": "Gráficos gerados e tabela de análise com interpretações escritas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Dados CSV do Step 2",
                                    "Software de análise (R, Python com Pandas/Matplotlib ou Excel)"
                                  ],
                                  "tips": "Use fórmulas de fila M/M/1 para validar resultados teóricos.",
                                  "learningObjective": "Interpretar métricas SLAM para insights de desempenho.",
                                  "commonMistakes": [
                                    "Ignorar intervalos de confiança",
                                    "Não normalizar unidades de throughput",
                                    "Confundir correlação com causalidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Gerar Relatório de Simulação Completo",
                                  "subSteps": [
                                    "Estruturar relatório: introdução, metodologia, resultados, análise e recomendações.",
                                    "Incluir tabelas de métricas, gráficos e comparações com cenários base.",
                                    "Destacar achados chave: e.g., 'Throughput de 5.2 unidades/hora com U=82%'.",
                                    "Adicionar seção de limitações e sugestões para otimizações.",
                                    "Exportar em PDF com formatação profissional."
                                  ],
                                  "verification": "Relatório PDF completo com todas as seções e visualizações integradas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Análises do Step 3",
                                    "Ferramenta de edição (Word, LaTeX ou Google Docs)"
                                  ],
                                  "tips": "Use templates de relatório para consistência e profissionalismo.",
                                  "learningObjective": "Comunicar resultados de simulação de forma clara e acionável.",
                                  "commonMistakes": [
                                    "Relatório sem visualizações",
                                    "Falta de recomendações práticas",
                                    "Excesso de jargão técnico sem explicação"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule uma central de call center com 5 atendentes, taxa de chegada de 20 chamadas/hora e tempo médio de atendimento de 2 minutos. Analise Wq (tempo médio de espera), X (chamadas atendidas/hora) e U (% ocupação dos atendentes), gerando relatório recomendando adicionar 2 atendentes se Wq > 5 min.",
                              "finalVerifications": [
                                "Relatório gerado corretamente identifica e interpreta Wq, X e U.",
                                "Gráficos mostram convergência e variabilidade das métricas.",
                                "Análise de sensibilidade demonstra impacto de mudanças em parâmetros.",
                                "Recomendações baseadas em thresholds realistas (e.g., U<85%).",
                                "Intervalos de confiança reportados com 95% de nível.",
                                "Modelo reproduzível por terceiros com código comentado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na coleta e cálculo de métricas (erro <5%).",
                                "Profundidade da análise e interpretação contextual.",
                                "Qualidade visual e clareza do relatório.",
                                "Uso correto de estatística em intervalos e sensibilidade.",
                                "Aplicação prática de insights para otimização.",
                                "Documentação completa e reproduzibilidade."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Cálculo de médias, desvios e intervalos de confiança em dados simulados.",
                                "Programação: Manipulação de linguagens de modelagem e scripts de análise (Python/R).",
                                "Engenharia Industrial: Otimização de filas e alocação de recursos.",
                                "Gestão de Operações: Análise de gargalos em sistemas de serviço.",
                                "Ciência de Dados: Visualização e análise exploratória de dados simulados."
                              ],
                              "realWorldApplication": "Em manufatura, otimizar linhas de produção analisando utilização de máquinas para reduzir tempos de espera e maximizar throughput, economizando custos em indústrias como automotiva ou logística."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.2",
                    "name": "Linguagens Gerais Adaptadas para Simulação",
                    "description": "Uso de linguagens como Fortran, C e Java com bibliotecas para simulação.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.2.1",
                        "name": "Fortran para Simulação",
                        "description": "Exploração do uso da linguagem Fortran, historicamente utilizada em computação científica, adaptada para simulação de sistemas discretos por meio de bibliotecas específicas que suportam geração de variáveis aleatórias, gerenciamento de eventos e modelagem probabilística.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.1.1",
                            "name": "Identificar bibliotecas de simulação em Fortran",
                            "description": "Reconhecer e listar bibliotecas como IMSL ou NAG para suporte a funções de simulação, incluindo geração de números pseudoaleatórios e distribuições estatísticas, comparando suas capacidades com linguagens dedicadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Pesquisar bibliotecas de simulação padrão em Fortran",
                                  "subSteps": [
                                    "Acesse documentação oficial do Fortran e sites de fornecedores como IMSL e NAG.",
                                    "Liste bibliotecas principais: IMSL (Intel Math Kernel Library), NAG Fortran Library, Netlib (incluindo SLATEC).",
                                    "Identifique seções dedicadas a simulação, RNG e distribuições estatísticas.",
                                    "Registre licenças, disponibilidade (gratuita/paga) e compatibilidade com compiladores modernos (gfortran, ifort).",
                                    "Crie uma tabela inicial com nomes, versões recentes e links de download."
                                  ],
                                  "verification": "Verifique se a lista contém pelo menos 3 bibliotecas com links válidos e resumo de foco em simulação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Acesso à internet",
                                    "Navegador web",
                                    "Editor de texto para tabela (ex: Markdown ou Excel)"
                                  ],
                                  "tips": [
                                    "Priorize bibliotecas ativas e mantidas; ignore legadas sem suporte.",
                                    "Use busca avançada com termos como 'Fortran simulation libraries RNG'."
                                  ],
                                  "learningObjective": "Conhecer o ecossistema de bibliotecas numéricas em Fortran.",
                                  "commonMistakes": [
                                    "Confundir bibliotecas C/Fortran mistas.",
                                    "Ignorar bibliotecas open-source como GSL wrappers."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar capacidades específicas para simulação",
                                  "subSteps": [
                                    "Estude funções de RNG em IMSL/NAG: uniform, normal, Poisson, etc.",
                                    "Examine suporte a distribuições estatísticas e métodos de simulação (Monte Carlo, bootstrap).",
                                    "Compile exemplos de código simples de documentação para geração de números pseudoaleatórios.",
                                    "Teste instalação básica de uma biblioteca (ex: baixe demo de Netlib).",
                                    "Documente limitações, como precisão de RNG ou paralelismo."
                                  ],
                                  "verification": "Execute um código de teste que gere 1000 números aleatórios e plote histograma básico.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Compilador Fortran (gfortran)",
                                    "Editor de código (VS Code com Fortran extension)",
                                    "Documentação PDF das bibliotecas"
                                  ],
                                  "tips": [
                                    "Use flags de compilação corretas para bibliotecas externas.",
                                    "Comece com exemplos prontos para validar."
                                  ],
                                  "learningObjective": "Mapear funções chave para simulações discretas em Fortran.",
                                  "commonMistakes": [
                                    "Não verificar semente de RNG para reprodutibilidade.",
                                    "Assumir portabilidade sem testar compilador."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar com bibliotecas de linguagens dedicadas",
                                  "subSteps": [
                                    "Liste equivalentes: NumPy/SciPy (Python), base/stats (R), MATLAB Statistics Toolbox.",
                                    "Compare performance: velocidade RNG, precisão, facilidade de uso.",
                                    "Avalie cenários: Fortran para high-performance computing vs. Python para prototipagem rápida.",
                                    "Crie uma matriz comparativa: features, custo, comunidade.",
                                    "Discuta trade-offs: Fortran para simulações massivas vs. linguagens high-level."
                                  ],
                                  "verification": "Preencha matriz com pelo menos 5 critérios comparados para 2 bibliotecas Fortran vs. 2 outras linguagens.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Planilha (Google Sheets)",
                                    "Documentação de SciPy/NumPy",
                                    "Benchmarks online (ex: StackOverflow)"
                                  ],
                                  "tips": [
                                    "Foque em simulação de sistemas discretos (filas, Markov).",
                                    "Use GitHub stars para medir popularidade."
                                  ],
                                  "learningObjective": "Avaliar adequação de Fortran em contextos modernos de simulação.",
                                  "commonMistakes": [
                                    "Superestimar velocidade sem benchmarks reais.",
                                    "Ignorar overhead de linking em Fortran."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar recomendações e casos de uso",
                                  "subSteps": [
                                    "Resuma prós/contras de cada biblioteca Fortran para simulação.",
                                    "Identifique quando usar IMSL/NAG vs. implementações customizadas.",
                                    "Planeje integração em projetos de Matemática Computacional.",
                                    "Crie um relatório curto com lista final e comparação.",
                                    "Teste um mini-projeto: simule lançamento de moeda com NAG RNG."
                                  ],
                                  "verification": "Relatório de 1 página com lista, comparação e código funcional.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Código-fonte de teste",
                                    "Compilador",
                                    "Ferramenta de plot (GNUPlot)"
                                  ],
                                  "tips": [
                                    "Mantenha código modular para reutilização.",
                                    "Documente dependências."
                                  ],
                                  "learningObjective": "Formular julgamentos informados sobre ferramentas de simulação.",
                                  "commonMistakes": [
                                    "Não considerar custo de licenças comerciais.",
                                    "Esquecer validação estatística de RNG."
                                  ]
                                }
                              ],
                              "practicalExample": "Para simular uma fila M/M/1 (sistema discreto), use IMSL para gerar chegadas Poisson e tempos de serviço exponenciais em Fortran, compilando com gfortran e plotando resultados vs. teoria de filas.",
                              "finalVerifications": [
                                "Lista precisa de 4+ bibliotecas Fortran com funções RNG/distribuições.",
                                "Matriz comparativa completa com linguagens dedicadas.",
                                "Código funcional testado gerando simulação básica.",
                                "Relatório sintetizando recomendações claras.",
                                "Identificação correta de limitações (ex: paralelismo em NAG)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de bibliotecas e funções (90%+ correto).",
                                "Profundidade da comparação (cobertura de performance/usabilidade).",
                                "Qualidade do código de teste (compila, executa sem erros).",
                                "Relevância das conexões com simulação discreta.",
                                "Clareza e organização do relatório final.",
                                "Demonstração de verificações estatísticas em RNG."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Geração de distribuições para testes de hipóteses.",
                                "Programação: Integração de bibliotecas externas e debugging.",
                                "Matemática Aplicada: Métodos Monte Carlo em otimização.",
                                "Engenharia de Software: Avaliação de ferramentas HPC."
                              ],
                              "realWorldApplication": "Em simulações de engenharia nuclear (ex: Monte Carlo para reatores) ou finanças (modelos de risco com chains Markov), onde Fortran + IMSL/NAG oferece performance superior para bilhões de iterações em clusters HPC."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.1.2",
                            "name": "Implementar geração de variáveis aleatórias em Fortran",
                            "description": "Desenvolver código em Fortran utilizando sub-rotinas de bibliotecas para gerar números aleatórios uniformes, exponenciais e normais, aplicados em modelos de simulação de filas ou processos estocásticos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configuração Inicial e Geração de Números Aleatórios Uniformes",
                                  "subSteps": [
                                    "Instale o compilador gfortran (ex: sudo apt install gfortran no Linux).",
                                    "Crie um programa Fortran básico usando a intrinsic RANDOM_NUMBER para gerar um escalar uniforme [0,1).",
                                    "Inclua RANDOM_SEED para inicializar a semente com base no tempo do sistema (GETARG ou DATE_AND_TIME).",
                                    "Gere um array de 1000 números uniformes e compute estatísticas básicas (média ≈0.5, variância ≈1/12).",
                                    "Compile e execute o programa múltiplas vezes para verificar variabilidade."
                                  ],
                                  "verification": "O programa compila sem erros (gfortran -o rand_uniform main.f90) e produz números variando entre 0 e 1 em execuções diferentes, com média próxima de 0.5.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Compilador gfortran",
                                    "Editor de texto (VS Code com extensão Fortran)",
                                    "Documentação oficial Fortran 2008 sobre RANDOM_NUMBER e RANDOM_SEED"
                                  ],
                                  "tips": "Use semente fixa durante desenvolvimento para reprodutibilidade, mas randomize em produção.",
                                  "learningObjective": "Dominar a geração de números pseudoaleatórios uniformes usando intrinsics do Fortran.",
                                  "commonMistakes": [
                                    "Esquecer de inicializar a semente, resultando em sequências idênticas.",
                                    "Confundir RANDOM_NUMBER (REAL) com RAND (não padrão).",
                                    "Não declarar variáveis como REAL(KIND=8) para precisão."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementação de Variáveis Aleatórias com Distribuição Exponencial",
                                  "subSteps": [
                                    "Revise o método da transformação inversa da CDF: X = -ln(U) / λ onde U ~ Uniform[0,1).",
                                    "Crie uma subroutine EXP_RAND(lambda) que chama RANDOM_NUMBER e aplica a fórmula.",
                                    "Gere 1000 amostras exponenciais com λ=1 e compute média (deve ≈1) e variância (≈1).",
                                    "Adicione output para histograma simples (bins de 0-5) ou use external tool como GNUPlot.",
                                    "Teste com diferentes λ (ex: 0.5, 2.0) e valide estatísticas."
                                  ],
                                  "verification": "Média das amostras exponenciais ≈ 1/λ e distribuição visualmente exponencial em histograma.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Programa base do Step 1",
                                    "Calculadora ou Python para validar teoria (opcional)",
                                    "GNUPlot para plotar histogramas"
                                  ],
                                  "tips": "Garanta U > 0 evitando ln(0); use SMALL para cutoff se necessário.",
                                  "learningObjective": "Aplicar método de transformação inversa para gerar exponenciais a partir de uniformes.",
                                  "commonMistakes": [
                                    "Usar log(U) em vez de -log(U), gerando distribuição errada.",
                                    "Esquecer divisão por λ, resultando em média sempre 1.",
                                    "Overflow em ln para U muito pequeno."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Geração de Variáveis Aleatórias Normais (Gaussianas)",
                                  "subSteps": [
                                    "Implemente o método Box-Muller: gere duas uniformes U1,U2; Z1=sqrt(-2lnU1)cos(2πU2), Z2=sqrt(-2lnU1)sin(2πU2).",
                                    "Crie subroutine NORMAL_RAND(mu, sigma) usando Box-Muller com uniformes e exponenciais.",
                                    "Gere 1000 amostras com μ=0, σ=1; compute média≈0, variância≈1, teste normalidade (QQ-plot simples).",
                                    "Integre com subrotinas anteriores em um módulo reutilizável.",
                                    "Valide com diferentes parâmetros (ex: μ=5, σ=2)."
                                  ],
                                  "verification": "Estatísticas das amostras: média ≈ μ, desvio padrão ≈ σ; histograma em forma de sino.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Módulos das subrotinas anteriores",
                                    "Biblioteca matemática básica (COS, SIN, SQRT, LOG intrínsecas)",
                                    "Ferramenta para QQ-plot (opcional: Python matplotlib)"
                                  ],
                                  "tips": "Gere pares Z1/Z2 para eficiência; use KIND=8 para precisão em trigonométricas.",
                                  "learningObjective": "Implementar transformação Box-Muller para distribuições normais independentes.",
                                  "commonMistakes": [
                                    "Erro no sinal: -2ln(U1) em vez de 2*-ln(U1).",
                                    "Radianos vs graus em 2πU2.",
                                    "Não normalizar para σ=1 antes de escalar."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicação em Simulação de Processos Estocásticos (Fila M/M/1)",
                                  "subSteps": [
                                    "Defina modelo M/M/1: chegadas exponenciais λ, serviços exponenciais μ > λ.",
                                    "Implemente simulador de eventos: loop while com próxima chegada/serviço usando MIN(EXP_RAND(λ), EXP_RAND(μ)).",
                                    "Rastreie fila length, tempo na fila, tempo total para 10000 eventos.",
                                    "Use NORMAL_RAND para ruído se aplicável (ex: variação em serviço).",
                                    "Compute métricas: Lq (média fila), Wq (tempo médio fila); compare com teoria (ρ=λ/μ, Lq=ρ²/(1-ρ))."
                                  ],
                                  "verification": "Métricas simuladas convergem para valores teóricos (ex: λ=1, μ=1.5 → Lq≈0.444).",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Todas subrotinas anteriores em módulo",
                                    "Papel para diagrama de eventos",
                                    "Teoria de filas (Wikipedia M/M/1)"
                                  ],
                                  "tips": "Use arrays para armazenar histórico e compute médias online para eficiência.",
                                  "learningObjective": "Integrar geradores RNG em simulação discreta de eventos para modelar sistemas estocásticos.",
                                  "commonMistakes": [
                                    "Atualização errada do relógio de simulação (não avançar corretamente).",
                                    "Índice off-by-one na fila.",
                                    "Não parar simulação após steady-state (warm-up period)."
                                  ]
                                }
                              ],
                              "practicalExample": "Simule uma fila M/M/1 de call center com taxa de chegada λ=2 chamadas/hora (exponencial) e serviço μ=3/hora. Rode 5000 eventos, compute tempo médio de espera na fila e compare com fórmula teórica ρ²/(μ(1-ρ)) onde ρ=λ/μ=2/3.",
                              "finalVerifications": [
                                "Código compila e executa sem erros ou crashes numéricos.",
                                "Estatísticas de uniformes: média 0.5 ±0.01, variância 0.083 ±0.001.",
                                "Exponenciais: média =1/λ ± erro pequeno.",
                                "Normais: média=μ, σ=σ dentro de 1-2 desvios.",
                                "Simulação fila: Lq ≈ ρ²/(1-ρ), com ρ<1 para estabilidade.",
                                "Reprodutibilidade com semente fixa."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática das transformações RNG (teste estatístico).",
                                "Modularidade: uso de subrotinas e módulos Fortran.",
                                "Eficiência computacional (tempo de execução <1s para 10k amostras).",
                                "Validação: comparação com teoria e histogramas.",
                                "Código limpo: comentários, indentação, variáveis nomeadas semanticamente.",
                                "Tratamento de edge cases (U=0, overflow)."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: CDF inversa, Box-Muller.",
                                "Programação Computacional: Módulos, intrinsics Fortran.",
                                "Modelagem Matemática: Simulação de eventos discretos.",
                                "Análise Numérica: Precisão floating-point em RNG.",
                                "Engenharia de Sistemas: Otimização de filas em TI."
                              ],
                              "realWorldApplication": "Simulações de redes de telecomunicações para dimensionar buffers, modelagem de tráfego em centros de dados, previsão de demanda em supply chains industriais, e análise de risco em finanças quantitativas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.1.3",
                            "name": "Construir modelo básico de simulação discreta em Fortran",
                            "description": "Criar um programa simples em Fortran para simular um sistema de eventos discretos, como uma fila M/M/1, incorporando bibliotecas para amostragem e controle de tempo de simulação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambiente e definir parâmetros da simulação M/M/1",
                                  "subSteps": [
                                    "Instale um compilador Fortran como gfortran via terminal (ex: sudo apt install gfortran no Linux).",
                                    "Crie um novo arquivo .f90 chamado simulacao_mm1.f90 usando um editor como VS Code ou Vim.",
                                    "Defina constantes: taxa de chegada lambda (ex: 1.0), taxa de serviço mu (ex: 1.2), tempo total de simulação (ex: 10000.0), semente para RNG (ex: 12345).",
                                    "Declare variáveis globais: tempo atual, próxima chegada, próxima saída, fila atual, total na fila, tempo ocioso servidor.",
                                    "Implemente função para gerar números aleatórios exponenciais: interarrivo = -log(unif)/lambda."
                                  ],
                                  "verification": "Compilar o código inicial com 'gfortran -o sim simulacao_mm1.f90' sem erros e verificar se as constantes são impressas corretamente ao rodar './sim'.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Compilador gfortran",
                                    "Editor de texto (VS Code)",
                                    "Documentação Fortran 90/95"
                                  ],
                                  "tips": "Use módulos para organizar constantes e funções; teste a função exponencial isoladamente com prints.",
                                  "learningObjective": "Entender e configurar os parâmetros fundamentais de uma simulação de fila M/M/1 em Fortran.",
                                  "commonMistakes": [
                                    "Esquecer de incluir <cmath> equivalente (use RANDOM_NUMBER intrínseco)",
                                    "Usar taxa lambda/mu incorretas levando a instabilidade",
                                    "Não inicializar sementes para reprodutibilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar geração de eventos de chegada",
                                  "subSteps": [
                                    "Crie uma função generate_arrival() que retorne o tempo da próxima chegada usando distribuição exponencial.",
                                    "Inicialize próxima_chegada = generate_arrival() no setup.",
                                    "No loop principal, se tempo_atual >= próxima_chegada, processe chegada: incremente fila, atualize próxima_chegada, se servidor ocioso, agende saída.",
                                    "Atualize estatísticas: total_chegadas++, tempo_medio_fila acumulado.",
                                    "Teste isoladamente gerando 100 chegadas e verificando média interarrivo ≈ 1/lambda."
                                  ],
                                  "verification": "Adicione prints para listar 10 primeiras chegadas e confirme que interarrivos são exponenciais (média ≈1/lambda).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "gfortran",
                                    "Calculadora para validar médias teóricas",
                                    "Referência: Devroye 'Non-Uniform Random Variate Generation'"
                                  ],
                                  "tips": "Use CALL RANDOM_SEED() e RANDOM_NUMBER() para uniformes; transforme para exponencial corretamente.",
                                  "learningObjective": "Dominar geração de eventos de chegada Poisson em simulações discretas.",
                                  "commonMistakes": [
                                    "Confundir lambda com 1/lambda",
                                    "Não avançar tempo_atual para min(próxima_chegada, próxima_saida)",
                                    "Ignorar wrap-around em tempos muito grandes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar lógica do servidor e eventos de saída",
                                  "subSteps": [
                                    "Crie função generate_service() similar para tempo de serviço exponencial com mu.",
                                    "Quando chegada e servidor ocioso: servidor_ocupado = true, próxima_saida = tempo_atual + generate_service().",
                                    "Quando saída: decrementa fila, se fila>0 agenda nova saída, senão servidor ocioso.",
                                    "Atualize estatísticas: total_saidas++, tempo_ocioso acumulado se aplicável.",
                                    "Integre no loop de eventos: avance tempo para próximo evento (chegada ou saída)."
                                  ],
                                  "verification": "Rode simulação curta (1000 unidades tempo) e verifique total_chegadas ≈ total_saidas, utilização servidor ≈ rho = lambda/mu.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "gfortran",
                                    "Papel para desenhar diagrama de eventos",
                                    "Exemplo código M/M/1 em pseudocódigo"
                                  ],
                                  "tips": "Mantenha lista de eventos futuros mínima (só próxima chegada/saída para M/M/1); use DO WHILE tempo_atual < tempo_final.",
                                  "learningObjective": "Modelar dinâmica servidor-fila com eventos discretos de saída.",
                                  "commonMistakes": [
                                    "Permitir múltiplos servidores inadvertidamente",
                                    "Não resetar próxima_saida corretamente em filas vazias",
                                    "Acumular tempo ocioso errado"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Gerenciar loop de simulação, coletar estatísticas e finalizar",
                                  "subSteps": [
                                    "Implemente loop principal: WHILE tempo_atual < tempo_final, avance para próximo evento, processe chegada/saída.",
                                    "Colete métricas: tempo_medio_fila = soma_tempo_fila / tempo_final, tempo_medio_sistema, utilização.",
                                    "No final, imprima estatísticas com 4 casas decimais usando FORMAT.",
                                    "Adicione rotina de cleanup: CALL RANDOM_SEED() reset, fecha arquivos se usados.",
                                    "Valide com teoria: para rho<1, Lq ≈ rho^2/(1-rho)."
                                  ],
                                  "verification": "Execute simulação completa, compare métricas com fórmulas analíticas M/M/1 (erro <5%).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "gfortran",
                                    "Planilha Excel para comparar teórico vs simulado",
                                    "Livro 'Simulation Modeling and Analysis' de Law"
                                  ],
                                  "tips": "Use contadores de confiança: rode múltiplas réplicas se necessário; formate output para legibilidade.",
                                  "learningObjective": "Executar simulação completa e extrair insights estatísticos.",
                                  "commonMistakes": [
                                    "Loop infinito por rho>=1",
                                    "Divisão por zero em médias",
                                    "Não normalizar estatísticas por tempo de simulação"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule uma fila de call center com lambda=5 chamadas/hora, mu=6/hora, por 8 horas: calcule tempo médio na fila e % tempo servidor ocioso, comparando com analítico.",
                              "finalVerifications": [
                                "Programa compila e executa sem crashes por 10000 unidades tempo.",
                                "Estatísticas convergem para valores teóricos (Lq ≈ rho^2/(1-rho), W ≈1/(mu-lambda)).",
                                "Reprodutibilidade: mesma semente dá mesmos resultados.",
                                "Utilização servidor entre 70-90% para rho=0.8.",
                                "Nenhum overflow em contadores ou tempos.",
                                "Output formatado corretamente com médias e desvios."
                              ],
                              "assessmentCriteria": [
                                "Precisão das estatísticas simuladas vs analíticas (<10% erro).",
                                "Eficiência: tempo execução <1s para 10k eventos.",
                                "Código limpo: comentários, indentação, uso de módulos.",
                                "Correção lógica: manejo correto de eventos ociosos/fila vazia.",
                                "Robustez: funciona para rho<1 e diferentes sementes.",
                                "Documentação: prints explicativos de parâmetros e resultados."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade: Distribuições exponencial e Poisson.",
                                "Estatística: Confiança intervals para médias simuladas.",
                                "Programação: Estruturas de controle e funções em Fortran.",
                                "Matemática Aplicada: Teoria de filas (Little's Law).",
                                "Ciência de Computação: Algoritmos de simulação de eventos discretos."
                              ],
                              "realWorldApplication": "Modelagem de filas em telecomunicações (pacotes de dados), logística (linhas de produção), saúde (esperas em emergências) para otimizar recursos e reduzir tempos de espera."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.2.2",
                        "name": "Linguagem C para Simulação",
                        "description": "Adaptação da linguagem C, conhecida por sua eficiência em baixo nível, para simulação utilizando bibliotecas que fornecem ferramentas para manipulação de eventos discretos, geração de aleatoriedade e otimização de performance em grandes simulações.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.2.1",
                            "name": "Selecionar bibliotecas de simulação em C",
                            "description": "Avaliar bibliotecas como GSL (GNU Scientific Library) ou SSJ para funções de simulação, focando em geração de VA, listas de eventos e integração com estruturas de dados eficientes como filas de prioridade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar Requisitos Específicos para Bibliotecas de Simulação",
                                  "subSteps": [
                                    "Liste os requisitos chave: geração de variáveis aleatórias (VA), suporte a listas de eventos discretos e integração com estruturas de dados como filas de prioridade.",
                                    "Defina critérios de avaliação: performance, documentação, licença open-source, facilidade de instalação e compatibilidade com C padrão.",
                                    "Pesquise brevemente bibliotecas iniciais como GSL e SSJ via Google ou repositórios como GitHub.",
                                    "Documente os requisitos em uma tabela simples (ex: Excel ou Markdown)."
                                  ],
                                  "verification": "Verifique se a tabela de requisitos está completa com pelo menos 5 critérios e 2 bibliotecas listadas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Navegador web",
                                    "Editor de texto ou planilha (Google Sheets)",
                                    "Documentação inicial de GSL: https://www.gnu.org/software/gsl/"
                                  ],
                                  "tips": "Priorize requisitos críticos como filas de prioridade para simulações de eventos discretos.",
                                  "learningObjective": "Entender e priorizar necessidades funcionais para seleção de bibliotecas.",
                                  "commonMistakes": [
                                    "Ignorar licenças ou compatibilidade com C",
                                    "Focar apenas em popularidade sem requisitos específicos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Pesquisar e Coletar Informações Detalhadas sobre Bibliotecas Candidatas",
                                  "subSteps": [
                                    "Instale GSL via gerenciador de pacotes (ex: apt install libgsl-dev no Linux).",
                                    "Baixe e revise documentação de GSL (RNG para VA) e SSJ (adaptar conceitos para C).",
                                    "Analise código fonte ou exemplos para suporte a geração de VA (ex: gsl_rng_uniform) e listas de eventos.",
                                    "Verifique integração com filas de prioridade (ex: usar heapq-like em C com GSL callbacks).",
                                    "Registre prós e contras em uma tabela comparativa."
                                  ],
                                  "verification": "Confirme instalação bem-sucedida compilando um exemplo simples de RNG do GSL.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Ambiente de desenvolvimento C (GCC/Clang)",
                                    "Documentação GSL PDF",
                                    "Repositório SSJ: https://www.hec.ca/simul/",
                                    "Ferramenta de compilação (make)"
                                  ],
                                  "tips": "Use 'man gsl' ou exemplos no site oficial para aceleração.",
                                  "learningObjective": "Coletar dados objetivos sobre features de bibliotecas para simulação em C.",
                                  "commonMistakes": [
                                    "Não testar instalação",
                                    "Confundir SSJ (Java) com nativo C sem adaptação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar e Comparar Funcionalidades Chave",
                                  "subSteps": [
                                    "Teste geração de VA: compile código GSL para uniformes/exponenciais vs. implementações manuais.",
                                    "Avalie listas de eventos: verifique suporte ou exemplos de event scheduling com priority queues.",
                                    "Meça performance: rode benchmarks simples (ex: 1M VA gerações) e compare tempos.",
                                    "Analise integração: escreva snippet mock integrando fila de prioridade (priority_queue.h like).",
                                    "Pontue cada biblioteca (1-10) por critério e calcule scores totais."
                                  ],
                                  "verification": "Execute benchmarks e tenha tabela com scores >80% para pelo menos uma biblioteca.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Compilador C com timers (clock_gettime)",
                                    "Código exemplo GSL RNG",
                                    "Biblioteca std C para priority queue (ou heapq impl)"
                                  ],
                                  "tips": "Use Valgrind para checar vazamentos de memória em testes.",
                                  "learningObjective": "Comparar quantitativamente bibliotecas baseadas em requisitos de simulação.",
                                  "commonMistakes": [
                                    "Benchmarks não controlados (máquina vs. máquina)",
                                    "Ignorar overhead de dependências"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Selecionar Biblioteca e Justificar Escolha",
                                  "subSteps": [
                                    "Escolha a melhor (ex: GSL por nativo C e RNG robusto).",
                                    "Escreva relatório de 300-500 palavras justificando com evidências de testes.",
                                    "Planeje protótipo: esboce código integrando VA + priority queue para simulação discreta.",
                                    "Identifique gaps e soluções (ex: custom event list se ausente).",
                                    "Compartilhe relatório em fórum ou GitHub para feedback."
                                  ],
                                  "verification": "Relatório completo com justificativa, scores e plano de uso.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Editor Markdown",
                                    "GitHub para repo de teste",
                                    "Fórum StackOverflow para validação"
                                  ],
                                  "tips": "Inclua gráficos de benchmark para visualização.",
                                  "learningObjective": "Tomar decisão informada e documentar para reprodutibilidade.",
                                  "commonMistakes": [
                                    "Escolha subjetiva sem dados",
                                    "Não considerar escalabilidade futura"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado, use GSL para gerar chegadas de clientes (VA exponencial), priority queue para horários de eventos (checkout), e liste eventos para processar saídas, otimizando tempo médio de espera.",
                              "finalVerifications": [
                                "Lista completa de prós/contras de GSL e SSJ documentada.",
                                "Benchmarks executados com resultados numéricos.",
                                "Relatório de seleção com justificativa baseada em requisitos.",
                                "Código snippet funcional integrando VA e priority queue.",
                                "Identificação de pelo menos 2 gaps e mitigações."
                              ],
                              "assessmentCriteria": [
                                "Profundidade da análise de features (geração VA, eventos, integração): 30%",
                                "Qualidade e objetividade dos benchmarks: 25%",
                                "Justificativa clara e evidenciada da seleção: 20%",
                                "Documentação completa e organizada: 15%",
                                "Criatividade em conexões com simulações reais: 10%"
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: Geração e validação de VA.",
                                "Estruturas de Dados: Filas de prioridade e listas ligadas.",
                                "Algoritmos: Scheduling de eventos discretos.",
                                "Desenvolvimento de Software: Gerenciamento de dependências e testes."
                              ],
                              "realWorldApplication": "Selecionar GSL para simular redes de telecomunicações em empresas como Ericsson, otimizando filas de pacotes para reduzir latência em 5G."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.2.2",
                            "name": "Programar geradores de números aleatórios em C",
                            "description": "Implementar algoritmos de geração de números pseudoaleatórios (ex: Mersenne Twister via GSL) e transformações para distribuições comuns, testando em cenários de simulação de sistemas discretos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambiente e compreender fundamentos de PRNGs",
                                  "subSteps": [
                                    "Instalar compilador GCC e biblioteca GSL via gerenciador de pacotes (apt install gsl-bin libgsl-dev no Ubuntu).",
                                    "Estudar documentação GSL para gsl_rng_mt19937 (Mersenne Twister).",
                                    "Implementar programa simples que inicializa seed e gera 10 números uniformes [0,1).",
                                    "Compilar com flags: gcc -o rng_test rng_test.c -lgsl -lgslcblas -lm.",
                                    "Executar e observar saída."
                                  ],
                                  "verification": "Programa compila sem erros e gera sequência de números pseudoaleatórios uniformes entre 0 e 1.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "GCC compiler",
                                    "GSL library (versão 2.x)",
                                    "Editor de texto (VS Code ou Vim)",
                                    "Documentação GSL online"
                                  ],
                                  "tips": "Sempre use gsl_rng_env_setup() para configurações padrão e verifique linking com ldd no executável.",
                                  "learningObjective": "Configurar ambiente C+GSL e gerar números uniformes básicos com Mersenne Twister.",
                                  "commonMistakes": [
                                    "Esquecer de linkar -lgsl -lgslcblas -lm",
                                    "Usar srand() nativo do C em vez de GSL",
                                    "Seed fixa levando a saídas idênticas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar geração de números uniformes discretos e contínuos",
                                  "subSteps": [
                                    "Criar função para gerar inteiros uniformes em [a,b] usando gsl_rng_uniform_int().",
                                    "Adaptar para intervalos personalizados e múltiplas seeds.",
                                    "Gerar array de 1000 números e salvar em arquivo CSV para análise.",
                                    "Implementar loop para múltiplas simulações com seeds diferentes.",
                                    "Testar uniformidade com histograma simples via printf."
                                  ],
                                  "verification": "Números gerados passam em teste de chi-quadrado básico (uniformidade visual em histograma).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código do Step 1",
                                    "GSL headers",
                                    "Ferramenta para plotar histograma (gnuplot opcional)"
                                  ],
                                  "tips": "Use gsl_rng_set(rng, time(NULL)) para seed dinâmica baseada em tempo.",
                                  "learningObjective": "Dominar geração uniforme e controle de seeds para reprodutibilidade.",
                                  "commonMistakes": [
                                    "Overflow em intervalos grandes",
                                    "Não liberar memória com gsl_rng_free()",
                                    "Ignorar limites de gsl_rng_uniform_int()"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar transformações para distribuições comuns",
                                  "subSteps": [
                                    "Implementar normal (Gaussiana) com gsl_ran_gaussian().",
                                    "Criar exponencial com gsl_ran_exponential() para tempos de chegada em simulações.",
                                    "Gerar Poisson com gsl_ran_poisson() para eventos discretos.",
                                    "Combinar em struct para diferentes distribuições parametrizáveis.",
                                    "Gerar 5000 amostras de cada e salvar para teste."
                                  ],
                                  "verification": "Médias e desvios padrão das amostras aproximam parâmetros teóricos (erro <5%).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "GSL random distribution module",
                                    "Código anterior",
                                    "Calculadora para parâmetros teóricos"
                                  ],
                                  "tips": "Para normal, especifique sigma=1, mu=0 inicialmente; teste com Box-Muller internamente.",
                                  "learningObjective": "Transformar uniformes em distribuições não-uniformes via métodos GSL.",
                                  "commonMistakes": [
                                    "Parâmetros errados (e.g., lambda em Poisson)",
                                    "Não normalizar para domínios discretos",
                                    "Confundir gsl_ran_ com gsl_rng_"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar em simulação de sistema discreto e testar",
                                  "subSteps": [
                                    "Implementar simulação simples de fila M/M/1: chegadas Poisson, serviços exponenciais.",
                                    "Rodar 10.000 eventos, coletar métricas (tempo médio na fila, utilização).",
                                    "Comparar com teoria de filas (L = λ/(μ-λ)).",
                                    "Adicionar testes estatísticos (KS-test via GSL gsl_cdf_).",
                                    "Otimizar código para performance (pré-alocar arrays)."
                                  ],
                                  "verification": "Métricas simuladas convergem para teóricas com <2% erro em 10 runs.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Teoria de filas (Little's Law)",
                                    "GSL stats module",
                                    "Profiler como gprof"
                                  ],
                                  "tips": "Use #define para parâmetros λ, μ; rode com diferentes seeds para variância.",
                                  "learningObjective": "Aplicar RNGs em simulações discretas e validar estatisticamente.",
                                  "commonMistakes": [
                                    "Loop infinito por μ <= λ",
                                    "Não sincronizar clocks de eventos",
                                    "Ignorar correlações em sequências longas"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Avaliar propriedades e refatorar código",
                                  "subSteps": [
                                    "Implementar testes de independência (runs test) e autocorrelação.",
                                    "Gerar relatório com estatísticas descritivas via GSL.",
                                    "Refatorar em biblioteca reutilizável (.h/.c).",
                                    "Documentar com comentários e Makefile.",
                                    "Executar benchmark contra rand() nativo."
                                  ],
                                  "verification": "Testes passam (p-value >0.05) e código é modular/portável.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "GSL stats/cdf",
                                    "Valgrind para leaks"
                                  ],
                                  "tips": "Salve seeds em arquivo para debug; use gsl_rng_clone() para ramificações.",
                                  "learningObjective": "Garantir qualidade RNG em aplicações reais via validação.",
                                  "commonMistakes": [
                                    "Vazamentos de memória em loops",
                                    "Testes insuficientes em tails",
                                    "Não comparar com benchmarks"
                                  ]
                                }
                              ],
                              "practicalExample": "Simulação de sistema de filas M/M/1: gerar chegadas Poisson (λ=4/hora), serviços exponenciais (μ=5/hora), simular 10.000 clientes, calcular tempo médio na fila e validar contra fórmula teórica Lq = ρ^2 / (1-ρ) onde ρ=λ/μ.",
                              "finalVerifications": [
                                "Código compila e executa sem crashes ou warnings em múltiplas plataformas.",
                                "Sequências passam testes de uniformidade, independência e goodness-of-fit (KS-test p>0.01).",
                                "Métricas de simulação convergem para valores teóricos em <3% erro após 10^4 iterações.",
                                "Memória sem leaks (valgrind all OK).",
                                "Código modular com funções reutilizáveis e Makefile funcional.",
                                "Geração de relatório CSV com plots de histogramas."
                              ],
                              "assessmentCriteria": [
                                "Precisão das distribuições geradas (erro estatístico <5%).",
                                "Eficiência computacional (tempo <1s para 10^6 amostras).",
                                "Robustez a diferentes seeds e parâmetros.",
                                "Qualidade do código (comentado, sem warnings, modular).",
                                "Validação estatística completa com p-values reportados.",
                                "Aplicação correta em simulação discreta com convergência demonstrada."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: Testes de hipóteses (chi-quadrado, KS-test).",
                                "Algoritmos: Complexidade de PRNGs (O(1) por amostra).",
                                "Sistemas de Filas: Teoria de Markov e Little's Law.",
                                "Desenvolvimento de Software: Boas práticas C (modularidade, testing).",
                                "Física Computacional: Simulações Monte Carlo."
                              ],
                              "realWorldApplication": "Desenvolvimento de simulações em finanças (preços de opções via Monte Carlo), telecomunicações (modelagem de tráfego de rede com eventos Poisson), jogos (geração procedural de mundos), e criptografia (seeds seguros para chaves)."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.2.3",
                            "name": "Desenvolver simulação de eventos discretos em C",
                            "description": "Construir uma simulação completa em C de um sistema como rede de filas, utilizando bibliotecas para gerenciamento de eventos futuros e coleta de estatísticas de performance.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Planejar o Modelo de Simulação de Rede de Filas",
                                  "subSteps": [
                                    "Defina o sistema: identifique servidores, filas e tipos de chegadas/saídas (ex: M/M/1 ou rede aberta).",
                                    "Liste eventos discretos: chegada de cliente, início de serviço, fim de serviço.",
                                    "Especifique parâmetros: taxas de chegada (λ), serviço (μ), número de réplicas da simulação.",
                                    "Desenhe diagrama: fluxograma da rede de filas com transições de eventos.",
                                    "Defina métricas de performance: tempo médio na fila, utilização do servidor, throughput."
                                  ],
                                  "verification": "Verifique se o diagrama cobre todos os eventos e métricas; simule manualmente 5 eventos em papel.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de diagrama (Draw.io)",
                                    "Documentação de simulação de eventos discretos (livro ou PDF)"
                                  ],
                                  "tips": "Comece simples com uma fila única antes de expandir para rede; use notação Kendall para modelar.",
                                  "learningObjective": "Compreender e modelar sistemas de filas como eventos discretos para simulação.",
                                  "commonMistakes": [
                                    "Ignorar dependências entre filas em redes",
                                    "Confundir eventos de chegada com partida",
                                    "Subestimar variabilidade estocástica"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Estruturas de Dados Básicas",
                                  "subSteps": [
                                    "Crie struct para Evento: tempo, tipo (chegada/partida), entidade ID.",
                                    "Defina struct para Servidor: estado (livre/ocupado), tempo de serviço restante, fila associada.",
                                    "Implemente fila para Clientes: lista ligada com atributos (ID, tempo chegada).",
                                    "Crie arrays ou listas para múltiplos servidores na rede.",
                                    "Inclua gerador de números aleatórios (use rand() ou drand48)."
                                  ],
                                  "verification": "Compile e teste structs isoladamente: insira/remova elementos e imprima estados.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Compilador C (gcc)",
                                    "Editor de código (VS Code ou Vim)",
                                    "Header stdlib.h, stdio.h, time.h"
                                  ],
                                  "tips": "Use ponteiros para listas ligadas eficientes; inicialize seeds com time(NULL) para aleatoriedade.",
                                  "learningObjective": "Dominar structs e listas ligadas para representar entidades dinâmicas em simulações.",
                                  "commonMistakes": [
                                    "Vazamentos de memória em listas",
                                    "Não inicializar ponteiros (segmentation fault)",
                                    "Usar rand() sem escala para distribuições exponenciais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolver Lista de Eventos Futuros (FEL)",
                                  "subSteps": [
                                    "Implemente FEL como heap ou lista ordenada por tempo de evento.",
                                    "Funções: inserir_evento(tempo, tipo), extrair_proximo_evento(), imprimir_FEL().",
                                    "Agende eventos iniciais: primeira chegada em tempo 0.",
                                    "Mantenha FEL ordenada: use insertion sort ou priority queue simples.",
                                    "Trate cancelamentos: remova eventos obsoletos de partições prematuras."
                                  ],
                                  "verification": "Teste unitário: insira 10 eventos aleatórios, extraia em ordem crescente de tempo.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Compilador C",
                                    "Biblioteca stdlib para qsort ou malloc"
                                  ],
                                  "tips": "Para heap, implemente min-heap simples; compare tempos para ordenação.",
                                  "learningObjective": "Gerenciar cronologia de eventos com eficiência temporal O(log n).",
                                  "commonMistakes": [
                                    "FEL não ordenada levando a eventos fora de sequência",
                                    "Duplicatas de eventos",
                                    "Não lidar com tempos iguais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir Loop Principal de Simulação",
                                  "subSteps": [
                                    "Inicialize: tempo_sim=0, esvazie filas, agende primeira chegada.",
                                    "Loop while (tempo_sim < tempo_fim || !FEL_vazia): extraia evento, avance tempo_sim.",
                                    "Processador de eventos: switch por tipo - chegada (fila ou serviço), partida (libere servidor, agende próxima).",
                                    "Atualize estados: enfileire/desfileire, calcule tempo na fila.",
                                    "Rode múltiplas réplicas: média estatísticas sobre N runs."
                                  ],
                                  "verification": "Execute simulação curta (tempo_fim=1000), verifique se tempo_sim avança monotonicamente e eventos processados corretamente.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": [
                                    "Compilador C",
                                    "Makefile para build rápido"
                                  ],
                                  "tips": "Use clock() para medir tempo de CPU; debug com printf em eventos chave.",
                                  "learningObjective": "Orquestrar execução temporal correta de eventos discretos.",
                                  "commonMistakes": [
                                    "Avanço incorreto de tempo (pular eventos)",
                                    "Corrida de condições em multi-servidor",
                                    "Loop infinito por FEL não esvaziando"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Implementar Coleta e Relatório de Estatísticas",
                                  "subSteps": [
                                    "Variáveis acumuladoras: soma_tempo_fila, num_chegadas, tempo_servidor_total.",
                                    "Atualize em eventos: ao chegar (registra tempo), partir (soma tempo_fila, atualiza utilizacao).",
                                    "Calcule médias: tempo_medio_fila = soma / num_partidas, utilizacao = tempo_servidor / tempo_sim.",
                                    "Confidence intervals: use médias e desvios de réplicas.",
                                    "Gere relatório: printf com métricas e histogramas simples."
                                  ],
                                  "verification": "Compare resultados com fórmulas analíticas M/M/1 (ex: Lq = ρ^2 / (1-ρ)) para validação.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Compilador C",
                                    "math.h para sqrt/variance"
                                  ],
                                  "tips": "Colete em réplicas independentes para reduzir variância; plote com gnuplot se possível.",
                                  "learningObjective": "Extrair insights quantitativos de simulações estocásticas.",
                                  "commonMistakes": [
                                    "Dividir por zero em médias",
                                    "Bias em warm-up (ignorar fase transitória)",
                                    "Não normalizar utilizações"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule uma rede de duas filas M/M/1 em série: clientes chegam à fila1 (λ=0.8), servida (μ=1.0), vão para fila2 (μ=1.2). Rode 10 réplicas de 10000 unidades tempo, reporte tempo médio no sistema e bottleneck.",
                              "finalVerifications": [
                                "FEL processa eventos em ordem temporal exata sem skips.",
                                "Estatísticas convergem para valores esperados (teste com M/M/1 conhecida).",
                                "Memória sem leaks (valgrind clean).",
                                "Múltiplas réplicas produzem intervalos de confiança <10% de erro.",
                                "Código modular: funções separadas para FEL, eventos, stats.",
                                "Execução eficiente: <1s por réplica em máquina padrão."
                              ],
                              "assessmentCriteria": [
                                "Precisão do modelo: eventos e transições corretos (80%).",
                                "Eficiência de dados: O(log n) para FEL (90%).",
                                "Validade estatística: match com teoria + ICs (85%).",
                                "Código limpo: comentários, modularidade, sem warnings (95%).",
                                "Robustez: lida com edge cases (fila vazia, alta carga).",
                                "Relatório claro: métricas com interpretações."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: distribuições exponenciais, intervalos de confiança.",
                                "Algoritmos e Estruturas de Dados: heaps, listas ligadas.",
                                "Sistemas Operacionais: scheduling de eventos, filas de processos.",
                                "Engenharia de Software: modularidade, testes unitários.",
                                "Física/Matéria: modelagem de sistemas dinâmicos discretos."
                              ],
                              "realWorldApplication": "Modelar call centers para otimizar número de atendentes, simular redes de telecom para prever latência, ou linhas de produção industrial para reduzir gargalos e maximizar throughput."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.2.3",
                        "name": "Java para Simulação",
                        "description": "Uso da linguagem Java, orientada a objetos, adaptada para simulação por meio de bibliotecas que facilitam a modelagem modular, multithreading para simulações paralelas e integração com ambientes gráficos para visualização de resultados.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.3.1",
                            "name": "Explorar bibliotecas de simulação em Java",
                            "description": "Identificar e comparar bibliotecas como Apache Commons Math, JSIM ou Desmo-J, destacando suporte a objetos para entidades de simulação, geradores de aleatoriedade e análise estatística.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e Listar Bibliotecas de Simulação em Java",
                                  "subSteps": [
                                    "Pesquise no Google, GitHub e sites oficiais por 'Java simulation libraries' e 'discrete event simulation Java'.",
                                    "Compile uma lista inicial de pelo menos 5 bibliotecas, priorizando Apache Commons Math, JSIM e Desmo-J.",
                                    "Verifique status de manutenção (último commit, issues abertas) e licenças de uso.",
                                    "Anote links para documentação oficial e repositórios.",
                                    "Crie uma tabela inicial com nome, versão atual e descrição breve."
                                  ],
                                  "verification": "Lista completa com 3+ bibliotecas principais, incluindo resumos e links válidos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Acesso à internet",
                                    "Editor de texto ou planilha (Google Sheets/Excel)",
                                    "Notebook"
                                  ],
                                  "tips": "Use filtros de busca por 'active' ou 'stars > 100' no GitHub para priorizar bibliotecas relevantes.",
                                  "learningObjective": "Familiarizar-se com o ecossistema de bibliotecas de simulação disponíveis em Java.",
                                  "commonMistakes": [
                                    "Incluir bibliotecas obsoletas sem verificação de manutenção",
                                    "Ignorar licenças open-source compatíveis com projetos educacionais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Documentação e Recursos-Chave de Cada Biblioteca",
                                  "subSteps": [
                                    "Acesse a documentação oficial de Apache Commons Math, JSIM e Desmo-J.",
                                    "Identifique suporte a objetos para entidades de simulação (ex: classes para queues, events).",
                                    "Localize seções sobre geradores de aleatoriedade (RNGs como Mersenne Twister).",
                                    "Examine módulos de análise estatística (histogramas, testes de confiança).",
                                    "Registre exemplos de código introdutórios de cada biblioteca."
                                  ],
                                  "verification": "Resumo por biblioteca com trechos de código e features mapeadas para entidades, RNG e stats.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Documentação oficial (sites das bibliotecas)",
                                    "IDE Java (Eclipse/IntelliJ)",
                                    "Maven/Gradle para dependências"
                                  ],
                                  "tips": "Use Ctrl+F para buscar termos como 'random', 'entity', 'statistics' na documentação.",
                                  "learningObjective": "Compreender as capacidades técnicas específicas de cada biblioteca.",
                                  "commonMistakes": [
                                    "Ler apenas a homepage sem mergulhar em tutoriais",
                                    "Confundir features genéricas de Math com simulação discreta"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Características Específicas das Bibliotecas",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: colunas para Bibliotecas, Suporte a Objetos/Entidades, Geradores RNG, Análise Estatística.",
                                    "Avalie facilidade de uso (curva de aprendizado, exemplos disponíveis).",
                                    "Pontue de 1-5 cada feature baseada em documentação e reviews.",
                                    "Discuta trade-offs: performance vs. flexibilidade.",
                                    "Inclua métricas como tamanho da lib (JAR size) e dependências externas."
                                  ],
                                  "verification": "Tabela comparativa preenchida com pontuações e justificativas detalhadas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Planilha comparativa",
                                    "Documentação anotada do passo anterior"
                                  ],
                                  "tips": "Priorize features do contexto: objetos para simulação, RNG customizáveis e stats integradas.",
                                  "learningObjective": "Desenvolver habilidades de análise comparativa crítica de ferramentas de software.",
                                  "commonMistakes": [
                                    "Comparações superficiais sem evidências da doc",
                                    "Ignorar overhead de dependências"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Validar com Implementações Práticas Simples",
                                  "subSteps": [
                                    "Configure um projeto Maven/Gradle e adicione dependências de 2 bibliotecas (ex: Commons Math e Desmo-J).",
                                    "Implemente uma simulação básica de fila (ex: M/M/1) em cada uma.",
                                    "Meça métricas: tempo de execução, output estatístico (média de espera).",
                                    "Compare resultados e código em termos de linhas de código e legibilidade.",
                                    "Documente lições aprendidas e escolha recomendada para cenários comuns."
                                  ],
                                  "verification": "Códigos funcionais com outputs comparados e relatório de testes.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "IDE Java com Maven",
                                    "Dependências JAR das bibliotecas"
                                  ],
                                  "tips": "Comece com exemplos da doc para evitar bugs iniciais; use System.nanoTime() para benchmarks.",
                                  "learningObjective": "Aplicar bibliotecas em cenários reais de simulação para validar comparações teóricas.",
                                  "commonMistakes": [
                                    "Não seedar RNG para reprodutibilidade",
                                    "Testes em escala muito pequena que mascaram diferenças"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente uma simulação de fila de atendimento em um call center usando Desmo-J: crie entidades 'Cliente' com chegada Poisson (RNG), servidor com tempo exponencial, e gere relatório estatístico de tempo médio de espera. Compare com Apache Commons Math usando distribuições personalizadas para o mesmo cenário.",
                              "finalVerifications": [
                                "Pode listar e descrever pelo menos 3 bibliotecas com features chave corretas.",
                                "Tabela comparativa cobre objetos/entidades, RNG e análise estatística.",
                                "Códigos de teste rodam sem erros e produzem outputs estatísticos válidos.",
                                "Identifica prós/contras realistas baseados em testes.",
                                "Recomendação justificada para um cenário específico (ex: Desmo-J para DES complexa)."
                              ],
                              "assessmentCriteria": [
                                "Profundidade da pesquisa: cobertura de docs e features específicas (30%)",
                                "Qualidade da comparação: tabela objetiva com evidências (25%)",
                                "Validade dos testes práticos: códigos funcionais e benchmarks (25%)",
                                "Análise crítica: trade-offs e recomendações fundamentadas (15%)",
                                "Clareza e organização do relatório final (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação Orientada a Objetos: modelagem de entidades como classes.",
                                "Estatística Computacional: uso de RNGs e análise de distribuições.",
                                "Engenharia de Software: avaliação de bibliotecas e dependências.",
                                "Modelagem de Sistemas: aplicação em simulação de eventos discretos.",
                                "Análise de Dados: geração e interpretação de relatórios estatísticos."
                              ],
                              "realWorldApplication": "Em logística, simular filas de produção em fábricas para otimizar fluxos; em telecomunicações, modelar tráfego de rede para prever congestionamentos; ou em saúde, simular distribuição de pacientes em hospitais para planejamento de recursos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.3.2",
                            "name": "Implementar métodos de amostragem em Java",
                            "description": "Criar classes em Java utilizando bibliotecas para métodos de amostragem como método da inversa e rejeição, gerando variáveis aleatórias para modelos estocásticos em simulações discretas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar Ambiente de Desenvolvimento e Revisar Conceitos Teóricos",
                                  "subSteps": [
                                    "Instalar e configurar JDK 11 ou superior no sistema operacional.",
                                    "Configurar um IDE como IntelliJ IDEA ou Eclipse com suporte a Java.",
                                    "Estudar o método da transformada inversa: entender F^{-1}(U) onde U ~ Uniform(0,1).",
                                    "Estudar o método de rejeição: princípios de envelope e aceitação/rejeição.",
                                    "Revisar geração de aleatórias uniformes com java.util.Random."
                                  ],
                                  "verification": "Ambiente configurado (projeto Java criado e compilando um Hello World) e resumo escrito dos conceitos em um documento.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "JDK 11+",
                                    "IDE (IntelliJ/Eclipse)",
                                    "Documentação oficial Java Random",
                                    "Notas sobre métodos de amostragem (PDF ou wiki)"
                                  ],
                                  "tips": "Use Random.nextDouble() para uniformes; teste o setup com um loop simples de geração de números.",
                                  "learningObjective": "Compreender fundamentos teóricos e preparar ferramentas para implementação.",
                                  "commonMistakes": [
                                    "Esquecer de importar java.util.Random",
                                    "Confundir PDF com CDF no método inversa",
                                    "Não configurar classpath corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o Método da Transformada Inversa",
                                  "subSteps": [
                                    "Criar classe SamplingMethods com método inverseTransform(double lambda) para exponencial.",
                                    "Definir a CDF inversa: -ln(1-U)/lambda para exponencial.",
                                    "Gerar U com Random.nextDouble() e aplicar fórmula.",
                                    "Adicionar Javadoc e comentários explicativos.",
                                    "Testar método isoladamente com 1000 amostras e calcular média (deve ≈ 1/lambda)."
                                  ],
                                  "verification": "Média das amostras geradas está próxima do valor teórico (erro <5%) impresso no console.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Editor de código",
                                    "Calculadora para validação teórica",
                                    "JUnit para testes unitários opcionais"
                                  ],
                                  "tips": "Para lambda=1, média deve ser 1; use System.out.println para debug rápido.",
                                  "learningObjective": "Implementar corretamente o método inversa para distribuições contínuas comuns.",
                                  "commonMistakes": [
                                    "Usar U diretamente em vez de 1-U",
                                    "Erro em log natural (use Math.log)",
                                    "Overflow em lambda muito pequeno"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o Método de Rejeição",
                                  "subSteps": [
                                    "Criar método rejectionSampling(double[] support, double[] pdf, double M) para discretas.",
                                    "Gerar candidato X uniforme no suporte e U uniforme.",
                                    "Aceitar se U < pdf(X)/ (M * uniform_pdf(X)); senão rejeitar.",
                                    "Implementar para distribuição triangular ou similar como exemplo.",
                                    "Contar taxa de aceitação e imprimir estatísticas."
                                  ],
                                  "verification": "Taxa de aceitação >20% e histograma das amostras bate com PDF esperada.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Arrays para suporte/PDF",
                                    "Biblioteca Apache Commons Math para validação (opcional)"
                                  ],
                                  "tips": "Escolha M como supremo da PDF; normalize PDF para somar 1 em discretas.",
                                  "learningObjective": "Dominar algoritmo de rejeição para distribuições sem inversa fechada.",
                                  "commonMistakes": [
                                    "M muito pequeno causando rejeições infinitas",
                                    "Não normalizar PDF",
                                    "Índices errados em arrays"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Métodos em Simulação Discreta e Validar",
                                  "subSteps": [
                                    "Criar classe DiscreteSimulation usando SamplingMethods para gerar eventos (ex: Poisson via exponencial).",
                                    "Simular 10.000 eventos e plotar histograma simples via console ou biblioteca.",
                                    "Adicionar exceções para casos inválidos (lambda<=0).",
                                    "Escrever testes unitários para ambos métodos.",
                                    "Documentar classe completa com exemplos de uso."
                                  ],
                                  "verification": "Simulação roda sem erros, estatísticas (média, variância) coincidem com teóricas (±5%).",
                                  "estimatedTime": "2-4 horas",
                                  "materials": [
                                    "JUnit 5 para testes",
                                    "Biblioteca para histograma como JFreeChart (opcional)",
                                    "Planilha para validação manual"
                                  ],
                                  "tips": "Use loops while para rejeição eficiente; profile com System.nanoTime().",
                                  "learningObjective": "Aplicar métodos em contexto de simulação estocástica discreta.",
                                  "commonMistakes": [
                                    "Ignorar seed para reprodutibilidade (use setSeed)",
                                    "Amostras insuficientes para validação",
                                    "Não tratar bordas do suporte"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma simulação de fila M/M/1 usando método inversa para interarradas exponenciais (lambda=0.5) e rejeição para tempos de serviço discretos triangulares. Gere 5000 clientes, calcule tempo médio na fila e valide contra fórmula teórica (rho/(1-rho) onde rho=lambda/mu).",
                              "finalVerifications": [
                                "Código compila e executa sem exceções em múltiplas runs.",
                                "Estatísticas de amostras (média, variância) dentro de 5% do teórico.",
                                "Taxa de aceitação no rejeição >10% com M otimizado.",
                                "Testes unitários passam com cobertura >80%.",
                                "Documentação cobre uso e limitações.",
                                "Reprodutível com seed fixa."
                              ],
                              "assessmentCriteria": [
                                "Correção algorítmica (inversa e rejeição implementados precisamente).",
                                "Eficiência computacional (tempo de execução razoável para N=10k).",
                                "Qualidade de código (OOP, comentários, exceções).",
                                "Validação estatística robusta (histogramas e testes).",
                                "Flexibilidade (fácil adaptar para outras distribuições).",
                                "Documentação e usabilidade."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística (distribuições, CDF/PDF).",
                                "Programação Orientada a Objetos (classes, métodos em Java).",
                                "Simulações Numéricas e Monte Carlo.",
                                "Análise de Algoritmos (complexidade de rejeição).",
                                "Ciência de Dados (geração de dados sintéticos)."
                              ],
                              "realWorldApplication": "Esses métodos são essenciais em simulações Monte Carlo para finanças (preços de opções), logística (modelagem de filas em supply chain), telecomunicações (tráfego de pacotes) e epidemiologia (simulação de contágios estocásticos), permitindo previsões realistas sem fórmulas analíticas fechadas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.3.3",
                            "name": "Modelar sistema discreto orientado a objetos em Java",
                            "description": "Desenvolver uma aplicação Java com classes para simular um processo de manufatura ou call center, incorporando herança, polimorfismo e bibliotecas para validação e redução de variância.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir Requisitos e Projetar Diagrama de Classes",
                                  "subSteps": [
                                    "Analise o sistema discreto alvo (ex: call center com filas de chamadas e atendentes).",
                                    "Identifique entidades principais: Chamada, Atendente (superclasse), AtendenteRegular e AtendenteSenior (subclasses).",
                                    "Desenhe diagrama UML de classes destacando herança e polimorfismo.",
                                    "Defina atributos (ex: tempo de chegada, tempo de serviço) e métodos (ex: processarChamada()).",
                                    "Planeje eventos discretos: chegada de chamadas, início/fim de atendimento."
                                  ],
                                  "verification": "Diagrama UML completo salvo como imagem ou documento, com todas entidades e relacionamentos anotados.",
                                  "estimatedTime": "1-2 hours",
                                  "materials": [
                                    "Ferramenta UML (Draw.io ou Lucidchart)",
                                    "JDK instalado",
                                    "Papel e caneta para esboços iniciais"
                                  ],
                                  "tips": "Comece com o diagrama para evitar refatorações; use notação padrão UML para herança (seta triangular).",
                                  "learningObjective": "Compreender modelagem OO para simulações discretas, identificando hierarquias de classes.",
                                  "commonMistakes": [
                                    "Ignorar eventos discretos no design",
                                    "Confundir composição com herança",
                                    "Definir métodos sem considerar polimorfismo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Classes Base com Herança",
                                  "subSteps": [
                                    "Crie a superclasse Atendente com atributos comuns (id, tempoOcioso, fila).",
                                    "Implemente construtor, getters/setters e método abstrato processarChamada().",
                                    "Crie subclasses AtendenteRegular e AtendenteSenior estendendo Atendente, sobrescrevendo processarChamada() com tempos diferentes.",
                                    "Adicione classe Chamada com atributos (id, tempoChegada, prioridade).",
                                    "Teste herança instanciando objetos e chamando métodos."
                                  ],
                                  "verification": "Código compila e testes unitários confirmam herança (superclasse referenciada por subclasses).",
                                  "estimatedTime": "2-3 hours",
                                  "materials": [
                                    "IDE (IntelliJ ou Eclipse)",
                                    "JUnit para testes unitários"
                                  ],
                                  "tips": "Use @Override para métodos sobrescritos e super() para chamar superclasse quando necessário.",
                                  "learningObjective": "Aplicar herança para modelar variações em entidades de simulação discreta.",
                                  "commonMistakes": [
                                    "Não declarar métodos como abstratos na superclasse",
                                    "Expor atributos publicamente",
                                    "Esquecer construtores nas subclasses"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Polimorfismo e Lógica de Simulação",
                                  "subSteps": [
                                    "Crie classe Simulador com lista de atendentes polimórficos (ArrayList<Atendente>).",
                                    "Implemente gerador de eventos: use Random para chegadas de chamadas (distribuição Poisson simulada).",
                                    "Desenvolva scheduler de eventos discretos: fila de prioridade para próximos eventos.",
                                    "No loop de simulação, chame processarChamada() polimorficamente baseado no tipo de atendente disponível.",
                                    "Registre métricas: tempo médio de espera, taxa de ocupação."
                                  ],
                                  "verification": "Simulação executa 1000 iterações sem erros, produzindo logs de eventos.",
                                  "estimatedTime": "3-4 hours",
                                  "materials": [
                                    "JDK 8+",
                                    "Biblioteca Apache Commons Math para distribuições randômicas"
                                  ],
                                  "tips": "Use PriorityQueue para eventos; avance tempo apenas em eventos discretos para eficiência.",
                                  "learningObjective": "Utilizar polimorfismo para simular comportamentos dinâmicos em sistemas discretos.",
                                  "commonMistakes": [
                                    "Atualizar tempo continuamente em vez de por eventos",
                                    "Não tratar fila vazia ou atendentes ociosos",
                                    "Ignorar casting desnecessário em polimorfismo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Bibliotecas para Validação e Redução de Variância",
                                  "subSteps": [
                                    "Adicione JUnit para testes de validação de classes e simulação.",
                                    "Incorpore Apache Commons Math para calcular estatísticas (média, variância) e técnicas de redução (antithetic variates).",
                                    "Implemente múltiplas runs da simulação e compute intervalos de confiança.",
                                    "Valide resultados contra valores teóricos (ex: M/M/1 queue).",
                                    "Adicione logs e relatórios de output."
                                  ],
                                  "verification": "Testes JUnit passam (cobertura >80%); variância reduzida em runs paralelas.",
                                  "estimatedTime": "2-3 hours",
                                  "materials": [
                                    "Maven/Gradle para dependências",
                                    "JUnit 5",
                                    "Apache Commons Math 3.x"
                                  ],
                                  "tips": "Use @ParameterizedTest para validar múltiplos cenários; seed Random para reprodutibilidade.",
                                  "learningObjective": "Melhorar precisão de simulações com bibliotecas e técnicas estatísticas.",
                                  "commonMistakes": [
                                    "Não configurar dependências corretamente",
                                    "Confundir variância com desvio padrão",
                                    "Executar runs insuficientes para confiança"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Executar, Analisar e Refinar a Simulação",
                                  "subSteps": [
                                    "Rode simulação completa para call center com 5 atendentes e 1000 chamadas.",
                                    "Analise outputs: gráficos de métricas usando bibliotecas ou Excel.",
                                    "Refatore código para extensibilidade (ex: adicionar mais subclasses).",
                                    "Documente limitações e melhorias potenciais.",
                                    "Compartilhe código em repositório Git."
                                  ],
                                  "verification": "Relatório final com métricas validadas e código commitado.",
                                  "estimatedTime": "1-2 hours",
                                  "materials": [
                                    "Git",
                                    "Ferramenta de gráficos (JFreeChart ou export to CSV)"
                                  ],
                                  "tips": "Compare resultados com simulações analíticas para validação cruzada.",
                                  "learningObjective": "Integrar e validar modelo OO completo para simulação discreta.",
                                  "commonMistakes": [
                                    "Sobreestimar precisão sem múltiplas runs",
                                    "Ignorar overhead computacional em loops",
                                    "Não documentar assumptions"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um call center: chamadas chegam aleatoriamente (Poisson λ=10/hora). AtendenteRegular leva 5min/chamada (exp 1/5), AtendenteSenior 3min (exp 1/3). Use 3 regulares + 2 seniors. Meça tempo médio na fila e % ociosos após 8h, reduzindo variância com 50 runs.",
                              "finalVerifications": [
                                "Código compila e executa simulação sem exceções.",
                                "Herança e polimorfismo funcionam: subclasses processam chamadas diferentemente.",
                                "Métricas estatísticas calculadas corretamente com redução de variância.",
                                "Testes unitários cobrem >80% do código.",
                                "Relatório inclui gráficos e intervalos de confiança.",
                                "Simulação escalável para diferentes parâmetros."
                              ],
                              "assessmentCriteria": [
                                "Uso correto e completo de herança (super/subclasses abstratas).",
                                "Implementação eficaz de polimorfismo sem casting.",
                                "Modelagem precisa de eventos discretos (fila de prioridade).",
                                "Integração de bibliotecas para validação estatística.",
                                "Código limpo, documentado e testado.",
                                "Análise de resultados com interpretações corretas."
                              ],
                              "crossCurricularConnections": [
                                "Programação Orientada a Objetos (herança/polimorfismo).",
                                "Probabilidade e Estatística (distribuições, variância).",
                                "Engenharia de Software (testes, refatoração).",
                                "Gestão de Operações (simulação de filas/processos).",
                                "Matemática Computacional (algoritmos de simulação)."
                              ],
                              "realWorldApplication": "Otimização de call centers (ex: dimensionamento de atendentes na Vivo/Claro), linhas de manufatura (ex: simular estações em fábricas da Toyota para reduzir gargalos), logística (gerenciamento de filas em portos/aeroportos) e saúde (simulação de emergências em hospitais)."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.3",
                    "name": "Características Essenciais das Linguagens de Simulação",
                    "description": "Recursos como gerenciamento de eventos, filas, geração de aleatórias e coleta de estatísticas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.3.1",
                        "name": "Gerenciamento de Eventos",
                        "description": "Mecanismos fundamentais nas linguagens de simulação para lidar com eventos discretos, incluindo escalonamento, processamento e avanço do tempo de simulação.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.1.1",
                            "name": "Identificar tipos de eventos em simulações discretas",
                            "description": "Diferenciar eventos internos e externos, e explicar como eles são representados em linguagens como GPSS ou Simula.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Básicos de Eventos em Simulações Discretas",
                                  "subSteps": [
                                    "Estude a definição de simulação discreta como um processo onde o estado muda em pontos discretos no tempo.",
                                    "Identifique que eventos são mudanças de estado que ocorrem em tempos específicos.",
                                    "Revise exemplos simples de eventos, como chegadas e partidas em uma fila.",
                                    "Anote as características comuns de eventos: tempo de ocorrência, tipo e impacto no sistema.",
                                    "Compare simulações discretas com contínuas para destacar a natureza event-driven."
                                  ],
                                  "verification": "Crie um diagrama simples de timeline com 3 eventos em uma simulação discreta e explique cada um.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro 'Simulation Modeling and Analysis' de Law; vídeo introdutório sobre simulações discretas no YouTube.",
                                  "tips": "Use analogias do dia a dia, como semáforos, para visualizar mudanças discretas.",
                                  "learningObjective": "Definir eventos em simulações discretas e listar suas propriedades essenciais.",
                                  "commonMistakes": "Confundir eventos com estados contínuos; assumir que todos os eventos ocorrem uniformemente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diferenciar Eventos Internos e Externos",
                                  "subSteps": [
                                    "Defina evento externo: disparado por fontes externas ao modelo, como chegadas de clientes.",
                                    "Defina evento interno: gerado pelo próprio sistema, como término de serviço interno.",
                                    "Classifique exemplos: chegada de paciente (externo) vs liberação de cama (interno).",
                                    "Crie uma tabela comparativa com colunas para definição, exemplos e triggers.",
                                    "Discuta implicações: eventos externos usam clocks reais, internos usam agendas internas."
                                  ],
                                  "verification": "Classifique 5 eventos de um cenário de supermercado como interno ou externo, justificando cada um.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Artigo sobre gerenciamento de eventos em simulação; planilha Excel para tabela comparativa.",
                                  "tips": "Lembre-se: externo vem 'de fora', interno é 'auto-gerado' pelo modelo.",
                                  "learningObjective": "Distinguir precisamente eventos internos de externos com exemplos contextualizados.",
                                  "commonMistakes": "Classificar erroneamente eventos dependentes como externos; ignorar hierarquia de triggers."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Representação de Eventos em GPSS",
                                  "subSteps": [
                                    "Estude a sintaxe GPSS: use BLOCKS como GENERATE para eventos externos e TERMINATE para internos.",
                                    "Analise um código GPSS simples para simulação de fila, identificando eventos.",
                                    "Implemente um snippet: simule chegadas (externo) e saídas (interno) com STORAGE.",
                                    "Debugue um código GPSS com eventos mistos para observar o calendário de eventos.",
                                    "Documente como GPSS gerencia a lista de eventos futuros (Future Event List - FEL)."
                                  ],
                                  "verification": "Escreva e execute um programa GPSS básico que diferencie e liste 3 eventos internos/externos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Manual GPSS/H; simulador online GPSS ou software GPSS World.",
                                  "tips": "Comece com modelos simples de M/M/1 para praticar sem sobrecarga.",
                                  "learningObjective": "Representar e simular eventos internos/externos usando sintaxe GPSS.",
                                  "commonMistakes": "Confundir GENERATE com TRANSFER; não atualizar corretamente a FEL."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Representação de Eventos em Simula",
                                  "subSteps": [
                                    "Revise classes em Simula: eventos como processos com WAIT e SIGNAL.",
                                    "Examine como eventos externos são modelados com input streams e internos com activations.",
                                    "Codifique um exemplo: simulação de banco com chegadas externas e serviços internos.",
                                    "Compare o event list em Simula com GPSS, destacando simulações orientadas a objetos.",
                                    "Teste o código compilando e rodando, observando logs de eventos."
                                  ],
                                  "verification": "Desenvolva um programa Simula curto que identifique e processe eventos internos/externos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Documentação Simula 67; compilador Simula online ou ambiente local.",
                                  "tips": "Use herança de classes para modelar diferentes tipos de eventos eficientemente.",
                                  "learningObjective": "Implementar representação de eventos em Simula, comparando com GPSS.",
                                  "commonMistakes": "Ignorar prioridades de eventos; misturar sincronização WAIT/SIGNAL."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar e Aplicar Conhecimentos",
                                  "subSteps": [
                                    "Compare GPSS e Simula em uma tabela: representação de eventos, vantagens e limitações.",
                                    "Crie um fluxograma híbrido mostrando fluxo de eventos internos/externos em ambas linguagens.",
                                    "Simule um cenário complexo com ambos tipos de eventos.",
                                    "Avalie performance: conte eventos processados em uma run de simulação.",
                                    "Reflita sobre quando usar cada linguagem baseado no tipo de eventos."
                                  ],
                                  "verification": "Produza um relatório comparativo com código e análise de 10 eventos simulados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramentas de simulação das steps anteriores; editor de texto para fluxogramas.",
                                  "tips": "Priorize cenários reais para manter relevância e motivação.",
                                  "learningObjective": "Sintetizar diferenças e aplicações práticas de eventos em linguagens de simulação.",
                                  "commonMistakes": "Superficialidade na comparação; não testar códigos em execução."
                                }
                              ],
                              "practicalExample": "Em uma simulação de call center: eventos externos são chamadas chegando (GENERATE em GPSS ou input em Simula); eventos internos são fim de atendimento (TERMINATE ou SIGNAL em Simula), gerenciados pela Future Event List para processar na ordem cronológica.",
                              "finalVerifications": [
                                "Defina corretamente evento interno vs externo com 100% de precisão.",
                                "Classifique eventos em um diagrama de simulação discreta fornecido.",
                                "Explique representação em GPSS com exemplo de código funcional.",
                                "Descreva mecanismo de eventos em Simula com herança de classes.",
                                "Compare as duas linguagens em gerenciamento de FEL.",
                                "Simule e liste eventos de um cenário simples sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na diferenciação de eventos internos/externos (30%)",
                                "Correção na representação sintática em GPSS e Simula (25%)",
                                "Profundidade de exemplos e comparações (20%)",
                                "Capacidade de verificação e debugging de simulações (15%)",
                                "Clareza em relatórios e fluxogramas (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Conceitos de filas de eventos e scheduling em linguagens como Python (SimPy).",
                                "Probabilidade: Modelagem de tempos inter-arrival para eventos externos.",
                                "Ciência da Computação: Algoritmos de heap para Future Event List.",
                                "Engenharia: Aplicações em simulação de manufatura e logística.",
                                "Matemática: Teoria de filas (M/M/1) para validação de eventos."
                              ],
                              "realWorldApplication": "Em logística, identificar eventos externos (chegadas de caminhões) vs internos (carregamentos concluídos) otimiza agendamentos em software como Arena ou custom GPSS, reduzindo atrasos em supply chains globais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.1.2",
                            "name": "Implementar escalonador de eventos",
                            "description": "Descrever o funcionamento de filas de eventos futuros (FEL) e o algoritmo de avanço de tempo em linguagens de simulação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Future Event List (FEL) e Gerenciamento de Eventos",
                                  "subSteps": [
                                    "Estude a definição de FEL como uma fila de prioridade ordenada pelo tempo de ocorrência futura dos eventos.",
                                    "Identifique atributos essenciais de um evento: tempo de ocorrência, tipo de evento (ex: chegada, saída), e dados associados (ex: ID da entidade).",
                                    "Analise o ciclo de vida de eventos em simulações discretas de eventos (DES).",
                                    "Revise estruturas de dados adequadas para FEL, como heap binário ou priority queue.",
                                    "Desenhe um diagrama ilustrando a evolução da FEL durante uma simulação simples."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o funcionamento da FEL com um exemplo de 3 eventos.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Documentação de simulação discreta (ex: livro 'Simulation Modeling and Analysis' de Law)",
                                    "Vídeo tutorial sobre DES no YouTube",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Comece com um exemplo manual de FEL evoluindo passo a passo para visualizar melhor.",
                                  "learningObjective": "Dominar os conceitos fundamentais da FEL e seu papel no escalonador de eventos.",
                                  "commonMistakes": "Confundir FEL com uma fila FIFO simples ou ignorar a necessidade de cancelamento de eventos futuros."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar e Implementar a Estrutura de Dados para a FEL",
                                  "subSteps": [
                                    "Escolha uma linguagem de programação (ex: Python com heapq) e defina uma classe Event com atributos: time, type, data.",
                                    "Implemente a FEL como uma priority queue onde a prioridade é o tempo (menor tempo primeiro).",
                                    "Adicione métodos para inserir evento (schedule_event(time, type, data)).",
                                    "Implemente remoção do evento com menor tempo (get_next_event()).",
                                    "Teste a ordenação inserindo eventos fora de ordem e verificando a extração."
                                  ],
                                  "verification": "Insira 5 eventos desordenados e confirme que são extraídos em ordem crescente de tempo.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Python ou pseudocódigo editor (ex: VS Code)",
                                    "Biblioteca heapq do Python",
                                    "Exemplos de código de priority queue"
                                  ],
                                  "tips": "Use tuplas (time, counter, event) na priority queue para quebrar empates em tempos iguais.",
                                  "learningObjective": "Criar uma FEL funcional e eficiente (O(log n) para inserção/remoção).",
                                  "commonMistakes": "Esquecer de lidar com empates de tempo ou usar lista simples sem heap."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolver Funções de Agendamento e Cancelamento de Eventos",
                                  "subSteps": [
                                    "Implemente schedule_event para adicionar eventos futuros à FEL.",
                                    "Crie uma função cancel_event para remover eventos específicos (ex: por ID).",
                                    "Adicione suporte a eventos condicionais ou recorrentes.",
                                    "Integre um contador global de eventos para IDs únicos.",
                                    "Teste cenários: agendar múltiplos eventos e cancelar alguns."
                                  ],
                                  "verification": "Agende 10 eventos, cancele 3 e confirme que os restantes são processados corretamente.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Código da FEL do passo anterior",
                                    "Ferramentas de debug (print ou debugger)"
                                  ],
                                  "tips": "Mantenha um dicionário de eventos pendentes por ID para facilitar cancelamentos.",
                                  "learningObjective": "Gerenciar dinamicamente eventos na FEL com inserção e remoção eficientes.",
                                  "commonMistakes": "Não invalidar eventos cancelados que ainda estão na FEL ou duplicar eventos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar o Algoritmo de Avanço de Tempo e Loop Principal",
                                  "subSteps": [
                                    "Defina variáveis globais: current_time, sim_end_time.",
                                    "Implemente o loop while: while FEL não vazia e current_time < sim_end_time.",
                                    "Extraia próximo evento, avance current_time para seu tempo.",
                                    "Processe o evento (dispatch baseado no tipo).",
                                    "Agende eventos consequentes (ex: saída após chegada)."
                                  ],
                                  "verification": "Execute uma simulação completa e logue a FEL e current_time em cada iteração.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Código completo dos passos anteriores",
                                    "Exemplo de simulação de fila M/M/1"
                                  ],
                                  "tips": "Use logging para rastrear mudanças na FEL e tempo atual.",
                                  "learningObjective": "Executar o ciclo completo de escalonamento e avanço de tempo em DES.",
                                  "commonMistakes": "Avançar tempo além do necessário ou processar eventos passados."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e Validar o Escalonador de Eventos",
                                  "subSteps": [
                                    "Crie casos de teste: simulação vazia, um evento, múltiplos eventos com cancelamentos.",
                                    "Meça métricas: tempo total de simulação, número de eventos processados.",
                                    "Verifique ordenação e ausência de eventos fantasmas.",
                                    "Otimize para performance com profiling.",
                                    "Documente o código com comentários."
                                  ],
                                  "verification": "Todos os testes passam e métricas batem com cálculos manuais.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Framework de testes (ex: unittest em Python)",
                                    "Casos de teste pré-definidos"
                                  ],
                                  "tips": "Compare saída com simulação manual para validação.",
                                  "learningObjective": "Garantir robustez e corretude do escalonador implementado.",
                                  "commonMistakes": "Testes insuficientes para cenários edge como FEL vazia ou tempos iguais."
                                }
                              ],
                              "practicalExample": "Implemente um escalonador para simular uma fila de caixa em supermercado: clientes chegam em tempos Poisson (média 5 min), tempo de serviço exponencial (média 3 min). Agende chegadas iniciais, processe chegadas (agende serviço se caixa livre) e saídas. Rode por 480 min e conte clientes atendidos.",
                              "finalVerifications": [
                                "FEL permanece ordenada por tempo em todas as iterações.",
                                "Current_time avança monotonicamente para o tempo do próximo evento.",
                                "Todos os eventos agendados são processados ou cancelados corretamente.",
                                "Nenhum evento com tempo < current_time permanece na FEL.",
                                "Métricas finais (ex: número de eventos) coincidem com logs.",
                                "Cancelamentos removem eventos específicos sem afetar outros."
                              ],
                              "assessmentCriteria": [
                                "Eficiência: Inserção/remoção em O(log n) com heap.",
                                "Corretude: Avanço de tempo preciso e processamento sequencial.",
                                "Robustez: Lida com cancelamentos, empates e FEL vazia.",
                                "Clareza: Código bem estruturado com comentários e nomes descritivos.",
                                "Testabilidade: Cobertura de testes >80% com casos edge.",
                                "Escalabilidade: Funciona com >1000 eventos sem lentidão."
                              ],
                              "crossCurricularConnections": [
                                "Estruturas de Dados e Algoritmos (priority queues, heaps)",
                                "Probabilidade e Estatística (distribuições para tempos de eventos)",
                                "Programação Orientada a Objetos (classes Event e Scheduler)",
                                "Engenharia de Software (testes unitários e logging)",
                                "Sistemas de Filas (teoria de filas em simulações)"
                              ],
                              "realWorldApplication": "Escalonadores de eventos são fundamentais em simuladores de redes (ex: NS-3 para tráfego de pacotes), logística (otimização de rotas em supply chain), manufatura (simulação de linhas de produção com máquinas e falhas) e jogos (gerenciamento de ações em tempo real como em Unity)."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.1.3",
                            "name": "Gerenciar conflitos de eventos",
                            "description": "Explicar estratégias para resolver múltiplos eventos no mesmo instante de tempo, como tie-breaking rules.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conflitos de eventos em simulações discretas",
                                  "subSteps": [
                                    "Definir evento como uma mudança de estado em um timestamp específico",
                                    "Explicar que conflitos ocorrem quando múltiplos eventos têm o mesmo timestamp",
                                    "Analisar impactos: ordem de processamento altera resultados da simulação",
                                    "Visualizar com timeline: desenhar eventos sobrepostos no eixo temporal",
                                    "Diferenciar de simulações contínuas onde simultaneidade é aproximada"
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito o conceito com um diagrama simples",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação de linguagens como SimPy ou DESMO-J; papel e caneta para diagramas",
                                  "tips": "Use timelines horizontais para visualizar melhor a sobreposição temporal",
                                  "learningObjective": "Identificar e descrever conflitos de eventos e suas implicações na simulação",
                                  "commonMistakes": "Confundir conflitos com atrasos de processamento ou ignorar ordenação"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar estratégias de tie-breaking",
                                  "subSteps": [
                                    "Listar regras comuns: FIFO (primeiro a chegar), LIFO (último a chegar)",
                                    "Estudar priorização por tipo de evento (ex: chegada > saída)",
                                    "Analisar regras personalizadas baseadas em atributos (ID, prioridade)",
                                    "Comparar prós e contras de cada estratégia em cenários hipotéticos",
                                    "Revisar exemplos em documentações de ferramentas de simulação"
                                  ],
                                  "verification": "Criar uma tabela comparativa de 3 estratégias com exemplos",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Tutoriais de SimPy ou Arena Simulation; planilha para tabela",
                                  "tips": "Priorize estratégias que preservem causalidade na simulação",
                                  "learningObjective": "Selecionar e justificar estratégias adequadas para diferentes contextos",
                                  "commonMistakes": "Aplicar FIFO universalmente sem considerar prioridades"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar gerenciamento de conflitos em pseudocódigo",
                                  "subSteps": [
                                    "Estruturar fila de eventos com campos: timestamp, tipo, prioridade, ID",
                                    "Implementar função de ordenação usando critérios de tie-breaking",
                                    "Codificar lógica condicional para múltiplos eventos no mesmo tempo",
                                    "Adicionar logging para rastrear ordem de processamento",
                                    "Testar com dados de entrada simulando conflito"
                                  ],
                                  "verification": "Executar pseudocódigo manualmente e verificar ordem correta",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Editor de texto ou IDE simples; exemplos de código de simulação",
                                  "tips": "Use heaps ou queues prioritárias para eficiência em implementações reais",
                                  "learningObjective": "Desenvolver código que resolva conflitos de forma determinística",
                                  "commonMistakes": "Esquecer de tratar empates em múltiplos critérios"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e testar a implementação",
                                  "subSteps": [
                                    "Criar casos de teste: sem conflito, um conflito, múltiplos conflitos",
                                    "Executar simulação e comparar saídas com expectativas",
                                    "Analisar sensibilidade: variar regras e observar impactos",
                                    "Documentar resultados em relatório com métricas (ex: tempo de processamento)",
                                    "Refinar código baseado em falhas identificadas"
                                  ],
                                  "verification": "Passar em todos os casos de teste com logs corretos",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramenta de simulação como Python com SimPy; planilha para testes",
                                  "tips": "Automatize testes com asserts para verificação rápida",
                                  "learningObjective": "Garantir robustez da solução em cenários variados",
                                  "commonMistakes": "Testar apenas casos ideais, ignorando edge cases"
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado, dois clientes chegam exatamente no tempo t=10.0s. Usando tie-breaking por ID (menor ID primeiro), o cliente ID=5 é processado antes do ID=7, evitando deadlock na caixa registradora.",
                              "finalVerifications": [
                                "Lista e explica pelo menos 3 estratégias de tie-breaking",
                                "Implementa pseudocódigo sem erros lógicos",
                                "Testa com 3 cenários de conflito e valida resultados",
                                "Justifica escolha de estratégia para um caso prático",
                                "Documenta impactos de diferentes regras na simulação",
                                "Identifica e corrige um erro comum em gerenciamento"
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (entendimento de conflitos: 20%)",
                                "Diversidade e justificativa de estratégias (25%)",
                                "Correção e eficiência da implementação (25%)",
                                "Qualidade dos testes e validação (15%)",
                                "Documentação clara e exemplos práticos (10%)",
                                "Criatividade em conexões reais (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Ciência da Computação: Algoritmos de ordenação e filas prioritárias",
                                "Gestão de Projetos: Resolução de conflitos em agendamento",
                                "Física: Modelagem de colisões em sistemas discretos",
                                "Engenharia de Software: Tratamento de concorrência em threads"
                              ],
                              "realWorldApplication": "Em simulações de redes de telecomunicações para resolver colisões de pacotes simultâneos, ou em logística para priorizar eventos de chegada de caminhões em terminais portuários, garantindo previsibilidade e eficiência operacional."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.3.2",
                        "name": "Gerenciamento de Filas",
                        "description": "Recursos para modelar e simular filas em sistemas de eventos discretos, incluindo entrada, saída e disciplinas de serviço.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.2.1",
                            "name": "Modelar estruturas de filas",
                            "description": "Definir filas como listas dinâmicas com atributos como tamanho, tempo de espera e disciplina FIFO/LIFO.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Filas",
                                  "subSteps": [
                                    "Defina fila como uma estrutura de dados linear que segue o princípio FIFO (First In, First Out).",
                                    "Compare com LIFO (Last In, First Out) usado em pilhas para destacar diferenças.",
                                    "Identifique operações básicas: enfileirar (enqueue), desenfileirar (dequeue), peek e isEmpty.",
                                    "Discuta filas como listas dinâmicas que crescem e encolhem.",
                                    "Explore variantes como filas circulares ou de prioridade."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o princípio FIFO com um exemplo simples.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagrama de fila impresso ou digital",
                                    "Vídeo introdutório sobre estruturas de dados (ex: Khan Academy)",
                                    "Pseudocódigo básico de fila"
                                  ],
                                  "tips": "Use analogias cotidianas como fila de supermercado para visualizar o fluxo.",
                                  "learningObjective": "Dominar os princípios operacionais e diferenças entre FIFO e LIFO.",
                                  "commonMistakes": [
                                    "Confundir FIFO com LIFO",
                                    "Ignorar o aspecto dinâmico da lista",
                                    "Esquecer operações auxiliares como peek"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Atributos Essenciais da Estrutura de Fila",
                                  "subSteps": [
                                    "Liste atributos principais: tamanho atual (currentSize), capacidade máxima (maxSize), tempo de espera médio e tempo total de espera.",
                                    "Defina disciplina de serviço: FIFO padrão ou variantes como LIFO para contextos específicos.",
                                    "Calcule métricas derivadas: tempo médio de espera = tempo total / número de elementos processados.",
                                    "Considere atributos de simulação: tempo de chegada, tempo de serviço por elemento.",
                                    "Crie um diagrama esquemático representando a fila com ponteiros front e rear."
                                  ],
                                  "verification": "Crie uma tabela com atributos e fórmulas associadas, validada por auto-revisão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou papel para tabela de atributos",
                                    "Exemplos de simulações de filas em PDF",
                                    "Ferramenta de desenho como Draw.io"
                                  ],
                                  "tips": "Priorize atributos relevantes para simulação discreta, focando em métricas de performance.",
                                  "learningObjective": "Identificar e quantificar atributos chave para modelagem realista.",
                                  "commonMistakes": [
                                    "Omitir tempos de espera",
                                    "Confundir tamanho atual com capacidade",
                                    "Ignorar dinâmicas de chegada/serviço"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modelar a Estrutura de Fila em Pseudocódigo",
                                  "subSteps": [
                                    "Defina a classe Queue com atributos: front, rear, size, maxSize.",
                                    "Implemente construtor inicializando front=rear=-1, size=0.",
                                    "Escreva pseudocódigo para enqueue: verificar overflow, ajustar rear, inserir elemento.",
                                    "Escreva pseudocódigo para dequeue: verificar underflow, ajustar front, remover elemento.",
                                    "Adicione funções auxiliares: isFull(), isEmpty(), calcular tempo de espera."
                                  ],
                                  "verification": "Teste o pseudocódigo manualmente com 5 operações de enfileiramento/desenfileiramento.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Editor de texto para pseudocódigo",
                                    "Simulador online de estruturas de dados",
                                    "Papel para traçar execuções"
                                  ],
                                  "tips": "Use arrays para implementação simples; valide limites para evitar erros de índice.",
                                  "learningObjective": "Construir uma representação abstrata e funcional da fila.",
                                  "commonMistakes": [
                                    "Erro em ponteiros front/rear",
                                    "Não tratar casos vazia/cheia",
                                    "Pseudocódigo ambíguo sem condições"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular e Validar a Modelagem com Atributos Dinâmicos",
                                  "subSteps": [
                                    "Simule uma sequência de chegadas e saídas, rastreando tamanho e tempos de espera.",
                                    "Calcule métricas: tempo médio de espera, utilização da fila (size/maxSize).",
                                    "Ajuste para disciplina FIFO/LIFO em cenários diferentes.",
                                    "Visualize a simulação com um gráfico de evolução do tamanho ao longo do tempo.",
                                    "Otimize o modelo adicionando prioridades ou filas múltiplas."
                                  ],
                                  "verification": "Gere relatório de simulação com métricas calculadas e gráfico.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Planilha Excel/Google Sheets para simulação",
                                    "Biblioteca Python como collections.deque para protótipo",
                                    "Gráfico de linha pronto"
                                  ],
                                  "tips": "Comece com poucos elementos para depurar antes de escalar.",
                                  "learningObjective": "Aplicar o modelo em simulações discretas com validação de atributos.",
                                  "commonMistakes": [
                                    "Erros em cálculos de tempo acumulado",
                                    "Ignorar wrap-around em filas circulares",
                                    "Não registrar estados intermediários"
                                  ]
                                }
                              ],
                              "practicalExample": "Modelar a fila de um caixa de supermercado: clientes chegam aleatoriamente (enqueue com tempo de chegada), cada um tem tempo de serviço de 2 minutos (dequeue). Rastreie tamanho da fila, tempo médio de espera (ex: 5 minutos) e pico de ocupação para otimizar abertura de caixas.",
                              "finalVerifications": [
                                "Explicar corretamente FIFO e atributos como tempo de espera em uma apresentação curta.",
                                "Implementar e executar pseudocódigo sem erros em um simulador.",
                                "Calcular métricas de uma simulação de 10 elementos com precisão.",
                                "Identificar e corrigir overflow/underflow em cenários teste.",
                                "Desenhar diagrama da fila em estados iniciais, cheios e vazios.",
                                "Comparar modelo com ferramenta real como Python Queue."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: 100% correto em definições FIFO/atributos (30%)",
                                "Qualidade do pseudocódigo: funcional, com tratamento de erros (25%)",
                                "Simulação realista: métricas calculadas corretamente (20%)",
                                "Visualizações claras: diagramas e gráficos legíveis (15%)",
                                "Criatividade em variantes: inclusão de prioridades ou múltiplas filas (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em linguagens como Python ou Java.",
                                "Probabilidade e Estatística: Modelagem de chegadas Poisson e tempos exponenciais.",
                                "Gestão de Operações: Otimização de filas em logística e serviços.",
                                "Física Computacional: Simulações de partículas em fluxos discretos."
                              ],
                              "realWorldApplication": "Em call centers para gerenciar chamadas pendentes, reduzindo tempo de espera; em redes de computadores para buffers de pacotes; em manufatura para linhas de produção, otimizando throughput e evitando gargalos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.2.2",
                            "name": "Implementar operações de fila",
                            "description": "Descrever comandos para enfileirar, desenfileirar e monitorar ocupação em linguagens de simulação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de filas em linguagens de simulação",
                                  "subSteps": [
                                    "Estude a definição de fila como estrutura FIFO (First In, First Out).",
                                    "Identifique comandos básicos: ENQUEUE (enfileirar), DEQUEUE (desenfileirar) e SIZE/OCCUPANCY (ocupação).",
                                    "Revise a sintaxe específica da linguagem de simulação escolhida (ex: SimPy, Arena ou pseudocódigo).",
                                    "Analise exemplos de declaração de fila e limites de capacidade.",
                                    "Desenhe um diagrama simples de uma fila com estados vazia, parcial e cheia."
                                  ],
                                  "verification": "Crie um diagrama manual da fila e liste os comandos corretos em um papel ou editor de texto.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação da linguagem de simulação (ex: manual do SimPy)",
                                    "Papel e caneta ou ferramenta de diagramação como Draw.io"
                                  ],
                                  "tips": "Comece com pseudocódigo para abstrair antes de codificar na linguagem específica.",
                                  "learningObjective": "Entender a estrutura FIFO e comandos essenciais de gerenciamento de filas.",
                                  "commonMistakes": [
                                    "Confundir FIFO com LIFO (pilha)",
                                    "Ignorar limites de capacidade da fila"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a operação de enfileirar (ENQUEUE)",
                                  "subSteps": [
                                    "Declare uma fila com capacidade definida (ex: queue = Queue(capacity=10)).",
                                    "Escreva o comando para adicionar um elemento à fila (ex: queue.enqueue(item)).",
                                    "Adicione verificação de fila cheia antes de enfileirar.",
                                    "Teste com 3-5 enfileiramentos sequenciais.",
                                    "Registre o estado da fila após cada operação."
                                  ],
                                  "verification": "Execute o código e confirme que elementos são adicionados na ordem correta sem exceder capacidade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (ex: VS Code, Jupyter Notebook)",
                                    "Ambiente de simulação instalado (ex: Python com SimPy)"
                                  ],
                                  "tips": "Use prints ou logs para visualizar o estado da fila após cada enfileiramento.",
                                  "learningObjective": "Codificar e validar a inserção ordenada de elementos em uma fila.",
                                  "commonMistakes": [
                                    "Não verificar overflow (fila cheia)",
                                    "Inserir no início em vez do fim"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a operação de desenfileirar (DEQUEUE)",
                                  "subSteps": [
                                    "Escreva o comando para remover o elemento do início da fila (ex: item = queue.dequeue()).",
                                    "Adicione verificação de fila vazia antes de desenfileirar.",
                                    "Teste removendo elementos após enfileiramentos prévios.",
                                    "Combine com enfileiramento para simular fluxo dinâmico.",
                                    "Monitore o tamanho da fila após cada remoção."
                                  ],
                                  "verification": "Execute e verifique que o primeiro elemento enfileirado é o primeiro removido (FIFO).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Ambiente de simulação"
                                  ],
                                  "tips": "Sempre retorne o item removido para confirmação visual.",
                                  "learningObjective": "Codificar e validar a remoção ordenada do elemento mais antigo.",
                                  "commonMistakes": [
                                    "Remover do fim da fila",
                                    "Não tratar underflow (fila vazia)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar monitoramento de ocupação e integração completa",
                                  "subSteps": [
                                    "Adicione comandos para verificar ocupação (ex: occupancy = queue.size() / queue.capacity()).",
                                    "Crie um loop de simulação com enfileirar/desenfileirar alternados.",
                                    "Implemente alertas para fila cheia (>80%) ou vazia.",
                                    "Execute simulação completa com 10-20 operações.",
                                    "Gere relatório final com estatísticas de ocupação."
                                  ],
                                  "verification": "Simule 20 operações e confirme monitoramento preciso sem erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Ambiente de simulação",
                                    "Gráficos para visualização (opcional, ex: Matplotlib)"
                                  ],
                                  "tips": "Use loops while para automação e evite código hardcoded.",
                                  "learningObjective": "Integrar operações com monitoramento para simulações realistas.",
                                  "commonMistakes": [
                                    "Cálculo errado de ocupação percentual",
                                    "Falta de integração entre operações"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de supermercado usando SimPy: Crie uma fila de clientes (enqueue ao chegar), processe no caixa (dequeue), monitore ocupação para evitar filas longas (>70% cheia aciona alerta).",
                              "finalVerifications": [
                                "Fila enche até capacidade máxima sem overflow.",
                                "Desenfileiramento remove elementos na ordem FIFO correta.",
                                "Monitoramento de ocupação reporta valores precisos (ex: 5/10 = 50%).",
                                "Simulação roda 20+ operações sem crashes.",
                                "Alertas ativam corretamente em estados críticos.",
                                "Relatório final resume estatísticas de uso da fila."
                              ],
                              "assessmentCriteria": [
                                "Correção sintática e lógica do código (sem erros de compilação/execução).",
                                "Fidelidade ao FIFO em todas as operações testadas.",
                                "Tratamento robusto de casos edge (vazia/cheia).",
                                "Eficiência do monitoramento (tempo O(1) ideal).",
                                "Clareza e comentários no código.",
                                "Integração completa das três operações."
                              ],
                              "crossCurricularConnections": [
                                "Estruturas de Dados (Ciência da Computação): Filas como ADT.",
                                "Teoria de Filas (Matemática): Modelos M/M/1 para simulação.",
                                "Programação Orientada a Objetos: Classes de fila em linguagens.",
                                "Análise de Sistemas: Otimização de filas em engenharia."
                              ],
                              "realWorldApplication": "Simulação de filas em call centers para dimensionar atendentes, modelagem de tráfego em semáforos para otimizar fluxos urbanos, ou gerenciamento de pedidos em e-commerces para prever sobrecargas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.2.3",
                            "name": "Aplicar prioridades em filas",
                            "description": "Explicar mecanismos de filas com prioridades múltiplas e preemptivas em simulações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de Filas em Simulações Discretas",
                                  "subSteps": [
                                    "Estude o conceito de fila FIFO (First-In-First-Out) em eventos discretos.",
                                    "Identifique como filas gerenciam entidades em linguagens de simulação como SimPy ou pseudocódigo.",
                                    "Analise o impacto de filas sem prioridades no tempo de espera e throughput.",
                                    "Revise exemplos básicos de chegada e serviço de entidades.",
                                    "Pratique modelando uma fila simples com chegada Poisson e serviço exponencial."
                                  ],
                                  "verification": "Crie um diagrama de fluxo de uma fila simples e simule manualmente 5 eventos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação de SimPy ou pseudocódigo",
                                    "Papel e caneta para diagramas",
                                    "Calculadora para tempos aleatórios"
                                  ],
                                  "tips": "Use geradores de números aleatórios para simular chegadas realistas.",
                                  "learningObjective": "Dominar o comportamento básico de filas em simulações discretas.",
                                  "commonMistakes": [
                                    "Confundir filas com pilhas",
                                    "Ignorar tempos de serviço variáveis",
                                    "Não considerar o clock de simulação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Prioridades Simples Não-Preemptivas",
                                  "subSteps": [
                                    "Defina níveis de prioridade (ex: alta=1, baixa=3) usando heaps ou listas ordenadas.",
                                    "Modifique uma fila FIFO para extrair a entidade de maior prioridade quando o servidor estiver livre.",
                                    "Implemente em pseudocódigo ou Python: enfileirar com prioridade e desenfileirar priorizando.",
                                    "Teste com 10 entidades mistas de prioridades.",
                                    "Meça tempos de espera por prioridade."
                                  ],
                                  "verification": "Execute simulação e confirme que entidades de alta prioridade são atendidas antes das baixas quando possível.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Editor de código (Python/IDEs)",
                                    "Biblioteca heapq para Python",
                                    "Exemplos de código de filas"
                                  ],
                                  "tips": "Sempre associe prioridade como chave de ordenação inversa para heaps min.",
                                  "learningObjective": "Aplicar ordenação por prioridade em filas sem interrupções.",
                                  "commonMistakes": [
                                    "Permitir preemptividade acidental",
                                    "Não atualizar prioridades dinamicamente",
                                    "Erros em comparações de prioridade igual"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Prioridades Múltiplas e Preemptivas",
                                  "subSteps": [
                                    "Diferencie não-preemptivo (fila estática) de preemptivo (interrompe serviço atual).",
                                    "Implemente preemptividade: ao chegar entidade de prioridade superior, pause serviço e troque.",
                                    "Gerencie filas múltiplas (uma por prioridade) com promoção entre níveis.",
                                    "Simule cenários com 3 níveis: emergência (1), VIP (2), normal (3).",
                                    "Registre switches de contexto e tempos de resposta."
                                  ],
                                  "verification": "Simule chegada de alta prioridade durante serviço baixo e verifique interrupção correta.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Código Python com SimPy ou custom queue",
                                    "Ferramentas de profiling para medir tempos",
                                    "Planilha para logs de eventos"
                                  ],
                                  "tips": "Use timestamps para rastrear início/fim de serviços e interrupções.",
                                  "learningObjective": "Modelar filas com múltiplas prioridades e preemptividade em simulações.",
                                  "commonMistakes": [
                                    "Não restaurar serviço pausado corretamente",
                                    "Overhead excessivo em switches frequentes",
                                    "Ignorar custos de preemptividade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular e Analisar Cenários Complexos",
                                  "subSteps": [
                                    "Crie simulação completa com geradores de chegada por prioridade.",
                                    "Execute múltiplas runs (Monte Carlo) para estatísticas: tempo médio de espera por prioridade.",
                                    "Ajuste parâmetros (taxas de chegada, probabilidades de prioridade) e compare resultados.",
                                    "Visualize com gráficos de Gantt ou histogramas de esperas.",
                                    "Otimize para minimizar starvation em baixas prioridades."
                                  ],
                                  "verification": "Gere relatório com métricas mostrando redução de tempo de espera em altas prioridades sem starvation.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Python com Matplotlib/Seaborn",
                                    "SimPy library",
                                    "Dados de entrada aleatórios"
                                  ],
                                  "tips": "Use seeds fixas para reprodutibilidade em testes.",
                                  "learningObjective": "Avaliar e refinar mecanismos de prioridades em simulações realistas.",
                                  "commonMistakes": [
                                    "Amostras insuficientes para estatísticas",
                                    "Não normalizar probabilidades de prioridade",
                                    "Confundir tempo de resposta com espera"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de hospital: pacientes emergência (pri 1, preemptivo) interrompem atendimentos normais (pri 3); VIP (pri 2) esperam após emergências mas antes de normais. Simule 100 pacientes com chegadas Poisson (λ=5/h emerg, 10/h normais).",
                              "finalVerifications": [
                                "Explicar verbalmente diferença entre prioridades múltiplas e preemptivas com exemplo.",
                                "Implementar código funcional de fila prioritária preemptiva sem erros.",
                                "Simular 50 eventos e produzir gráficos de tempos de espera por prioridade.",
                                "Identificar e corrigir starvation em simulação com altas taxas de chegada prioritárias.",
                                "Comparar métricas de desempenho com fila FIFO simples.",
                                "Documentar overhead de preemptividade em relatório."
                              ],
                              "assessmentCriteria": [
                                "Precisão na ordenação e extração por prioridade (100% correto).",
                                "Correta implementação de preemptividade sem loops infinitos.",
                                "Estatísticas confiáveis com variância baixa (múltiplas runs).",
                                "Análise qualitativa/quantitativa de trade-offs (espera vs throughput).",
                                "Código limpo, comentado e modular.",
                                "Visualizações claras e interpretáveis."
                              ],
                              "crossCurricularConnections": [
                                "Ciência da Computação: Algoritmos de scheduling em SO (ex: MLFQ).",
                                "Matemática: Teoria de filas (M/M/1 com prioridades), distribuições probabilísticas.",
                                "Engenharia: Simulação de sistemas de manufatura (Kanban com prioridades).",
                                "Gestão: Otimização de recursos em call centers ou logística."
                              ],
                              "realWorldApplication": "Em sistemas operacionais para escalonamento de processos (Linux CFS com prioridades); redes para QoS em pacotes (alta prioridade para voz/video); hospitais para triagem de pacientes; centros de dados para jobs de VMs críticas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.3.3",
                        "name": "Geração de Números e Variáveis Aleatórias",
                        "description": "Ferramentas integradas para produzir sequências pseudoaleatórias e transformar em distribuições probabilísticas.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.3.1",
                            "name": "Gerar números pseudoaleatórios",
                            "description": "Entender geradores congruenciais lineares e testes de aleatoriedade em linguagens de simulação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Teoria dos Geradores Congruenciais Lineares (LCG)",
                                  "subSteps": [
                                    "Estude a fórmula básica do LCG: X_{n+1} = (a * X_n + c) mod m, onde a é o multiplicador, c o incremento, m o módulo e X_0 a semente.",
                                    "Analise os parâmetros ideais: escolha de m como potência de 2, a com propriedades específicas (ex: a=4k+1), c ímpar para bom período.",
                                    "Revise propriedades: período máximo (m se c≠0 e condições atendidas), uniformidade e independência aparente.",
                                    "Explore limitações: correlações detectáveis em sequências longas.",
                                    "Compare com outros geradores (ex: Mersenne Twister) para contextualizar."
                                  ],
                                  "verification": "Resuma em um diagrama ou parágrafo os componentes do LCG e condições para período completo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação online (Wikipedia LCG, Knuth 'The Art of Computer Programming' Vol. 2), notebook para anotações.",
                                  "tips": "Use exemplos numéricos manuais com m=16, a=5, c=1, X0=0 para visualizar iterações.",
                                  "learningObjective": "Explicar a matemática por trás do LCG e identificar parâmetros ótimos.",
                                  "commonMistakes": "Confundir módulo com multiplicador; ignorar impacto da semente zero."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar um Gerador LCG em Python",
                                  "subSteps": [
                                    "Instale Python e um editor (VS Code ou Jupyter Notebook).",
                                    "Escreva uma função LCG básica: def lcg(seed, a, c, m, n): que retorne lista de n números.",
                                    "Teste com parâmetros padrão: a=1664525, c=1013904223, m=2**32, seed=1.",
                                    "Adicione normalização para [0,1]: u_i = X_i / m.",
                                    "Crie uma classe reutilizável para estado persistente."
                                  ],
                                  "verification": "Execute o código e gere 1000 números; visualize histograma com matplotlib para uniformidade.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python 3+, bibliotecas numpy, matplotlib; tutoriais Codecademy Python.",
                                  "tips": "Use print intermediários para debugar iterações iniciais.",
                                  "learningObjective": "Codificar funcionalmente um LCG que produza sequências válidas.",
                                  "commonMistakes": "Overflow em inteiros grandes (use int em Python3); esquecimento do mod m."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar Sequências Pseudoaleatórias e Visualizar",
                                  "subSteps": [
                                    "Gere sequências longas (10^5 números) com diferentes sementes.",
                                    "Plote autocoerelação e histograma para inspecionar padrões.",
                                    "Teste sensibilidade à semente alterando X0 ligeiramente.",
                                    "Salve sequências em arquivo CSV para análises futuras.",
                                    "Experimente diferentes parâmetros e compare períodos."
                                  ],
                                  "verification": "Confirme ausência de padrões visuais em plots e período próximo a m.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Código do Step 2, pandas para CSV, seaborn para plots avançados.",
                                  "tips": "Aumente tamanho da amostra gradualmente para eficiência.",
                                  "learningObjective": "Produzir e analisar visualmente sequências pseudoaleatórias.",
                                  "commonMistakes": "Escala errada em plots; usar sementes que levam a período curto."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Testes Estatísticos de Aleatoriedade",
                                  "subSteps": [
                                    "Implemente teste de frequência (chi-quadrado para uniformidade).",
                                    "Codifique teste de séries (runs test) para independência.",
                                    "Aplique teste do poker e teste de gaps (usando scipy.stats).",
                                    "Execute bateria NIST-like simplificada (monobits, poker, etc.).",
                                    "Interprete p-valores: >0.01 indica passage."
                                  ],
                                  "verification": "Gere relatório com p-valores para 5 testes; todos passam.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Scipy.stats, NIST SP 800-22 docs adaptadas; código exemplo GitHub.",
                                  "tips": "Padronize testes para bits binários convertendo u_i >0.5.",
                                  "learningObjective": "Avaliar quantitativamente a qualidade pseudoaleatória.",
                                  "commonMistakes": "Amostra pequena (<10^4); ignorar múltiplos testes (ajuste Bonferroni)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Avaliar, Melhorar e Integrar em Simulação",
                                  "subSteps": [
                                    "Compare LCG custom vs random Python (Mersenne).",
                                    "Otimize parâmetros para cenários específicos (ex: baixa discrepância).",
                                    "Integre em simulação simples: Monte Carlo para π.",
                                    "Documente limitações e quando usar alternativas.",
                                    "Crie script completo automatizado."
                                  ],
                                  "verification": "Simulação converge corretamente; testes passam consistentemente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Códigos anteriores, exemplos Monte Carlo online.",
                                  "tips": "Versione código no Git para rastrear melhorias.",
                                  "learningObjective": "Refinar gerador e aplicá-lo em contexto simulacional.",
                                  "commonMistakes": "Sobreestimar LCG para alta dimensionalidade; não testar em aplicações."
                                }
                              ],
                              "practicalExample": "Implemente um LCG para simular 10000 lances de um dado justo (1-6). Use m=2**31-1, a=48271, c=0, seed=12345. Normalize X_i / m * 6 +1, plote histograma (esperado ~16.6% por face) e aplique chi-quadrado (p>0.05).",
                              "finalVerifications": [
                                "Fórmula LCG implementada corretamente sem overflow.",
                                "Sequências passam 4+ testes estatísticos (p>0.01).",
                                "Histograma mostra uniformidade visual.",
                                "Período verificado próximo ao máximo teórico.",
                                "Integração em simulação Monte Carlo converge.",
                                "Relatório escrito com interpretações."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na implementação LCG (100%).",
                                "Qualidade dos testes: cobertura e interpretação correta (80%).",
                                "Eficiência computacional: tempo <1s para 10^6 números.",
                                "Análise visual e estatística robusta.",
                                "Criatividade em exemplo prático e conexões reais.",
                                "Código limpo, comentado e reproduzível."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade: Testes baseados em distribuições chi-quadrado.",
                                "Programação: Estruturas modulares e bibliotecas científicas.",
                                "Estatística: Análise de hipóteses e p-valores.",
                                "Física: Simulações estocásticas em dinâmica.",
                                "Ciência de Dados: Geração de dados sintéticos."
                              ],
                              "realWorldApplication": "Em simulações financeiras (Monte Carlo para opções), jogos (RNG em videogames), criptografia básica (sementes seguras), modelagem climática e testes de software (inputs aleatórios para fuzzing)."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.3.2",
                            "name": "Transformar em variáveis aleatórias",
                            "description": "Aplicar métodos de inversa, aceitação-rejeição e convolução para distribuições comuns como exponencial e normal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de Geração de Variáveis Aleatórias",
                                  "subSteps": [
                                    "Revise a geração de números pseudoaleatórios uniformes (U[0,1]) usando geradores como Mersenne Twister.",
                                    "Estude as propriedades das distribuições alvo: exponencial (λ, pdf = λ e^{-λx}) e normal (μ, σ, pdf gaussiana).",
                                    "Aprenda os princípios dos métodos de transformação: inversa (usar CDF inversa), aceitação-rejeição (envelope) e convolução (soma de independentes).",
                                    "Identifique quando usar cada método: inversa para CDF invertível, rejeição para unimodal, convolução para soma de variáveis.",
                                    "Pratique calcular manualmente CDFs para exponencial (1 - e^{-λx}) e normal (erf aproximado)."
                                  ],
                                  "verification": "Resuma em um diagrama os três métodos e suas condições de uso; teste com cálculos manuais de 5 transformações uniformes para exponencial.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de simulação (ex: 'Simulation' de Ross), Python com NumPy, papel e caneta para diagramas.",
                                  "tips": "Sempre comece com U[0,1] uniforme; visualize CDFs com plots para intuição.",
                                  "learningObjective": "Dominar os conceitos teóricos e pré-requisitos para aplicar os métodos de transformação.",
                                  "commonMistakes": "Confundir PDF com CDF; ignorar que normal não tem inversa fechada simples."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o Método da Inversa",
                                  "subSteps": [
                                    "Derive a fórmula para exponencial: X = -ln(1-U)/λ onde U ~ Uniform[0,1].",
                                    "Implemente em código: gere 1000 amostras e plote histograma.",
                                    "Para normal, use aproximação Box-Muller: gere pares (U1,U2) → X1 = sqrt(-2ln U1) cos(2π U2).",
                                    "Valide estatisticamente: calcule média e variância das amostras.",
                                    "Compare com funções built-in (numpy.random.exponential, normal) via QQ-plot."
                                  ],
                                  "verification": "Amostras geradas têm média ≈ 1/λ para exponencial e variância ≈ σ² para normal; QQ-plot linear.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python/Jupyter Notebook, bibliotecas NumPy/Matplotlib/SciPy.stats.",
                                  "tips": "Use seed para reprodutibilidade; normalize U para evitar log(0).",
                                  "learningObjective": "Aplicar inversa para distribuições com CDF invertível ou aproximável.",
                                  "commonMistakes": "Esquecer de subtrair U de 1 antes do log; usar seno em vez de cosseno em Box-Muller."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o Método Aceitação-Rejeição",
                                  "subSteps": [
                                    "Escolha envelope para exponencial: use uniforme majorante g(x)=1 para x em [0,1], ajuste c.",
                                    "Implemente algoritmo: gere U,V; aceite se V ≤ f(X)/ (c g(X)).",
                                    "Para normal, use envelope exponencial bilateral ou Cauchy.",
                                    "Gere 1000 amostras aceitas e meça taxa de aceitação (>20% ideal).",
                                    "Plote envelope vs pdf para visualizar eficiência."
                                  ],
                                  "verification": "Taxa de aceitação estável; histograma das amostras aceitas matches pdf alvo.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Jupyter Notebook, NumPy para geração e plots.",
                                  "tips": "Otimize c para eficiência; monitore loops para evitar ineficiência.",
                                  "learningObjective": "Gerar amostras de distribuições arbitrárias unimodais via rejeição.",
                                  "commonMistakes": "Calcular c incorretamente (sup(integral f/g)); gerar X fora do suporte."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar o Método da Convolução",
                                  "subSteps": [
                                    "Lembre que soma de k independentes exponenciais(λ) dá Erlang/Gamma(k,λ).",
                                    "Para normal, use convolução de duas normais ou soma de 12 uniformes (CLT aproximado).",
                                    "Implemente: gere k variáveis independentes via inversa e some.",
                                    "Gere amostras para Gamma(2,λ) como soma de 2 exponenciais; compare pdf.",
                                    "Teste variância soma = soma variâncias para independentes."
                                  ],
                                  "verification": "Amostras convolucionadas têm pdf resultante correta (ex: Gamma vs soma exponenciais).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python com SciPy para pdfs teóricas, NumPy para soma.",
                                  "tips": "Use fft para convolução eficiente em grandes k; verifique independência.",
                                  "learningObjective": "Gerar distribuições via soma de variáveis independentes.",
                                  "commonMistakes": "Assumir dependência nas somas; ignorar normalização da escala."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar e Validar Todos os Métodos",
                                  "subSteps": [
                                    "Crie função unificada que escolhe método baseado na distribuição.",
                                    "Gere 10k amostras para exponencial/normal com cada método.",
                                    "Execute testes KS ou chi-quadrado para aderência à distribuição teórica.",
                                    "Compare tempo computacional e eficiência entre métodos.",
                                    "Documente código com comentários e gere relatório de plots."
                                  ],
                                  "verification": "Todos testes estatísticos passam (p-value >0.05); eficiência ordem: inversa > rejeição > convolução.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Jupyter, SciPy.stats (kstest, chisquare), timer Python.",
                                  "tips": "Use vectorização NumPy para velocidade; armazene seeds para debug.",
                                  "learningObjective": "Comparar e aplicar métodos de forma integrada em simulações.",
                                  "commonMistakes": "Amostras insuficientes para testes; confundir normal com lognormal."
                                }
                              ],
                              "practicalExample": "Em uma simulação de filas (M/M/1), gere tempos de chegada exponenciais(λ=2) via inversa: X_i = -ln(1-U_i)/2 para 1000 clientes; plote interarrivals e verifique média ≈0.5.",
                              "finalVerifications": [
                                "Amostras de todos métodos têm média e variância dentro de 5% dos valores teóricos.",
                                "QQ-plots mostram linearidade para N=1000 amostras.",
                                "Teste KS rejeita H0 de não-uniformidade com p>0.01.",
                                "Taxa de aceitação >15% no método rejeição.",
                                "Tempo de geração <1s para 10k amostras por método.",
                                "Código roda sem erros e é reprodutível com seed."
                              ],
                              "assessmentCriteria": [
                                "Correção teórica das fórmulas e implementações (50%).",
                                "Qualidade dos plots e validações estatísticas (20%).",
                                "Eficiência computacional e escolha adequada de métodos (15%).",
                                "Clareza do código e documentação (10%).",
                                "Tratamento de edge cases (ex: U=0,1) (5%)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Testes de aderência (KS, chi2).",
                                "Programação: Algoritmos numéricos e vectorização.",
                                "Física: Simulações Monte Carlo em processos estocásticos.",
                                "Finanças: Modelagem de retornos lognormais via normal.",
                                "Ciência de Dados: Geração de dados sintéticos para ML."
                              ],
                              "realWorldApplication": "Em simulações de risco financeiro, gere retornos normais para Value-at-Risk; em epidemiologia, tempos exponenciais para contágio em modelos SIR; otimiza alocação de servidores via filas simuladas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.3.3",
                            "name": "Controlar sementes e streams",
                            "description": "Configurar múltiplos streams independentes para replicação e variância em experimentos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos de sementes e streams em geração de números aleatórios",
                                  "subSteps": [
                                    "Estude a diferença entre números pseudoaleatórios e verdadeiramente aleatórios.",
                                    "Aprenda que uma semente (seed) inicializa o gerador para reprodutibilidade.",
                                    "Entenda streams como sequências independentes de números aleatórios de um mesmo gerador.",
                                    "Explore por que múltiplos streams são úteis para variância controlada em experimentos.",
                                    "Revise exemplos de bibliotecas como NumPy RandomState ou Generator."
                                  ],
                                  "verification": "Resuma em suas palavras os conceitos e forneça um diagrama simples de streams.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação NumPy random, Jupyter Notebook",
                                  "tips": "Use analogias como 'semente de uma planta gera a mesma árvore' para fixar o conceito.",
                                  "learningObjective": "Diferenciar sementes e streams e justificar seu uso em simulações.",
                                  "commonMistakes": "Confundir semente com stream; assumir aleatoriedade verdadeira em computadores."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar sementes básicas para reprodutibilidade",
                                  "subSteps": [
                                    "Instale e importe NumPy.",
                                    "Gere números aleatórios sem semente e anote os resultados.",
                                    "Defina uma semente fixa com np.random.seed() e gere novamente para comparar.",
                                    "Teste múltiplas execuções com a mesma semente.",
                                    "Experimente diferentes valores de semente para variância."
                                  ],
                                  "verification": "Execute o código 3 vezes com a mesma semente e confirme resultados idênticos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python com NumPy, Jupyter Notebook",
                                  "tips": "Sempre anote o valor da semente nos experimentos para documentação.",
                                  "learningObjective": "Implementar sementes para garantir resultados reproduzíveis em simulações.",
                                  "commonMistakes": "Esquecer de importar random antes de usar seed; usar seed global em loops."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar múltiplos streams independentes",
                                  "subSteps": [
                                    "Crie geradores independentes usando np.random.default_rng(seed).",
                                    "Configure dois streams: um para chegadas (Poisson) e outro para serviços (Exponential).",
                                    "Gere sequências paralelas de números aleatórios de cada stream.",
                                    "Teste independência comparando distribuições.",
                                    "Salve estados dos streams para replicação futura."
                                  ],
                                  "verification": "Gere 1000 números de cada stream e confirme que histogramas são independentes.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com NumPy, código de exemplo de filas M/M/1",
                                  "tips": "Use um seed mestre e derive seeds filhos para streams relacionados.",
                                  "learningObjective": "Criar streams independentes para modelar múltiplas fontes de aleatoriedade.",
                                  "commonMistakes": "Reutilizar o mesmo gerador sem clonar, causando dependência."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar sementes e streams em experimentos de simulação",
                                  "subSteps": [
                                    "Defina um experimento: simule 10 réplicas de uma fila com streams fixos.",
                                    "Execute simulações variando sementes para medir variância.",
                                    "Calcule estatísticas como tempo médio na fila por réplica.",
                                    "Compare resultados com e sem controle de streams.",
                                    "Documente o setup para relatórios."
                                  ],
                                  "verification": "Produza um relatório com tabelas mostrando baixa variância intra-semente e variância inter-semente.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Código de simulação de filas, pandas para análise",
                                  "tips": "Automatize réplicas em um loop com seeds incrementais.",
                                  "learningObjective": "Usar sementes/streams para replicação confiável e análise de variância.",
                                  "commonMistakes": "Não resetar streams entre réplicas, levando a correlação artificial."
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila M/M/1: stream1 gera chegadas Poisson(λ=5), stream2 gera serviços Exp(μ=6). Com seed=42, réplicas produzem tempo médio na fila de 0.83 unidades; variando seed, média varia em ±0.05.",
                              "finalVerifications": [
                                "Código reproduz resultados idênticos com mesma semente/streams.",
                                "Streams independentes: correlação entre sequências < 0.01.",
                                "10 réplicas mostram variância controlada (CV < 10%).",
                                "Relatório inclui setup de sementes para replicabilidade.",
                                "Análise estatística confirma independência (teste KS).",
                                "Código comentado e modular para reutilização."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: explicação correta de sementes/streams (80%).",
                                "Implementação funcional: código roda sem erros e reproduz (90%).",
                                "Análise de variância: métricas calculadas corretamente (85%).",
                                "Documentação: setup claro e relatórios profissionais (75%).",
                                "Criatividade: extensão para cenários reais (extra).",
                                "Eficiência: tempos de execução otimizados."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: análise de variância em réplicas.",
                                "Programação: OOP com classes de geradores aleatórios.",
                                "Ciência de Dados: validação de simulações Monte Carlo.",
                                "Engenharia Industrial: modelagem de sistemas de filas."
                              ],
                              "realWorldApplication": "Em simulações de supply chain, streams controlam demandas e lead times independentes, permitindo análises de risco precisas e reprodutíveis para otimização de estoques em empresas como Amazon."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.3.4",
                        "name": "Coleta e Análise de Estatísticas",
                        "description": "Módulos automáticos para registrar métricas de desempenho e computar estatísticas de confiança durante a simulação.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.4.1",
                            "name": "Configurar contadores e acumuladores",
                            "description": "Definir variáveis para contar ocorrências, somar tempos e calcular médias em tempo de execução.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos de Contadores e Acumuladores",
                                  "subSteps": [
                                    "Identifique o que é um contador: uma variável que incrementa para registrar o número de ocorrências de um evento específico durante a simulação.",
                                    "Diferencie acumuladores de contadores: acumuladores somam valores contínuos, como tempos de espera ou custos.",
                                    "Revise exemplos básicos em linguagens de simulação como Simula ou GPSS para contextualizar o uso em sistemas discretos.",
                                    "Analise quando usar cada um: contadores para eventos discretos, acumuladores para métricas agregadas."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre contador e acumulador com um exemplo simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de linguagens de simulação (ex: manual do SimPy ou Arena)",
                                    "Notebook para anotações"
                                  ],
                                  "tips": [
                                    "Lembre-se: contadores começam em 0 e incrementam em 1; acumuladores somam valores variáveis."
                                  ],
                                  "learningObjective": "Compreender a função e distinção entre contadores e acumuladores em simulações discretas.",
                                  "commonMistakes": [
                                    "Confundir contadores com acumuladores, usando soma para contagem simples.",
                                    "Ignorar inicialização em zero."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar e Inicializar Variáveis",
                                  "subSteps": [
                                    "Escolha o tipo de variável apropriado: inteiro para contadores, float para acumuladores.",
                                    "Declare as variáveis no início do código de simulação, ex: counter = 0; accumulator = 0.0.",
                                    "Inicialize sempre em zero para evitar resultados enviesados.",
                                    "Nomeie variáveis de forma descritiva, como num_arrivals ou total_wait_time."
                                  ],
                                  "verification": "Mostre o código de declaração e inicialização compilando sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código (ex: VS Code com extensão Python)",
                                    "Ambiente de simulação como SimPy instalado"
                                  ],
                                  "tips": [
                                    "Use nomes camelCase ou snake_case consistentes com a linguagem.",
                                    "Inicialize fora do loop principal."
                                  ],
                                  "learningObjective": "Declarar corretamente variáveis para contadores e acumuladores com inicialização adequada.",
                                  "commonMistakes": [
                                    "Esquecer de inicializar, levando a valores garbage.",
                                    "Usar tipo errado, como string para números."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Atualizar Contadores e Acumuladores Durante a Execução",
                                  "subSteps": [
                                    "Identifique pontos de evento na simulação onde atualizar, ex: chegada de entidade incrementa contador.",
                                    "Implemente incrementos: counter += 1 para contadores; accumulator += valor para acumuladores.",
                                    "Garanta atomicidade em linguagens multi-threaded usando locks se necessário.",
                                    "Teste atualizações em um loop simulado simples."
                                  ],
                                  "verification": "Execute uma simulação curta e verifique se os valores mudam corretamente após eventos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código base de simulação simples",
                                    "Debugger do IDE"
                                  ],
                                  "tips": [
                                    "Atualize imediatamente após o evento para precisão temporal.",
                                    "Registre logs para depuração."
                                  ],
                                  "learningObjective": "Implementar atualizações precisas de contadores e acumuladores em resposta a eventos.",
                                  "commonMistakes": [
                                    "Atualizar fora do contexto do evento.",
                                    "Incrementar múltiplas vezes por evento acidentalmente."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular e Reportar Estatísticas Finais",
                                  "subSteps": [
                                    "Ao final da simulação, calcule médias: media = accumulator / counter se counter > 0.",
                                    "Reporte estatísticas em formato legível, ex: print(f'Média de tempo: {media}')",
                                    "Trate casos de divisão por zero com verificações condicionais.",
                                    "Valide cálculos com dados conhecidos."
                                  ],
                                  "verification": "Compare resultados calculados com valores esperados manualmente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código completo da simulação",
                                    "Planilha para validação manual"
                                  ],
                                  "tips": [
                                    "Sempre verifique counter > 0 antes de dividir.",
                                    "Arredonde resultados para precisão desejada."
                                  ],
                                  "learningObjective": "Calcular estatísticas derivadas como médias usando contadores e acumuladores.",
                                  "commonMistakes": [
                                    "Dividir por zero causando erros.",
                                    "Esquecer de reportar ou formatar saídas."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado usando SimPy: declare counter_checkout = 0 e accumulator_time = 0.0. A cada checkout, counter_checkout += 1 e accumulator_time += tempo_espera. Ao final, calcule média de tempo por cliente: accumulator_time / counter_checkout.",
                              "finalVerifications": [
                                "O contador foi inicializado em 0 e incrementado corretamente por evento.",
                                "O acumulador somou valores reais sem overflow.",
                                "Média calculada é precisa e sem divisão por zero.",
                                "Código executa sem erros em simulação completa."
                              ],
                              "assessmentCriteria": [
                                "Precisão na declaração e inicialização (30%)",
                                "Correção nas atualizações durante execução (30%)",
                                "Validade dos cálculos finais (20%)",
                                "Clareza no código e relatórios (10%)",
                                "Tratamento de edge cases (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Estruturas de controle e variáveis em Python/Java.",
                                "Estatística: Cálculo de médias e análise de dados.",
                                "Matemática: Operações aritméticas e condicionais.",
                                "Engenharia de Software: Depuração e validação de simulações."
                              ],
                              "realWorldApplication": "Em simulações de tráfego para otimizar semáforos (contar veículos, acumular atrasos), ou em call centers para medir tempo médio de espera e número de chamadas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.4.2",
                            "name": "Implementar coleta de estatísticas de filas",
                            "description": "Registrar tempo total no sistema, comprimento médio de fila e utilização de servidores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir e Inicializar Variáveis de Estatísticas de Filas",
                                  "subSteps": [
                                    "Identifique as métricas principais: tempo total no sistema (W), comprimento médio de fila (Lq), e utilização de servidores (U).",
                                    "Declare variáveis acumuladoras: total_tempo_sistema, total_comprimento_fila_tempo, tempo_servico_total, num_chegadas, num_saidas, tempo_simulacao_inicial.",
                                    "Inicialize todas as variáveis para zero no início da simulação.",
                                    "Defina estruturas para rastrear entidades individuais se necessário (ex: tempo_entrada_fila, tempo_entrada_servidor).",
                                    "Configure relógio de simulação e duração total da simulação."
                                  ],
                                  "verification": "Execute um teste simples com zero eventos e confirme que todas as variáveis estão zeradas via print ou debug.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação da linguagem de simulação (ex: SimPy, DESMO-J)",
                                    "Editor de código (VS Code, PyCharm)",
                                    "Pseudocódigo de modelo de fila M/M/1"
                                  ],
                                  "tips": "Use nomes de variáveis descritivos como 'sum_queue_length_over_time' para facilitar depuração.",
                                  "learningObjective": "Compreender as variáveis essenciais para coletar estatísticas básicas de filas em simulações discretas.",
                                  "commonMistakes": [
                                    "Esquecer de inicializar variáveis, levando a resultados incorretos.",
                                    "Confundir tempo no sistema com tempo na fila.",
                                    "Não considerar tempo zero para filas vazias."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Instrumentar Eventos de Chegada à Fila",
                                  "subSteps": [
                                    "No evento de chegada: registre o tempo atual como tempo_entrada_fila para a entidade.",
                                    "Incremente contador de chegadas (num_chegadas += 1).",
                                    "Atualize acumulador de comprimento de fila: some o comprimento atual da fila multiplicado pelo intervalo de tempo desde última atualização.",
                                    "Se fila estava vazia, agende início de serviço.",
                                    "Atualize último_tempo_atualizacao para tempo atual."
                                  ],
                                  "verification": "Simule 5 chegadas sem saídas e verifique se num_chegadas == 5 e acumuladores de fila aumentaram corretamente.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Exemplos de código de eventos de chegada em simulação",
                                    "Debugger integrado no IDE",
                                    "Planilha para validar cálculos manuais"
                                  ],
                                  "tips": "Sempre atualize o 'last_update_time' após cada mudança no comprimento da fila para precisão na integral de Little's Law.",
                                  "learningObjective": "Implementar corretamente a coleta de dados em eventos de chegada para métricas de fila.",
                                  "commonMistakes": [
                                    "Não atualizar o acumulador de comprimento_fila_tempo no momento exato da chegada.",
                                    "Incrementar contadores errados (ex: saídas em chegadas).",
                                    "Ignorar filas vazias antes da chegada."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Instrumentar Eventos de Saída e Serviço",
                                  "subSteps": [
                                    "No evento de fim de serviço: calcule tempo no sistema (tempo_atual - tempo_entrada_fila) e some a total_tempo_sistema.",
                                    "Atualize tempo_servico_total com duração do serviço.",
                                    "Atualize acumulador de comprimento de fila considerando redução no comprimento.",
                                    "Incremente num_saidas e, se fila não vazia, agende próximo serviço.",
                                    "Atualize last_update_time."
                                  ],
                                  "verification": "Simule um ciclo completo (chegada + serviço) para 10 entidades e confira se total_tempo_sistema soma corretamente os tempos individuais.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código base de modelo de fila simples",
                                    "Ferramentas de profiling para medir utilização",
                                    "Calculadora para validação manual de médias"
                                  ],
                                  "tips": "Diferencie tempo na fila (espera) de tempo no sistema (fila + serviço) para evitar confusão em relatórios.",
                                  "learningObjective": "Capturar estatísticas de saídas e utilização de servidores com precisão em simulações de eventos discretos.",
                                  "commonMistakes": [
                                    "Calcular tempo no sistema apenas como tempo de serviço, ignorando espera.",
                                    "Não decrementar comprimento da fila em saídas.",
                                    "Atualizar utilização sem dividir por tempo total de simulação."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular e Reportar Estatísticas Finais",
                                  "subSteps": [
                                    "Ao final da simulação: calcule Lq = total_comprimento_fila_tempo / tempo_simulacao_total.",
                                    "Calcule W médio = total_tempo_sistema / num_saidas.",
                                    "Calcule U = tempo_servico_total / tempo_simulacao_total.",
                                    "Imprima ou exporte as estatísticas com formatação clara (ex: médias, intervalos de confiança se aplicável).",
                                    "Valide contra teoremas como Little's Law (Lq ≈ λ * W, onde λ é taxa de chegada)."
                                  ],
                                  "verification": "Execute simulação completa com input conhecido (ex: M/M/1 com ρ=0.8) e compare resultados com fórmulas analíticas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Fórmulas analíticas de filas (Wikipedia M/M/1)",
                                    "Bibliotecas de plotagem (Matplotlib) para gráficos de estatísticas",
                                    "Script de teste unitário"
                                  ],
                                  "tips": "Adicione logs intermediários durante desenvolvimento, mas remova para performance em simulações longas.",
                                  "learningObjective": "Finalizar a coleta computando e validando métricas agregadas de forma confiável.",
                                  "commonMistakes": [
                                    "Dividir por num_chegadas em vez de num_saidas para médias.",
                                    "Esquecer de normalizar por tempo total na utilização.",
                                    "Não tratar simulações com zero saídas (divisão por zero)."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de caixa de supermercado usando SimPy: para 100 clientes chegando a cada 5-10 min com serviço de 7 min em média, colete e reporte W=12.5 min, Lq=2.1 clientes, U=0.85 após 8 horas de simulação.",
                              "finalVerifications": [
                                "Estatísticas calculadas coincidem com validação manual para 10 entidades teste.",
                                "Little's Law é aproximadamente satisfeita (Lq ≈ taxa_chegada * W).",
                                "Utilização U está entre 0 e 1 para cenários realistas.",
                                "Nenhum erro de divisão por zero em simulações vazias.",
                                "Relatório final imprime todas as três métricas com precisão de 2 casas decimais.",
                                "Código roda sem crashes em simulações de 1000+ eventos."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos cálculos de W, Lq e U (erro <1% vs. analítico).",
                                "Eficiência: overhead de coleta <5% do tempo de simulação.",
                                "Robustez: lida com filas vazias, chegadas sem saídas e vice-versa.",
                                "Clareza do código: comentários em pontos de atualização de estatísticas.",
                                "Modularidade: funções separadas para chegada, saída e relatório.",
                                "Validação integrada: testes unitários para cada métrica."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: cálculo de médias, somas acumuladas e lei de Little.",
                                "Programação: manipulação de eventos assíncronos e estruturas de dados (filas).",
                                "Modelagem de Sistemas: aplicação da teoria de filas (M/M/1, M/G/1).",
                                "Ciência de Dados: coleta e agregação de métricas em simulações.",
                                "Engenharia de Software: instrumentação e logging em código."
                              ],
                              "realWorldApplication": "Otimizar operações em call centers (reduzir tempo de espera), aeroportos (gerenciar filas de check-in), ou fábricas (balancear linhas de produção), usando simulações para testar cenários antes de mudanças reais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.4.3",
                            "name": "Gerar intervalos de confiança",
                            "description": "Usar métodos de batch means ou regenerativos para estimar erros padrão e limites de confiança.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos de intervalos de confiança em simulações",
                                  "subSteps": [
                                    "Estudar a definição de intervalo de confiança (IC) e sua importância em simulações estocásticas para estimar parâmetros populacionais como média e variância.",
                                    "Revisar conceitos de erro padrão e distribuição normal aproximada pela Lei dos Grandes Números e Teorema Central do Limite.",
                                    "Explorar por que métodos como batch means e regenerativos são necessários em simulações de sistemas discretos com dependências.",
                                    "Analisar fórmulas básicas: IC = média ± z * (erro padrão / sqrt(n)), onde z é o quantil normal.",
                                    "Discutir autocorrelação em saídas de simulação e seu impacto na estimativa de variância."
                                  ],
                                  "verification": "Resumir em um parágrafo os conceitos chave e resolver um exercício simples de IC clássico.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Simulação (ex: Banks et al.), notas de aula sobre Estatística, calculadora ou Python/Jupyter para exemplos rápidos"
                                  ],
                                  "tips": "Use diagramas para visualizar dependências em séries temporais de simulação.",
                                  "learningObjective": "Entender a base teórica para estimar incertezas em simulações.",
                                  "commonMistakes": "Ignorar autocorrelação, tratando amostras como independentes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o método de Batch Means",
                                  "subSteps": [
                                    "Dividir a saída da simulação em k batches de tamanho m, garantindo independência aproximada.",
                                    "Calcular a média e variância de cada batch.",
                                    "Estimar a média geral como média das médias de batch e o erro padrão como sqrt(variância entre batches / k).",
                                    "Determinar o número de batches necessário para independência (ex: teste de Welch).",
                                    "Construir o IC usando distribuição t de Student para k pequeno."
                                  ],
                                  "verification": "Gerar batches de uma simulação simples e calcular IC manualmente, comparando com software.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software de simulação (ex: Python com SimPy ou R), planilha Excel para cálculos iniciais, código exemplo de batch means"
                                  ],
                                  "tips": "Escolha tamanho de batch para que correlação dentro do batch seja alta, mas entre batches baixa.",
                                  "learningObjective": "Dominar o cálculo de IC via batch means para saídas dependentes.",
                                  "commonMistakes": "Usar batches muito pequenos, levando a variância subestimada."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o método regenerativo",
                                  "subSteps": [
                                    "Identificar pontos de regeneração em cadeias de Markov, onde o processo reinicia independentemente.",
                                    "Coletar ciclos entre pontos de regeneração e calcular médias por ciclo.",
                                    "Estimar média geral e variância como variância das médias de ciclo dividida pelo número de ciclos.",
                                    "Construir IC usando distribuição normal ou t para poucos ciclos.",
                                    "Comparar com batch means em termos de eficiência."
                                  ],
                                  "verification": "Simular um processo com regenerações (ex: fila com reset) e validar IC.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código Python/R para detecção de regenerações, simulador de sistemas discretos"
                                  ],
                                  "tips": "Use algoritmo de Lewis para estimar pontos de regeneração automaticamente.",
                                  "learningObjective": "Aplicar método regenerativo para simulações com estrutura de Markov.",
                                  "commonMistakes": "Não detectar corretamente pontos de regeneração, invalidando independência."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Gerar, interpretar e validar intervalos de confiança",
                                  "subSteps": [
                                    "Executar simulação longa, aplicar ambos métodos e comparar ICs.",
                                    "Interpretar largura do IC como medida de precisão e decidir run length.",
                                    "Validar com simulações múltiplas (replicatas) para checar cobertura do IC.",
                                    "Automatizar em código para relatar IC com nível de confiança desejado (ex: 95%).",
                                    "Documentar relatório com gráficos de evolução do IC."
                                  ],
                                  "verification": "Produzir um relatório com ICs de uma simulação real e discutir precisão alcançada.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Jupyter Notebook, bibliotecas como numpy, matplotlib, simpy"
                                  ],
                                  "tips": "Monitore convergência plotando IC vs. tempo de simulação.",
                                  "learningObjective": "Integrar métodos para gerar ICs confiáveis e acionáveis.",
                                  "commonMistakes": "Parar simulação prematuramente sem verificar estabilidade do IC."
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila M/M/1 com taxa de chegada 4/h e serviço 5/h, rode 10.000 chegadas, aplique batch means com 50 batches para estimar tempo médio no sistema: média ≈ 1.25h, erro padrão 0.05, IC 95% [1.15, 1.35]. Compare com método regenerativo usando resets após serviço idle.",
                              "finalVerifications": [
                                "Calcular corretamente erro padrão via batch means para dados simulados.",
                                "Identificar pontos regenerativos em uma cadeia de Markov simples.",
                                "Construir IC ao 95% com ambos métodos e interpretar largura.",
                                "Validar cobertura do IC com 20 replicatas independentes.",
                                "Automatizar código para output de IC em simulação de fila.",
                                "Comparar eficiência de métodos em relatório curto."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de médias e variâncias de batches/ciclos (erro <5%).",
                                "Correta detecção de independência e escolha de parâmetros (k ou ciclos).",
                                "Interpretação adequada da confiança e precisão do IC.",
                                "Implementação limpa e eficiente em código (sem bugs lógicos).",
                                "Uso apropriado de testes estatísticos para validação.",
                                "Relatório claro com gráficos e conclusões acionáveis."
                              ],
                              "crossCurricularConnections": [
                                "Estatística Inferencial: Teorema Central do Limite e testes de hipóteses.",
                                "Programação Computacional: Implementação em Python/R para simulações.",
                                "Análise de Sistemas: Modelagem de filas e processos estocásticos.",
                                "Probabilidade: Cadeias de Markov e processos regenerativos."
                              ],
                              "realWorldApplication": "Em simulações de Monte Carlo para previsão de riscos financeiros (ex: VaR em bancos), manufatura (otimização de linhas de produção) ou logística (planejamento de estoques), onde ICs quantificam incerteza em estimativas de throughput ou tempo médio, auxiliando decisões robustas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.4",
                    "name": "Critérios de Avaliação de Software de Simulação",
                    "description": "Fatores como facilidade de uso, flexibilidade, eficiência computacional e suporte a validação.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.4.1",
                        "name": "Facilidade de Uso",
                        "description": "Critério que avalia a intuitividade da interface gráfica, a qualidade da documentação, tutoriais disponíveis e a curva de aprendizado do software de simulação, permitindo que usuários inexperientes ou experientes o adotem rapidamente sem frustrações excessivas.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.1.1",
                            "name": "Identificar métricas de usabilidade em interfaces de software de simulação",
                            "description": "Analisar elementos como navegação intuitiva, feedback visual imediato, atalhos de teclado e acessibilidade para avaliar quão amigável é a interface para modelagem e execução de simulações discretas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos fundamentais de usabilidade em interfaces de software",
                                  "subSteps": [
                                    "Defina usabilidade segundo normas como ISO 9241-11 (eficácia, eficiência e satisfação).",
                                    "Liste métricas gerais: tempo para completar tarefas, taxa de erros, satisfação do usuário via SUS (System Usability Scale).",
                                    "Relacione usabilidade com simulações discretas: modelagem rápida e execução sem frustrações.",
                                    "Identifique componentes chave de interfaces: menus, toolbars, painéis de simulação.",
                                    "Pesquise exemplos de interfaces ruins vs. boas em softwares como NetLogo ou AnyLogic."
                                  ],
                                  "verification": "Crie um glossário com 5 definições chave e 3 exemplos de métricas gerais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação ISO 9241-11 (online)",
                                    "Vídeos tutoriais sobre SUS no YouTube",
                                    "NetLogo download gratuito"
                                  ],
                                  "tips": "Use mind maps para conectar conceitos gerais a simulações específicas.",
                                  "learningObjective": "Entender os pilares da usabilidade e sua relevância para software de simulação.",
                                  "commonMistakes": [
                                    "Confundir usabilidade com desempenho computacional",
                                    "Ignorar satisfação subjetiva do usuário"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar métricas específicas de usabilidade para interfaces de simulação",
                                  "subSteps": [
                                    "Analise navegação intuitiva: tempo para acessar modelo de simulação discreta, hierarquia de menus clara.",
                                    "Avalie feedback visual imediato: cores para estados (parado/executando), tooltips em simulações.",
                                    "Examine atalhos de teclado: comandos para play/pause, zoom em grids discretos.",
                                    "Verifique acessibilidade: suporte a screen readers, contraste WCAG, teclado-only navigation.",
                                    "Compile uma checklist com 8-10 métricas adaptadas para simulações discretas (e.g., tempo para setup de eventos)."
                                  ],
                                  "verification": "Desenvolva uma tabela com 4 métricas principais, descrições e exemplos para simulações.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "WCAG guidelines (w3.org)",
                                    "Checklist de usabilidade de Nielsen",
                                    "Documentação de NetLogo/AnyLogic"
                                  ],
                                  "tips": "Priorize métricas quantificáveis como 'tempo < 10s para iniciar simulação'.",
                                  "learningObjective": "Dominar métricas chave: navegação, feedback, atalhos e acessibilidade em contextos de simulação.",
                                  "commonMistakes": [
                                    "Focar só em visual sem testar interatividade",
                                    "Esquecer métricas para simulações discretas como eventos em filas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar métricas em uma interface real de software de simulação",
                                  "subSteps": [
                                    "Baixe e instale NetLogo; abra um modelo de fila discreta (e.g., Single Server Queue).",
                                    "Meça navegação: cronometre setup de parâmetros iniciais.",
                                    "Teste feedback: execute simulação e note respostas visuais a inputs.",
                                    "Verifique atalhos: liste e teste 5 atalhos disponíveis.",
                                    "Avalie acessibilidade: use ferramentas como WAVE ou NVDA para checar conformidade."
                                  ],
                                  "verification": "Registre pontuações numéricas para cada métrica em um relatório de 1 página.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "NetLogo (netlogo.org)",
                                    "Ferramentas de acessibilidade: WAVE (wave.webaim.org), NVDA screen reader"
                                  ],
                                  "tips": "Grave a tela para revisar testes e medir tempos exatos.",
                                  "learningObjective": "Praticar identificação prática de métricas em software real.",
                                  "commonMistakes": [
                                    "Testar só uma vez sem repetições",
                                    "Ignorar contexto de simulações discretas como eventos aleatórios"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar achados e criar plano de melhoria",
                                  "subSteps": [
                                    "Calcule scores agregados (e.g., média de tempos, % de acessibilidade).",
                                    "Compare com benchmarks: usabilidade boa se >80% SUS.",
                                    "Identifique gaps: e.g., falta de atalhos para reset de simulação.",
                                    "Proponha melhorias: adicionar feedback sonoro para acessibilidade.",
                                    "Documente em template: métricas, scores, recomendações."
                                  ],
                                  "verification": "Produza um relatório final com scores e 3 sugestões acionáveis.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Google Sheets para cálculos",
                                    "Template de relatório usabilidade (online)"
                                  ],
                                  "tips": "Use gráficos para visualizar scores por métrica.",
                                  "learningObjective": "Interpretar dados de usabilidade e propor enhancements para interfaces de simulação.",
                                  "commonMistakes": [
                                    "Não quantificar subjetivo",
                                    "Sugestões vagas sem métricas de impacto"
                                  ]
                                }
                              ],
                              "practicalExample": "Em NetLogo, para um modelo de simulação discreta de filas (Single Server Queue), meça: navegação (tempo para setar arrival rate <5s), feedback (barras coloridas atualizam em <1s), atalhos (Ctrl+R para run), acessibilidade (contraste AA-compliant). Score final: 85/100.",
                              "finalVerifications": [
                                "Lista corretamente 4 métricas principais com exemplos para simulações discretas.",
                                "Avalia uma interface real com scores quantificáveis.",
                                "Identifica pelo menos 2 gaps e propõe melhorias específicas.",
                                "Explica conexão entre usabilidade e eficiência em modelagem discreta.",
                                "Aplica checklist WCAG básica a uma interface."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de métricas (80% cobertura das 4 principais).",
                                "Qualidade dos testes práticos (tempos medidos, repetições).",
                                "Profundidade da análise (quantitativa + qualitativa).",
                                "Relevância das sugestões de melhoria para simulações.",
                                "Clareza e estrutura do relatório final.",
                                "Integração de acessibilidade e atalhos em avaliações."
                              ],
                              "crossCurricularConnections": [
                                "Design de UI/UX (engenharia de software).",
                                "Programação de interfaces (desenvolvimento web/mobile).",
                                "Estatística (medição de tempos e erros em simulações).",
                                "Inclusão digital (educação especial e acessibilidade).",
                                "Gestão de projetos (avaliação de ferramentas em equipes)."
                              ],
                              "realWorldApplication": "Desenvolvedores de software como AnyLogic usam essas métricas para refinar interfaces, reduzindo tempo de treinamento de usuários em indústrias como logística (simulações de filas) e manufatura, melhorando produtividade em 20-30%."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.1.2",
                            "name": "Avaliar a qualidade da documentação e recursos de suporte",
                            "description": "Examinar manuais, exemplos práticos, vídeos tutoriais e fóruns de comunidade para determinar se o software fornece orientação clara e completa para implementação de modelos de simulação de sistemas discretos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Coletar e acessar os recursos de documentação disponíveis",
                                  "subSteps": [
                                    "Acessar o site oficial do software de simulação",
                                    "Baixar ou visualizar manuais do usuário, guias de referência e documentação técnica",
                                    "Localizar seções de tutoriais, exemplos práticos e vídeos oficiais",
                                    "Identificar links para fóruns de comunidade, Stack Overflow ou repositórios GitHub relacionados",
                                    "Criar uma lista organizada de todos os recursos encontrados, categorizando por tipo"
                                  ],
                                  "verification": "Lista completa e categorizada de recursos acessíveis e salvos localmente",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Computador com internet",
                                    "Site oficial do software",
                                    "Bloco de notas ou planilha para registro"
                                  ],
                                  "tips": "Use a função de busca do site para termos como 'simulação discreta' ou 'eventos discretos'",
                                  "learningObjective": "Identificar e organizar todos os materiais de suporte disponíveis para avaliação",
                                  "commonMistakes": "Ignorar recursos em versões beta ou idiomas não nativos sem tradução automática"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Avaliar a qualidade dos manuais e guias escritos",
                                  "subSteps": [
                                    "Ler a tabela de conteúdos e índice para verificar cobertura de simulações discretas",
                                    "Analisar clareza da linguagem, uso de diagramas e estrutura lógica",
                                    "Verificar se há seções dedicadas a instalação, configuração e implementação de modelos",
                                    "Avaliar profundidade: presença de explicações passo a passo para cenários comuns",
                                    "Pontuar em uma escala de 1-10 aspectos como completude, precisão e acessibilidade"
                                  ],
                                  "verification": "Relatório com pontuações e notas sobre forças e fraquezas dos manuais",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Manuais baixados",
                                    "Planilha de avaliação (Google Sheets ou Excel)"
                                  ],
                                  "tips": "Leia amostras de seções relevantes antes de mergulhar em tudo",
                                  "learningObjective": "Determinar se os manuais fornecem orientação clara e completa para implementação",
                                  "commonMistakes": "Focar apenas no comprimento sem avaliar a usabilidade prática"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Examinar exemplos práticos, tutoriais e vídeos",
                                  "subSteps": [
                                    "Executar ou simular um exemplo prático de simulação discreta fornecido",
                                    "Verificar se os tutoriais cobrem desde conceitos básicos até aplicações avançadas",
                                    "Assistir vídeos tutoriais e anotar tempo de duração, qualidade visual e explicações",
                                    "Testar se os exemplos são reproduzíveis e adaptáveis a cenários personalizados",
                                    "Avaliar se há códigos-fonte ou arquivos de modelo disponíveis para download"
                                  ],
                                  "verification": "Resumo com testes realizados e resultados de reproduzibilidade dos exemplos",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software instalado",
                                    "Vídeos e exemplos baixados",
                                    "Ambiente de teste"
                                  ],
                                  "tips": "Cronometre o tempo para completar um tutorial para medir eficiência",
                                  "learningObjective": "Verificar a efetividade prática dos recursos visuais e hands-on",
                                  "commonMistakes": "Não testar os exemplos em um ambiente real, apenas ler"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar fóruns de comunidade e suporte",
                                  "subSteps": [
                                    "Pesquisar tópicos relacionados a simulações discretas nos fóruns oficiais",
                                    "Avaliar atividade da comunidade: número de usuários, respostas rápidas e qualidade",
                                    "Verificar presença de FAQs, wikis comunitárias e suporte técnico pago",
                                    "Analisar exemplos de problemas resolvidos e tempo médio de resposta",
                                    "Pontuar responsividade e utilidade das discussões para iniciantes e avançados"
                                  ],
                                  "verification": "Relatório de buscas com exemplos de threads analisadas e métricas de suporte",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Acesso aos fóruns",
                                    "Conta de usuário se necessário"
                                  ],
                                  "tips": "Use palavras-chave específicas como 'erro em eventos discretos' para testes realistas",
                                  "learningObjective": "Avaliar o ecossistema de suporte comunitário para resolução de dúvidas",
                                  "commonMistakes": "Considerar apenas fóruns oficiais, ignorando Reddit ou Discord"
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar a avaliação geral e formular conclusões",
                                  "subSteps": [
                                    "Compilar pontuações de todos os recursos em uma métrica agregada",
                                    "Identificar gaps: tópicos de simulação discreta não cobertos adequadamente",
                                    "Comparar com critérios ideais de documentação (clareza, completude, atualidade)",
                                    "Redigir um relatório final com recomendação de uso do software",
                                    "Sugerir melhorias ou alternativas baseadas na avaliação"
                                  ],
                                  "verification": "Relatório final escrito com conclusão clara sobre a qualidade geral",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Planilhas e notas anteriores",
                                    "Editor de texto"
                                  ],
                                  "tips": "Use uma rubrica padronizada para objetividade",
                                  "learningObjective": "Integrar todas as avaliações em uma recomendação acionável",
                                  "commonMistakes": "Ser muito subjetivo sem base em evidências coletadas"
                                }
                              ],
                              "practicalExample": "Ao avaliar o software AnyLogic para simulação de sistemas de filas discretas (ex: modelagem de um call center), colete o manual PDF (200+ páginas com capítulos sobre 'Discrete Event Simulation'), execute o tutorial de vídeo 'Bank Office Example' (15 min, com arquivos .alp baixáveis), e busque no fórum oficial por 'DEVS implementation issues' (100+ threads ativas com respostas em <24h). Conclua que a documentação é excelente (9/10) pela completude, mas vídeos poderiam ter legendas em PT-BR.",
                              "finalVerifications": [
                                "Documentação cobre 100% dos tópicos essenciais de simulações discretas?",
                                "Exemplos práticos são reproduzíveis em <30 minutos?",
                                "Vídeos tutoriais têm qualidade HD e narração clara?",
                                "Fóruns têm >80% de respostas úteis em problemas comuns?",
                                "Recursos estão atualizados para a versão mais recente do software?",
                                "Há suporte multilíngue ou traduções disponíveis?"
                              ],
                              "assessmentCriteria": [
                                "Completude: Cobertura exaustiva de implementação de modelos discretos (30%)",
                                "Clareza: Linguagem acessível, diagramas e estrutura lógica (25%)",
                                "Praticidade: Exemplos hands-on e tutoriais passo a passo (20%)",
                                "Atualidade: Datas de atualização recentes e relevância (15%)",
                                "Suporte comunitário: Atividade e qualidade das respostas (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Linguagens de Programação: Leitura e interpretação de documentação técnica similar a APIs",
                                "Comunicação e Redação: Análise de materiais instrucionais e relatórios claros",
                                "Pesquisa e Informação: Habilidades de busca avançada e avaliação de fontes online",
                                "Gestão de Projetos: Avaliação de recursos para eficiência em desenvolvimento de software"
                              ],
                              "realWorldApplication": "Em indústrias como manufatura ou logística, engenheiros avaliam documentação de softwares como FlexSim para implementar simulações de linhas de produção discretas, evitando erros caros e acelerando o deployment de modelos que otimizam fluxos reais, economizando tempo e recursos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.1.3",
                            "name": "Comparar curvas de aprendizado entre diferentes softwares",
                            "description": "Realizar testes práticos para medir o tempo necessário para criar e executar um modelo simples de simulação discreta, identificando barreiras iniciais e progressão para tarefas complexas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e Configurar Softwares para Teste",
                                  "subSteps": [
                                    "Pesquise e liste 3-5 softwares de simulação discreta (ex: Arena, AnyLogic, SimPy em Python).",
                                    "Instale ou acesse versões trial/demos dos softwares selecionados.",
                                    "Crie contas de usuário se necessário e familiarize-se com a interface inicial sem executar simulações.",
                                    "Defina métricas padronizadas: tempo para login, criar modelo simples, executar e visualizar resultados.",
                                    "Prepare um modelo simples de referência: fila única M/M/1 com chegada Poisson e serviço exponencial."
                                  ],
                                  "verification": "Lista de softwares instalados com screenshots das interfaces iniciais e modelo de referência documentado.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": "Computador com internet, licenças trial de Arena/AnyLogic/SimPy, bloco de notas para documentação.",
                                  "tips": "Escolha softwares com curvas conhecidas: proprietários vs open-source para contraste claro.",
                                  "learningObjective": "Identificar e preparar ferramentas para medição objetiva de usabilidade inicial.",
                                  "commonMistakes": "Selecionar softwares incompatíveis com o hardware ou ignorar requisitos de sistema."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Medir Tempos para Tarefas Simples",
                                  "subSteps": [
                                    "Registre tempo desde abertura do software até criação completa do modelo M/M/1 simples.",
                                    "Meça tempo para configurar parâmetros (taxa de chegada λ=5, serviço μ=6) e executar simulação de 1000 runs.",
                                    "Anote tempo para gerar relatório básico de métricas (tempo médio na fila, utilização).",
                                    "Repita o teste 3 vezes por software para calcular média e desvio padrão.",
                                    "Documente barreiras: tutoriais necessários, erros de sintaxe ou interface confusa."
                                  ],
                                  "verification": "Tabela com tempos médios, desvios e anotações de barreiras para cada software.",
                                  "estimatedTime": "4-6 horas",
                                  "materials": "Cronômetro preciso (app ou relógio), planilha Excel/Google Sheets para dados.",
                                  "tips": "Use o mesmo computador e condições para todos os testes evitando fadiga como variável.",
                                  "learningObjective": "Quantificar barreiras iniciais e eficiência para tarefas básicas.",
                                  "commonMistakes": "Não repetir testes ou ignorar tempo gasto em resolução de erros iniciais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar Progressão para Tarefas Complexas",
                                  "subSteps": [
                                    "Após prática inicial, avance para modelo complexo: rede de filas com 3 estações e prioridades.",
                                    "Meça tempo para adicionar lógica de roteamento, prioridades e animação/visualização avançada.",
                                    "Execute simulação longa (10.000 runs) e gere gráficos de curvas de aprendizado cumulativas.",
                                    "Registre redução percentual no tempo entre primeira e terceira execução por tarefa.",
                                    "Identifique pontos de platô onde complexidade não aumenta tempo proporcionalmente."
                                  ],
                                  "verification": "Gráficos de tempo vs. tarefa complexidade para cada software, com curvas suavizadas.",
                                  "estimatedTime": "5-7 horas",
                                  "materials": "Softwares instalados, planilhas avançadas com gráficos (Excel ou Python Matplotlib).",
                                  "tips": "Pratique uma vez extra antes de medir para simular 'curva real' de aprendizado.",
                                  "learningObjective": "Mapear progressão de eficiência à medida que a complexidade aumenta.",
                                  "commonMistakes": "Pular prática inicial, levando a tempos inflados por inexperiência persistente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e Comparar Curvas de Aprendizado",
                                  "subSteps": [
                                    "Plote curvas de aprendizado: eixo X=tarefas (simples a complexa), Y=tempo médio por tarefa.",
                                    "Calcule inclinação inicial (barreiras) e assintótica (eficiência máxima) para cada software.",
                                    "Compare qualitativamente: intuitividade de drag-and-drop vs. código manual.",
                                    "Gere relatório com ranking e recomendações baseadas em cenários (iniciante vs. expert).",
                                    "Valide com literatura ou benchmarks online para curvas conhecidas."
                                  ],
                                  "verification": "Relatório final com gráficos comparativos, tabelas de métricas e conclusões.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": "Ferramentas de plotagem (Excel, Python Seaborn), templates de relatório.",
                                  "tips": "Use log-scale no eixo Y para visualizar melhor diferenças em tempos extremos.",
                                  "learningObjective": "Sintetizar dados em insights acionáveis sobre usabilidade relativa.",
                                  "commonMistakes": "Comparar apenas tempos absolutos sem normalizar por features equivalentes."
                                }
                              ],
                              "practicalExample": "Compare Arena e AnyLogic simulando uma linha de produção com 3 máquinas e filas intermediárias: meça tempo para setup inicial (simples: 1 fila) vs. full modelo (complexo: prioridades e breakdowns), plotando curvas mostrando Arena mais rápida para iniciantes devido a drag-and-drop.",
                              "finalVerifications": [
                                "Curvas de aprendizado plotadas para todos softwares com pelo menos 3 pontos de dados.",
                                "Métricas calculadas: tempo médio, desvio, inclinação inicial e platô.",
                                "Relatório documenta barreiras específicas (ex: 'AnyLogic requer Java setup').",
                                "Comparação inclui pelo menos 2 cenários: iniciante e avançado.",
                                "Gráficos legíveis com legendas e escalas apropriadas.",
                                "Recomendações justificadas por dados quantitativos."
                              ],
                              "assessmentCriteria": [
                                "Precisão das medições (repetições ≥3, desvio <20%).",
                                "Profundidade da análise (inclinação, platôs identificados).",
                                "Objetividade na comparação (dados vs. opiniões).",
                                "Qualidade visual dos gráficos e relatórios.",
                                "Cobertura de barreiras qualitativas e quantitativas.",
                                "Validação cruzada com fontes externas."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Cálculo de médias, desvios e regressão linear para curvas.",
                                "Programação: Uso de scripts em SimPy para automação de testes.",
                                "Design de UX/UI: Análise de interfaces intuitivas.",
                                "Gestão de Projetos: Estimativa de ramp-up time para equipes."
                              ],
                              "realWorldApplication": "Em indústrias de manufatura ou logística, comparar curvas ajuda a selecionar software que minimiza tempo de treinamento de analistas, reduzindo custos em projetos de otimização de supply chain."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.4.2",
                        "name": "Flexibilidade",
                        "description": "Capacidade do software de suportar uma ampla gama de modelos de simulação, incluindo adaptações personalizadas, integração com outras ferramentas e extensibilidade para cenários não padronizados em sistemas discretos.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.2.1",
                            "name": "Verificar suporte a diferentes paradigmas de modelagem",
                            "description": "Avaliar se o software permite modelagem de eventos discretos, híbrida ou contínua, com opções para alternar entre abordagens sem necessidade de reescrita completa do modelo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os paradigmas de modelagem",
                                  "subSteps": [
                                    "Defina modelagem de eventos discretos: simulações baseadas em mudanças de estado em pontos específicos no tempo.",
                                    "Defina modelagem contínua: simulações com variáveis que mudam suavemente ao longo do tempo, usando equações diferenciais.",
                                    "Defina modelagem híbrida: combinação de eventos discretos e dinâmica contínua.",
                                    "Identifique exemplos reais para cada paradigma, como filas para discreto e circuitos para contínuo.",
                                    "Compare as diferenças em termos de solvers, representação de tempo e componentes suportados."
                                  ],
                                  "verification": "Crie um diagrama comparativo dos três paradigmas e explique verbalmente ou por escrito as diferenças principais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação conceitual online (ex: Wikipedia sobre simulação discreta/contínua), caderno para anotações.",
                                  "tips": "Use analogias cotidianas, como tráfego em semáforos (discreto) vs. fluxo de água (contínuo).",
                                  "learningObjective": "Diferenciar claramente eventos discretos, contínuos e híbridos para contextualizar a avaliação de software.",
                                  "commonMistakes": "Confundir discreto com estocástico ou ignorar que híbrido requer suporte simultâneo aos dois."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Consultar documentação e recursos oficiais do software",
                                  "subSteps": [
                                    "Acesse o site oficial, manual do usuário e whitepapers do software de simulação.",
                                    "Busque seções sobre 'paradigmas suportados', 'tipos de simulação' ou 'modelos híbridos'.",
                                    "Verifique listas de features para menções a DEVS (discreto), ODE/PDE solvers (contínuo) e hybrid modeling.",
                                    "Anote suporte explícito para alternância sem reescrita, como flags ou modos configuráveis.",
                                    "Procure fóruns, tutoriais ou benchmarks que confirmem ou refutem as claims da documentação."
                                  ],
                                  "verification": "Compile uma tabela resumindo o suporte declarado para cada paradigma e alternância, com citações de fontes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Navegador web, PDF reader, acesso ao site do software (ex: AnyLogic, Simulink, Modelica).",
                                  "tips": "Use Ctrl+F para buscas rápidas por termos como 'discrete event', 'continuous', 'hybrid'.",
                                  "learningObjective": "Extrair e interpretar informações técnicas de documentação para embasar avaliações.",
                                  "commonMistakes": "Aceitar claims sem verificação cruzada ou ignorar versões específicas do software."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar testes práticos de suporte a paradigmas",
                                  "subSteps": [
                                    "Instale ou abra o software e crie um modelo simples de eventos discretos (ex: fila M/M/1).",
                                    "Construa um modelo contínuo (ex: oscilador harmônico com equações diferenciais).",
                                    "Desenvolva um modelo híbrido (ex: sistema de controle com eventos de falha e dinâmica contínua).",
                                    "Execute simulações e valide saídas contra resultados esperados teóricos.",
                                    "Documente erros ou limitações observadas durante a construção."
                                  ],
                                  "verification": "Execute e capture screenshots/vídeos das simulações bem-sucedidas para cada paradigma.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Software de simulação instalado, exemplos de modelos prontos (tutoriais oficiais).",
                                  "tips": "Comece com modelos mínimos viáveis para isolar o suporte ao paradigma.",
                                  "learningObjective": "Aplicar paradigmas em modelos reais para testar suporte prático do software.",
                                  "commonMistakes": "Usar modelos complexos demais inicialmente ou não validar resultados com teoria."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar alternância entre paradigmas sem reescrita",
                                  "subSteps": [
                                    "Pegue um modelo base e alterne para modo discreto, execute e compare.",
                                    "Mude para contínuo ou híbrido usando configurações (ex: solver selection, hybrid flags).",
                                    "Verifique se o código/modelo original permanece intacto, apenas com parâmetros alterados.",
                                    "Meça tempo de setup para alternância e note qualquer necessidade de adaptações.",
                                    "Registre se a alternância preserva resultados consistentes nos regimes comuns."
                                  ],
                                  "verification": "Demonstre alternância em um relatório com antes/depois, mostrando código inalterado.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Mesmo modelo do step 3, cronômetro para medir tempo.",
                                  "tips": "Salve versões do modelo antes de alterar para fácil rollback.",
                                  "learningObjective": "Avaliar flexibilidade prática na troca de paradigmas sem overhead significativo.",
                                  "commonMistakes": "Assumir suporte sem testar alternância real ou ignorar overhead de performance."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar avaliação e identificar limitações",
                                  "subSteps": [
                                    "Classifique o suporte: pleno (todos + alternância), parcial ou ausente.",
                                    "Liste prós/contras baseados em testes e docs.",
                                    "Compare com softwares concorrentes brevemente.",
                                    "Recomende cenários ideais de uso baseado na flexibilidade.",
                                    "Prepare um relatório final com evidências."
                                  ],
                                  "verification": "Produza um relatório de 1-2 páginas com classificação, evidências e recomendações.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de texto, imagens dos testes.",
                                  "tips": "Use escalas qualitativas (ex: 1-5) para suporte a cada aspecto.",
                                  "learningObjective": "Integrar dados de docs e testes em uma avaliação holística.",
                                  "commonMistakes": "Ser enviesado por docs sem priorizar testes práticos."
                                }
                              ],
                              "practicalExample": "Em AnyLogic, crie uma fila de supermercado (discreto), alterne para modelo contínuo aproximando com DEs de fluido, depois híbrido adicionando eventos de chegada, validando saídas como tempo médio de espera em todos modos sem reescrever o modelo base.",
                              "finalVerifications": [
                                "Modelo discreto simula corretamente eventos sem drift temporal.",
                                "Modelo contínuo resolve equações diferenciais com precisão configurável.",
                                "Modelo híbrido integra ambos sem artefatos de transição.",
                                "Alternância via parâmetros altera paradigma sem edição de código.",
                                "Resultados são consistentes entre paradigmas em overlaps.",
                                "Documentação e testes alinham em suporte declarado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção conceitual dos paradigmas (80%+ acerto em quiz).",
                                "Relatório com evidências visuais de testes (screenshots/vídeos).",
                                "Tempo de alternância medido <5min sem reescrita.",
                                "Identificação correta de pelo menos 2 limitações reais.",
                                "Recomendações contextualizadas para uso.",
                                "Clareza e estrutura do relatório final."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Uso de solvers numéricos em linguagens como Python (SciPy).",
                                "Engenharia: Modelagem de sistemas de controle em mecatrônica.",
                                "Física: Simulação de dinâmica newtoniana vs. eventos quânticos.",
                                "Ciência de Dados: Análise de simulações estocásticas híbridas."
                              ],
                              "realWorldApplication": "Em indústrias como manufatura (simular linhas de produção híbridas) ou logística (otimizar cadeias de suprimentos alternando discreto/contínuo), permitindo engenheiros testar cenários sem múltiplos softwares, reduzindo custos e tempo de desenvolvimento."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.2.2",
                            "name": "Analisar extensibilidade via scripts e plugins",
                            "description": "Testar a capacidade de incorporar linguagens de programação como Python ou C++ para customizações, e a disponibilidade de APIs para integração com ferramentas externas de análise de dados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Pesquisar Documentação de Suporte a Scripts e Plugins",
                                  "subSteps": [
                                    "Acesse o site oficial do software de simulação e localize a seção de documentação técnica.",
                                    "Procure por termos como 'scripting', 'plugins', 'extensions', 'Python support' ou 'C++ API'.",
                                    "Identifique linguagens suportadas (ex: Python, C++) e exemplos de customizações.",
                                    "Anote a disponibilidade de tutoriais ou amostras de código para extensões.",
                                    "Registre limitações declaradas, como versões específicas ou dependências."
                                  ],
                                  "verification": "Criar um resumo escrito da documentação com citações e links para seções relevantes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Acesso à internet, navegador web, software alvo instalado, bloco de notas ou editor de texto.",
                                  "tips": "Use Ctrl+F para buscas rápidas na documentação PDF ou HTML.",
                                  "learningObjective": "Compreender as capacidades declaradas de extensibilidade do software.",
                                  "commonMistakes": "Ignorar seções de 'versões antigas' ou assumir suporte sem verificar compatibilidade com a versão instalada."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar e Testar Integração com Linguagens de Programação",
                                  "subSteps": [
                                    "Instale as dependências necessárias (ex: Python interpreter ou C++ compiler compatível).",
                                    "Siga um tutorial oficial para criar um script simples, como uma função de customização de simulação.",
                                    "Execute o script dentro do software e observe o impacto na simulação discreta.",
                                    "Teste modificações avançadas, como adicionar novos comportamentos via plugin.",
                                    "Meça o tempo de carregamento e performance do script."
                                  ],
                                  "verification": "Script executado com sucesso, gerando saída visível na interface do software (ex: novo gráfico ou entidade).",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Software de simulação, Python/C++ instalados, exemplos de código da documentação, ambiente de desenvolvimento (ex: VS Code).",
                                  "tips": "Comece com scripts mínimos viáveis (MVPs) para isolar erros.",
                                  "learningObjective": "Dominar a incorporação prática de código externo para customizações.",
                                  "commonMistakes": "Não configurar caminhos de bibliotecas corretamente, levando a erros de importação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar e Testar APIs para Integrações Externas",
                                  "subSteps": [
                                    "Identifique APIs documentadas para exportação/importação de dados (ex: RESTful ou SDKs).",
                                    "Crie um script externo em Python para conectar via API e puxar dados da simulação.",
                                    "Integre com uma ferramenta externa de análise (ex: Pandas para dados ou Matplotlib para visualizações).",
                                    "Teste cenários de ida e volta: envie parâmetros da ferramenta externa para o software.",
                                    "Registre erros de autenticação ou rate limiting."
                                  ],
                                  "verification": "Integração bem-sucedida com log de dados transferidos e análise externa aplicada.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "API keys se necessário, bibliotecas Python (requests, pandas), ferramenta externa como Jupyter Notebook.",
                                  "tips": "Use Postman para testar endpoints de API antes de codificar.",
                                  "learningObjective": "Avaliar a viabilidade de integrações com ecossistemas de análise de dados.",
                                  "commonMistakes": "Sobrecarregar a API com chamadas excessivas sem implementar cache."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Limitações e Gerar Relatório de Extensibilidade",
                                  "subSteps": [
                                    "Compile métricas: tempo de execução, facilidade de depuração, escalabilidade para simulações grandes.",
                                    "Compare com softwares alternativos (ex: NetLogo vs. AnyLogic).",
                                    "Identifique gaps, como falta de suporte a linguagens modernas ou APIs limitadas.",
                                    "Classifique o nível de extensibilidade (alto/médio/baixo) com justificativa.",
                                    "Escreva um relatório conciso com recomendações."
                                  ],
                                  "verification": "Relatório finalizado com tabela comparativa e evidências de testes.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Planilha (Google Sheets/Excel) para métricas, relatórios de testes anteriores.",
                                  "tips": "Use critérios quantitativos (ex: tempo < 5s para script) e qualitativos (facilidade de uso).",
                                  "learningObjective": "Sintetizar análise em julgamento informado sobre flexibilidade do software.",
                                  "commonMistakes": "Focar apenas em sucessos, ignorando falhas em cenários edge-case."
                                }
                              ],
                              "practicalExample": "No software NetLogo, crie um plugin em Python para estender uma simulação de sistema discreto de filas (queueing system), integrando via API com Pandas para análise estatística em tempo real de tempos de espera, exportando resultados para visualização em Matplotlib.",
                              "finalVerifications": [
                                "Script/plugin personalizado executado sem erros em simulação discreta.",
                                "Integração API com ferramenta externa (ex: Python Pandas) transfere dados corretamente.",
                                "Performance medida: tempo de extensão < 10% do tempo base da simulação.",
                                "Relatório inclui pelo menos 3 métricas quantitativas e 2 qualitativas.",
                                "Customização altera comportamento da simulação de forma observável.",
                                "Limitações identificadas com evidências de testes falhos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de suporte documentado (90% cobertura).",
                                "Sucesso em execução de pelo menos 2 scripts/plugins customizados.",
                                "Qualidade da integração API: dados bidirecionais funcionais.",
                                "Análise de performance abrangente com benchmarks.",
                                "Relatório claro, estruturado e acionável.",
                                "Demonstração de compreensão de trade-offs em extensibilidade."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Prática em Python/C++ para automação.",
                                "Análise de Dados: Uso de APIs e bibliotecas como Pandas.",
                                "Engenharia de Software: Avaliação de arquiteturas extensíveis.",
                                "Matemática Aplicada: Modelagem de sistemas discretos estendidos."
                              ],
                              "realWorldApplication": "Em simulações de logística para otimizar cadeias de suprimentos, estendendo software com scripts Python para integrar dados reais de sensores IoT via APIs, permitindo análises preditivas em tempo real para empresas como Amazon ou indústrias manufatureiras."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.2.3",
                            "name": "Avaliar adaptabilidade a cenários variados",
                            "description": "Examinar suporte a múltiplos tipos de distribuições de probabilidade, escalabilidade de modelos grandes e flexibilidade em parâmetros de entrada para simulações de sistemas discretos complexos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir Cenários de Teste Variados",
                                  "subSteps": [
                                    "Identifique tipos comuns de distribuições de probabilidade relevantes para sistemas discretos (ex: Poisson, Binomial, Geométrica, Uniforme).",
                                    "Especifique tamanhos de modelos escaláveis (pequeno: 100 entidades; médio: 10k; grande: 1M+).",
                                    "Liste parâmetros de entrada flexíveis (ex: taxas variáveis, seeds randômicos, dimensões configuráveis).",
                                    "Crie uma matriz de cenários combinando distribuições, escalas e parâmetros (mínimo 9 combinações).",
                                    "Documente requisitos de adaptabilidade esperados para cada cenário."
                                  ],
                                  "verification": "Matriz de cenários documentada com pelo menos 9 entradas únicas e critérios de sucesso definidos.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": "Planilha ou documento (Google Sheets/Excel), documentação do software de simulação.",
                                  "tips": "Priorize cenários realistas baseados em aplicações como filas ou redes de eventos discretos.",
                                  "learningObjective": "Compreender como variabilidade em cenários testa adaptabilidade geral do software.",
                                  "commonMistakes": "Ignorar distribuições edge-case como as de cauda pesada, levando a subestimação de limitações."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Testar Suporte a Múltiplas Distribuições de Probabilidade",
                                  "subSteps": [
                                    "Configure simulações idênticas alterando apenas a distribuição de chegada/serviços.",
                                    "Execute 3-5 runs por distribuição com seeds diferentes para medir variância.",
                                    "Registre métricas: tempo de setup, taxa de erro, precisão de saída estatística.",
                                    "Compare saídas contra benchmarks analíticos ou simulações conhecidas.",
                                    "Identifique falhas como crashes ou aproximações inadequadas."
                                  ],
                                  "verification": "Relatório com resultados para cada distribuição, incluindo gráficos de comparação.",
                                  "estimatedTime": "4-6 horas",
                                  "materials": "Software de simulação, gerador de dados randômicos, ferramentas de plotagem (Python/MATLAB).",
                                  "tips": "Use bibliotecas como NumPy/SciPy para validação rápida de distribuições.",
                                  "learningObjective": "Avaliar como o software gerencia diversidade estocástica sem perda de robustez.",
                                  "commonMistakes": "Usar seeds fixos em todos os testes, mascarando variabilidade randômica."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar Escalabilidade para Modelos Grandes",
                                  "subSteps": [
                                    "Implemente modelos progressivamente maiores usando o mesmo cenário base.",
                                    "Meça recursos computacionais: tempo de execução, uso de CPU/memória por escala.",
                                    "Teste paralelização ou otimizações internas do software.",
                                    "Analise degradação de performance (ex: tempo O(n^2) vs. linear).",
                                    "Verifique estabilidade numérica em escalas extremas."
                                  ],
                                  "verification": "Gráficos de performance escalável (tempo/memória vs. tamanho do modelo).",
                                  "estimatedTime": "3-5 horas",
                                  "materials": "Monitor de sistema (Task Manager/htop), hardware com >16GB RAM.",
                                  "tips": "Inicie com modelos pequenos para baseline antes de escalar.",
                                  "learningObjective": "Determinar limites práticos de escala do software em simulações discretas.",
                                  "commonMistakes": "Não normalizar métricas por unidade de modelo, distorcendo comparações."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Flexibilidade em Parâmetros de Entrada",
                                  "subSteps": [
                                    "Varie parâmetros extremos (ex: taxa zero/infinita, dimensões 1D a multi-D).",
                                    "Teste interfaces de input: arquivos, APIs, GUIs para usabilidade.",
                                    "Avalie validação de inputs: rejeição de inválidos, defaults inteligentes.",
                                    "Execute simulações com inputs dinâmicos (ex: mudando mid-run).",
                                    "Documente esforço de configuração por tipo de input."
                                  ],
                                  "verification": "Tabela de testes de parâmetros com status de sucesso/falha e tempo de setup.",
                                  "estimatedTime": "2-4 horas",
                                  "materials": "Scripts de automação de inputs, exemplos de arquivos de configuração.",
                                  "tips": "Automatize com loops em scripts para eficiência em variações.",
                                  "learningObjective": "Garantir que o software adapte-se a inputs não padronizados sem recodificação.",
                                  "commonMistakes": "Focar só em inputs válidos, ignorando handling de erros."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e Concluir Avaliação de Adaptabilidade",
                                  "subSteps": [
                                    "Compile métricas de todos os testes em um scorecard quantitativo/qualitativo.",
                                    "Calcule scores compostos (ex: 0-10 para distribuições, escala, flexibilidade).",
                                    "Identifique padrões de falha e recomendações de melhoria.",
                                    "Compare com softwares alternativos ou literatura.",
                                    "Redija relatório final com evidências."
                                  ],
                                  "verification": "Scorecard e relatório final com conclusões acionáveis.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": "Ferramentas de análise (Excel/R), templates de relatório.",
                                  "tips": "Use pesos nos scores baseados em importância contextual (ex: escala > distribuições).",
                                  "learningObjective": "Integrar avaliações parciais em julgamento holístico de adaptabilidade.",
                                  "commonMistakes": "Sobrepesar um aspecto (ex: velocidade) em detrimento de robustez geral."
                                }
                              ],
                              "practicalExample": "Em um software como Simul8 ou AnyLogic, teste uma simulação de call center: altere distribuições de chamadas (Poisson para picos, Uniforme para estável), escale de 10 para 100k agentes, e flexione parâmetros como tempo médio de serviço de 1-60min ou adicione filas multi-servidor dinamicamente. Verifique se roda sem crashes e outputs precisos.",
                              "finalVerifications": [
                                "Software suporta ≥5 distribuições sem erros de implementação.",
                                "Tempo de execução escala linearmente ou melhor para modelos 10x maiores.",
                                "≥90% dos parâmetros variáveis são configuráveis sem edição de código.",
                                "Nenhum crash em 20+ cenários combinados.",
                                "Outputs estatísticos coincidem com validações analíticas em ±5%.",
                                "Relatório inclui benchmarks comparativos com ferramentas open-source."
                              ],
                              "assessmentCriteria": [
                                "Robustez: Taxa de falha <5% em cenários variados.",
                                "Eficiência: Degradação de performance <20% por ordem de magnitude de escala.",
                                "Usabilidade: Tempo médio de setup de cenário <10min.",
                                "Precisão: Erro médio em métricas simuladas <3%.",
                                "Abrangência: Cobertura de 80%+ dos cenários definidos.",
                                "Documentabilidade: Evidências reproduzíveis em relatório."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Validação de distribuições e testes de hipótese em outputs.",
                                "Ciência da Computação: Análise de complexidade algorítmica e paralelismo.",
                                "Engenharia de Software: Testes unitários e integração para simulações.",
                                "Gestão de Operações: Modelagem de sistemas reais como supply chains."
                              ],
                              "realWorldApplication": "Em logística, avaliar se um software simula cadeias de suprimentos com distribuições variáveis de demanda (ex: sazonal Poisson), escala para redes globais (milhões de itens), e ajusta parâmetros como atrasos portuários dinamicamente, otimizando decisões de estoque e rotas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.4.3",
                        "name": "Eficiência Computacional",
                        "description": "Desempenho do software em termos de tempo de execução, consumo de memória, paralelização e escalabilidade para simulações de grande porte em sistemas discretos, otimizando recursos computacionais.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.3.1",
                            "name": "Medir tempo de execução e escalabilidade",
                            "description": "Executar benchmarks com modelos de simulação discretos de tamanhos crescentes para quantificar o tempo de processamento e identificar gargalos em execuções longas ou com alto número de réplicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar Modelos de Simulação Discreta de Tamanhos Crescentes",
                                  "subSteps": [
                                    "Definir um modelo base de simulação discreta, como uma fila ou rede de eventos.",
                                    "Criar variações parametrizadas com tamanhos crescentes (ex.: 100, 1.000, 10.000 entidades ou eventos).",
                                    "Garantir que as variações sejam funcionalmente idênticas, alterando apenas parâmetros de escala.",
                                    "Testar cada modelo individualmente para verificar ausência de erros.",
                                    "Salvar os modelos em scripts ou arquivos configuráveis para execução automatizada."
                                  ],
                                  "verification": "Todos os modelos rodam sem erros e produzem saídas esperadas para tamanhos pequenos.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Software de simulação (ex.: SimPy em Python, AnyLogic), editor de código (VS Code), ambiente Python/Jupyter.",
                                  "tips": "Use funções parametrizadas para evitar duplicação de código e facilitar escalas futuras.",
                                  "learningObjective": "Dominar a criação de modelos escaláveis para testes de performance.",
                                  "commonMistakes": "Criar modelos manualmente sem parâmetros, levando a erros de inconsistência."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Ambiente e Ferramentas de Benchmark",
                                  "subSteps": [
                                    "Instalar bibliotecas de medição de tempo (ex.: timeit, time.perf_counter em Python).",
                                    "Definir número de réplicas por teste (ex.: 10-50 execuções para média estatística).",
                                    "Configurar logging automatizado para registrar tempos, tamanhos e desvios padrão.",
                                    "Preparar scripts de execução em loop para cada tamanho de modelo.",
                                    "Testar configuração com um modelo pequeno para validar medições."
                                  ],
                                  "verification": "Script de benchmark roda e gera log com tempos precisos para teste inicial.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Python 3+, bibliotecas (timeit, pandas, matplotlib), terminal ou Jupyter Notebook.",
                                  "tips": "Use precisão de nanosegundos com time.perf_counter para evitar overhead do time().",
                                  "learningObjective": "Configurar ferramentas precisas para medições de performance em simulações.",
                                  "commonMistakes": "Usar time.time() impreciso ou esquecer de aquecer o cache da CPU."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar Benchmarks e Coletar Dados",
                                  "subSteps": [
                                    "Executar benchmarks sequencialmente para cada tamanho de modelo com réplicas definidas.",
                                    "Registrar tempo total, tempo médio, desvio padrão e uso de memória para cada execução.",
                                    "Monitorar recursos do sistema (CPU, RAM) durante execuções longas.",
                                    "Salvar dados brutos em formato CSV ou DataFrame para análise posterior.",
                                    "Verificar integridade dos dados (ausência de outliers anômalos)."
                                  ],
                                  "verification": "Dados coletados para todos tamanhos, com pelo menos 10 réplicas cada, sem falhas.",
                                  "estimatedTime": "3-4 horas (dependendo da escala)",
                                  "materials": "Computador com recursos suficientes (mín. 8GB RAM), scripts de benchmark, planilha ou pandas.",
                                  "tips": "Execute em modo single-thread para isolar gargalos de simulação, não de paralelismo.",
                                  "learningObjective": "Coletar dados empíricos confiáveis de performance em simulações discretas.",
                                  "commonMistakes": "Poucas réplicas, levando a variância alta e conclusões erradas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Dados, Identificar Gargalos e Avaliar Escalabilidade",
                                  "subSteps": [
                                    "Calcular métricas: tempo médio vs. tamanho, speedup, eficiência.",
                                    "Plotar gráficos (tempo vs. log(tamanho), curvas de escalabilidade).",
                                    "Identificar gargalos (ex.: loops O(n²), alocações de memória).",
                                    "Comparar com complexidades teóricas (O(n), O(n log n)).",
                                    "Gerar relatório com recomendações de otimização."
                                  ],
                                  "verification": "Gráficos gerados, gargalos listados e escalabilidade quantificada (ex.: tempo dobra a cada 2x tamanho).",
                                  "estimatedTime": "2 horas",
                                  "materials": "Pandas, Matplotlib/Seaborn para plots, Jupyter Notebook para visualização.",
                                  "tips": "Use log-escala nos eixos para detectar não-linearidades claramente.",
                                  "learningObjective": "Interpretar dados de benchmark para otimizar simulações.",
                                  "commonMistakes": "Ignorar variância ou overfitting em poucos pontos de dado."
                                }
                              ],
                              "practicalExample": "Simule uma fila M/M/1 em SimPy com número de chegadas crescendo de 100 a 10.000. Meça tempo de simulação para 20 réplicas cada; identifique gargalo em geração de eventos aleatórios para n>5.000.",
                              "finalVerifications": [
                                "Gráficos de tempo vs. tamanho gerados e legíveis.",
                                "Tempos médios e desvios padrão calculados corretamente.",
                                "Gargalos identificados com evidências nos dados.",
                                "Curva de escalabilidade classificada (linear, quadrática etc.).",
                                "Relatório escrito com conclusões acionáveis.",
                                "Teste de repetibilidade: reexecução confirma resultados (±5%)."
                              ],
                              "assessmentCriteria": [
                                "Precisão das medições (erro <5% com réplicas).",
                                "Identificação correta de pelo menos 2 gargalos reais.",
                                "Gráficos claros com legendas e escalas adequadas.",
                                "Análise quantitativa com métricas (ex.: slope de regressão).",
                                "Relatório conciso e com recomendações práticas.",
                                "Uso correto de ferramentas sem overhead artificial."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Técnicas de profiling e otimização de código.",
                                "Estatística: Análise de variância e testes de significância em réplicas.",
                                "Ciência da Computação: Complexidade algorítmica e Big O.",
                                "Engenharia de Software: Testes de performance e escalabilidade.",
                                "Matemática Aplicada: Modelagem estocástica e simulações Monte Carlo."
                              ],
                              "realWorldApplication": "Em indústrias como manufatura ou telecomunicações, benchmarks de simulações discretas avaliam se software suporta simulações de fábricas reais (milhões de eventos), identificando gargalos para evitar atrasos em projetos de bilhões."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.3.2",
                            "name": "Avaliar uso de memória e otimização de algoritmos",
                            "description": "Monitorar consumo de RAM durante simulações e analisar implementações internas de filas de eventos, geração de aleatórias e algoritmos de avanço de tempo para eficiência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambiente de monitoramento de memória e simulador",
                                  "subSteps": [
                                    "Instalar ferramentas de profiling como Valgrind, perf ou memory_profiler para Python.",
                                    "Selecionar ou implementar um simulador de eventos discretos (ex: SimPy ou custom em C++/Python).",
                                    "Definir cenários de teste escaláveis com parâmetros variáveis (número de eventos, duração).",
                                    "Configurar hooks de logging para capturar uso de RAM em pontos iniciais, médios e finais da simulação.",
                                    "Executar teste piloto para validar configuração sem erros."
                                  ],
                                  "verification": "Teste piloto gera logs de memória sem falhas e ambiente está funcional.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Computador com Python/C++ instalado, bibliotecas SimPy/Valgrind, editor de código.",
                                  "tips": "Use ambientes virtuais (venv) para isolar dependências e evitar conflitos.",
                                  "learningObjective": "Preparar ferramentas precisas para medição de consumo de memória em simulações.",
                                  "commonMistakes": "Não calibrar ferramentas, causando overhead que mascara resultados reais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar simulações e monitorar consumo de RAM",
                                  "subSteps": [
                                    "Rodar simulações com escalas crescentes (10k, 100k, 1M eventos).",
                                    "Registrar métricas de RAM (pico, média, vazamentos) em intervalos de 10% do tempo total.",
                                    "Gerar gráficos de evolução temporal do uso de memória usando Matplotlib ou ferramentas nativas.",
                                    "Identificar padrões como picos súbitos ou crescimento linear contínuo.",
                                    "Repetir execuções (mínimo 3) para médias estatisticamente confiáveis."
                                  ],
                                  "verification": "Gráficos e tabelas de métricas de RAM gerados para todos os cenários.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Simulador configurado, ferramentas de plotting (Matplotlib), planilhas para dados.",
                                  "tips": "Desabilite garbage collector durante medições para resultados consistentes.",
                                  "learningObjective": "Coletar e visualizar dados de consumo de memória durante execuções reais.",
                                  "commonMistakes": "Executar apenas um cenário, ignorando escalabilidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar implementações internas de componentes chave",
                                  "subSteps": [
                                    "Inspecionar código da fila de eventos (event queue): verificar uso de listas vs. heaps/priority queues.",
                                    "Examinar gerador de números aleatórios: analisar seed, distribuição e eficiência (ex: Mersenne Twister vs. linear congruential).",
                                    "Revisar algoritmo de avanço de tempo: identificar next-event time logic e complexidade O(n).",
                                    "Medir complexidade espacial/temporal de cada componente com profiling detalhado.",
                                    "Documentar ineficiências como realocações frequentes ou loops desnecessários."
                                  ],
                                  "verification": "Relatório com análise código-a-código e métricas por componente.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Código fonte do simulador, debugger (gdb/pdb), documentação de algoritmos.",
                                  "tips": "Use printfs ou breakpoints em funções críticas para tracing.",
                                  "learningObjective": "Identificar gargalos em filas de eventos, geração aleatória e avanço temporal.",
                                  "commonMistakes": "Focar apenas em tempo, ignorando alocações dinâmicas de memória."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar eficiência geral e propor/implementar otimizações",
                                  "subSteps": [
                                    "Comparar métricas atuais com benchmarks de simuladores otimizados (ex: DESMO-J).",
                                    "Priorizar otimizações: substituir lista por heap na queue, otimizar RNG, usar time wheels para avanço.",
                                    "Implementar mudanças em branch separado e retestar com mesmas condições.",
                                    "Quantificar ganhos (redução % em RAM e tempo).",
                                    "Documentar trade-offs (ex: precisão vs. velocidade)."
                                  ],
                                  "verification": "Versão otimizada roda com redução mensurável de RAM e relatório comparativo.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Sistema de controle de versão (Git), compilador/interpretador.",
                                  "tips": "Teste regressão para garantir que otimizações não quebrem lógica.",
                                  "learningObjective": "Aplicar análise para otimizar algoritmos e validar melhorias.",
                                  "commonMistakes": "Otimizar prematuramente sem profiling, desperdiçando esforço."
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado com 500.000 clientes, monitore RAM durante processamento: identifique que fila de eventos em lista cresce para 200MB devido a appends ineficientes; otimize para heap, reduzindo para 50MB sem perda de precisão.",
                              "finalVerifications": [
                                "Gráficos de uso de RAM antes/depois para múltiplos cenários.",
                                "Análise documentada de fila de eventos, RNG e avanço temporal.",
                                "Métricas comparativas mostrando redução >20% em RAM.",
                                "Código otimizado funcional e sem vazamentos detectados.",
                                "Relatório com recomendações escaláveis.",
                                "Testes de estresse confirmam estabilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude das medições de memória (erro <5%).",
                                "Profundidade na análise de complexidades algorítmicas.",
                                "Relevância e impacto das otimizações propostas.",
                                "Qualidade dos gráficos e documentação.",
                                "Capacidade de identificar e evitar vazamentos.",
                                "Trade-offs discutidos de forma equilibrada."
                              ],
                              "crossCurricularConnections": [
                                "Ciência da Computação: Estruturas de Dados e Algoritmos (heaps, priority queues).",
                                "Estatística: Geração de Números Pseudo-Aleatórios e Distribuições.",
                                "Engenharia de Software: Profiling, Otimização e Refatoração.",
                                "Matemática: Análise de Complexidade Assintótica (Big O)."
                              ],
                              "realWorldApplication": "Em simulações de logística para empresas como Amazon, otimizar uso de memória permite rodar cenários com milhões de pacotes em desktops comuns, reduzindo custos de cloud e acelerando decisões de roteirização."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.3.3",
                            "name": "Verificar suporte a paralelização e computação distribuída",
                            "description": "Testar recursos de multiprocessamento, GPU ou cluster para aceleração de simulações paralelas em sistemas discretos, medindo ganhos de performance.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Pesquisar suporte a paralelização no software de simulação",
                                  "subSteps": [
                                    "Ler documentação oficial do software para identificar APIs ou configurações de multiprocessamento, GPU (ex: CUDA) ou cluster (ex: MPI).",
                                    "Verificar exemplos de código ou tutoriais específicos para simulações discretas paralelas.",
                                    "Consultar fóruns, repositórios GitHub ou benchmarks comunitários para casos reais de uso.",
                                    "Listar limitações conhecidas, como suporte apenas para certas arquiteturas de hardware.",
                                    "Documentar flags de compilação ou bibliotecas externas necessárias (ex: OpenMP, Thrust)."
                                  ],
                                  "verification": "Criar um relatório resumido com evidências de suporte (capturas de tela da doc, links).",
                                  "estimatedTime": "2-3 horas",
                                  "materials": "Documentação do software, navegador web, notebook para anotações.",
                                  "tips": "Use palavras-chave como 'parallel', 'GPU acceleration', 'distributed computing' na busca.",
                                  "learningObjective": "Compreender as capacidades nativas de paralelização do software para simulações discretas.",
                                  "commonMistakes": "Ignorar versões específicas do software que podem não suportar paralelização; assumir suporte sem verificação prática."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar ambiente de computação paralela",
                                  "subSteps": [
                                    "Instalar drivers e bibliotecas necessárias (ex: NVIDIA CUDA para GPU, MPICH para clusters).",
                                    "Configurar o software de simulação com opções de paralelização (ex: --enable-openmp).",
                                    "Testar conectividade em cluster se aplicável (ex: SSH sem senha entre nós).",
                                    "Preparar hardware: alocar GPUs ou múltiplos cores via gerenciadores como SLURM.",
                                    "Validar configuração com um teste simples de 'hello world' paralelo."
                                  ],
                                  "verification": "Executar um benchmark básico e confirmar saída paralela sem erros.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": "Computador com GPU/multi-core, software de simulação, drivers CUDA/OpenMP, cluster access (opcional).",
                                  "tips": "Use ambientes virtuais (conda) para isolar dependências e evitar conflitos.",
                                  "learningObjective": "Configurar corretamente hardware e software para execução paralela em simulações.",
                                  "commonMistakes": "Esquecer de recompilar o software após habilitar flags paralelas; incompatibilidades de versão entre CUDA e driver."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar simulação discreta paralelizável",
                                  "subSteps": [
                                    "Selecionar ou criar um modelo discreto simples (ex: automato celular como Game of Life).",
                                    "Dividir o modelo em tarefas paralelas (ex: decomposição de domínio espacial).",
                                    "Codificar versão sequencial como baseline.",
                                    "Adaptar para paralelo usando APIs do software (ex: parallel_for loops).",
                                    "Garantir sincronização correta entre threads/processos (ex: barreiras, locks)."
                                  ],
                                  "verification": "Rodar simulação sequencial e paralela em escala pequena; comparar resultados idênticos.",
                                  "estimatedTime": "4-6 horas",
                                  "materials": "Editor de código (VS Code), compilador (GCC/Clang), modelo de simulação de teste.",
                                  "tips": "Comece com granularidade fina para maximizar paralelismo, mas evite overhead de comunicação.",
                                  "learningObjective": "Desenvolver modelos de simulação discretos otimizados para aceleração paralela.",
                                  "commonMistakes": "Race conditions devido a acessos concorrentes a dados compartilhados; ignorar balanceamento de carga."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar testes de performance e medir ganhos",
                                  "subSteps": [
                                    "Rodar simulações sequencial e paralela com tamanhos variados (ex: grids 100x100 a 1000x1000).",
                                    "Medir tempos de execução usando timers precisos (ex: std::chrono, nvprof).",
                                    "Calcular speedup (tempo_seq / tempo_par) e eficiência (speedup / num_cores).",
                                    "Coletar métricas adicionais: uso de CPU/GPU, memória, throughput.",
                                    "Repetir testes múltiplas vezes para médias estatisticamente significativas."
                                  ],
                                  "verification": "Gerar gráficos de speedup vs. escala (Amdahl's law visualization).",
                                  "estimatedTime": "3-5 horas",
                                  "materials": "Ferramentas de profiling (gprof, NVIDIA Nsight), planilhas (Excel/Google Sheets) para dados.",
                                  "tips": "Warm-up runs antes de medições para cache effects; isole variáveis fixando seeds randômicas.",
                                  "learningObjective": "Quantificar ganhos de performance em simulações paralelas de sistemas discretos.",
                                  "commonMistakes": "Medir apenas uma vez (variabilidade); confundir wall-clock time com CPU time."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar resultados e documentar conclusões",
                                  "subSteps": [
                                    "Comparar performance com benchmarks teóricos (ex: lei de Gustafson).",
                                    "Identificar gargalos (ex: comunicação > computação).",
                                    "Recomendar configurações ótimas baseadas em testes.",
                                    "Documentar trade-offs (ex: escalabilidade vs. complexidade de código).",
                                    "Preparar relatório com gráficos, tabelas e sugestões de melhorias."
                                  ],
                                  "verification": "Relatório final com speedup mínimo de 2x em cenários realistas.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": "Ferramentas de plotagem (Matplotlib, GNUPlot), template de relatório.",
                                  "tips": "Use logs escalares para automatizar plots; discuta limitações do hardware testado.",
                                  "learningObjective": "Interpretar métricas de performance para avaliar eficiência computacional.",
                                  "commonMistakes": "Superestimar speedup ignorando overheads; generalizar resultados de um único modelo."
                                }
                              ],
                              "practicalExample": "Em um simulador de automato celular como o Game of Life usando software como NetLogo com extensões Java paralelizadas ou Python com Numba/CuPy: configure uma grid 500x500, rode sequencial (10s) vs. GPU (1.5s), meça speedup de ~6x em RTX 3060.",
                              "finalVerifications": [
                                "Speedup linear ou superlinear em pelo menos 3 escalas de problema.",
                                "Eficiência > 70% para num_cores até 8.",
                                "Resultados idênticos entre sequencial e paralelo (teste de corretude).",
                                "Uso eficiente de hardware (GPU utilization > 80%).",
                                "Relatório com gráficos reproduzíveis.",
                                "Identificação de gargalos com sugestões de mitigação."
                              ],
                              "assessmentCriteria": [
                                "Precisão das medições de performance (erro < 5%).",
                                "Corretude da implementação paralela (sem divergências numéricas).",
                                "Análise quantitativa completa (speedup, eficiência, escalabilidade).",
                                "Documentação clara e reproduzível dos testes.",
                                "Identificação de limitações e otimizações potenciais.",
                                "Aplicação prática em modelo discreto relevante.",
                                "Profundidade da pesquisa inicial sobre suporte do software."
                              ],
                              "crossCurricularConnections": [
                                "Programação Paralela (OpenMP, CUDA, MPI).",
                                "Análise de Performance e Algoritmos (Amdahl/Gustafson).",
                                "Computação Científica (bibliotecas como NumPy, SciPy).",
                                "Sistemas Operacionais (gerenciamento de threads/processos).",
                                "Engenharia de Software (testes e benchmarking)."
                              ],
                              "realWorldApplication": "Em simulações de epidemias (modelos SIR discretos em clusters para prever surtos em cidades), modelagem climática (cellular automata para frentes de onda em GPUs) ou finanças (Monte Carlo paralelos em bancos para risco), acelerando tempos de horas para minutos em supercomputadores."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.4.4",
                        "name": "Suporte a Validação",
                        "description": "Recursos integrados para validação de modelos de simulação, incluindo testes estatísticos, planejamento de experimentos e técnicas para garantir a fidelidade do modelo ao sistema real discreto.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.4.1",
                            "name": "Identificar ferramentas de validação estatística",
                            "description": "Avaliar testes de hipóteses, intervalos de confiança e gráficos de saída para verificar se as simulações reproduzem comportamentos esperados do sistema discreto modelado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de Validação Estatística em Simulações",
                                  "subSteps": [
                                    "Defina validação estatística como o processo de comparar saídas de simulações com comportamentos esperados de sistemas discretos.",
                                    "Identifique componentes chave: testes de hipóteses, intervalos de confiança (IC) e gráficos de saída.",
                                    "Estude exemplos de sistemas discretos como filas ou processos Markovianos.",
                                    "Revise propriedades esperadas, como médias estacionárias ou distribuições de estado.",
                                    "Liste ferramentas comuns: R, Python (scipy.stats), MATLAB Statistics Toolbox."
                                  ],
                                  "verification": "Crie um resumo de 1 página listando 3 componentes e 2 ferramentas com suas funções.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livro 'Simulation Modeling and Analysis' de Law; tutoriais online de R/Python para stats.",
                                  "tips": "Comece com definições simples antes de mergulhar em fórmulas para construir intuição.",
                                  "learningObjective": "Explicar o papel da validação estatística em simulações de sistemas discretos.",
                                  "commonMistakes": "Confundir validação com verificação (verificação é sintaxe, validação é fidelidade ao real)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Testes de Hipóteses para Validação",
                                  "subSteps": [
                                    "Aprenda hipóteses nula (H0: simulação = modelo teórico) e alternativa (H1: difere).",
                                    "Estude testes como t-test, chi-quadrado e Kolmogorov-Smirnov para distribuições e médias.",
                                    "Implemente um teste em Python: use scipy.stats.ttest_1samp para comparar média simulada com teórica.",
                                    "Interprete p-valores: p > 0.05 geralmente aceita H0.",
                                    "Aplique a uma simulação simples de fila M/M/1, testando tempo médio de espera."
                                  ],
                                  "verification": "Execute um teste de hipóteses em código e interprete o resultado em um relatório curto.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Python com scipy e numpy; Jupyter Notebook; dados de simulação de fila.",
                                  "tips": "Sempre verifique premissas do teste (normalidade, independência) antes de aplicar.",
                                  "learningObjective": "Selecionar e aplicar teste de hipóteses apropriado para validar saídas de simulação.",
                                  "commonMistakes": "Ignorar tamanho da amostra; amostras pequenas levam a p-valores instáveis."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Dominar Intervalos de Confiança (IC) em Simulações",
                                  "subSteps": [
                                    "Calcule IC para médias: use fórmula média ± t * (desvio padrão / sqrt(n)).",
                                    "Gere múltiplas runs de simulação para estimar variância.",
                                    "Verifique se valor teórico está dentro do IC (ex: 95% confiança).",
                                    "Use ferramentas como bootStrap em R para IC não-paramétricos.",
                                    "Aplique a distribuições de estado em cadeias Markov discretas."
                                  ],
                                  "verification": "Compute IC para 100 runs de uma simulação e confirme se parâmetro esperado está coberto.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "R ou Python (statsmodels); gerador de simulações discretas.",
                                  "tips": "Aumente número de runs para IC mais estreitos, mas equilibre com tempo computacional.",
                                  "learningObjective": "Construir e interpretar IC para validar precisão de simulações.",
                                  "commonMistakes": "Confundir IC com intervalo de predição; IC é para parâmetros populacionais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Gráficos de Saída para Verificação Visual",
                                  "subSteps": [
                                    "Crie histogramas de saídas simuladas vs. distribuições teóricas.",
                                    "Plote séries temporais para convergência a regime estacionário.",
                                    "Use Q-Q plots para checar normalidade ou adequação de distribuição.",
                                    "Gere gráficos com ggplot2 (R) ou matplotlib/seaborn (Python).",
                                    "Compare visualmente com benchmarks teóricos ou dados reais."
                                  ],
                                  "verification": "Produza 3 gráficos de uma simulação e anote observações de validação.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Python matplotlib/seaborn ou R ggplot2; dados de simulação.",
                                  "tips": "Use logs ou escalas para visualizar discrepâncias sutis em caudas.",
                                  "learningObjective": "Interpretar gráficos para detectar desvios entre simulação e expectativa.",
                                  "commonMistakes": "Sobrepor gráficos sem legendas claras ou escalas inadequadas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar Ferramentas em um Fluxo de Validação Completo",
                                  "subSteps": [
                                    "Desenhe um workflow: simule > gere saídas > aplique testes/IC > plote > decida validar.",
                                    "Implemente em software de simulação como SimPy (Python) ou Arena.",
                                    "Teste em sistema discreto real: simulação de rede de filas.",
                                    "Documente thresholds para aceitação (ex: IC cobre 95%, p>0.05).",
                                    "Automatize com scripts para múltiplas validações."
                                  ],
                                  "verification": "Crie um script completo validando uma simulação e gere relatório final.",
                                  "estimatedTime": "4 horas",
                                  "materials": "SimPy ou similar; ambiente Jupyter/RStudio.",
                                  "tips": "Versione código com Git para rastrear mudanças em validações.",
                                  "learningObjective": "Combinar testes, IC e gráficos para validar simulações discretas holisticamente.",
                                  "commonMistakes": "Não replicar runs suficientes; mire em pelo menos 1000 iterações."
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila M/M/1 (λ=1, μ=1.5), rode 1000 runs de 10000 eventos cada. Calcule tempo médio de espera teórico (1/(μ-λ)=2). Use t-test para H0: média_sim=2 (p=0.12>0.05), IC 95% [1.95,2.05] cobre 2, e Q-Q plot mostra adequação normal. Conclusão: validada.",
                              "finalVerifications": [
                                "Nomeie e descreva 3 ferramentas de validação estatística (ex: t-test, IC bootstrap, Q-Q plots).",
                                "Implemente e interprete um teste de hipóteses em código para simulação discreta.",
                                "Gere IC que cubra parâmetro teórico em pelo menos 95% das runs.",
                                "Produza gráficos mostrando convergência e adequação de distribuição.",
                                "Crie um relatório integrando todos para validar uma simulação completa.",
                                "Identifique discrepâncias e proponha ajustes no modelo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na seleção de testes/IC adequados ao tipo de saída (média vs. distribuição).",
                                "Correta interpretação de p-valores, cobertura de IC e padrões gráficos.",
                                "Adequação do número de runs e tamanho de amostra para confiabilidade.",
                                "Clareza e completude do workflow de validação documentado.",
                                "Capacidade de detectar e explicar desvios simulados vs. esperados.",
                                "Eficiência computacional e automação do processo."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Inferência e testes paramétricos/não-paramétricos.",
                                "Programação: Bibliotecas stats em Python/R para análise de dados simulados.",
                                "Modelagem Matemática: Cadeias de Markov e processos estocásticos discretos.",
                                "Ciência de Dados: Visualização e bootstrapping para validação.",
                                "Engenharia de Software: Testes automatizados em simulações."
                              ],
                              "realWorldApplication": "Em logística, validar simulações de filas em aeroportos para otimizar tempos de espera; em finanças, checar modelos de risco de mercado via testes em simulações Monte Carlo discretas; em telecomunicações, verificar redes de pacotes para garantir QoS esperada."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.4.2",
                            "name": "Avaliar suporte a planejamento de experimentos",
                            "description": "Examinar designs fatoriais, screening e otimização para experimentos de simulação, integrados ao software para eficiente exploração do espaço de parâmetros.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Planejamento de Experimentos",
                                  "subSteps": [
                                    "Estude designs fatoriais: defina níveis, fatores e interações.",
                                    "Aprenda sobre screening designs (ex: Plackett-Burman) para identificar fatores principais.",
                                    "Explore métodos de otimização como Response Surface Methodology (RSM) e algoritmos genéticos.",
                                    "Identifique métricas chave: número de runs, cobertura do espaço de parâmetros e eficiência computacional.",
                                    "Revise literatura sobre exploração de espaços de parâmetros em simulações discretas."
                                  ],
                                  "verification": "Resuma em um diagrama os tipos de designs e suas aplicações, confirmando compreensão com exemplos.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Livro 'Design and Analysis of Experiments' de Montgomery (capítulos iniciais)",
                                    "Artigos sobre DOE em simulações (PDFs gratuitos)",
                                    "Vídeos Khan Academy sobre estatística experimental"
                                  ],
                                  "tips": "Use mind maps para conectar conceitos; foque em simulações discretas como filas ou redes.",
                                  "learningObjective": "Dominar terminologia e princípios de designs fatoriais, screening e otimização para avaliação de software.",
                                  "commonMistakes": [
                                    "Confundir screening com full factorial",
                                    "Ignorar custo computacional em simulações",
                                    "Subestimar interações entre fatores"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Suporte a Designs Fatoriais e Screening no Software",
                                  "subSteps": [
                                    "Consulte documentação do software para módulos de DOE (Design of Experiments).",
                                    "Teste criação de um design fatorial 2^k: defina fatores, níveis e gere plano de runs.",
                                    "Implemente um screening design: configure e execute para 8-12 fatores.",
                                    "Verifique exportação de planos e integração com modelo de simulação discreta.",
                                    "Meça tempo de geração e escalabilidade para espaços grandes."
                                  ],
                                  "verification": "Gere e execute um design fatorial simples; valide runs gerados contra cálculo manual.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Software de simulação (ex: AnyLogic, Simio)",
                                    "Documentação oficial do software",
                                    "Modelos de exemplo de simulação discreta (fila M/M/1)"
                                  ],
                                  "tips": "Comece com poucos fatores para depuração rápida; use seeds fixos para reprodutibilidade.",
                                  "learningObjective": "Avaliar presença e usabilidade de ferramentas para designs fatoriais e screening.",
                                  "commonMistakes": [
                                    "Não testar com dados reais de simulação",
                                    "Ignorar limitações de paralelização",
                                    "Confundir suporte nativo com plugins externos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar Suporte a Otimização e Exploração de Espaço de Parâmetros",
                                  "subSteps": [
                                    "Configure otimizadores integrados: defina objetivo, restrições e algoritmo (ex: Nelder-Mead, GA).",
                                    "Integre com simulação: linke parâmetros do modelo ao otimizador e rode iterações.",
                                    "Analise cobertura: plote trajetórias de busca no espaço de parâmetros.",
                                    "Compare eficiência: runs totais vs. convergência em benchmarks conhecidos.",
                                    "Teste sensibilidade: varie ruído e observe robustez."
                                  ],
                                  "verification": "Otimize um parâmetro em modelo de simulação; registre convergência e valide ótimo local/global.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "Tutoriais de otimização no software",
                                    "Benchmark datasets para simulações discretas",
                                    "Ferramentas de plotagem (Matplotlib ou built-in)"
                                  ],
                                  "tips": "Monitore uso de CPU/RAM durante runs longos; use visualizações para inspecionar exploração.",
                                  "learningObjective": "Determinar se o software suporta otimização eficiente integrada à simulação.",
                                  "commonMistakes": [
                                    "Escolher algoritmos inadequados para dimensionalidade alta",
                                    "Não definir critérios de parada claros",
                                    "Ignorar multicolinearidade em parâmetros"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar, Testar e Documentar a Avaliação Completa",
                                  "subSteps": [
                                    "Combine designs e otimização em workflow: screening → factorial → otimização.",
                                    "Execute end-to-end em modelo real: simule sistema discreto como fábrica ou rede.",
                                    "Colete métricas: tempo total, qualidade de exploração (latin hypercube coverage).",
                                    "Compare com software alternativo (ex: manual via Python).",
                                    "Redija relatório com achados, scores e recomendações."
                                  ],
                                  "verification": "Produza relatório com gráficos de exploração e scores quantitativos (ex: efficiency score >80%).",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Modelo de simulação complexo",
                                    "Templates de relatório DOE",
                                    "Ferramentas de comparação (Excel ou R)"
                                  ],
                                  "tips": "Automatize com scripts se possível; priorize cenários de alto impacto.",
                                  "learningObjective": "Sintetizar avaliação holística do suporte a planejamento de experimentos.",
                                  "commonMistakes": [
                                    "Focar só em features sem testar performance",
                                    "Não considerar usabilidade para não-especialistas",
                                    "Omitir trade-offs custo-benefício"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um software como AnyLogic, avalie suporte criando um design fatorial 2^3 para parâmetros de chegada/serviços em uma fila M/M/1, seguido de screening para 10 fatores em uma rede de produção, e otimize throughput maximizando com GA, medindo tempo de exploração vs. grid search manual.",
                              "finalVerifications": [
                                "Software gera designs fatoriais e screening sem erros para até 20 fatores.",
                                "Otimização converge em <100 runs para problemas 5D.",
                                "Integração permite automação end-to-end com simulação discreta.",
                                "Cobertura do espaço de parâmetros >90% em visualizações.",
                                "Tempo de execução escalável para simulações longas.",
                                "Relatório inclui métricas reprodutíveis e benchmarks."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos designs gerados (100% match com teoria).",
                                "Eficiência computacional (runs <20% de grid equivalente).",
                                "Usabilidade da interface (tempo setup <10min).",
                                "Robustez a falhas (error handling em params inválidos).",
                                "Escalabilidade para espaços multidimensionais (>10D).",
                                "Integração seamless com engine de simulação."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Análise de variância (ANOVA) em designs experimentais.",
                                "Engenharia Industrial: Otimização de processos de manufatura.",
                                "Ciência de Dados: Exploração de hiperparâmetros em ML.",
                                "Física Computacional: Simulações de partículas discretas.",
                                "Gestão de Projetos: Planejamento eficiente de testes."
                              ],
                              "realWorldApplication": "Em indústrias farmacêuticas, otimizar formulações de drogas via screening e RSM em simulações de liberação discreta; em logística, planejar experimentos para roteirização de frotas reduzindo custos operacionais em 15-20%."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.4.3",
                            "name": "Verificar integração com redução de variância",
                            "description": "Testar métodos como common random numbers, antithetic variates e control variates diretamente no software para melhorar precisão das estimativas em validações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos de Técnicas de Redução de Variância",
                                  "subSteps": [
                                    "Estude common random numbers (CRN): entenda como usar a mesma sequência de números aleatórios em múltiplas simulações para reduzir variância.",
                                    "Analise antithetic variates (AV): aprenda a parear simulações com números aleatórios complementares (ex: U e 1-U) para induzir correlação negativa.",
                                    "Revise control variates (CV): identifique variáveis de controle conhecidas analiticamente e ajuste estimativas para reduzir variância.",
                                    "Compare as técnicas: note quando cada uma é mais eficaz (CRN para comparações, AV para independência, CV para bias zero).",
                                    "Reúna referências teóricas de livros como 'Simulation' de Ross."
                                  ],
                                  "verification": "Resuma cada técnica em um parágrafo e liste 2 vantagens/desvantagens por técnica em um documento.",
                                  "estimatedTime": "1-2 hours",
                                  "materials": [
                                    "Livro 'Simulation' de Sheldon Ross (capítulos relevantes)",
                                    "Artigos acadêmicos sobre variance reduction",
                                    "Notebook Jupyter para anotações"
                                  ],
                                  "tips": "Use diagramas para visualizar como as sequências aleatórias são compartilhadas ou pareadas.",
                                  "learningObjective": "Dominar os princípios teóricos das técnicas CRN, AV e CV para aplicação em software.",
                                  "commonMistakes": [
                                    "Confundir AV com CRN",
                                    "Ignorar requisitos de independência nas réplicas",
                                    "Não considerar o custo computacional extra"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Modelo de Simulação Baseline",
                                  "subSteps": [
                                    "Selecione ou crie um modelo simples no software (ex: fila M/M/1 com chegada λ=1, serviço μ=1.2).",
                                    "Implemente simulação padrão com réplicas independentes (n=1000) para estimar tempo médio de espera W.",
                                    "Execute múltiplas rodadas e calcule média e variância da estimativa de W.",
                                    "Registre o desvio padrão da média amostral como métrica de precisão baseline.",
                                    "Salve resultados em tabela: rodadas, média(W), var(W)."
                                  ],
                                  "verification": "Confirme que a variância baseline é calculada corretamente e plote histograma das estimativas.",
                                  "estimatedTime": "2-3 hours",
                                  "materials": [
                                    "Software de simulação (ex: SimPy em Python, Arena)",
                                    "Computador com ambiente configurado",
                                    "Planilha Excel ou Pandas para análise"
                                  ],
                                  "tips": "Use sementes fixas para reprodutibilidade inicial.",
                                  "learningObjective": "Estabelecer uma baseline confiável para comparação com técnicas de redução de variância.",
                                  "commonMistakes": [
                                    "Réplicas insuficientes levando a variância subestimada",
                                    "Não inicializar o sistema em steady-state",
                                    "Escala errada nos parâmetros λ/μ"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e Testar Common Random Numbers (CRN)",
                                  "subSteps": [
                                    "Configure o gerador de números aleatórios para usar a mesma semente em todas as réplicas.",
                                    "Execute simulações pareadas com o baseline, mantendo a mesma sequência para chegadas e serviços.",
                                    "Calcule a variância da diferença entre estimativas pareadas.",
                                    "Compare variância reduzida vs baseline (espera-se redução >20%).",
                                    "Teste sensibilidade variando n de réplicas."
                                  ],
                                  "verification": "Variância da estimativa CRN < 70% da baseline; gere relatório com tabelas comparativas.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Software de simulação com controle de sementes",
                                    "Scripts Python para automação",
                                    "Ferramentas de plotagem (Matplotlib)"
                                  ],
                                  "tips": "Verifique se o software suporta streams aleatórios independentes por componente.",
                                  "learningObjective": "Aplicar CRN para melhorar precisão em comparações de sistemas.",
                                  "commonMistakes": [
                                    "Não sincronizar todos os streams aleatórios",
                                    "Usar réplicas ímpares",
                                    "Interpretar redução como bias"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar Antithetic Variates (AV) e Control Variates (CV)",
                                  "subSteps": [
                                    "Para AV: pareie réplicas com U e 1-U; execute e calcule covariância negativa.",
                                    "Para CV: identifique controle (ex: número de chegadas); estime covariância e ajuste estimativa de W.",
                                    "Implemente ambos no software e rode experimentos com n=1000.",
                                    "Calcule fatores de redução de variância para cada (ρ = 1 - var_reduzida/var_baseline).",
                                    "Documente limitações do software na implementação."
                                  ],
                                  "verification": "Confirme ρ > 0.1 para AV/CV; plote intervalos de confiança sobrepostos.",
                                  "estimatedTime": "3 hours",
                                  "materials": [
                                    "Documentação do software para variates",
                                    "Código-fonte de geradores aleatórios",
                                    "Bibliotecas NumPy/SciPy"
                                  ],
                                  "tips": "Para CV, valide o valor analítico do controle antes.",
                                  "learningObjective": "Integrar AV e CV para validação precisa em simulações discretas.",
                                  "commonMistakes": [
                                    "Pareamento incorreto em AV",
                                    "Escolha ruim de controle em CV",
                                    "Não normalizar pelo custo computacional"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar Resultados e Verificar Integração Geral",
                                  "subSteps": [
                                    "Compile tabelas comparativas: baseline vs CRN vs AV vs CV (média, var, tempo de CPU).",
                                    "Avalie suporte do software: facilidade de configuração, estabilidade, documentação.",
                                    "Teste em modelo mais complexo (ex: rede de filas).",
                                    "Conclua se a integração é robusta para validações reais.",
                                    "Gere relatório final com gráficos de variância.",
                                    "verification]: "
                                  ],
                                  "estimatedTime": "1-2 hours",
                                  "materials": [
                                    "Ferramentas de análise estatística (R ou Python statsmodels)",
                                    "Templates de relatório"
                                  ],
                                  "tips": "Use boxplots para visualizar reduções de variância.",
                                  "learningObjective": "Avaliar holisticamente a integração de redução de variância no software.",
                                  "commonMistakes": [
                                    "Ignorar overhead computacional",
                                    "Concluir sem testes múltiplos",
                                    "Não considerar escalabilidade"
                                  ],
                                  "verification": [
                                    "Tabelas comparativas (baseline vs CRN vs AV vs CV) geradas com métricas (média, variância, tempo CPU).",
                                    "Relatório de suporte do software (configuração, estabilidade, docs) documentado.",
                                    "Testes em modelo complexo (ex: rede de filas) realizados e resultados analisados.",
                                    "Conclusão explícita sobre robustez da integração para validações reais.",
                                    "Relatório final com gráficos de variância (ex: boxplots) produzido e salvo."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um software como SimPy (Python), simule uma fila M/M/1 com λ=4/h, μ=5/h. Estime tempo médio de espera com 500 réplicas baseline (var≈2.5). Aplique CRN (mesma semente): var reduz para 1.2; AV: var=1.0; CV usando N_chegadas: var=0.8. Verifique redução consistente em 10 rodadas.",
                              "finalVerifications": [
                                "Variância reduzida em pelo menos 15% para cada técnica vs baseline.",
                                "Intervalos de confiança mais estreitos e sobrepostos corretamente.",
                                "Software permite configuração sem erros de streams aleatórios.",
                                "Resultados reprodutíveis com sementes fixas.",
                                "Relatório inclui fatores de eficiência (redução var / custo CPU).",
                                "Testes em steady-state confirmam ausência de bias."
                              ],
                              "assessmentCriteria": [
                                "Precisão na implementação teórica (80%+ acerto em conceitos).",
                                "Redução de variância quantificada corretamente (>10% médio).",
                                "Análise estatística robusta (testes t ou plots).",
                                "Relatório claro com evidências visuais.",
                                "Identificação de limitações do software.",
                                "Aplicação criativa em modelo não-trivial."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Cálculo de covariâncias e variâncias amostrais.",
                                "Programação: Controle de geradores pseudo-aleatórios e streams.",
                                "Análise Numérica: Métodos de aceleração em Monte Carlo.",
                                "Probabilidade: Propriedades de transformadas antithetic.",
                                "Engenharia de Software: Avaliação de features em ferramentas especializadas."
                              ],
                              "realWorldApplication": "Em simulações de manufatura (ex: Arena para linhas de produção), CRN/AV/CV reduzem tempo de validação de dias para horas, permitindo otimização precisa de throughput em fábricas reais como automotivas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.5",
                    "name": "Métodos de Comparação entre Softwares de Simulação",
                    "description": "Benchmarking, testes de performance e análise de custo-benefício.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.5.1",
                        "name": "Benchmarking em Softwares de Simulação",
                        "description": "Benchmarking envolve a definição e execução de testes padronizados para comparar o desempenho de diferentes softwares de simulação discreta em cenários controlados, permitindo uma avaliação objetiva de capacidades.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.1.1",
                            "name": "Definir benchmarks relevantes",
                            "description": "Identificar e selecionar métricas e cenários de teste apropriados para softwares de simulação, como modelos de filas ou sistemas de produção, baseados em referências como Banks et al.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos fundamentais de benchmarks em simulação",
                                  "subSteps": [
                                    "Ler capítulos relevantes de referências como Banks et al. sobre validação e benchmarking em simulação discreta.",
                                    "Identificar definições de benchmarks, métricas de performance e cenários padrão para sistemas como filas e produção.",
                                    "Anotar diferenças entre validação estatística e benchmarking comparativo.",
                                    "Listar exemplos de benchmarks comuns em softwares como Arena ou Simio.",
                                    "Revisar glossário de termos como throughput, utilidade e tempo de ciclo."
                                  ],
                                  "verification": "Criar um mapa mental ou resumo de 1 página com definições chave e exemplos anotados.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livro 'Discrete-Event System Simulation' de Banks et al., acesso online a capítulos ou PDFs, caderno ou ferramenta de mind mapping como XMind.",
                                  "tips": "Comece pelas seções de validação para contextualizar benchmarks.",
                                  "learningObjective": "Dominar terminologia e propósitos de benchmarks em simulação de sistemas discretos.",
                                  "commonMistakes": "Confundir benchmarks com calibração de modelo; focar apenas em software sem contexto de sistemas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o contexto do software e sistema alvo",
                                  "subSteps": [
                                    "Descrever o software de simulação (ex: Arena, Simul8) e suas capacidades.",
                                    "Identificar o tipo de sistema (ex: modelo de fila M/M/1 ou linha de produção).",
                                    "Listar objetivos do benchmark: precisão, velocidade, escalabilidade.",
                                    "Coletar dados históricos ou requisitos do sistema real.",
                                    "Mapear variáveis de entrada/saída relevantes."
                                  ],
                                  "verification": "Produzir um relatório de 1 página com análise do software e sistema, incluindo tabela de variáveis.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Documentação do software (manuais Arena/Simul8), planilha Excel para tabelas.",
                                  "tips": "Use diagramas de fluxo para visualizar o sistema.",
                                  "learningObjective": "Alinhar benchmarks ao contexto específico do software e aplicação.",
                                  "commonMistakes": "Ignorar limitações do software; generalizar sem análise do sistema."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Selecionar métricas apropriadas",
                                  "subSteps": [
                                    "Categorizar métricas: estatísticas de fila (tempo médio de espera, comprimento), produção (throughput, taxa de ociosidade).",
                                    "Priorizar 5-10 métricas baseadas em Banks et al. e relevância ao sistema.",
                                    "Definir thresholds aceitáveis para cada métrica.",
                                    "Verificar compatibilidade com o software.",
                                    "Justificar escolhas com citações de literatura."
                                  ],
                                  "verification": "Criar tabela com métricas selecionadas, fórmulas, thresholds e justificativas.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Referências bibliográficas, calculadora ou Python para fórmulas, template de tabela em Google Sheets.",
                                  "tips": "Escolha métricas sensíveis ao modelo para detectar diferenças.",
                                  "learningObjective": "Escolher métricas que capturem performance chave de forma mensurável.",
                                  "commonMistakes": "Selecionar métricas irrelevantes ou excessivas; não definir thresholds."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir cenários de teste realistas",
                                  "subSteps": [
                                    "Criar 3-5 cenários variando parâmetros (ex: chegada Poisson, falhas de máquina).",
                                    "Basear em casos de Banks et al. ou literatura similar.",
                                    "Especificar condições iniciais, runs de simulação (ex: 30 replicatas).",
                                    "Garantir cenários cobrem casos nominais, edge e estresse.",
                                    "Documentar seeds para reprodutibilidade."
                                  ],
                                  "verification": "Elaborar documento com descrição detalhada dos cenários em formato tabular.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Software de simulação para prototipagem rápida, referências como Banks.",
                                  "tips": "Inclua cenários que testem escalabilidade com aumento de entidades.",
                                  "learningObjective": "Construir cenários que validem robustez do software.",
                                  "commonMistakes": "Cenários muito simples; falta de variação ou reprodutibilidade."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar e validar o conjunto de benchmarks",
                                  "subSteps": [
                                    "Compilar métricas e cenários em um framework unificado.",
                                    "Revisar contra critérios de Banks et al. (relevância, completude).",
                                    "Testar preliminarmente um cenário no software.",
                                    "Solicitar feedback de pares ou autoavaliação.",
                                    "Ajustar baseado em gaps identificados."
                                  ],
                                  "verification": "Gerar documento final de benchmarks com todas as seções e teste preliminar documentado.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Word/Google Docs para documento, software de simulação.",
                                  "tips": "Use versionamento no documento para rastrear mudanças.",
                                  "learningObjective": "Finalizar benchmarks acionáveis e defensáveis.",
                                  "commonMistakes": "Pular validação; documentação incompleta."
                                }
                              ],
                              "practicalExample": "Para benchmarkar o Arena em um modelo de fila M/M/1 (chegada λ=5/h, serviço μ=6/h), selecione métricas como Lq (comprimento médio fila=5), Wq (tempo espera=1h) de Banks et al.; cenários: nominal, alta carga (λ=5.5), falha servidor (10% downtime). Rode 30 replicatas, verifique se Lq está dentro ±10% da teoria (ρ/(1-ρ)=5).",
                              "finalVerifications": [
                                "Lista de 5+ métricas com fórmulas e thresholds explícitos.",
                                "3-5 cenários variados cobrindo casos nominais e estresse.",
                                "Justificativas citando Banks et al. ou fontes similares.",
                                "Compatibilidade confirmada com software alvo.",
                                "Teste preliminar em pelo menos um cenário com resultados anotados.",
                                "Documentação completa e reprodutível."
                              ],
                              "assessmentCriteria": [
                                "Relevância das métricas ao sistema (80% alinhadas a objetivos).",
                                "Completude dos cenários (cobertura de variações chave).",
                                "Precisão teórica (thresholds baseados em literatura).",
                                "Justificativa robusta com referências (mínimo 3 citações).",
                                "Clareza e estrutura da documentação.",
                                "Viabilidade prática (tempo de execução razoável)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Análise de variância e intervalos de confiança em replicatas.",
                                "Programação: Scripts para automação de runs em linguagens como Python/SimPy.",
                                "Engenharia Industrial: Otimização de filas e produção lean.",
                                "Ciência de Dados: Seleção de KPIs e visualização de resultados."
                              ],
                              "realWorldApplication": "Em indústrias como logística (otimizar filas em portos com Simio) ou manufatura (benchmark Arena vs. FlexSim para linhas de montagem automotiva), garantindo escolha do software que minimiza tempo de ciclo em 15-20% com precisão validada."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.1.2",
                            "name": "Executar benchmarks comparativos",
                            "description": "Implementar e rodar testes padronizados em múltiplos softwares, registrando resultados em tabelas para comparação direta de eficiência e precisão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e preparar testes de benchmark padronizados",
                                  "subSteps": [
                                    "Identificar cenários representativos de simulações discretas (ex: filas, redes de Petri)",
                                    "Definir métricas chave: tempo de execução, uso de memória, precisão numérica e escalabilidade",
                                    "Preparar conjuntos de dados de entrada padronizados e variados (pequenos, médios, grandes)",
                                    "Documentar os critérios de seleção dos testes para reproducibilidade",
                                    "Validar a neutralidade dos testes em relação aos softwares"
                                  ],
                                  "verification": "Lista documentada de testes, métricas e dados de entrada aprovada e salva em arquivo.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Documentação oficial dos softwares de simulação",
                                    "Literatura acadêmica sobre benchmarks em simulações discretas",
                                    "Planilha ou editor de texto para documentação"
                                  ],
                                  "tips": "Priorize testes que reflitam aplicações reais; inclua casos de borda para testar robustez.",
                                  "learningObjective": "Compreender como selecionar testes imparciais e representativos para comparações válidas.",
                                  "commonMistakes": [
                                    "Escolher testes enviesados para um software específico",
                                    "Ignorar métricas de precisão além do tempo de execução",
                                    "Não variar tamanhos de dados para testar escalabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar o ambiente de teste controlado",
                                  "subSteps": [
                                    "Instalar e configurar múltiplos softwares de simulação (ex: MATLAB SimEvents, Python com SimPy)",
                                    "Padronizar hardware e SO para todas as execuções (mesma máquina, sem outros processos)",
                                    "Criar scripts ou interfaces para automação das execuções",
                                    "Executar testes de baseline para calibrar o ambiente",
                                    "Verificar configurações idênticas de parâmetros iniciais"
                                  ],
                                  "verification": "Relatório de configuração confirmando ambiente idêntico para todos os softwares.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Máquina com especificações fixas (CPU, RAM documentadas)",
                                    "Instaladores dos softwares de simulação",
                                    "Ferramentas de monitoramento (Task Manager, htop)"
                                  ],
                                  "tips": "Use ambientes virtuais (Docker) para isolar execuções e garantir reproducibilidade.",
                                  "learningObjective": "Dominar a configuração de ambientes controlados para resultados confiáveis.",
                                  "commonMistakes": [
                                    "Executar em máquinas diferentes alterando resultados",
                                    "Não fechar processos em background afetando performance",
                                    "Configurações de parâmetros inconsistentes entre softwares"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar os benchmarks nos softwares",
                                  "subSteps": [
                                    "Rodar cada teste em todos os softwares selecionados, repetindo 5-10 vezes para médias",
                                    "Registrar métricas automaticamente via scripts (tempo, memória, saída numérica)",
                                    "Monitorar e anotar anomalias durante as execuções",
                                    "Garantir que todas as repetições usem sementes aleatórias iguais para fairness",
                                    "Salvar logs brutos de cada execução"
                                  ],
                                  "verification": "Arquivos de logs e dados brutos coletados para todos os testes e softwares.",
                                  "estimatedTime": "3-5 horas",
                                  "materials": [
                                    "Scripts de automação (Python, MATLAB scripts)",
                                    "Ferramentas de profiling (timeit, cProfile)",
                                    "Espaço de armazenamento para logs"
                                  ],
                                  "tips": "Automatize com loops para evitar erros manuais; rode em horários de baixa carga da máquina.",
                                  "learningObjective": "Executar testes de forma sistemática e registrar dados de performance com precisão.",
                                  "commonMistakes": [
                                    "Poucas repetições levando a variância alta",
                                    "Sementes aleatórias diferentes invalidando comparações",
                                    "Não registrar logs completos para depuração"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Registrar resultados em tabelas e realizar comparação inicial",
                                  "subSteps": [
                                    "Compilar dados em tabelas comparativas (colunas: software, teste, métrica, média, desvio)",
                                    "Calcular estatísticas descritivas (média, mediana, intervalo de confiança)",
                                    "Gerar gráficos (boxplots, barras) para visualização",
                                    "Identificar vencedores por métrica e cenário",
                                    "Documentar observações qualitativas (facilidade de uso, erros)"
                                  ],
                                  "verification": "Tabelas e gráficos finais salvos e validados contra dados brutos.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Planilhas (Excel, Google Sheets) ou bibliotecas (Pandas, Matplotlib)",
                                    "Ferramentas de visualização (Python plotting, MATLAB plots)"
                                  ],
                                  "tips": "Use formatação condicional nas tabelas para destacar diferenças significativas (>10%).",
                                  "learningObjective": "Analisar e apresentar dados de benchmarks de forma clara e objetiva.",
                                  "commonMistakes": [
                                    "Erros de transcrição de dados brutos",
                                    "Ignorar desvios padrão em análises",
                                    "Gráficos enganosos por escalas inadequadas"
                                  ]
                                }
                              ],
                              "practicalExample": "Compare MATLAB SimEvents e Python com SimPy em uma simulação de fila M/M/1 com 1000 chegadas: meça tempo de execução para 10 repetições, precisão da média de tempo de espera (erro <1%) e uso de memória, registrando em tabela com médias e desvios.",
                              "finalVerifications": [
                                "Tabelas comparativas completas com todas as métricas e repetições",
                                "Gráficos visuais confirmando tendências de performance",
                                "Conclusões baseadas em dados, sem viés",
                                "Reprodutibilidade: outro usuário pode rodar e obter resultados similares",
                                "Relatório final com resumo executivo",
                                "Dados brutos arquivados para auditoria"
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude dos testes executados (100% cobertura)",
                                "Consistência do ambiente de teste (desvios <5%)",
                                "Qualidade das tabelas e análises estatísticas",
                                "Imparcialidade na comparação (todos softwares tratados igualmente)",
                                "Clareza e profissionalismo da documentação",
                                "Eficiência no tempo total de execução do processo"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Desenvolvimento de scripts de automação e profiling",
                                "Estatística: Cálculo de médias, desvios e testes de significância",
                                "Engenharia de Software: Práticas de teste e avaliação de ferramentas",
                                "Gestão de Projetos: Planejamento e documentação de experimentos",
                                "Ciência de Dados: Visualização e análise de dados experimentais"
                              ],
                              "realWorldApplication": "Em empresas de engenharia e pesquisa, como na escolha de software para otimizar simulações de tráfego em sistemas logísticos, reduzindo custos computacionais em projetos de grande escala."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.1.3",
                            "name": "Analisar resultados de benchmarking",
                            "description": "Interpretar dados de benchmarks, utilizando gráficos e estatísticas para identificar forças e fraquezas de cada software em relação a linguagens de simulação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Coletar e Organizar Dados de Benchmark",
                                  "subSteps": [
                                    "Reunir todos os resultados brutos de benchmarks executados nos softwares de simulação.",
                                    "Padronizar formatos de dados, convertendo unidades para tempo (segundos), memória (MB) e precisão (erro %).",
                                    "Criar uma tabela comparativa com colunas para cada software e linhas para métricas (ex: tempo de execução, uso de CPU).",
                                    "Verificar integridade dos dados, removendo valores inválidos ou duplicados.",
                                    "Categorizar métricas em performance, precisão e escalabilidade."
                                  ],
                                  "verification": "Tabela organizada e limpa exportada em formato CSV ou Excel, com pelo menos 5 métricas principais comparadas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Planilha Excel/Google Sheets",
                                    "Arquivos de log de benchmarks",
                                    "Editor de texto para limpeza"
                                  ],
                                  "tips": "Use fórmulas para calcular normalizações e mantenha um log de alterações nos dados.",
                                  "learningObjective": "Estruturar dados de benchmark de forma limpa e comparável para análise subsequente.",
                                  "commonMistakes": [
                                    "Ignorar outliers que afetam médias",
                                    "Misturar unidades de medida inconsistentes",
                                    "Omitir metadados como hardware usado"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar Visualizações Gráficas dos Dados",
                                  "subSteps": [
                                    "Selecionar tipos de gráficos adequados: barras para comparações absolutas, boxplots para variabilidade, linhas para escalabilidade.",
                                    "Gerar pelo menos 3 gráficos principais (ex: tempo de execução por software, uso de memória, precisão).",
                                    "Posicionar softwares lado a lado para comparação direta.",
                                    "Adicionar títulos, labels nos eixos, legendas e anotações para destaques.",
                                    "Exportar gráficos em alta resolução para relatórios."
                                  ],
                                  "verification": "Conjunto de 3-5 gráficos gerados e salvos, interpretáveis sem texto adicional.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python com bibliotecas Matplotlib e Seaborn",
                                    "ou Excel/R",
                                    "Dados organizados do Step 1"
                                  ],
                                  "tips": "Use cores consistentes para cada software e evite sobrecarregar um gráfico com muitas métricas.",
                                  "learningObjective": "Visualizar dados de benchmark para identificar padrões visuais de performance.",
                                  "commonMistakes": [
                                    "Escalas inadequadas que distorcem comparações",
                                    "Falta de legendas levando a confusão",
                                    "Gráficos 3D desnecessários que obscurecem dados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar Análise Estatística Descritiva e Inferencial",
                                  "subSteps": [
                                    "Calcular estatísticas descritivas: média, mediana, desvio padrão e intervalos de confiança para cada métrica.",
                                    "Aplicar testes estatísticos como t-test ou ANOVA para comparar médias entre softwares.",
                                    "Computar scores normalizados (ex: z-scores) para ranquear softwares.",
                                    "Identificar correlações entre métricas (ex: tempo vs. precisão).",
                                    "Documentar p-valores e significância (ex: p < 0.05)."
                                  ],
                                  "verification": "Tabela de estatísticas com testes aplicados e interpretações breves.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com Pandas, NumPy e SciPy",
                                    "ou R",
                                    "Gráficos do Step 2"
                                  ],
                                  "tips": "Sempre verifique premissas dos testes (normalidade, homogeneidade de variâncias).",
                                  "learningObjective": "Aplicar ferramentas estatísticas para quantificar diferenças nos benchmarks.",
                                  "commonMistakes": [
                                    "Confundir correlação com causalidade",
                                    "Ignorar múltiplos testes sem correção (Bonferroni)",
                                    "Usar médias sem considerar distribuições assimétricas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Resultados e Identificar Forças e Fraquezas",
                                  "subSteps": [
                                    "Comparar performances dos softwares com benchmarks de linguagens de simulação (ex: Python com SimPy, MATLAB).",
                                    "Listar forças (ex: software A rápido em grandes simulações) e fraquezas (ex: software B alto uso de memória).",
                                    "Priorizar forças/fraquezas baseado em critérios do projeto (ex: custo computacional vs. facilidade de uso).",
                                    "Redigir conclusões acionáveis e recomendações.",
                                    "Validar interpretações cruzando gráficos e estatísticas."
                                  ],
                                  "verification": "Relatório final de 1-2 páginas resumindo forças, fraquezas e recomendações com evidências.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Resultados dos Steps 1-3",
                                    "Benchmarks de referência de linguagens",
                                    "Editor de texto"
                                  ],
                                  "tips": "Considere contexto do usuário final; nem sempre o mais rápido é o melhor.",
                                  "learningObjective": "Sintetizar análises para decisões informadas sobre softwares de simulação.",
                                  "commonMistakes": [
                                    "Viés de confirmação ignorando dados contrários",
                                    "Generalizações sem considerar cenários específicos",
                                    "Omitir trade-offs entre métricas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um projeto de simulação de filas em um call center, compare AnyLogic, Arena e Simio usando benchmarks de tempo de execução (Arena: 45s médio), uso de memória (AnyLogic: 500MB) e precisão (Simio: 2% erro). Gráficos mostram Arena mais rápido, mas AnyLogic superior em cenários complexos vs. SimPy (Python: 120s). Conclusão: Arena para performance simples.",
                              "finalVerifications": [
                                "Explica corretamente padrões em gráficos de benchmark.",
                                "Identifica forças/fraquezas com suporte estatístico.",
                                "Compara adequadamente com linguagens de simulação.",
                                "Gera recomendações baseadas em trade-offs.",
                                "Detecta e corrige inconsistências nos dados.",
                                "Documenta processo de análise de forma reproduzível."
                              ],
                              "assessmentCriteria": [
                                "Precisão e correção na interpretação de dados e estatísticas (30%).",
                                "Clareza e efetividade das visualizações (25%).",
                                "Profundidade na identificação de forças/fraquezas (20%).",
                                "Uso apropriado de testes estatísticos (15%).",
                                "Qualidade do relatório final e recomendações (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Análise descritiva e testes de hipótese.",
                                "Programação: Manipulação de dados com Python/R.",
                                "Gestão de Projetos: Tomada de decisão baseada em evidências.",
                                "Engenharia de Software: Avaliação de ferramentas.",
                                "Matemática Computacional: Modelagem e simulação."
                              ],
                              "realWorldApplication": "Engenheiros de manufatura e logística usam análise de benchmarking para selecionar softwares como AnyLogic ou FlexSim, otimizando simulações de supply chain que reduzem custos operacionais em 15-20% ao escolher a ferramenta mais eficiente para cenários reais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.5.2",
                        "name": "Testes de Performance",
                        "description": "Testes de performance avaliam aspectos como velocidade de execução, consumo de recursos e escalabilidade de softwares de simulação em experimentos variados.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.2.1",
                            "name": "Medir tempo de execução e throughput",
                            "description": "Configurar testes cronometrados para simulações discretas, medindo tempo de CPU e número de eventos processados por segundo em diferentes cargas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e o modelo de simulação discreta",
                                  "subSteps": [
                                    "Selecionar uma ferramenta de simulação discreta como SimPy (Python) ou Arena.",
                                    "Definir um modelo simples de simulação, como uma fila única com chegadas Poisson e serviço exponencial.",
                                    "Configurar parâmetros iniciais: taxa de chegada λ=5 eventos/min, tempo de serviço μ=3 min.",
                                    "Implementar o modelo básico sem medições.",
                                    "Executar uma simulação de teste para validar o modelo (ex: 1000 eventos)."
                                  ],
                                  "verification": "Modelo roda sem erros e gera saídas esperadas (ex: número total de eventos processados).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com SimPy instalado",
                                    "Editor de código (VS Code ou Jupyter)",
                                    "Documentação do SimPy"
                                  ],
                                  "tips": "Comece com um modelo pequeno para evitar complexidade inicial; use seeds fixos para reprodutibilidade.",
                                  "learningObjective": "Configurar um ambiente funcional para simulações discretas.",
                                  "commonMistakes": [
                                    "Ignorar dependências de bibliotecas",
                                    "Não definir distribuições probabilísticas corretamente",
                                    "Esquecer de importar módulos necessários"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar medição de tempo de execução (CPU time)",
                                  "subSteps": [
                                    "Importar módulos de tempo: timeit ou time.perf_counter() no Python.",
                                    "Envolver o loop principal da simulação com start_time = time.perf_counter() e end_time = time.perf_counter().",
                                    "Calcular cpu_time = end_time - start_time.",
                                    "Registrar o tempo em um log ou variável de saída.",
                                    "Executar múltiplas runs (ex: 10) e calcular média para reduzir variância."
                                  ],
                                  "verification": "Tempo medido é consistente entre runs (±5%) e em segundos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código do modelo do Step 1",
                                    "Biblioteca time do Python"
                                  ],
                                  "tips": "Use time.perf_counter() para precisão em multi-thread; evite time.time() por ser menos preciso.",
                                  "learningObjective": "Medir tempo de CPU de forma precisa e reprodutível em simulações.",
                                  "commonMistakes": [
                                    "Usar time.time() em vez de perf_counter()",
                                    "Medir apenas uma run sem médias",
                                    "Incluir tempo de I/O no CPU time"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar medição de throughput (eventos por segundo)",
                                  "subSteps": [
                                    "Contar o número total de eventos processados (ex: chegadas + saídas).",
                                    "Calcular throughput = total_events / cpu_time.",
                                    "Adicionar contadores no modelo: evento_chegada() e evento_saida().",
                                    "Integrar com a medição de tempo do Step 2.",
                                    "Testar com o modelo simples para validar (ex: throughput esperado ~1.67 eventos/seg se λ/μ ajustado)."
                                  ],
                                  "verification": "Throughput calculado é numérico positivo e coerente com parâmetros do modelo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código atualizado dos Steps 1-2"
                                  ],
                                  "tips": "Garanta que contadores sejam incrementados atomicamente para evitar race conditions em simulações paralelas.",
                                  "learningObjective": "Quantificar eficiência de processamento em simulações discretas.",
                                  "commonMistakes": [
                                    "Contar apenas chegadas, ignorando saídas",
                                    "Dividir por tempo wall-clock em vez de CPU",
                                    "Não zerar contadores entre runs"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar testes em diferentes cargas e analisar resultados",
                                  "subSteps": [
                                    "Definir cargas: baixa (λ=2), média (λ=5), alta (λ=8).",
                                    "Rodar simulações para cada carga (ex: 10 runs de 10000 eventos cada).",
                                    "Coletar dados em tabela: carga, cpu_time médio, throughput médio.",
                                    "Plotar gráficos: throughput vs. carga usando Matplotlib.",
                                    "Analisar: identificar gargalos quando throughput cai."
                                  ],
                                  "verification": "Tabela e gráficos gerados; throughput diminui com carga alta como esperado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código completo",
                                    "Pandas e Matplotlib para análise"
                                  ],
                                  "tips": "Use interval confidence (ex: ±std) nas médias para robustez estatística.",
                                  "learningObjective": "Avaliar performance sob variação de carga em simulações.",
                                  "commonMistakes": [
                                    "Poucas runs levando a variância alta",
                                    "Escalas erradas nos gráficos",
                                    "Ignorar warm-up period na simulação"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado usando SimPy: configure chegadas de clientes (λ=10/hora), meça CPU time para 5000 clientes e calcule throughput. Para carga alta (λ=20), observe throughput cair de 0.8 para 0.4 clientes/seg devido a saturação.",
                              "finalVerifications": [
                                "Tempos de CPU medidos com precisão <1% de variação entre runs idênticas.",
                                "Throughput calculado corretamente como eventos/segundo em todas as cargas.",
                                "Gráficos mostram relação inversa entre carga e throughput.",
                                "Resultados reprodutíveis com seeds fixos.",
                                "Análise identifica limite de performance do modelo.",
                                "Relatório inclui médias, desvios e interpretações."
                              ],
                              "assessmentCriteria": [
                                "Precisão das medições (erro <5% em benchmarks conhecidos).",
                                "Cobertura de múltiplas cargas (pelo menos 3 níveis).",
                                "Uso correto de métricas (CPU time vs. wall time).",
                                "Qualidade dos gráficos e tabelas (legendas, eixos claros).",
                                "Interpretação dos resultados (explicação de gargalos).",
                                "Código limpo e comentado."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Uso de bibliotecas Python (time, SimPy).",
                                "Estatística: Cálculo de médias, desvios e intervalos de confiança.",
                                "Engenharia de Software: Benchmarking e profiling de performance.",
                                "Matemática: Modelos de filas (M/M/1) e teoria de filas.",
                                "Ciência de Dados: Visualização de dados com Matplotlib."
                              ],
                              "realWorldApplication": "Otimizar simuladores em logística (ex: medir throughput de um armazém automatizado para escalar robôs) ou em telecomunicações (testar switches de rede sob pico de tráfego para evitar congestionamentos)."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.2.2",
                            "name": "Avaliar uso de memória e escalabilidade",
                            "description": "Monitorar consumo de RAM e comportamento em modelos de grande escala, comparando softwares como GPSS ou Arena com base em Kelton e Law.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos Teóricos de Memória e Escalabilidade",
                                  "subSteps": [
                                    "Estude definições de uso de memória (RAM) e escalabilidade em simulações discretas conforme Kelton e Law.",
                                    "Revise métricas chave: pico de RAM, uso médio, crescimento com tamanho do modelo.",
                                    "Analise exemplos de bottlenecks em simulações de eventos discretos (DES).",
                                    "Compare abordagens de GPSS (baseado em transações) e Arena (baseado em processos).",
                                    "Anote diferenças teóricas em alocação de memória entre os softwares."
                                  ],
                                  "verification": "Resumo escrito com definições e comparações teóricas, validado contra capítulos relevantes de Kelton e Law.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livro 'Simulation Modeling and Analysis' de Kelton e Law (capítulos sobre performance), PDFs de manuais GPSS/Arena.",
                                  "tips": "Use destaques para métricas chave e crie um glossário pessoal.",
                                  "learningObjective": "Dominar conceitos teóricos para contextualizar medições práticas.",
                                  "commonMistakes": "Confundir RAM com CPU; ignorar overhead de inicialização."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Ambiente de Teste e Ferramentas de Monitoramento",
                                  "subSteps": [
                                    "Instale GPSS e Arena em máquina com pelo menos 16GB RAM.",
                                    "Configure ferramentas de monitoramento: Task Manager (Windows), htop/top (Linux), ou perfmon.",
                                    "Crie scripts para automação de runs (ex: batch files para múltiplas réplicas).",
                                    "Defina baselines: execute simulações vazias para medir overhead.",
                                    "Teste monitoramento em simulação simples para validar setup."
                                  ],
                                  "verification": "Relatório de setup com screenshots de ferramentas rodando e baseline medido (<5% variação).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Softwares GPSS/Arena instalados, computador com monitor de recursos, tutoriais oficiais.",
                                  "tips": "Feche outros apps para isolar medições; use modo admin para precisão.",
                                  "learningObjective": "Preparar ambiente confiável para coletas precisas de dados.",
                                  "commonMistakes": "Não zerar caches de memória; medir em máquina sobrecarregada."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenhar e Implementar Modelos de Teste Escaláveis",
                                  "subSteps": [
                                    "Crie modelo base: fila M/M/1 com chegada/serviço exponenciais.",
                                    "Implemente em GPSS e Arena com parâmetros escaláveis (ex: 100, 1k, 10k, 100k entidades).",
                                    "Adicione complexidade gradual: múltiplas filas, prioridades.",
                                    "Valide modelos com runs analíticos (ex: Little's Law).",
                                    "Prepare planilha para registrar tamanhos de modelo."
                                  ],
                                  "verification": "Modelos rodando sem erros, outputs estatísticos coincidentes entre softwares.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Editores GPSS/Arena, planilha Excel/Google Sheets para tracking.",
                                  "tips": "Parametrize tamanhos via variáveis para reutilização rápida.",
                                  "learningObjective": "Construir modelos representativos de cenários reais para testes.",
                                  "commonMistakes": "Modelos não validados; escalas não logarítmicas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar Simulações e Coletar Dados de Memória",
                                  "subSteps": [
                                    "Rode simulações em sequências crescentes de escala para cada software.",
                                    "Monitore RAM em tempo real: pico, média, durante warm-up e steady-state.",
                                    "Registre 5 réplicas por configuração para estatísticas (média/desvio).",
                                    "Capture gráficos de uso ao longo do tempo.",
                                    "Exporte dados para análise (CSV)."
                                  ],
                                  "verification": "Dataset completo com pelo menos 40 medições (2 softwares x 4 escalas x 5 réplicas).",
                                  "estimatedTime": "4 horas",
                                  "materials": "Computador de teste, scripts de automação, software de gráficos (Excel/Matplotlib).",
                                  "tips": "Use warm-up periods longos para steady-state; monitore temperatura da CPU.",
                                  "learningObjective": "Coletar dados empíricos robustos de performance.",
                                  "commonMistakes": "Poucas réplicas; ignorar garbage collection em linguagens gerenciadas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar e Comparar Resultados com Base em Kelton e Law",
                                  "subSteps": [
                                    "Calcule métricas: crescimento linear/quadrático de RAM vs escala.",
                                    "Compare GPSS vs Arena: eficiência por entidade simulada.",
                                    "Aplique testes estatísticos (t-test para diferenças significativas).",
                                    "Relacione achados com guidelines de Kelton e Law (ex: trade-offs em DES).",
                                    "Gere relatório com gráficos e conclusões."
                                  ],
                                  "verification": "Relatório final com tabelas, gráficos e interpretações alinhadas à literatura.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Excel/R/Python para análise, referências Kelton e Law.",
                                  "tips": "Plote curvas de escalabilidade em log-log para padrões.",
                                  "learningObjective": "Interpretar dados para recomendações práticas de software.",
                                  "commonMistakes": "Não normalizar por tamanho de modelo; cherry-picking dados."
                                }
                              ],
                              "practicalExample": "Simule uma linha de produção com 10k itens em GPSS e Arena: monitore RAM para 1k vs 100k itens. GPSS usa ~200MB estável, Arena cresce para 1.5GB devido a objetos gráficos, confirmando superioridade de GPSS em escalas grandes per Kelton e Law.",
                              "finalVerifications": [
                                "Gráficos de RAM vs escala para ambos softwares gerados e analisados.",
                                "Comparação quantitativa (ex: RAM/entidade) com desvios padrão.",
                                "Conclusões alinhadas a pelo menos 3 citações de Kelton e Law.",
                                "Relatório reproduzível com datasets anexados.",
                                "Validação cruzada: re-run de 20% dos testes sem discrepâncias >5%.",
                                "Recomendação explícita de software por cenário de escala."
                              ],
                              "assessmentCriteria": [
                                "Precisão das medições (±5% erro em RAM reportada).",
                                "Cobertura de escalas (pelo menos 4 ordens de magnitude).",
                                "Uso correto de estatísticas (réplicas, testes de hipótese).",
                                "Integração teórica com Kelton e Law (citações específicas).",
                                "Clareza de visualizações e relatório (gráficos legíveis).",
                                "Robustez: testes em hardware consistente."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Scripts de automação em Python/Batch para monitoramento.",
                                "Estatística: Análise de variância e testes paramétricos em dados de performance.",
                                "Engenharia de Software: Princípios de benchmarking e profiling.",
                                "Gestão de Sistemas: Otimização de recursos em cloud computing.",
                                "Matemática Aplicada: Modelagem assintótica de complexidade (O(n))."
                              ],
                              "realWorldApplication": "Em logística, avaliar Arena vs GPSS para simular supply chains com milhões de eventos, escolhendo GPSS para cenários massivos em manufatura, reduzindo custos de hardware em 40% conforme cases industriais."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.2.3",
                            "name": "Testar precisão e confiabilidade",
                            "description": "Verificar a consistência de resultados em réplicas de simulações, aplicando técnicas de validação para garantir reprodutibilidade nos testes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o modelo de simulação e definir parâmetros para réplicas",
                                  "subSteps": [
                                    "Selecione o software de simulação (ex: SimPy, NetLogo) compatível com sistemas discretos.",
                                    "Defina os parâmetros iniciais do modelo, incluindo sementes aleatórias para reprodutibilidade.",
                                    "Configure o número de réplicas (mínimo 30-100) e critérios de parada.",
                                    "Documente todas as configurações em um arquivo de log.",
                                    "Teste uma execução única para validar o setup básico."
                                  ],
                                  "verification": "Verifique se o modelo roda sem erros e gera saídas consistentes em uma réplica teste; confira o log de parâmetros.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de simulação instalado, documentação do modelo, editor de código.",
                                  "tips": "Use sementes fixas inicialmente para debuggar antes de randomizar.",
                                  "learningObjective": "Entender como configurar simulações para permitir múltiplas execuções idênticas.",
                                  "commonMistakes": "Ignorar variações em parâmetros globais ou não fixar sementes aleatórias."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar múltiplas réplicas da simulação",
                                  "subSteps": [
                                    "Implemente um loop de automação para rodar N réplicas com sementes incrementais.",
                                    "Monitore o progresso e registre tempos de execução para cada réplica.",
                                    "Colete métricas chave (ex: média, desvio padrão) automaticamente em um arquivo CSV.",
                                    "Garanta que cada réplica use condições iniciais idênticas.",
                                    "Salve saídas brutas e logs de erro para análise posterior."
                                  ],
                                  "verification": "Confirme que todas as réplicas foram executadas sem falhas e que o CSV contém N linhas de dados.",
                                  "estimatedTime": "60-90 minutos (dependendo de N e complexidade)",
                                  "materials": "Script de automação (Python/R), armazenamento de dados (CSV/JSON), hardware com boa performance.",
                                  "tips": "Paralelize execuções se possível para acelerar (ex: multiprocessing em Python).",
                                  "learningObjective": "Dominar a execução em batch para gerar dados replicáveis.",
                                  "commonMistakes": "Não sincronizar sementes, levando a resultados não reprodutíveis; sobrecarregar memória."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar consistência e calcular métricas de precisão",
                                  "subSteps": [
                                    "Carregue os dados das réplicas em uma ferramenta estatística (ex: Pandas, R).",
                                    "Calcule estatísticas descritivas: média, mediana, variância, coeficiente de variação (CV).",
                                    "Aplique testes de normalidade (ex: Shapiro-Wilk) e homogeneidade de variância.",
                                    "Identifique outliers usando boxplots ou Z-scores.",
                                    "Visualize distribuições com histogramas e boxplots para inspeção visual."
                                  ],
                                  "verification": "Gere gráficos e relatório com CV < 5-10% para métricas estáveis; testes estatísticos aprovados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Bibliotecas estatísticas (Pandas, SciPy, ggplot2), Jupyter Notebook.",
                                  "tips": "Foquem em CV baixo como indicador inicial de consistência.",
                                  "learningObjective": "Aplicar análise estatística para quantificar variabilidade em simulações.",
                                  "commonMistakes": "Interpretar variância alta como erro sem checar outliers ou não-normalidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar validação final e documentar reprodutibilidade",
                                  "subSteps": [
                                    "Execute testes de reprodutibilidade: rode um subconjunto de réplicas novamente com mesmas sementes.",
                                    "Compare resultados originais vs. reexecutados usando métricas como RMSE ou teste t.",
                                    "Defina thresholds de aceitação (ex: p-value > 0.05 em testes).",
                                    "Gere relatório com conclusões sobre precisão (baixa variância) e confiabilidade (alta reprodutibilidade).",
                                    "Arquive código, dados e relatório para auditoria futura."
                                  ],
                                  "verification": "Resultados reexecutados coincidem em >95%; relatório completo com thresholds atendidos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Ferramentas de comparação (NumPy diff), template de relatório.",
                                  "tips": "Automatize comparações para eficiência em grandes datasets.",
                                  "learningObjective": "Validar integralmente a reprodutibilidade do modelo de simulação.",
                                  "commonMistakes": "Pular reexecução, assumindo consistência sem prova empírica."
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila M/M/1 usando SimPy (fila de supermercado), rode 100 réplicas com chegada λ=5/min e serviço μ=6/min. Calcule tempo médio na fila: espere CV<5%, valide reexecutando 20 réplicas e confirmando RMSE<0.1.",
                              "finalVerifications": [
                                "Coeficiente de variação (CV) das métricas chave <10% em todas as réplicas.",
                                "Testes estatísticos (ex: ANOVA) mostram sem diferenças significativas entre réplicas (p>0.05).",
                                "Reexecução de 20% das réplicas reproduz resultados originais (RMSE<1%).",
                                "Ausência de outliers extremos (>3 desvios padrão).",
                                "Gráficos de distribuição mostram sobreposição alta entre réplicas.",
                                "Relatório documenta todos os thresholds atendidos."
                              ],
                              "assessmentCriteria": [
                                "Execução completa de ≥50 réplicas sem erros técnicos (100%).",
                                "Análise estatística correta com métricas apropriadas (ex: CV, testes) (90-100%).",
                                "Interpretação precisa de resultados, identificando inconsistências (85-95%).",
                                "Documentação clara e reprodutível do processo (95%).",
                                "Validação final com reexecução comprovada (100%).",
                                "Visualizações eficazes suportando conclusões (90%)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Testes de hipóteses e análise de variância.",
                                "Programação: Automação de loops e manipulação de dados em Python/R.",
                                "Ciência da Computação: Gerenciamento de aleatoriedade e paralelismo.",
                                "Engenharia de Software: Testes unitários e validação de modelos.",
                                "Física/Matemática: Modelos estocásticos e processos de Markov."
                              ],
                              "realWorldApplication": "Em simulações epidemiológicas (ex: propagação de doenças com modelos SIR), testar precisão garante previsões confiáveis para políticas públicas; em finanças, valida backtesting de algoritmos de trading para evitar overfitting."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.5.3",
                        "name": "Análise de Custo-Benefício",
                        "description": "Análise de custo-benefício quantifica os investimentos em licenças, treinamento e hardware versus os ganhos em produtividade e qualidade de simulações.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.3.1",
                            "name": "Calcular custos totais de aquisição e manutenção",
                            "description": "Listar e somar despesas com licenças, suporte técnico e treinamento para cada software, considerando opções open-source versus proprietárias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e listar categorias de custos relevantes",
                                  "subSteps": [
                                    "Revise a descrição dos softwares de simulação a comparar (ex: proprietário como AnyLogic e open-source como SimPy).",
                                    "Liste categorias fixas: aquisição (licenças iniciais e anuais), suporte técnico (contratos pagos ou comunidade), treinamento (cursos pagos ou tutoriais gratuitos).",
                                    "Inclua custos indiretos como hardware necessário ou tempo de setup, diferenciando open-source vs proprietário.",
                                    "Crie uma tabela inicial em planilha com colunas: Categoria, Software Proprietário, Software Open-Source.",
                                    "Valide a lista consultando documentações oficiais dos softwares."
                                  ],
                                  "verification": "Tabela preenchida com pelo menos 5 categorias de custos listadas para cada software.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Planilha (Google Sheets ou Excel), sites oficiais dos softwares (ex: anylogic.com, simpy.readthedocs.io).",
                                  "tips": "Priorize custos recorrentes (anuais) sobre únicos para análises de longo prazo.",
                                  "learningObjective": "Compreender as componentes principais de custos totais em softwares de simulação.",
                                  "commonMistakes": "Esquecer custos de treinamento ou assumir open-source como 'zero custo' sem considerar tempo de aprendizado."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Pesquisar e registrar custos para software proprietário",
                                  "subSteps": [
                                    "Acesse o site oficial e pricing page do software proprietário (ex: AnyLogic Research License).",
                                    "Registre valores exatos: licença inicial ($10.000), anual ($5.000), suporte incluso ou extra ($2.000/ano), treinamento oficial ($3.000 por curso).",
                                    "Considere pacotes para múltiplos usuários ou enterprise se aplicável.",
                                    "Anote fontes e datas para rastreabilidade (ex: 'Pricing 2024 de anylogic.com').",
                                    "Estime custos para um horizonte de 3 anos, multiplicando anuais."
                                  ],
                                  "verification": "Todos os valores pesquisados inseridos na tabela com fontes citadas e sem campos vazios.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Navegador web, calculadora ou planilha para multiplicações iniciais.",
                                  "tips": "Use ferramentas de busca como 'AnyLogic pricing 2024' e verifique páginas de vendas ou contato.",
                                  "learningObjective": "Coletar dados precisos de custos proprietários de forma sistemática.",
                                  "commonMistakes": "Usar valores desatualizados ou ignorar taxas de câmbio para moedas estrangeiras."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Pesquisar e registrar custos para software open-source",
                                  "subSteps": [
                                    "Identifique opções open-source equivalentes (ex: SimPy para Python).",
                                    "Registre: licença (gratuita), suporte (comunidade gratuita ou consultoria paga ~$1.000/ano opcional), treinamento (tutoriais gratuitos ou cursos online ~$500).",
                                    "Inclua custos indiretos como tempo de desenvolvedor (ex: 40 horas a $50/h = $2.000 inicial).",
                                    "Preencha a tabela comparativa com valores realistas baseados em fóruns ou docs.",
                                    "Atualize para horizonte de 3 anos, considerando manutenção voluntária."
                                  ],
                                  "verification": "Tabela completa com custos open-source preenchidos e comparáveis aos proprietários.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Sites de documentação open-source, fóruns (Stack Overflow, Reddit), planilha atualizada.",
                                  "tips": "Pesquise 'custo real SimPy simulação' para estimativas comunitárias autênticas.",
                                  "learningObjective": "Avaliar custos ocultos em soluções open-source.",
                                  "commonMistakes": "Subestimar tempo de setup ou suporte comunitário como 'infinito e gratuito'."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular totais e gerar relatório comparativo",
                                  "subSteps": [
                                    "Some custos por categoria e total geral para cada software (ex: Proprietário 3 anos: $30.000; Open-source: $5.000).",
                                    "Use fórmulas na planilha: =SOMA(B2:B10) para totais automáticos.",
                                    "Crie gráfico de barras comparando totais.",
                                    "Escreva um parágrafo resumindo: 'Proprietário é 6x mais caro, mas inclui suporte pronto.'",
                                    "Revise cálculos para erros aritméticos."
                                  ],
                                  "verification": "Totais calculados corretamente validados por recálculo manual e gráfico gerado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha com fórmulas, exportador de gráficos (Excel ou Google Sheets).",
                                  "tips": "Sempre use funções de soma para evitar erros manuais em listas longas.",
                                  "learningObjective": "Executar somas precisas e visualizar comparações custo-benefício.",
                                  "commonMistakes": "Erros de arredondamento ou esquecer multiplicar custos anuais pelo período."
                                }
                              ],
                              "practicalExample": "Compare AnyLogic (proprietário: licença $10k inicial + $5k/ano suporte + $3k treinamento = $28k em 3 anos) vs SimPy (open-source: grátis licença + $1k suporte opcional + $500 tutoriais = $4.5k em 3 anos, incluindo 40h setup). Total proprietário: $28k; open-source: $4.5k.",
                              "finalVerifications": [
                                "Todas categorias de custos listadas e quantificadas para ambos softwares.",
                                "Totais somados corretamente com fórmulas verificáveis.",
                                "Fontes de dados citadas e atualizadas.",
                                "Comparação visual (gráfico) incluída.",
                                "Diferenças open-source vs proprietário destacadas.",
                                "Horizonte temporal (ex: 3 anos) aplicado consistentemente."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos valores pesquisados (90%+ correspondem a fontes oficiais).",
                                "Completude da lista de custos (mínimo 5 categorias por software).",
                                "Correção matemática nos totais (sem erros de soma/multiplicação).",
                                "Clareza na apresentação (tabela + gráfico legíveis).",
                                "Análise qualitativa breve (considera prós/contras além de números).",
                                "Rastreabilidade (todas estimativas justificadas)."
                              ],
                              "crossCurricularConnections": [
                                "Economia: Análise custo-benefício e ROI em investimentos de TI.",
                                "Gestão de Projetos: Orçamentação e planejamento de recursos em simulações.",
                                "Informática: Entendimento de licenças GPL vs proprietárias.",
                                "Matemática Financeira: Cálculos compostos e projeções temporais."
                              ],
                              "realWorldApplication": "Em uma empresa de logística, calcular custos para escolher software de simulação discreta otimizará a seleção entre ferramentas pagas (com suporte rápido) e gratuitas (econômicas mas demandando expertise interna), economizando milhares em orçamentos anuais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.3.2",
                            "name": "Quantificar benefícios em termos de produtividade",
                            "description": "Estimar reduções de tempo de modelagem e análise, usando métricas de performance para calcular ROI em projetos de simulação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e Definir Métricas de Produtividade Relevantes",
                                  "subSteps": [
                                    "Liste métricas chave como tempo de modelagem, tempo de análise, tempo total de simulação e taxa de erros.",
                                    "Defina baselines para cada métrica usando dados históricos de projetos semelhantes.",
                                    "Priorize métricas alinhadas ao contexto do projeto de simulação discreta.",
                                    "Documente unidades (ex: horas, minutos) e escopo (ex: por modelo ou por iteração).",
                                    "Crie uma tabela de métricas para comparação entre softwares."
                                  ],
                                  "verification": "Verifique se a tabela de métricas está completa com pelo menos 4 métricas definidas e baselines estabelecidas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha Excel ou Google Sheets, documentação de projetos anteriores.",
                                  "tips": "Foquem em métricas mensuráveis e relevantes para evitar subjetividade.",
                                  "learningObjective": "Compreender e selecionar métricas específicas para quantificar produtividade em simulações.",
                                  "commonMistakes": "Escolher métricas vagas como 'facilidade de uso' em vez de tempos quantificáveis."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Coletar e Registrar Dados de Performance dos Softwares",
                                  "subSteps": [
                                    "Execute simulações idênticas em cada software comparado (ex: Arena vs. Simio).",
                                    "Registre tempos exatos para modelagem, análise e execução usando cronômetro ou logs internos.",
                                    "Repita testes 3-5 vezes para calcular médias e desvios padrão.",
                                    "Anote fatores externos como hardware e configurações para garantir comparabilidade.",
                                    "Compile dados em uma tabela com colunas para software, métrica e valor médio."
                                  ],
                                  "verification": "Confirme que dados foram coletados para todos softwares e métricas, com pelo menos 3 repetições por teste.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Softwares de simulação (ex: Arena, Simio), cronômetro, computador com specs idênticas.",
                                  "tips": "Use seeds fixas nas simulações para reprodutibilidade dos resultados.",
                                  "learningObjective": "Adquirir habilidades para coletar dados empíricos de performance de forma precisa e repetível.",
                                  "commonMistakes": "Ignorar variabilidade nos testes, levando a dados não confiáveis."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Reduções de Tempo e Ganhos de Produtividade",
                                  "subSteps": [
                                    "Calcule redução percentual: (tempo_baseline - tempo_novo) / tempo_baseline * 100%.",
                                    "Estime ganhos absolutos: redução_por_projeto * número_de_projetos_anuais.",
                                    "Compute produtividade total: horas economizadas * valor_hora_trabalho.",
                                    "Aplique métricas compostas como speedup factor (tempo_velho / tempo_novo).",
                                    "Gere gráficos de barras comparando tempos antes/depois."
                                  ],
                                  "verification": "Valide cálculos com fórmulas mostradas e resultados em tabela/gráfico.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Planilha com fórmulas (Excel), calculadora ou Python para automação.",
                                  "tips": "Use funções como AVERAGE e STDEV no Excel para robustez estatística.",
                                  "learningObjective": "Dominar cálculos quantitativos de reduções de tempo e produtividade.",
                                  "commonMistakes": "Confundir redução percentual com absoluta, superestimando benefícios."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular ROI e Quantificar Benefícios Globais",
                                  "subSteps": [
                                    "Defina fórmula ROI: (Ganho - Custo) / Custo * 100%, onde Ganho = produtividade * tempo_economizado.",
                                    "Estime custos: licença software, treinamento e migração.",
                                    "Projete ROI para 1-3 anos, considerando depreciação e escalabilidade.",
                                    "Sensitize análise variando premissas (ex: +/-20% em tempos).",
                                    "Resuma em relatório com ROI final e pay-back period."
                                  ],
                                  "verification": "Verifique se ROI é calculado corretamente com sensibilidade e pay-back < 12 meses ideal.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Planilha de ROI template, dados de custos de software.",
                                  "tips": "Inclua custo-oportunidade do tempo economizado para ROI mais realista.",
                                  "learningObjective": "Aplicar fórmula de ROI adaptada a contextos de simulação de software.",
                                  "commonMistakes": "Omitir custos ocultos como treinamento, inflando ROI artificialmente."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar Resultados e Comunicar Benefícios",
                                  "subSteps": [
                                    "Interprete ROI: alto (>50%) indica forte benefício de produtividade.",
                                    "Compare com benchmarks industriais (ex: reduções >20% em simulações discretas).",
                                    "Crie visualizações: dashboard com KPIs de produtividade e ROI.",
                                    "Redija executive summary destacando impactos em projetos.",
                                    "Recomende software baseado em quantificação."
                                  ],
                                  "verification": "Revise relatório final com interpretações claras e recomendações fundamentadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Ferramentas de visualização (Tableau, PowerBI ou Excel charts).",
                                  "tips": "Use storytelling: 'Economize 30% de tempo, ROI de 200% em 1 ano'.",
                                  "learningObjective": "Comunicar análises quantitativas de forma persuasiva para stakeholders.",
                                  "commonMistakes": "Sobrecarregar relatório com dados crus sem insights acionáveis."
                                }
                              ],
                              "practicalExample": "Em um projeto de simulação de linha de produção em fábrica (usando Arena vs. Simio), meça tempo de modelagem (Arena: 4h, Simio: 2.5h), análise (Arena: 3h, Simio: 1.8h). Calcule redução de 30% no tempo total (7.5h para 4.3h), produtividade ganha: 3.2h/projeto * 50 projetos/ano * R$100/h = R$16.000/ano. Custos: Arena R$5.000/ano, Simio R$8.000 + R$2.000 treinamento. ROI Simio: (16.000 - 10.000)/10.000 = 60%.",
                              "finalVerifications": [
                                "Tabela de métricas e dados coletados está completa e precisa.",
                                "Cálculos de redução de tempo e ROI validados com fórmulas mostradas.",
                                "Análise de sensibilidade demonstra robustez dos resultados.",
                                "Relatório inclui gráficos e executive summary claro.",
                                "Recomendação de software justificada por quantificação de produtividade.",
                                "Pay-back period calculado e <12 meses para opção recomendada."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de redução percentual e absoluta (erro <5%).",
                                "Coleta de dados com repetições e estatísticas descritivas.",
                                "Inclusão de custos completos no ROI, com sensibilidade.",
                                "Qualidade das visualizações e clareza na comunicação.",
                                "Alinhamento das métricas ao contexto de simulação discreta.",
                                "Profundidade dos substeps executados (mínimo 80% completos)."
                              ],
                              "crossCurricularConnections": [
                                "Economia/Gestão: Cálculo de ROI e análise custo-benefício.",
                                "Estatística: Médias, desvios e análise de variância em testes.",
                                "Programação: Automação de cálculos em Python/R para escalabilidade.",
                                "Gestão de Projetos: Estimativa de baselines e pay-back periods.",
                                "Engenharia Industrial: Aplicação em otimização de sistemas discretos."
                              ],
                              "realWorldApplication": "Em indústrias como manufatura e logística, engenheiros usam essa habilidade para justificar migração de software de simulação (ex: de FlexSim para AnyLogic), economizando milhares de horas anuais em modelagem de filas e processos discretos, resultando em ROI >100% e decisões de investimento baseadas em dados."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.3.3",
                            "name": "Realizar análise qualitativa de usabilidade",
                            "description": "Avaliar facilidade de uso, documentação e suporte comunitário, integrando fatores não monetários à decisão de escolha do software.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir critérios qualitativos de usabilidade",
                                  "subSteps": [
                                    "Identifique dimensões chave: facilidade de uso (interface intuitiva, curva de aprendizado), qualidade da documentação (clareza, completude, atualizações) e suporte comunitário (fóruns ativos, tutoriais, comunidade responsiva).",
                                    "Crie uma escala de avaliação padronizada (ex: 1-5 para cada critério, com rubrica detalhada).",
                                    "Adapte critérios ao contexto de simulação de sistemas discretos (ex: suporte a modelagem agent-based, visualização de simulações).",
                                    "Liste fontes de dados: sites oficiais, fóruns, reviews de usuários em plataformas como Stack Overflow ou GitHub.",
                                    "Documente os critérios em uma tabela comparativa inicial."
                                  ],
                                  "verification": "Verifique se a tabela de critérios está completa com pelo menos 3 dimensões, escalas definidas e fontes listadas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Planilha Google Sheets ou Excel",
                                    "Lista de softwares a comparar (ex: NetLogo, AnyLogic)"
                                  ],
                                  "tips": "Priorize critérios relevantes para simulações discretas, como facilidade em definir regras de agentes.",
                                  "learningObjective": "Estabelecer uma base objetiva para avaliação qualitativa de usabilidade.",
                                  "commonMistakes": [
                                    "Ignorar contexto específico de simulação",
                                    "Escalas subjetivas sem rubrica",
                                    "Omitir múltiplas fontes de dados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Avaliar facilidade de uso através de testes práticos",
                                  "subSteps": [
                                    "Instale e execute tutoriais básicos de cada software.",
                                    "Meça tempo para completar tarefas simples (ex: criar um modelo de simulação discreta básica).",
                                    "Registre métricas: intuitividade da interface, necessidade de referências externas, erros comuns durante uso.",
                                    "Realize um teste heurístico baseado em princípios de Nielsen (visibilidade do status, match entre sistema e mundo real).",
                                    "Anote feedbacks qualitativos: o que foi frustrante ou fluido?"
                                  ],
                                  "verification": "Confirme existência de logs de testes com tempos medidos e heurísticas aplicadas para cada software.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Softwares de simulação instalados",
                                    "Cronômetro",
                                    "Checklist de heurísticas de Nielsen"
                                  ],
                                  "tips": "Simule cenários reais de simulação discreta, como modelar uma fila de espera.",
                                  "learningObjective": "Desenvolver habilidades práticas em avaliação empírica de interfaces.",
                                  "commonMistakes": [
                                    "Testes superficiais sem tarefas representativas",
                                    "Viés pessoal sem métricas objetivas",
                                    "Ignorar curva de aprendizado inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar documentação e suporte comunitário",
                                  "subSteps": [
                                    "Revise documentação oficial: busque manuais, APIs, exemplos de código para simulações discretas.",
                                    "Avalie acessibilidade (PDFs legíveis, busca interna, idiomas disponíveis).",
                                    "Pesquise fóruns (GitHub issues, Reddit, Stack Overflow): volume de perguntas/respostas, tempo médio de resolução.",
                                    "Verifique atualizações recentes e tutoriais comunitários (YouTube, blogs).",
                                    "Pontue qualidade geral: completude (80%+ cobertura de features), clareza e exemplos práticos."
                                  ],
                                  "verification": "Relatório com scores para documentação e suporte, apoiado por capturas de tela ou links de evidências.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Navegador web",
                                    "Ferramentas de busca avançada",
                                    "Contas em fóruns como GitHub"
                                  ],
                                  "tips": "Use queries específicas como 'NetLogo agent-based simulation troubleshooting'.",
                                  "learningObjective": "Compreender o impacto de recursos de suporte na adoção de software.",
                                  "commonMistakes": [
                                    "Focar só em documentação oficial, ignorando comunidade",
                                    "Avaliações baseadas em opiniões sem dados quantitativos",
                                    "Não checar atualidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar análise e integrar a custo-benefício",
                                  "subSteps": [
                                    "Compile scores de todos critérios em uma matriz ponderada (ex: usabilidade 40%, docs 30%, suporte 30%).",
                                    "Compare softwares qualitativamente e quantitativamente.",
                                    "Integre fatores não monetários à decisão: calcule 'pontuação total ajustada' somando qualitativos a custos.",
                                    "Gere recomendações com justificativas claras.",
                                    "Documente limitações da análise (ex: viés de versão atual)."
                                  ],
                                  "verification": "Matriz final preenchida com recomendação explícita e integração a custo-benefício.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Planilha de critérios do Step 1",
                                    "Dados de custo de licenças"
                                  ],
                                  "tips": "Use pesos personalizados baseados em necessidades do projeto de simulação.",
                                  "learningObjective": "Integrar análise qualitativa em decisões holísticas de software.",
                                  "commonMistakes": [
                                    "Não ponderar critérios",
                                    "Isolar qualitativo do monetário",
                                    "Recomendações sem evidências"
                                  ]
                                }
                              ],
                              "practicalExample": "Compare NetLogo e Repast Simphony para simular tráfego urbano discreto: avalie tempo para modelar veículos como agentes, qualidade de tutoriais para visualização e atividade no fórum Repast para dúvidas sobre escalabilidade.",
                              "finalVerifications": [
                                "Matriz de critérios preenchida com scores consistentes para todos softwares.",
                                "Logs de testes práticos com métricas temporais e observações.",
                                "Evidências de pesquisa em documentação e fóruns (links/screenshots).",
                                "Recomendação integrada a custo-benefício com justificativa.",
                                "Identificação de pelo menos 3 forças e fraquezas por software.",
                                "Relatório final conciso (1-2 páginas) resumindo achados."
                              ],
                              "assessmentCriteria": [
                                "Completude dos critérios (cobertura de usabilidade, docs, suporte).",
                                "Objetividade nas avaliações (uso de escalas e evidências).",
                                "Profundidade dos testes práticos (tarefas relevantes a simulações).",
                                "Integração eficaz com análise custo-benefício.",
                                "Clareza e estrutura do relatório final.",
                                "Identificação de limitações e sugestões de melhorias."
                              ],
                              "crossCurricularConnections": [
                                "Design de Experiência do Usuário (UX/UI): aplicação de heurísticas de Nielsen.",
                                "Psicologia Cognitiva: curva de aprendizado e carga mental.",
                                "Gestão de Projetos: avaliação de ferramentas para eficiência de equipe.",
                                "Estatística: análise qualitativa com escalas ordinais.",
                                "Comunicação Técnica: avaliação de documentação."
                              ],
                              "realWorldApplication": "Engenheiros de software em empresas de simulação (ex: AnyLogic Corp) usam essa análise para selecionar ferramentas em projetos de logística, evitando custos ocultos de treinamento e suporte fraco, otimizando ROI em simulações de sistemas discretos como redes de supply chain."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.5",
                "name": "Validação de Modelos",
                "description": "Explica técnicas para verificar e validar a precisão dos modelos de simulação desenvolvidos.",
                "totalSkills": 46,
                "atomicTopics": [
                  {
                    "id": "10.1.5.1",
                    "name": "Verificação vs. Validação de Modelos",
                    "description": "Diferença entre verificação (implementação correta do modelo conceitual) e validação (representação fiel do sistema real).",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.1.1",
                        "name": "Verificação de Modelos",
                        "description": "Processo que garante que o modelo computacional de simulação implementa corretamente o modelo conceitual, ou seja, o programa está livre de erros de programação e reflete fielmente as especificações conceituais definidas.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.1.1",
                            "name": "Definir verificação de modelos",
                            "description": "Explicar o conceito de verificação como a checagem da implementação correta do modelo conceitual em código, identificando erros lógicos, sintáticos e de programação em simulações de sistemas discretos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito fundamental de verificação de modelos",
                                  "subSteps": [
                                    "Ler e analisar a definição de verificação como a checagem da implementação correta do modelo conceitual em código.",
                                    "Identificar que a verificação foca na correspondência entre o modelo teórico e sua codificação.",
                                    "Estudar exemplos iniciais de discrepâncias entre conceito e código.",
                                    "Escrever uma definição pessoal em 3-5 frases.",
                                    "Discutir com um par ou em fórum para refinar entendimento."
                                  ],
                                  "verification": "Comparar a definição pessoal com referências padrão; deve cobrir implementação correta e erros lógicos/sintáticos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Texto introdutório sobre simulação de sistemas discretos",
                                    "Notebook para anotações",
                                    "Artigo sobre verificação vs. validação"
                                  ],
                                  "tips": "Use analogias como 'verificar se a receita foi seguida na cozinha' para fixar o conceito.",
                                  "learningObjective": "Definir verificação de modelos com precisão conceitual.",
                                  "commonMistakes": "Confundir verificação com validação (esta é sobre realidade, não código)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diferenciar verificação de validação e identificar tipos de erros",
                                  "subSteps": [
                                    "Listar diferenças chave: verificação (código vs. modelo conceitual) vs. validação (modelo vs. sistema real).",
                                    "Classificar erros: sintáticos (erros de sintaxe), lógicos (lógica errada no algoritmo), de programação (bugs em loops ou condições).",
                                    "Criar uma tabela comparativa com exemplos para cada tipo.",
                                    "Analisar um código simples de simulação discreta e rotular potenciais erros.",
                                    "Revisar a tabela com exemplos reais de simulações discretas."
                                  ],
                                  "verification": "Tabela completa com pelo menos 3 exemplos por tipo de erro e diferenciação clara.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Exemplos de código em Python para simulações discretas (fila simples)",
                                    "Planilha ou documento para tabela"
                                  ],
                                  "tips": "Sempre pergunte: 'O código faz exatamente o que o modelo conceitual descreve?'",
                                  "learningObjective": "Distinguir tipos de erros e seu impacto na verificação.",
                                  "commonMistakes": "Ignorar erros lógicos sutis, como condições de parada incorretas em loops de eventos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar métodos de verificação em simulações discretas",
                                  "subSteps": [
                                    "Estudar técnicas: inspeção de código, walkthrough, testes unitários para componentes do modelo.",
                                    "Implementar checagens manuais: traçar execução passo a passo com dados de teste conhecidos.",
                                    "Usar ferramentas básicas como print statements ou debuggers para inspecionar variáveis.",
                                    "Verificar invariantes do modelo, como conservação de massa em simulações de filas.",
                                    "Documentar um checklist de verificação personalizado."
                                  ],
                                  "verification": "Checklist funcional testado em um código exemplo, identificando pelo menos 2 erros simulados.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Editor de código (Python/IDLE)",
                                    "Exemplo de código de simulação de fila M/M/1",
                                    "Debugger simples"
                                  ],
                                  "tips": "Comece com casos extremos (zero eventos, um evento) para detectar erros rapidamente.",
                                  "learningObjective": "Aplicar métodos práticos de verificação em código de simulações.",
                                  "commonMistakes": "Pular testes com entradas edge cases, levando a erros não detectados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar definição e aplicação de verificação em um exemplo completo",
                                  "subSteps": [
                                    "Escolher ou criar um modelo conceitual simples de sistema discreto (ex: gerenciador de fila).",
                                    "Codificar o modelo e listar verificações específicas para cada componente.",
                                    "Executar verificações e corrigir erros encontrados.",
                                    "Redigir um relatório resumindo o processo de verificação.",
                                    "Autoavaliar se a definição de verificação foi aplicada corretamente."
                                  ],
                                  "verification": "Relatório com código corrigido, lista de verificações e lições aprendidas.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Ambiente de programação Python",
                                    "Modelo conceitual impresso ou digital",
                                    "Template de relatório"
                                  ],
                                  "tips": "Registre screenshots de antes/depois das correções para evidência visual.",
                                  "learningObjective": "Definir e executar verificação de forma autônoma em simulações.",
                                  "commonMistakes": "Focar só em sintaxe, negligenciando lógica que afeta resultados simulados."
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila M/M/1, verifique se o código corretamente implementa a chegada de clientes (taxa lambda): inspecione se o loop de eventos gera chegadas Poisson sem erros lógicos (ex: overflow em contadores) e sem bugs sintáticos (variáveis indefinidas). Corrija um erro comum onde o tempo de serviço é ignorado, traçando execução com 10 eventos.",
                              "finalVerifications": [
                                "Explicar verbalmente ou por escrito a diferença entre verificação e validação.",
                                "Identificar 3 tipos de erros em um código fornecido de simulação discreta.",
                                "Criar um checklist de verificação para um modelo simples.",
                                "Demonstrar correção de um erro lógico em código real.",
                                "Discutir aplicação em um contexto de sistemas discretos.",
                                "Autoavaliar compreensão com 90% de acerto em quiz relacionado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de verificação (cobre implementação correta e tipos de erros).",
                                "Profundidade na identificação de erros lógicos/sintáticos em exemplos.",
                                "Qualidade do checklist e aplicação prática em código.",
                                "Clareza na diferenciação com validação.",
                                "Criatividade e relevância nos métodos de verificação propostos.",
                                "Completude do relatório com evidências de testes."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Técnicas de debugging e testes unitários.",
                                "Lógica Matemática: Verificação de teoremas e provas formais.",
                                "Engenharia de Software: Ciclo de vida de desenvolvimento e quality assurance.",
                                "Estatística: Análise de simulações Monte Carlo e checagem de distribuições."
                              ],
                              "realWorldApplication": "Na indústria, engenheiros de simulação em logística (ex: otimização de filas em aeroportos) usam verificação para garantir que o código reflita fielmente o modelo conceitual, evitando erros caros em decisões baseadas em simulações discretas de eventos como tráfego ou redes de telecomunicações."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.2",
                            "name": "Identificar métodos de verificação",
                            "description": "Listar e descrever técnicas como inspeção de código, testes unitários, depuração passo a passo e simulações de casos extremos para verificar a implementação em linguagens de simulação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de verificação em modelos de simulação",
                                  "subSteps": [
                                    "Defina verificação como a confirmação de que o modelo implementado corresponde à especificação conceitual.",
                                    "Diferencie verificação de validação (esta foca na adequação ao mundo real).",
                                    "Identifique objetivos principais: detectar erros de implementação e garantir fidelidade ao design.",
                                    "Revise exemplos de erros comuns em simulações discretas, como loops infinitos ou distribuições incorretas.",
                                    "Anote os benefícios da verificação, como redução de custos em iterações posteriores."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras explicando verificação vs. validação e liste 3 objetivos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação de linguagens de simulação (ex: SimPy manual), slides introdutórios sobre V&V em simulações.",
                                  "tips": "Use diagramas de fluxo para visualizar o processo de verificação.",
                                  "learningObjective": "Entender o papel e escopo da verificação em simulações discretas.",
                                  "commonMistakes": "Confundir verificação com validação ou ignorar erros lógicos sutis."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar método de inspeção de código",
                                  "subSteps": [
                                    "Descreva inspeção como revisão manual estática do código fonte sem execução.",
                                    "Liste checklists: sintaxe, lógica de eventos, consistência de variáveis em simulações discretas.",
                                    "Pratique identificando padrões: checagem de condições de parada em simulações de filas.",
                                    "Compare com peer review: envolva outro programador para feedback.",
                                    "Documente achados em um relatório de inspeção."
                                  ],
                                  "verification": "Aplique uma checklist a um código de simulação simples e liste 3 potenciais problemas encontrados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Código exemplo de simulação discreta (ex: Python com SimPy para fila única), template de checklist de inspeção.",
                                  "tips": "Leia o código em voz alta para detectar inconsistências lógicas.",
                                  "learningObjective": "Dominar inspeção de código como método estático de verificação.",
                                  "commonMistakes": "Focar apenas em sintaxe e ignorar lógica de eventos discretos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar testes unitários e depuração passo a passo",
                                  "subSteps": [
                                    "Implemente testes unitários para funções isoladas, como gerador de eventos em simulações.",
                                    "Use frameworks como unittest em Python para automatizar testes de componentes.",
                                    "Descreva depuração passo a passo: use breakpoints para rastrear execução em ferramentas como PyCharm ou gdb.",
                                    "Teste cenários simples: verifique se um evento é processado corretamente em tempo discreto.",
                                    "Registre traces de depuração para análise posterior."
                                  ],
                                  "verification": "Escreva e execute 3 testes unitários em um módulo de simulação, corrigindo falhas via depuração.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Ambiente Python com SimPy e unittest, debugger integrado (ex: VS Code).",
                                  "tips": "Comece com testes para funções puras antes de integrar ao modelo completo.",
                                  "learningObjective": "Aplicar métodos dinâmicos para verificar implementação funcional.",
                                  "commonMistakes": "Não cobrir casos de borda nos testes unitários."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar simulações de casos extremos e síntese dos métodos",
                                  "subSteps": [
                                    "Defina casos extremos: entradas mínimas/máximas, como fila vazia ou sobrecarregada em simulações.",
                                    "Execute simulações com parâmetros extremos e monitore métricas (ex: tempo de espera infinito).",
                                    "Compare todos os métodos: quando usar cada um (estático vs. dinâmico).",
                                    "Crie uma tabela resumindo prós, contras e aplicações em linguagens de simulação.",
                                    "Planeje uma estratégia híbrida de verificação para um modelo completo."
                                  ],
                                  "verification": "Simule um caso extremo em código e gere relatório comparando resultados esperados vs. obtidos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Código de simulação discreta expandido, ferramentas de profiling (ex: cProfile).",
                                  "tips": "Automatize casos extremos com loops de parâmetros variáveis.",
                                  "learningObjective": "Identificar e integrar todos os métodos de verificação.",
                                  "commonMistakes": "Subestimar impacto de casos extremos em sistemas discretos."
                                }
                              ],
                              "practicalExample": "Em uma simulação de sistema de filas M/M/1 usando SimPy em Python, realize inspeção de código para verificar lógica de chegada; testes unitários na função de serviço; depuração para rastrear um evento perdido; e simule caso extremo com taxa de chegada infinita para checar overflow.",
                              "finalVerifications": [
                                "Liste corretamente os 4 métodos principais com descrições breves.",
                                "Aplique inspeção a um código e identifique pelo menos 2 issues.",
                                "Implemente e passe testes unitários em um módulo de simulação.",
                                "Execute depuração passo a passo e explique um trace.",
                                "Simule um caso extremo e interprete resultados.",
                                "Crie uma tabela comparativa dos métodos."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude nas descrições dos métodos (80% cobertura).",
                                "Qualidade dos exemplos práticos e relevância ao contexto de simulações discretas.",
                                "Correção na implementação de testes e depuração (sem erros reportados).",
                                "Profundidade na análise de casos extremos e conexões lógicas.",
                                "Clareza na síntese e estratégia híbrida proposta.",
                                "Uso adequado de terminologia técnica de linguagens de simulação."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Desenvolvimento de testes automatizados e debugging.",
                                "Matemática: Análise probabilística em casos extremos e distribuições.",
                                "Engenharia de Software: Práticas de Quality Assurance (QA).",
                                "Ciência da Computação: Algoritmos de simulação e complexidade.",
                                "Estatística: Verificação de saídas estatísticas em simulações."
                              ],
                              "realWorldApplication": "Na manufatura, verifica-se modelos de simulação de linhas de produção para detectar erros de implementação que poderiam levar a ineficiências milionárias, garantindo otimizações precisas em indústrias como automotiva ou logística."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.1.1.3",
                            "name": "Aplicar verificação em um modelo simples",
                            "description": "Executar verificação prática em um modelo de simulação discreta básica, como uma fila M/M/1, usando ferramentas de depuração para confirmar a correspondência com o modelo conceitual.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o modelo conceitual M/M/1",
                                  "subSteps": [
                                    "Estude as premissas do modelo M/M/1: chegadas Poisson (taxa λ), serviços exponenciais (taxa μ), uma única fila e servidor.",
                                    "Especifique parâmetros: escolha λ = 1 cliente/hora, μ = 1.2 serviços/hora para ρ = λ/μ < 1 (estável).",
                                    "Calcule métricas analíticas esperadas: Lq = ρ²/(1-ρ) para fila, Wq = Lq/λ para tempo na fila.",
                                    "Desenhe um diagrama de estados ou fluxograma do modelo.",
                                    "Documente suposições em um arquivo de notas."
                                  ],
                                  "verification": "Verifique se as métricas analíticas foram calculadas corretamente comparando com fórmulas padrão (ex: Lq ≈ 2 para os parâmetros dados).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e caneta ou software de diagramação como Draw.io; calculadora ou Python para fórmulas.",
                                  "tips": "Use valores numéricos concretos para facilitar comparações futuras.",
                                  "learningObjective": "Compreender e formalizar o modelo teórico antes da implementação.",
                                  "commonMistakes": "Esquecer de garantir ρ < 1, levando a instabilidade; confundir L (sistema) com Lq (fila)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a simulação discreta básica",
                                  "subSteps": [
                                    "Instale biblioteca de simulação como SimPy em Python.",
                                    "Escreva código para gerador de chegadas Poisson, servidor exponencial e fila FIFO.",
                                    "Colete estatísticas: número na fila, tempo na fila para N=1000 clientes.",
                                    "Execute uma simulação de teste com semente fixa para reprodutibilidade.",
                                    "Salve o código em um arquivo .py com comentários."
                                  ],
                                  "verification": "Execute o código e confirme que simula 1000 chegadas sem erros e gera estatísticas iniciais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python 3+, pip install simpy; editor como VS Code ou Jupyter Notebook.",
                                  "tips": "Use random.seed(42) para resultados consistentes entre runs.",
                                  "learningObjective": "Traduzir modelo conceitual em código simulável.",
                                  "commonMistakes": "Implementar gerador de chegadas como uniforme em vez de Poisson; não resetar contadores entre runs."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar ferramentas de depuração para inspeção",
                                  "subSteps": [
                                    "Insira print statements ou use debugger (pdb ou VS Code debugger) para rastrear eventos: chegada, início/fim de serviço.",
                                    "Verifique se o estado da fila corresponde ao esperado em pontos chave (ex: fila vazia no início).",
                                    "Use breakpoints para pausar em chegadas e inspecionar variáveis como queue.length e server.busy.",
                                    "Registre logs em arquivo para análise posterior.",
                                    "Corrija bugs identificados, como race conditions em eventos simultâneos."
                                  ],
                                  "verification": "Logs mostram sequência lógica de eventos sem anomalias (ex: serviço sem cliente).",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Debugger integrado no IDE; biblioteca logging do Python.",
                                  "tips": "Depure com poucos clientes primeiro (N=10) antes de escalar.",
                                  "learningObjective": "Usar depuração para validar lógica de implementação contra conceitual.",
                                  "commonMistakes": "Ignorar eventos de timeout ou não lidar com preemptions; depurar sem semente fixa."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar simulações e comparar com analítico",
                                  "subSteps": [
                                    "Rode múltiplas simulações (10 runs) com N=10000 para reduzir variância.",
                                    "Calcule médias e intervalos de confiança para Wq simulado.",
                                    "Compare com valor analítico (Wq ≈ 5 horas); verifique se |sim - anal| < 10%.",
                                    "Plote histogramas de tempos na fila vs. distribuição exponencial esperada.",
                                    "Ajuste código se discrepâncias > threshold e re-verifique."
                                  ],
                                  "verification": "Relatório mostra convergência: erro < 5% em métricas chave.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Matplotlib/Seaborn para plots; NumPy para stats.",
                                  "tips": "Aumente N se variância alta; use batch means para IC.",
                                  "learningObjective": "Confirmar correspondência numérica entre simulação e teoria.",
                                  "commonMistakes": "Usar N pequeno causando alta variância; comparar médias sem IC."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar e finalizar verificação",
                                  "subSteps": [
                                    "Compile relatório: código, logs, plots, tabela de comparações.",
                                    "Liste discrepâncias resolvidas e lições aprendidas.",
                                    "Teste sensibilidade variando λ ligeiramente.",
                                    "Arquive projeto em repositório Git.",
                                    "Resuma se o modelo implementado matches o conceitual."
                                  ],
                                  "verification": "Relatório completo com todas métricas validadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Markdown ou Jupyter para relatório; Git.",
                                  "tips": "Use templates para relatórios consistentes.",
                                  "learningObjective": "Documentar processo de verificação para reprodutibilidade.",
                                  "commonMistakes": "Omitir IC ou sensibilidade; não versionar código."
                                }
                              ],
                              "practicalExample": "Simule uma fila de caixa de supermercado: λ=2 clientes/min, μ=2.5/min. Use depurador para verificar que fila não excede 5 (esperado ρ=0.8, Lq≈2), compare tempo médio na fila simulado (~1.25 min) com analítico.",
                              "finalVerifications": [
                                "Código executa sem erros para N=10000 clientes.",
                                "Métricas simuladas convergem para analíticas (erro <5%).",
                                "Logs de depuração confirmam lógica de eventos correta.",
                                "Plots mostram distribuição compatível com exponencial.",
                                "Relatório documenta todo processo com evidências.",
                                "Teste de sensibilidade com λ alterada valida robustez."
                              ],
                              "assessmentCriteria": [
                                "Precisão das métricas simuladas vs. analíticas (≥95% match).",
                                "Uso efetivo de depurador com logs detalhados.",
                                "Número e qualidade de sub-steps completados.",
                                "Identificação e correção de pelo menos um erro comum.",
                                "Clareza do relatório e plots gerados.",
                                "Tempo total dentro de 2.5 horas estimadas."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação e depuração em Python/SimPy.",
                                "Estatística: Análise de variância, intervalos de confiança, testes de hipóteses.",
                                "Engenharia de Software: Testes unitários e logging.",
                                "Probabilidade: Distribuições Poisson/Exponencial."
                              ],
                              "realWorldApplication": "Verificação de modelos de filas em call centers para otimizar número de atendentes, garantindo tempos de espera abaixo de 1 min; usado em simulações de tráfego para semáforos ou logística de supply chain."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.1.2",
                        "name": "Validação de Modelos",
                        "description": "Processo que assegura que o modelo de simulação representa adequadamente o sistema real, comparando saídas do modelo com dados observados do mundo real ou conhecimentos de especialistas.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.2.1",
                            "name": "Definir validação de modelos",
                            "description": "Explicar a validação como a avaliação da fidelidade do modelo ao sistema real, utilizando métricas estatísticas e testes de hipótese para confirmar a representatividade em simulações discretas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito fundamental de validação de modelos",
                                  "subSteps": [
                                    "Ler e anotar a definição de validação: avaliação da fidelidade do modelo ao sistema real representado.",
                                    "Diferenciar validação (modelo certo para o sistema real) de verificação (modelo implementado corretamente).",
                                    "Analisar exemplos simples de simulações discretas, como modelagem de filas ou eventos Markovianos.",
                                    "Discutir em um diário pessoal por que a validação é crucial para confiabilidade em simulações.",
                                    "Revisar glossário de termos: fidelidade, representatividade e sistema real."
                                  ],
                                  "verification": "Escrever um parágrafo explicando validação em suas palavras e diferenciando de verificação, com um exemplo de simulação discreta.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Texto introdutório sobre V&V em modelagem (PDF ou artigo)",
                                    "Vídeo explicativo de 10 minutos sobre simulações discretas"
                                  ],
                                  "tips": "Use analogias cotidianas, como comparar um mapa (modelo) com uma viagem real (sistema).",
                                  "learningObjective": "Definir validação de modelos e diferenciá-la de verificação no contexto de simulações discretas.",
                                  "commonMistakes": [
                                    "Confundir validação com verificação.",
                                    "Ignorar o foco em simulações discretas versus contínuas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar métricas estatísticas para avaliação de fidelidade",
                                  "subSteps": [
                                    "Estudar métricas básicas: Erro Quadrático Médio (MSE), Raiz do Erro Quadrático Médio (RMSE) e coeficiente de determinação (R²).",
                                    "Calcular manualmente MSE e RMSE para um conjunto de dados simulados vs. reais simples.",
                                    "Interpretar valores: o que indica baixa fidelidade (ex.: RMSE alto)?",
                                    "Aplicar métricas a dados de simulação discreta, como contagens de eventos.",
                                    "Comparar métricas em uma tabela: vantagens e limitações de cada uma."
                                  ],
                                  "verification": "Calcular RMSE para um dataset fornecido e interpretar se o modelo é fiel (RMSE < 10% do desvio real).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets com dados de exemplo",
                                    "Tutorial online sobre métricas estatísticas em modelagem"
                                  ],
                                  "tips": "Sempre normalize as métricas pelo escala dos dados reais para comparações justas.",
                                  "learningObjective": "Selecionar e calcular métricas estatísticas adequadas para validar fidelidade em simulações discretas.",
                                  "commonMistakes": [
                                    "Usar métricas inadequadas para dados discretos (ex.: assumir normalidade).",
                                    "Interpretar erroneamente valores baixos como sempre bons."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Dominar testes de hipótese para confirmação de representatividade",
                                  "subSteps": [
                                    "Aprender testes comuns: teste qui-quadrado para distribuições discretas, teste t de Student para médias.",
                                    "Entender hipóteses nula (H0: modelo representa o real) e alternativa (H1: não representa).",
                                    "Executar um teste qui-quadrado passo a passo com dados simulados vs. observados.",
                                    "Calcular p-valor e decidir rejeitar H0 (significância α=0.05).",
                                    "Discutir limitações: tamanho amostral e suposições de independência em simulações discretas."
                                  ],
                                  "verification": "Realizar um teste qui-quadrado em dados de exemplo e concluir sobre representatividade (p-valor reportado).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software gratuito como R ou Python (scipy.stats)",
                                    "Dataset de simulação discreta de exemplo (ex.: chegadas Poisson)"
                                  ],
                                  "tips": "Verifique sempre as premissas do teste antes de aplicar (ex.: frequências esperadas >5).",
                                  "learningObjective": "Aplicar testes de hipótese para validar representatividade estatística do modelo.",
                                  "commonMistakes": [
                                    "Confundir p-valor com probabilidade de H0 ser verdadeira.",
                                    "Ignorar múltiplos testes sem correção."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar validação em simulações discretas",
                                  "subSteps": [
                                    "Revisar pipeline completo: simular dados discretos, coletar reais, aplicar métricas e testes.",
                                    "Criar fluxograma de processo de validação para um sistema discreto (ex.: rede de filas).",
                                    "Simular um modelo simples (ex.: processo Poisson) e validá-lo contra dados reais.",
                                    "Documentar relatório: métricas, testes e conclusão de fidelidade.",
                                    "Refletir: quando revalidar (mudanças no sistema real)."
                                  ],
                                  "verification": "Produzir um relatório de 1 página validando um modelo discreto simulado.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python ou MATLAB para simulação",
                                    "Dados reais públicos de simulações discretas (ex.: Kaggle)"
                                  ],
                                  "tips": "Comece com simulações simples para construir confiança antes de complexas.",
                                  "learningObjective": "Integrar conceitos de validação em um workflow completo para simulações discretas.",
                                  "commonMistakes": [
                                    "Não considerar viés de seleção de dados reais.",
                                    "Sobreajustar o modelo aos dados de validação."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um call center, simule um modelo discreto de filas (chegadas Poisson, serviço exponencial). Colete dados reais de 100 chamadas (tempos de espera médios). Calcule RMSE (espera simulada 2.1 min vs. real 2.0 min, RMSE=0.15) e teste qui-quadrado (p=0.23 >0.05), confirmando fidelidade do modelo.",
                              "finalVerifications": [
                                "Define validação como avaliação de fidelidade ao sistema real.",
                                "Lista e explica pelo menos 3 métricas estatísticas (MSE, RMSE, R²).",
                                "Executa corretamente um teste de hipótese com interpretação de p-valor.",
                                "Diferencia validação de verificação com exemplo em simulações discretas.",
                                "Produz relatório de validação com conclusões claras.",
                                "Identifica limitações em contextos discretos."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definição correta e diferenciação (30%)",
                                "Domínio técnico: cálculos de métricas e testes sem erros (25%)",
                                "Aplicação prática: integração em simulação discreta (20%)",
                                "Clareza na comunicação: relatórios e explicações (15%)",
                                "Profundidade: consideração de limitações e dicas (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Estatística: métricas e testes de hipótese",
                                "Programação: implementação em Python/R para simulações",
                                "Engenharia de Sistemas: V&V em modelagem industrial",
                                "Ciência de Dados: validação de ML em dados discretos",
                                "Física Computacional: simulações de partículas discretas"
                              ],
                              "realWorldApplication": "Na logística, validar modelos de simulação discreta de estoques em armazéns, comparando previsões de rupturas com dados históricos via RMSE e qui-quadrado, otimizando inventários e reduzindo custos em 15%."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.2.2",
                            "name": "Descrever técnicas de validação",
                            "description": "Detalhar métodos como comparação de distribuições estatísticas, testes de qui-quadrado, intervalos de confiança e validação face a face com especialistas do domínio.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de validação de modelos",
                                  "subSteps": [
                                    "Definir validação como a confirmação de que o modelo representa adequadamente o sistema real.",
                                    "Diferenciar validação de verificação (correção interna vs. adequação externa).",
                                    "Identificar tipos de validação: estatística e qualitativa.",
                                    "Estudar hierarquia de validação em simulações discretas.",
                                    "Revisar exemplos iniciais de falhas em validação."
                                  ],
                                  "verification": "Resumir em um parágrafo as diferenças entre verificação e validação, com exemplos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de simulação (ex: Law & Kelton), slides introdutórios, caderno de anotações.",
                                  "tips": "Use diagramas de fluxo para visualizar o processo de validação.",
                                  "learningObjective": "Entender o papel e os tipos de validação em modelagem de simulações.",
                                  "commonMistakes": "Confundir validação com calibração de parâmetros."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar comparação de distribuições estatísticas",
                                  "subSteps": [
                                    "Coletar dados reais e simulados de saídas do modelo (ex: tempos de ciclo).",
                                    "Construir histogramas e gráficos Q-Q para visualização.",
                                    "Calcular estatísticas descritivas (média, variância, skewness).",
                                    "Aplicar testes de Kolmogorov-Smirnov para comparar distribuições.",
                                    "Interpretar resultados e ajustar thresholds de aceitação."
                                  ],
                                  "verification": "Gerar gráficos comparativos e concluir se as distribuições são semelhantes.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Software Python (bibliotecas SciPy, Matplotlib) ou R, conjunto de dados de exemplo de filas.",
                                  "tips": "Padronize escalas nos gráficos para facilitar comparações visuais.",
                                  "learningObjective": "Aplicar métodos gráficos e testes para comparar distribuições empiricamente.",
                                  "commonMistakes": "Ignorar tamanho da amostra, levando a falsos positivos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar testes estatísticos avançados: qui-quadrado e intervalos de confiança",
                                  "subSteps": [
                                    "Preparar tabelas de contingência para teste qui-quadrado em categorias discretas.",
                                    "Executar teste qui-quadrado de aderência e independência no software.",
                                    "Calcular intervalos de confiança para médias e proporções simuladas vs. reais.",
                                    "Interpretar p-valores e larguras de intervalos para decidir validade.",
                                    "Realizar testes de sensibilidade variando sementes de simulação."
                                  ],
                                  "verification": "Executar teste qui-quadrado em dados de exemplo e reportar p-valor com interpretação.",
                                  "estimatedTime": "1 hora e 15 minutos",
                                  "materials": "Python (SciPy.stats), R (chisq.test), dados simulados e reais de sistema discreto.",
                                  "tips": "Verifique pressupostos do teste (ex: independência das observações).",
                                  "learningObjective": "Executar e interpretar testes qui-quadrado e intervalos de confiança para validação.",
                                  "commonMistakes": "Usar qui-quadrado em dados contínuos sem discretização adequada."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Realizar validação qualitativa face a face com especialistas do domínio",
                                  "subSteps": [
                                    "Preparar relatórios visuais e cenários de simulação para revisão.",
                                    "Agendar sessão com especialista e apresentar saídas do modelo.",
                                    "Coletar feedback qualitativo sobre plausibilidade e comportamentos extremos.",
                                    "Documentar discrepâncias e propor ajustes no modelo.",
                                    "Iterar validação até consenso com o especialista."
                                  ],
                                  "verification": "Produzir um relatório de feedback com pelo menos 3 pontos de validação qualitativa.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Relatórios PDF, ferramentas de videoconferência (Zoom), modelo simulado rodando.",
                                  "tips": "Use perguntas abertas para elicitar insights profundos do especialista.",
                                  "learningObjective": "Integrar validação humana para complementar métodos estatísticos.",
                                  "commonMistakes": "Ignorar viés do especialista sem triangulação de opiniões."
                                }
                              ],
                              "practicalExample": "Em uma simulação de sistema de filas de um hospital, compare a distribuição de tempos de espera reais (coletados de registros) com simulados usando gráficos Q-Q e teste qui-quadrado (p-valor > 0.05 indica boa aderência), calcule IC 95% para média de espera, e valide face a face com enfermeiros confirmando plausibilidade de picos em horários de pico.",
                              "finalVerifications": [
                                "Explicar corretamente 3 técnicas de validação com exemplos.",
                                "Executar teste qui-quadrado em dados fornecidos e interpretar resultado.",
                                "Construir gráfico comparativo de distribuições sem erros.",
                                "Descrever processo de validação com especialista em 5 passos.",
                                "Identificar quando usar validação estatística vs. qualitativa.",
                                "Calcular IC para uma média simulada com precisão."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude na descrição das técnicas (90%+ acerto).",
                                "Correta execução de testes estatísticos (p-valor e interpretação).",
                                "Qualidade dos gráficos e visualizações comparativas.",
                                "Profundidade no planejamento de validação qualitativa.",
                                "Integração coerente de métodos estatísticos e qualitativos.",
                                "Clareza na documentação de resultados e conclusões."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Testes de hipótese e distribuições.",
                                "Ciência de Dados: Análise exploratória e modelagem preditiva.",
                                "Engenharia de Software: Testes e validação de sistemas.",
                                "Gestão de Projetos: Validação com stakeholders.",
                                "Física Computacional: Simulações numéricas."
                              ],
                              "realWorldApplication": "Na indústria farmacêutica, validar modelos de simulação de ensaios clínicos para prever eficácia de drogas; em logística, validar simulações de supply chain para otimizar estoques e reduzir custos operacionais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.5.1.2.3",
                            "name": "Realizar validação estatística",
                            "description": "Aplicar testes estatísticos em saídas de simulação, como teste t para médias e Kolmogorov-Smirnov para distribuições, comparando com dados reais de um sistema discreto.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Coleta e Preparação de Dados",
                                  "subSteps": [
                                    "Identifique e colete dados reais do sistema discreto (ex: tempos de espera em uma fila).",
                                    "Execute a simulação para gerar dados correspondentes no mesmo período e condições.",
                                    "Limpe os dados: remova outliers, trate valores ausentes e normalize escalas.",
                                    "Divida os dados em amostras para médias (teste t) e distribuições completas (KS).",
                                    "Crie histogramas e estatísticas descritivas para inspeção visual inicial."
                                  ],
                                  "verification": "Verifique se os datasets de simulação e reais têm o mesmo tamanho, formato e estatísticas descritivas semelhantes (média, variância).",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Software de simulação (ex: Python com SimPy ou Arena)",
                                    "Planilhas ou Jupyter Notebook",
                                    "Dados reais históricos"
                                  ],
                                  "tips": "Use scripts automatizados para limpeza para evitar erros manuais; sempre documente transformações aplicadas.",
                                  "learningObjective": "Preparar datasets comparáveis para testes estatísticos precisos.",
                                  "commonMistakes": [
                                    "Ignorar outliers que distorcem médias",
                                    "Não alinhar unidades de tempo entre dados reais e simulados",
                                    "Usar amostras desbalanceadas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Seleção de Testes Estatísticos Adequados",
                                  "subSteps": [
                                    "Avalie hipóteses: H0 (simulação = real) vs. H1 (diferença significativa).",
                                    "Para médias: escolha teste t de Student (unilateral ou bilateral) baseado na variância.",
                                    "Para distribuições: selecione teste de Kolmogorov-Smirnov (KS) para comparar CDFs.",
                                    "Verifique pré-condições: normalidade (Shapiro-Wilk), independência e tamanho de amostra (>30).",
                                    "Defina nível de significância (α=0.05) e potência do teste."
                                  ],
                                  "verification": "Liste os testes escolhidos com justificativa escrita e pré-condições confirmadas.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Tabelas de testes estatísticos",
                                    "Bibliotecas Python: scipy.stats",
                                    "Documentação de software estatístico"
                                  ],
                                  "tips": "Use QQ-plots para checar normalidade antes do t-test; KS é não-paramétrico e robusto.",
                                  "learningObjective": "Selecionar testes apropriados com base nas características dos dados.",
                                  "commonMistakes": [
                                    "Aplicar t-test sem normalidade",
                                    "Confundir teste KS com teste de médias",
                                    "Escolher α inadequado sem contexto"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Execução dos Testes Estatísticos",
                                  "subSteps": [
                                    "Implemente o teste t: scipy.stats.ttest_ind(sim_data, real_data).",
                                    "Implemente o teste KS: scipy.stats.ks_2samp(sim_data, real_data).",
                                    "Calcule estatísticas: t-stat, p-value para t-test; D-stat, p-value para KS.",
                                    "Repita testes com bootstrap se amostras pequenas para robustez.",
                                    "Registre todos os outputs em log ou tabela."
                                  ],
                                  "verification": "Outputs dos testes salvos com p-values <0.05 indicando rejeição de H0.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python/Jupyter com scipy e numpy",
                                    "R se preferido (t.test(), ks.test())"
                                  ],
                                  "tips": "Teste em subconjuntos primeiro para depuração; use seed para reprodutibilidade.",
                                  "learningObjective": "Executar testes computacionalmente com precisão.",
                                  "commonMistakes": [
                                    "Pares errados de dados no teste",
                                    "Interpretar p-value como probabilidade de H0 verdadeira",
                                    "Esquecer de testar bilateral quando necessário"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretação de Resultados e Conclusão",
                                  "subSteps": [
                                    "Compare p-values: se >α, modelo validado; senão, identifique discrepâncias.",
                                    "Analise efeito tamanho (Cohen's d para t-test, suprema de diferença para KS).",
                                    "Visualize: plots de densidade sobrepostos e gráficos de resíduos.",
                                    "Recomende ajustes no modelo se invalidação (ex: parâmetros de chegada).",
                                    "Documente relatório com evidências e limitações."
                                  ],
                                  "verification": "Relatório escrito com conclusão clara: validado/inválido e razões.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": [
                                    "Ferramentas de plotagem: matplotlib/seaborn",
                                    "Template de relatório"
                                  ],
                                  "tips": "Considere múltiplos testes com correção Bonferroni para evitar falsos positivos.",
                                  "learningObjective": "Interpretar resultados estatísticos no contexto de validação de simulações.",
                                  "commonMistakes": [
                                    "Ignorar tamanho de efeito apesar de p>α",
                                    "Sobre-generalizar de uma amostra",
                                    "Não discutir limitações como tamanho de amostra"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado (sistema discreto M/M/1), colete dados reais de 1000 clientes (tempos de espera médios: 5.2 min). Rode simulação com λ=10/h, μ=12/h gerando 1000 saídas (média: 5.1 min). Aplique t-test (p=0.72>0.05) e KS-test (p=0.15>0.05), validando o modelo para otimização de caixas.",
                              "finalVerifications": [
                                "Datasets preparados com estatísticas descritivas matching (±10%).",
                                "Testes executados corretamente com p-values calculados.",
                                "Interpretação coerente: aceito/rejeitado H0 com justificativa.",
                                "Visualizações confirmam ausência de discrepâncias sistemáticas.",
                                "Relatório completo com recomendações.",
                                "Pré-condições dos testes verificadas e documentadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na execução dos testes (p-values corretos: 100%).",
                                "Justificativa adequada da seleção de testes (cobertura completa).",
                                "Interpretação estatística rigorosa (inclui efeito tamanho).",
                                "Qualidade das visualizações e relatório (claro e profissional).",
                                "Tratamento de erros comuns evitado (ex: normalidade checada).",
                                "Eficiência temporal dentro dos estimados."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Fundamentos de inferência e testes de hipóteses.",
                                "Programação: Uso de bibliotecas científicas (Python/R).",
                                "Engenharia de Sistemas: Validação em simulações de eventos discretos.",
                                "Ciência de Dados: Limpeza e visualização de dados.",
                                "Gestão de Operações: Aplicação em filas e processos logísticos."
                              ],
                              "realWorldApplication": "Validar modelos de simulação em logística (ex: centros de distribuição Amazon) para prever gargalos, otimizando estoques e reduzindo custos operacionais em até 20%; ou em manufatura para testar linhas de produção antes de investimentos físicos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.1.3",
                        "name": "Diferenças entre Verificação e Validação",
                        "description": "Comparação clara entre verificação (correção interna do modelo) e validação (correção externa em relação ao sistema real), destacando sua importância sequencial no ciclo de modelagem de simulação.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.3.1",
                            "name": "Comparar conceitos de verificação e validação",
                            "description": "Elaborar uma tabela ou diagrama comparativo destacando diferenças: verificação foca no 'está construído certo?', validação no 'está modelando o certo?', com exemplos de simulação discreta.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Básicos de Verificação e Validação",
                                  "subSteps": [
                                    "Ler definições padrão: Verificação responde 'O modelo está construído corretamente?' (foco em implementação sem erros).",
                                    "Ler definição de validação: 'O modelo representa corretamente a realidade?' (foco em adequação ao problema real).",
                                    "Pesquisar fontes confiáveis sobre V&V em simulações discretas, como livros de Banks ou Law.",
                                    "Anotar exemplos iniciais: Verificação usa debugging; validação usa dados reais.",
                                    "Resumir cada conceito em uma frase própria."
                                  ],
                                  "verification": "Criar flashcards com definições e testar-se recitando sem olhar notas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Acesso à internet para artigos acadêmicos",
                                    "Caderno e caneta",
                                    "Livro ou PDF sobre simulação discreta"
                                  ],
                                  "tips": "Use analogias cotidianas: Verificação é checar a receita; validação é provar se o bolo agrada o paladar.",
                                  "learningObjective": "Diferenciar conceitualmente verificação de validação no contexto de modelagem.",
                                  "commonMistakes": [
                                    "Confundir verificação com testes unitários sem contexto de simulação",
                                    "Ignorar o foco em simulações discretas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Listar Diferenças Chave",
                                  "subSteps": [
                                    "Listar pelo menos 5 diferenças: foco (implementação vs. representação), métodos (debugging vs. calibração com dados), momento (durante construção vs. após), critérios (correção técnica vs. utilidade prática), exemplos em simulação.",
                                    "Categorizar diferenças em categorias: pergunta central, técnicas usadas, objetivos.",
                                    "Priorizar diferenças relevantes para simulações discretas, como eventos discretos vs. comportamento agregado.",
                                    "Validar lista consultando 2-3 referências externas.",
                                    "Discutir diferenças em voz alta ou gravar explicação."
                                  ],
                                  "verification": "Compartilhar lista com um colega ou fórum online e pedir feedback sobre precisão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de papel ou editor de texto",
                                    "Referências online sobre V&V em simulação"
                                  ],
                                  "tips": "Use tabela preliminar de 2 colunas para brainstorm: Verificação | Validação.",
                                  "learningObjective": "Mapear distinções essenciais entre os dois conceitos.",
                                  "commonMistakes": [
                                    "Listar diferenças superficiais sem exemplos de simulação",
                                    "Invertar papéis dos conceitos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir Tabela ou Diagrama Comparativo",
                                  "subSteps": [
                                    "Escolher formato: tabela (Excel/Google Sheets) ou diagrama (Venn ou fluxograma em Draw.io).",
                                    "Preencher linhas/colunas com diferenças identificadas, incluindo exemplos.",
                                    "Adicionar coluna de 'Pergunta Central': 'Construído certo?' vs. 'Modelando o certo?'.",
                                    "Incluir ícones ou cores para visualização (ex: vermelho para erros de verificação).",
                                    "Revisar legibilidade e clareza para um público iniciante."
                                  ],
                                  "verification": "Mostrar o artefato a alguém não familiarizado e perguntar se entendeu as diferenças.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Google Sheets ou Microsoft Excel",
                                    "Ferramenta de diagrama como Lucidchart ou Draw.io",
                                    "Impressora opcional"
                                  ],
                                  "tips": "Mantenha simples: máximo 8 linhas de comparação para evitar sobrecarga.",
                                  "learningObjective": "Criar representação visual clara das diferenças.",
                                  "commonMistakes": [
                                    "Tabela desorganizada ou com texto excessivo",
                                    "Falta de exemplos concretos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a Exemplos de Simulação Discreta e Refinar",
                                  "subSteps": [
                                    "Escolher exemplo: simulação de fila M/M/1 (fila única com chegada/saída Poisson).",
                                    "Aplicar verificação: checar se código simula corretamente tempos de serviço (sem bugs numéricos).",
                                    "Aplicar validação: comparar saídas com dados reais de uma fila de banco (tempo médio de espera).",
                                    "Integrar exemplos na tabela/diagrama.",
                                    "Refinar com base em autoavaliação: adicionar mais detalhes se necessário."
                                  ],
                                  "verification": "Executar uma simulação simples em Python ou AnyLogic e documentar V&V aplicada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software de simulação como Python (SimPy) ou AnyLogic trial",
                                    "Dados de exemplo de filas reais"
                                  ],
                                  "tips": "Use código open-source de simulações discretas para prática rápida.",
                                  "learningObjective": "Contextualizar conceitos em simulações discretas reais.",
                                  "commonMistakes": [
                                    "Exemplos irrelevantes ou sem ligação clara aos conceitos",
                                    "Não diferenciar cenários de V&V"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação discreta de fila de supermercado: Verificação confirma se o algoritmo processa chegadas Poisson e serviços exponenciais corretamente (ex: tempo médio calculado = 1/μ). Validação compara estatísticas simuladas (espera média de 5 min) com dados reais do supermercado (espera observada de 4.8 min), ajustando parâmetros se necessário.",
                              "finalVerifications": [
                                "Explicar verbalmente as diferenças sem consultar notas.",
                                "Identificar corretamente V&V em um cenário dado de simulação.",
                                "Preencher lacunas em uma tabela incompleta de diferenças.",
                                "Dar 2 exemplos próprios de V&V em simulações discretas.",
                                "Diferenciar V&V de outros testes como sensibilidade.",
                                "Avaliar se uma tabela/diagrama explica bem os conceitos."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições e diferenças corretas (30%)",
                                "Clareza visual: tabela/diagrama legível e organizada (25%)",
                                "Relevância de exemplos: ligados a simulações discretas (20%)",
                                "Completude: cobre pergunta central e pelo menos 5 diferenças (15%)",
                                "Originalidade: explicação em palavras próprias (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Software: Testes unitários (verificação) vs. testes de aceitação (validação)",
                                "Estatística: Análise de resíduos em modelagem vs. testes de hipótese",
                                "Ciência de Dados: Debugging de pipelines vs. validação cruzada de modelos",
                                "Gestão de Projetos: Controle de qualidade vs. alinhamento com requisitos do cliente"
                              ],
                              "realWorldApplication": "Em indústrias como manufatura e logística, onde simulações discretas otimizam linhas de produção: verificação garante código sem erros lógicos em eventos discretos, validação assegura que o modelo prediz gargalos reais, evitando perdas financeiras em implementações falhas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.1.1",
                              "10.1.5.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.5.1.3.2",
                            "name": "Explicar a sequência de aplicação",
                            "description": "Descrever o fluxo: primeiro verificar (internamente), depois validar (externamente), e consequências de inverter, referenciando Banks et al. (2000) e Law & Kelton (1991).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Básicos de Verificação e Validação",
                                  "subSteps": [
                                    "Defina verificação como processo interno: 'O modelo resolve o problema certo?' (correção do modelo em si).",
                                    "Defina validação como processo externo: 'O modelo resolve o problema real?' (correspondência com o mundo real).",
                                    "Compare diferenças chave: verificação foca em lógica e matemática interna; validação em dados empíricos e observações.",
                                    "Identifique exemplos simples: verificação = debugar código; validação = testar com dados reais.",
                                    "Anote definições em um diagrama de fluxo para visualização."
                                  ],
                                  "verification": "Criar um diagrama que distingue claramente verificação (interna) de validação (externa).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e caneta ou ferramenta de diagramação como Draw.io; acesso a definições básicas de simulação.",
                                  "tips": "Use setas para mostrar 'interno' vs. 'externo' no diagrama para reforçar a distinção espacial.",
                                  "learningObjective": "Diferenciar conceitualmente verificação e validação com precisão.",
                                  "commonMistakes": "Confundir verificação com teste de unidade (foco apenas em código) sem ênfase no problema certo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explicar a Sequência Correta de Aplicação",
                                  "subSteps": [
                                    "Descreva o fluxo: 1) Verificar internamente para garantir que o modelo está correto antes de investir em dados reais.",
                                    "2) Depois validar externamente com dados do mundo real para confirmar representatividade.",
                                    "Justifique a ordem: Evita desperdício de tempo e recursos em um modelo logicamente falho.",
                                    "Crie um fluxograma sequencial: Verificação → Validação.",
                                    "Pratique verbalizando o fluxo em voz alta."
                                  ],
                                  "verification": "Produzir um fluxograma sequencial aprovado por auto-revisão ou peer review.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramenta de fluxograma (ex: Lucidchart); timer para prática verbal.",
                                  "tips": "Inclua checkpoints de decisão no fluxograma, como 'Modelo logicamente correto?' antes de prosseguir.",
                                  "learningObjective": "Articular a sequência lógica Verificação → Validação com justificativa.",
                                  "commonMistakes": "Ignorar o 'por quê' da ordem, focando apenas na sequência sem racionalidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Consequências de Inverter a Sequência",
                                  "subSteps": [
                                    "Descreva cenário invertido: Validar primeiro (gastar recursos em dados reais) em modelo com erros internos.",
                                    "Liste consequências: Desperdício de tempo/dados, falsos positivos, custos elevados, perda de credibilidade.",
                                    "Compare com sequência correta usando tabela de prós/contras.",
                                    "Simule um exemplo numérico simples: modelo com erro aritmético validado cedo leva a conclusões erradas.",
                                    "Registre impactos quantitativos hipotéticos (ex: +50% custo)."
                                  ],
                                  "verification": "Completar tabela de comparação com pelo menos 3 consequências listadas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Planilha (Google Sheets) para tabela; calculadora para simulação numérica.",
                                  "tips": "Use cores na tabela: vermelho para consequências negativas da inversão.",
                                  "learningObjective": "Identificar e quantificar riscos de inverter Verificação e Validação.",
                                  "commonMistakes": "Subestimar custos, focando apenas em falhas técnicas sem impactos operacionais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Referências Acadêmicas e Praticar Explicação Completa",
                                  "subSteps": [
                                    "Leia excertos de Banks et al. (2000) sobre V&V em simulação discreta.",
                                    "Incorpore Law & Kelton (1991): ênfase em verificação antes de validação para eficiência.",
                                    "Escreva parágrafo integrando refs: 'Conforme Banks et al. (2000), a sequência...'.",
                                    "Pratique explicação completa em 2 minutos para um 'público imaginário'.",
                                    "Grave e autoavalie a explicação."
                                  ],
                                  "verification": "Produzir parágrafo com citações corretas e gravação de explicação fluida.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Cópias digitais/PDFs das referências; gravador de áudio (celular).",
                                  "tips": "Cite página específica se possível para credibilidade acadêmica.",
                                  "learningObjective": "Referenciar fontes autoritativas na explicação da sequência.",
                                  "commonMistakes": "Citar fontes sem integrar ao argumento principal."
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado: Primeiro verifique se o modelo matemático (ex: fórmula de Little's Law) está correto internamente (sem bugs). Depois valide com dados reais de tempos de espera observados. Inverter: Gastar semanas coletando dados reais só para descobrir erro na fórmula básica, desperdiçando esforço.",
                              "finalVerifications": [
                                "Explicar verbalmente a sequência Verificação → Validação sem hesitação.",
                                "Identificar 3 diferenças chave entre V&V em um quiz rápido.",
                                "Descrever 2 consequências de inversão com exemplos.",
                                "Citar corretamente Banks et al. (2000) e Law & Kelton (1991).",
                                "Produzir fluxograma completo da sequência.",
                                "Autoavaliar explicação gravada como 'clara e concisa'."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: Distinção interna/externa correta (30%).",
                                "Clareza na sequência e justificativa lógica (25%).",
                                "Profundidade nas consequências de inversão (20%).",
                                "Integração precisa de referências acadêmicas (15%).",
                                "Fluência na explicação verbal/escrita (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Software: Testes unitários (verificação) vs. integração (validação).",
                                "Ciência de Dados: Debugging de modelos ML vs. avaliação em holdout sets.",
                                "Gestão de Projetos: Análise de risco e ordem de tarefas.",
                                "Física Computacional: Verificação de simulações numéricas antes de calibração experimental."
                              ],
                              "realWorldApplication": "No desenvolvimento de software para bancos, verificar lógica interna do algoritmo de risco antes de validar com dados de mercado reais evita multas regulatórias por modelos falhos; usado em indústrias como aviação (simulações de voo) e saúde (modelos epidemiológicos)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.3.1"
                            ]
                          },
                          {
                            "id": "10.1.5.1.3.3",
                            "name": "Analisar erros comuns na distinção",
                            "description": "Identificar e discutir erros típicos, como confundir bugs de código com falta de fidelidade ao real, e propor estratégias para evitar em projetos de simulação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as Definições Fundamentais de Verificação e Validação",
                                  "subSteps": [
                                    "Ler definições padrão: Verificação (construímos o modelo corretamente?) vs. Validação (construímos o modelo certo?).",
                                    "Estudar exemplos simples: Verificação foca em bugs de implementação; Validação em fidelidade ao sistema real.",
                                    "Criar um diagrama comparativo entre os dois conceitos.",
                                    "Revisar literatura acadêmica sobre simulações discretas (ex: livros de Law e Kelton).",
                                    "Discutir com pares as diferenças em um fórum ou grupo."
                                  ],
                                  "verification": "Criar um resumo de 1 página distinguindo os conceitos sem erros conceituais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livros ou artigos sobre simulação (ex: Simulation Modeling and Analysis), papel e caneta para diagrama"
                                  ],
                                  "tips": "Use mnemônicos: Verificação = 'código certo', Validação = 'modelo realista'.",
                                  "learningObjective": "Dominar as diferenças conceituais entre verificação e validação.",
                                  "commonMistakes": "Confundir verificação com testes unitários sem contexto de simulação."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Erros Comuns na Distinção",
                                  "subSteps": [
                                    "Listar erros típicos: confundir bugs de código (verificação) com imprecisões do modelo (validação).",
                                    "Analisar caso: erro de loop infinito como bug vs. taxa de chegada errada como falta de fidelidade.",
                                    "Coletar exemplos de projetos reais de simulação discretas (ex: filas, redes).",
                                    "Classificar 5 cenários hipotéticos em verificação ou validação.",
                                    "Documentar padrões de confusão observados em fóruns como Stack Overflow."
                                  ],
                                  "verification": "Produzir uma tabela com 5 erros comuns classificados corretamente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Acesso a fóruns online, planilha Excel ou Google Sheets"
                                  ],
                                  "tips": "Pergunte sempre: 'É erro de implementação ou de representação do real?'",
                                  "learningObjective": "Reconhecer padrões de erros na distinção entre os processos.",
                                  "commonMistakes": "Atribuir todos os desvios à validação sem checar código primeiro."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Exemplos Práticos de Erros",
                                  "subSteps": [
                                    "Selecionar um projeto de simulação (ex: simulador de fila M/M/1).",
                                    "Simular um bug de código e um erro de modelo, comparando saídas.",
                                    "Usar ferramentas de debug para isolar problemas de verificação.",
                                    "Comparar saídas simuladas com dados reais para validar.",
                                    "Registrar discussões sobre por que o erro foi mal classificado inicialmente."
                                  ],
                                  "verification": "Relatório com análise de 2 exemplos, um de cada tipo, com evidências.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Software de simulação (ex: Python com SimPy, AnyLogic trial), dados reais de filas"
                                  ],
                                  "tips": "Execute simulações múltiplas com sementes diferentes para robustez.",
                                  "learningObjective": "Aplicar a distinção em cenários concretos de simulação.",
                                  "commonMistakes": "Ignorar variância estatística ao julgar fidelidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Propor e Testar Estratégias de Prevenção",
                                  "subSteps": [
                                    "Desenvolver checklist: 1) Verificar código; 2) Validar com dados reais; 3) Usar métricas separadas.",
                                    "Criar fluxograma de decisão para classificar problemas.",
                                    "Aplicar estratégias em um mini-projeto de simulação.",
                                    "Avaliar eficácia revisando logs de erros anteriores.",
                                    "Refinar estratégias com base em feedback simulado."
                                  ],
                                  "verification": "Checklist e fluxograma funcionais, testados em um exemplo.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Ferramenta de diagrama (ex: Draw.io), código de simulação de teste"
                                  ],
                                  "tips": "Integre testes automatizados para verificação desde o início.",
                                  "learningObjective": "Desenvolver abordagens proativas para evitar confusões.",
                                  "commonMistakes": "Criar checklists genéricas sem foco em simulações discretas."
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado usando SimPy em Python: um loop infinito (bug de verificação) causa tempo infinito de espera, confundido inicialmente com modelo irrealista (validação). Após debug, identifica-se o erro de código; validação posterior usa dados reais de tempos de serviço para confirmar fidelidade.",
                              "finalVerifications": [
                                "Explicar verbalmente a diferença entre verificação e validação sem hesitação.",
                                "Classificar corretamente 5 cenários mistos de erros.",
                                "Aplicar checklist em um novo projeto de simulação.",
                                "Identificar um erro comum pessoal e propor correção.",
                                "Discutir estratégias em grupo com exemplos precisos.",
                                "Produzir relatório final sem confusões conceituais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção conceitual (80%+ acerto em testes).",
                                "Profundidade na análise de exemplos (cobertura de subtipos de erros).",
                                "Criatividade e viabilidade das estratégias propostas.",
                                "Clareza na documentação e checklists.",
                                "Integração de ferramentas e práticas reais de simulação.",
                                "Capacidade de autoavaliação de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Software: Técnicas de debugging e testes unitários.",
                                "Filosofia da Ciência: Limites da modelagem e epistemologia de simulações.",
                                "Estatística: Análise de variância e testes de hipóteses para validação.",
                                "Gestão de Projetos: Ciclos de iteração em desenvolvimento ágil de modelos."
                              ],
                              "realWorldApplication": "Em indústrias como manufatura (simulações de linhas de produção da Siemens) ou saúde (modelos de epidemias da WHO), distinguir corretamente evita recalls caros, otimizando processos sem desperdiçar tempo corrigindo o 'problema errado'."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.2",
                    "name": "Validação Facial (Face Validity)",
                    "description": "Técnica qualitativa onde especialistas avaliam se o modelo parece representar realisticamente o sistema real.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.2.1",
                        "name": "Definição e Conceitos Básicos de Validação Facial",
                        "description": "Compreensão fundamental da validação facial como técnica qualitativa em que especialistas avaliam intuitivamente se o modelo de simulação representa de forma realista o sistema real.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.1.1",
                            "name": "Explicar a definição de validação facial",
                            "description": "Descrever a validação facial como uma técnica qualitativa preliminar onde experts no domínio do sistema real examinam o modelo de simulação e confirmam se ele parece representar realisticamente o comportamento esperado do sistema, sem necessidade de dados quantitativos iniciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Contextualizar a Validação de Modelos em Simulações",
                                  "subSteps": [
                                    "Revise o que é um modelo de simulação em sistemas discretos.",
                                    "Identifique a importância da validação para garantir credibilidade.",
                                    "Diferencie validação qualitativa de quantitativa.",
                                    "Liste tipos comuns de validação (ex: facial, estatística).",
                                    "Explique por que a validação é essencial antes de usar o modelo."
                                  ],
                                  "verification": "Resuma em 3 frases o papel da validação em simulações.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro: 'Simulation Modeling and Analysis' de Averill Law (cap. 7)",
                                    "Artigo: 'Model Validation' da Wikipedia"
                                  ],
                                  "tips": "Use diagramas para visualizar o ciclo de vida de um modelo.",
                                  "learningObjective": "Compreender o contexto geral da validação em modelagem.",
                                  "commonMistakes": "Confundir validação com verificação (verificação é sobre implementação correta)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o Conceito Central de Validação Facial",
                                  "subSteps": [
                                    "Defina validação facial como técnica qualitativa preliminar.",
                                    "Descreva o papel dos experts no domínio do sistema real.",
                                    "Explique que envolve exame visual e julgamento subjetivo do modelo.",
                                    "Enfatize que não requer dados quantitativos iniciais.",
                                    "Compare com 'face validity' em pesquisa qualitativa."
                                  ],
                                  "verification": "Escreva a definição em suas próprias palavras e cite 3 características chave.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Slides: 'Face Validity in Simulation' (buscar em Google Scholar)",
                                    "Vídeo: Khan Academy sobre validade em pesquisa"
                                  ],
                                  "tips": "Memorize a frase: 'Parece real? Experts dizem sim!'",
                                  "learningObjective": "Dominar a definição precisa de validação facial.",
                                  "commonMistakes": "Achar que é puramente subjetiva sem base em expertise."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Descrever o Processo de Validação Facial",
                                  "subSteps": [
                                    "Descreva passos: apresentar modelo aos experts, discutir outputs esperados.",
                                    "Explique como experts comparam simulação com comportamento real.",
                                    "Liste perguntas guias: 'O modelo captura dinâmicas chave?'",
                                    "Discuta iterações se o modelo 'não passa' no exame.",
                                    "Registre feedback qualitativo dos experts."
                                  ],
                                  "verification": "Crie um fluxograma simples do processo com 5 etapas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta: Draw.io para fluxogramas",
                                    "Exemplo: Paper sobre validação em simulações de filas (queueing theory)"
                                  ],
                                  "tips": "Role-play: finja ser um expert avaliando um modelo simples.",
                                  "learningObjective": "Mapear o fluxo prático da validação facial.",
                                  "commonMistakes": "Ignorar a necessidade de múltiplos experts para reduzir viés."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Vantagens, Limitações e Aplicações",
                                  "subSteps": [
                                    "Liste vantagens: rápida, barata, preliminar.",
                                    "Discuta limitações: subjetiva, não substitui validação quantitativa.",
                                    "Explique quando usar: fases iniciais de modelagem.",
                                    "Conecte com ciclo completo de validação.",
                                    "Forneça exemplo breve de falha sem validação facial."
                                  ],
                                  "verification": "Debata prós e contras em um parágrafo balanceado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Artigo: 'Validity Assessment in Simulation Models' de Sargent",
                                    "Fórum: Stack Exchange Operations Research"
                                  ],
                                  "tips": "Use analogia: como um chef prova a comida antes de servir.",
                                  "learningObjective": "Avaliar criticamente a validação facial no contexto amplo.",
                                  "commonMistakes": "Superestimar sua precisão como método único."
                                }
                              ],
                              "practicalExample": "Em um modelo de simulação de fila de supermercado, um gerente de loja (expert) examina saídas do modelo (tempos de espera, comprimento de fila) e confirma se 'parece realista' comparado à loja física, sem rodar experimentos com dados reais ainda.",
                              "finalVerifications": [
                                "Pode definir validação facial sem consultar notas?",
                                "Explica corretamente o papel dos experts e ausência de dados quantitativos?",
                                "Diferencia de validação estatística?",
                                "Descreve o processo em 4 passos sequenciais?",
                                "Identifica pelo menos 2 limitações?",
                                "Fornece um exemplo prático relevante?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição (80% das palavras-chave incluídas).",
                                "Clareza na explicação do processo (fluxo lógico).",
                                "Uso de exemplos concretos para ilustrar.",
                                "Diferenciação de conceitos relacionados.",
                                "Profundidade nas vantagens e limitações.",
                                "Linguagem acessível e sem jargões desnecessários."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Conceitos de validade em testes e pesquisas.",
                                "Engenharia de Software: Inspeções de código e walkthroughs.",
                                "Psicologia: Validade de face em questionários e escalas.",
                                "Gestão de Projetos: Revisões de protótipos por stakeholders."
                              ],
                              "realWorldApplication": "Em simulações epidemiológicas, como durante a COVID-19, experts em saúde pública validam facialmente modelos de propagação de vírus para aprovar uso inicial em políticas públicas antes de calibrações quantitativas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.2",
                            "name": "Identificar as características qualitativas da validação facial",
                            "description": "Listar e diferenciar as características da validação facial, como subjetividade baseada em julgamento de experts, foco em plausibilidade lógica e ausência de testes estatísticos, em contraste com validações quantitativas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Definição Básica de Validação Facial",
                                  "subSteps": [
                                    "Leia a definição de validação facial como uma avaliação qualitativa inicial onde o modelo é julgado pela sua aparência plausível.",
                                    "Anote os termos chave: 'face validity', 'aparência superficial' e 'julgamento informal'.",
                                    "Pesquise brevemente origens do conceito em validação de modelos de simulação.",
                                    "Resuma em uma frase própria o propósito da validação facial em simulações discretas.",
                                    "Compare superficialmente com intuição cotidiana (ex: 'parece certo à primeira vista')."
                                  ],
                                  "verification": "Escreva um parágrafo explicando a definição em suas palavras sem consultar fontes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Texto introdutório sobre validação de modelos (ex: capítulo de livro de simulação)",
                                    "Bloco de notas ou editor de texto"
                                  ],
                                  "tips": "Use analogias visuais, como julgar a cara de um relógio sem checar precisão.",
                                  "learningObjective": "Dominar o conceito fundamental de validação facial como avaliação qualitativa inicial.",
                                  "commonMistakes": "Confundir com validação estatística ou assumir que é uma medida precisa."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar as Características Qualitativas Principais",
                                  "subSteps": [
                                    "Liste subjetividade: depende de opiniões pessoais de experts.",
                                    "Descreva foco em plausibilidade lógica: o modelo faz sentido conceitualmente?",
                                    "Note ausência de testes estatísticos: sem métricas numéricas ou p-values.",
                                    "Registre dependência em conhecimento de domínio dos avaliadores.",
                                    "Agrupe em uma tabela: característica, descrição e exemplo breve."
                                  ],
                                  "verification": "Crie uma lista numerada com pelo menos 4 características qualitativas com descrições curtas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Quadro branco ou ferramenta de mindmap (ex: Draw.io)",
                                    "Referências sobre face validity em simulações"
                                  ],
                                  "tips": "Pergunte-se: 'Isso soa subjetivo ou mensurável?' para cada traço.",
                                  "learningObjective": "Reconhecer e descrever as 4 principais características qualitativas da validação facial.",
                                  "commonMistakes": "Incluir elementos quantitativos como 'acurácia' na lista qualitativa."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar de Validações Quantitativas",
                                  "subSteps": [
                                    "Defina validação quantitativa: usa dados, testes estatísticos e métricas objetivas.",
                                    "Crie uma tabela de contraste: qualitativa vs. quantitativa (subjetiva/objetiva, experts/dados, etc.).",
                                    "Identifique quando usar cada: facial para triagem inicial, quantitativa para confirmação.",
                                    "Exemplo: facial checa se modelo de fila parece real; quantitativa mede tempo médio real vs. simulado.",
                                    "Discuta limitações: facial é rápida mas enviesada; quantitativa é robusta mas custosa."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito 3 diferenças chave com exemplos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Planilha comparativa (ex: Google Sheets)",
                                    "Artigos comparando tipos de validação"
                                  ],
                                  "tips": "Use setas em uma tabela para mostrar oposições claras (ex: subjetivo ←→ objetivo).",
                                  "learningObjective": "Distinguir validação facial qualitativa de abordagens quantitativas.",
                                  "commonMistakes": "Equiparar plausibilidade lógica com evidência estatística."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação em um Cenário Simples",
                                  "subSteps": [
                                    "Escolha um modelo de simulação discreta (ex: fila de banco).",
                                    "Avalie facialmente: liste características qualitativas observadas.",
                                    "Aplique contraste: o que uma validação quantitativa adicionaria?",
                                    "Autoavalie: suas conclusões dependem de julgamento expert?",
                                    "Registre insights em um relatório curto."
                                  ],
                                  "verification": "Produza um relatório de 1 página identificando características em um exemplo dado.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Exemplo de modelo de simulação (diagrama ou descrição textual)",
                                    "Template de relatório"
                                  ],
                                  "tips": "Simule ser um expert: 'Isso parece lógico para um banco real?'",
                                  "learningObjective": "Aplicar identificação de características qualitativas em contexto prático.",
                                  "commonMistakes": "Ignorar subjetividade e buscar 'provas' numéricas no exercício."
                                }
                              ],
                              "practicalExample": "Ao validar um modelo de simulação de tráfego urbano, um expert observa se os carros param realisticamente em semáforos (plausibilidade lógica), baseado em sua experiência, sem rodar testes estatísticos de distribuição de velocidades – puramente qualitativo e subjetivo.",
                              "finalVerifications": [
                                "Lista precisa de 4+ características qualitativas sem elementos quantitativos.",
                                "Explicação clara da subjetividade baseada em julgamento de experts.",
                                "Contraste correto com validações quantitativas (ex: ausência de stats).",
                                "Aplicação bem-sucedida em um exemplo de simulação discreta.",
                                "Identificação de plausibilidade lógica como foco principal.",
                                "Reconhecimento de limitações como viés subjetivo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na listagem de características qualitativas (80% cobertura).",
                                "Clareza no contraste com abordagens quantitativas.",
                                "Profundidade nos substeps com exemplos relevantes.",
                                "Capacidade de aplicação prática sem recorrer a métricas numéricas.",
                                "Uso correto de terminologia (subjetividade, plausibilidade, experts).",
                                "Ausência de confusões comuns como equiparar a validações estatísticas."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Contraste com testes de hipótese e validação estatística.",
                                "Psicologia: Subjetividade e vieses cognitivos em julgamentos de experts.",
                                "Filosofia da Ciência: Discussão sobre evidência qualitativa vs. empírica.",
                                "Engenharia de Software: Validação inicial de modelos em desenvolvimento ágil."
                              ],
                              "realWorldApplication": "Em simulações de Monte Carlo para previsão de epidemias, validação facial é usada por epidemiologistas para checar se taxas de infecção parecem plausíveis baseadas em conhecimento de domínio, antes de investimentos em validações estatísticas caras."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.3",
                            "name": "Diferenciar validação facial de outras validações",
                            "description": "Comparar a validação facial com métodos quantitativos como testes de hipóteses ou validação estatística, destacando seu papel inicial na hierarquia de validação de modelos de simulação de sistemas discretos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Definição e Características da Validação Facial",
                                  "subSteps": [
                                    "Ler definições padrão de validação facial em simulações discretas: julgamento subjetivo de experts sobre plausibilidade do modelo.",
                                    "Identificar traços principais: qualitativa, inicial, baseada em observação visual e intuição.",
                                    "Analisar exemplos: em uma simulação de fila, verificar se o comportamento parece real aos olhos de um especialista.",
                                    "Listar vantagens: rápida, barata, útil para detecção inicial de falhas.",
                                    "Registrar limitações: subjetiva, não quantitativa."
                                  ],
                                  "verification": "Escrever um resumo de 3-5 frases definindo validação facial e suas características principais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Artigos ou capítulos sobre validação de modelos de simulação",
                                    "Vídeos introdutórios sobre face validity"
                                  ],
                                  "tips": "Use analogias cotidianas, como julgar se uma foto representa fielmente uma cena.",
                                  "learningObjective": "Dominar a definição precisa de validação facial e suas propriedades únicas.",
                                  "commonMistakes": [
                                    "Confundir com validação objetiva, ignorando o aspecto subjetivo",
                                    "Subestimar seu papel como etapa inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Outros Métodos de Validação Quantitativos",
                                  "subSteps": [
                                    "Definir validação estatística: comparação de distribuições de saída do modelo com dados reais usando testes como qui-quadrado.",
                                    "Explicar testes de hipóteses: verificar se H0 (modelo = realidade) é rejeitada com p-valor.",
                                    "Listar outros métodos: validação cruzada, sensibilidade, validação operacional.",
                                    "Comparar qualitativamente: quantitativos são objetivos, exigem dados reais e são mais rigorosos.",
                                    "Coletar exemplos de cada método em simulações discretas."
                                  ],
                                  "verification": "Criar uma tabela comparativa simples com colunas para cada método e suas características.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livros de simulação como 'Simulation Modeling and Analysis' de Law",
                                    "Tutoriais online sobre testes estatísticos em simulações"
                                  ],
                                  "tips": "Enfatize a necessidade de dados empíricos para métodos quantitativos.",
                                  "learningObjective": "Identificar e definir métodos quantitativos de validação em contraste com o facial.",
                                  "commonMistakes": [
                                    "Misturar conceitos estatísticos básicos, como confundir p-valor com probabilidade de verdade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Diferenças Chave Entre Validação Facial e Outras",
                                  "subSteps": [
                                    "Mapear diferenças: subjetiva vs. objetiva; qualitativa vs. quantitativa; inicial vs. confirmatória.",
                                    "Analisar hierarquia: facial como base, seguida por estatística para refinamento.",
                                    "Criar uma matriz de comparação: critérios como custo, tempo, precisão, requisitos de dados.",
                                    "Discutir quando usar cada: facial para protótipos, quantitativos para produção.",
                                    "Praticar verbalizando diferenças em um diagrama."
                                  ],
                                  "verification": "Produzir uma tabela ou diagrama Venn destacando sobreposições e diferenças exclusivas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Ferramentas de diagramação como Draw.io ou papel e caneta",
                                    "Exemplos de hierarquias de validação"
                                  ],
                                  "tips": "Use cores para diferenciar: azul para facial (subjetivo), vermelho para quantitativo (objetivo).",
                                  "learningObjective": "Discernir precisamente as distinções entre validação facial e métodos quantitativos.",
                                  "commonMistakes": [
                                    "Ignorar o contexto hierárquico, tratando todos como equivalentes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a Diferenciação no Contexto da Hierarquia de Validação",
                                  "subSteps": [
                                    "Estudar a hierarquia de validação em simulações discretas: facial → operacional → estatística.",
                                    "Explicar papel da facial: filtro inicial para evitar desperdício em métodos caros.",
                                    "Simular cenários: aprovar modelo via facial antes de testes estatísticos.",
                                    "Avaliar trade-offs: facial é porta de entrada, mas insuficiente sozinha.",
                                    "Refletir sobre integração: combinar facial com quantitativos para validação robusta."
                                  ],
                                  "verification": "Desenvolver um fluxograma da hierarquia de validação com posicionamento da facial.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Diagramas de hierarquia de validação de fontes acadêmicas",
                                    "Software de simulação como Arena ou Simul8 (demo)"
                                  ],
                                  "tips": "Pense na validação como uma pirâmide: base ampla (facial) para topo preciso (estatística).",
                                  "learningObjective": "Posicionar corretamente a validação facial na hierarquia geral de validação de modelos.",
                                  "commonMistakes": [
                                    "Superestimar facial como método final, subestimando necessidade de quantitativos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de sistema de filas em um call center, a validação facial envolve experts observando animações para confirmar se o fluxo de chamadas parece realista (ex.: picos em horários de almoço). Já a validação estatística compara tempos de espera médios e variâncias do modelo com logs reais usando teste t de Student, enquanto testes de hipóteses verificam se a distribuição de abandono de chamadas difere significativamente dos dados observados.",
                              "finalVerifications": [
                                "Explicar verbalmente as 3 diferenças principais entre validação facial e estatística.",
                                "Identificar corretamente o papel inicial da facial na hierarquia.",
                                "Classificar exemplos: 'Observar animação' como facial vs. 'Teste qui-quadrado' como estatístico.",
                                "Criar uma frase comparativa precisa sem erros conceituais.",
                                "Desenhar hierarquia simples com facial na base."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições (sem confusão subjetivo/objetivo).",
                                "Compreensão da hierarquia (facial como etapa inicial).",
                                "Capacidade de listar pelo menos 4 diferenças chave.",
                                "Uso correto de exemplos contextualizados em simulações discretas.",
                                "Clareza na comunicação de comparações.",
                                "Identificação de limitações e quando usar cada método."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Aplicação de testes de hipóteses e distribuições.",
                                "Programação Computacional: Implementação de simulações em linguagens como Python ou R.",
                                "Engenharia Industrial: Validação de modelos para otimização de processos.",
                                "Gestão de Projetos: Decisões iniciais de viabilidade em modelagem."
                              ],
                              "realWorldApplication": "Na indústria manufatureira, engenheiros usam validação facial para aprovar rapidamente protótipos de simulações de linhas de produção antes de investir em coletas de dados caras para validação estatística, acelerando o desenvolvimento de sistemas eficientes e reduzindo custos."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.2.2",
                        "name": "Procedimentos para Realizar Validação Facial",
                        "description": "Passos práticos para implementar a validação facial, incluindo seleção de especialistas e coleta de feedback qualitativo.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.2.1",
                            "name": "Selecionar especialistas adequados",
                            "description": "Definir critérios para escolher experts com conhecimento profundo do sistema real, como operadores, engenheiros ou gestores familiarizados com o processo modelado em simulações discretas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar os conhecimentos essenciais necessários",
                                  "subSteps": [
                                    "Analise a descrição detalhada do sistema real modelado na simulação discreta.",
                                    "Liste os aspectos críticos do processo, como fluxos de trabalho, gargalos e variáveis chave.",
                                    "Defina perfis específicos de experts: operadores diários, engenheiros de manutenção e gestores estratégicos.",
                                    "Especifique critérios mínimos, como anos de experiência (mín. 5 anos) e exposição prática ao sistema.",
                                    "Priorize conhecimento prático sobre conhecimento teórico."
                                  ],
                                  "verification": "Documento com lista de critérios e perfis definidos, revisado e aprovado.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Descrição do modelo de simulação",
                                    "Documentos do sistema real",
                                    "Planilha de critérios"
                                  ],
                                  "tips": "Envolva a equipe de modelagem para alinhar critérios com o escopo da validação facial.",
                                  "learningObjective": "Compreender os requisitos de expertise alinhados ao sistema real para validação eficaz.",
                                  "commonMistakes": "Selecionar critérios genéricos sem ligação direta ao processo simulado, resultando em experts irrelevantes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Mapear fontes potenciais de especialistas",
                                  "subSteps": [
                                    "Consulte colegas, equipes operacionais e redes internas da organização.",
                                    "Pesquise em plataformas profissionais como LinkedIn, usando palavras-chave do sistema (ex: 'engenheiro de simulação discreta').",
                                    "Identifique associações profissionais, sindicatos ou fóruns setoriais relacionados ao domínio.",
                                    "Contate departamentos de universidades ou centros de pesquisa com foco em simulações industriais.",
                                    "Compile uma lista inicial de 10-20 candidatos com contatos preliminares."
                                  ],
                                  "verification": "Lista compilada de candidatos potenciais com fontes e contatos iniciais.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": [
                                    "LinkedIn ou redes profissionais",
                                    "Lista de contatos internos",
                                    "Associações setoriais"
                                  ],
                                  "tips": "Use filtros avançados em buscas para refinar por localização e experiência recente.",
                                  "learningObjective": "Desenvolver habilidades de prospecção em redes profissionais para sourcing de experts.",
                                  "commonMistakes": "Limitar-se a fontes internas, ignorando diversidade externa que enriquece perspectivas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar qualificações dos candidatos",
                                  "subSteps": [
                                    "Solicite e revise CVs, portfólios e históricos profissionais dos candidatos.",
                                    "Realize entrevistas curtas (15-30 min) focadas em cenários reais do sistema.",
                                    "Verifique referências com contatos anteriores para validar expertise.",
                                    "Pontue candidatos em uma matriz por critérios (experiência, relevância, disponibilidade).",
                                    "Classifique os top 5-10 candidatos com justificativas."
                                  ],
                                  "verification": "Matriz de avaliação preenchida com scores e notas para cada candidato.",
                                  "estimatedTime": "4-6 horas",
                                  "materials": [
                                    "Modelos de entrevista",
                                    "Matriz de pontuação em planilha",
                                    "Ferramentas de videochamada"
                                  ],
                                  "tips": "Prepare perguntas abertas sobre desafios reais no sistema para testar profundidade.",
                                  "learningObjective": "Aplicar métodos de avaliação qualitativa e quantitativa para seleção precisa.",
                                  "commonMistakes": "Confiar apenas em CVs sem validação prática, levando a experts teóricos inadequados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar seleção e confirmar compromissos",
                                  "subSteps": [
                                    "Ranqueie os candidatos com base na matriz e selecione 3-5 experts ideais.",
                                    "Envie convites formais descrevendo o papel na validação facial e agenda.",
                                    "Obtenha confirmações por escrito, incluindo disponibilidade e NDA se aplicável.",
                                    "Registre a equipe final com perfis e justificativas de seleção.",
                                    "Planeje sessão de onboarding breve para alinhamento."
                                  ],
                                  "verification": "Lista final de especialistas com confirmações assinadas e documento de seleção.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Modelo de convite/email",
                                    "Contrato ou termo de compromisso",
                                    "Agenda compartilhada"
                                  ],
                                  "tips": "Ofereça incentivos como reconhecimento ou relatórios de impacto para aumentar adesão.",
                                  "learningObjective": "Garantir compromisso e alinhamento da equipe para validação bem-sucedida.",
                                  "commonMistakes": "Selecionar sem confirmar disponibilidade, causando atrasos na validação."
                                }
                              ],
                              "practicalExample": "Em uma simulação discreta de fila de atendimento em call center, selecione: um operador sênior (conhece rotinas diárias), um engenheiro de TI (entende integrações de software) e o gestor de operações (visão estratégica de KPIs), usando critérios de 5+ anos de experiência e entrevistas sobre gargalos reais.",
                              "finalVerifications": [
                                "Equipe possui diversidade de papéis (operacional, técnico, gerencial).",
                                "Todos os critérios de seleção foram atendidos por cada expert.",
                                "Confirmações de disponibilidade e compromisso obtidas por escrito.",
                                "Justificativas documentadas para cada seleção.",
                                "Nenhum conflito de interesse identificado.",
                                "Equipe alinhada com escopo da validação facial."
                              ],
                              "assessmentCriteria": [
                                "Relevância e profundidade do conhecimento dos selecionados ao sistema real.",
                                "Diversidade de perspectivas para cobertura completa do modelo.",
                                "Eficiência no processo de seleção (tempo e recursos otimizados).",
                                "Documentação completa e rastreável das decisões.",
                                "Potencial impacto na qualidade da validação facial.",
                                "Ausência de vieses na avaliação (ex: favoritismo)."
                              ],
                              "crossCurricularConnections": [
                                "Gestão de Recursos Humanos: Técnicas de recrutamento e avaliação.",
                                "Comunicação e Networking: Prospecção e entrevistas profissionais.",
                                "Ética Profissional: Seleção imparcial e gestão de conflitos.",
                                "Gestão de Projetos: Planejamento de equipes para validação."
                              ],
                              "realWorldApplication": "Na indústria manufatureira, selecionar operadores e engenheiros para validar simulações de linhas de produção, garantindo que otimizações propostas sejam viáveis e reflitam a realidade operacional, evitando erros caros em implementação."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.2.2.2",
                            "name": "Preparar materiais para avaliação",
                            "description": "Elaborar documentação clara do modelo, incluindo diagramas de fluxo, animações e descrições verbais, para apresentar aos especialistas durante a validação facial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar e Estruturar o Modelo para Documentação",
                                  "subSteps": [
                                    "Identifique os componentes principais do modelo de simulação (estados, transições, variáveis).",
                                    "Defina o público-alvo (especialistas em simulação discreta) e objetivos da validação facial.",
                                    "Crie um outline hierárquico: introdução, estrutura do modelo, fluxos e outputs.",
                                    "Colete dados de entrada/saída e resultados preliminares da simulação.",
                                    "Priorize elementos visuais para diagramas e animações."
                                  ],
                                  "verification": "Outline completo escrito e revisado, cobrindo todos os componentes do modelo.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Notebook ou editor de texto (ex: Google Docs, Notion)",
                                    "Descrição original do modelo",
                                    "Resultados de simulações prévias"
                                  ],
                                  "tips": "Use bullet points para o outline inicial para facilitar iterações rápidas.",
                                  "learningObjective": "Compreender e organizar logicamente os elementos do modelo para comunicação clara.",
                                  "commonMistakes": [
                                    "Ignorar o público-alvo, resultando em jargão excessivo",
                                    "Pular coleta de dados reais, enfraquecendo credibilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar Diagramas de Fluxo Detalhados",
                                  "subSteps": [
                                    "Escolha ferramenta de diagramação (ex: Draw.io, Lucidchart).",
                                    "Desenhe fluxogramas principais: estados iniciais, transições e condições.",
                                    "Adicione rótulos claros, setas com probabilidades e legendas.",
                                    "Inclua sub-diagramas para processos complexos.",
                                    "Exporte em alta resolução (PNG/SVG) e teste visualização em diferentes telas."
                                  ],
                                  "verification": "Diagramas legíveis, com todos os fluxos do modelo representados e legendas completas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Ferramenta de diagramação gratuita (Draw.io, Microsoft Visio)",
                                    "Referências de notação BPMN ou UML para simulações"
                                  ],
                                  "tips": "Mantenha diagramas em uma página para evitar zoom excessivo durante apresentações.",
                                  "learningObjective": "Dominar representação visual de sistemas discretos para facilitar compreensão intuitiva.",
                                  "commonMistakes": [
                                    "Diagramas sobrecarregados com texto excessivo",
                                    "Falta de consistência em símbolos e cores"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolver Animações do Modelo em Execução",
                                  "subSteps": [
                                    "Selecione software de animação (ex: PowerPoint, Manim, ou Processing).",
                                    "Anime fluxos principais: mostre partículas movendo-se por estados e transições.",
                                    "Sincronize animação com narração textual ou áudio explicativo.",
                                    "Crie variações para cenários normais e edge cases.",
                                    "Teste playback em velocidades diferentes e exporte em MP4."
                                  ],
                                  "verification": "Animações reproduzem fielmente o comportamento do modelo, com duração < 2 minutos cada.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Software de animação (Manim para Python, Adobe Animate)",
                                    "Código fonte da simulação para fidelidade"
                                  ],
                                  "tips": "Comece com animações simples e adicione complexidade iterativamente para evitar erros.",
                                  "learningObjective": "Visualizar dinamicamente simulações discretas para validar intuitivamente o modelo.",
                                  "commonMistakes": [
                                    "Animações muito rápidas ou lentas, confundindo observadores",
                                    "Desalinhamento entre animação e diagrama estático"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Redigir Descrições Verbais Claras e Concisas",
                                  "subSteps": [
                                    "Escreva introdução: contexto, suposições e objetivos do modelo.",
                                    "Descreva fluxos verbalmente, referenciando diagramas/animações.",
                                    "Inclua explicações de outputs esperados e métricas de validação.",
                                    "Use linguagem acessível, evitando abreviações sem definição.",
                                    "Revise para fluidez, lendo em voz alta."
                                  ],
                                  "verification": "Texto de 1-2 páginas, com referências cruzadas a visuais e sem ambiguidades.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Editor de texto com verificador ortográfico (Google Docs, Grammarly)",
                                    "Dicionário técnico de simulações"
                                  ],
                                  "tips": "Estruture como script de apresentação: 'Como mostrado no Diagrama 1...'",
                                  "learningObjective": "Comunicar conceitualmente o modelo de forma verbal para suporte à validação facial.",
                                  "commonMistakes": [
                                    "Textos muito técnicos sem exemplos concretos",
                                    "Falta de ligação entre descrição e materiais visuais"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Compilar, Revisar e Preparar Pacote Final",
                                  "subSteps": [
                                    "Monte tudo em um deck de slides ou PDF interativo (ex: PowerPoint, Canva).",
                                    "Adicione índice, sumário e seção de perguntas esperadas.",
                                    "Realize revisão final: cheque clareza, completude e fidelidade ao modelo.",
                                    "Teste apresentação completa com timer.",
                                    "Prepare backups (USB, nuvem) e versão impressa se necessário."
                                  ],
                                  "verification": "Pacote completo testado em hardware similar ao da apresentação, sem erros técnicos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Ferramenta de apresentação (PowerPoint, Google Slides)",
                                    "Dispositivo de teste (projetor ou tela compartilhada)"
                                  ],
                                  "tips": "Peça feedback de um colega para simular validação.",
                                  "learningObjective": "Integrar todos os materiais em um pacote coeso e profissional.",
                                  "commonMistakes": [
                                    "Esquecer backups ou compatibilidade de formatos",
                                    "Sobrecarregar slides com informação"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um modelo de fila M/M/1 em um supermercado, crie: diagrama de chegada/saída de clientes, animação de clientes avançando na fila com tempos aleatórios, e descrição verbal explicando taxa de chegada λ=5/h e serviço μ=6/h, validando se parece realista para especialistas.",
                              "finalVerifications": [
                                "Todos os componentes do modelo estão documentados (estados, transições, probabilidades).",
                                "Materiais visuais (diagramas/animações) são legíveis e sincronizados com descrições.",
                                "Pacote é navegável independentemente, com índice e legendas.",
                                "Tempo total de apresentação < 10 minutos.",
                                "Fidelidade ao modelo original confirmada por auto-revisão.",
                                "Preparado para perguntas sobre suposições e edge cases."
                              ],
                              "assessmentCriteria": [
                                "Clareza e precisão das descrições verbais (sem ambiguidades).",
                                "Qualidade visual dos diagramas e animações (legibilidade, fidelidade).",
                                "Completude: cobre todos os aspectos do modelo para validação facial.",
                                "Profissionalismo do pacote final (formatação, navegação).",
                                "Efetividade na comunicação intuitiva para não-desenvolvedores.",
                                "Tempo de preparação dentro do estimado e escalabilidade."
                              ],
                              "crossCurricularConnections": [
                                "Comunicação: Técnicas de apresentação e storytelling visual.",
                                "Design Gráfico: Princípios de UX/UI em diagramas e animações.",
                                "Programação: Geração automatizada de visuais via scripts (Python/Manim).",
                                "Educação: Pedagogia de validação por pares e feedback.",
                                "Gestão de Projetos: Planejamento e revisão de entregáveis."
                              ],
                              "realWorldApplication": "Em empresas de simulação como AnyLogic ou em pesquisa acadêmica, preparar esses materiais permite validação rápida por experts em projetos de logística, saúde (ex: modelagem de epidemias) ou manufatura, acelerando iterações e reduzindo erros custosos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.5.2.2.3",
                            "name": "Coletar e registrar feedback qualitativo",
                            "description": "Conduzir sessões de revisão com especialistas, registrando comentários sobre plausibilidade, identificando discrepâncias lógicas e ajustando o modelo com base no feedback informal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a sessão de revisão com especialistas",
                                  "subSteps": [
                                    "Identificar e convidar 3-5 especialistas relevantes no domínio do modelo (ex.: professores de simulação ou profissionais de sistemas discretos).",
                                    "Preparar materiais de apresentação: diagrama do modelo, simulação inicial e perguntas guiadas sobre plausibilidade.",
                                    "Definir formato da sessão: duração (45-60 min), modo (presencial/virtual) e ferramentas de registro (gravador, notas compartilhadas).",
                                    "Criar um roteiro inicial com tópicos chave: estrutura do modelo, premissas e cenários de teste.",
                                    "Testar a apresentação em si mesmo para garantir clareza e fluidez."
                                  ],
                                  "verification": "Lista de convidados confirmados e materiais de apresentação prontos e revisados.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Lista de contatos de especialistas, software de simulação (ex.: AnyLogic), slides ou documento compartilhado (Google Slides), gravador de áudio.",
                                  "tips": "Escolha especialistas com experiência prática para feedback autêntico; envie agenda com antecedência de 48h.",
                                  "learningObjective": "Dominar a organização prévia para sessões eficazes de validação facial.",
                                  "commonMistakes": "Convidados irrelevantes ou materiais mal preparados, levando a feedback superficial."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Conduzir a sessão de revisão e coletar feedback qualitativo",
                                  "subSteps": [
                                    "Apresentar o modelo de forma clara, destacando premissas e lógica subjacente.",
                                    "Fazer perguntas abertas: 'O modelo parece plausível para o sistema real?' e 'Há discrepâncias lógicas evidentes?'.",
                                    "Registrar verbalmente comentários em tempo real, usando gravador e anotações.",
                                    "Explorar respostas profundas com follow-ups: 'Por que essa premissa parece irrealista?'.",
                                    "Encerrar com resumo dos pontos principais e agradecer aos participantes."
                                  ],
                                  "verification": "Gravação ou notas da sessão com pelo menos 10 comentários qualitativos registrados.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": "Gravador de áudio/vídeo (Zoom), bloco de notas ou ferramenta digital (Notion/OneNote), protótipo do modelo simulado.",
                                  "tips": "Mantenha neutralidade para evitar viés; pause para esclarecimentos sem interromper o fluxo.",
                                  "learningObjective": "Aprender a facilitar discussões para extrair feedback informal rico e relevante.",
                                  "commonMistakes": "Perguntas fechadas que limitam respostas ou falha em registrar detalhes contextuais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Registrar e categorizar o feedback coletado",
                                  "subSteps": [
                                    "Transcrever áudio/notas em documento estruturado: colunas para comentário, plausibilidade, discrepância lógica.",
                                    "Categorizar feedback: plausível/não plausível, lógico/irrealista, sugestões de ajuste.",
                                    "Identificar padrões recorrentes entre especialistas (ex.: 3/5 citam mesma discrepância).",
                                    "Priorizar itens por impacto no modelo (alta/média/baixa prioridade).",
                                    "Validar transcrição com gravação para precisão."
                                  ],
                                  "verification": "Documento de feedback categorizado com pelo menos 80% dos comentários processados.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": "Planilha (Google Sheets/Excel) com template de categorias, transcrição de áudio (Otter.ai), gravação da sessão.",
                                  "tips": "Use cores para categorização visual; inclua timestamps da gravação para referência.",
                                  "learningObjective": "Desenvolver habilidades de análise qualitativa para validação de modelos.",
                                  "commonMistakes": "Registro incompleto ou categorização subjetiva sem evidências."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ajustar o modelo com base no feedback registrado",
                                  "subSteps": [
                                    "Mapear discrepâncias identificadas para componentes do modelo (ex.: parâmetros, regras de transição).",
                                    "Implementar ajustes priorizados: modificar premissas ou lógica no software de simulação.",
                                    "Testar iterações rápidas do modelo ajustado e documentar mudanças.",
                                    "Preparar relatório de ajustes com antes/depois e justificativas baseadas em feedback.",
                                    "Planejar sessão de follow-up se necessário para validar ajustes."
                                  ],
                                  "verification": "Modelo atualizado com log de mudanças rastreáveis ao feedback e testes iniciais aprovados.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Software de simulação (ex.: Simul8), versão anterior do modelo, relatório de feedback.",
                                  "tips": "Mantenha versionamento (Git para modelos); ajuste incrementalmente para isolar impactos.",
                                  "learningObjective": "Aplicar feedback qualitativo para refinar modelos de simulação discretos.",
                                  "commonMistakes": "Ignorar feedback de baixa prioridade ou ajustes sem testes de plausibilidade."
                                }
                              ],
                              "practicalExample": "Em um modelo de simulação de fila de supermercado (sistema discreto de eventos), conduza sessão com 3 gerentes de loja. Registre comentários como 'A taxa de chegada de clientes ignora horários de pico, parecendo irrealista'. Categorize como discrepância lógica, ajuste parâmetro de chegada para variar por hora e reteste plausibilidade.",
                              "finalVerifications": [
                                "Registro completo de pelo menos 10 comentários qualitativos de múltiplos especialistas.",
                                "Todas as discrepâncias lógicas identificadas foram categorizadas e priorizadas.",
                                "Modelo ajustado reflete pelo menos 70% do feedback relevante.",
                                "Relatório final inclui evidências de plausibilidade melhorada.",
                                "Sessão gravada e transcrita com precisão verificada.",
                                "Log de mudanças rastreável ao feedback original."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude do registro de feedback (sem omissões chave).",
                                "Profundidade na identificação de discrepâncias lógicas (além de superficial).",
                                "Eficácia dos ajustes no modelo (melhoria mensurável em plausibilidade).",
                                "Qualidade da facilitação da sessão (feedback rico e variado obtido).",
                                "Organização do relatório final (claro, estruturado e acionável).",
                                "Tempo respeitado e profissionais envolvidos adequadamente."
                              ],
                              "crossCurricularConnections": [
                                "Comunicação: Técnicas de entrevista qualitativa e escuta ativa.",
                                "Pesquisa Científica: Métodos de validação empírica e análise temática.",
                                "Engenharia de Software: Versionamento e iteração baseada em revisão por pares.",
                                "Psicologia: Viés cognitivo na percepção de plausibilidade.",
                                "Gestão de Projetos: Coleta de requisitos de stakeholders."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software de simulação para logística (ex.: otimização de supply chain na Amazon), coletar feedback de operadores para validar modelos de fluxo discreto, reduzindo erros de previsão em 20-30% e acelerando deployment."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.2.2"
                            ]
                          },
                          {
                            "id": "10.1.5.2.2.4",
                            "name": "Documentar resultados da validação facial",
                            "description": "Compilar relatórios com achados qualitativos, incluindo citações de experts e ações corretivas propostas para o modelo de simulação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Coletar e Organizar Achados Qualitativos",
                                  "subSteps": [
                                    "Reúna todos os feedbacks qualitativos obtidos durante a validação facial, como comentários verbais ou escritos dos validadores.",
                                    "Classifique os achados em categorias: plausibilidade do modelo, realismo das saídas e discrepâncias observadas.",
                                    "Registre métricas qualitativas, como nível de confiança dos validadores (alta/média/baixa).",
                                    "Crie uma tabela inicial resumindo os achados principais.",
                                    "Priorize achados críticos que impactam a credibilidade do modelo."
                                  ],
                                  "verification": "Verificar se existe uma tabela ou lista organizada com pelo menos 5 achados categorizados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Notas da sessão de validação, planilha (Excel/Google Sheets), gravações de entrevistas.",
                                  "tips": "Use cores para destacar achados positivos (verde) e negativos (vermelho) na tabela.",
                                  "learningObjective": "Dominar a organização sistemática de dados qualitativos para análise posterior.",
                                  "commonMistakes": "Ignorar feedbacks menores que podem revelar padrões; misturar categorias sem clareza."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Pesquisar e Incluir Citações de Experts",
                                  "subSteps": [
                                    "Identifique experts relevantes no domínio da simulação (ex: autores de papers sobre face validity).",
                                    "Busque citações em literatura acadêmica que suportem ou contestem os achados (usar Google Scholar ou bases como IEEE).",
                                    "Selecione 3-5 citações chave e extraia trechos relevantes.",
                                    "Integre as citações aos achados, ligando-os diretamente (ex: 'Como citado por Smith (2020)...').",
                                    "Verifique a formatação das citações (ABNT ou APA)."
                                  ],
                                  "verification": "Lista de citações com pelo menos 3 referências bibliográficas completas vinculadas aos achados.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Acesso à internet, ferramentas de busca acadêmica (Google Scholar), gerenciador de referências (Zotero/Mendeley).",
                                  "tips": "Priorize citações recentes (últimos 5-10 anos) e de fontes peer-reviewed.",
                                  "learningObjective": "Aprender a integrar evidências acadêmicas para embasar relatórios técnicos.",
                                  "commonMistakes": "Citar sem contexto relevante; plagiar trechos sem aspas e referência."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Achados e Propor Ações Corretivas",
                                  "subSteps": [
                                    "Analise os achados e citações para identificar padrões e gaps no modelo.",
                                    "Proponha ações corretivas específicas, como ajustes nos parâmetros ou reformulação de hipóteses.",
                                    "Estime impactos das ações (ex: 'Melhorará plausibilidade em 20%').",
                                    "Classifique ações por prioridade (alta/média/baixa) e viabilidade.",
                                    "Documente prazos sugeridos para implementação."
                                  ],
                                  "verification": "Seção com pelo menos 4 ações corretivas priorizadas e justificadas.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Modelos de simulação originais, ferramentas de análise (MindMeister para mapas mentais).",
                                  "tips": "Use o framework SMART (Specific, Measurable, Achievable, Relevant, Time-bound) para ações.",
                                  "learningObjective": "Desenvolver habilidades analíticas para transformar feedback em melhorias acionáveis.",
                                  "commonMistakes": "Propor ações vagas sem métricas; ignorar viabilidade técnica."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Compilar e Finalizar o Relatório",
                                  "subSteps": [
                                    "Estruture o relatório: introdução, achados, citações, ações corretivas, conclusão.",
                                    "Inclua visualizações como gráficos de feedbacks ou tabelas de ações.",
                                    "Escreva um resumo executivo de 1 página.",
                                    "Revise linguagem para clareza e objetividade técnica.",
                                    "Exporte em PDF e compartilhe para feedback final."
                                  ],
                                  "verification": "Relatório completo gerado, com todas seções presentes e formatado profissionalmente.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Editor de texto (Word/Google Docs), ferramentas de diagramação (Canva/LibreOffice).",
                                  "tips": "Mantenha o relatório conciso (5-10 páginas); use headings e bullet points.",
                                  "learningObjective": "Mestres a redação técnica de relatórios científicos.",
                                  "commonMistakes": "Excesso de jargão sem explicação; esquecimento de sumário ou referências."
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado, o relatório documenta: 'Validadores acharam saídas realistas (confiança alta), mas tempos de espera implausíveis. Citação: Jones (2018) alerta para subestimação em 15%. Ação corretiva: Ajustar distribuição Poisson (alta prioridade, 1 semana).'",
                              "finalVerifications": [
                                "Relatório inclui todos achados qualitativos categorizados.",
                                "Pelo menos 3 citações de experts integradas corretamente.",
                                "Ações corretivas são específicas, priorizadas e mensuráveis.",
                                "Visualizações auxiliam a compreensão dos resultados.",
                                "Formatação segue padrões profissionais (ABNT).",
                                "Resumo executivo resume os pontos chave."
                              ],
                              "assessmentCriteria": [
                                "Completude: Cobertura de todos elementos requeridos (achados, citações, ações).",
                                "Clareza e precisão da linguagem técnica.",
                                "Relevância e qualidade das citações acadêmicas.",
                                "Viabilidade e detalhamento das ações corretivas.",
                                "Estrutura lógica e uso eficaz de visuais.",
                                "Concisão sem perda de informações essenciais."
                              ],
                              "crossCurricularConnections": [
                                "Redação Técnica e Comunicação Científica: Estrutura de relatórios.",
                                "Pesquisa Bibliográfica: Busca e citação em bases acadêmicas.",
                                "Análise de Dados Qualitativos: Categorização de feedbacks.",
                                "Gestão de Projetos: Priorização de ações corretivas."
                              ],
                              "realWorldApplication": "Em empresas de simulação como AnyLogic ou em pesquisa acadêmica, esses relatórios embasam iterações de modelos para otimizar sistemas reais, como logística em supply chains ou validação de modelos epidemiológicos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.2.3"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.2.3",
                        "name": "Vantagens, Limitações e Aplicações em Simulação Discreta",
                        "description": "Análise crítica das vantagens, limitações e exemplos práticos da validação facial em contextos de simulação de sistemas discretos.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.3.1",
                            "name": "Listar vantagens da validação facial",
                            "description": "Explicar benefícios como rapidez, baixo custo, detecção precoce de erros conceituais e aumento da confiança inicial no modelo antes de testes caros.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de validação facial em simulações discretas",
                                  "subSteps": [
                                    "Ler a definição de validação facial: julgamento intuitivo de especialistas sobre se o modelo representa adequadamente o sistema real.",
                                    "Revisar o contexto em simulações de sistemas discretos, como filas ou processos de manufatura.",
                                    "Identificar diferenças entre validação facial e outras validações (ex.: estatística ou operacional).",
                                    "Anotar exemplos iniciais de quando a validação facial é usada.",
                                    "Discutir com um colega ou em fórum por que ela é qualitativa."
                                  ],
                                  "verification": "Criar um mapa mental com definição, contexto e diferenças, compartilhando para feedback.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Artigo ou capítulo sobre validação de modelos em simulação discreta (ex.: Law & Kelton)",
                                    "Vídeo introdutório sobre face validity no YouTube"
                                  ],
                                  "tips": "Use analogias cotidianas, como verificar se uma foto parece com a pessoa, para fixar o conceito.",
                                  "learningObjective": "Entender o que é validação facial e seu papel inicial na validação de modelos.",
                                  "commonMistakes": [
                                    "Confundir com validação estatística; achar que é puramente subjetiva sem base em expertise."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e listar as principais vantagens da validação facial",
                                  "subSteps": [
                                    "Listar vantagens iniciais: rapidez na execução, baixo custo financeiro e temporal.",
                                    "Adicionar detecção precoce de erros conceituais no modelo.",
                                    "Incluir aumento da confiança inicial antes de testes caros como validação operacional.",
                                    "Pesquisar fontes para validar a lista (ex.: livros de simulação).",
                                    "Organizar em bullet points com uma frase explicativa para cada."
                                  ],
                                  "verification": "Produzir uma lista de pelo menos 4 vantagens com justificativas breves.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro 'Simulation Modeling and Analysis' de Averill Law",
                                    "Notas de aula sobre MC-37"
                                  ],
                                  "tips": "Priorize vantagens quantitativas (custo/tempo) e qualitativas (confiança/detecção).",
                                  "learningObjective": "Reconhecer e enumerar as vantagens chave da validação facial.",
                                  "commonMistakes": [
                                    "Omitir detecção de erros conceituais; superestimar como substituto para outras validações."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar cada vantagem com exemplos em simulações discretas",
                                  "subSteps": [
                                    "Para cada vantagem, criar um exemplo: rapidez em revisar animação de fila de supermercado.",
                                    "Explicar baixo custo: sem necessidade de dados reais extensos.",
                                    "Detalhar detecção precoce: identificar se o modelo ignora prioridades erradas.",
                                    "Discutir confiança inicial: aprovar modelo conceitual antes de codificação longa.",
                                    "Comparar com desvantagens brevemente para equilíbrio."
                                  ],
                                  "verification": "Escrever parágrafos curtos para 4 vantagens com exemplos específicos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de simulação como Arena ou AnyLogic (versão trial)",
                                    "Exemplos de modelos de filas"
                                  ],
                                  "tips": "Use diagramas ou fluxogramas para visualizar exemplos.",
                                  "learningObjective": "Aplicar vantagens a cenários reais de simulação discreta.",
                                  "commonMistakes": [
                                    "Exemplos genéricos sem ligação a simulações; ignorar contexto discreto."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar a lista e preparar para aplicação",
                                  "subSteps": [
                                    "Compilar lista final ordenada por importância (rapidez, custo, detecção, confiança).",
                                    "Criar tabela comparativa com outras validações.",
                                    "Praticar explicando oralmente ou em vídeo curto.",
                                    "Identificar cenários onde priorizar validação facial.",
                                    "Autoavaliar a lista contra critérios de completude."
                                  ],
                                  "verification": "Apresentar lista final em formato de slide ou documento, com exemplos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Ferramenta de apresentação como PowerPoint ou Google Slides",
                                    "Checklist de vantagens"
                                  ],
                                  "tips": "Ordene da mais imediata (rapidez) à estratégica (confiança).",
                                  "learningObjective": "Consolidar conhecimento para listar e defender vantagens autonomamente.",
                                  "commonMistakes": [
                                    "Lista incompleta; não ordenar logicamente."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de call center discreto, um especialista revisa a animação do modelo: vê que as chamadas são atendidas em ordem FIFO, detecta erro conceitual (deveria ser prioridade), corrige rapidamente sem rodar simulações longas, economizando tempo e custo antes de validação com dados reais.",
                              "finalVerifications": [
                                "Listar corretamente pelo menos 4 vantagens principais sem consulta.",
                                "Explicar cada vantagem com um exemplo de simulação discreta.",
                                "Diferenciar vantagens de limitações da validação facial.",
                                "Identificar quando usá-la em um fluxo de validação de modelo.",
                                "Criar tabela comparativa com validação operacional.",
                                "Defender verbalmente as vantagens em 2 minutos."
                              ],
                              "assessmentCriteria": [
                                "Completude: Todas as 4 vantagens principais incluídas (90-100%).",
                                "Precisão: Descrições alinhadas com literatura (ex.: Law & Kelton) (80-90%).",
                                "Profundidade: Exemplos concretos e contextualizados (70-80%).",
                                "Clareza: Linguagem acessível e estrutura organizada (60-70%).",
                                "Originalidade: Análise pessoal além de cópia (bônus).",
                                "Aplicação: Ligação clara a simulações discretas."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Comparação com testes de hipóteses em validação quantitativa.",
                                "Gestão de Projetos: Economia de tempo e custo em fases iniciais.",
                                "Psicologia Cognitiva: Julgamento de especialistas e vieses intuitivos.",
                                "Engenharia de Software: Validação inicial de protótipos.",
                                "Economia: Análise custo-benefício em modelagem."
                              ],
                              "realWorldApplication": "Em indústrias como logística (simulação de armazéns da Amazon) ou saúde (fluxo de pacientes em hospitais), a validação facial permite experts aprovarem rapidamente modelos conceituais, evitando investimentos em simulações caras que falhariam por erros básicos, acelerando o desenvolvimento de sistemas eficientes."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.2.3.2",
                            "name": "Identificar limitações e riscos",
                            "description": "Discutir desvantagens como subjetividade, viés de experts e insuficiência para validar precisão quantitativa, recomendando combinação com outras técnicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de Validação Facial e suas limitações fundamentais",
                                  "subSteps": [
                                    "Ler definição de Validação Facial como julgamento qualitativo de plausibilidade por experts.",
                                    "Identificar que é subjetiva por depender de opiniões humanas.",
                                    "Listar limitações gerais: falta de rigor quantitativo e dependência de conhecimento prévio.",
                                    "Estudar exemplos iniciais de simulações discretas onde falhou.",
                                    "Anotar por que não substitui validações estatísticas."
                                  ],
                                  "verification": "Criar um mapa mental com 5 limitações principais anotadas corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Artigo sobre validação de modelos de simulação, caderno para anotações, acesso à internet para referências.",
                                  "tips": "Use analogias cotidianas, como julgar uma receita só pelo cheiro, sem provar.",
                                  "learningObjective": "Entender as bases conceituais das limitações da Validação Facial.",
                                  "commonMistakes": "Confundir com validação estatística ou ignorar o aspecto qualitativo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a subjetividade e o viés de experts",
                                  "subSteps": [
                                    "Definir subjetividade: opiniões variam entre indivíduos.",
                                    "Exemplificar viés de experts: experiência limitada a cenários específicos.",
                                    "Discutir tipos de viés: confirmação, ancoragem e expertise estreita.",
                                    "Simular debate: listar argumentos de dois experts divergentes sobre um modelo.",
                                    "Documentar como mitigar com múltiplos experts independentes."
                                  ],
                                  "verification": "Escrever um parágrafo descrevendo um viés específico com exemplo em simulação discreta.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Vídeos curtos sobre viés cognitivo (YouTube/Khan Academy), exemplos de modelos de filas.",
                                  "tips": "Pergunte 'O que o expert não sabe?' para revelar viés.",
                                  "learningObjective": "Identificar e exemplificar subjetividade e viés na Validação Facial.",
                                  "commonMistakes": "Subestimar viés assumindo que experts são infalíveis."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Reconhecer a insuficiência para validar precisão quantitativa",
                                  "subSteps": [
                                    "Explicar que face validity checa plausibilidade, não exatidão numérica.",
                                    "Comparar com métricas quantitativas: erro médio quadrático, testes estatísticos.",
                                    "Analisar caso: modelo parece 'certo' mas falha em dados reais.",
                                    "Calcular exemplo simples: simulação de Monte Carlo vs. face validity.",
                                    "Listar cenários de simulação discreta onde quantitativo é essencial (ex: logística)."
                                  ],
                                  "verification": "Criar tabela comparando face validity vs. validação quantitativa com 4 diferenças.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software de simulação básico (AnyLogic trial ou Python com SimPy), planilha Excel.",
                                  "tips": "Sempre pergunte: 'Isso parece certo, mas os números batem?'",
                                  "learningObjective": "Diferenciar limites qualitativos de necessidades quantitativas.",
                                  "commonMistakes": "Achar que plausibilidade garante precisão numérica."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar riscos e recomendar combinações com outras técnicas",
                                  "subSteps": [
                                    "Listar riscos: decisões erradas em políticas públicas, desperdício de recursos.",
                                    "Discutir combinações: face validity + validação estatística + sensibilidade.",
                                    "Planejar protocolo híbrido para simulações discretas.",
                                    "Simular aplicação: escolher técnicas complementares para um modelo de tráfego.",
                                    "Redigir recomendação formal com justificativa."
                                  ],
                                  "verification": "Produzir um plano de validação híbrido com 3 técnicas integradas.",
                                  "estimatedTime": "55 minutos",
                                  "materials": "Template de relatório de validação, referências de livros como 'Simulation Modeling and Arena'.",
                                  "tips": "Priorize técnicas baseadas no contexto: qualitativo para inicial, quantitativo para final.",
                                  "learningObjective": "Formular estratégias para mitigar riscos usando abordagens integradas.",
                                  "commonMistakes": "Recomendar combinações sem justificar compatibilidade."
                                }
                              ],
                              "practicalExample": "Em uma simulação discreta de filas em um call center, um expert em telecom acha o modelo plausível (face validity), mas ignora viés de sua experiência em horários de pico; testes quantitativos revelam 20% de subestimação de tempo médio de espera devido à subjetividade.",
                              "finalVerifications": [
                                "Listar corretamente 5 limitações da Validação Facial.",
                                "Explicar viés de experts com exemplo em simulação discreta.",
                                "Diferenciar face validity de validação quantitativa em um diagrama.",
                                "Propor combinação com 2 técnicas complementares.",
                                "Identificar 3 riscos reais em aplicações práticas.",
                                "Redigir parágrafo recomendando uso híbrido."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de subjetividade e viés (30%)",
                                "Clareza na distinção qualitativo vs. quantitativo (25%)",
                                "Profundidade na análise de riscos (20%)",
                                "Qualidade das recomendações de combinação (15%)",
                                "Uso de exemplos concretos de simulação discreta (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Análise de viés e testes de hipótese.",
                                "Psicologia: Viés cognitivo em julgamentos de experts.",
                                "Ciência da Computação: Validação de algoritmos de simulação.",
                                "Gestão de Projetos: Riscos em modelagem preditiva.",
                                "Filosofia da Ciência: Limites do conhecimento empírico."
                              ],
                              "realWorldApplication": "Na simulação de propagação de epidemias (como COVID-19), face validity por experts médicos identifica plausibilidade inicial, mas combinação com dados quantitativos evita erros em políticas de lockdown, salvando recursos e vidas."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.3.1"
                            ]
                          },
                          {
                            "id": "10.1.5.2.3.3",
                            "name": "Aplicar em exemplos de sistemas discretos",
                            "description": "Analisar casos reais, como filas em bancos ou linhas de produção, onde validação facial confirmou plausibilidade do modelo antes de simulações extensas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e Descrever um Exemplo de Sistema Discreto Real",
                                  "subSteps": [
                                    "Pesquise exemplos comuns de sistemas discretos, como filas em bancos, linhas de produção ou semáforos.",
                                    "Escolha um exemplo específico, como uma fila de banco com múltiplos caixas.",
                                    "Descreva o sistema em detalhes: eventos de chegada de clientes, atendimento e saídas.",
                                    "Identifique os componentes discretos: chegadas aleatórias, tempos de serviço variáveis e estados da fila.",
                                    "Registre observações qualitativas do comportamento real do sistema."
                                  ],
                                  "verification": "Produzir uma descrição escrita de 200-300 palavras do sistema selecionado, destacando eventos discretos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e caneta ou editor de texto; acesso à internet para exemplos reais (vídeos ou artigos).",
                                  "tips": "Escolha um sistema familiar para facilitar a intuição inicial.",
                                  "learningObjective": "Identificar e descrever características discretas de sistemas reais.",
                                  "commonMistakes": "Confundir sistemas discretos com contínuos, como fluxo de tráfego em rodovias."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir um Modelo Conceitual Simples do Sistema",
                                  "subSteps": [
                                    "Defina os estados do sistema (ex.: número de clientes na fila).",
                                    "Liste os eventos principais (chegada de cliente, início/fim de atendimento).",
                                    "Esboce um diagrama de fluxo ou grafo de estados.",
                                    "Estime parâmetros iniciais intuitivos (taxa média de chegada, tempo médio de serviço).",
                                    "Compare o modelo conceitual com o sistema real descrito."
                                  ],
                                  "verification": "Criar um diagrama visual ou tabela de estados/eventos que represente o modelo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramentas de desenho (Draw.io, papel); calculadora para estimativas.",
                                  "tips": "Mantenha o modelo simples: foque em 3-5 estados principais.",
                                  "learningObjective": "Desenvolver uma representação conceitual básica de um sistema discreto.",
                                  "commonMistakes": "Sobrecarregar o modelo com variáveis desnecessárias no início."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a Validação Facial ao Modelo",
                                  "subSteps": [
                                    "Pergunte: 'O modelo parece plausível com base no conhecimento comum do sistema real?'",
                                    "Compare saídas esperadas do modelo (ex.: fila crescendo em horários de pico) com observações reais.",
                                    "Consulte especialistas ou pares para opiniões intuitivas.",
                                    "Identifique discrepâncias óbvias e ajuste o modelo conceitual.",
                                    "Documente justificativas para a plausibilidade ou ajustes necessários."
                                  ],
                                  "verification": "Relatório curto listando 5+ razões intuitivas para a plausibilidade do modelo.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Descrição do Passo 1; opiniões de colegas ou vídeos reais do sistema.",
                                  "tips": "Use analogias cotidianas para validar intuitivamente.",
                                  "learningObjective": "Avaliar intuitivamente a adequação do modelo à realidade.",
                                  "commonMistakes": "Ignorar intuições contrárias por apego ao modelo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Vantagens, Limitações e Confirmar Plausibilidade Antes de Simulações",
                                  "subSteps": [
                                    "Liste vantagens da validação facial (rápida, barata, detecta erros grosseiros).",
                                    "Discuta limitações (subjetiva, não quantitativa).",
                                    "Confirme se o modelo é plausível o suficiente para prosseguir a simulações extensas.",
                                    "Sugira próximos passos, como coleta de dados reais para validação estatística.",
                                    "Resuma lições aprendidas sobre aplicações em simulações discretas."
                                  ],
                                  "verification": "Produzir um resumo final de 1 página com análise de prós/contras e recomendação.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Relatórios dos passos anteriores; referências sobre validação facial.",
                                  "tips": "Equilibre otimismo com ceticismo para uma análise honesta.",
                                  "learningObjective": "Compreender o papel da validação facial no ciclo de modelagem.",
                                  "commonMistakes": "Superestimar a precisão da validação facial como substituta para testes rigorosos."
                                }
                              ],
                              "practicalExample": "Em uma fila de banco: clientes chegam a uma taxa média de 1 a cada 5 minutos (evento discreto); cada caixa atende em 10 minutos. Modelo conceitual: fila como fila M/M/2. Validação facial: 'Sim, filas crescem em pico matinal, caixas ociosos à tarde – plausível antes de simular 1000 chegadas'.",
                              "finalVerifications": [
                                "O modelo reflete comportamentos intuitivos observados no sistema real?",
                                "Foram identificados e corrigidos erros grosseiros no modelo?",
                                "Há consenso intuitivo (próprio ou de pares) sobre a plausibilidade?",
                                "Vantagens e limitações da validação facial foram explicitadas?",
                                "O modelo está pronto para simulações extensas sem falhas óbvias?",
                                "Exemplo real foi adequadamente mapeado ao modelo discreto?"
                              ],
                              "assessmentCriteria": [
                                "Descrição precisa e detalhada do sistema discreto real (20%)",
                                "Modelo conceitual claro e coerente (25%)",
                                "Aplicação rigorosa e documentada da validação facial (25%)",
                                "Análise equilibrada de vantagens/limitações (15%)",
                                "Conexão explícita com plausibilidade pré-simulação (10%)",
                                "Clareza e organização do relatório final (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Distribuições probabilísticas para chegadas/serviços",
                                "Programação: Implementação inicial em linguagens como Python (SimPy)",
                                "Engenharia de Produção: Otimização de filas e recursos",
                                "Gestão: Tomada de decisões baseadas em modelagem intuitiva"
                              ],
                              "realWorldApplication": "Em bancos e fábricas, validação facial confirma modelos de filas/produção antes de simulações caras, economizando tempo e recursos em otimização de processos reais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.2.3",
                              "10.1.5.2.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.3",
                    "name": "Validação Estatística",
                    "description": "Comparação quantitativa de saídas do modelo com dados reais do sistema usando estatísticas descritivas e gráficos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.3.1",
                        "name": "Estatísticas Descritivas para Validação",
                        "description": "Cálculo e comparação de medidas resumidas como média, variância e percentis entre saídas do modelo de simulação e dados reais do sistema para avaliar a fidelidade do modelo.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.1.1",
                            "name": "Calcular medidas de tendência central",
                            "description": "Computar média, mediana e moda a partir de dados reais e saídas do modelo de simulação discreta, utilizando ferramentas como planilhas ou linguagens de programação (ex: Python com NumPy).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e Organizar Dados de Simulação Discreta",
                                  "subSteps": [
                                    "Colete um conjunto de dados reais ou de saída de modelo de simulação discreta, como tempos de espera em uma fila (ex: [5, 7, 3, 8, 5, 9, 4]).",
                                    "Ordene os dados em ordem crescente para facilitar cálculos de mediana e moda.",
                                    "Identifique o tipo de dados (numéricos discretos ou contínuos) e verifique por valores ausentes ou outliers.",
                                    "Importe os dados para uma planilha (Google Sheets ou Excel) e para um ambiente Python com NumPy.",
                                    "Crie uma tabela resumida com contagens de frequência para moda."
                                  ],
                                  "verification": "Dados organizados em planilha e script Python prontos, com ordenação confirmada e sem erros de importação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Planilha (Excel/Google Sheets)",
                                    "Python com NumPy e Pandas instalados",
                                    "Conjunto de dados de simulação (ex: arquivo CSV)"
                                  ],
                                  "tips": "Use funções de ordenação automática na planilha para agilizar; sempre salve uma cópia dos dados originais.",
                                  "learningObjective": "Dominar a preparação de dados estatísticos para cálculos precisos de tendência central.",
                                  "commonMistakes": [
                                    "Ignorar outliers que distorcem a média",
                                    "Não ordenar dados para mediana",
                                    "Confundir dados categóricos com numéricos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a Média Aritmética",
                                  "subSteps": [
                                    "Na planilha: Use a função AVERAGE() ou SUM()/COUNT() sobre a coluna de dados.",
                                    "Em Python: Importe NumPy e use np.mean(dados).",
                                    "Some manualmente os valores e divida pelo número de observações para verificação cruzada.",
                                    "Registre o resultado com precisão decimal adequada (ex: 2 casas).",
                                    "Compare resultados entre planilha e Python para consistência."
                                  ],
                                  "verification": "Resultados idênticos em planilha, Python e cálculo manual, com valor documentado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Planilha aberta com dados",
                                    "Editor Python (Jupyter Notebook ou VS Code)"
                                  ],
                                  "tips": "Arredonde apenas no final; use np.mean() com precisão full em Python.",
                                  "learningObjective": "Executar e verificar cálculo de média em múltiplas ferramentas computacionais.",
                                  "commonMistakes": [
                                    "Dividir pela contagem errada",
                                    "Incluir labels como dados numéricos",
                                    "Não verificar com soma manual"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Mediana e Moda",
                                  "subSteps": [
                                    "Para mediana na planilha: Use MEDIAN(); em Python: np.median(dados).",
                                    "Para moda na planilha: Use MODE() ou MODE.MULT() para multimodal; em Python: scipy.stats.mode() ou collections.Counter.",
                                    "Para conjuntos pares/ímpares, confirme posição mediana manualmente (n+1)/2.",
                                    "Identifique se há moda unimodal, bimodal ou amodal.",
                                    "Documente resultados e compare entre ferramentas."
                                  ],
                                  "verification": "Mediana e moda calculadas corretamente em ambas ferramentas, com identificação de multimodalidade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha",
                                    "Python com NumPy e SciPy",
                                    "Documentação de funções (opcional: docs online)"
                                  ],
                                  "tips": "Para moda em Python, prefira Counter para simplicidade em dados pequenos.",
                                  "learningObjective": "Aplicar fórmulas de mediana e moda a dados ordenados em contextos computacionais.",
                                  "commonMistakes": [
                                    "Usar posição errada para mediana em amostras pares",
                                    "Ignorar múltiplas modas",
                                    "Aplicar MODE() em dados não inteiros"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Resultados e Validar no Contexto de Simulação",
                                  "subSteps": [
                                    "Compare média, mediana e moda: Discuta se a distribuição é simétrica ou enviesada.",
                                    "Relacione com validação do modelo: Ex: média de tempos de espera próxima ao teórico indica bom modelo.",
                                    "Gere gráfico (histograma ou boxplot) na planilha/Python para visualização.",
                                    "Teste sensibilidade removendo outliers e recalculando.",
                                    "Escreva um relatório curto com conclusões estatísticas."
                                  ],
                                  "verification": "Relatório com interpretações, gráficos e comparações gerados e salvos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha com gráficos",
                                    "Python com Matplotlib/Seaborn",
                                    "Template de relatório simples"
                                  ],
                                  "tips": "Use boxplot para detectar outliers visualmente; relacione sempre ao objetivo da simulação.",
                                  "learningObjective": "Interpretar medidas de tendência central para validar modelos de simulação discreta.",
                                  "commonMistakes": [
                                    "Interpretar média como sempre representativa em distribuições enviesadas",
                                    "Omitir visualizações",
                                    "Não contextualizar com simulação"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado, dados de tempos de espera: [2.5, 3.0, 2.8, 4.1, 3.2, 2.9, 5.0]. Média: 3.36 min; Mediana: 3.0 min; Moda: Nenhuma (unimodal aproximada em 3.0). Use para validar se o modelo reflete tempos reais observados.",
                              "finalVerifications": [
                                "Cálculos de média, mediana e moda coincidem entre planilha, Python e manual.",
                                "Dados preparados corretamente ordenados e sem erros de importação.",
                                "Interpretação contextualizada à validação de simulação discreta.",
                                "Gráficos gerados mostram distribuição e outliers.",
                                "Relatório final resume resultados e implicações.",
                                "Testes de sensibilidade realizados com outliers."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos (erro < 0.01).",
                                "Uso correto de ferramentas (planilha e Python).",
                                "Qualidade da preparação e organização de dados.",
                                "Profundidade da interpretação e conexão com simulação.",
                                "Clareza de gráficos e relatório.",
                                "Identificação e tratamento de casos especiais (multimodal, outliers)."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Uso de NumPy/SciPy para computação estatística.",
                                "Estatística: Fundamentos de descriptivas em validação de modelos.",
                                "Simulação: Aplicação em sistemas discretos (ex: filas, redes).",
                                "Ciência de Dados: Visualização com Matplotlib e análise exploratória.",
                                "Matemática Aplicada: Tendência central em contextos reais."
                              ],
                              "realWorldApplication": "Em engenharia de processos, calcular medidas de tendência central em saídas de simulações de filas (ex: call centers) para validar modelos contra dados reais, otimizando tempos de serviço e reduzindo custos operacionais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.1.2",
                            "name": "Calcular medidas de dispersão",
                            "description": "Determinar variância, desvio padrão e intervalo interquartil (IQR) para dados reais e do modelo, identificando discrepâncias que indiquem problemas na modelagem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Coleta e Organização dos Dados",
                                  "subSteps": [
                                    "Identifique os conjuntos de dados reais e do modelo (ex: tempos de processamento reais vs simulados).",
                                    "Ordene os dados em ordem crescente para facilitar cálculos posteriores.",
                                    "Calcule estatísticas básicas iniciais: média, mediana e número de observações (n).",
                                    "Registre os dados em uma tabela ou planilha para visualização.",
                                    "Verifique a presença de outliers preliminarmente."
                                  ],
                                  "verification": "Conferir se os dados estão ordenados corretamente e médias coincidem com cálculos manuais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Planilha Excel ou Google Sheets, conjunto de dados reais e simulados.",
                                  "tips": "Use funções como SORT() no Excel para ordenação automática.",
                                  "learningObjective": "Organizar dados de forma estruturada para análises estatísticas.",
                                  "commonMistakes": "Ignorar outliers iniciais ou confundir dados reais com simulados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Cálculo da Variância e Desvio Padrão",
                                  "subSteps": [
                                    "Calcule a variância amostral: subtraia a média de cada valor, eleve ao quadrado, some e divida por (n-1).",
                                    "Calcule a variância populacional dividindo por n, se aplicável.",
                                    "Obtenha o desvio padrão como raiz quadrada da variância.",
                                    "Repita para dados reais e do modelo.",
                                    "Compare os valores obtidos entre real e simulação."
                                  ],
                                  "verification": "Validar com fórmula manual em poucos dados e comparar com função VAR.S() no Excel.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora científica, Excel ou Python (biblioteca numpy).",
                                  "tips": "Lembre-se: use variância amostral (divisor n-1) para inferência estatística.",
                                  "learningObjective": "Dominar fórmulas de variância e desvio padrão para conjuntos univariados.",
                                  "commonMistakes": "Usar divisor n em vez de n-1 para amostras ou esquecer raiz quadrada no desvio padrão."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Cálculo do Intervalo Interquartil (IQR)",
                                  "subSteps": [
                                    "Encontre o primeiro quartil (Q1): mediana da metade inferior dos dados ordenados.",
                                    "Encontre o terceiro quartil (Q3): mediana da metade superior.",
                                    "Calcule IQR = Q3 - Q1.",
                                    "Repita para dados reais e simulados.",
                                    "Identifique boxplot preliminar para visualização."
                                  ],
                                  "verification": "Conferir Q1 e Q3 com função QUARTIL.EXC() no Excel e calcular IQR manualmente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Excel com gráficos de boxplot, ou Python (pandas e matplotlib).",
                                  "tips": "Para n ímpar, ignore o valor mediano ao dividir metades.",
                                  "learningObjective": "Calcular e interpretar medidas de dispersão robustas como IQR.",
                                  "commonMistakes": "Confundir Q1/Q3 com percentis ou incluir mediana nas metades incorretamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparação e Identificação de Discrepâncias",
                                  "subSteps": [
                                    "Compare variância, desvio padrão e IQR entre dados reais e modelo.",
                                    "Calcule diferenças percentuais: |(real - modelo)/real| * 100%.",
                                    "Interprete discrepâncias: alta variância no modelo indica subestimação de variabilidade.",
                                    "Crie tabela de comparação e gráfico (ex: boxplots lado a lado).",
                                    "Documente implicações para validação do modelo."
                                  ],
                                  "verification": "Discrepâncias quantificadas e interpretadas corretamente em relatório curto.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Software de gráficos (Excel, Python matplotlib), tabela de comparação.",
                                  "tips": "Use limiares como 10-20% para considerar discrepância significativa.",
                                  "learningObjective": "Analisar discrepâncias estatísticas para validar modelos simulados.",
                                  "commonMistakes": "Ignorar escala dos dados ao comparar ou superestimar pequenas diferenças."
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado, dados reais: tempos de espera [2, 3, 5, 7, 10] min; modelo: [2.5, 3, 4, 6, 8] min. Calcule variância real ≈ 11.7, modelo ≈ 4.3; desvio padrão real ≈ 3.42, modelo ≈ 2.07; IQR real=5, modelo=3.5. Discrepância indica modelo subestima variabilidade.",
                              "finalVerifications": [
                                "Variância e desvio padrão calculados corretamente para ambos conjuntos.",
                                "IQR determinado com Q1 e Q3 precisos.",
                                "Discrepâncias quantificadas e comparadas numericamente.",
                                "Gráficos ou tabelas de comparação gerados.",
                                "Interpretação escrita de implicações para o modelo.",
                                "Ausência de erros aritméticos em cálculos manuais."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos matemáticos (erro <1%).",
                                "Correta distinção entre amostral e populacional.",
                                "Interpretação qualitativa e quantitativa de discrepâncias.",
                                "Uso adequado de ferramentas e visualizações.",
                                "Clareza na documentação e relatório.",
                                "Identificação de pelo menos uma implicação prática."
                              ],
                              "crossCurricularConnections": [
                                "Estatística Descritiva: Integra com medidas de tendência central.",
                                "Programação Computacional: Implementação em Python/R para automação.",
                                "Validação de Modelos: Conexão com testes de hipóteses.",
                                "Ciência de Dados: Visualização e análise exploratória de dados."
                              ],
                              "realWorldApplication": "Na indústria farmacêutica, calcular dispersão em tempos de produção reais vs modelo para detectar falhas na simulação, garantindo conformidade regulatória e otimização de processos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.1.3",
                            "name": "Comparar estatísticas descritivas",
                            "description": "Realizar comparação quantitativa entre estatísticas calculadas (ex: diferença percentual entre médias), definindo critérios de aceitação para validar o modelo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Calcular Estatísticas Descritivas para Dados Reais e Simulados",
                                  "subSteps": [
                                    "Coletar dados reais do sistema (ex: tempos de chegada em uma fila)",
                                    "Executar simulação para gerar dados equivalentes",
                                    "Calcular estatísticas chave: média, mediana, desvio padrão, variância para ambos os conjuntos",
                                    "Registrar valores em tabela comparativa",
                                    "Verificar consistência dos cálculos com fórmulas padrão"
                                  ],
                                  "verification": "Tabela preenchida com valores numéricos idênticos em recálculos independentes",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha Excel ou Python (pandas/numpy), dados reais e simulados",
                                  "tips": "Use funções built-in como np.mean() para precisão",
                                  "learningObjective": "Dominar cálculo preciso de estatísticas descritivas em contextos comparativos",
                                  "commonMistakes": "Ignorar outliers que distorcem a média; confundir população com amostra"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar Métricas de Comparação Quantitativa",
                                  "subSteps": [
                                    "Identificar estatísticas relevantes para o modelo (ex: média para throughput)",
                                    "Definir fórmula de diferença percentual: |(simulado - real)/real| * 100%",
                                    "Escolher outras métricas: razão de variâncias, intervalo de confiança",
                                    "Justificar seleção baseada no contexto do sistema discreto",
                                    "Documentar critérios em um checklist"
                                  ],
                                  "verification": "Lista de métricas com fórmulas e justificativas documentadas",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Folha de referência de métricas estatísticas, software de documentação",
                                  "tips": "Priorize métricas sensíveis ao tipo de sistema (ex: variância para filas)",
                                  "learningObjective": "Selecionar métricas apropriadas para validação estatística",
                                  "commonMistakes": "Usar métrica inadequada (ex: média para dados assimétricos); ignorar escala dos dados"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar Comparações Quantitativas",
                                  "subSteps": [
                                    "Aplicar fórmulas às estatísticas calculadas para cada par (real vs simulado)",
                                    "Calcular diferenças percentuais e outras métricas para todas estatísticas chave",
                                    "Visualizar com gráficos (ex: bar chart de diferenças)",
                                    "Interpretar resultados: identificar discrepâncias maiores que 5%",
                                    "Anotar padrões de erro sistemático"
                                  ],
                                  "verification": "Gráficos e tabela de diferenças percentuais gerados e salvos",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Python (matplotlib/seaborn) ou Excel para gráficos",
                                  "tips": "Automatize cálculos em script para replicabilidade",
                                  "learningObjective": "Realizar e interpretar comparações quantitativas com precisão",
                                  "commonMistakes": "Erro aritmético em fórmulas; interpretação errada de sinais (positivo/negativo)"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir e Aplicar Critérios de Aceitação para Validação",
                                  "subSteps": [
                                    "Estabelecer thresholds baseados em literatura (ex: <10% para médias)",
                                    "Comparar resultados obtidos com critérios pré-definidos",
                                    "Classificar modelo: validado, parcialmente validado ou rejeitado",
                                    "Documentar decisão com evidências quantitativas",
                                    "Sugerir ajustes no modelo se critérios não atendidos"
                                  ],
                                  "verification": "Relatório final com decisão de validação e thresholds aplicados",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Referências de validação estatística, template de relatório",
                                  "tips": "Use critérios conservadores para simulações críticas",
                                  "learningObjective": "Definir critérios objetivos para validar modelos simulados",
                                  "commonMistakes": "Thresholds subjetivos sem base; ignorar múltiplas estatísticas"
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado: dados reais mostram média de espera de 5 minutos (desvio padrão 2 min); simulação gera 5.2 min (2.1 min). Diferença percentual na média: 4%, na variância: 9.6%. Critério: <10% → modelo validado.",
                              "finalVerifications": [
                                "Todas diferenças percentuais < threshold definido (ex: 10%)",
                                "Gráficos mostram sobreposição visual entre distribuições",
                                "Relatório documenta todas estatísticas e decisões",
                                "Recálculo independente confirma resultados",
                                "Sugestões de refinamento do modelo se aplicável",
                                "Checklist de critérios 100% atendido"
                              ],
                              "assessmentCriteria": [
                                "Precisão dos cálculos estatísticos (erro <1%)",
                                "Adequação das métricas escolhidas ao contexto",
                                "Clareza na documentação e visualizações",
                                "Rigor nos critérios de aceitação",
                                "Interpretação correta dos resultados",
                                "Completude de todos os passos documentados"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Uso de bibliotecas como pandas para automação",
                                "Estatística: Conceitos de inferência e testes de hipótese",
                                "Engenharia de Software: Validação de modelos em simulações",
                                "Ciência de Dados: Análise exploratória e visualização"
                              ],
                              "realWorldApplication": "Validação de modelos de simulação em logística (ex: otimização de supply chain na Amazon), manufatura (controle de qualidade em linhas de produção) e saúde (simulação de fluxos de pacientes em hospitais), garantindo que simulações reflitam realidade para decisões baseadas em dados."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.3.2",
                        "name": "Análise Gráfica para Validação",
                        "description": "Uso de gráficos para visualização comparativa das distribuições e comportamentos das saídas do modelo versus dados reais, facilitando a detecção visual de inadequações.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.2.1",
                            "name": "Construir histogramas comparativos",
                            "description": "Gerar histogramas sobrepostos ou lado a lado dos dados reais e do modelo usando bibliotecas como Matplotlib ou R, analisando similaridade de formas de distribuição.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e carregar os dados reais e do modelo",
                                  "subSteps": [
                                    "Colete os dados reais de uma fonte confiável (ex: arquivo CSV com medições empíricas).",
                                    "Gere ou carregue os dados simulados do modelo (ex: simulação Monte Carlo).",
                                    "Limpe os dados removendo valores ausentes ou outliers extremos usando funções como dropna() no Pandas.",
                                    "Verifique estatísticas descritivas básicas (média, variância) para ambos os conjuntos.",
                                    "Divida os dados em bins preliminares para entender o range de valores."
                                  ],
                                  "verification": "Execute df.describe() e confirme que ambos os datasets têm o mesmo número de observações e ranges semelhantes.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "Biblioteca Pandas",
                                    "Arquivos CSV com dados reais e simulados"
                                  ],
                                  "tips": "Use seed para reproducibilidade nos dados simulados: np.random.seed(42).",
                                  "learningObjective": "Dominar a preparação de datasets para análise comparativa de distribuições.",
                                  "commonMistakes": [
                                    "Ignorar outliers que distorcem a escala",
                                    "Não alinhar o número de amostras entre real e modelo",
                                    "Esquecer de normalizar escalas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar o ambiente e importar bibliotecas",
                                  "subSteps": [
                                    "Instale as bibliotecas necessárias: pip install matplotlib pandas numpy.",
                                    "Importe as bibliotecas: import matplotlib.pyplot as plt, import pandas as pd, import numpy as np.",
                                    "Defina o estilo do plot para melhor visualização: plt.style.use('seaborn-v0_8').",
                                    "Crie figure e axes para subplots: fig, ax = plt.subplots(1, 2, figsize=(12,5)).",
                                    "Ajuste parâmetros globais como bins=30 e alpha=0.7 para transparência."
                                  ],
                                  "verification": "Execute os imports sem erros e plt.style.available para confirmar estilos.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Ambiente Jupyter Notebook ou IDE Python",
                                    "Internet para pip install"
                                  ],
                                  "tips": "Use %matplotlib inline em notebooks para visualização imediata.",
                                  "learningObjective": "Configurar eficientemente ferramentas de visualização para análises comparativas.",
                                  "commonMistakes": [
                                    "Usar bins fixos sem testar",
                                    "Esquecer alpha para sobreposições",
                                    "Não definir figsize adequado"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir histogramas comparativos lado a lado e sobrepostos",
                                  "subSteps": [
                                    "Plote histograma lado a lado: ax[0].hist(dados_reais, bins=30, alpha=0.7, label='Real', color='blue').",
                                    "Adicione o histograma do modelo no mesmo subplot: ax[0].hist(dados_modelo, bins=30, alpha=0.7, label='Modelo', color='red').",
                                    "Crie subplot sobreposto: ax[1].hist([dados_reais, dados_modelo], bins=30, label=['Real', 'Modelo'], alpha=0.7).",
                                    "Adicione labels, título e legenda: ax[0].set_title('Comparação Lado a Lado'), ax[0].legend().",
                                    "Salve o gráfico: plt.savefig('histogramas_comparativos.png', dpi=300)."
                                  ],
                                  "verification": "Visualize o plot e confirme que ambas as distribuições são visíveis sem sobreposição excessiva ou clipping.",
                                  "estimatedTime": "25-40 minutos",
                                  "materials": [
                                    "Código Python preparado",
                                    "Datasets do Step 1"
                                  ],
                                  "tips": "Teste diferentes números de bins (20-50) para otimizar resolução.",
                                  "learningObjective": "Gerar visualizações gráficas comparativas claras usando Matplotlib.",
                                  "commonMistakes": [
                                    "Bins diferentes entre histogramas",
                                    "Cores semelhantes causando confusão",
                                    "Falta de legendas ou títulos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar similaridade das formas de distribuição",
                                  "subSteps": [
                                    "Observe picos, caudas e simetria visualmente nos histogramas.",
                                    "Calcule métricas quantitativas: KS test com scipy.stats.ks_2samp(dados_reais, dados_modelo).",
                                    "Identifique discrepâncias: ex: 'Modelo tem cauda mais pesada que real'.",
                                    "Documente observações em um relatório Markdown ou comentários no código.",
                                    "Itere ajustando o modelo se similaridade baixa (ex: recalibre parâmetros)."
                                  ],
                                  "verification": "p-value do KS test > 0.05 indica similaridade estatística; anote 3+ observações qualitativas.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Biblioteca SciPy",
                                    "Histogramas gerados"
                                  ],
                                  "tips": "Combine análise visual com testes estatísticos para robustez.",
                                  "learningObjective": "Interpretar e quantificar similaridades em distribuições empíricas vs simuladas.",
                                  "commonMistakes": [
                                    "Confiar só na visão sem testes stats",
                                    "Ignorar amostras pequenas (<1000)",
                                    "Não considerar normalização prévia"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de sistema de filas (ex: chegada de clientes a uma loja), use dados reais de 1000 chegadas (CSV) vs 1000 simulações Poisson (lambda=5). Plote histogramas lado a lado e sobrepostos para validar se o modelo captura a distribuição bimodal real.",
                              "finalVerifications": [
                                "Histogramas lado a lado e sobrepostos gerados e salvos sem erros.",
                                "Ambas distribuições visíveis com alpha adequado e legendas claras.",
                                "Análise qualitativa documentada com pelo menos 3 observações sobre similaridades/discrepâncias.",
                                "Teste KS executado com p-value reportado.",
                                "Gráfico salvo em alta resolução e interpretado corretamente.",
                                "Código reproduzível com seed e comentários."
                              ],
                              "assessmentCriteria": [
                                "Precisão na preparação de dados (ranges e tamanhos alinhados).",
                                "Qualidade visual dos histogramas (bins ótimos, cores distintas, labels).",
                                "Correção na análise (qualitativa + quantitativa via KS test).",
                                "Uso eficiente de bibliotecas e boas práticas de código.",
                                "Profundidade da interpretação de similaridades.",
                                "Reprodutibilidade e documentação do processo."
                              ],
                              "crossCurricularConnections": [
                                "Estatística Descritiva: Cálculo de momentos e testes de aderência.",
                                "Programação Computacional: Manipulação de dados com Pandas/Numpy.",
                                "Visualização de Dados: Princípios de design gráfico em Matplotlib.",
                                "Simulação e Modelagem: Validação de modelos estocásticos."
                              ],
                              "realWorldApplication": "Validação de modelos generativos em Machine Learning (ex: GANs para imagens), simulações financeiras (distribuições de retornos), ou controle de qualidade em manufatura (comparar sensores reais vs simulações para detectar falhas)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.2.2",
                            "name": "Criar gráficos QQ (Quantile-Quantile)",
                            "description": "Plotar gráficos QQ para comparar a distribuição empírica dos dados reais com a do modelo, verificando se os pontos seguem a linha reta (indício de similaridade distributional).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os dados empíricos e simulados",
                                  "subSteps": [
                                    "Colete ou carregue o conjunto de dados reais (empíricos) de uma simulação ou experimento, garantindo que esteja limpo e sem valores ausentes.",
                                    "Gere ou carregue o conjunto de dados simulados do modelo a ser validado, com o mesmo tamanho da amostra dos dados reais.",
                                    "Ordene ambos os conjuntos de dados em ordem crescente para facilitar o cálculo de quantis.",
                                    "Verifique estatísticas descritivas básicas (média, mediana, variância) para garantir compatibilidade inicial.",
                                    "Salve os dados em arrays ou listas nomeados, como 'dados_reais' e 'dados_simulados'."
                                  ],
                                  "verification": "Confirme que ambos os arrays têm o mesmo comprimento e estão ordenados usando print ou len() e sorted().",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python com NumPy e Pandas",
                                    "Conjuntos de dados reais e simulados (ex: CSV ou arrays gerados)"
                                  ],
                                  "tips": "Use np.sort() para ordenação eficiente; padronize escalas se necessário.",
                                  "learningObjective": "Entender a importância de dados limpos e ordenados para análise QQ.",
                                  "commonMistakes": [
                                    "Ignorar valores ausentes",
                                    "Usar tamanhos de amostra diferentes",
                                    "Não ordenar os dados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular quantis empíricos e teóricos",
                                  "subSteps": [
                                    "Defina a distribuição teórica assumida pelo modelo (ex: normal, exponencial) com parâmetros estimados dos dados reais.",
                                    "Calcule os quantis teóricos usando funções como ppf (percent point function) da scipy.stats para a distribuição escolhida.",
                                    "Calcule os quantis empíricos plotando os dados ordenados contra probabilidades teóricas (ex: (i-0.5)/n).",
                                    "Armazene quantis em arrays separados: quantis_empiricos e quantis_teoricos.",
                                    "Visualize rapidamente os quantis com um scatter plot preliminar para inspeção."
                                  ],
                                  "verification": "Execute um plot scatter simples dos quantis e confirme que os pontos estão alinhados aproximadamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Biblioteca SciPy (scipy.stats)",
                                    "NumPy para cálculos numéricos"
                                  ],
                                  "tips": "Para distribuição normal, use stats.norm.ppf; ajuste parâmetros com stats.norm.fit(dados_reais).",
                                  "learningObjective": "Dominar o cálculo de quantis para comparação distributional.",
                                  "commonMistakes": [
                                    "Escolha errada de distribuição teórica",
                                    "Índices incorretos para probabilidades empíricas (use i-0.5/n)",
                                    "Não estimar parâmetros corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Plotar o gráfico QQ",
                                  "subSteps": [
                                    "Importe matplotlib.pyplot e scipy.stats para probplot.",
                                    "Use stats.probplot(dados_reais, dist='norm', plot=plt) ou função manual com plt.scatter(quantis_teoricos, quantis_empiricos).",
                                    "Adicione rótulos aos eixos: 'Quantis Teóricos' (x) e 'Quantis Empíricos' (y).",
                                    "Inclua título como 'Gráfico QQ: Dados Reais vs Modelo Normal'.",
                                    "Ajuste o grid e limites dos eixos para melhor visualização."
                                  ],
                                  "verification": "O gráfico deve mostrar pontos scatter com uma linha de referência reta (y=x ou ajustada).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Matplotlib para plotting",
                                    "SciPy para probplot automatizado"
                                  ],
                                  "tips": "probplot() gera QQ pronto; para custom, use plt.plot([min,max], [min,max], 'r--') para linha de referência.",
                                  "learningObjective": "Criar visualizações QQ precisas e informativas.",
                                  "commonMistakes": [
                                    "Eixos trocados",
                                    "Falta da linha de referência",
                                    "Escala inadequada nos eixos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e validar o gráfico QQ",
                                  "subSteps": [
                                    "Verifique se os pontos seguem a linha reta: desvio indica falta de similaridade distributional.",
                                    "Identifique padrões de desvio (ex: curvatura em S sugere não-normalidade).",
                                    "Calcule uma métrica quantitativa como correlação de Pearson entre quantis (deve ser próxima de 1).",
                                    "Compare com dados simulados: plote QQ para simulados vs reais se aplicável.",
                                    "Documente conclusões: 'Distribuições similares' se alinhados, senão 'Rejeitar modelo'."
                                  ],
                                  "verification": "Correlação > 0.95 e inspeção visual confirma alinhamento; salve o gráfico com plt.savefig().",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "NumPy para np.corrcoef(quantis_teoricos, quantis_empiricos)"
                                  ],
                                  "tips": "Use zoom para tails; correlação alta não garante tudo, cheque visualmente.",
                                  "learningObjective": "Interpretar QQ para validar modelos estatisticamente.",
                                  "commonMistakes": [
                                    "Ignorar tails do gráfico",
                                    "Confundir correlação com causalidade",
                                    "Não quantificar o alinhamento"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Refinar e reportar resultados",
                                  "subSteps": [
                                    "Teste sensibilidade variando distribuição teórica ou parâmetros.",
                                    "Gere múltiplos QQ para subconjuntos de dados.",
                                    "Crie um relatório com o gráfico, correlação e interpretação.",
                                    "Salve código e outputs em notebook Jupyter para reprodutibilidade.",
                                    "Discuta limitações (ex: tamanho amostral pequeno)."
                                  ],
                                  "verification": "Relatório completo com gráfico salvo e código executável sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Jupyter Notebook ou script Python"
                                  ],
                                  "tips": "Use plt.tight_layout() para formatação; version control com Git.",
                                  "learningObjective": "Aplicar QQ em workflow completo de validação.",
                                  "commonMistakes": [
                                    "Não testar múltiplas distribuições",
                                    "Relatório sem métricas quantitativas",
                                    "Código não reproduzível"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de tempos de espera em uma fila M/M/1 (distribuição exponencial), carregue 1000 tempos reais de um call center e 1000 simulados. Plote QQ exponencial: se pontos seguem y=x, modelo válido; desvios indicam necessidade de ajustar λ.",
                              "finalVerifications": [
                                "Gráfico QQ gerado corretamente com linha de referência.",
                                "Correlação de quantis > 0.95 calculada e reportada.",
                                "Interpretação escrita distingue similaridade ou não.",
                                "Código roda sem erros em dados de teste.",
                                "Relatório inclui limitações e sugestões.",
                                "Teste com dados simulados conhecidos (ex: normal) confirma alinhamento perfeito."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de quantis (erro < 1%).",
                                "Qualidade visual do gráfico (rótulos, grid, legenda).",
                                "Correta interpretação de alinhamento/devios.",
                                "Uso apropriado de bibliotecas SciPy/Matplotlib.",
                                "Reprodutibilidade e documentação do código.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Testes de aderência e normalidade.",
                                "Programação: Manipulação de dados com Python/NumPy.",
                                "Visualização de Dados: Técnicas de plotting com Matplotlib.",
                                "Simulação Computacional: Validação de Monte Carlo.",
                                "Análise de Sistemas: Modelagem de filas e processos estocásticos."
                              ],
                              "realWorldApplication": "Em finanças, validar simulações de retornos de portfólio contra dados históricos para risco; em manufatura, checar se tempos de processamento simulados matcham reais para otimizar linhas de produção."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.2.3",
                            "name": "Elaborar gráficos de séries temporais",
                            "description": "Comparar séries temporais ou boxplots de saídas agregadas do modelo e dados reais para identificar padrões, sazonalidades ou desvios no comportamento dinâmico do sistema.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os dados reais e do modelo",
                                  "subSteps": [
                                    "Coletar séries temporais de dados reais e saídas agregadas do modelo (ex.: médias por período).",
                                    "Verificar e tratar valores ausentes, outliers e desalinhamentos temporais usando interpolação ou remoção.",
                                    "Criar colunas alinhadas: timestamp, valor_real, valor_modelo.",
                                    "Agreg ar dados em intervalos regulares (diário, horário) se necessário.",
                                    "Normalizar escalas para comparação justa (ex.: z-score)."
                                  ],
                                  "verification": "DataFrame ou tabela com colunas timestamp, valor_real e valor_modelo sem erros de alinhamento ou NaNs.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python com Pandas",
                                    "Dados de exemplo em CSV",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Use pd.to_datetime() para padronizar timestamps e merge_asof() para alinhar séries irregulares.",
                                  "learningObjective": "Dominar a limpeza e alinhamento de dados temporais para visualização comparativa.",
                                  "commonMistakes": [
                                    "Desalinhar timestamps levando a comparações erradas",
                                    "Ignorar outliers que distorcem escalas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e planejar o tipo de gráfico",
                                  "subSteps": [
                                    "Avaliar objetivo: séries temporais lineares para tendências dinâmicas ou boxplots para distribuições sazonais.",
                                    "Definir eixos: tempo no eixo x, valores no y; incluir linhas/duplas para modelo vs real.",
                                    "Escolher escalas (linear/log) e agregações (média, mediana).",
                                    "Planejar anotações para sazonalidades esperadas (ex.: picos diários).",
                                    "Esboçar o gráfico manualmente ou em papel para validar layout."
                                  ],
                                  "verification": "Descrição escrita ou esboço com tipo de gráfico, eixos e elementos chave definidos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de diagramação como Draw.io",
                                    "Documentação de bibliotecas de plot (Matplotlib/Seaborn)"
                                  ],
                                  "tips": "Boxplots são ideais para variabilidade sazonal; linhas para evolução contínua.",
                                  "learningObjective": "Escolher representações gráficas adequadas para validação temporal.",
                                  "commonMistakes": [
                                    "Usar boxplots para tendências longas sem agregação",
                                    "Sobrecarregar gráfico com muitos dados sem downsampling"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar os gráficos de comparação",
                                  "subSteps": [
                                    "Importar bibliotecas: import matplotlib.pyplot as plt; import seaborn as sns.",
                                    "Plotar séries temporais: plt.plot(tempo, real, label='Real'); plt.plot(tempo, modelo, label='Modelo').",
                                    "Para boxplots: sns.boxplot(data=df_melted, x='periodo', y='valor', hue='fonte').",
                                    "Adicionar legendas, títulos, grids e salvar como PNG/PDF.",
                                    "Superpor ou subplot para múltiplas visualizações."
                                  ],
                                  "verification": "Gráficos gerados e salvos mostrando sobreposição clara de modelo vs real.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com Matplotlib e Seaborn",
                                    "Jupyter Notebook",
                                    "Dados preparados do step 1"
                                  ],
                                  "tips": "Use plt.figure(figsize=(12,6)) para layouts legíveis e twinx() para eixos duplos se escalas diferem.",
                                  "learningObjective": "Implementar visualizações comparativas de séries temporais em código.",
                                  "commonMistakes": [
                                    "Esquecer labels/legends tornando gráfico ilegível",
                                    "Escalas inadequadas escondendo desvios"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar gráficos e identificar padrões",
                                  "subSteps": [
                                    "Observar sobreposições: tendências, sazonalidades (picos/vaus coincidentes?).",
                                    "Detectar desvios: lags, biases sistemáticos ou variâncias excessivas.",
                                    "Quantificar visualmente: RMSE aproximado ou intervalos de confiança.",
                                    "Documentar achados em relatório com screenshots anotados.",
                                    "Sugerir ajustes no modelo baseados em discrepâncias."
                                  ],
                                  "verification": "Relatório com 3+ padrões/desvios identificados e recomendações.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Gráficos gerados",
                                    "Editor de texto ou Markdown"
                                  ],
                                  "tips": "Use zoom em regiões críticas e compare com métricas numéricas para validação.",
                                  "learningObjective": "Extrair insights de validação gráfica para melhoria de modelos.",
                                  "commonMistakes": [
                                    "Interpretar correlação como causalidade",
                                    "Ignorar ruído natural vs erro modelo"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de sistema de filas em call center, plote séries temporais de tempo médio de espera real (dados históricos) vs modelo (simulado), revelando sazonalidade subestimada nos picos de almoço, com boxplots por hora mostrando variância maior no modelo.",
                              "finalVerifications": [
                                "Gráficos gerados comparam claramente modelo vs real com legendas e escalas adequadas.",
                                "Padrões (tendências, sazonalidades) e desvios documentados em relatório.",
                                "Código reproduzível gera os mesmos gráficos.",
                                "Interpretação inclui pelo menos 3 insights acionáveis.",
                                "Arquivos salvos em formatos profissionais (PNG/PDF)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na preparação e alinhamento de dados (25%)",
                                "Adequação do tipo de gráfico escolhido (20%)",
                                "Qualidade visual e legibilidade dos plots (20%)",
                                "Profundidade da análise de padrões/desvios (20%)",
                                "Documentação clara e insights acionáveis (15%)"
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Análise de resíduos e testes de estacionariedade",
                                "Programação: Manipulação de dados com Pandas e visualização",
                                "Ciência de Dados: Validação cruzada de modelos preditivos",
                                "Física/Mecânica: Simulação de sistemas dinâmicos"
                              ],
                              "realWorldApplication": "Validar modelos de previsão de demanda em e-commerce (comparar vendas reais vs previstas para ajustar sazonalidades); monitorar sensores IoT em indústrias para detectar falhas em simulações de manutenção preditiva."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.2.4",
                            "name": "Interpretar discrepâncias gráficas",
                            "description": "Analisar visualmente gráficos gerados para quantificar e qualificar diferenças, propondo ajustes no modelo de simulação baseado em evidências gráficas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Examinar gráficos de referência e simulados",
                                  "subSteps": [
                                    "Carregue os gráficos de dados reais (referência) e os gerados pelo modelo de simulação.",
                                    "Identifique eixos (X, Y), escalas, legendas e unidades de medida em ambos os gráficos.",
                                    "Observe tendências gerais, como inclinações, picos, vales e platôs.",
                                    "Anotar observações iniciais sobre similaridades visuais em um documento ou ferramenta de notas.",
                                    "Ajuste visualizações (zoom, rotação) para alinhamento ótimo."
                                  ],
                                  "verification": "Liste pelo menos 3 características principais de cada gráfico e confirme alinhamento visual inicial.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Gráficos de referência e simulados (PNG/PDF ou software como Matplotlib/Excel)",
                                    "Ferramenta de visualização (Python Jupyter, Tableau)"
                                  ],
                                  "tips": "Sempre verifique se as escalas dos eixos são idênticas para evitar ilusões ópticas.",
                                  "learningObjective": "Compreender a estrutura e o conteúdo dos gráficos para estabelecer uma base de comparação.",
                                  "commonMistakes": [
                                    "Ignorar diferenças de escala nos eixos",
                                    "Não anotar observações iniciais",
                                    "Comparar sem alinhar os gráficos lado a lado"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Detectar discrepâncias visuais qualitativas",
                                  "subSteps": [
                                    "Compare formas gerais das curvas ou barras entre referência e simulação.",
                                    "Identifique regiões de sobreposição perfeita, superestimação ou subestimação.",
                                    "Marque visualmente diferenças em picos, cruzamentos de eixos ou dispersões.",
                                    "Classifique discrepâncias como locais (em pontos específicos) ou globais (em toda a extensão).",
                                    "Descreva qualitativamente o impacto (ex.: 'pico antecipado na simulação')."
                                  ],
                                  "verification": "Crie uma lista anotada com pelo menos 4 discrepâncias qualitativas identificadas.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Gráficos superimpostos",
                                    "Ferramenta de anotação (como Draw.io ou papel e caneta)",
                                    "Lupa digital para zoom"
                                  ],
                                  "tips": "Use cores diferentes para destacar discrepâncias e superimpor curvas transparentes.",
                                  "learningObjective": "Desenvolver habilidade em percepção visual para qualificar diferenças sem métricas numéricas.",
                                  "commonMistakes": [
                                    "Focar apenas em discrepâncias óbvias, ignorando sutis",
                                    "Confundir ruído aleatório com discrepância sistemática",
                                    "Não classificar o tipo de discrepância"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Quantificar as discrepâncias",
                                  "subSteps": [
                                    "Meça distâncias verticais entre curvas em pontos chave (ex.: 5-10 pontos representativos).",
                                    "Calcule métricas visuais simples como área entre curvas ou desvio máximo.",
                                    "Use réguas digitais ou ferramentas para extrair valores numéricos dos gráficos.",
                                    "Crie um gráfico de resíduos (diferenças) para visualização adicional.",
                                    "Registre quantificações em tabela (ponto, diferença absoluta, % de erro)."
                                  ],
                                  "verification": "Apresente uma tabela com quantificações numéricas de pelo menos 5 discrepâncias.",
                                  "estimatedTime": "30-40 minutos",
                                  "materials": [
                                    "Software de análise gráfica (Matplotlib, Origin, Excel)",
                                    "Calculadora ou script Python simples para métricas"
                                  ],
                                  "tips": "Escolha pontos equidistantes para uma quantificação representativa e evite amostragem enviesada.",
                                  "learningObjective": "Aprender a transformar observações visuais em dados numéricos mensuráveis.",
                                  "commonMistakes": [
                                    "Medir em escalas erradas",
                                    "Ignorar unidades nos cálculos",
                                    "Selecionar poucos pontos, perdendo representatividade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Qualificar discrepâncias e propor ajustes",
                                  "subSteps": [
                                    "Interprete o significado das discrepâncias (ex.: 'subestimação indica taxa baixa no modelo').",
                                    "Relacione com parâmetros do modelo (ex.: 'aumentar taxa de chegada reduz pico antecipado').",
                                    "Proponha 2-3 ajustes específicos e hipotéticos no modelo.",
                                    "Preveja o impacto gráfico dos ajustes propostos.",
                                    "Documente raciocínio em relatório com evidências gráficas."
                                  ],
                                  "verification": "Elabore um relatório curto com qualificações, propostas e justificativas baseadas em evidências.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Documentação do modelo de simulação",
                                    "Editor de texto ou Jupyter Notebook para relatório"
                                  ],
                                  "tips": "Baseie propostas em causalidade lógica, não em adivinhação; teste mentalmente o ajuste.",
                                  "learningObjective": "Conectar análise gráfica a decisões de modelagem iterativa.",
                                  "commonMistakes": [
                                    "Propor ajustes genéricos sem ligação à discrepância",
                                    "Ignorar trade-offs entre ajustes",
                                    "Não justificar com evidências visuais"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado (sistema discreto), compare o gráfico de tempo médio de espera real (dados empíricos) vs. simulado. Identifique discrepância: simulação mostra picos 20% mais altos às 18h. Quantifique: desvio máximo de 5 minutos. Qualifique: taxa de chegada subestimada. Proponha: aumentar parâmetro lambda em 15% no modelo Poisson.",
                              "finalVerifications": [
                                "Identifica corretamente 4+ discrepâncias qualitativas e quantitativas em um gráfico novo.",
                                "Propõe ajustes específicos e plausíveis com justificativa gráfica.",
                                "Cria tabela de quantificações precisas e relatório interpretativo.",
                                "Distingue discrepâncias sistemáticas de ruído visual.",
                                "Prevé impactos de ajustes em gráficos hipotéticos.",
                                "Aplica o processo em menos de 2 horas para um caso real."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção e quantificação de discrepâncias (erro <10%).",
                                "Profundidade qualitativa na interpretação (causalidade clara).",
                                "Relevância e especificidade das propostas de ajuste.",
                                "Organização visual e documentação do processo.",
                                "Eficiência temporal e uso adequado de ferramentas.",
                                "Criatividade em conexões com parâmetros do modelo."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Cálculo de resíduos e métricas como RMSE.",
                                "Programação: Geração e manipulação de gráficos em Python/R.",
                                "Física/Engenharia: Validação de modelos dinâmicos discretos.",
                                "Ciência de Dados: Análise exploratória visual (EDA).",
                                "Gestão de Projetos: Iteração e refinamento baseado em evidências."
                              ],
                              "realWorldApplication": "Na validação de modelos epidemiológicos (ex.: previsão de surtos), engenharia de tráfego (otimização de semáforos) ou finanças (simulações Monte Carlo para riscos), onde discrepâncias gráficas guiam calibrações para previsões precisas e decisões informadas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.4",
                    "name": "Testes de Hipóteses para Validação",
                    "description": "Aplicação de testes estatísticos, como qui-quadrado ou Kolmogorov-Smirnov, para verificar se distribuições de modelo e sistema são equivalentes.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.4.1",
                        "name": "Fundamentos de Testes de Hipóteses para Validação de Modelos",
                        "description": "Compreensão dos princípios básicos dos testes de hipóteses aplicados à validação de modelos de simulação, incluindo formulação de hipóteses nula e alternativa para comparar distribuições empíricas do sistema real e do modelo simulado.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.1.1",
                            "name": "Formular Hipóteses Nula e Alternativa",
                            "description": "Definir a hipótese nula (H0: as distribuições do modelo e do sistema real são estatisticamente equivalentes) e a alternativa (H1: as distribuições diferem), considerando o contexto de validação em simulações de sistemas discretos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar o Contexto da Validação do Modelo",
                                  "subSteps": [
                                    "Identificar o sistema real e o modelo simulado em sistemas discretos.",
                                    "Descrever as distribuições relevantes (ex.: tempo de espera, número de eventos).",
                                    "Definir métricas de comparação (média, variância, forma da distribuição).",
                                    "Estabelecer o nível de equivalência estatística desejado.",
                                    "Documentar o problema de validação em termos claros."
                                  ],
                                  "verification": "Verificar se o contexto está documentado com descrições das distribuições e métricas escolhidas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Descrição do sistema real",
                                    "Saídas de simulações do modelo",
                                    "Papel ou editor de texto"
                                  ],
                                  "tips": [
                                    "Comece pelo sistema real para ancorar a análise.",
                                    "Use histogramas iniciais para visualizar distribuições."
                                  ],
                                  "learningObjective": "Compreender as distribuições envolvidas no contexto de validação de simulações discretas.",
                                  "commonMistakes": [
                                    "Ignorar diferenças sutis nas distribuições.",
                                    "Confundir sistema real com modelo simulado."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a Hipótese Nula (H0)",
                                  "subSteps": [
                                    "Estabelecer H0 como 'as distribuições do modelo e do sistema real são estatisticamente equivalentes'.",
                                    "Especificar o teste de equivalência (ex.: teste de Kolmogorov-Smirnov).",
                                    "Incluir parâmetros como p-valor ou intervalo de confiança.",
                                    "Garantir que H0 reflita ausência de diferença significativa.",
                                    "Escrever em notação matemática: H0: D(modelo, real) = 0."
                                  ],
                                  "verification": "Conferir se H0 afirma equivalência estatística sem ambiguidades.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Notas do Step 1",
                                    "Referências de testes estatísticos"
                                  ],
                                  "tips": [
                                    "H0 sempre presume 'sem diferença' ou equivalência no contexto de validação."
                                  ],
                                  "learningObjective": "Formular corretamente a hipótese nula para validação de modelos.",
                                  "commonMistakes": [
                                    "Invertir H0 com H1.",
                                    "Definir H0 como igualdade exata em vez de estatística."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir a Hipótese Alternativa (H1)",
                                  "subSteps": [
                                    "Estabelecer H1 como 'as distribuições do modelo e do sistema real diferem'.",
                                    "Especificar o tipo de diferença (unilateral ou bilateral, se aplicável).",
                                    "Garantir que H1 seja o complemento lógico de H0.",
                                    "Incluir exemplos de diferenças detectáveis (ex.: desvios na cauda).",
                                    "Escrever em notação: H1: D(modelo, real) ≠ 0."
                                  ],
                                  "verification": "Verificar se H1 é mutuamente exclusiva e exaustiva com H0.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Notas dos Steps 1 e 2"
                                  ],
                                  "tips": [
                                    "H1 deve capturar as falhas potenciais do modelo na simulação discreta."
                                  ],
                                  "learningObjective": "Formular a hipótese alternativa alinhada ao contexto de validação.",
                                  "commonMistakes": [
                                    "Tornar H1 muito vaga.",
                                    "Confundir com hipótese direcional sem justificativa."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Formalizar as Hipóteses",
                                  "subSteps": [
                                    "Conferir se H0 e H1 são testáveis com dados simulados.",
                                    "Avaliar consistência com o contexto de sistemas discretos.",
                                    "Testar logicamente: rejeitar H0 implica aceitar H1.",
                                    "Documentar suposições (ex.: independência das amostras).",
                                    "Revisar notação e clareza para comunicação."
                                  ],
                                  "verification": "Simular um teste simples para ver se as hipóteses fazem sentido.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "R ou Python para teste rápido",
                                    "Documentação das hipóteses"
                                  ],
                                  "tips": [
                                    "Use um exemplo pequeno para validar a formulação."
                                  ],
                                  "learningObjective": "Garantir que as hipóteses sejam rigorosas e aplicáveis.",
                                  "commonMistakes": [
                                    "Esquecer suposições estatísticas.",
                                    "Não testar a complementaridade."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar e Preparar para Teste",
                                  "subSteps": [
                                    "Escrever as hipóteses finais em formato LaTeX ou texto formatado.",
                                    "Incluir justificativa contextual para cada uma.",
                                    "Planejar o teste subsequente (ex.: tamanho amostral).",
                                    "Compartilhar para feedback inicial.",
                                    "Arquivar para uso no processo de validação completo."
                                  ],
                                  "verification": "Obter aprovação ou feedback de pares sobre a formulação.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Editor de texto ou Jupyter Notebook"
                                  ],
                                  "tips": [
                                    "Mantenha linguagem precisa e matemática."
                                  ],
                                  "learningObjective": "Finalizar hipóteses prontas para testes empíricos.",
                                  "commonMistakes": [
                                    "Notação inconsistente.",
                                    "Omitir contexto na documentação."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila M/M/1 para um call center real: H0: A distribuição de tempos de atendimento do modelo é estatisticamente equivalente à do sistema real (teste KS, α=0.05); H1: As distribuições diferem significativamente, indicando necessidade de ajuste no modelo.",
                              "finalVerifications": [
                                "H0 afirma explicitamente equivalência estatística das distribuições.",
                                "H1 declara diferença estatística de forma complementar.",
                                "Notação matemática correta (H0 e H1).",
                                "Contexto de simulações discretas está integrado.",
                                "Hipóteses são testáveis com dados disponíveis.",
                                "Suposições implícitas estão listadas."
                              ],
                              "assessmentCriteria": [
                                "Clareza e precisão na definição de H0 e H1 (30%).",
                                "Adequação ao contexto de validação de modelos discretos (25%).",
                                "Consistência lógica entre H0 e H1 (20%).",
                                "Formalização matemática e documentação (15%).",
                                "Identificação de suposições e limitações (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística Inferencial: Testes de hipóteses não paramétricos.",
                                "Programação Computacional: Geração de simulações em Python/R.",
                                "Modelagem Matemática: Teoria de filas e processos estocásticos.",
                                "Análise de Dados: Visualização e testes de distribuições.",
                                "Engenharia de Software: Validação de modelos simulados."
                              ],
                              "realWorldApplication": "Na indústria aeroespacial, formular H0/H1 para validar simulações de tráfego aéreo discreto contra dados reais, garantindo segurança em sistemas de controle de voo; ou em logística, validando modelos de supply chain para otimizar estoques."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.1.2",
                            "name": "Interpretar o Valor-p e Nível de Significância",
                            "description": "Calcular e interpretar o valor-p de um teste de hipóteses, decidindo se rejeita H0 com base em um nível de significância α (ex.: 0,05), aplicando ao contexto de validação de distribuições simuladas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Valor-p e Nível de Significância",
                                  "subSteps": [
                                    "Defina H0 (hipótese nula: a simulação segue a distribuição esperada) e H1 (alternativa).",
                                    "Explique o nível de significância α como o limiar de probabilidade para rejeitar H0 (ex.: α = 0.05 significa 5% de risco de erro Tipo I).",
                                    "Descreva o valor-p como a probabilidade de observar dados tão extremos quanto os obtidos, assumindo H0 verdadeira.",
                                    "Diferencie valor-p de α: valor-p é calculado dos dados; α é escolhido previamente.",
                                    "Relacione ao contexto: em validação de simulações, H0 é 'simulação matches distribuição real'."
                                  ],
                                  "verification": "Escreva definições curtas e um diagrama comparando valor-p e α; autoavalie se cobre todos os substeps.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel ou editor de texto",
                                    "Gráfico de testes de hipóteses (impresso ou online)"
                                  ],
                                  "tips": [
                                    "Use analogia: α é o 'juiz' pré-definido; valor-p é a 'evidência do réu'.",
                                    "Memorize: p < α → rejeitar H0."
                                  ],
                                  "learningObjective": "Dominar definições e relação entre valor-p, α, H0 e contexto de simulações.",
                                  "commonMistakes": [
                                    "Confundir valor-p com probabilidade de H0 ser verdadeira.",
                                    "Pensar que α é calculado dos dados."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Obter ou Calcular o Valor-p a Partir de Dados Simulados",
                                  "subSteps": [
                                    "Colete dados simulados (ex.: frequências de uma simulação de Poisson vs. esperadas).",
                                    "Escolha teste apropriado (ex.: Qui-quadrado de aderência para distribuições discretas).",
                                    "Calcule estatística de teste (ex.: χ² = Σ (O_i - E_i)² / E_i).",
                                    "Determine graus de liberdade (k-1 para k categorias).",
                                    "Use tabela Qui-quadrado ou software (Python/R) para encontrar valor-p."
                                  ],
                                  "verification": "Execute cálculo em dados de exemplo e confira valor-p com calculadora online; deve coincidir em 95%.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software: Python (scipy.stats.chisquare) ou Excel",
                                    "Dados simulados de exemplo (100 amostras)"
                                  ],
                                  "tips": [
                                    "Comece com software para validar manual; foque em entrada correta de observados/esperados.",
                                    "Salve código para reutilização."
                                  ],
                                  "learningObjective": "Calcular valor-p corretamente para validação de distribuições simuladas.",
                                  "commonMistakes": [
                                    "Esquecer graus de liberdade.",
                                    "Inverter observados e esperados no teste."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Valor-p com α e Decidir sobre H0",
                                  "subSteps": [
                                    "Estabeleça α (ex.: 0.05 para rigor moderado em simulações).",
                                    "Compare: se valor-p ≤ α, rejeite H0 (evidência contra simulação válida).",
                                    "Se valor-p > α, falhe em rejeitar H0 (simulação plausível).",
                                    "Registre decisão com justificativa numérica (ex.: p=0.03 < 0.05 → rejeitar).",
                                    "Considere poder do teste (tamanho amostra afeta confiabilidade)."
                                  ],
                                  "verification": "Aplique a 3 cenários hipotéticos (p=0.01, 0.10, 0.04 com α=0.05) e liste decisões corretas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela de decisões (p vs α)",
                                    "Calculadora"
                                  ],
                                  "tips": [
                                    "Regra simples: 'p menor que α? Rejeita!'",
                                    "Anote sempre o valor exato de p e α usados."
                                  ],
                                  "learningObjective": "Tomar decisões precisas baseadas em comparação valor-p e α.",
                                  "commonMistakes": [
                                    "Usar > em vez de ≤ para rejeição.",
                                    "Ignorar contexto de α escolhido."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Resultados no Contexto de Validação de Modelos Simulados",
                                  "subSteps": [
                                    "Explique implicações: rejeição significa modelo/simulação precisa ajustes.",
                                    "Discuta não-rejeição: não prova H0, só falta evidência contra.",
                                    "Avalie limitações (ex.: amostra pequena → p alto falso).",
                                    "Sugira próximos passos (aumentar simulações, mudar parâmetros).",
                                    "Documente relatório: 'Com p=0.02 < α=0.05, modelo inválido para esta distribuição.'"
                                  ],
                                  "verification": "Escreva parágrafo de interpretação para um caso simulado; peer-review ou auto-check contra rubrica.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Template de relatório de validação",
                                    "Exemplo de simulação inválida"
                                  ],
                                  "tips": [
                                    "Sempre contextualize: 'Isso invalida o modelo para X cenários.'",
                                    "Evite absolutos como 'prova'."
                                  ],
                                  "learningObjective": "Interpretar decisões de forma contextual e acionável para validação.",
                                  "commonMistakes": [
                                    "Interpretar não-rejeição como 'modelo perfeito'.",
                                    "Omitir limitações do teste."
                                  ]
                                }
                              ],
                              "practicalExample": "Simule 1000 lançamentos de um dado (distribuição uniforme esperada: 1/6 cada face). Conte frequências observadas: [150, 170, 165, 160, 180, 175]. Calcule χ² ≈ 5.2 (gl=5), p=0.39 > 0.05 → não rejeitar H0, simulação válida. Se observadas [300,50,50,50,50,500], p<0.001 → rejeitar, dado 'viciado'.",
                              "finalVerifications": [
                                "Calcule p corretamente para dados fornecidos e compare com α=0.05.",
                                "Explique verbalmente por que p=0.03 leva a rejeição de H0.",
                                "Identifique erro em interpretação: 'p alto prova modelo certo' (incorreto).",
                                "Aplique a um novo dataset simulado sem erros.",
                                "Escreva relatório de 100 palavras com decisão e implicações.",
                                "Diferencie risco Tipo I de valor-p em discussão."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de valor-p (erro <5%).",
                                "Decisão correta baseada em p vs α (100% acerto).",
                                "Interpretação contextualizada ao simulação (clareza e relevância).",
                                "Identificação de pelo menos 2 limitações do teste.",
                                "Uso correto de terminologia (H0, p-valor, α).",
                                "Relatório estruturado e acionável."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Integra com inferência em Ciência de Dados.",
                                "Programação: Uso de bibliotecas como scipy.stats em Python/R.",
                                "Física: Validação de simulações Monte Carlo em mecânica quântica.",
                                "Economia: Testes em modelos de simulação financeira (ex.: risco de mercado)."
                              ],
                              "realWorldApplication": "Em controle de qualidade industrial, validar se máquina de envasamento segue distribuição Poisson de defeitos (p<0.05 → recalibrar); em pesquisa farmacêutica, testar se simulação de trials clínicos matches dados reais para aprovar fármacos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.1.3",
                            "name": "Coletar e Preparar Dados para Testes",
                            "description": "Preparar histogramas ou funções de distribuição cumulativa (CDF) a partir de dados reais e simulados, garantindo amostras independentes e tamanho adequado para aplicação de testes estatísticos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Coletar Dados Reais e Simulados",
                                  "subSteps": [
                                    "Identifique a fonte de dados reais relevantes ao modelo (ex.: medições experimentais de um sistema de filas).",
                                    "Gere dados simulados usando o modelo discreto proposto (ex.: simule 1000 chegadas em uma fila M/M/1 com Python ou R).",
                                    "Registre metadados: origem, método de geração e parâmetros usados.",
                                    "Armazene em formato tabular (CSV ou DataFrame) com colunas claras para variável de interesse.",
                                    "Documente qualquer pré-processamento inicial, como remoção de outliers evidentes."
                                  ],
                                  "verification": "Verifique se há pelo menos 500 observações reais e simuladas em arquivos separados, com metadados documentados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software de simulação (Python com NumPy/SciPy ou R)",
                                    "Dados reais de fontes públicas (ex.: Kaggle datasets de filas)",
                                    "Editor de texto ou Jupyter Notebook"
                                  ],
                                  "tips": "Use seeds fixas para reproducibilidade em simulações (ex.: np.random.seed(42)).",
                                  "learningObjective": "Compreender fontes de dados e gerar amostras simuladas alinhadas ao modelo.",
                                  "commonMistakes": [
                                    "Misturar dados reais e simulados sem rotulação.",
                                    "Usar parâmetros incorretos na simulação, levando a distribuições desalinhadas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar Independência das Amostras",
                                  "subSteps": [
                                    "Calcule a autocorrelação (ACF) para séries temporais nos dados reais e simulados.",
                                    "Aplique teste de independência como Ljung-Box ou Durbin-Watson.",
                                    "Separe amostras em subconjuntos aleatórios e compare estatísticas descritivas.",
                                    "Se dependência detectada, subamostre ou transforme (ex.: diferenças sucessivas).",
                                    "Confirme visualmente com scatterplots de pares consecutivos."
                                  ],
                                  "verification": "ACF cai dentro de bandas de confiança para lags >1 e p-value >0.05 em testes de independência.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Bibliotecas statsmodels (Python) ou forecast (R)",
                                    "Gráficos ACF via matplotlib ou ggplot2"
                                  ],
                                  "tips": "Para sistemas discretos, amostre em intervalos maiores se houver dependência temporal.",
                                  "learningObjective": "Aplicar testes para garantir suposição de independência exigida em testes de hipóteses.",
                                  "commonMistakes": [
                                    "Ignorar dependência em dados sequenciais de simulações Markovianas.",
                                    "Não testar tanto reais quanto simulados."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar e Ajustar Tamanho de Amostra Adequado",
                                  "subSteps": [
                                    "Calcule tamanho mínimo via fórmula de poder estatístico (ex.: para teste t, n = (Zα/2 + Zβ)^2 * (σ^2 / δ^2)).",
                                    "Estime variância e efeito mínimo dos dados preliminares.",
                                    "Aumente amostra se n atual < requerido, via re-simulação ou coleta adicional.",
                                    "Balanceie tamanhos entre reais e simulados para comparações pareadas.",
                                    "Valide com simulações de Monte Carlo para poder empírico."
                                  ],
                                  "verification": "Tamanho final ≥ n calculado e poder >80% em simulações de validação.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Funções pwr (R) ou statsmodels.stats.power (Python)",
                                    "Calculadora de poder online como G*Power"
                                  ],
                                  "tips": "Para distribuições não normais, use bootstrap para estimar poder.",
                                  "learningObjective": "Garantir suficiência amostral para detecção confiável de diferenças.",
                                  "commonMistakes": [
                                    "Subestimar variância, levando a amostras subpotentes.",
                                    "Usar regras de polegar sem cálculo específico."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir Histogramas e Funções de Distribuição Cumulativa (CDF)",
                                  "subSteps": [
                                    "Gere histogramas com bins ótimos (ex.: Sturges ou Freedman-Diaconis).",
                                    "Calcule CDF empírica: sort dados e compute proporções cumulativas.",
                                    "Plote histogramas e CDFs lado a lado para reais vs. simulados.",
                                    "Ajuste normalização e labels para clareza.",
                                    "Exporte gráficos e tabelas de CDF para relatório."
                                  ],
                                  "verification": "Histogramas e CDFs plotados corretamente, com sobreposição visual entre reais e simulados.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Seaborn/Matplotlib (Python) ou ggplot2 (R)",
                                    "Função ecdf em R ou stats.ecdf em Python"
                                  ],
                                  "tips": "Use kernel density estimation (KDE) como complemento ao histograma para suavização.",
                                  "learningObjective": "Visualizar e quantificar distribuições para inspeção pré-teste.",
                                  "commonMistakes": [
                                    "Bins inadequados distorcendo forma.",
                                    "Erro na escala cumulativa (deve ir de 0 a 1)."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar Preparação para Testes Estatísticos",
                                  "subSteps": [
                                    "Execute testes de normalidade (Shapiro-Wilk) ou bondade de ajuste (Kolmogorov-Smirnov).",
                                    "Confirme suposições centrais: independência, tamanho e stationarity.",
                                    "Compare estatísticas descritivas (média, variância, skewness).",
                                    "Documente relatório de preparação com gráficos e métricas.",
                                    "Prepare datasets finais para testes de hipóteses subsequentes."
                                  ],
                                  "verification": "Todas suposições atendidas (p-values >0.05 onde aplicável) e relatório completo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "SciPy.stats ou nortest (R)",
                                    "Template de relatório em Markdown"
                                  ],
                                  "tips": "Se normalidade falhar, planeje testes não-paramétricos adiante.",
                                  "learningObjective": "Assegurar dados prontos para aplicação robusta de testes de hipóteses.",
                                  "commonMistakes": [
                                    "Prosseguir sem validar suposições, invalidando resultados futuros.",
                                    "Esquecer documentação."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila M/M/1, colete tempos de espera reais de um call center (1000 observações) e simule 2000 com λ=2, μ=3. Verifique independência via ACF, ajuste n=1500 por poder para δ=0.5, construa histogramas/CDFs exponenciais e valide para teste KS de igualdade de distribuições.",
                              "finalVerifications": [
                                "Dados coletados com ≥1000 observações independentes por tipo.",
                                "Tamanho de amostra calculado e atendido com poder ≥80%.",
                                "Histogramas e CDFs gerados e comparados visualmente.",
                                "Suposições de independência e adequação confirmadas por testes.",
                                "Relatório com gráficos e métricas pronto para testes de hipóteses.",
                                "Datasets finais exportados em formato limpo (CSV/DataFrame)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na verificação de independência (ACF e testes corretos).",
                                "Cálculo rigoroso de tamanho de amostra com justificativa.",
                                "Qualidade visual e técnica dos histogramas/CDFs (bins, escalas).",
                                "Cobertura completa de suposições para testes estatísticos.",
                                "Documentação clara e reprodutível do processo.",
                                "Eficiência temporal dentro das estimativas."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Uso de Python/R para simulação e visualização (Ciência da Computação).",
                                "Probabilidade: Compreensão de distribuições e CDFs (Estatística Básica).",
                                "Análise de Dados: Pré-processamento e validação (Data Science).",
                                "Modelagem: Aplicação em simulações discretas (Engenharia de Sistemas)."
                              ],
                              "realWorldApplication": "Na validação de modelos de simulação para sistemas de filas em logística (ex.: Amazon warehouses), preparar dados garante testes precisos de hipóteses, evitando erros caros em otimização de recursos e previsão de gargalos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.4.2",
                        "name": "Teste Qui-Quadrado (χ²) para Validação",
                        "description": "Aplicação do teste de qui-quadrado de adequação ao ajuste para verificar se a distribuição de frequências observada no sistema real corresponde à esperada pelo modelo de simulação discreta.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.2.1",
                            "name": "Calcular a Estatística Qui-Quadrado",
                            "description": "Computar a estatística χ² = Σ (O_i - E_i)² / E_i, onde O_i são frequências observadas e E_i esperadas, usando dados categorizados de simulações e sistema real.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Coletar e organizar dados observados (O_i) e esperados (E_i)",
                                  "subSteps": [
                                    "Identifique as categorias relevantes nos dados categorizados da simulação e do sistema real.",
                                    "Conte as frequências observadas (O_i) para cada categoria a partir dos dados reais.",
                                    "Calcule as frequências esperadas (E_i) usando o modelo de simulação: E_i = n * p_i, onde n é o total de observações e p_i a probabilidade esperada.",
                                    "Monte uma tabela com colunas para categoria, O_i e E_i, verificando que soma(O_i) = soma(E_i) = n total.",
                                    "Registre o número de categorias (k) para uso posterior."
                                  ],
                                  "verification": "Tabela completa com O_i e E_i para todas categorias, somas iguais e E_i > 0 para todas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Dados brutos da simulação e sistema real",
                                    "Planilha Excel, Google Sheets ou papel e calculadora"
                                  ],
                                  "tips": "Use probabilidades do modelo de simulação para E_i; arredonde E_i se necessário, mas mantenha consistência.",
                                  "learningObjective": "Preparar dados categorizados de forma precisa para análise qui-quadrado.",
                                  "commonMistakes": [
                                    "Esquecer uma categoria",
                                    "Calcular E_i sem normalizar probabilidades para somar 1",
                                    "Usar totais incorretos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar premissas do teste qui-quadrado",
                                  "subSteps": [
                                    "Confira se todas E_i ≥ 5 (ou pelo menos 80% das E_i ≥ 5 e nenhuma <1).",
                                    "Verifique independência das observações (amostra aleatória).",
                                    "Confirme que os dados são categóricos e não há categorias vazias.",
                                    "Calcule graus de liberdade preliminar: df = k - 1 - parâmetros estimados.",
                                    "Se premissas violadas, anote ajustes necessários como combinar categorias."
                                  ],
                                  "verification": "Lista de premissas confirmadas ou ajustes propostos documentados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela de dados do Step 1",
                                    "Tabela de referência de premissas qui-quadrado"
                                  ],
                                  "tips": "Combine categorias raras para atender E_i ≥ 5 sem distorcer o modelo.",
                                  "learningObjective": "Garantir validade estatística antes do cálculo da estatística.",
                                  "commonMistakes": [
                                    "Ignorar E_i <5 levando a resultados inválidos",
                                    "Confundir df com número de categorias"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular as contribuições individuais (O_i - E_i)² / E_i",
                                  "subSteps": [
                                    "Para cada categoria i, compute a diferença d_i = O_i - E_i.",
                                    "Eleve ao quadrado: d_i² = (O_i - E_i)².",
                                    "Divida pela esperada: contrib_i = d_i² / E_i.",
                                    "Registre contrib_i para cada i em uma nova coluna da tabela.",
                                    "Use fórmula precisa, evitando arredondamentos prematuros."
                                  ],
                                  "verification": "Coluna de contrib_i completa na tabela, com valores positivos e realistas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela atualizada",
                                    "Calculadora científica ou software como Excel (fórmula = (O-E)^2/E)"
                                  ],
                                  "tips": "Em Excel, arraste a fórmula para todas linhas; verifique divisão por zero.",
                                  "learningObjective": "Executar os componentes matemáticos do qui-quadrado com precisão.",
                                  "commonMistakes": [
                                    "Erro de sinal na diferença (quadrados eliminam, mas confira)",
                                    "Dividir por O_i em vez de E_i",
                                    "Arredondar cedo causando perda de precisão"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Somar as contribuições para obter a estatística χ²",
                                  "subSteps": [
                                    "Some todas as contrib_i: χ² = Σ contrib_i de i=1 a k.",
                                    "Arredonde χ² para 2-3 casas decimais.",
                                    "Compare com valor crítico ou compute p-value (opcional para validação).",
                                    "Documente o resultado final com a tabela completa.",
                                    "Interprete brevemente: maior χ² indica maior discrepância."
                                  ],
                                  "verification": "Valor final de χ² calculado e tabela integral salva.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Tabela com contrib_i",
                                    "Função SOMAR no Excel ou Python (sum(contribs))"
                                  ],
                                  "tips": "Automatize soma para evitar erros manuais; use código Python para reprodutibilidade.",
                                  "learningObjective": "Finalizar o cálculo da estatística qui-quadrado de forma consolidada.",
                                  "commonMistakes": [
                                    "Soma errada de contribuições",
                                    "Confundir χ² com df",
                                    "Esquecer de somar todas as linhas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de sistema de filas discretas (fila M/M/1), dados reais de 120 clientes: O = [35 (<5min), 55 (5-15min), 30 (>15min)]; E do modelo = [48, 48, 24]. Contribuições: (35-48)^2/48 ≈ 3.75, (55-48)^2/48 ≈ 0.52, (30-24)^2/24 ≈ 1.50. χ² = 3.75 + 0.52 + 1.50 = 5.77.",
                              "finalVerifications": [
                                "Soma de O_i e E_i iguais ao total n.",
                                "Todas contrib_i positivas e E_i ≥ 5.",
                                "χ² somado corretamente de todas contrib_i.",
                                "Premissas do teste confirmadas.",
                                "Tabela completa reproduzível.",
                                "χ² consistente com discrepância observada."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica em todas diferenças e divisões (erro <0.01).",
                                "Tabela organizada e completa com todos campos.",
                                "Verificação correta de premissas.",
                                "Uso eficiente de ferramentas computacionais.",
                                "Interpretação básica do resultado.",
                                "Documentação clara dos passos."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade: Cálculo de E_i via distribuições.",
                                "Programação: Implementação em Python/R com pandas e scipy.stats.",
                                "Ciência de Dados: Validação de modelos preditivos.",
                                "Estatística Inferencial: Hipóteses nulas/alternativas."
                              ],
                              "realWorldApplication": "Validar se uma simulação de tráfego urbano (eventos discretos) reproduz padrões reais de congestionamento, permitindo ajustes no modelo para otimizar semáforos em cidades reais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.4.2.2",
                            "name": "Determinar Graus de Liberdade e Valor Crítico",
                            "description": "Calcular graus de liberdade (k-1-m, onde k classes, m parâmetros estimados) e consultar tabelas ou software para obter valores críticos ou p-value no teste qui-quadrado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar Parâmetros para Cálculo de Graus de Liberdade",
                                  "subSteps": [
                                    "Examine os dados observados e determine o número de classes ou categorias (k) na tabela de contingência ou distribuição.",
                                    "Identifique o número de parâmetros estimados do modelo (m), como probabilidades ajustadas ou médias.",
                                    "Confirme se há restrições adicionais, como somas que devem ser 1 para probabilidades.",
                                    "Registre k e m em um papel ou software para verificação.",
                                    "Valide com o contexto do teste qui-quadrado: k deve corresponder a bins ou células independentes."
                                  ],
                                  "verification": "Verifique se k e m foram corretamente contados comparando com a tabela de dados original; df preliminar deve fazer sentido (positivo e inteiro).",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Tabela de contingência ou dados observados/esperados",
                                    "Papel e caneta ou planilha (Excel/Google Sheets)",
                                    "Documentação do modelo simulado"
                                  ],
                                  "tips": "Sempre subtraia 1 para a restrição de soma total em distribuições de probabilidade.",
                                  "learningObjective": "Compreender os componentes k e m para aplicação precisa na fórmula de graus de liberdade.",
                                  "commonMistakes": [
                                    "Confundir k com o número total de observações",
                                    "Esquecer de subtrair m para parâmetros estimados",
                                    "Não considerar independência das células"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Graus de Liberdade (df)",
                                  "subSteps": [
                                    "Aplique a fórmula df = k - 1 - m.",
                                    "Substitua os valores identificados: exemplo, k=5 classes, m=2 parâmetros → df=5-1-2=2.",
                                    "Realize o cálculo manualmente e confirme com calculadora ou software.",
                                    "Anote o df final e verifique se é um inteiro não-negativo.",
                                    "Compare com exemplos padrão de testes qui-quadrado para validação cruzada."
                                  ],
                                  "verification": "O df calculado deve coincidir com o esperado para o tipo de tabela (ex: 2x2 → df=1); teste com fórmula em Excel =k-1-m.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Calculadora ou planilha eletrônica",
                                    "Tabela qui-quadrado de referência rápida"
                                  ],
                                  "tips": "Use parênteses na fórmula para evitar erros de precedência: (k - 1) - m.",
                                  "learningObjective": "Executar o cálculo preciso de df para testes qui-quadrado em validação de modelos.",
                                  "commonMistakes": [
                                    "Erro aritmético simples como 5-1-2=3 em vez de 2",
                                    "Não subtrair o 1 para a restrição de soma",
                                    "Confundir m com número de variáveis independentes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar Nível de Significância e Obter Valor Crítico da Tabela",
                                  "subSteps": [
                                    "Selecione alpha (ex: 0.05 ou 0.01) baseado no contexto de validação do modelo.",
                                    "Localize df na linha da tabela qui-quadrado e alpha na coluna para ler o valor crítico (χ²_crítico).",
                                    "Interpolo se necessário para valores não exatos.",
                                    "Registre o valor crítico e a probabilidade associada.",
                                    "Compare o estatístico qui-quadrado calculado previamente com χ²_crítico."
                                  ],
                                  "verification": "Valor crítico deve bater com tabela padrão (ex: df=1, alpha=0.05 → 3.841); confira em múltiplas fontes.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Tabela de distribuição qui-quadrado impressa ou online",
                                    "Livro de estatística ou PDF de referência"
                                  ],
                                  "tips": "Use tabelas one-tailed para qui-quadrado, sempre à direita da distribuição.",
                                  "learningObjective": "Selecionar e interpretar valores críticos manualmente para decisões de hipótese.",
                                  "commonMistakes": [
                                    "Ler a coluna errada (alpha vs 1-alpha)",
                                    "Confundir df com alpha",
                                    "Usar tabela t-Student em vez de qui-quadrado"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Usar Software para Valor Crítico e p-value",
                                  "subSteps": [
                                    "Abra software como R, Python (scipy) ou Excel.",
                                    "Insira comando: R - qchisq(1-0.05, df=2); Python - chi2.ppf(0.95, df=2).",
                                    "Calcule p-value: R - 1-pchisq(statistico, df); compare com alpha.",
                                    "Gere output e salve gráfico da distribuição qui-quadrado com linha crítica.",
                                    "Valide resultado cruzando com tabela manual."
                                  ],
                                  "verification": "p-value e crítico do software coincidem com tabela (±0.001); gráfico mostra rejeição/aceitação correta.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Software: R, Python (com scipy.stats), ou Excel",
                                    "Script de exemplo pronto"
                                  ],
                                  "tips": "Sempre defina seed para reprodutibilidade em simulações.",
                                  "learningObjective": "Aplicar ferramentas computacionais para eficiência em cálculos qui-quadrado.",
                                  "commonMistakes": [
                                    "Erro de sintaxe no comando (ex: pchisq vs qchisq)",
                                    "Usar df errado no software",
                                    "Interpretar p-value como valor crítico"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de sistema discreto com 4 bins de chegada de clientes (k=4), estimando 1 parâmetro de taxa (m=1), df=4-1-1=2. Para alpha=0.05, tabela dá χ²_crítico=5.991. Com estatístico=6.5 (de dados observados vs esperados), rejeite H0. Em R: qchisq(0.95,2) confirma 5.991; p-value=1-pchisq(6.5,2)=0.039 <0.05.",
                              "finalVerifications": [
                                "df calculado corretamente como k-1-m e é inteiro positivo.",
                                "Valor crítico da tabela/software bate com referências padrão.",
                                "p-value computado leva à decisão correta de hipótese (rejeitar/aceitar).",
                                "Gráfico ou output mostra distribuição qui-quadrado com linha crítica.",
                                "Resultados aplicados corretamente à validação do modelo simulado.",
                                "Sem discrepâncias entre método manual e computacional."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de df (100% correto).",
                                "Correta seleção e leitura de valor crítico da tabela (erro <0.01).",
                                "Uso correto de software com output reproduzível.",
                                "Interpretação coerente de p-value vs alpha.",
                                "Integração com contexto de validação de modelo (decisão lógica).",
                                "Documentação clara de passos e resultados."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Fundamentos de testes de hipóteses e distribuições assintóticas.",
                                "Programação Computacional: Uso de bibliotecas como scipy.stats ou R stats para automação.",
                                "Ciência de Dados: Validação de modelos em machine learning e simulações Monte Carlo.",
                                "Probabilidade: Compreensão de distribuições qui-quadrado derivadas de normais.",
                                "Engenharia: Controle de qualidade e testes em processos discretos."
                              ],
                              "realWorldApplication": "Em simulações de filas em call centers (sistemas discretos), calcular df e χ²_crítico valida se o modelo simulado reproduz distribuições reais de chegadas, permitindo otimizar alocação de agentes e reduzir custos operacionais em empresas como bancos ou telecom."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.1.2"
                            ]
                          },
                          {
                            "id": "10.1.5.4.2.3",
                            "name": "Aplicar Teste Qui-Quadrado em Software de Simulação",
                            "description": "Implementar o teste qui-quadrado em ferramentas como R, Python (scipy.stats.chisquare) ou linguagens de simulação (ex.: Arena), validando distribuições de tempos de serviço ou chegadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar Dados Observados e Esperados para o Teste",
                                  "subSteps": [
                                    "Colete dados observados da simulação (ex.: frequências de intervalos de tempo de serviço ou chegadas)",
                                    "Defina a hipótese nula (H0: dados seguem distribuição teórica esperada) e alternativa (H1: não seguem)",
                                    "Calcule frequências esperadas baseadas na distribuição teórica assumida (ex.: Poisson para chegadas)",
                                    "Construa tabela de contingência com categorias, observados (Oi) e esperados (Ei)",
                                    "Verifique premissas: Ei >= 5 em pelo menos 80% das células, independência das observações e amostra adequada (n >= 20-30)"
                                  ],
                                  "verification": "Tabela de contingência completa e balanceada, com soma de Oi igual à soma de Ei, salva em formato acessível (CSV ou DataFrame).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Dados de simulação gerados previamente",
                                    "Jupyter Notebook ou RStudio",
                                    "Planilha Excel para cálculos iniciais"
                                  ],
                                  "tips": "Use bins apropriados para dados contínuos para evitar Ei muito baixos; agrupe categorias se necessário.",
                                  "learningObjective": "Preparar dados de forma precisa para aplicação do teste qui-quadrado, garantindo validade estatística.",
                                  "commonMistakes": [
                                    "Ignorar células com Ei < 5, levando a resultados inválidos",
                                    "Confundir Oi com Ei",
                                    "Não definir hipóteses claras"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Ambiente de Software para Implementação",
                                  "subSteps": [
                                    "Instale e importe bibliotecas necessárias (Python: scipy.stats, pandas, numpy; R: chisq.test; Arena: módulos de análise)",
                                    "Carregue os dados preparados em estrutura de dados compatível (array ou DataFrame)",
                                    "Defina parâmetros do teste: graus de liberdade (k-1, onde k é número de categorias)",
                                    "Teste o ambiente com dados sintéticos simples para verificar sintaxe",
                                    "Documente o código com comentários sobre hipóteses e premissas"
                                  ],
                                  "verification": "Ambiente rodando com teste sintético bem-sucedido, exibindo estatística qui-quadrado e p-value corretos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python 3+ com Anaconda",
                                    "R/RStudio",
                                    "Arena Simulation Software (se aplicável)",
                                    "Documentação oficial de scipy.stats.chisquare"
                                  ],
                                  "tips": "Prefira Python para flexibilidade; use %matplotlib inline em Jupyter para visualizações.",
                                  "learningObjective": "Configurar ferramentas de software de simulação de forma eficiente para testes estatísticos.",
                                  "commonMistakes": [
                                    "Importar bibliotecas erradas (ex.: usar ttest_ind em vez de chisquare)",
                                    "Não padronizar dados",
                                    "Esquecer de definir ddof=0 em scipy"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e Executar o Teste Qui-Quadrado",
                                  "subSteps": [
                                    "Escreva o código para calcular estatística qui-quadrado: Σ((Oi - Ei)^2 / Ei)",
                                    "Execute a função built-in: scipy.stats.chisquare(f_obs, f_exp) ou chisq.test em R",
                                    "Capture saídas: estatística χ², graus de liberdade (df), p-value",
                                    "Gere visualizações: gráfico de barras Oi vs Ei e resíduo padronizado",
                                    "Salve resultados em relatório (incluindo código fonte e outputs)"
                                  ],
                                  "verification": "Output completo com χ², df, p-value exibido e salvo; p-value calculado manualmente coincide com função.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código-fonte em Jupyter ou script R",
                                    "Dados da tabela de contingência"
                                  ],
                                  "tips": "Sempre compute χ² manualmente primeiro para validar a função; use seed para reprodutibilidade em simulações.",
                                  "learningObjective": "Executar o teste qui-quadrado programaticamente com precisão em ferramentas de simulação.",
                                  "commonMistakes": [
                                    "Inverter f_obs e f_exp",
                                    "Esquecer df correto (df = len(categorias) - 1 - parâmetros estimados)",
                                    "Interpretar p-value sem contexto"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Resultados e Validar o Modelo de Simulação",
                                  "subSteps": [
                                    "Compare p-value com nível de significância (α=0.05): rejeitar H0 se p < α",
                                    "Analise resíduos: identifique categorias com contribuições altas para χ²",
                                    "Valide o modelo: se aceito, prossiga; se rejeitado, ajuste distribuição ou bins",
                                    "Documente conclusões: adequação da distribuição para tempos de serviço/chegadas",
                                    "Integre ao relatório de validação do modelo de simulação completo"
                                  ],
                                  "verification": "Relatório escrito com interpretação clara, recomendação de aceitação/rejeição e ajustes propostos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Resultados do teste",
                                    "Template de relatório em Markdown ou Word"
                                  ],
                                  "tips": "Use p-value < 0.05 como threshold conservador; considere poder do teste para amostras pequenas.",
                                  "learningObjective": "Interpretar outputs do teste qui-quadrado para validar modelos de simulação de sistemas discretos.",
                                  "commonMistakes": [
                                    "Rejeitar H0 baseado apenas em χ² alto sem p-value",
                                    "Ignorar múltiplos testes (ajuste Bonferroni)",
                                    "Não propor ajustes no modelo"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado usando Arena, colete 1000 tempos de serviço categorizados em bins (0-2min, 2-4min, etc.). Calcule esperados assumindo exponencial (λ=0.5/min). Implemente em Python: import scipy.stats; chisq, p = scipy.stats.chisquare(obs, exp). Se p>0.05, valide a distribuição; caso contrário, ajuste λ.",
                              "finalVerifications": [
                                "Tabela de contingência corretamente preparada com premissas atendidas",
                                "Código executado sem erros, produzindo χ², df e p-value precisos",
                                "Interpretação correta: rejeição/aceitação de H0 com justificativa",
                                "Visualizações de Oi vs Ei e resíduos geradas",
                                "Relatório completo integrando resultados à validação do modelo",
                                "Teste manual de χ² coincide com função built-in (±0.01)"
                              ],
                              "assessmentCriteria": [
                                "Precisão na preparação de dados (100% das premissas verificadas)",
                                "Correção do código e outputs (p-value exato match com manual)",
                                "Profundidade da interpretação (análise de resíduos e implicações)",
                                "Qualidade das visualizações e documentação (claras e profissionais)",
                                "Aplicação contextual à simulação (ligação com tempos de serviço/chegadas)",
                                "Criatividade em ajustes propostos para modelos rejeitados"
                              ],
                              "crossCurricularConnections": [
                                "Estatística Inferencial: Testes de bondade de ajuste",
                                "Programação Computacional: Manipulação de dados em Python/R",
                                "Engenharia Industrial: Validação de simulações de filas e processos",
                                "Ciência de Dados: Análise exploratória e visualização",
                                "Matemática Discreta: Distribuições de probabilidade em sistemas estocásticos"
                              ],
                              "realWorldApplication": "Em fábricas ou hospitais, validar se tempos de chegada de pacientes seguem Poisson via chi-quadrado em Python, otimizando alocação de recursos e reduzindo esperas em 20-30% após ajustes no modelo de simulação."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.4.3",
                        "name": "Teste Kolmogorov-Smirnov (KS) para Validação",
                        "description": "Uso do teste KS para comparar funções de distribuição cumulativa (CDF) empírica do sistema real com a CDF teórica ou simulada do modelo, ideal para distribuições contínuas em simulações.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.3.1",
                            "name": "Calcular a Estatística KS",
                            "description": "Determinar D = sup |F_n(x) - F(x)|, onde F_n é a CDF empírica dos dados reais e F a CDF do modelo, identificando o ponto máximo de discrepância.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e Ordenar a Amostra de Dados",
                                  "subSteps": [
                                    "Colete a amostra de dados reais da simulação (vetor X com n observações).",
                                    "Ordene os dados em ordem crescente: X_{(1)} ≤ X_{(2)} ≤ ... ≤ X_{(n)}.",
                                    "Registre o tamanho da amostra n.",
                                    "Verifique se não há valores ausentes ou duplicatas excessivas que possam distorcer a CDF.",
                                    "Salve os dados ordenados em uma estrutura acessível (ex: lista ou array)."
                                  ],
                                  "verification": "Confirme que os dados estão ordenados corretamente comparando X_{(i)} ≤ X_{(i+1)} para todo i.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Amostra de dados (CSV ou lista)",
                                    "Python com NumPy ou planilha Excel"
                                  ],
                                  "tips": "Use np.sort() no Python para ordenação rápida e precisa.",
                                  "learningObjective": "Entender a importância da ordenação para construção da CDF empírica.",
                                  "commonMistakes": [
                                    "Esquecer de ordenar os dados.",
                                    "Incluir dados duplicados sem ajuste.",
                                    "Confundir amostra ordenada com original."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a Função de Distribuição Cumulativa Empírica (F_n(x))",
                                  "subSteps": [
                                    "Para cada X_{(i)}, calcule F_n(X_{(i)}) = i / n, onde i vai de 1 a n.",
                                    "Crie um vetor paralelo com os valores F_n para os pontos ordenados.",
                                    "Ajuste para laços em i=1 (F_n=1/n) e i=n (F_n=1).",
                                    "Plote opcionalmente F_n(x) vs x para visualização.",
                                    "Salve os pares (X_{(i)}, F_n(X_{(i)}))."
                                  ],
                                  "verification": "Verifique se F_n(X_{(1)}) = 1/n e F_n(X_{(n)}) = 1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Dados ordenados do Step 1",
                                    "Python com NumPy/Matplotlib ou calculadora"
                                  ],
                                  "tips": "Evite divisão por zero usando i/n com i iniciando em 1.",
                                  "learningObjective": "Dominar a construção da CDF empírica a partir de dados ordenados.",
                                  "commonMistakes": [
                                    "Usar (i-1)/n em vez de i/n.",
                                    "Aplicar F_n em pontos não ordenados.",
                                    "Arredondar prematuramente os valores de F_n."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir e Calcular a CDF Teórica do Modelo (F(x))",
                                  "subSteps": [
                                    "Identifique a distribuição teórica do modelo (ex: Normal(μ,σ), Uniforme(a,b)).",
                                    "Para cada X_{(i)}, compute F(X_{(i)}) usando a função CDF da distribuição.",
                                    "Use parâmetros estimados do modelo se disponíveis.",
                                    "Crie um vetor paralelo com F(X_{(i)}).",
                                    "Valide F(x) em extremos: deve tender a 0 e 1."
                                  ],
                                  "verification": "Confirme que min(F(X)) ≈ 0 e max(F(X)) ≈ 1 para os dados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Parâmetros do modelo",
                                    "Python com SciPy.stats (ex: norm.cdf())"
                                  ],
                                  "tips": "Para distribuições customizadas, implemente a CDF analiticamente.",
                                  "learningObjective": "Aplicar funções CDF teóricas aos pontos empíricos.",
                                  "commonMistakes": [
                                    "Usar PDF em vez de CDF.",
                                    "Parâmetros errados da distribuição.",
                                    "Não avaliar F exatamente nos X_{(i)}."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular as Diferenças Absolutas |F_n(x) - F(x)|",
                                  "subSteps": [
                                    "Para cada i, compute d_i = |F_n(X_{(i)}) - F(X_{(i)})|.",
                                    "Crie um vetor de todas as d_i.",
                                    "Identifique visualmente o maior d_i plotando as diferenças.",
                                    "Registre todas as diferenças para inspeção.",
                                    "Verifique consistência numérica (ex: precisão de 4 casas decimais)."
                                  ],
                                  "verification": "Todas d_i ≥ 0 e pelo menos uma d_i > 0 se discrepância existir.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Vetores F_n e F do Steps 2-3",
                                    "Python com NumPy (np.abs())"
                                  ],
                                  "tips": "Use np.maximum para eficiência em grandes n.",
                                  "learningObjective": "Quantificar discrepâncias ponto a ponto entre empírico e teórico.",
                                  "commonMistakes": [
                                    "Esquecer o valor absoluto.",
                                    "Calcular em pontos errados.",
                                    "Ignorar diferenças em caudas."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Determinar a Estatística KS D como o Supremo das Diferenças",
                                  "subSteps": [
                                    "Encontre D = max(d_i) sobre todos i=1 a n.",
                                    "Confirme que é o supremo (máximo em pontos discretos KS).",
                                    "Registre o índice i* onde D ocorre e o valor X_{(i*)}.",
                                    "Compare com thresholds críticos se aplicável.",
                                    "Documente o resultado final com contexto."
                                  ],
                                  "verification": "D = max(d_i) e corresponde ao maior |F_n - F| observado.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Vetor de d_i do Step 4",
                                    "Python com np.max()"
                                  ],
                                  "tips": "Para aproximação contínua, considere também saltos, mas max discreto basta para KS padrão.",
                                  "learningObjective": "Identificar o ponto máximo de discrepância como estatística de teste.",
                                  "commonMistakes": [
                                    "Confundir D com soma ou média das diferenças.",
                                    "Não reportar o local do máximo.",
                                    "Arredondar D prematuramente."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere dados de tempos de falha em simulação: X = [1.2, 1.5, 1.8, 2.0, 2.3, 2.5, 2.8]. Teste contra Uniforme(1,3). Ordenados: iguais. n=7. F_n = [1/7,2/7,...,7/7]. F(x) = (x-1)/2. Diferenças: ex. |1/7 - (1.2-1)/2| ≈ |0.143-0.1|=0.043; max D≈0.214 em x=2.8.",
                              "finalVerifications": [
                                "Dados ordenados corretamente com F_n(1)=1/n e F_n(n)=1.",
                                "CDF teórica avaliada precisamente nos pontos X_{(i)}.",
                                "Todas diferenças d_i = |F_n - F| ≥ 0.",
                                "D = máximo exato de d_i, com índice i* identificado.",
                                "Resultado documentado com valores numéricos (ex: D=0.214).",
                                "Visualização opcional confirma o pico de discrepância."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de F_n e F (erro < 0.001).",
                                "Identificação correta do máximo D e seu local.",
                                "Tratamento adequado de edge cases (n pequeno, dados com ties).",
                                "Documentação clara de passos e resultados.",
                                "Eficiência computacional para n>1000.",
                                "Interpretação correta: D maior indica pior ajuste."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Ligação com testes de bondade de ajuste e p-valores.",
                                "Programação: Implementação numérica com SciPy.stats.kstest().",
                                "Simulação: Validação de geradores pseudo-aleatórios.",
                                "Probabilidade: Compreensão profunda de CDFs empíricas vs teóricas.",
                                "Ciência de Dados: Detecção de desvios em distribuições de dados reais."
                              ],
                              "realWorldApplication": "Em simulações de sistemas discretos como filas de atendimento ou redes de computadores, calcular KS valida se tempos de resposta simulados seguem distribuição teórica (ex: exponencial), permitindo ajustes no modelo para previsões precisas em logística ou telecomunicações."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.1.3"
                            ]
                          },
                          {
                            "id": "10.1.5.4.3.2",
                            "name": "Usar Tabelas KS e Decidir Rejeição",
                            "description": "Comparar a estatística KS com valores críticos de tabelas KS para amostras finitas ou assintóticas, decidindo sobre equivalência das distribuições com nível α.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar a Tabela KS Adequada",
                                  "subSteps": [
                                    "Determine se a amostra é finita (n < 40) ou assintótica (n ≥ 40) com base no tamanho da amostra n.",
                                    "Identifique o tipo de teste: unilateral ou bilateral, e o nível de significância α (ex: 0.05, 0.01).",
                                    "Localize a tabela KS correspondente: tabela finita para amostras pequenas ou tabela assintótica para grandes amostras.",
                                    "Verifique se a tabela inclui os valores de α relevantes para o teste.",
                                    "Anote o contexto do teste (ex: comparação de CDF empírica com teórica)."
                                  ],
                                  "verification": "Confirme que a tabela selecionada matches com n e α do problema; liste justificativa por escrito.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Tabelas KS (finita e assintótica impressas ou digitais), descrição do problema com n e α.",
                                  "tips": "Sempre priorize tabelas de fontes confiáveis como livros de estatística (ex: Miller, 1956 para KS).",
                                  "learningObjective": "Compreender critérios para escolha da tabela KS baseada em n e tipo de teste.",
                                  "commonMistakes": "Usar tabela assintótica para n pequeno (leva a decisões erradas); ignorar se é unilateral ou bilateral."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Parâmetros e Localizar Valor Crítico",
                                  "subSteps": [
                                    "Extraia o tamanho da amostra n e o nível α do enunciado do teste KS.",
                                    "Para tabela finita, encontre a linha de n e coluna de α; leia o valor crítico D_crit.",
                                    "Para tabela assintótica, use a fórmula aproximada ou tabela direta: D_crit = K_α / sqrt(n), onde K_α é o valor tabelado.",
                                    "Registre o valor crítico exato ou aproximado com precisão de 3 casas decimais.",
                                    "Confirme unidades: D é adimensional, entre 0 e 1."
                                  ],
                                  "verification": "Escreva os valores de n, α e D_crit extraídos; compare com tabela para consistência.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Tabela KS, calculadora para aproximações assintóticas, rascunho para anotações.",
                                  "tips": "Para n grande, memorize valores comuns: K_0.05 ≈ 1.36, K_0.01 ≈ 1.63.",
                                  "learningObjective": "Localizar e extrair valores críticos com precisão de tabelas KS.",
                                  "commonMistakes": "Confundir α com 1-α; ler linha/coluna errada; esquecer ajuste para bilateral (multiplicar por 2 em alguns casos)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Obter e Comparar a Estatística KS Observada",
                                  "subSteps": [
                                    "Obtenha a estatística KS calculada D_obs do teste anterior (suprema distância entre CDFs).",
                                    "Compare D_obs com D_crit: se D_obs > D_crit, hipótese nula H0 é rejeitada.",
                                    "Considere o nível α: rejeição significa distribuições não equivalentes com probabilidade 1-α.",
                                    "Anote a desigualdade: D_obs ? D_crit e a decisão (rejeitar ou não rejeitar H0).",
                                    "Calcule p-valor aproximado se tabela fornecer, para suporte à decisão."
                                  ],
                                  "verification": "Registre D_obs, D_crit, comparação e decisão final em uma tabela resumida.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Resultado do cálculo KS (D_obs), tabela KS, papel para comparação.",
                                  "tips": "Use desigualdade estrita > para rejeição; lembre que não rejeitar ≠ aceitar H0.",
                                  "learningObjective": "Realizar comparação precisa e interpretar o resultado da hipótese.",
                                  "commonMistakes": "Inverter comparação (rejeitar quando D_obs < D_crit); ignorar que KS testa equivalência de CDFs."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Documentar Decisão e Justificativa",
                                  "subSteps": [
                                    "Escreva a conclusão: 'Rejeitamos H0 ao nível α = X pois D_obs = Y > D_crit = Z'.",
                                    "Inclua implicações para validação do modelo: distribuições equivalentes ou não.",
                                    "Registre suposições do teste (ex: amostra iid, continuidade).",
                                    "Sugira próximos passos: ajustar modelo se rejeitado.",
                                    "Revise todo o processo para erros aritméticos ou de tabela."
                                  ],
                                  "verification": "Produza um relatório de 1 parágrafo com decisão, valores e justificativa; peer-review simulado.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Rascunho anterior, template de relatório.",
                                  "tips": "Use linguagem clara: evite ambiguidades como 'aceitar' H0.",
                                  "learningObjective": "Comunicar decisão de teste KS de forma profissional e completa.",
                                  "commonMistakes": "Omitir valores numéricos na conclusão; confundir rejeição com prova de diferença."
                                }
                              ],
                              "practicalExample": "Dado n=20, α=0.05, bilateral, D_obs=0.22. Tabela finita KS: D_crit(20,0.05)=0.294. Como 0.22 < 0.294, não rejeitamos H0: as distribuições são equivalentes ao nível 5%.",
                              "finalVerifications": [
                                "Tabela KS selecionada corretamente para n e α.",
                                "Valor crítico extraído com precisão.",
                                "Comparação D_obs vs D_crit realizada sem erros.",
                                "Decisão de rejeição/não rejeição justificada.",
                                "Conclusão inclui implicações para validação.",
                                "Suposições do teste mencionadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na seleção e consulta da tabela KS (30%).",
                                "Correção na comparação e decisão (25%).",
                                "Detalhe nos subpassos e verificações (20%).",
                                "Clareza na documentação e justificativa (15%).",
                                "Identificação de erros comuns evitados (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Integra com testes de hipóteses não-paramétricos.",
                                "Programação: Implementação em Python (scipy.stats.kstest) para automação.",
                                "Probabilidade: Compreensão de CDFs e distribuições contínuas.",
                                "Ciência de Dados: Validação de modelos preditivos."
                              ],
                              "realWorldApplication": "Em simulações de sistemas discretos como filas em call centers, usar KS para validar se o modelo gerado matches a distribuição real de tempos de espera, decidindo rejeitar modelo inválido para evitar decisões erradas em otimização de recursos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.1.2"
                            ]
                          },
                          {
                            "id": "10.1.5.4.3.3",
                            "name": "Implementar Teste KS em Análise de Simulação",
                            "description": "Aplicar o teste KS via software (ex.: Python scipy.stats.ks_2samp para duas amostras) para validar tempos interchegada ou de processamento em modelos de simulação de eventos discretos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar Dados de Simulação e Observados",
                                  "subSteps": [
                                    "Colete ou gere dados observados reais de tempos interchegada ou processamento (ex.: logs de um sistema de fila).",
                                    "Execute uma simulação de eventos discretos para gerar dados simulados correspondentes (usando bibliotecas como SimPy ou simulação customizada em Python).",
                                    "Garanta que ambos os conjuntos de dados tenham o mesmo tamanho e estejam limpos (remova outliers ou valores inválidos).",
                                    "Calcule estatísticas descritivas básicas (média, mediana, desvios) para ambos os conjuntos para inspeção inicial.",
                                    "Armazene os dados em arrays NumPy para eficiência computacional."
                                  ],
                                  "verification": "Verifique se os arrays têm o mesmo comprimento e estatísticas descritivas semelhantes via print ou DataFrame.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python com NumPy e Pandas instalados",
                                    "Dados reais ou dataset de exemplo de simulação de filas"
                                  ],
                                  "tips": "Use seed fixa na simulação para reprodutibilidade (np.random.seed(42)).",
                                  "learningObjective": "Compreender a importância de dados pareados e preparados para testes de hipóteses em validação de simulações.",
                                  "commonMistakes": [
                                    "Ignorar limpeza de dados levando a falsos positivos",
                                    "Usar distribuições diferentes sem alinhamento",
                                    "Não fixar seed causando variabilidade excessiva"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Ambiente e Importar Bibliotecas",
                                  "subSteps": [
                                    "Instale scipy via pip se necessário: pip install scipy.",
                                    "Importe módulos essenciais: from scipy.stats import ks_2samp; import numpy as np; import matplotlib.pyplot as plt.",
                                    "Defina nível de significância alpha (ex.: 0.05).",
                                    "Crie uma função wrapper para o teste KS que aceite dois arrays e alpha.",
                                    "Teste a importação com dados sintéticos simples (ex.: duas distribuições normais)."
                                  ],
                                  "verification": "Execute um teste KS em dados conhecidos e confirme p-value esperado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ambiente Python (Jupyter Notebook recomendado)",
                                    "Documentação SciPy KS test"
                                  ],
                                  "tips": "Use Jupyter para visualizações interativas de histogramas cumulativos.",
                                  "learningObjective": "Dominar a configuração de ferramentas estatísticas em Python para análise de simulações.",
                                  "commonMistakes": [
                                    "Esquecer de importar módulos corretos",
                                    "Confundir ks_1samp com ks_2samp",
                                    "Definir alpha muito baixo/alto sem justificativa"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar o Teste KS e Analisar Estatísticas",
                                  "subSteps": [
                                    "Chame ks_2samp(observed_data, simulated_data) para obter estatística D e p-value.",
                                    "Compare p-value com alpha: se p > alpha, não rejeite H0 (distribuições semelhantes).",
                                    "Plote histogramas cumulativos (ECDF) dos dois conjuntos para visualização gráfica do teste.",
                                    "Calcule a estatística D manualmente para compreensão (máxima diferença vertical nas ECDFs).",
                                    "Registre resultados em um relatório ou dicionário com D, p-value e decisão."
                                  ],
                                  "verification": "Confirme que D é calculado corretamente e plotas mostram sobreposição se p > alpha.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "SciPy e Matplotlib",
                                    "Dados preparados do Step 1"
                                  ],
                                  "tips": "Visualize ECDF com statsmodels.ecdf para precisão.",
                                  "learningObjective": "Aplicar e interpretar o teste KS bidimensional para validação empírica de simulações.",
                                  "commonMistakes": [
                                    "Interpretar erroneamente H0 (H0 é que distribuições são iguais)",
                                    "Ignorar tamanho amostral pequeno afetando poder do teste",
                                    "Não plotar ECDF para validação visual"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Resultados e Validar Modelo",
                                  "subSteps": [
                                    "Se rejeitar H0, ajuste parâmetros da simulação (ex.: distribuição interchegada) e reexecute.",
                                    "Documente iterações de ajuste até p > alpha.",
                                    "Compare com outros testes (ex.: Anderson-Darling) para robustez.",
                                    "Gere relatório final com conclusões sobre validade do modelo.",
                                    "Salve resultados e plots para portfólio ou apresentação."
                                  ],
                                  "verification": "Modelo validado se p > alpha consistentemente em múltiplas runs.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código dos steps anteriores",
                                    "Template de relatório Markdown ou Jupyter"
                                  ],
                                  "tips": "Automatize com loop para múltiplas seeds e médias de p-values.",
                                  "learningObjective": "Integrar resultados do KS em processo iterativo de validação de modelos de simulação.",
                                  "commonMistakes": [
                                    "Não iterar ajustes após rejeição",
                                    "Aceitar p próximo a alpha sem runs múltiplas",
                                    "Omitir documentação de decisões"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de check-in em aeroporto usando SimPy, gere 1000 tempos interchegada simulados de uma exponencial(λ=5 min). Compare com 1000 tempos reais coletados. Execute ks_2samp: se p=0.23 > 0.05, valide que o modelo captura a chegada de passageiros corretamente.",
                              "finalVerifications": [
                                "Executa teste KS em dataset próprio e obtém p-value correto.",
                                "Interpreta corretamente rejeição/aceitação de H0.",
                                "Gera plots ECDF mostrando similaridade ou diferenças.",
                                "Ajusta simulação iterativamente até validação.",
                                "Documenta relatório com D, p-value e conclusões.",
                                "Reprodutibilidade confirmada com seed fixa."
                              ],
                              "assessmentCriteria": [
                                "Precisão na preparação e limpeza de dados (20%)",
                                "Correta execução e interpretação do ks_2samp (30%)",
                                "Qualidade de visualizações e análises complementares (20%)",
                                "Capacidade de iteração e ajuste do modelo (15%)",
                                "Clareza e completude do relatório final (15%)"
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Testes não-paramétricos e hipóteses.",
                                "Programação: Manipulação de dados com NumPy/SciPy.",
                                "Engenharia de Sistemas: Validação de modelos de simulação.",
                                "Ciência de Dados: Análise empírica e visualização."
                              ],
                              "realWorldApplication": "Validar modelos de simulação em logística (ex.: otimização de filas em supermercados ou call centers), garantindo que tempos simulados reflitam realidade para decisões de alocação de recursos e previsão de gargalos."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.5",
                    "name": "Análise de Sensibilidade na Validação",
                    "description": "Exame de como variações nos parâmetros do modelo afetam as saídas, confirmando robustez e precisão.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.5.1",
                        "name": "Definição e Objetivos da Análise de Sensibilidade",
                        "description": "Compreender os fundamentos da análise de sensibilidade, incluindo sua definição como técnica para examinar o impacto de variações nos parâmetros do modelo de simulação sobre as saídas, e seus objetivos principais na confirmação de robustez e precisão do modelo.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.1.1",
                            "name": "Definir Análise de Sensibilidade",
                            "description": "Explicar a análise de sensibilidade como um procedimento sistemático que varia intencionalmente parâmetros do modelo de simulação discreta para observar mudanças nas saídas estatísticas, identificando parâmetros críticos e validando a estabilidade do modelo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Simulação de Sistemas Discretos",
                                  "subSteps": [
                                    "Defina simulação discreta como um modelo onde o estado muda em pontos discretos no tempo.",
                                    "Identifique componentes chave: entidades, recursos, filas e saídas estatísticas (ex: tempo médio de espera).",
                                    "Liste exemplos comuns: filas de supermercado, linhas de produção.",
                                    "Explique parâmetros do modelo (ex: tempo de serviço, chegada de clientes).",
                                    "Discuta saídas estatísticas como métricas agregadas de múltiplas rodadas."
                                  ],
                                  "verification": "Resuma em 3 frases os fundamentos e liste 3 parâmetros e 2 saídas de um modelo de fila simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Notebook com internet",
                                    "Artigo introdutório sobre simulação discreta (ex: Wikipedia ou tutorial Arena)"
                                  ],
                                  "tips": "Use diagramas para visualizar o fluxo de entidades e mudanças de estado.",
                                  "learningObjective": "Compreender os elementos básicos de um modelo de simulação discreta e suas saídas estatísticas.",
                                  "commonMistakes": [
                                    "Confundir simulação discreta com contínua (ex: ignorar eventos discretos)",
                                    "Ignorar variabilidade estocástica nos parâmetros"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Conceito Geral de Análise de Sensibilidade",
                                  "subSteps": [
                                    "Defina análise de sensibilidade como técnica para testar impacto de variações em entradas sobre saídas.",
                                    "Diferencie de otimização: foco em identificação de influência, não em ajuste ótimo.",
                                    "Classifique tipos: one-at-a-time (OAT) vs. global (varia múltiplos simultaneamente).",
                                    "Explique variação intencional: ±10-20% ou faixas realistas.",
                                    "Discuta observação de mudanças nas saídas estatísticas."
                                  ],
                                  "verification": "Escreva uma definição de 50 palavras e dê um exemplo fora de simulação (ex: orçamento familiar).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de papel ou editor de texto",
                                    "Vídeo curto sobre análise de sensibilidade (ex: YouTube, 5-10 min)"
                                  ],
                                  "tips": "Comece com OAT para simplicidade antes de métodos avançados.",
                                  "learningObjective": "Dominar a definição e propósito geral da análise de sensibilidade em modelagem.",
                                  "commonMistakes": [
                                    "Confundir com calibração de modelo (ajuste para dados reais)",
                                    "Não considerar variabilidade estocástica nas simulações"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Análise de Sensibilidade a Modelos de Simulação Discreta",
                                  "subSteps": [
                                    "Selecione um parâmetro chave (ex: taxa de chegada) e defina faixas de variação (±20%).",
                                    "Execute múltiplas rodadas (replicatas) para cada variação para estabilizar estatísticas.",
                                    "Registre mudanças nas saídas (ex: aumento de 20% na fila leva a 50% mais tempo de espera).",
                                    "Identifique parâmetros críticos: aqueles com maior impacto nas saídas.",
                                    "Compare respostas: linear vs. não-linear."
                                  ],
                                  "verification": "Crie uma tabela simples com 3 parâmetros variados e impactos esperados em saídas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets",
                                    "Software gratuito como SimPy (Python) para simulação básica"
                                  ],
                                  "tips": "Use pelo menos 10 replicatas por cenário para reduzir ruído estocástico.",
                                  "learningObjective": "Entender o procedimento sistemático de variação de parâmetros em simulações discretas.",
                                  "commonMistakes": [
                                    "Poucas replicatas levando a resultados instáveis",
                                    "Variações irreais (ex: tempo negativo)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir Objetivos e Validar Estabilidade do Modelo",
                                  "subSteps": [
                                    "Estabeleça objetivos: rankear parâmetros por criticidade, validar robustez.",
                                    "Explique estabilidade: saídas insensíveis a pequenas variações indicam modelo confiável.",
                                    "Interprete resultados: parâmetros com alta sensibilidade precisam de dados precisos.",
                                    "Sintetize definição completa: procedimento sistemático para variar parâmetros e observar saídas.",
                                    "Redija a definição final em parágrafo coeso."
                                  ],
                                  "verification": "Escreva a definição completa da análise de sensibilidade e liste 3 objetivos no contexto de validação.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Editor de texto",
                                    "Modelo de simulação simples salvo do Step 3"
                                  ],
                                  "tips": "Priorize parâmetros com alta incerteza de dados reais.",
                                  "learningObjective": "Sintetizar a definição integral, incluindo identificação de críticos e validação de estabilidade.",
                                  "commonMistakes": [
                                    "Ignorar contexto estocástico (focar só em determinístico)",
                                    "Não ligar sensibilidade à validação geral do modelo"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um modelo de fila de call center (simulação discreta com chegadas Poisson e serviço exponencial), varie o parâmetro 'taxa de chegada' de 10 para 8 e 12 chamadas/hora. Execute 20 replicatas por cenário. Observe que a taxa de 12 aumenta o tempo médio de espera de 2 para 5 minutos (150% de mudança), identificando-a como crítica e validando que o modelo é estável para taxas abaixo de 11.",
                              "finalVerifications": [
                                "Explique em suas palavras a definição completa de análise de sensibilidade em simulação discreta.",
                                "Identifique 3 parâmetros críticos em um modelo de fila dado.",
                                "Descreva como variações intencionais validam estabilidade do modelo.",
                                "Crie uma tabela de sensibilidade para um exemplo simples.",
                                "Diferencie análise de sensibilidade de otimização ou calibração.",
                                "Liste objetivos principais da análise na validação de modelos."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude na definição (inclui variação intencional, saídas estatísticas, parâmetros críticos).",
                                "Clareza no procedimento sistemático (passos de variação e observação).",
                                "Compreensão de objetivos (identificação crítica e validação de estabilidade).",
                                "Uso correto de terminologia (simulação discreta, replicatas, estocasticidade).",
                                "Capacidade de aplicar em exemplo prático com interpretação quantitativa.",
                                "Identificação de erros comuns e dicas preventivas."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Análise de variância e distribuições probabilísticas em replicatas.",
                                "Programação: Implementação em Python (SimPy) ou R para automação de simulações.",
                                "Engenharia Industrial: Otimização de sistemas de filas e manufatura.",
                                "Gestão de Riscos: Avaliação de incertezas em modelos preditivos.",
                                "Matemática Aplicada: Funções de resposta e análise multivariable."
                              ],
                              "realWorldApplication": "Na logística de supply chain, a análise de sensibilidade identifica se variações no tempo de processamento em armazéns (parâmetro crítico) causam atrasos em entregas, permitindo priorizar investimentos em automação e validar a robustez do modelo para cenários reais de demanda volátil."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.1.2",
                            "name": "Identificar Objetivos na Validação",
                            "description": "Listar e descrever os objetivos da análise de sensibilidade na validação de modelos, como detectar fragilidades, confirmar robustez ante incertezas e priorizar calibrações de parâmetros em simulações de sistemas discretos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Validação de Modelos",
                                  "subSteps": [
                                    "Defina validação de modelos em simulações discretas como o processo de verificar se o modelo representa adequadamente o sistema real.",
                                    "Explique análise de sensibilidade como técnica para avaliar como variações em inputs afetam outputs.",
                                    "Identifique o papel da análise de sensibilidade na validação: testar robustez e identificar pontos críticos.",
                                    "Liste exemplos de sistemas discretos, como filas M/M/1 ou redes de Petri.",
                                    "Anote diferenças entre validação global e local."
                                  ],
                                  "verification": "Crie um mapa mental conectando validação, sensibilidade e sistemas discretos; revise se cobre todos os pontos chave.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro 'Simulation Modeling and Analysis' de Law; notebook Jupyter com exemplos de simulações discretas.",
                                  "tips": "Use diagramas de fluxo para visualizar o pipeline de validação antes de prosseguir.",
                                  "learningObjective": "Compreender o contexto da análise de sensibilidade dentro da validação de modelos discretos.",
                                  "commonMistakes": "Confundir sensibilidade com otimização; ignorar que validação precede calibração."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Listar Objetivos Principais da Análise de Sensibilidade",
                                  "subSteps": [
                                    "Enumere objetivos como: detectar fragilidades (identificar parâmetros sensíveis).",
                                    "Adicione confirmar robustez ante incertezas (testar estabilidade sob variações aleatórias).",
                                    "Inclua priorizar calibrações de parâmetros (rankear por impacto na saída).",
                                    "Registre objetivos adicionais: quantificar propagação de erros e guiar simplificações de modelo.",
                                    "Organize em uma tabela com colunas: Objetivo, Descrição Breve, Métrica Associada."
                                  ],
                                  "verification": "Verifique se a lista tem pelo menos 4 objetivos alinhados à descrição; compartilhe com um peer para feedback.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha Google Sheets ou Excel para tabela; artigo 'Sensitivity Analysis in Practice' de Saltelli.",
                                  "tips": "Priorize objetivos por relevância em sistemas discretos, como tempos de serviço em filas.",
                                  "learningObjective": "Produzir uma lista exaustiva e categorizada de objetivos da análise de sensibilidade.",
                                  "commonMistakes": "Listar objetivos genéricos sem link à validação; omitir incertezas estocásticas em discretos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Descrever Detalhadamente Cada Objetivo",
                                  "subSteps": [
                                    "Para 'detectar fragilidades': descreva como variações pequenas em parâmetros levam a grandes desvios na saída.",
                                    "Para 'confirmar robustez': explique testes com distribuições de Monte Carlo para incertezas.",
                                    "Para 'priorizar calibrações': detalhe uso de índices como Sobol' para ranking.",
                                    "Para cada um, forneça fórmula ou pseudocódigo simples de implementação.",
                                    "Conecte descrições a validação: como cada objetivo contribui para confiança no modelo."
                                  ],
                                  "verification": "Escreva parágrafos descritivos para cada; leia em voz alta para clareza e completude.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software Python com bibliotecas SALib para índices de sensibilidade; exemplos de código de simulações discretas.",
                                  "tips": "Use analogias: fragilidade como 'casa de cartas' sensível a ventos (incertezas).",
                                  "learningObjective": "Articular descrições precisas e acionáveis para cada objetivo.",
                                  "commonMistakes": "Descrições vagas sem métricas quantificáveis; ignorar contexto discreto (ex: eventos discretos)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e Contextualizar em Simulações Discretas",
                                  "subSteps": [
                                    "Compile lista e descrições em um documento unificado.",
                                    "Aplique a um exemplo: simulação de fila, variando taxa de chegada para detectar fragilidades.",
                                    "Discuta como objetivos guiam decisões de validação em cenários reais discretos.",
                                    "Identifique lacunas na lista e refine.",
                                    "Crie um fluxograma mostrando integração dos objetivos no processo de validação."
                                  ],
                                  "verification": "Gere relatório de 1 página resumindo; teste aplicando a um mini-exemplo numérico.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramenta de diagrama como Draw.io; simulador SimPy para Python (sistemas discretos).",
                                  "tips": "Sempre volte à descrição original para alinhamento.",
                                  "learningObjective": "Integrar objetivos em um framework coeso para validação em sistemas discretos.",
                                  "commonMistakes": "Generalizar demais sem exemplos discretos; não sintetizar em formato acionável."
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila M/M/1 (sistema discreto de eventos), varie a taxa de chegada λ de 0.8μ para 1.2μ. Detecte fragilidade se tempo médio na fila explode >20%; confirme robustez se variância <5% sob 1000 runs Monte Carlo; priorize calibrar μ se índice Sobol' >0.3.",
                              "finalVerifications": [
                                "Lista completa de pelo menos 4 objetivos listados com descrições claras.",
                                "Cada objetivo ligado explicitamente à validação de modelos discretos.",
                                "Exemplo prático implementável com métricas quantificáveis.",
                                "Fluxograma ou tabela sintetizando o processo.",
                                "Auto-avaliação: consegue explicar a um colega sem notas?",
                                "Teste: aplique a um novo sistema discreto como rede de filas."
                              ],
                              "assessmentCriteria": [
                                "Completude: Todos objetivos da descrição cobertos (detectar fragilidades, robustez, priorizar calibrações).",
                                "Precisão: Descrições tecnicamente corretas com referências a métodos como Sobol' ou Morris.",
                                "Profundidade: Substeps detalhados e exemplos concretos em discretos.",
                                "Clareza: Linguagem acessível, sem jargão não explicado.",
                                "Aplicabilidade: Verificações e tips acionáveis para aprendizado.",
                                "Integração: Conexão forte com contexto de simulações discretas."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Uso de Monte Carlo e índices de sensibilidade (Sobol').",
                                "Programação: Implementação em Python/SimPy para simulações.",
                                "Engenharia de Sistemas: Validação em modelagem de filas e redes.",
                                "Gestão de Riscos: Identificação de fragilidades em cenários incertos."
                              ],
                              "realWorldApplication": "Em logística, validar modelos de simulação de armazéns discretos para detectar fragilidades em taxas de chegada de caminhões, confirmando robustez sob greves ou picos sazonais, e priorizando calibração de tempos de processamento para otimizar operações reais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.1.3",
                            "name": "Diferenciar de Outras Técnicas de Validação",
                            "description": "Comparar a análise de sensibilidade com testes de validação estatística e face validity, destacando seu foco em variações paramétricas para avaliar precisão em cenários de simulação discreta.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais da Análise de Sensibilidade",
                                  "subSteps": [
                                    "Ler a definição oficial de análise de sensibilidade em validação de modelos discretos.",
                                    "Identificar os objetivos principais: avaliar impacto de variações paramétricas na precisão do modelo.",
                                    "Listar exemplos de parâmetros comuns em simulações discretas (ex.: taxa de chegada, tempo de serviço).",
                                    "Anotar como ela difere de análises globais por focar em variações locais controladas.",
                                    "Resumir em um diagrama mental os passos da análise de sensibilidade."
                                  ],
                                  "verification": "Criar um resumo de 1 parágrafo explicando o foco em variações paramétricas e confirmar com auto-perguntas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação do módulo MC-37, artigo sobre validação de simulações discretas, papel e caneta para diagrama.",
                                  "tips": "Use analogias como 'testar sensibilidade de um carro ajustando pneus' para fixar o conceito.",
                                  "learningObjective": "Compreender o escopo único da análise de sensibilidade em simulações discretas.",
                                  "commonMistakes": "Confundir com otimização de parâmetros, que visa melhoria, não validação."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Testes de Validação Estatística",
                                  "subSteps": [
                                    "Definir testes estatísticos comuns: teste qui-quadrado, Kolmogorov-Smirnov, teste de aderência.",
                                    "Explicar seu foco em comparar distribuições de saída do modelo com dados reais.",
                                    "Listar pré-requisitos: dados empíricos observados e simulações suficientes.",
                                    "Analisar limitações: sensíveis a suposições de normalidade e não capturam variações paramétricas.",
                                    "Comparar superficialmente com sensibilidade anotando 3 diferenças iniciais."
                                  ],
                                  "verification": "Listar 3 testes estatísticos com uma frase de aplicação cada e verificar se menciona dependência de dados reais.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Tabelas de testes estatísticos online, exemplos de simulações de filas, calculadora ou software R/Python.",
                                  "tips": "Pratique com dados sintéticos para visualizar distribuições antes de comparar.",
                                  "learningObjective": "Dominar os princípios e limitações dos testes estatísticos em validação.",
                                  "commonMistakes": "Ignorar que testes estatísticos requerem dados reais, não apenas simulações."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Face Validity",
                                  "subSteps": [
                                    "Descrever face validity como avaliação qualitativa subjetiva por experts.",
                                    "Exemplificar: experts revisam se o modelo 'faz sentido' logicamente em cenários discretos.",
                                    "Destacar vantagens: rápida e não requer dados quantitativos.",
                                    "Pontuar desvantagens: subjetiva, propensa a vieses e não quantifica precisão paramétrica.",
                                    "Criar tabela comparativa inicial com sensibilidade e testes estatísticos."
                                  ],
                                  "verification": "Escrever um parágrafo criticando face validity e confirmar ausência de métricas quantitativas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Artigos sobre validação qualitativa, exemplos de revisões de modelos por experts, ferramenta de tabela (Excel ou papel).",
                                  "tips": "Pergunte-se: 'Isso parece certo?' para simular julgamento de expert.",
                                  "learningObjective": "Entender o caráter qualitativo e subjetivo da face validity.",
                                  "commonMistakes": "Superestimar face validity como substituto para validações quantitativas rigorosas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar e Diferenciar as Três Técnicas",
                                  "subSteps": [
                                    "Construir tabela de comparação: colunas para foco, método, requisitos, forças e fraquezas.",
                                    "Destacar diferencial da sensibilidade: variações paramétricas controladas para precisão em discretos.",
                                    "Simular cenários onde cada técnica falha e sensibilidade succeeds.",
                                    "Sintetizar em mindmap ou fluxograma de escolha de técnica.",
                                    "Testar conhecimento respondendo perguntas de diferenciação."
                                  ],
                                  "verification": "Preencher tabela completa e explicar verbalmente uma diferença chave para um par hipotético.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Ferramenta de tabela/diagrama (Draw.io ou papel), resumos dos steps anteriores.",
                                  "tips": "Use cores na tabela: verde para forças da sensibilidade, vermelho para limitações das outras.",
                                  "learningObjective": "Capacitar diferenciação clara e contextualizada das técnicas.",
                                  "commonMistakes": "Equiparar sensibilidade a testes estatísticos por ambos usarem simulações, ignorando foco paramétrico."
                                }
                              ],
                              "practicalExample": "Em uma simulação discreta de sistema de filas (M/M/1), aplique análise de sensibilidade variando taxa de chegada (λ) em ±10%, medindo impacto no tempo médio de espera. Compare com teste qui-quadrado (usando dados reais de um call center) e face validity (expert aprova lógica do modelo). Note: sensibilidade revela robustez paramétrica sem dados reais, diferentemente das outras.",
                              "finalVerifications": [
                                "Explicar em 2 minutos as 3 diferenças principais sem consultar notas.",
                                "Preencher tabela de comparação corretamente em <5 minutos.",
                                "Identificar cenário onde sensibilidade é preferível sobre as outras.",
                                "Criticar limitações de cada técnica com exemplos.",
                                "Aplicar diferenciação a um novo contexto de simulação discreta."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção do foco paramétrico da sensibilidade (peso 30%).",
                                "Compreensão profunda de requisitos e limitações das outras técnicas (25%).",
                                "Capacidade de tabelas/comparações claras e lógicas (20%).",
                                "Exemplos relevantes e contextualizados em discretos (15%).",
                                "Síntese verbal/fluid fluida sem erros conceituais (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Integra testes qui-quadrado e KS para validação quantitativa.",
                                "Programação Computacional: Implementação em Python/R para simulações sensíveis.",
                                "Engenharia Industrial: Aplicação em modelagem de processos logísticos discretos.",
                                "Metodologia Científica: Paralelos com validação experimental em ciências."
                              ],
                              "realWorldApplication": "Em simulações de supply chain para empresas como Amazon, análise de sensibilidade testa robustez de modelos de estoque discreto a variações de demanda, complementando testes estatísticos (com dados históricos) e face validity (revisão de gerentes), garantindo precisão preditiva em cenários voláteis."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.5.2",
                        "name": "Métodos e Técnicas de Implementação",
                        "description": "Explorar as principais técnicas para realizar análise de sensibilidade em modelos de simulação, incluindo métodos univariados, multivariados e baseados em amostragem, com ênfase em sua aplicação prática.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.2.1",
                            "name": "Aplicar Análise Univariada",
                            "description": "Implementar análise de sensibilidade univariada variando um parâmetro por vez em um modelo de simulação discreta, plotando curvas de resposta e identificando thresholds de sensibilidade nas saídas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o Modelo de Simulação Discreta e Selecionar Parâmetro",
                                  "subSteps": [
                                    "Carregue ou implemente o modelo de simulação discreta base (ex: simulação de filas ou Monte Carlo).",
                                    "Identifique as saídas principais de interesse (ex: tempo médio de espera).",
                                    "Selecione um parâmetro único para análise univariada (ex: taxa de chegada λ).",
                                    "Defina o intervalo de variação do parâmetro (ex: de 0.1 a 2.0 com passos de 0.1).",
                                    "Configure sementes aleatórias para reprodutibilidade nas simulações."
                                  ],
                                  "verification": "Modelo executa corretamente produzindo saídas estáveis para valores fixos do parâmetro; intervalo de variação documentado.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Ambiente de programação (Python com NumPy/SciPy ou MATLAB)",
                                    "Código fonte do modelo discreto",
                                    "Documentação do modelo"
                                  ],
                                  "tips": "Comece com um modelo simples para testar; documente todas as suposições.",
                                  "learningObjective": "Entender a estrutura do modelo e preparar dados para variação univariada.",
                                  "commonMistakes": [
                                    "Ignorar efeitos estocásticos sem múltiplas runs",
                                    "Escolher intervalo inadequado que não capture não-linearidades"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Variação Univariada e Executar Simulações",
                                  "subSteps": [
                                    "Crie um loop para variar o parâmetro selecionado em intervalos definidos.",
                                    "Para cada valor do parâmetro, execute múltiplas simulações (ex: 100 runs) para média e desvio padrão.",
                                    "Colete saídas em arrays ou DataFrames (parâmetro vs. média de saída, vs. desvio).",
                                    "Salve dados em formato tabular (CSV ou Pandas DataFrame).",
                                    "Valide dados excluindo outliers ou runs falhas."
                                  ],
                                  "verification": "Tabela de dados gerada com colunas: parâmetro, média_saída, std_saída; pelo menos 10-20 pontos de variação.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Bibliotecas: NumPy, Pandas, SciPy.stats",
                                    "Código do loop de simulação"
                                  ],
                                  "tips": "Use paralelização (ex: joblib) para acelerar múltiplas runs.",
                                  "learningObjective": "Dominar execução sistemática de simulações univariadas.",
                                  "commonMistakes": [
                                    "Poucas runs por ponto levando a variância alta",
                                    "Não computar estatísticas descritivas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Plotar Curvas de Resposta",
                                  "subSteps": [
                                    "Importe bibliotecas de plotagem (Matplotlib/Seaborn ou ggplot).",
                                    "Crie gráfico de linha: eixo x = parâmetro variado, y = média saída com barras de erro (std).",
                                    "Adicione rótulos, título, grid e legenda.",
                                    "Plote curva de sensibilidade normalizada se aplicável (derivada ou % mudança).",
                                    "Salve plot em alta resolução (PNG/PDF)."
                                  ],
                                  "verification": "Gráfico gerado mostrando relação não-linear ou linear entre parâmetro e saída; legível e anotado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Matplotlib/Seaborn",
                                    "Dados coletados do Step 2"
                                  ],
                                  "tips": "Use log scales para intervalos amplos; destaque regiões de alta sensibilidade.",
                                  "learningObjective": "Visualizar impactos de variações paramétricas.",
                                  "commonMistakes": [
                                    "Escalas inadequadas escondendo thresholds",
                                    "Omitir intervalos de confiança"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar Thresholds de Sensibilidade",
                                  "subSteps": [
                                    "Calcule derivadas numéricas ou slopes nas curvas para detectar mudanças abruptas.",
                                    "Identifique thresholds onde saída muda >10-20% ou slope > limite pré-definido.",
                                    "Marque thresholds no gráfico com linhas verticais/anotações.",
                                    "Classifique sensibilidade: baixa/média/alta baseada em magnitude de mudança.",
                                    "Gere relatório resumindo thresholds e implicações."
                                  ],
                                  "verification": "Lista de thresholds identificados com justificativa quantitativa; gráfico atualizado com marcações.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "SciPy para derivadas (np.gradient)",
                                    "Gráficos do Step 3"
                                  ],
                                  "tips": "Use métodos automáticos como change-point detection para objetividade.",
                                  "learningObjective": "Extrair insights acionáveis de análises de sensibilidade.",
                                  "commonMistakes": [
                                    "Confundir ruído com thresholds reais",
                                    "Não quantificar sensibilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar e Documentar Resultados",
                                  "subSteps": [
                                    "Discuta implicações para validação do modelo (ex: parâmetros críticos).",
                                    "Compare com literatura ou expectativas teóricas.",
                                    "Recomende faixas seguras para parâmetros baseados em thresholds.",
                                    "Repita para 2-3 parâmetros adicionais se tempo permitir.",
                                    "Compile relatório final com código, plots e conclusões."
                                  ],
                                  "verification": "Relatório escrito com conclusões claras e reproduzível.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Jupyter Notebook ou relatório Markdown",
                                    "Todos os outputs anteriores"
                                  ],
                                  "tips": "Estruture relatório: intro, métodos, resultados, discussão.",
                                  "learningObjective": "Integrar análise em contexto de validação de modelos.",
                                  "commonMistakes": [
                                    "Sobregeneralizar de um parâmetro",
                                    "Ignorar limitações estocásticas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila M/M/1 (supermercado), varie a taxa de serviço μ de 0.5 a 2.0. Plote tempo médio de espera vs. μ, identificando threshold em μ=1.2 onde espera explode devido a instabilidade (ρ>1).",
                              "finalVerifications": [
                                "Curvas de resposta plotadas corretamente para pelo menos um parâmetro com erros.",
                                "Thresholds quantitativamente identificados e marcados.",
                                "Relatório documenta sensibilidade e implicações.",
                                "Código reproduz resultados em <5% variação.",
                                "Análise univariada distingue de multivariada.",
                                "Saídas estáveis com múltiplas runs."
                              ],
                              "assessmentCriteria": [
                                "Precisão na implementação do loop univariado (100% cobertura de intervalos).",
                                "Qualidade visual e interpretativa dos plots (clareza, escalas adequadas).",
                                "Identificação correta de thresholds (baseada em critérios quantitativos).",
                                "Profundidade da interpretação (implicações para modelo).",
                                "Reprodutibilidade e documentação do código.",
                                "Eficiência computacional (tempo razoável para runs)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Cálculo de médias, desvios e testes de significância.",
                                "Programação: Loops, vetores e visualização de dados.",
                                "Engenharia de Sistemas: Validação e robustez de modelos.",
                                "Física/Matemática: Dinâmica de sistemas discretos e estocásticos.",
                                "Ciência de Dados: Análise exploratória e sensibilidade."
                              ],
                              "realWorldApplication": "Em engenharia de tráfego, variar taxa de chegada para identificar thresholds de congestionamento em simulações de semáforos, otimizando timings para evitar engarrafamentos críticos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.5.2.2",
                            "name": "Utilizar Métodos Multivariados",
                            "description": "Executar análise multivariada, como design de experimentos fatoriais ou resposta superficial, para avaliar interações entre parâmetros em simulações de eventos discretos e quantificar contribuições relativas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos dos Métodos Multivariados",
                                  "subSteps": [
                                    "Estudar os conceitos básicos de design de experimentos (DOE), incluindo experimentos fatoriais completos e fracionários.",
                                    "Aprender sobre modelos de resposta superficial e sua relação com análise de sensibilidade.",
                                    "Diferenciar métodos univariados de multivariados, enfatizando a detecção de interações entre parâmetros.",
                                    "Revisar exemplos de simulações de eventos discretos onde interações são críticas.",
                                    "Explorar ferramentas estatísticas como ANOVA para análise multivariada."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito a diferença entre DOE factorial e análise de resposta superficial, com um diagrama de interações.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro 'Design and Analysis of Experiments' de Montgomery (capítulos iniciais)",
                                    "Tutoriais online em R ou Python para DOE",
                                    "Vídeos do Khan Academy sobre ANOVA"
                                  ],
                                  "tips": "Comece com exemplos simples de 2 fatores para visualizar interações graficamente.",
                                  "learningObjective": "Dominar os conceitos teóricos fundamentais de métodos multivariados aplicados a simulações discretas.",
                                  "commonMistakes": [
                                    "Confundir fatores controlados com variáveis de resposta",
                                    "Ignorar a importância das interações entre parâmetros",
                                    "Subestimar a necessidade de replicatas nas simulações"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Parâmetros e Fatores Relevantes",
                                  "subSteps": [
                                    "Identificar os parâmetros chave no modelo de simulação de eventos discretos (ex: taxa de chegada, tempo de serviço).",
                                    "Selecionar 3-5 fatores multivariados com níveis realistas (baixo, médio, alto).",
                                    "Definir a variável de resposta principal (ex: tempo médio de espera, taxa de utilização).",
                                    "Estabelecer o número de replicatas por combinação para reduzir variância.",
                                    "Documentar hipóteses sobre interações esperadas entre fatores."
                                  ],
                                  "verification": "Criar uma tabela de fatores e níveis com justificativa para cada escolha.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets para tabela de fatores",
                                    "Documentação do software de simulação (Arena, Simul8 ou Python com SimPy)"
                                  ],
                                  "tips": "Priorize fatores com maior impacto esperado baseado em análises univariadas prévias.",
                                  "learningObjective": "Selecionar fatores e níveis apropriados para análise multivariada em simulações.",
                                  "commonMistakes": [
                                    "Escolher níveis irreais que não representem o contexto real",
                                    "Incluir fatores irrelevantes, aumentando complexidade desnecessária",
                                    "Esquecer de definir replicatas suficientes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Projetar o Experimento Multivariado",
                                  "subSteps": [
                                    "Escolher o tipo de design: factorial completo (2^k), fracionário ou resposta superficial (ex: Box-Behnken).",
                                    "Gerar a matriz de experimentos usando software (R: DoE.base, Python: pyDOE).",
                                    "Calcular o número total de runs necessárias e avaliar viabilidade computacional.",
                                    "Planejar a randomização das runs para evitar vieses.",
                                    "Validar o design quanto a poder estatístico e resolução para detectar interações."
                                  ],
                                  "verification": "Gerar e apresentar a matriz de design com pelo menos 8 runs, incluindo randomização.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software R com pacote DoE.base",
                                    "Python com bibliotecas pyDOE e pandas",
                                    "Calculadora de poder estatístico online"
                                  ],
                                  "tips": "Use designs fracionários para reduzir runs quando k>3, mas verifique resolução para interações principais.",
                                  "learningObjective": "Projetar eficientemente um experimento multivariado otimizado para simulações.",
                                  "commonMistakes": [
                                    "Usar factorial completo com muitos fatores, levando a explosão combinatória",
                                    "Não randomizar runs, introduzindo ordem artificial",
                                    "Ignorar aliasing em designs fracionários"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar Simulações e Coletar Dados",
                                  "subSteps": [
                                    "Implementar o modelo de simulação de eventos discretos com os fatores variados.",
                                    "Executar cada run da matriz, coletando métricas de resposta com estatísticas descritivas.",
                                    "Registrar dados em formato tabular (fatores como colunas independentes, respostas como dependentes).",
                                    "Verificar consistência das simulações (warm-up, steady-state).",
                                    "Salvar dados brutos para análise posterior."
                                  ],
                                  "verification": "Executar todas as runs e fornecer dataset completo com pelo menos 3 replicatas por run.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Software de simulação: Arena, Simul8 ou Python (SimPy/SimJulia)",
                                    "Planilhas para logging de dados"
                                  ],
                                  "tips": "Automatize execuções com scripts para eficiência em múltiplas runs.",
                                  "learningObjective": "Executar simulações controladas por design multivariado de forma precisa.",
                                  "commonMistakes": [
                                    "Não usar período de warm-up, poluindo dados iniciais",
                                    "Erros de implementação no modelo afetando todas runs",
                                    "Falta de replicatas levando a alta variância"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar Resultados e Quantificar Contribuições",
                                  "subSteps": [
                                    "Realizar ANOVA ou regressão para testar significância de fatores e interações.",
                                    "Calcular contribuições relativas (percentual de variância explicada por cada fator).",
                                    "Visualizar resultados com gráficos de interação e superfícies de resposta.",
                                    "Interpretar efeitos principais e interações no contexto da simulação.",
                                    "Gerar relatório com recomendações para otimização."
                                  ],
                                  "verification": "Produzir relatório com ANOVA table, gráficos e ranking de contribuições relativas.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "R com pacotes ggplot2, car; Python com statsmodels, seaborn",
                                    "Templates de relatório em LaTeX ou Word"
                                  ],
                                  "tips": "Use half-normal plots para screening inicial de efeitos significativos.",
                                  "learningObjective": "Interpretar análises multivariadas para quantificar impactos em simulações discretas.",
                                  "commonMistakes": [
                                    "Interpretar p-valores sem contexto prático",
                                    "Ignorar interações ao focar só em main effects",
                                    "Gráficos mal escalados distorcendo percepções"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado (evento discreto), use DOE 2^3 fracionário para variar 3 fatores: número de caixas (2-4), tempo médio de empacotamento (1-3 min) e taxa de chegada (alta/baixa). Analise interações no tempo médio de espera, identificando que caixas extras só beneficiam em alta chegada.",
                              "finalVerifications": [
                                "Implementa corretamente um DOE com pelo menos 3 fatores e detecta interações.",
                                "Gera matriz de experimentos randomizada e executa simulações com replicatas.",
                                "Realiza ANOVA e quantifica contribuições relativas com precisão (>80% variância explicada).",
                                "Interpreta resultados com gráficos claros de interações.",
                                "Aplica achados para otimizar o modelo de simulação.",
                                "Documenta todo processo em relatório reproduzível."
                              ],
                              "assessmentCriteria": [
                                "Precisão na seleção e planejamento do DOE (resolução adequada, runs viáveis).",
                                "Qualidade da execução de simulações (consistência, warm-up correto).",
                                "Correção estatística na análise (ANOVA/regressão sem erros).",
                                "Profundidade na interpretação de interações e contribuições relativas.",
                                "Clareza visual e relatório (gráficos profissionais, conclusões acionáveis).",
                                "Eficiência temporal e uso otimizado de recursos computacionais."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: ANOVA e modelagem regressiva.",
                                "Programação Computacional: Scripts em R/Python para automação de DOE.",
                                "Engenharia Industrial: Otimização de sistemas de filas e processos.",
                                "Ciência de Dados: Visualização e análise exploratória multivariada.",
                                "Matemática Aplicada: Modelos estocásticos em eventos discretos."
                              ],
                              "realWorldApplication": "Otimização de linhas de produção em indústrias manufatureiras, análise de sensibilidade em simulações logísticas para supply chain, avaliação de riscos em modelagens financeiras discretas e melhoria de desempenho em centros de call center ou hospitais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.1.2"
                            ]
                          },
                          {
                            "id": "10.1.5.5.2.3",
                            "name": "Empregar Técnicas de Amostragem",
                            "description": "Aplicar métodos de amostragem como Monte Carlo ou Latin Hypercube para análise global de sensibilidade, gerando distribuições de parâmetros e analisando variâncias nas saídas do modelo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos das Técnicas de Amostragem",
                                  "subSteps": [
                                    "Estude o método Monte Carlo: geração de amostras aleatórias independentes de distribuições de parâmetros.",
                                    "Analise o Latin Hypercube Sampling (LHS): divisão estratificada do espaço de parâmetros para cobertura uniforme.",
                                    "Compare vantagens: Monte Carlo para simplicidade, LHS para eficiência em dimensões altas.",
                                    "Revise conceitos de análise global de sensibilidade: foco em variâncias totais das saídas.",
                                    "Leia exemplos em simulações discretas, como filas ou redes."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras explicando diferenças e aplicações de Monte Carlo e LHS.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Documentação SALib (Python)",
                                    "Tutorial 'Sensitivity Analysis' em SciPy",
                                    "Vídeo introdutório sobre Monte Carlo no YouTube"
                                  ],
                                  "tips": "Use diagramas para visualizar a cobertura de amostras no espaço paramétrico.",
                                  "learningObjective": "Dominar conceitos teóricos para seleção adequada de técnica.",
                                  "commonMistakes": [
                                    "Ignorar correlações entre parâmetros",
                                    "Confundir amostragem local com global"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Distribuições de Parâmetros do Modelo",
                                  "subSteps": [
                                    "Identifique parâmetros incertos no modelo de simulação discreta (ex: tempo de chegada, serviço).",
                                    "Escolha distribuições apropriadas: normal, uniforme, log-normal baseadas em dados reais.",
                                    "Defina estatísticas: média, desvio padrão, limites para cada parâmetro.",
                                    "Crie um arquivo de configuração com dicionário de distribuições (ex: em JSON ou Python dict).",
                                    "Valide distribuições com histogramas e testes de plausibilidade."
                                  ],
                                  "verification": "Gere um relatório com distribuições definidas e justifique escolhas para 5 parâmetros.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Biblioteca NumPy/SciPy para distribuições",
                                    "Exemplo de modelo de fila M/M/1",
                                    "Ferramenta Draw.io para diagramas"
                                  ],
                                  "tips": "Baseie-se em literatura ou dados empíricos para realismo nas distribuições.",
                                  "learningObjective": "Configurar inputs probabilísticos realistas para análise.",
                                  "commonMistakes": [
                                    "Usar distribuições uniformes sem justificativa",
                                    "Definir variâncias muito pequenas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Geração de Amostras e Execução de Simulações",
                                  "subSteps": [
                                    "Instale bibliotecas: SALib para LHS e Monte Carlo.",
                                    "Gere amostras: 1000-5000 para Monte Carlo, equivalente para LHS.",
                                    "Integre amostras ao modelo: loop para executar simulações com cada conjunto.",
                                    "Colete saídas: vetor de resultados (ex: tempo médio de espera).",
                                    "Monitore tempo de computação e otimize se necessário (paralelização)."
                                  ],
                                  "verification": "Execute e salve um arquivo com 1000 amostras geradas e saídas correspondentes.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Python com SALib, NumPy",
                                    "Código modelo de simulação discreta (ex: SimPy)",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Comece com poucas amostras (100) para depuração rápida.",
                                  "learningObjective": "Gerar e processar amostras de forma eficiente.",
                                  "commonMistakes": [
                                    "Gerar amostras correlacionadas acidentalmente",
                                    "Sobrecarregar memória com simulações grandes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Variâncias e Realizar Análise de Sensibilidade",
                                  "subSteps": [
                                    "Calcule estatísticas: média, variância das saídas por parâmetro.",
                                    "Aplique índices de Sobol: decomposição de variância total.",
                                    "Gere gráficos: tornado plot, correlações paramétricas.",
                                    "Interprete resultados: identifique parâmetros mais influentes.",
                                    "Valide com reamostragem para confiança nos índices."
                                  ],
                                  "verification": "Produza um gráfico de sensibilidade e relatório com top 3 parâmetros sensíveis.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "SALib para análise Sobol",
                                    "Matplotlib/Seaborn para plots",
                                    "Documentação SALib analyze"
                                  ],
                                  "tips": "Use saltos de amostragem para estimativas de Sobol rápidas.",
                                  "learningObjective": "Extrair insights acionáveis da análise de variância.",
                                  "commonMistakes": [
                                    "Interpretar correlação como causalidade",
                                    "Ignorar interações entre parâmetros"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um modelo de simulação de fila de call center (usando SimPy), defina parâmetros como taxa de chegada (Poisson) e tempo de atendimento (exponencial). Gere 2000 amostras LHS, execute simulações e analise como variância na taxa de chegada afeta o tempo médio de espera, identificando-a como o parâmetro mais sensível.",
                              "finalVerifications": [
                                "Gerar corretamente amostras Monte Carlo e LHS para 5 parâmetros.",
                                "Executar pelo menos 1000 simulações sem erros.",
                                "Calcular e plotar índices de sensibilidade (Sobol primeiro ordem).",
                                "Identificar e justificar os 2 parâmetros mais influentes.",
                                "Validar resultados com reamostragem (erro <10%).",
                                "Documentar todo processo em um notebook reproduzível."
                              ],
                              "assessmentCriteria": [
                                "Precisão na geração de amostras (cobertura uniforme no espaço).",
                                "Correta implementação de simulações e coleta de saídas.",
                                "Qualidade da análise de variância (índices Sobol precisos).",
                                "Interpretação clara e fundamentada dos resultados.",
                                "Eficiência computacional (tempo razoável para N amostras).",
                                "Uso adequado de visualizações e relatórios."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Decomposição de variância e índices de Sobol.",
                                "Programação: Bibliotecas Python (SALib, SimPy, NumPy).",
                                "Probabilidade: Modelagem de distribuições e simulações estocásticas.",
                                "Engenharia de Software: Código modular e reproduzível.",
                                "Ciência de Dados: Visualização e análise exploratória."
                              ],
                              "realWorldApplication": "Em otimização de cadeias de suprimentos, empregar LHS para analisar sensibilidade de parâmetros incertos (demanda, lead time) em modelos de simulação, permitindo priorizar reduções de variabilidade e melhorar eficiência operacional em indústrias como manufatura ou logística."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.2.1"
                            ]
                          },
                          {
                            "id": "10.1.5.5.2.4",
                            "name": "Configurar Experimentos em Software",
                            "description": "Configurar experimentos de sensibilidade em linguagens de simulação como Arena ou Simio, definindo faixas de variação paramétrica e rodando réplicas para coletar dados estatísticos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o Modelo Base no Software de Simulação",
                                  "subSteps": [
                                    "Abra o software Arena ou Simio e crie um novo projeto.",
                                    "Construa ou importe o modelo base discreto-eventos representando o sistema (ex: fila de chegada-serviço).",
                                    "Defina as variáveis iniciais fixas e configure o tempo de simulação (ex: 1000 horas).",
                                    "Execute uma simulação de teste única para validar o modelo base.",
                                    "Salve o modelo como baseline."
                                  ],
                                  "verification": "Modelo executa sem erros e produz saídas estatísticas básicas consistentes (ex: tempo médio na fila).",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Licença ou trial do Arena/Simio",
                                    "Documentação do software",
                                    "Especificações do sistema a simular"
                                  ],
                                  "tips": "Use templates prontos do software para acelerar a construção inicial.",
                                  "learningObjective": "Dominar a setup inicial de um modelo de simulação discreta para servir de base à análise de sensibilidade.",
                                  "commonMistakes": [
                                    "Ignorar validação inicial do modelo base",
                                    "Definir tempo de simulação muito curto",
                                    "Não salvar versões intermediárias"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Parametrizar Variáveis de Sensibilidade",
                                  "subSteps": [
                                    "Liste variáveis chave do modelo (ex: taxa de chegada, tempo de serviço).",
                                    "Converta variáveis fixas em parâmetros editáveis no software.",
                                    "Defina valores nominais (padrão) para cada parâmetro.",
                                    "Documente o impacto esperado de cada variável na métrica de performance (ex: throughput).",
                                    "Teste alterações manuais em um parâmetro para confirmar parametrização."
                                  ],
                                  "verification": "Parâmetros podem ser alterados dinamicamente sem quebrar o modelo, com mudanças refletidas nas saídas.",
                                  "estimatedTime": "45 minutos - 1 hora",
                                  "materials": [
                                    "Modelo baseline salvo",
                                    "Planilha para rastrear parâmetros (Excel/Google Sheets)"
                                  ],
                                  "tips": "Priorize 3-5 parâmetros mais influentes baseados em conhecimento domínio.",
                                  "learningObjective": "Selecionar e preparar variáveis paramétricas para experimentos de sensibilidade.",
                                  "commonMistakes": [
                                    "Escolher variáveis irrelevantes",
                                    "Não definir valores nominais realistas",
                                    "Parametrizar incorretamente levando a erros de sintaxe"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Faixas de Variação Paramétrica e Cenários",
                                  "subSteps": [
                                    "Para cada parâmetro, defina faixa de variação (ex: ±20% do nominal, em 5 níveis).",
                                    "Crie cenários combinatórios ou fatoriais (ex: variação univariada ou bivariada).",
                                    "Configure no módulo de experimentos do software (Arena: Input Analyzer/Experiment; Simio: Experiments).",
                                    "Especifique métricas de saída a coletar (ex: média, variância, intervalos de confiança).",
                                    "Revise e salve a configuração de experimentos."
                                  ],
                                  "verification": "Lista de cenários gerada corretamente, com faixas e níveis visíveis na interface.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software com modelo parametrizado",
                                    "Guia de experimentos do Arena/Simio (PDF)"
                                  ],
                                  "tips": "Comece com variação univariada para simplicidade antes de multifatorial.",
                                  "learningObjective": "Estruturar experimentos de sensibilidade com faixas paramétricas sistemáticas.",
                                  "commonMistakes": [
                                    "Faixas muito amplas causando instabilidade",
                                    "Muitos cenários levando a tempo excessivo",
                                    "Esquecer métricas de saída"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Configurar Réplicas e Executar Experimentos para Coleta de Dados",
                                  "subSteps": [
                                    "Defina número de réplicas por cenário (ex: 10-30 para convergência estatística).",
                                    "Configure semente aleatória para reprodutibilidade ou randomize para robustez.",
                                    "Inicie a execução batch dos experimentos.",
                                    "Monitore progresso e interrompa se houver erros.",
                                    "Exporte dados brutos para análise (CSV ou relatórios nativos)."
                                  ],
                                  "verification": "Todos cenários executados com réplicas completas; dados exportados sem missing values.",
                                  "estimatedTime": "2-4 horas (depende da complexidade)",
                                  "materials": [
                                    "Computador com bom desempenho",
                                    "Espaço em disco para outputs"
                                  ],
                                  "tips": "Execute em batch overnight se o modelo for computacionalmente intensivo.",
                                  "learningObjective": "Executar simulações replicadas para gerar dados estatísticos confiáveis em sensibilidade.",
                                  "commonMistakes": [
                                    "Poucas réplicas causando variância alta",
                                    "Semente fixa levando a resultados enviesados",
                                    "Não monitorar execução"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um modelo de fila de supermercado no Arena: varie o número de caixas (2-6) e taxa de chegada (nominal 10/min ±20%), rode 20 réplicas por cenário, colete tempo médio na fila para análise de sensibilidade.",
                              "finalVerifications": [
                                "Modelo base validado executa sem erros.",
                                "Parâmetros variam corretamente em faixas definidas.",
                                "Réplicas geram dados com intervalos de confiança convergentes.",
                                "Dados exportados incluem métricas estatísticas por cenário.",
                                "Resultados iniciais mostram sensibilidade (ex: gráfico tornado plot).",
                                "Configuração reproduzível em nova execução."
                              ],
                              "assessmentCriteria": [
                                "Precisão na parametrização e faixas (sem erros lógicos).",
                                "Número adequado de réplicas para precisão estatística (>90% convergência).",
                                "Coleta completa de métricas relevantes.",
                                "Eficiência computacional (tempo razoável por experimento).",
                                "Documentação clara dos cenários e outputs.",
                                "Interpretação inicial de sensibilidade coerente."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Análise de variância e intervalos de confiança.",
                                "Programação: Scripts para automação de experimentos (VB/AnyLogic).",
                                "Matemática Aplicada: Otimização paramétrica e design de experimentos.",
                                "Engenharia de Sistemas: Validação de modelos em manufatura/logística."
                              ],
                              "realWorldApplication": "Em logística, configurar experimentos em Simio para testar sensibilidade de throughput de armazéns a variações em velocidades de empilhadeiras, otimizando layouts reais e reduzindo custos operacionais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.5.3",
                        "name": "Interpretação de Resultados e Aplicação na Validação",
                        "description": "Analisar os resultados da análise de sensibilidade para interpretar impactos nas saídas do modelo e integrá-los ao processo de validação, confirmando a adequação do modelo ao sistema real.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.3.1",
                            "name": "Interpretar Gráficos de Sensibilidade",
                            "description": "Analisar gráficos de tornado, correlações ou índices de Sobol' para identificar parâmetros mais influentes, avaliando se variações causam desvios inaceitáveis nas métricas de performance da simulação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Tipos de Gráficos de Sensibilidade",
                                  "subSteps": [
                                    "Estude a definição e propósito de gráficos de tornado, matrizes de correlação e índices de Sobol'.",
                                    "Identifique características visuais únicas de cada tipo: barras horizontais em tornado, mapa de calor em correlações, barras de primeira e total ordem em Sobol'.",
                                    "Revise exemplos simples de literatura ou tutoriais para cada gráfico.",
                                    "Anote diferenças entre análise local (one-at-a-time) e global (Sobol').",
                                    "Pratique reconhecendo o tipo de gráfico em imagens de amostra."
                                  ],
                                  "verification": "Liste corretamente as características de pelo menos dois tipos de gráficos com 90% de precisão em um quiz autoavaliado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Tutoriais online sobre análise de sensibilidade (ex: Saltelli et al.), imagens de gráficos de exemplo, caderno de anotações"
                                  ],
                                  "tips": "Comece com gráficos de tornado, pois são os mais intuitivos para iniciantes.",
                                  "learningObjective": "Diferenciar e descrever os principais tipos de gráficos de sensibilidade usados em análise.",
                                  "commonMistakes": [
                                    "Confundir índices de Sobol' de primeira ordem com ordem total",
                                    "Ignorar a direção da sensibilidade em gráficos de tornado"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Parâmetros Mais Influentes",
                                  "subSteps": [
                                    "Examine o eixo das barras ou cores para ordenar parâmetros por magnitude de impacto.",
                                    "Compare comprimentos de barras em tornado ou valores absolutos em Sobol' para ranquear influência.",
                                    "Note parâmetros com impacto nulo ou mínimo (próximo de zero).",
                                    "Registre os top 3-5 parâmetros influentes com seus valores quantitativos.",
                                    "Valide a consistência entre diferentes gráficos (ex: correlação alta deve alinhar com Sobol' alto)."
                                  ],
                                  "verification": "Extraia e ranqueie corretamente os top 3 parâmetros de um gráfico fornecido, justificando com valores numéricos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Gráficos de sensibilidade de exemplo de simulações discretas, software como Python (Matplotlib/Seaborn) ou Excel para visualização"
                                  ],
                                  "tips": "Sempre considere valores absolutos para ignorar direção e focar em magnitude.",
                                  "learningObjective": "Extrair e ranquear parâmetros por influência a partir de gráficos de sensibilidade.",
                                  "commonMistakes": [
                                    "Focar apenas no maior parâmetro, ignorando interações",
                                    "Não usar escala logarítmica quando apropriado"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar Impacto de Variações nas Métricas de Performance",
                                  "subSteps": [
                                    "Defina thresholds aceitáveis para desvios nas métricas (ex: <10% variação em tempo médio de espera).",
                                    "Calcule ou estime desvios causados por variações nos parâmetros influentes.",
                                    "Compare desvios observados com thresholds para classificar como 'aceitável' ou 'inaceitável'.",
                                    "Analise interações: verifique se efeitos combinados amplificam desvios.",
                                    "Documente cenários onde variações levam a falhas na validação do modelo."
                                  ],
                                  "verification": "Classifique desvios de 3 parâmetros como aceitáveis/inaceitáveis com justificativa baseada em thresholds.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Dados de simulação de exemplo (ex: modelo de fila M/M/1), calculadora ou planilha Excel"
                                  ],
                                  "tips": "Use percentuais relativos para métricas normalizadas, facilitando comparações.",
                                  "learningObjective": "Avaliar se variações paramétricas causam desvios inaceitáveis nas métricas de simulação.",
                                  "commonMistakes": [
                                    "Definir thresholds subjetivos sem base no contexto da simulação",
                                    "Ignorar variância total vs. média"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Interpretação na Validação do Modelo",
                                  "subSteps": [
                                    "Integre achados à validação: priorize calibração de parâmetros influentes.",
                                    "Recomende reduções de incerteza ou fixação de parâmetros não influentes.",
                                    "Simule cenários de pior caso baseados em parâmetros sensíveis.",
                                    "Atualize relatório de validação com insights de sensibilidade.",
                                    "Planeje iterações futuras de análise se desvios persistirem."
                                  ],
                                  "verification": "Gere um relatório curto (1 página) recomendando ações de validação baseadas na análise.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Template de relatório de validação, software de simulação (ex: SimPy para discretos)"
                                  ],
                                  "tips": "Sempre ligue sensibilidade de volta ao objetivo da simulação (ex: precisão preditiva).",
                                  "learningObjective": "Usar insights de gráficos de sensibilidade para melhorar e validar modelos de simulação.",
                                  "commonMistakes": [
                                    "Não conectar análise a ações concretas",
                                    "Sobrestimar influência sem contexto de variância de entrada"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado (M/M/c), um gráfico de tornado mostra que 'taxa de chegada' tem o maior impacto no tempo de espera médio (desvio de 25% para variação de 20%). Identifique-o como prioritário, avalie se excede threshold de 15%, e recomende medições mais precisas de chegadas reais para validar o modelo.",
                              "finalVerifications": [
                                "Lista correta dos top 3 parâmetros influentes com valores.",
                                "Classificação precisa de desvios como aceitáveis/inaceitáveis.",
                                "Recomendações acionáveis para validação do modelo.",
                                "Identificação de pelo menos uma interação paramétrica.",
                                "Relatório coeso integrando análise aos objetivos da simulação.",
                                "Consistência entre múltiplos tipos de gráficos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de parâmetros influentes (90%+ acurácia).",
                                "Justificativa quantitativa para avaliações de impacto.",
                                "Uso correto de thresholds contextualizados.",
                                "Profundidade na análise de interações e não-linearidades.",
                                "Clareza e estrutura no relatório final.",
                                "Aplicação prática às decisões de validação."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Interpretação de índices de variância (Sobol').",
                                "Programação: Geração de gráficos com Python/R.",
                                "Engenharia de Sistemas: Validação de modelos preditivos.",
                                "Gestão de Riscos: Análise de incertezas em simulações.",
                                "Visualização de Dados: Design de gráficos informativos."
                              ],
                              "realWorldApplication": "Em engenharia de tráfego, interpretar gráficos de sensibilidade em simulações de redes de sinalização para priorizar calibração de tempos de ciclo, evitando congestionamentos inaceitáveis e otimizando investimentos em infraestrutura."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.2.1"
                            ]
                          },
                          {
                            "id": "10.1.5.5.3.2",
                            "name": "Avaliar Robustez do Modelo",
                            "description": "Determinar a robustez do modelo com base nos resultados de sensibilidade, decidindo se o modelo é preciso e confiável para o sistema discreto real, considerando tolerâncias de variação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar e Organizar Resultados de Análise de Sensibilidade",
                                  "subSteps": [
                                    "Compilar todos os dados de sensibilidade de variáveis chave (ex: parâmetros de entrada como taxas de chegada em sistemas de fila).",
                                    "Visualizar os resultados usando gráficos de tornado ou heatmaps para identificar variações críticas.",
                                    "Calcular estatísticas descritivas: média, desvio padrão e intervalos de confiança para cada variação.",
                                    "Identificar variáveis com maior impacto na saída do modelo.",
                                    "Documentar observações iniciais em uma tabela comparativa."
                                  ],
                                  "verification": "Verificar se gráficos e tabelas mostram claramente as variações e impactos sem erros de escala ou rótulos.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Dados de sensibilidade (CSV ou Excel)",
                                    "Software como Python (Matplotlib/Seaborn) ou MATLAB",
                                    "Planilha para tabelas"
                                  ],
                                  "tips": "Use log-escala para variações extremas para melhor visualização.",
                                  "learningObjective": "Compreender e organizar dados de sensibilidade para análise subsequente.",
                                  "commonMistakes": [
                                    "Ignorar variações não lineares",
                                    "Não normalizar unidades de diferentes variáveis",
                                    "Sobrepor gráficos sem legendas claras"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Critérios de Tolerância e Thresholds de Robustez",
                                  "subSteps": [
                                    "Consultar especificações do sistema real discreto para definir tolerâncias aceitáveis (ex: erro <5% na saída).",
                                    "Estabelecer thresholds quantitativos baseados em requisitos: ex: variação <10% em 95% dos cenários.",
                                    "Classificar robustez em níveis: alta (variação <5%), média (5-15%), baixa (>15%).",
                                    "Validar thresholds com literatura ou benchmarks de simulações semelhantes.",
                                    "Registrar justificativas para cada threshold escolhido."
                                  ],
                                  "verification": "Checklist confirmando que todos thresholds têm base documentada e são realistas para o contexto.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação do sistema real",
                                    "Referências acadêmicas sobre validação de modelos",
                                    "Ferramenta de edição de texto"
                                  ],
                                  "tips": "Alinhe thresholds com objetivos de negócio ou precisão requerida no mundo real.",
                                  "learningObjective": "Estabelecer métricas objetivas para julgar robustez do modelo.",
                                  "commonMistakes": [
                                    "Definir thresholds muito rígidos sem justificativa",
                                    "Ignorar interdependências entre variáveis",
                                    "Usar valores arbitrários sem referência"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Impacto das Variações e Quantificar Robustez",
                                  "subSteps": [
                                    "Comparar variações observadas nos resultados de sensibilidade com os thresholds definidos.",
                                    "Calcular índices de robustez: ex: coeficiente de variação (CV = desvio/média) para cada parâmetro.",
                                    "Simular cenários extremos (Monte Carlo) para testar estabilidade global.",
                                    "Identificar pontos fracos do modelo e propor ajustes se necessário.",
                                    "Gerar relatório com métricas agregadas (ex: % de parâmetros robustos)."
                                  ],
                                  "verification": "Relatório com cálculos validados (ex: rodar script e conferir outputs numéricos).",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Software de simulação (Python com NumPy/SciPy)",
                                    "Dados de sensibilidade",
                                    "Templates de relatório"
                                  ],
                                  "tips": "Automatize cálculos com scripts para evitar erros manuais.",
                                  "learningObjective": "Quantificar matematicamente a robustez e identificar vulnerabilidades.",
                                  "commonMistakes": [
                                    "Confundir sensibilidade local com global",
                                    "Não testar cenários extremos",
                                    "Erros em cálculos de CV por divisão por zero"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Resultados e Decidir Confiabilidade do Modelo",
                                  "subSteps": [
                                    "Avaliar se o modelo atende aos critérios de robustez geral (>80% robusto).",
                                    "Decidir: aprovar, rejeitar ou recomendar refinamentos (ex: recalibrar parâmetros sensíveis).",
                                    "Discutir implicações para o sistema discreto real (ex: confiável para previsão de filas?).",
                                    "Preparar recomendação final com evidências quantitativas.",
                                    "Compartilhar achados em formato acessível (resumo executivo)."
                                  ],
                                  "verification": "Decisão final justificada com evidências e aprovada por peer-review simulado.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Relatórios dos steps anteriores",
                                    "Ferramenta de apresentação (PowerPoint ou Markdown)"
                                  ],
                                  "tips": "Considere custo-benefício de refinamentos antes de rejeitar o modelo.",
                                  "learningObjective": "Tomar decisões informadas sobre confiabilidade baseada em análise quantitativa.",
                                  "commonMistakes": [
                                    "Decisões subjetivas sem dados",
                                    "Subestimar riscos de falsos positivos",
                                    "Não considerar contexto do sistema real"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de sistema de filas de um call center discreto, analise sensibilidade à taxa de abandono de chamadas (20-30%). Se variação causar <3% de erro no tempo médio de espera real, classifique como robusto e aprove para escalonamento de agentes.",
                              "finalVerifications": [
                                "Relatório completo com gráficos, métricas e decisão final.",
                                "Thresholds documentados e justificados.",
                                "Cálculos de robustez validados numericamente.",
                                "Identificação de pelo menos 2 pontos fracos potenciais.",
                                "Recomendação clara: aprovar/rejeitar/refinar com razões.",
                                "Simulação de peer-review sem inconsistências."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos cálculos de sensibilidade e robustez (90%+ acurácia).",
                                "Justificativa robusta de thresholds (baseada em evidências).",
                                "Qualidade visual e clareza dos gráficos/tabelas.",
                                "Profundidade da análise de impactos e cenários extremos.",
                                "Decisão final lógica e alinhada com dados.",
                                "Documentação completa e profissional."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Uso de intervalos de confiança e testes de sensibilidade.",
                                "Programação: Implementação em Python/MATLAB para automação.",
                                "Engenharia de Sistemas: Validação em contextos industriais reais.",
                                "Gestão de Riscos: Avaliação de incertezas em decisões.",
                                "Ciência de Dados: Técnicas de Monte Carlo para robustez."
                              ],
                              "realWorldApplication": "Em indústrias como logística (simulação de supply chains discretas) ou saúde (modelos de fluxo de pacientes), avaliar robustez garante que previsões sejam confiáveis para otimizar operações, evitando custos de decisões erradas baseadas em modelos frágeis."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.2.3"
                            ]
                          },
                          {
                            "id": "10.1.5.5.3.3",
                            "name": "Integrar na Validação Geral",
                            "description": "Incorporar resultados da análise de sensibilidade ao fluxo de validação de modelos, ajustando parâmetros sensíveis e documentando evidências de precisão para relatórios de simulação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar e Interpretar Resultados da Análise de Sensibilidade",
                                  "subSteps": [
                                    "Mapear todos os parâmetros analisados e seus índices de sensibilidade.",
                                    "Quantificar o impacto de cada parâmetro nas saídas do modelo (ex: variação percentual).",
                                    "Identificar parâmetros críticos (alta sensibilidade) e thresholds de tolerância.",
                                    "Visualizar resultados com gráficos de tornado ou scatter plots.",
                                    "Priorizar parâmetros para ajuste com base no impacto na precisão geral."
                                  ],
                                  "verification": "Relatório preliminar com lista de parâmetros sensíveis e impactos quantificados.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Resultados da análise de sensibilidade (planilhas ou scripts Python/R)",
                                    "Ferramentas de visualização (Matplotlib, Excel, Tableau)"
                                  ],
                                  "tips": "Use gráficos para facilitar a interpretação visual e priorize parâmetros com sensibilidade > 10%.",
                                  "learningObjective": "Interpretar quantitativamente os resultados da análise de sensibilidade para identificar ajustes necessários.",
                                  "commonMistakes": [
                                    "Ignorar parâmetros com sensibilidade média que acumulam erros",
                                    "Não considerar interações entre parâmetros sensíveis"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Ajustar Parâmetros Sensíveis no Modelo",
                                  "subSteps": [
                                    "Selecionar valores ajustados para parâmetros sensíveis baseados em dados empíricos ou otimização.",
                                    "Implementar ajustes no código ou configuração do modelo de simulação.",
                                    "Executar simulações preliminares para testar estabilidade dos ajustes.",
                                    "Comparar saídas ajustadas com as originais para validar melhorias.",
                                    "Registrar rationale para cada ajuste realizado."
                                  ],
                                  "verification": "Versão atualizada do modelo com parâmetros ajustados e log de mudanças.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código fonte do modelo (Python, MATLAB ou Simulink)",
                                    "Dados de referência empíricos",
                                    "Ferramentas de otimização (SciPy, Solver)"
                                  ],
                                  "tips": "Ajuste incrementalmente um parâmetro por vez para isolar efeitos.",
                                  "learningObjective": "Aplicar ajustes precisos em parâmetros sensíveis para melhorar a robustez do modelo.",
                                  "commonMistakes": [
                                    "Ajustes excessivos que criam overfitting",
                                    "Não testar estabilidade após múltiplos ajustes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporar Ajustes ao Fluxo de Validação Geral",
                                  "subSteps": [
                                    "Integrar o modelo ajustado ao pipeline completo de validação (ex: testes de precisão, cruzados).",
                                    "Executar validação end-to-end incluindo métricas como RMSE, MAE e cobertura de confiança.",
                                    "Comparar métricas antes e depois dos ajustes para evidenciar melhorias.",
                                    "Identificar e corrigir discrepâncias remanescentes no fluxo.",
                                    "Automatizar o processo de integração via scripts se possível."
                                  ],
                                  "verification": "Relatório de validação geral mostrando métricas melhoradas pós-ajuste.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Pipeline de validação (scripts Jupyter ou workflows GitHub Actions)",
                                    "Dados de validação reais ou sintéticos"
                                  ],
                                  "tips": "Use métricas compostas para validar holisticamente o impacto.",
                                  "learningObjective": "Integrar ajustes de sensibilidade ao fluxo de validação para garantir precisão global.",
                                  "commonMistakes": [
                                    "Pular validação cruzada após ajustes",
                                    "Não comparar com baseline original"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Documentar Evidências e Gerar Relatório de Simulação",
                                  "subSteps": [
                                    "Compilar resultados: sensibilidade, ajustes, métricas de validação.",
                                    "Incluir gráficos, tabelas e evidências de precisão (ex: intervalos de confiança).",
                                    "Escrever seções de rationale, limitações e recomendações.",
                                    "Revisar relatório por clareza e conformidade com padrões (ex: IEEE).",
                                    "Compartilhar relatório via repositório ou ferramenta colaborativa."
                                  ],
                                  "verification": "Relatório final completo e aprovado por revisão.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Templates de relatório (LaTeX, Markdown, Word)",
                                    "Ferramentas de edição (Overleaf, Google Docs)"
                                  ],
                                  "tips": "Use seções padronizadas: Introdução, Métodos, Resultados, Conclusão.",
                                  "learningObjective": "Documentar de forma profissional evidências para suporte a decisões baseadas em simulações.",
                                  "commonMistakes": [
                                    "Omitir limitações dos ajustes",
                                    "Gráficos sem legendas ou escalas claras"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de sistema de filas para um call center (M/M/1), a análise de sensibilidade revela que o tempo de serviço (μ) tem alta sensibilidade no tempo médio de espera. Ajuste μ de 0.8 para 0.85 com base em dados reais, reintegre à validação geral (comparando simulação vs. logs reais), melhorando RMSE de 15% para 5%, e documente no relatório com gráficos de sensibilidade e métricas.",
                              "finalVerifications": [
                                "Parâmetros sensíveis foram ajustados e integrados com evidência de melhoria em métricas de precisão.",
                                "Fluxo de validação geral passa em todos os testes pós-integração.",
                                "Relatório inclui documentação completa de análises, ajustes e evidências.",
                                "Modelo ajustado é estável e reproduzível em simulações repetidas.",
                                "Limitações e recomendações estão explicitadas no relatório.",
                                "Melhoria quantificável na precisão global do modelo (ex: redução >10% em erro)."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude na identificação de parâmetros sensíveis (nota 1-5).",
                                "Adequação e impacto dos ajustes realizados (melhoria mensurável).",
                                "Integração seamless ao fluxo de validação sem quebrar outros componentes.",
                                "Qualidade da documentação: clareza, visualizações e evidências.",
                                "Robustez: testes de sensibilidade residual pós-ajuste.",
                                "Eficiência temporal: conclusão dentro do estimado com automação onde possível."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Uso de métricas como RMSE e análise de variância.",
                                "Programação Computacional: Implementação de ajustes em scripts de simulação.",
                                "Gestão de Projetos: Documentação técnica para relatórios e auditorias.",
                                "Engenharia de Software: Integração em pipelines CI/CD para validação.",
                                "Comunicação Científica: Redação de relatórios com visualizações profissionais."
                              ],
                              "realWorldApplication": "Em simulações epidemiológicas para previsão de surtos (ex: COVID-19), integrar análises de sensibilidade em parâmetros como taxa de transmissão para ajustar modelos e validar contra dados reais, gerando relatórios para políticas públicas de saúde."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.3.1"
                            ]
                          },
                          {
                            "id": "10.1.5.5.3.4",
                            "name": "Tratar Limitações e Erros",
                            "description": "Identificar limitações da análise de sensibilidade, como suposições lineares ou custos computacionais, e propor mitigações para melhorar a validação em simulações complexas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar Limitações Comuns na Análise de Sensibilidade",
                                  "subSteps": [
                                    "Revisar suposições lineares: analisar quando a linearidade não se aplica em sistemas discretos não-lineares.",
                                    "Avaliar custos computacionais: estimar tempo de execução para grids de parâmetros variados.",
                                    "Detectar limitações de dados: identificar viés, ruído ou escassez nos conjuntos de entrada.",
                                    "Reconhecer interdependências: mapear correlações entre parâmetros sensíveis.",
                                    "Documentar limitações contextuais: considerar escala temporal e espacial do modelo."
                                  ],
                                  "verification": "Lista completa de pelo menos 5 limitações identificadas, com justificativas baseadas no modelo.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação do modelo de simulação",
                                    "Código fonte da análise de sensibilidade",
                                    "Referências bibliográficas (ex: Saltelli et al.)"
                                  ],
                                  "tips": "Use matrizes de sensibilidade para visualizar limitações rapidamente.",
                                  "learningObjective": "Compreender e catalogar limitações teóricas e práticas da análise de sensibilidade em simulações discretas.",
                                  "commonMistakes": [
                                    "Ignorar correlações entre parâmetros",
                                    "Subestimar impactos em alta dimensionalidade",
                                    "Confundir limitações com erros numéricos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Avaliar Impacto das Limitações no Modelo Específico",
                                  "subSteps": [
                                    "Executar testes de sensibilidade direcionados: variar parâmetros um a um e observar desvios.",
                                    "Quantificar impactos: calcular métricas como variância explicada ou erro de predição.",
                                    "Simular cenários extremos: testar bordas do espaço paramétrico para expor fragilidades.",
                                    "Comparar com benchmarks: validar contra modelos analíticos ou dados reais quando disponíveis.",
                                    "Registrar métricas de impacto: usar gráficos de tornado ou índices de Sobol."
                                  ],
                                  "verification": "Relatório com gráficos mostrando impacto quantitativo de pelo menos 3 limitações principais.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software de simulação (ex: Python com NumPy/SciPy)",
                                    "Dados de validação do modelo",
                                    "Ferramentas de visualização (Matplotlib)"
                                  ],
                                  "tips": "Priorize limitações com maior variância na saída do modelo.",
                                  "learningObjective": "Avaliar quantitativamente como limitações afetam a robustez da validação do modelo.",
                                  "commonMistakes": [
                                    "Usar grids de parâmetros muito grosseiros",
                                    "Não normalizar variáveis para comparação justa",
                                    "Ignorar efeitos não-lineares em avaliações lineares"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Propor e Projetar Mitigações Específicas",
                                  "subSteps": [
                                    "Selecionar mitigações adequadas: para linearidade, usar métodos quasi-Monte Carlo; para custos, redução dimensional.",
                                    "Desenhar planos de mitigação: especificar algoritmos alternativos como análise global de sensibilidade.",
                                    "Estimar viabilidade: prever redução de erro e custo computacional das mitigações.",
                                    "Integrar validações cruzadas: propor uso de bootstrap ou ensembles para robustez.",
                                    "Priorizar por impacto: ranquear mitigações por custo-benefício."
                                  ],
                                  "verification": "Lista de 4-6 mitigações propostas, com justificativa, algoritmo sugerido e estimativa de melhoria.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Literatura avançada (ex: livros de Saltelli ou Razavi)",
                                    "Ferramentas de otimização (ex: SALib em Python)"
                                  ],
                                  "tips": "Combine mitigações locais e globais para cobertura ampla.",
                                  "learningObjective": "Desenvolver estratégias personalizadas de mitigação para limitações identificadas.",
                                  "commonMistakes": [
                                    "Propor soluções genéricas sem adaptação ao modelo",
                                    "Superestimar eficácia sem testes prévios",
                                    "Ignorar trade-offs entre precisão e custo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar, Testar e Documentar Mitigações",
                                  "subSteps": [
                                    "Codificar mitigações: integrar métodos propostos no pipeline de simulação.",
                                    "Executar testes comparativos: medir antes/depois em métricas de sensibilidade.",
                                    "Validar melhorias: confirmar redução de erros e limitações remanescentes.",
                                    "Documentar processo: criar relatório com código, resultados e lições aprendidas.",
                                    "Iterar se necessário: refinar com base em resultados iniciais."
                                  ],
                                  "verification": "Relatório final com código funcional, gráficos comparativos e evidência de melhoria em pelo menos 70% das limitações.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Ambiente de programação (Jupyter Notebook)",
                                    "Repositório Git para versionamento",
                                    "Templates de relatório"
                                  ],
                                  "tips": "Use versionamento para comparar iterações facilmente.",
                                  "learningObjective": "Aplicar mitigações na prática e validar sua efetividade em simulações complexas.",
                                  "commonMistakes": [
                                    "Não testar em escala real",
                                    "Omitir documentação de falhas parciais",
                                    "Parar após primeira implementação sem iteração"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de sistema de filas M/M/c com chegada não-estacionária, identificar limitação de suposição linear nos tempos de serviço (erro de 25% em picos), mitigar com análise de sensibilidade global via método de Sobol, reduzindo custo computacional em 40% via amostragem latina hiperbólica e validando com dados reais de call centers.",
                              "finalVerifications": [
                                "Lista fluentemente 5 limitações comuns sem consulta.",
                                "Avalia impacto com métricas precisas (ex: S1 Sobol > 0.1).",
                                "Propõe mitigações viáveis para 80% das limitações.",
                                "Implementa e testa com melhoria mensurável (>20% redução de erro).",
                                "Documenta processo completo e reproduzível.",
                                "Explica trade-offs em cenários complexos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação: 90% das limitações corretas e relevantes.",
                                "Quantificação de impacto: uso de métricas estatísticas adequadas.",
                                "Criatividade e viabilidade das mitigações: alinhadas ao contexto.",
                                "Efetividade da implementação: redução comprovada de limitações.",
                                "Qualidade da documentação: clara, reproduzível e abrangente.",
                                "Profundidade de análise: considera interações paramétricas."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Uso de métodos bayesianos para quantificar incertezas.",
                                "Programação: Otimização de algoritmos e paralelização para custos computacionais.",
                                "Engenharia de Software: Testes unitários e validação em pipelines CI/CD.",
                                "Física/Engenharia: Aplicação em modelagem de sistemas dinâmicos reais.",
                                "Gestão de Projetos: Avaliação de risco e priorização de mitigações."
                              ],
                              "realWorldApplication": "Em simulações financeiras para risco de portfólio, tratar limitações de sensibilidade a volatilidade (suposições lineares falham em crashes), propondo mitigações como simulações Monte Carlo com copulas, melhorando validação para decisões de investimento em bancos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.6",
                "name": "Projeto e Planejamento de Experimentos de Simulação",
                "description": "Orienta sobre o design e planejamento de experimentos em simulações para obter resultados confiáveis.",
                "totalSkills": 46,
                "atomicTopics": [
                  {
                    "id": "10.1.6.1",
                    "name": "Seleção de Fatores e Níveis em Experimentos de Simulação",
                    "description": "Identificação das variáveis de entrada relevantes e definição de seus níveis para o design experimental.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.1.1",
                        "name": "Fatores em Experimentos de Simulação",
                        "description": "Compreensão dos fatores como variáveis de entrada controláveis que afetam o comportamento do modelo de simulação de sistemas discretos, diferenciando-os de variáveis aleatórias e parâmetros fixos.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.1.1",
                            "name": "Diferenciar fatores de outras variáveis de entrada",
                            "description": "Classificar variáveis em um modelo de simulação como fatores controláveis, variáveis aleatórias ou parâmetros fixos, com base em sua influência nas saídas e capacidade de manipulação experimental.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as definições dos tipos de variáveis de entrada",
                                  "subSteps": [
                                    "Ler e anotar as definições: fatores controláveis (manipuláveis experimentalmente), variáveis aleatórias (estocásticas, com distribuições probabilísticas) e parâmetros fixos (constantes não alteradas no experimento).",
                                    "Identificar características chave: influência nas saídas, capacidade de controle e variabilidade inerente.",
                                    "Criar um quadro comparativo com colunas para cada tipo e exemplos genéricos.",
                                    "Discutir com um colega ou em grupo as diferenças sutis entre os tipos.",
                                    "Revisar definições com base em referências bibliográficas sobre simulação."
                                  ],
                                  "verification": "Quadro comparativo completo e correto, com pelo menos um exemplo por tipo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta digital como Google Docs",
                                    "Referências: livro de simulação ou slides do módulo MC-37"
                                  ],
                                  "tips": "Use mnemônicos: 'Fator = Faço eu mudar', 'Aleatória = A sorte decide', 'Parâmetro = Pedra parada'.",
                                  "learningObjective": "Definir precisamente cada tipo de variável e suas distinções.",
                                  "commonMistakes": "Confundir variáveis aleatórias com fatores (pensar que aleatoriedade é controlável)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar estrutura de um modelo de simulação simples",
                                  "subSteps": [
                                    "Selecionar um modelo básico, como simulação de fila M/M/1 (fila única com chegadas e serviços Poisson).",
                                    "Listar todas as variáveis de entrada: λ (taxa de chegada), μ (taxa de serviço), número de servidores.",
                                    "Mapear como cada variável afeta as saídas (ex: tempo médio na fila, comprimento da fila).",
                                    "Questionar: 'Posso alterar isso no experimento? É estocástico? É fixo?'",
                                    "Desenhar um diagrama de fluxo do modelo destacando as variáveis."
                                  ],
                                  "verification": "Diagrama completo com variáveis listadas e influências nas saídas anotadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de simulação como Simul8 ou Python com SimPy",
                                    "Exemplo de código ou diagrama pronto"
                                  ],
                                  "tips": "Comece pelo diagrama: entradas → processo → saídas, para visualizar fluxos.",
                                  "learningObjective": "Identificar variáveis em um modelo e mapear sua influência nas saídas.",
                                  "commonMistakes": "Ignorar a variabilidade estocástica e tratar tudo como determinístico."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Classificar variáveis em um exemplo prático",
                                  "subSteps": [
                                    "Escolher exemplo: simulação de fila de supermercado com variáveis como número de caixas (controlável), tempo entre clientes (aleatório), tempo médio de checkout (parâmetro).",
                                    "Classificar cada variável: fator (caixas), aleatória (chegadas), parâmetro (checkout fixo).",
                                    "Justificar com base em manipulação experimental e impacto nas saídas (ex: tempo de espera).",
                                    "Executar simulações curtas alterando uma variável por vez para observar efeitos.",
                                    "Registrar classificações em uma tabela com justificativas."
                                  ],
                                  "verification": "Tabela de classificação com 100% de acerto no exemplo e simulações executadas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python ou Excel para simulação simples",
                                    "Dataset de exemplo ou gerador de números aleatórios"
                                  ],
                                  "tips": "Teste alterando: se muda o resultado sistematicamente e é controlável, é fator.",
                                  "learningObjective": "Aplicar classificações em um modelo concreto com justificativa.",
                                  "commonMistakes": "Classificar parâmetros como fatores por serem 'importantes'."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e refinar classificações em modelo complexo",
                                  "subSteps": [
                                    "Aplicar a um modelo mais complexo, como simulação de produção com múltiplas etapas.",
                                    "Revisar classificações iniciais com um peer review ou autoavaliação.",
                                    "Simular cenários: fixar parâmetros, variar fatores, incluir aleatoriedade.",
                                    "Ajustar classificações baseadas em resultados e discutir ambiguidades.",
                                    "Documentar lições aprendidas e regras gerais para diferenciação."
                                  ],
                                  "verification": "Relatório final com classificações validadas e simulações comparativas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software avançado como AnyLogic ou código Python customizado",
                                    "Modelo de simulação fornecido"
                                  ],
                                  "tips": "Use sensibilidade: variáveis com alta variância controlada são fatores.",
                                  "learningObjective": "Refinar classificações através de validação experimental.",
                                  "commonMistakes": "Sobrecarregar com muitas variáveis sem priorizar influência."
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de banco: 'Número de caixas' é fator controlável (pode-se variar de 1 a 5 para testar impacto no tempo de espera); 'Tempo entre chegadas de clientes' é variável aleatória (distribuição exponencial, não manipulável diretamente); 'Taxa de serviço por caixa' é parâmetro fixo (1 cliente/minuto, constante no experimento). Executar 10 réplicas varia saídas apenas pela aleatoriedade, confirmando classificações.",
                              "finalVerifications": [
                                "Classificar corretamente 95% das variáveis em um modelo dado.",
                                "Justificar cada classificação com evidência de influência e manipulabilidade.",
                                "Executar simulações alterando apenas fatores e observar mudanças consistentes.",
                                "Identificar ambiguidades e propor testes para resolução.",
                                "Criar quadro comparativo sem erros conceituais.",
                                "Aplicar em modelo não visto com acurácia mínima de 90%."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições e classificações (peso 30%).",
                                "Qualidade das justificativas baseadas em experimentos (peso 25%).",
                                "Uso correto de simulações para validação (peso 20%).",
                                "Identificação de erros comuns e correções (peso 15%).",
                                "Clareza na documentação e diagramas (peso 10%)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: compreensão de distribuições probabilísticas para variáveis aleatórias.",
                                "Programação: implementação de loops de simulação e geradores aleatórios.",
                                "Engenharia Industrial: design de experimentos fatoriais (DOE).",
                                "Física: modelagem de sistemas dinâmicos discretos."
                              ],
                              "realWorldApplication": "Em indústrias como manufatura ou logística, permite otimizar processos identificando fatores chave para experimentos (ex: variar turnos de máquinas em simulações de produção para reduzir gargalos, economizando custos reais de testes físicos)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.1.2",
                            "name": "Identificar fatores relevantes em sistemas discretos",
                            "description": "Analisar uma descrição de sistema discreto (ex.: filas, produção) para listar fatores como taxa de chegada, tempo de serviço ou número de servidores que impactam métricas de desempenho.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a descrição do sistema discreto",
                                  "subSteps": [
                                    "Leia atentamente a descrição do sistema, identificando o tipo (ex.: fila, linha de produção).",
                                    "Anote eventos discretos chave, como chegadas, serviços ou falhas.",
                                    "Desenhe um diagrama simples do fluxo do sistema (ex.: fluxograma).",
                                    "Liste os componentes principais (ex.: clientes, servidores, buffers).",
                                    "Defina o escopo temporal e espacial do sistema."
                                  ],
                                  "verification": "Diagrama e anotações completas que representam fielmente a descrição.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Descrição do sistema",
                                    "Papel e caneta ou software de diagramação como Draw.io"
                                  ],
                                  "tips": "Foque em eventos que mudam o estado do sistema, ignorando aspectos contínuos.",
                                  "learningObjective": "Entender a estrutura e dinâmica básica de um sistema discreto.",
                                  "commonMistakes": [
                                    "Confundir eventos discretos com processos contínuos",
                                    "Ignorar buffers ou filas intermediárias"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar métricas de desempenho principais",
                                  "subSteps": [
                                    "Liste métricas comuns para o tipo de sistema (ex.: tempo de espera em filas, taxa de utilização em produção).",
                                    "Relacione métricas à descrição, priorizando as mais impactadas.",
                                    "Classifique métricas por importância (alta, média, baixa).",
                                    "Pesquise definições padrão se necessário (ex.: Little's Law para filas).",
                                    "Documente como cada métrica é calculada."
                                  ],
                                  "verification": "Lista de 3-5 métricas com definições e classificações.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Referências de simulação discreta (livro ou online)",
                                    "Planilha para tabulação"
                                  ],
                                  "tips": "Pergunte: 'O que o sistema busca otimizar?' para guiar a seleção.",
                                  "learningObjective": "Reconhecer indicadores chave de performance em sistemas discretos.",
                                  "commonMistakes": [
                                    "Listar métricas irrelevantes ao sistema",
                                    "Confundir throughput com tempo de ciclo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Listar fatores potenciais que afetam as métricas",
                                  "subSteps": [
                                    "Brainstorm fatores de entrada: taxas (chegada, serviço), números (servidores), distribuições probabilísticas.",
                                    "Categorize fatores por tipo (estocásticos, determinísticos, controle).",
                                    "Mapeie cada fator para pelo menos uma métrica afetada.",
                                    "Inclua fatores ambientais (ex.: falhas, variações sazonais).",
                                    "Priorize por plausibilidade de impacto alto."
                                  ],
                                  "verification": "Tabela com 5-10 fatores mapeados a métricas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela em Excel ou Google Sheets",
                                    "Lista de fatores padrão para filas/produção"
                                  ],
                                  "tips": "Use analogias reais: 'O que varia em um supermercado lotado?'",
                                  "learningObjective": "Associar variáveis de entrada a saídas de performance.",
                                  "commonMistakes": [
                                    "Omitir fatores estocásticos",
                                    "Incluir fatores incontroláveis sem justificativa"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar e selecionar fatores relevantes",
                                  "subSteps": [
                                    "Avalie impacto potencial de cada fator via raciocínio qualitativo ou Pareto.",
                                    "Elimine fatores com impacto mínimo ou redundantes.",
                                    "Justifique seleção com evidências da descrição.",
                                    "Defina níveis iniciais para fatores selecionados (ex.: baixo/alto).",
                                    "Revise a lista final para completude."
                                  ],
                                  "verification": "Lista final de 4-8 fatores relevantes com justificativas e níveis.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Matriz de impacto (planilha)",
                                    "Critérios de relevância pré-definidos"
                                  ],
                                  "tips": "Aplique o princípio 80/20: foque nos 20% de fatores que causam 80% do impacto.",
                                  "learningObjective": "Selecionar fatores otimizados para experimentos de simulação.",
                                  "commonMistakes": [
                                    "Selecionar todos os fatores brainstormados",
                                    "Ignorar correlações entre fatores"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma fila de call center: fatores incluem taxa de chegada de chamadas (λ=10/hora), tempo médio de atendimento (μ=5 min/chamada), número de atendentes (c=5), e probabilidade de abandono (p=0.1). Esses impactam tempo médio de espera e % de chamadas perdidas.",
                              "finalVerifications": [
                                "Lista identifica pelo menos 80% dos fatores chave do sistema descrito.",
                                "Cada fator está mapeado a uma métrica de desempenho específica.",
                                "Justificativas são baseadas na descrição, não em suposições.",
                                "Fatores selecionados são acionáveis para simulação (com níveis definidos).",
                                "Nenhum fator irrelevante ou duplicado está incluído.",
                                "Diagrama ou tabela resume claramente os fatores."
                              ],
                              "assessmentCriteria": [
                                "Completude: Cobertura de fatores estocásticos, determinísticos e ambientais.",
                                "Precisão: Correta associação a métricas reais do sistema.",
                                "Profundidade: Justificativas detalhadas e mapeamento lógico.",
                                "Priorização: Seleção focada em alto impacto (Pareto aplicado).",
                                "Clareza: Apresentação organizada em tabela/diagrama.",
                                "Originalidade: Adaptação ao contexto específico do sistema."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Modelos probabilísticos (distribuições de Poisson, exponencial).",
                                "Programação: Implementação em linguagens de simulação (Python com SimPy).",
                                "Engenharia Industrial: Otimização de processos de produção e filas.",
                                "Gestão: Análise de gargalos em operações de serviço.",
                                "Física: Modelos de partículas discretas em simulações."
                              ],
                              "realWorldApplication": "Em logística, identificar fatores como taxa de chegada de caminhões e capacidade de docas em um armazém para reduzir tempos de espera e otimizar throughput, evitando custos extras com atrasos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.1.3",
                            "name": "Avaliar impacto potencial de fatores",
                            "description": "Utilizar conhecimento preliminar do modelo para priorizar fatores com maior variabilidade ou sensibilidade nas saídas, referenciando técnicas como análise de sensibilidade inicial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o modelo de simulação e listar fatores candidatos",
                                  "subSteps": [
                                    "Examine a estrutura do modelo de simulação para identificar todas as variáveis de entrada potenciais.",
                                    "Compile uma lista inicial de fatores com base no conhecimento domínio-específico e documentação do modelo.",
                                    "Classifique os fatores em categorias como parâmetros aleatórios, determinísticos ou ambientais.",
                                    "Documente suposições preliminares sobre a variabilidade de cada fator.",
                                    "Crie um diagrama de influência inicial ligando fatores a saídas chave."
                                  ],
                                  "verification": "Lista completa de fatores candidatos documentada com classificações e diagrama de influência.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação do modelo, papel ou ferramenta de diagramação (ex: Draw.io), editor de texto.",
                                  "tips": "Comece pelos fatores com maior incerteza no domínio real para maximizar relevância.",
                                  "learningObjective": "Identificar e categorizar fatores de entrada relevantes no modelo de simulação.",
                                  "commonMistakes": "Ignorar fatores interdependentes ou superestimar o número de fatores iniciais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar análise preliminar de variabilidade dos fatores",
                                  "subSteps": [
                                    "Colete dados históricos ou distribuições assumidas para cada fator.",
                                    "Calcule estatísticas descritivas: média, desvio padrão, coeficiente de variação e intervalos de confiança.",
                                    "Gere amostras aleatórias de cada fator usando geradores de números aleatórios.",
                                    "Visualize a variabilidade com histogramas ou boxplots.",
                                    "Rankeie fatores por magnitude de variabilidade relativa."
                                  ],
                                  "verification": "Relatório com estatísticas e visualizações para todos os fatores, com ranking inicial.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software de programação (Python com NumPy/Pandas/Matplotlib ou R), dados de entrada.",
                                  "tips": "Use coeficiente de variação para comparar variabilidades em escalas diferentes.",
                                  "learningObjective": "Quantificar a variabilidade inerente de cada fator usando estatísticas descritivas.",
                                  "commonMistakes": "Usar apenas médias sem considerar distribuições ou caudas extremas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar análise de sensibilidade inicial (One-Factor-At-a-Time - OFAT)",
                                  "subSteps": [
                                    "Fixe todos os fatores exceto um e execute múltiplas rodadas de simulação variando o fator alvo.",
                                    "Meça a mudança nas saídas chave (ex: média, variância) para cada variação.",
                                    "Calcule índices de sensibilidade, como correlação de Pearson ou regressão linear simples.",
                                    "Repita para cada fator candidato.",
                                    "Plote curvas de resposta para visualizar não-linearidades."
                                  ],
                                  "verification": "Tabelas e gráficos de sensibilidade para cada fator, com índices calculados.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Software de simulação (ex: SimPy para Python), ambiente computacional com paralelização.",
                                  "tips": "Limite variações a 5-10 níveis por fator para eficiência inicial.",
                                  "learningObjective": "Aplicar OFAT para estimar sensibilidade individual de fatores nas saídas.",
                                  "commonMistakes": "Não fixar adequadamente outros fatores, levando a ruído nos resultados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Priorizar fatores e justificar seleção",
                                  "subSteps": [
                                    "Combine rankings de variabilidade e sensibilidade em um escore composto (ex: produto ou soma ponderada).",
                                    "Selecione top 3-5 fatores com base no escore e impacto potencial nas saídas.",
                                    "Justifique escolhas referenciando evidências quantitativas e qualitativas.",
                                    "Discuta limitações da análise inicial (ex: interações ignoradas).",
                                    "Prepare relatório resumido com priorização para experimentos subsequentes."
                                  ],
                                  "verification": "Relatório final com lista priorizada, escores, justificativas e limitações.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Planilha (Excel/Google Sheets) para cálculos de escores, relatório template.",
                                  "tips": "Pondere sensibilidade mais que variabilidade se o foco for impacto nas saídas.",
                                  "learningObjective": "Integrar análises para priorizar fatores de alto impacto em experimentos.",
                                  "commonMistakes": "Priorizar subjetivamente sem base quantitativa."
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado (sistema discreto de eventos), fatores incluem taxa de chegada de clientes (λ), tempo médio de serviço (μ) e número de caixas. Analise variabilidade: λ tem alto CV de 20%; OFAT mostra que variar μ muda tempo médio de espera em 40%. Priorize μ e λ para experimentos DOE.",
                              "finalVerifications": [
                                "Lista priorizada de fatores com escores quantitativos corretos.",
                                "Gráficos de sensibilidade mostram impacto relativo claramente.",
                                "Justificativas ligam evidências a saídas do modelo.",
                                "Limitações da OFAT (ex: interações) são explicitadas.",
                                "Relatório é conciso e pronto para planejamento DOE.",
                                "Reprodutibilidade: código/scripts executam resultados idênticos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação e categorização de fatores (20%).",
                                "Qualidade das análises estatística e de sensibilidade (30%).",
                                "Rigor na priorização e justificativas baseadas em dados (25%).",
                                "Clareza de visualizações e relatórios (15%).",
                                "Identificação de limitações e sugestões de melhorias (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Cálculo de variabilidade e correlações.",
                                "Programação Computacional: Implementação de simulações e análises.",
                                "Engenharia de Processos: Otimização de sistemas reais via simulação.",
                                "Gestão de Projetos: Priorização em planejamento experimental."
                              ],
                              "realWorldApplication": "Em manufatura, priorizar fatores como velocidade de máquina e setup time em simulações de produção para reduzir custos em experimentos físicos caros, acelerando otimização de linhas de montagem."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.1.2",
                        "name": "Seleção de Fatores Relevantes",
                        "description": "Processo sistemático para escolher fatores chave a partir de um conjunto amplo de variáveis de entrada, considerando objetivos do experimento, restrições computacionais e conhecimento domínio-específico.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.2.1",
                            "name": "Aplicar critérios de seleção de fatores",
                            "description": "Usar critérios como relevância teórica, variabilidade histórica, custo de variação e interações potenciais para selecionar 3-5 fatores principais de uma lista de 10+ variáveis em um experimento de simulação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e Definir os Critérios de Seleção",
                                  "subSteps": [
                                    "Liste os critérios principais: relevância teórica, variabilidade histórica, custo de variação e interações potenciais.",
                                    "Pesquise definições precisas para cada critério no contexto de experimentos de simulação.",
                                    "Crie uma tabela ou matriz com colunas para cada critério e descrições breves.",
                                    "Adapte os critérios ao contexto específico do experimento (ex.: simulação de sistemas discretos).",
                                    "Priorize critérios com base na literatura ou dados preliminares."
                                  ],
                                  "verification": "Verificar se há uma tabela ou lista completa com 4 critérios definidos e exemplos de aplicação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Notas de aula, artigos sobre design de experimentos (DOE), planilha Excel ou Google Sheets.",
                                  "tips": "Use escalas qualitativas (alta/média/baixa) para facilitar comparações futuras.",
                                  "learningObjective": "Compreender e internalizar os critérios fundamentais para seleção de fatores em simulações.",
                                  "commonMistakes": "Confundir relevância teórica com variabilidade histórica ou ignorar custos práticos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Coletar Dados Preliminares para Cada Variável",
                                  "subSteps": [
                                    "Liste todas as 10+ variáveis candidatas do experimento de simulação.",
                                    "Reúna dados históricos ou execute simulações preliminares rápidas para medir variabilidade.",
                                    "Identifique interações potenciais entre variáveis via correlações ou gráficos de dispersão.",
                                    "Estime custos de variação (tempo computacional, recursos) para cada variável.",
                                    "Documente evidências teóricas de relevância para cada uma."
                                  ],
                                  "verification": "Verificar se há um banco de dados ou tabela com dados quantitativos/qualitativos para todas as variáveis.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de simulação (ex.: AnyLogic, Python com SimPy), dados históricos, calculadora ou script para correlações.",
                                  "tips": "Execute simulações curtas (monte carlo) para dados reais em vez de suposições.",
                                  "learningObjective": "Adquirir dados empíricos para embasar a avaliação objetiva das variáveis.",
                                  "commonMistakes": "Usar dados insuficientes ou desatualizados, levando a viés na seleção."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar e Pontuar Cada Variável",
                                  "subSteps": [
                                    "Aplique cada critério a todas as variáveis, atribuindo pontuações (ex.: 1-5 por critério).",
                                    "Calcule pontuação total por variável somando ou ponderando os critérios.",
                                    "Crie um ranking das variáveis do mais alto para o mais baixo pontuado.",
                                    "Analise trade-offs, como alto custo mas alta relevância.",
                                    "Discuta com pares ou mentor para validar pontuações subjetivas."
                                  ],
                                  "verification": "Verificar se existe uma tabela de pontuação com ranking claro das top 5 variáveis.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Planilha com fórmulas para pontuação automática, gráficos de ranking.",
                                  "tips": "Pondere critérios (ex.: relevância 40%, variabilidade 30%) se o contexto exigir.",
                                  "learningObjective": "Desenvolver habilidade em avaliação multicritério quantitativa e qualitativa.",
                                  "commonMistakes": "Pontuações inconsistentes entre critérios ou superestimar interações sem evidência."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Selecionar Fatores, Justificar e Verificar",
                                  "subSteps": [
                                    "Selecione os 3-5 fatores com as maiores pontuações totais.",
                                    "Escreva justificativas detalhadas para cada seleção, citando critérios e dados.",
                                    "Verifique se a seleção cobre pelo menos 80% da variabilidade total esperada.",
                                    "Simule brevemente com os fatores selecionados para validar impacto.",
                                    "Documente fatores excluídos e razões para transparência."
                                  ],
                                  "verification": "Verificar relatório final com seleção, justificativas e simulação de validação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de simulação, template de relatório.",
                                  "tips": "Sempre inclua sensibilidade: 'e se' para fatores borderline.",
                                  "learningObjective": "Consolidar a seleção em um plano acionável com justificativa robusta.",
                                  "commonMistakes": "Selecionar mais de 5 fatores por 'cautela' ou sem justificativa clara."
                                }
                              ],
                              "practicalExample": "Em uma simulação de sistema de filas em um supermercado com 12 variáveis (taxa de chegada de clientes, tempo de empacotamento, número de caixas, layout de corredores, etc.), aplique os critérios para selecionar 4 fatores principais: taxa de chegada (alta variabilidade histórica e relevância teórica), número de caixas (baixo custo de variação e interações potenciais), tempo de serviço (relevância alta) e layout (interações com fluxo).",
                              "finalVerifications": [
                                "Selecionou exatamente 3-5 fatores de uma lista de 10+ variáveis.",
                                "Cada fator tem justificativa ligada a pelo menos 3 critérios.",
                                "Dados históricos ou simulações preliminares foram usados na avaliação.",
                                "Ranking e pontuações mostram lógica consistente.",
                                "Verificação de cobertura de variabilidade (>70-80%).",
                                "Relatório documenta exclusões e trade-offs."
                              ],
                              "assessmentCriteria": [
                                "Precisão e consistência na aplicação dos 4 critérios (pontuação 30%).",
                                "Uso de dados empíricos vs. suposições (25%).",
                                "Qualidade das justificativas e análise de trade-offs (20%).",
                                "Eficiência na seleção (impacto simulado alto com poucos fatores, 15%).",
                                "Clareza e organização do relatório/ranking (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Análise de variância (ANOVA) para validar variabilidade.",
                                "Ciência de Dados: Feature selection em machine learning.",
                                "Engenharia Industrial: Design of Experiments (DOE) em otimização de processos.",
                                "Economia: Análise custo-benefício em modelagem.",
                                "Programação: Implementação em scripts de simulação (Python/R)."
                              ],
                              "realWorldApplication": "Na indústria automotiva, selecionar fatores como velocidade de linha de montagem, tolerância de peças e turnos de trabalhadores de uma lista de 15 variáveis para simular e otimizar produção, reduzindo custos em 20% e tempo de setup."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.2.2",
                            "name": "Realizar triagem de fatores não relevantes",
                            "description": "Eliminar fatores com impacto desprezível por meio de análise qualitativa ou testes preliminares curtos, justificando decisões com base em literatura como Banks et al. (2000).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisão Inicial de Literatura e Identificação de Fatores Potenciais",
                                  "subSteps": [
                                    "Reúna a lista completa de fatores potenciais identificados no planejamento do experimento de simulação.",
                                    "Consulte literatura relevante, como Banks et al. (2000), para entender impactos históricos de fatores semelhantes em simulações discretas.",
                                    "Classifique fatores em categorias: altamente prováveis, moderadamente prováveis e improváveis com base em evidências qualitativas.",
                                    "Documente razões iniciais para suspeita de irrelevância para cada fator improvável.",
                                    "Crie uma tabela de triagem inicial com colunas para fator, justificativa qualitativa e referência bibliográfica."
                                  ],
                                  "verification": "Tabela de triagem inicial completada com pelo menos 80% dos fatores classificados e referências citadas.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Acesso a literatura (Banks et al. 2000, artigos DOE), software de planilhas (Excel/Google Sheets), lista de fatores do experimento"
                                  ],
                                  "tips": "Priorize fatores com suporte empírico fraco na literatura para agilizar a triagem.",
                                  "learningObjective": "Compreender o papel da literatura na eliminação prévia de fatores irrelevantes.",
                                  "commonMistakes": [
                                    "Ignorar literatura recente ou específica ao contexto da simulação",
                                    "Classificar subjetivamente sem justificativas documentadas",
                                    "Incluir fatores irrelevantes baseados em intuição pessoal"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Análise Qualitativa para Eliminação Preliminar",
                                  "subSteps": [
                                    "Avalie cada fator improvável usando critérios qualitativos: mecanismo físico, escala de variação e interação esperada com o sistema.",
                                    "Compare com benchmarks de simulações semelhantes (ex: impacto desprezível se <5% da variância total).",
                                    "Realize discussões em grupo ou autoquestionamento: 'Este fator altera o output em cenários reais?'",
                                    "Elimine fatores com impacto qualitativamente desprezível e registre justificativas.",
                                    "Atualize a tabela de triagem marcando fatores eliminados qualitativamente."
                                  ],
                                  "verification": "Pelo menos 30-50% dos fatores iniciais eliminados com justificativas qualitativas claras na tabela.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Tabela de triagem do Step 1",
                                    "Checklists qualitativos de DOE (ex: templates de screening designs)"
                                  ],
                                  "tips": "Use escalas de 1-5 para impacto qualitativo para tornar a análise mais objetiva.",
                                  "learningObjective": "Desenvolver habilidade em análise qualitativa para filtrar fatores sem experimentos custosos.",
                                  "commonMistakes": [
                                    "Subestimar interações entre fatores",
                                    "Eliminar prematuramente sem considerar cenários extremos",
                                    "Falta de documentação explícita das decisões"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Execução de Testes Preliminares Curtos (Screening Experiments)",
                                  "subSteps": [
                                    "Selecione design de screening eficiente (ex: fractional factorial 2^(k-p) com k-p baixo).",
                                    "Configure simulações curtas variando apenas fatores remanescentes em níveis baixo/alto.",
                                    "Execute rodadas de simulação (mínimo 16 runs) e colete métricas de output (ex: tempo médio de ciclo).",
                                    "Calcule efeitos principais e interações usando ANOVA ou Pareto plots.",
                                    "Identifique fatores com p-value >0.05 ou efeito < threshold (ex: 2% variância)."
                                  ],
                                  "verification": "Relatório de screening com plots e tabela de efeitos, mostrando fatores com impacto desprezível.",
                                  "estimatedTime": "2-4 horas",
                                  "materials": [
                                    "Software de simulação (Arena, Simio), R/Python para análise estatística (packages como DoE.base)",
                                    "Design de experimento gerado (ex: via Minitab)"
                                  ],
                                  "tips": "Limite runs para manter testes 'curtos'; foque em resolution III/IV designs para economia.",
                                  "learningObjective": "Aplicar testes empíricos rápidos para quantificar irrelevância de fatores.",
                                  "commonMistakes": [
                                    "Design de experimento confuso levando a aliasing de efeitos",
                                    "Amostragem insuficiente causando ruído alto",
                                    "Ignorar normalização de outputs antes da análise"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Justificação Final e Documentação das Decisões",
                                  "subSteps": [
                                    "Integre resultados qualitativos e quantitativos para decisão final de eliminação.",
                                    "Compare com literatura (Banks et al.) para validar achados (ex: fatores com efeitos semelhantes reportados como irrelevantes).",
                                    "Escreva relatório justificando cada eliminação com evidências mistas.",
                                    "Atualize plano de experimento principal excluindo fatores triados.",
                                    "Revise com pares para confirmação de robustez das decisões."
                                  ],
                                  "verification": "Relatório final aprovado por revisão par com todas eliminações justificadas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Resultados dos steps anteriores",
                                    "Templates de relatório DOE",
                                    "Literatura de referência"
                                  ],
                                  "tips": "Use frases padronizadas: 'Fator X eliminado pois efeito <1% e suportado por [ref].'",
                                  "learningObjective": "Consolidar evidências para decisões transparentes e reproduzíveis.",
                                  "commonMistakes": [
                                    "Justificativas vagas sem dados quantitativos",
                                    "Não cruzar com literatura",
                                    "Falhar em atualizar plano principal"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado (sistema discreto), fatores potenciais incluem: tempo de serviço, chegada de clientes, número de caixas, cor do uniforme dos caixas. Triagem qualitativa elimina 'cor do uniforme' (sem mecanismo lógico). Teste preliminar com 16 runs confirma impacto <0.5% no tempo de espera, justificando eliminação citando Banks et al. sobre fatores não-ergonômicos.",
                              "finalVerifications": [
                                "Todos fatores eliminados têm impacto <5% da variância total ou p>0.10 nos testes.",
                                "Cada eliminação possui justificativa dupla: qualitativa + quantitativa/literatura.",
                                "Lista final de fatores reduzida em pelo menos 20-40% sem perda de representatividade do sistema.",
                                "Tabela de triagem completa e auditável.",
                                "Pareto plot mostra concentração de efeitos nos fatores retidos.",
                                "Plano de experimento principal atualizado e validado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na eliminação: >90% dos fatores irrelevantes corretamente triados.",
                                "Robustez das justificativas: Todas baseadas em múltiplas evidências (qualitativa, testes, lit.).",
                                "Eficiência: Tempo total <8 horas com designs econômicos.",
                                "Documentação: Relatórios claros, tabelas legíveis e referências corretas.",
                                "Validação estatística: Uso correto de ANOVA/Pareto com thresholds definidos.",
                                "Integração com contexto: Alinhamento com objetivos da simulação discreta."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Análise de variância (ANOVA) e designs fatoriais.",
                                "Engenharia de Produção: Otimização de processos via DOE.",
                                "Ciência de Dados: Feature selection em modelagem preditiva.",
                                "Pesquisa Científica: Revisão bibliográfica e validação empírica.",
                                "Gestão de Projetos: Decisões baseadas em evidências para redução de escopo."
                              ],
                              "realWorldApplication": "Em indústrias como manufatura e logística, triar fatores irrelevantes em simulações reduz custos computacionais em 50-70%, acelerando otimização de linhas de produção ou cadeias de suprimentos, como na Ford usando DOE para simulações de montagem."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.2.3",
                            "name": "Considerar interações entre fatores",
                            "description": "Identificar pares ou grupos de fatores suscetíveis a interações não-lineares em simulações discretas, como efeito de taxa de chegada combinada com número de servidores em filas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de interações entre fatores",
                                  "subSteps": [
                                    "Estudar definições de interações principais e não-lineares em experimentos de simulação.",
                                    "Analisar exemplos clássicos de interações em filas, como taxa de chegada e serviço.",
                                    "Diferenciar interações aditivas de não-lineares usando gráficos de resposta superficial.",
                                    "Revisar literatura sobre Design of Experiments (DOE) para simulações discretas.",
                                    "Discutir com pares casos onde interações foram ignoradas e causaram erros."
                                  ],
                                  "verification": "Explicar em palavras próprias a diferença entre interação linear e não-linear com um diagrama simples.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livro de simulação discreta (ex: Banks et al.), slides sobre DOE, software de plotagem como Python Matplotlib.",
                                  "tips": "Use analogias do dia a dia, como 'trânsito aumenta mais com chuva + hora pico do que isoladamente'.",
                                  "learningObjective": "Dominar definições e identificar sinais de interações não-lineares.",
                                  "commonMistakes": "Confundir correlação com interação; assumir todas as interações são lineares."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar fatores relevantes na simulação",
                                  "subSteps": [
                                    "Mapear todos os fatores do sistema de simulação (ex: parâmetros de entrada).",
                                    "Classificar fatores por relevância usando conhecimento domínio-específico.",
                                    "Coletar dados históricos ou literatura para priorizar fatores voláteis.",
                                    "Criar uma tabela de fatores com níveis possíveis (baixo, médio, alto).",
                                    "Validar lista com simulação preliminar de um fator isolado."
                                  ],
                                  "verification": "Produzir uma tabela completa com pelo menos 5 fatores e seus níveis propostos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Planilha Excel ou Google Sheets, documentação do modelo de simulação.",
                                  "tips": "Comece pelo funil: fatores que afetam diretamente a saída principal (ex: tempo médio de espera).",
                                  "learningObjective": "Listar e priorizar fatores candidatos a interações.",
                                  "commonMistakes": "Incluir fatores irrelevantes, inchando o experimento; ignorar fatores contextuais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detectar pares ou grupos suscetíveis a interações não-lineares",
                                  "subSteps": [
                                    "Listar combinações pares de fatores (ex: taxa chegada x servidores).",
                                    "Executar simulações fatoriais 2^k para pares selecionados.",
                                    "Analisar gráficos de interação (interaction plots) para não-linearidades.",
                                    "Usar testes estatísticos como ANOVA para interações significativas.",
                                    "Documentar evidências qualitativas e quantitativas de interações."
                                  ],
                                  "verification": "Gerar pelo menos 3 gráficos de interação mostrando não-linearidades claras.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Software de simulação (ex: Simul8, Arena ou Python SimPy), R ou Python para ANOVA.",
                                  "tips": "Foque em pares com lógica teórica: 'alta chegada + poucos servidores = colapso'.",
                                  "learningObjective": "Identificar interações via análise visual e estatística.",
                                  "commonMistakes": "Interpretar ruído como interação; não testar níveis extremos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Selecionar e planejar inclusão de interações no experimento",
                                  "subSteps": [
                                    "Priorizar interações por impacto na saída (ex: variância explicada).",
                                    "Decidir níveis e frações fatoriais para incluir interações.",
                                    "Estimar poder estatístico do design considerando interações.",
                                    "Documentar plano em relatório com justificativas.",
                                    "Simular o design proposto para validar viabilidade computacional."
                                  ],
                                  "verification": "Elaborar um plano de experimento DOE incluindo 2-3 interações selecionadas.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Software DOE (ex: Minitab, JMP ou Python pyDOE), template de relatório.",
                                  "tips": "Use designs fracionários para reduzir runs se muitas interações.",
                                  "learningObjective": "Integrar interações de forma eficiente no planejamento experimental.",
                                  "commonMistakes": "Sobrecarregar o design com muitas interações desnecessárias."
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila M/M/c, identifique a interação entre taxa de chegada (λ = 5, 10, 15 clientes/h) e número de servidores (c = 1, 2, 3). Simule cenários: com λ alta e c=1, tempo de espera explode (>1h), mas com c=3 estabiliza; graficamente, linhas não paralelas indicam interação não-linear forte.",
                              "finalVerifications": [
                                "Explica corretamente interações não-lineares com exemplo próprio.",
                                "Identifica pelo menos 3 pares de fatores interativos em um novo sistema.",
                                "Produz gráficos de interação válidos para validação.",
                                "Propõe design DOE que inclui interações relevantes sem excesso.",
                                "Demonstra impacto de ignorar interações via simulação comparativa.",
                                "Avalia significância estatística de interações detectadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de fatores e interações (80% acerto).",
                                "Qualidade dos gráficos e análises estatísticas (rubrica visual).",
                                "Eficiência do plano DOE proposto (runs < 32 para 4 fatores).",
                                "Profundidade das justificativas teóricas e práticas.",
                                "Capacidade de generalizar para outros sistemas discretos.",
                                "Ausência de erros comuns como confusão linear/não-linear."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Design of Experiments (DOE) e ANOVA para interações.",
                                "Programação: Implementação de simulações em Python (SimPy) ou R.",
                                "Gestão de Operações: Otimização de filas em logística.",
                                "Física/Matemática: Modelos estocásticos e dinâmica de sistemas."
                              ],
                              "realWorldApplication": "Em call centers, considerar interação entre taxa de chamadas e número de atendentes evita sobrecarga; em hospitais, chegada de pacientes x leitos previne colapsos; otimiza alocação de recursos em supermercados durante picos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.1.3",
                        "name": "Definição de Níveis para Fatores",
                        "description": "Determinação dos valores discretos ou contínuos (níveis) para cada fator selecionado, garantindo representatividade, eficiência computacional e adequação ao design experimental como fatoriais ou response surface.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.3.1",
                            "name": "Escolher número de níveis por fator",
                            "description": "Decidir entre 2 níveis (para screening), 3 níveis (para curvas) ou mais, balanceando precisão com número de runs, considerando métodos de redução de variância.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar o objetivo do experimento e o papel do fator",
                                  "subSteps": [
                                    "Analisar o contexto do experimento de simulação (screening, modelagem de curvas, otimização).",
                                    "Definir o papel do fator: qualitativo ou quantitativo, e sua influência esperada na resposta.",
                                    "Listar restrições iniciais, como orçamento computacional e tempo disponível.",
                                    "Documentar hipóteses sobre a relação fator-resposta (linear, quadrática, etc.).",
                                    "Consultar literatura ou dados prévios para insights sobre o fator."
                                  ],
                                  "verification": "Verificar se há um relatório escrito com objetivo claro, papel do fator e hipóteses documentadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação do projeto de simulação, literatura relevante (artigos DOE), software de notas (ex: Jupyter Notebook).",
                                  "tips": "Comece pelo 'porquê' do experimento para evitar escolhas arbitrárias.",
                                  "learningObjective": "Compreender como o contexto guia a escolha de níveis para alinhar com objetivos experimentais.",
                                  "commonMistakes": "Ignorar o tipo de experimento, levando a oversampling desnecessário."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Avaliar o tipo de relação esperada e precisão necessária",
                                  "subSteps": [
                                    "Classificar a relação: linear (2 níveis), quadrática/cúbica (3+ níveis).",
                                    "Determinar se screening é prioritário (2 níveis para FFD) ou modelagem detalhada (3 níveis para CCD).",
                                    "Calcular poder estatístico aproximado para diferentes números de níveis.",
                                    "Considerar métodos de redução de variância (ex: common random numbers, control variates).",
                                    "Simular cenários rápidos para testar sensibilidade."
                                  ],
                                  "verification": "Conferir tabela comparativa de relações esperadas vs. níveis propostos com justificativas estatísticas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramentas estatísticas (R, Python com statsmodels), planilhas para cálculos de poder.",
                                  "tips": "Use gráficos de resposta superficial preliminares para visualizar necessidades.",
                                  "learningObjective": "Avaliar trade-offs entre modelagem precisa e simplicidade experimental.",
                                  "commonMistakes": "Assumir linearidade sem evidência, subestimando níveis para curvas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estimar custos computacionais e restrições de runs",
                                  "subSteps": [
                                    "Calcular número total de runs: níveis^k * replicatas para k fatores.",
                                    "Benchmarkar tempo de simulação por run no ambiente disponível.",
                                    "Identificar limites: hardware, tempo paralelo, orçamento cloud.",
                                    "Incorporar técnicas de redução de variância para minimizar runs.",
                                    "Priorizar fatores principais se múltiplos."
                                  ],
                                  "verification": "Validar planilha com cálculos de runs totais < limite viável e tempo total estimado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Simulador do sistema discreto, cronômetro para benchmarks, calculadora ou Excel.",
                                  "tips": "Teste 1-2 runs reais para calibração precisa de tempos.",
                                  "learningObjective": "Quantificar impactos computacionais na decisão de níveis.",
                                  "commonMistakes": "Superestimar paralelismo disponível, inflando número de níveis."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Selecionar e justificar o número de níveis finais",
                                  "subSteps": [
                                    "Escolher: 2 níveis para screening, 3 para curvas, mais se alta precisão e recursos.",
                                    "Balancear precisão vs. runs usando critérios como D-optimality.",
                                    "Documentar decisão com prós/contras e alternativas rejeitadas.",
                                    "Planejar análise posterior (ANOVA, regressão) compatível com níveis.",
                                    "Revisar com pares ou supervisor para validação."
                                  ],
                                  "verification": "Aprovação de relatório final com escolha justificada, cálculos e plano de análise.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Software DOE (JMP, Minitab ou Python doe2), documento de design experimental.",
                                  "tips": "Prefira 2 níveis inicialmente; escale só com necessidade comprovada.",
                                  "learningObjective": "Tomar decisões balanceadas baseadas em princípios DOE e contexto prático.",
                                  "commonMistakes": "Escolher níveis altos por 'segurança' sem considerar custo explosivo."
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de call center, para o fator 'número de agentes' (quantitativo), escolha 2 níveis (5 e 15 agentes) para screening inicial em FFD com 4 fatores (16 runs), detectando impacto linear no tempo de espera; avance para 3 níveis (5,10,15) em CCD se curvatura suspeita, totalizando 27 runs com centro.",
                              "finalVerifications": [
                                "Número de runs totais é viável dentro de restrições computacionais.",
                                "Escolha alinhada com tipo de experimento (screening vs. modelagem).",
                                "Justificativa documentada inclui relação esperada e métodos de variância.",
                                "Plano de análise estatística compatível com níveis selecionados.",
                                "Simulação piloto confirma tempos e viabilidade.",
                                "Trade-offs de precisão vs. custo explicitados."
                              ],
                              "assessmentCriteria": [
                                "Justificativa teórica sólida baseada em princípios DOE.",
                                "Cálculos precisos de runs e custos computacionais.",
                                "Balanceamento ótimo entre precisão e eficiência.",
                                "Consideração explícita de redução de variância.",
                                "Documentação clara e reprodutível.",
                                "Adequação ao contexto específico do experimento."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Design de Experimentos (DOE), análise de variância (ANOVA).",
                                "Ciência da Computação: Otimização de simulações paralelas e Monte Carlo.",
                                "Engenharia Industrial: Planejamento de experimentos em processos discretos.",
                                "Gestão de Projetos: Avaliação de trade-offs custo-benefício."
                              ],
                              "realWorldApplication": "Em simulações de supply chain para otimização de estoque, escolher 3 níveis para fator 'lead time' permite modelar curvaturas no custo total, reduzindo variância com antithetic variates e evitando milhões de runs desnecessários em cenários industriais reais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.3.2",
                            "name": "Definir valores realistas de níveis",
                            "description": "Selecionar níveis baseados em dados reais, distribuições históricas ou expert judgment, ex.: para tempo de serviço, níveis baixo/médio/alto como 5/10/15 minutos em simulação de fila.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o fator e seu contexto real",
                                  "subSteps": [
                                    "Identificar o fator específico (ex.: tempo de serviço em uma fila)",
                                    "Pesquisar o domínio operacional real do fator (mínimo, máximo e típico)",
                                    "Analisar distribuições históricas ou padrões observados (ex.: normal, exponencial)",
                                    "Considerar influências contextuais como sazonalidade ou variações regionais",
                                    "Documentar o contexto em um resumo inicial"
                                  ],
                                  "verification": "Resumo escrito do fator com range realista e fontes iniciais",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Acesso à internet para pesquisas",
                                    "Livros ou artigos sobre simulações",
                                    "Bloco de notas ou editor de texto"
                                  ],
                                  "tips": "Priorize dados de fontes confiáveis como estudos acadêmicos ou relatórios industriais",
                                  "learningObjective": "Dominar o range e comportamento real do fator no mundo físico",
                                  "commonMistakes": [
                                    "Escolher valores arbitrários sem contexto",
                                    "Ignorar variações extremas raras mas impactantes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Coletar dados reais e evidências históricas",
                                  "subSteps": [
                                    "Buscar dados empíricos de experimentos reais ou bancos de dados (ex.: Kaggle, papers)",
                                    "Analisar distribuições estatísticas (média, desvio padrão, percentis)",
                                    "Identificar benchmarks de expert judgment de literatura especializada",
                                    "Compilar uma tabela com valores observados de múltiplas fontes",
                                    "Calcular percentis para níveis baixo/médio/alto (ex.: 10%, 50%, 90%)"
                                  ],
                                  "verification": "Tabela de dados com pelo menos 3 fontes e cálculos de percentis",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Ferramentas de planilha (Excel/Google Sheets)",
                                    "Bancos de dados online",
                                    "Calculadora ou software estatístico básico"
                                  ],
                                  "tips": "Use percentis para capturar variabilidade real em vez de médias simples",
                                  "learningObjective": "Adquirir dados quantitativos para embasar escolhas realistas",
                                  "commonMistakes": [
                                    "Confiar em uma única fonte",
                                    "Confundir unidades (minutos vs. segundos)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir os valores dos níveis (baixo, médio, alto)",
                                  "subSteps": [
                                    "Mapear percentis aos níveis: baixo (10-25%), médio (50%), alto (75-90%)",
                                    "Ajustar valores para serem acionáveis na simulação (arredondar realisticamente)",
                                    "Garantir espaçamento lógico entre níveis para discriminar efeitos",
                                    "Testar valores em uma fórmula simples de simulação preliminar",
                                    "Registrar os valores finais com justificativa numérica"
                                  ],
                                  "verification": "Lista de 3 níveis definidos com cálculos e justificativas",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha para cálculos",
                                    "Software de simulação básico (ex.: Python com SimPy)"
                                  ],
                                  "tips": "Mantenha os níveis próximos o suficiente para simulação eficiente, mas distintos",
                                  "learningObjective": "Selecionar níveis quantitativos realistas e diferenciados",
                                  "commonMistakes": [
                                    "Níveis muito próximos (sem discriminação)",
                                    "Valores fora do range real"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e documentar a seleção de níveis",
                                  "subSteps": [
                                    "Comparar níveis com literatura ou experts para validação",
                                    "Simular um cenário rápido para checar plausibilidade",
                                    "Documentar sensibilidade (impacto de ±10% nos níveis)",
                                    "Preparar justificativa para relatório do experimento",
                                    "Revisar com pares ou autoavaliação"
                                  ],
                                  "verification": "Documento final com níveis, fontes, validação e sensibilidade",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software de simulação",
                                    "Checklist de validação"
                                  ],
                                  "tips": "Sempre inclua uma análise de sensibilidade para robustez",
                                  "learningObjective": "Garantir que os níveis sejam defensáveis e aplicáveis",
                                  "commonMistakes": [
                                    "Pular validação por pressa",
                                    "Não documentar fontes"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado, para o fator 'tempo de serviço por cliente', defina níveis: baixo=3 minutos (10% percentil de observações rápidas), médio=5 minutos (média histórica), alto=8 minutos (90% percentil em picos), baseado em dados de 500 observações em lojas reais (fonte: estudo de engenharia industrial).",
                              "finalVerifications": [
                                "Os níveis cobrem 80-90% do range real observado?",
                                "Há pelo menos 2 fontes de dados citadas?",
                                "Os níveis são distintos o suficiente (diferença >20%)?",
                                "Justificativa inclui percentis ou distribuições?",
                                "Teste preliminar confirma plausibilidade?",
                                "Documentação está clara e reproduzível?"
                              ],
                              "assessmentCriteria": [
                                "Precisão dos níveis em relação a dados reais (nota 1-10)",
                                "Uso adequado de estatísticas (percentis, média)",
                                "Espaçamento lógico e discriminante entre níveis",
                                "Qualidade da documentação e justificativas",
                                "Validação por simulação ou sensibilidade",
                                "Criatividade na seleção contextual"
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Cálculo de percentis e distribuições",
                                "Programação: Implementação de parâmetros em código de simulação",
                                "Engenharia Industrial: Otimização de processos reais",
                                "Gestão de Projetos: Planejamento experimental DOE",
                                "Ciência de Dados: Análise de datasets históricos"
                              ],
                              "realWorldApplication": "Aplicado em simulações de call centers para definir tempos de atendimento (baixo=2min, médio=4min, alto=7min), otimizando escalas de funcionários sem testes reais custosos; usado em manufatura para tempos de máquina e logística de supply chain."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.3.3",
                            "name": "Adaptar níveis para tipos de fatores",
                            "description": "Ajustar níveis para fatores contínuos (ex.: intervalos uniformes) vs. discretos (ex.: inteiros para número de recursos), alinhando com linguagens de simulação e validação de modelos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar o Tipo de Fator",
                                  "subSteps": [
                                    "Analise a natureza da variável: contínua (valores reais em intervalo) ou discreta (valores inteiros ou categóricos).",
                                    "Revise o contexto do sistema de simulação para confirmar o tipo (ex.: tempo é contínuo, número de recursos é discreto).",
                                    "Classifique o fator usando definições padrão: contínuo permite frações, discreto requer passos inteiros.",
                                    "Documente o tipo e justifique com exemplos do domínio da simulação.",
                                    "Consulte literatura ou ferramentas de simulação para validação inicial."
                                  ],
                                  "verification": "Crie uma tabela resumindo o fator, tipo e justificativa; confirme se não há ambiguidades.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta ou editor de texto (ex.: Google Docs), referência rápida sobre tipos de variáveis em simulação.",
                                  "tips": "Use diagramas de Venn para visualizar diferenças entre contínuo e discreto.",
                                  "learningObjective": "Diferenciar precisamente fatores contínuos de discretos no contexto de simulações.",
                                  "commonMistakes": "Confundir variáveis categóricas nominais com discretas numéricas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Níveis para Fatores Contínuos",
                                  "subSteps": [
                                    "Estabeleça o intervalo mínimo e máximo realista baseado no domínio do problema.",
                                    "Divida o intervalo em níveis uniformes (ex.: 5 pontos equidistantes).",
                                    "Garanta distribuição uniforme para amostragem eficiente em simulações.",
                                    "Teste os níveis em uma simulação preliminar para checar viabilidade.",
                                    "Ajuste bordas se necessário para evitar extremos irreais."
                                  ],
                                  "verification": "Gere uma lista de níveis numéricos e plote em gráfico linear para uniformidade.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software de simulação (ex.: Python com NumPy ou R), calculadora.",
                                  "tips": "Use a fórmula para pontos uniformes: nível_i = min + i*(max-min)/(n-1), onde n= número de níveis.",
                                  "learningObjective": "Criar intervalos uniformes otimizados para fatores contínuos.",
                                  "commonMistakes": "Escolher intervalos muito amplos que incluam valores impossíveis."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Níveis para Fatores Discretos",
                                  "subSteps": [
                                    "Liste valores inteiros possíveis dentro do contexto (ex.: 1, 2, 3 servidores).",
                                    "Selecione subconjunto representativo, evitando excesso de níveis para eficiência computacional.",
                                    "Priorize níveis que cubram cenários de baixa, média e alta carga.",
                                    "Valide compatibilidade com linguagens de simulação (ex.: Arena ou Simul8 suporta inteiros nativamente).",
                                    "Registre razões para exclusão de certos valores discretos."
                                  ],
                                  "verification": "Compile tabela de níveis discretos e simule um caso simples para execução sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Planilha (ex.: Excel ou Google Sheets), documentação de software de simulação.",
                                  "tips": "Limite a 3-7 níveis para equilibrar precisão e tempo de simulação.",
                                  "learningObjective": "Selecionar níveis discretos práticos e alinhados ao modelo.",
                                  "commonMistakes": "Incluir níveis zero ou negativos quando não fazem sentido no contexto."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar e Validar Níveis nos Experimentos",
                                  "subSteps": [
                                    "Incorpore níveis definidos no plano de experimento (ex.: design fatorial).",
                                    "Execute simulações de teste nas linguagens escolhidas (ex.: Python/SimPy).",
                                    "Verifique resultados para cobertura adequada do espaço de fatores.",
                                    "Ajuste níveis com base em métricas de validação (ex.: variância explicada).",
                                    "Documente o alinhamento final com objetivos de modelagem."
                                  ],
                                  "verification": "Rode pelo menos 2 réplicas por combinação e confira se o modelo roda sem crashes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ambiente de programação (Python com SimPy ou R com simmer), dados de entrada simulados.",
                                  "tips": "Automatize com scripts para múltiplas runs e compare saídas.",
                                  "learningObjective": "Garantir que níveis sejam viáveis e eficazes em simulações reais.",
                                  "commonMistakes": "Ignorar overhead computacional de muitos níveis discretos."
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado: fator 'tempo de serviço' (contínuo: níveis 1.0, 2.0, 3.0, 4.0, 5.0 min); fator 'número de caixas' (discreto: 2, 4, 6). Rode em Python/SimPy para medir tempo médio de espera.",
                              "finalVerifications": [
                                "Todos os fatores têm tipos corretamente identificados e documentados.",
                                "Níveis contínuos são uniformes e realistas (ver gráfico).",
                                "Níveis discretos são inteiros viáveis e cobrem cenários chave.",
                                "Simulações de teste executam sem erros em linguagem escolhida.",
                                "Validação mostra boa cobertura do espaço experimental.",
                                "Documentação inclui justificativas para cada escolha de nível."
                              ],
                              "assessmentCriteria": [
                                "Precisão na classificação de tipos de fatores (100% correto).",
                                "Uniformidade e realismo dos intervalos contínuos (desvio <5%).",
                                "Eficiência dos níveis discretos (≤7 níveis por fator).",
                                "Sucesso em simulações de validação (zero falhas).",
                                "Qualidade da documentação e justificativas (clara e completa).",
                                "Alinhamento com metas de experimento (cobertura >90%)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Design de Experimentos (DOE) e amostragem.",
                                "Programação: Implementação em linguagens de simulação como SimPy ou Arena.",
                                "Engenharia: Otimização de sistemas reais (ex.: manufatura).",
                                "Ciência de Dados: Validação de modelos preditivos."
                              ],
                              "realWorldApplication": "Em logística, adaptar níveis para simular 'velocidade de entrega' (contínua: 20-80 km/h) vs. 'número de veículos' (discreto: 5,10,15), otimizando rotas em ferramentas como AnyLogic para reduzir custos operacionais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.3.4",
                            "name": "Validar seleção de níveis preliminarmente",
                            "description": "Executar runs de simulação curtos para verificar se os níveis cobrem o espaço de interesse sem extrapolação, ajustando com base em saídas iniciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o Experimento Preliminar de Simulação",
                                  "subSteps": [
                                    "Defina os fatores e níveis iniciais selecionados previamente, garantindo que representem o espaço de interesse.",
                                    "Adapte o modelo de simulação para runs curtos, reduzindo o número de iterações ou tempo de simulação.",
                                    "Implemente o código ou software para executar múltiplas réplicas nos níveis preliminares.",
                                    "Teste a configuração com um run único para verificar ausência de erros.",
                                    "Salve os parâmetros iniciais em um arquivo de configuração para rastreabilidade."
                                  ],
                                  "verification": "Execute um run de teste e confirme que os outputs são gerados sem erros e dentro do tempo esperado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software de simulação (ex: Python com NumPy/SciPy, ou SimPy para sistemas discretos), código fonte do modelo, computador com capacidade computacional moderada.",
                                  "tips": "Use sementes fixas para reprodutibilidade nos runs preliminares.",
                                  "learningObjective": "Preparar uma configuração eficiente para validação rápida de níveis.",
                                  "commonMistakes": "Não reduzir adequadamente o escopo da simulação, levando a tempos excessivos; ignorar reprodutibilidade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar Runs de Simulação Curtos",
                                  "subSteps": [
                                    "Execute simulações nos pontos de níveis preliminares, visando 10-50 réplicas por combinação.",
                                    "Monitore o progresso e registre métricas intermediárias como tempo de execução e uso de recursos.",
                                    "Colete outputs principais (ex: médias, desvios, distribuições) para cada nível.",
                                    "Salve todos os dados brutos em formato estruturado (CSV ou HDF5).",
                                    "Verifique se todos os runs completaram sem falhas."
                                  ],
                                  "verification": "Confirme que dados de outputs foram coletados para todos os níveis planejados, sem falhas reportadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Mesmo software do Step 1, scripts de execução em batch, armazenamento de dados (disco ou nuvem).",
                                  "tips": "Paralelize runs se possível para acelerar o processo.",
                                  "learningObjective": "Gerar dados preliminares de forma eficiente e confiável.",
                                  "commonMistakes": "Executar réplicas insuficientes, levando a variância alta; não monitorar recursos computacionais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Cobertura e Extrapolação dos Níveis",
                                  "subSteps": [
                                    "Plote respostas vs. níveis para visualizar cobertura do espaço de interesse.",
                                    "Calcule estatísticas descritivas (média, variância, intervalos de confiança) por nível.",
                                    "Identifique regiões de extrapolação onde respostas são instáveis ou fora do domínio esperado.",
                                    "Compare com conhecimento domínio-específico para validar se níveis capturam variações relevantes.",
                                    "Gere relatório inicial com gráficos e tabelas de análise."
                                  ],
                                  "verification": "Plots e stats mostram cobertura adequada sem gaps ou instabilidades evidentes.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Ferramentas de análise e visualização (Matplotlib/Seaborn em Python, ou R), dados dos runs.",
                                  "tips": "Use boxplots para detectar outliers que indiquem extrapolação.",
                                  "learningObjective": "Interpretar dados de simulação para diagnosticar adequação dos níveis.",
                                  "commonMistakes": "Ignorar variância alta como sinal de extrapolação; plots mal escalados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ajustar Níveis e Revalidar",
                                  "subSteps": [
                                    "Baseado na análise, proponha ajustes: adicionar/refinar níveis em regiões críticas.",
                                    "Atualize a configuração e execute runs adicionais apenas nos níveis ajustados.",
                                    "Reanalise os novos dados combinados com os anteriores.",
                                    "Itere até que cobertura seja satisfatória (máx. 2 iterações).",
                                    "Documente todas as mudanças e razões."
                                  ],
                                  "verification": "Análise final confirma ausência de extrapolação e cobertura completa do espaço.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Mesmos do Step 3, versão atualizada do código de simulação.",
                                  "tips": "Priorize ajustes em regiões de maior variância ou interesse.",
                                  "learningObjective": "Aplicar feedback iterativo para otimizar seleção de níveis.",
                                  "commonMistakes": "Ajustes excessivos sem critério, prolongando o processo."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar e Finalizar Validação Preliminar",
                                  "subSteps": [
                                    "Compile relatório com configurações, resultados, análises e ajustes.",
                                    "Defina níveis finais validados para experimentos completos.",
                                    "Arquive todos os dados e scripts para reprodutibilidade.",
                                    "Compartilhe achados com equipe ou stakeholders.",
                                    "Planeje próximos passos no planejamento experimental."
                                  ],
                                  "verification": "Relatório completo e níveis finais aprovados por auto-revisão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Ferramentas de documentação (Jupyter Notebook, Markdown, LaTeX).",
                                  "tips": "Use versionamento (Git) para rastrear mudanças.",
                                  "learningObjective": "Garantir rastreabilidade e transição suave para fases subsequentes.",
                                  "commonMistakes": "Documentação incompleta, perdendo justificativas de ajustes."
                                }
                              ],
                              "practicalExample": "Em uma simulação de sistema de filas M/M/1, fatores: taxa de chegada (λ: 0.1, 0.5, 0.9) e serviço (μ: 0.2, 0.6, 1.0). Runs curtos (1000 chegadas) revelam extrapolação em λ=0.9/μ=1.0 (fila instável). Ajuste adicionando λ=0.95, re-run confirma cobertura até saturação.",
                              "finalVerifications": [
                                "Plots mostram respostas suaves sem saltos abruptos indicando extrapolação.",
                                "Intervalos de confiança não se sobrepõem excessivamente em regiões críticas.",
                                "Variância das respostas é estável ao longo dos níveis.",
                                "Níveis cobrem 95% do espaço de interesse definido.",
                                "Nenhum run falhou ou exibiu comportamentos anômalos.",
                                "Documentação registra todos os ajustes efetuados."
                              ],
                              "assessmentCriteria": [
                                "Eficiência: Tempo total < 3 horas para validação completa.",
                                "Precisão: Ausência de extrapolação detectada em análise.",
                                "Qualidade de análise: Gráficos claros e stats apropriadas.",
                                "Iteratividade: Ajustes lógicos baseados em evidências.",
                                "Documentação: Relatório completo e reprodutível.",
                                "Cobertura: Níveis finais abrangem espaço sem gaps."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Análise de variância e intervalos de confiança.",
                                "Programação: Implementação eficiente de simulações paralelas.",
                                "Engenharia de Software: Versionamento e reprodutibilidade.",
                                "Design de Experimentos: Princípios DOE para otimização.",
                                "Ciência de Dados: Visualização e interpretação de dados simulados."
                              ],
                              "realWorldApplication": "Em indústrias como manufatura ou telecomunicações, validação preliminar de níveis em simulações de Monte Carlo otimiza experimentos para previsão de desempenho de sistemas, reduzindo custos computacionais em 50-70% antes de runs full-scale."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.2",
                    "name": "Planejamento de Réplicas e Execuções",
                    "description": "Determinação do número de réplicas independentes e runs necessárias para resultados confiáveis.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.2.1",
                        "name": "Réplicas Independentes em Simulações",
                        "description": "Compreensão do conceito de réplicas independentes, sua importância para reduzir variância e obter estimativas confiáveis em experimentos de simulação de sistemas discretos.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.1.1",
                            "name": "Definir réplicas independentes",
                            "description": "Explicar o que são réplicas independentes em simulações, destacando a necessidade de usar sementes de números aleatórios diferentes para cada uma, garantindo independência estatística conforme Banks et al. (2000).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de réplicas em simulações discretas",
                                  "subSteps": [
                                    "Leia a definição de réplicas conforme Banks et al. (2000): múltiplas execuções independentes da mesma simulação para reduzir variância.",
                                    "Identifique que réplicas são usadas para obter estimativas estatisticamente confiáveis de medidas de desempenho.",
                                    "Diferencie réplicas de execuções únicas ou batches correlacionados.",
                                    "Anote exemplos de simulações que requerem réplicas, como filas ou sistemas de manufatura.",
                                    "Resuma em suas palavras o propósito principal das réplicas."
                                  ],
                                  "verification": "Escreva um parágrafo explicando réplicas e forneça um exemplo simples; revise se menciona redução de variância.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Texto de Banks et al. (2000), seção sobre simulações",
                                    "Notebook para anotações"
                                  ],
                                  "tips": [
                                    "Use analogia com 'lançar uma moeda várias vezes' para entender variância",
                                    "Foque em simulações estocásticas discretas"
                                  ],
                                  "learningObjective": "Definir réplicas e seu papel em experimentos de simulação.",
                                  "commonMistakes": [
                                    "Confundir réplicas com runs de warm-up",
                                    "Ignorar que réplicas são para eventos aleatórios"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explicar a necessidade de independência estatística nas réplicas",
                                  "subSteps": [
                                    "Estude por que correlação entre réplicas leva a estimativas enviesadas (Banks et al., 2000).",
                                    "Aprenda que independência garante que cada réplica seja uma amostra idêntica e independente (i.i.d.).",
                                    "Compare réplicas dependentes (mesma semente) vs. independentes em um diagrama.",
                                    "Calcule manualmente variância de média de réplicas correlacionadas vs. independentes.",
                                    "Discuta impacto na confiança dos intervalos de confiança."
                                  ],
                                  "verification": "Crie um diagrama comparando réplicas dependentes e independentes; explique diferenças em variância.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou planilha para variância",
                                    "Artigo de Banks et al. (2000)"
                                  ],
                                  "tips": [
                                    "Lembre: independência é chave para CLT (Teorema Central do Limite)",
                                    "Visualize com gráficos de distribuições sobrepostas"
                                  ],
                                  "learningObjective": "Justificar a independência estatística para validade de resultados simulados.",
                                  "commonMistakes": [
                                    "Achar que mais réplicas sempre compensam dependência",
                                    "Confundir independência com identicidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Dominar o uso de sementes diferentes para garantir independência",
                                  "subSteps": [
                                    "Entenda geradores de números pseudo-aleatórios (PRNG) e seu estado inicial (semente).",
                                    "Aprenda que mesma semente produz mesma sequência; sementes diferentes geram sequências independentes.",
                                    "Liste métodos para gerar sementes únicas: incrementais, baseadas em tempo, hash.",
                                    "Implemente em pseudocódigo: loop de réplicas com seed = i para i=1 a n.",
                                    "Teste com um PRNG simples para ver sequências diferentes."
                                  ],
                                  "verification": "Gere 3 sequências aleatórias com sementes 1, 2, 3 e confirme que são distintas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código ou Python/R com random.seed()",
                                    "Documentação de PRNG"
                                  ],
                                  "tips": [
                                    "Sempre documente sementes para reprodutibilidade",
                                    "Evite sementes zero ou padrões ruins"
                                  ],
                                  "learningObjective": "Configurar sementes para réplicas independentes em simulações.",
                                  "commonMistakes": [
                                    "Reusar semente acidentalmente",
                                    "Usar sementes não numéricas sem hash"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir e validar réplicas independentes em uma simulação prática",
                                  "subSteps": [
                                    "Defina um experimento: 10 réplicas independentes de uma simulação simples (ex: fila M/M/1).",
                                    "Configure o código para variar sementes por réplica.",
                                    "Execute e colete estatísticas (média, variância, IC).",
                                    "Teste independência: verifique se covariâncias são próximas de zero.",
                                    "Compare com réplicas dependentes para demonstrar diferença."
                                  ],
                                  "verification": "Produza relatório com tabelas de resultados independentes vs. dependentes, mostrando menor variância nos independentes.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Software de simulação (AnyLogic, SimPy Python, ou Excel)",
                                    "Código template para fila"
                                  ],
                                  "tips": [
                                    "Use 30-50 réplicas iniciais para testes",
                                    "Salve sementes em log"
                                  ],
                                  "learningObjective": "Implementar e validar definição de réplicas independentes.",
                                  "commonMistakes": [
                                    "Não resetar estado do simulador entre réplicas",
                                    "Ignorar warm-up em cada réplica"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila M/M/1 (chegada λ=4/h, serviço μ=5/h), defina 20 réplicas independentes usando sementes 1001 a 1020. Cada réplica roda por 1000 horas após warm-up de 100h. Calcule tempo médio na fila; independência garante IC de 95% confiável, conforme Banks et al. (2000).",
                              "finalVerifications": [
                                "Explicar réplicas independentes citando Banks et al. (2000).",
                                "Demonstrar configuração de sementes diferentes em código.",
                                "Calcular variância reduzida com independência.",
                                "Identificar erros em setups dependentes.",
                                "Produzir IC válido de uma simulação com réplicas.",
                                "Discutir reprodutibilidade vs. independência."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição conceitual (80%+ correto).",
                                "Correta implementação de sementes (sequências distintas).",
                                "Análise estatística válida (IC correto).",
                                "Identificação de pitfalls comuns.",
                                "Relatório claro com exemplos e validações.",
                                "Conexão com independência i.i.d."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Teorema Central do Limite e intervalos de confiança.",
                                "Programação: Geradores pseudo-aleatórios e controle de estado.",
                                "Ciência de Dados: Simulações Monte Carlo e validação.",
                                "Engenharia Industrial: Planejamento de experimentos em manufatura."
                              ],
                              "realWorldApplication": "Em modelagem de tráfego urbano, réplicas independentes com sementes únicas simulam variações diárias, permitindo previsões confiáveis de congestionamentos para planejamento de infraestrutura, reduzindo custos em milhões."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.1.2",
                            "name": "Identificar fontes de variância em réplicas",
                            "description": "Analisar as fontes de variância aleatória em simulações discretas e como réplicas independentes capturam essa variância para médias mais precisas, referenciando métodos de geração de variáveis aleatórias (Kelton & Law, 1991).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Variância em Simulações Discretas",
                                  "subSteps": [
                                    "Defina variância como a medida de dispersão dos resultados em uma simulação estocástica.",
                                    "Explique como simulações discretas geram eventos aleatórios, como chegadas em uma fila.",
                                    "Diferencie variância aleatória (devido à aleatoriedade inerente) de variância sistemática (devido a parâmetros fixos).",
                                    "Revise a fórmula da variância amostral: σ² = Σ(xi - μ)² / (n-1).",
                                    "Discuta o impacto da variância na precisão das estimativas de médias."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos de variância e forneça um exemplo simples de simulação discreta.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro Kelton & Law (1991), seção sobre variância",
                                    "Calculadora ou software como Excel para cálculos básicos"
                                  ],
                                  "tips": "Use diagramas de fluxo para visualizar eventos discretos e sua aleatoriedade.",
                                  "learningObjective": "Entender o papel fundamental da variância nas simulações estocásticas discretas.",
                                  "commonMistakes": [
                                    "Confundir variância com desvio padrão",
                                    "Ignorar que variância é sempre positiva"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Fontes de Variância Aleatória em Réplicas",
                                  "subSteps": [
                                    "Liste fontes comuns: sementes de geradores de números aleatórios (RNG), condições iniciais variáveis e interações estocásticas.",
                                    "Analise como diferentes sementes em RNG produzem réplicas independentes com variância similar.",
                                    "Examine o efeito de réplicas curtas vs. longas na captura de variância.",
                                    "Compare variância observada em uma única réplica vs. múltiplas réplicas.",
                                    "Registre fontes específicas para um sistema discreto, como tempo de serviço em uma fila M/M/1."
                                  ],
                                  "verification": "Crie uma tabela listando 5 fontes de variância e exemplos para uma simulação de fila.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de simulação como SimPy (Python) ou Arena",
                                    "Papel e caneta para tabela"
                                  ],
                                  "tips": "Sempre inicialize RNG com sementes diferentes para independência.",
                                  "learningObjective": "Identificar e categorizar fontes precisas de variância aleatória em réplicas.",
                                  "commonMistakes": [
                                    "Atribuir variância sistemática à aleatoriedade",
                                    "Usar a mesma semente em todas as réplicas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o Papel das Réplicas Independentes na Captura de Variância",
                                  "subSteps": [
                                    "Execute 5 réplicas independentes de uma simulação discreta simples (ex: fila única servidor).",
                                    "Calcule a média e variância de cada réplica individualmente.",
                                    "Compute a variância das médias das réplicas (variância da média amostral).",
                                    "Observe como mais réplicas reduzem a variância da média estimada.",
                                    "Interprete resultados usando o teorema do limite central para precisão."
                                  ],
                                  "verification": "Gere gráficos de médias e intervalos de confiança para 3, 5 e 10 réplicas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com NumPy e Matplotlib",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Use intervalos de confiança de 95% para visualizar redução de variância.",
                                  "learningObjective": "Demonstrar empiricamente como réplicas capturam e estabilizam variância para médias precisas.",
                                  "commonMistakes": [
                                    "Réplicas não independentes devido a sementes iguais",
                                    "Confundir variância total com variância da média"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Referenciar Métodos de Geração de Variáveis Aleatórias e Conectar à Precisão",
                                  "subSteps": [
                                    "Estude métodos de RNG do Kelton & Law (1991): congruencial linear, Mersenne Twister.",
                                    "Explique como qualidade do RNG afeta variância em simulações discretas.",
                                    "Conecte inversa transformada e métodos de aceitação-rejeição à geração de eventos discretos.",
                                    "Avalie impacto de um bom RNG na consistência da variância entre réplicas.",
                                    "Discuta planejamento: número de réplicas baseado em variância esperada do RNG."
                                  ],
                                  "verification": "Escreva um relatório curto citando Kelton & Law e propondo 3 melhorias em RNG para reduzir variância.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Kelton & Law (1991), capítulos sobre RNG",
                                    "Documentação Python random module"
                                  ],
                                  "tips": "Teste diferentes RNGs e compare histogramas de distribuições geradas.",
                                  "learningObjective": "Integrar teoria de RNG à análise de variância em réplicas para planejamento preciso.",
                                  "commonMistakes": [
                                    "Subestimar ciclo do RNG levando a dependência entre réplicas",
                                    "Ignorar autocorrelação em séries temporais"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado (M/M/1), execute 10 réplicas independentes com sementes diferentes. Identifique variância de tempos de espera devido a chegadas Poisson aleatórias. Calcule médias: uma réplica mostra 5.2 min (alta variância), mas 10 réplicas convergem para 4.8 min ± 0.3 min, demonstrando captura de variância.",
                              "finalVerifications": [
                                "Lista corretamente pelo menos 4 fontes de variância aleatória em réplicas.",
                                "Calcula variância da média amostral de réplicas com precisão.",
                                "Gera gráficos mostrando redução de variância com mais réplicas.",
                                "Cita Kelton & Law corretamente em contexto de RNG.",
                                "Propõe número ótimo de réplicas baseado em análise de variância.",
                                "Diferencia variância aleatória de sistemática em exemplos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de fontes de variância (80% cobertura).",
                                "Correção matemática em cálculos de variância e médias.",
                                "Qualidade dos gráficos e visualizações empíricas.",
                                "Profundidade na referência a métodos RNG e impactos.",
                                "Clareza na explicação de como réplicas melhoram precisão.",
                                "Originalidade no exemplo prático fornecido."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Teorema do Limite Central e Intervalos de Confiança.",
                                "Programação: Implementação de RNG em Python/R.",
                                "Probabilidade: Distribuições discretas como Poisson e Exponencial.",
                                "Engenharia Industrial: Planejamento de experimentos em simulação de manufatura."
                              ],
                              "realWorldApplication": "Em telecomunicações, identificar variância em réplicas de simulações de redes para otimizar buffers e reduzir latência; em logística, planejar réplicas para estimar tempos de entrega precisos em cadeias de suprimentos estocásticas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.1.3",
                            "name": "Gerar réplicas independentes na prática",
                            "description": "Demonstrar como configurar sementes diferentes em linguagens de simulação para executar réplicas independentes, incluindo exemplos em software como Arena ou Simio.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de sementes aleatórias e réplicas independentes",
                                  "subSteps": [
                                    "Estude a definição de réplicas independentes: execuções idênticas do modelo com streams aleatórios diferentes para capturar variabilidade.",
                                    "Aprenda sobre geradores de números pseudoaleatórios (PRNG) e como sementes inicializam sequências únicas.",
                                    "Identifique por que réplicas independentes são essenciais para estimativas confiáveis em simulações estocásticas.",
                                    "Revise exemplos teóricos de dependência vs. independência em streams aleatórios.",
                                    "Anote diferenças entre réplicas independentes e runs com a mesma semente."
                                  ],
                                  "verification": "Resuma em 3-5 frases o papel das sementes em réplicas independentes e liste 2 vantagens.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação de Arena/Simio sobre random streams; vídeo tutorial introdutório (ex: YouTube 'Simulation Replication').",
                                  "tips": "Use diagramas para visualizar streams aleatórios paralelos em réplicas.",
                                  "learningObjective": "Explicar como sementes garantem independência em réplicas de simulação.",
                                  "commonMistakes": "Confundir semente com número aleatório único; assumir que runs sem mudança de semente são independentes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar sementes diferentes em Arena Simulation",
                                  "subSteps": [
                                    "Abra o Arena e carregue ou crie um modelo estocástico simples (ex: fila única).",
                                    "Acesse as propriedades do módulo Create/Process que usa random streams.",
                                    "Defina múltiplas réplicas no Run Setup > Replication Parameters (ex: 10 réplicas).",
                                    "Ative 'Different Random Number Streams' e atribua Entity Types a streams únicos (ex: Arrival Stream 1, Service Stream 2).",
                                    "Salve e execute uma prévia para confirmar configuração."
                                  ],
                                  "verification": "Execute 2 réplicas e verifique se os resultados iniciais diferem devido a streams independentes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Arena Simulation instalado; modelo de exemplo (Single Queue); manual Arena 'Random Number Streams'.",
                                  "tips": "Comece com poucos réplicas para testes rápidos; documente stream numbers atribuídos.",
                                  "learningObjective": "Configurar réplicas independentes usando streams múltiplos no Arena.",
                                  "commonMistakes": "Esquecer de habilitar 'Different Random Number Streams'; reutilizar o mesmo stream para interarrivals e service."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar sementes diferentes em Simio",
                                  "subSteps": [
                                    "Abra o Simio e carregue um modelo estocástico (ex: sistema de filas MM1).",
                                    "No Experiment ou Scenario, defina Number of Replications > 10.",
                                    "Acesse Random Variations no modelo: crie References para ArrivalProcess e ProcessingTime.",
                                    "Atribua diferentes Random Seeds ou References para cada réplica (ex: Seed1 para chegada, Seed2 para serviço).",
                                    "Execute o experiment e exporte resultados para análise."
                                  ],
                                  "verification": "Confira o Summary Report: valores médios de métricas (ex: Queue Length) variam entre réplicas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Simio instalado; modelo MM1 exemplo; guia Simio 'Replication and Random Seeds'.",
                                  "tips": "Use Tally Statistics para métricas chave; teste com seeds fixas iniciais para debug.",
                                  "learningObjective": "Implementar réplicas independentes via seeds variáveis no Simio.",
                                  "commonMistakes": "Não alterar seeds por réplica; confundir Run Length com Number of Replications."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar, analisar e validar réplicas independentes",
                                  "subSteps": [
                                    "Execute 10+ réplicas em ambos softwares e colete métricas (ex: tempo médio de espera).",
                                    "Calcule estatísticas descritivas: média, desvio padrão, IC 95% usando Excel/R.",
                                    "Teste independência: plote trajetórias de réplicas e verifique sobreposição mínima.",
                                    "Compare resultados entre Arena e Simio para consistência.",
                                    "Documente relatório com gráficos de boxplot das réplicas."
                                  ],
                                  "verification": "IC 95% não inclui zero para variabilidade e réplicas mostram distribuição estável.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Excel/R para análise; relatórios exportados de Arena/Simio.",
                                  "tips": "Warm-up period de 10% do run length para steady-state; use 30+ réplicas para precisão.",
                                  "learningObjective": "Analisar resultados de réplicas para validar independência e precisão.",
                                  "commonMistakes": "Ignorar warm-up, levando a bias; média de poucas réplicas (menos de 5)."
                                }
                              ],
                              "practicalExample": "Em uma simulação de call center com 5 atendentes, configure 20 réplicas independentes no Arena: stream 1 para chegadas Poisson, stream 2 para tempos de serviço exponenciais. Analise variabilidade no tempo de espera médio, obtendo IC 95% de [4.2, 5.8] minutos, confirmando robustez da estimativa de staffing.",
                              "finalVerifications": [
                                "Réplicas produzem resultados estatisticamente diferentes inicialmente mas convergem em médias.",
                                "Intervalos de confiança 95% são estreitos e não sobrepostos excessivamente.",
                                "Gráficos de trajetórias mostram independência (sem padrões correlacionados).",
                                "Métricas chave (ex: throughput) variam dentro de 10-20% entre softwares.",
                                "Relatório inclui semente configs e seeds usadas por réplica.",
                                "Teste de variância entre réplicas é significativo (ANOVA p<0.05)."
                              ],
                              "assessmentCriteria": [
                                "Configuração correta de streams/seeds em ambos softwares (100% match com docs).",
                                "Número adequado de réplicas (mín. 10) com análise estatística completa.",
                                "Verificação de independência via plots e testes (IC válidos).",
                                "Relatório claro com exemplos, erros evitados e conclusões acionáveis.",
                                "Tempo de execução eficiente sem crashes por má config.",
                                "Consistência entre Arena e Simio (diferença <5% em médias)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Cálculo de IC e testes de hipóteses para validade de réplicas.",
                                "Programação: Manipulação de PRNG em linguagens como Python (random.seed()).",
                                "Ciência de Dados: Análise de variabilidade e boxplots em ferramentas como R.",
                                "Engenharia Industrial: Aplicação em DOE para otimização de sistemas.",
                                "Matemática: Teoria de processos estocásticos e lei dos grandes números."
                              ],
                              "realWorldApplication": "Em logística de armazéns (ex: Amazon), réplicas independentes simulam variabilidade diária de pedidos para dimensionar robôs, reduzindo custos em 15% via planejamento robusto de capacidade."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.2.2",
                        "name": "Runs de Simulação e sua Planejamento",
                        "description": "Planejamento das execuções (runs) de simulação, incluindo distinção entre runs de aquecimento, steady-state e terminais, para otimizar o experimento.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.2.1",
                            "name": "Diferenciar tipos de runs",
                            "description": "Distinguir runs de transiente (warm-up) de runs em regime permanente (steady-state), explicando o impacto no planejamento de réplicas para resultados confiáveis (Pidd, 1998).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de run transiente (warm-up)",
                                  "subSteps": [
                                    "Defina run transiente como a fase inicial de uma simulação onde o sistema ainda não atingiu equilíbrio.",
                                    "Identifique características: flutuações iniciais devido a condições iniciais artificiais.",
                                    "Estude exemplos em simulações de filas ou produção, onde o warm-up distorce estatísticas iniciais.",
                                    "Analise o período típico de warm-up (ex.: 10-20% do tempo total de simulação).",
                                    "Registre impactos: médias enviesadas se incluídas nos resultados."
                                  ],
                                  "verification": "Explique em suas palavras o que é warm-up e dê um exemplo de distorção em uma simulação simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de Pidd (1998), simulador de filas (ex.: Simul8 ou AnyLogic trial), notas de aula.",
                                  "tips": "Visualize com gráficos de evolução temporal de métricas como tempo médio na fila.",
                                  "learningObjective": "Identificar e descrever a fase transiente em simulações discretas.",
                                  "commonMistakes": "Confundir warm-up com variabilidade natural; ignorar que condições iniciais artificiais causam o problema."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o conceito de run em regime permanente (steady-state)",
                                  "subSteps": [
                                    "Defina steady-state como a fase onde estatísticas se estabilizam e refletem comportamento de longo prazo.",
                                    "Discuta como detectar: plotar gráficos de médias móveis ou usar testes estatísticos (ex.: Welch's test).",
                                    "Compare com transiente: steady-state ignora warm-up para resultados confiáveis.",
                                    "Calcule o comprimento necessário: baseie em análise de autocorrelação ou inspeção visual.",
                                    "Exemplifique em sistemas ergódicos onde médias convergem."
                                  ],
                                  "verification": "Crie um gráfico de simulação mostrando transição para steady-state e marque o ponto de corte.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de simulação (Python com SimPy ou Arena), planilhas para gráficos.",
                                  "tips": "Use janelas deslizantes para médias para visualizar estabilização.",
                                  "learningObjective": "Reconhecer e quantificar a fase de regime permanente em runs de simulação.",
                                  "commonMistakes": "Assumir steady-state imediato; não verificar convergência estatística."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar tipos de runs e suas características chave",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: warm-up vs. steady-state (duração, métricas afetadas, detecção).",
                                    "Explique critérios de diferenciação: visual (gráficos), estatístico (testes de estacionariedade).",
                                    "Simule cenários: rode uma simulação e identifique manualmente o fim do warm-up.",
                                    "Discuta referências: Pidd (1998) sobre exclusão de warm-up para ICs precisas.",
                                    "Pratique rotulando fases em runs múltiplos."
                                  ],
                                  "verification": "Preencha tabela comparativa e aplique a uma simulação real, justificando cortes.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Tabela em Excel/Google Sheets, simulador, PDF de Pidd (1998).",
                                  "tips": "Sempre compare múltiplos runs para validar diferenciação.",
                                  "learningObjective": "Distinguir precisamente entre transiente e steady-state com evidências.",
                                  "commonMistakes": "Cortar warm-up muito cedo/tarde; ignorar variabilidade entre réplicas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar impacto no planejamento de réplicas para resultados confiáveis",
                                  "subSteps": [
                                    "Descreva como excluir warm-up melhora precisão de intervalos de confiança (ICs).",
                                    "Planeje réplicas: determine número baseado em steady-state (ex.: 10-30 runs).",
                                    "Calcule: use fórmulas de half-width para tamanho de réplicas pós-warm-up.",
                                    "Simule planejamento: compare resultados com/sem exclusão de warm-up.",
                                    "Documente protocolo: defina regras fixas ou adaptativas para runs futuros."
                                  ],
                                  "verification": "Elabore um plano de réplicas para uma simulação, mostrando ICs melhorados.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Calculadora estatística (R ou Python), exemplos de simulações anteriores.",
                                  "tips": "Priorize steady-state para planejamento; teste sensibilidade ao comprimento de warm-up.",
                                  "learningObjective": "Aplicar diferenciação de runs ao planejamento eficiente de experimentos.",
                                  "commonMistakes": "Subestimar réplicas necessárias; incluir warm-up em agregações."
                                }
                              ],
                              "practicalExample": "Em uma simulação de supermercado (fila M/M/1), o warm-up inicial mostra filas vazias (condição artificial), distorcendo tempo médio de espera. Corte após 100 clientes para steady-state, onde médias estabilizam em 5 minutos; planeje 20 réplicas de 1000 clientes cada para IC de 95%.",
                              "finalVerifications": [
                                "Explique diferenças entre warm-up e steady-state sem consultar notas.",
                                "Identifique fases corretamente em um gráfico de simulação fornecido.",
                                "Planeje réplicas para uma simulação dada, justificando exclusão de warm-up.",
                                "Calcule impacto em ICs com e sem steady-state.",
                                "Crie tabela comparativa precisa.",
                                "Simule e valide um experimento completo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e diferenciação de tipos de runs (80%+ acerto).",
                                "Uso correto de métodos de detecção (gráficos/testes estatísticos).",
                                "Planejamento de réplicas reflete impacto no steady-state.",
                                "Exemplos práticos relevantes e corretos.",
                                "Ausência de erros comuns como corte inadequado de warm-up.",
                                "Clareza na explicação do impacto em resultados confiáveis."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Testes de estacionariedade e intervalos de confiança.",
                                "Programação: Implementação de simulações em Python/SimPy para detecção automática.",
                                "Engenharia Industrial: Otimização de sistemas de produção/manufatura.",
                                "Pesquisa Operacional: Planejamento de experimentos em modelagem.",
                                "Análise de Dados: Visualização e tratamento de séries temporais."
                              ],
                              "realWorldApplication": "Em logística de armazéns (ex.: Amazon), diferenciar warm-up evita superestimação de throughput inicial; planejar réplicas em steady-state garante decisões confiáveis em expansão de capacidade, reduzindo custos operacionais em 10-20%."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.2.2",
                            "name": "Planejar duração de runs",
                            "description": "Determinar o comprimento adequado de cada run usando técnicas como análise de Welch para eliminar período de warm-up e estabilizar estatísticas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Executar simulações preliminares para coletar dados iniciais",
                                  "subSteps": [
                                    "Configure uma simulação inicial do sistema discreto com duração longa (ex: 10x o tempo esperado de estabilização).",
                                    "Registre métricas chave ao longo do tempo, como média de fila, taxa de utilização e tempo de espera.",
                                    "Colete dados em intervalos regulares (ex: a cada 100 unidades de tempo) para plotagem de séries temporais.",
                                    "Repita a simulação 5-10 vezes para capturar variabilidade.",
                                    "Salve os dados em formato tabular para análise posterior."
                                  ],
                                  "verification": "Verifique se os dados preliminares foram coletados e plotados, mostrando tendências iniciais de warm-up.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": "Software de simulação (Arena, Simio ou Python com SimPy), planilha para dados (Excel ou Pandas).",
                                  "tips": "Use sementes aleatórias diferentes para cada replicata para garantir independência.",
                                  "learningObjective": "Compreender a necessidade de dados preliminares para identificar padrões de warm-up.",
                                  "commonMistakes": "Executar simulações muito curtas que não capturam o warm-up completo; ignorar variabilidade entre runs."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar o período de warm-up usando análise de Welch",
                                  "subSteps": [
                                    "Divida os dados em janelas móveis sobrepostas (ex: tamanho de janela = 50% do total).",
                                    "Calcule a média móvel e variância para cada métrica em cada janela.",
                                    "Aplique o procedimento de Welch: compare médias de janelas iniciais vs. finais usando teste t de Welch.",
                                    "Determine o ponto de corte onde as médias estabilizam (p-valor > 0.05).",
                                    "Plote o gráfico de Welch para visualização (média cumulativa vs. tempo)."
                                  ],
                                  "verification": "Confirme o gráfico de Welch mostrando o ponto de warm-up eliminado (ex: tempo W onde estabiliza).",
                                  "estimatedTime": "3-4 horas",
                                  "materials": "Python (bibliotecas SciPy, Matplotlib) ou R para análise estatística; dados preliminares do step 1.",
                                  "tips": "Comece com janelas maiores se o sistema for ruidoso para reduzir falsos positivos.",
                                  "learningObjective": "Dominar a análise de Welch para detectar objetivamente o período de warm-up.",
                                  "commonMistakes": "Usar janelas fixas sem sobreposição, levando a detecção imprecisa; confundir variância com warm-up."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar o comprimento da run para estabilização de estatísticas",
                                  "subSteps": [
                                    "Exclua o período de warm-up (0 a W) dos dados.",
                                    "Calcule o comprimento necessário para atingir precisão desejada (ex: erro relativo < 5%) usando fórmula de confiança: n = (Z * CV / RE)^2, onde CV é coeficiente de variação.",
                                    "Simule runs truncadas pós-warm-up e monitore convergência de médias e ICs.",
                                    "Ajuste iterativamente o comprimento até que as estatísticas estabilizem (ex: IC constante).",
                                    "Defina o comprimento final como múltiplo do tempo de ciclo médio do sistema."
                                  ],
                                  "verification": "Documente o comprimento final da run com cálculos de precisão e gráficos de convergência.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": "Ferramentas estatísticas (Python NumPy/SciPy), gráficos de convergência.",
                                  "tips": "Monitore múltiplas métricas simultaneamente para o gargalo mais lento a estabilizar.",
                                  "learningObjective": "Calcular comprimentos de run que garantam estatísticas confiáveis e eficientes.",
                                  "commonMistakes": "Subestimar variabilidade pós-warm-up, resultando em runs curtas com ICs largos; ignorar correlações temporais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e otimizar o planejamento de duração de runs",
                                  "subSteps": [
                                    "Execute 3-5 runs completas com o comprimento planejado e compare estatísticas.",
                                    "Verifique se os ICs são estreitos e consistentes entre runs.",
                                    "Ajuste se necessário (ex: aumentar 20% se variância alta).",
                                    "Documente o plano final: warm-up W, run length R, número de replicatas.",
                                    "Teste sensibilidade variando parâmetros do sistema."
                                  ],
                                  "verification": "Relatório com runs validadas, ICs < alvo e plano documentado.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": "Software de simulação, relatório template.",
                                  "tips": "Automatize validação com scripts para eficiência em sistemas complexos.",
                                  "learningObjective": "Validar empiricamente o planejamento para robustez.",
                                  "commonMistakes": "Não validar com replicatas independentes; overfitar a um cenário específico."
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado (M/M/1), dados preliminares mostram warm-up de 200 min até estabilização da fila média. Análise de Welch corta aos 180 min. Comprimento da run calculado em 1000 min para erro <5% na taxa de serviço, validado com 5 runs onde IC da média de espera é 2.1 ± 0.1 min.",
                              "finalVerifications": [
                                "Gráficos de Welch confirmam eliminação precisa do warm-up.",
                                "Comprimento da run resulta em ICs estreitos (<10% da média).",
                                "Estatísticas estabilizam consistentemente entre replicatas.",
                                "Plano documentado inclui W, R e justificativa estatística.",
                                "Teste de sensibilidade cobre variações de 20% nos parâmetros.",
                                "Tempo total de simulação otimizado (redução >20% vs. runs iniciais longas)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de warm-up via Welch (erro <10% do tempo real).",
                                "Cálculo correto de comprimento de run baseado em precisão desejada.",
                                "Validação empírica com pelo menos 3 replicatas independentes.",
                                "Documentação clara com gráficos, fórmulas e justificativas.",
                                "Eficiência: plano reduz tempo de simulação sem perda de precisão.",
                                "Tratamento de erros comuns como variância alta ou correlações."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Testes de hipóteses (t de Welch), intervalos de confiança.",
                                "Programação: Simulação em Python/SimPy, análise de dados com Pandas/SciPy.",
                                "Engenharia Industrial: Otimização de processos em manufatura e logística.",
                                "Matemática: Séries temporais, convergência estatística."
                              ],
                              "realWorldApplication": "Em fábricas, planejar duração de simulações para otimizar linhas de produção, eliminando warm-up para decisões precisas em alocação de recursos; em call centers, estabilizar métricas de tempo de espera para dimensionamento de equipes, economizando milhões em simulações desnecessárias."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.2.3",
                            "name": "Otimizar número de runs por réplica",
                            "description": "Calcular o número de runs necessários por réplica considerando trade-offs entre precisão e custo computacional em simulações discretas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Réplicas e Runs",
                                  "subSteps": [
                                    "Defina réplicas como execuções independentes de um cenário para capturar variabilidade.",
                                    "Explique runs como o número de iterações por réplica para estimar médias com precisão.",
                                    "Identifique trade-offs: mais runs aumentam precisão (menor variância) mas elevam custo computacional.",
                                    "Revise métricas chave: variância amostral, erro padrão e intervalo de confiança.",
                                    "Estude fórmulas básicas: n = (Z * σ / E)^2, onde n é runs, Z é score Z, σ variância, E erro desejado."
                                  ],
                                  "verification": "Resuma os conceitos em um diagrama ou tabela comparando cenários com 10, 50 e 100 runs.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação de simulações discretas",
                                    "Calculadora ou planilha Excel",
                                    "Artigos sobre Monte Carlo"
                                  ],
                                  "tips": "Use analogias como lançar moedas múltiplas vezes para estimar probabilidade.",
                                  "learningObjective": "Dominar definições e relações entre precisão, custo e número de runs.",
                                  "commonMistakes": [
                                    "Confundir réplicas com runs",
                                    "Ignorar independência das execuções"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Variância e Erro Padrão em Simulações Discretas",
                                  "subSteps": [
                                    "Execute uma simulação piloto com 10-20 runs para coletar dados de saída (ex: tempo médio de espera).",
                                    "Calcule a variância amostral: σ² = Σ(xi - μ)^2 / (n-1).",
                                    "Determine o erro padrão: SE = σ / √n.",
                                    "Defina níveis de precisão desejados (ex: erro < 5% do valor médio).",
                                    "Teste com dados sintéticos gerados em Python ou R para validar cálculos."
                                  ],
                                  "verification": "Produza uma tabela com variância e SE para diferentes tamanhos de amostra piloto.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software de simulação (Python com NumPy/SciPy)",
                                    "Planilha para cálculos",
                                    "Dataset piloto de simulação discreta"
                                  ],
                                  "tips": "Sempre use n-1 para variância amostral em populações desconhecidas.",
                                  "learningObjective": "Aplicar fórmulas estatísticas para quantificar incerteza em simulações.",
                                  "commonMistakes": [
                                    "Usar variância populacional em vez de amostral",
                                    "Arredondar prematuramente valores"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar Número Ótimo de Runs Usando Fórmulas Estatísticas",
                                  "subSteps": [
                                    "Escolha nível de confiança (ex: 95%, Z=1.96) e erro relativo desejado (E).",
                                    "Aplique fórmula: n = (Z * CV / α)^2, onde CV é coeficiente de variação, α erro relativo.",
                                    "Ajuste para cenários discretos considerando distribuição (normal aproximada para n grande).",
                                    "Itere: rode n calculado, recalcule variância e refine se necessário.",
                                    "Compare com métodos alternativos como bootstrap para validação."
                                  ],
                                  "verification": "Calcule n para um caso com σ=10, E=2, Z=1.96 e verifique se SE < E após simulação.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Código Python para simulação e cálculo automático",
                                    "Tabelas de Z-scores",
                                    "Ferramenta de bootstrap (ex: boot em R)"
                                  ],
                                  "tips": "Comece com aproximações conservadoras (maior n) para evitar subestimação.",
                                  "learningObjective": "Calcular runs necessários equilibrando precisão estatística e viabilidade.",
                                  "commonMistakes": [
                                    "Não verificar normalidade da distribuição",
                                    "Ignorar custos não lineares de computação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Trade-offs e Otimizar Configuração Final",
                                  "subSteps": [
                                    "Estime custo computacional: tempo por run * n * réplicas.",
                                    "Crie gráfico de trade-off: precisão (1/SE) vs custo total.",
                                    "Otimize usando análise de sensibilidade: varie E e observe impacto.",
                                    "Defina critérios de parada: quando ganho de precisão < custo incremental.",
                                    "Documente decisão final com justificativa quantitativa."
                                  ],
                                  "verification": "Gere relatório com gráfico e recomendação de n ótimo (ex: 50 runs por réplica).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Matplotlib/Seaborn para gráficos",
                                    "Planilha de otimização",
                                    "Simulador discreto pronto"
                                  ],
                                  "tips": "Use escalonamento paralelo se disponível para mitigar custos altos.",
                                  "learningObjective": "Balancear múltiplos objetivos em planejamento de experimentos.",
                                  "commonMistakes": [
                                    "Focar só em precisão ignorando orçamento",
                                    "Não considerar variabilidade entre réplicas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila M/M/1 (supermercado), com tempo médio de espera μ=5min e σ=3min, calcule n para E=0.5min (95% confiança). Resultado: n≈ (1.96*3/0.5)^2 ≈ 146 runs por réplica. Compare custo: 146 runs = 2h vs 50 runs=40min com SE maior.",
                              "finalVerifications": [
                                "Calcule corretamente n para dados dados (σ=20, E=4, 95%).",
                                "Interprete trade-off em gráfico de precisão vs custo.",
                                "Ajuste n após piloto e valide com intervalo de confiança.",
                                "Explique impacto de réplicas vs runs em variância total.",
                                "Documente decisão com métricas quantitativas."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos estatísticos (variância, SE, n) >95% acurácia.",
                                "Análise de trade-offs inclui gráficos e sensibilidade.",
                                "Otimização considera custo real (tempo CPU).",
                                "Verificações finais mostram convergência adequada.",
                                "Relatório claro e acionável para planejamento."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Inferência e intervalos de confiança.",
                                "Programação: Implementação de simulações em Python/R.",
                                "Otimização: Análise de Pareto para multi-objetivos.",
                                "Gestão de Projetos: Planejamento de recursos computacionais."
                              ],
                              "realWorldApplication": "Em engenharia de tráfego, otimizar runs em simulações de semáforos reduz tempo de calibração de dias para horas, economizando custos em supercomputadores para planejamento urbano sustentável."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.2.3",
                        "name": "Determinação do Número de Réplicas para Confiabilidade",
                        "description": "Métodos estatísticos para calcular o número mínimo de réplicas independentes e runs, visando intervalos de confiança com precisão desejada e redução de variância.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.3.1",
                            "name": "Calcular número de réplicas via intervalo de confiança",
                            "description": "Aplicar a fórmula para o número de réplicas n = (z * σ / E)^2, onde z é o valor crítico, σ a variância piloto e E o erro desejado, para garantir resultados confiáveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de intervalo de confiança e réplicas",
                                  "subSteps": [
                                    "Defina o que é um intervalo de confiança (IC) em termos de estimativa de parâmetros populacionais.",
                                    "Explique o papel das réplicas em experimentos de simulação: múltiplas execuções independentes para reduzir variabilidade.",
                                    "Identifique os componentes da fórmula n = (z * σ / E)^2: z (valor crítico), σ (desvio padrão piloto), E (erro desejado).",
                                    "Discuta por que o número de réplicas garante confiabilidade nos resultados de simulações.",
                                    "Revise suposições: normalidade aproximada e independência das réplicas."
                                  ],
                                  "verification": "Resuma em suas palavras os componentes da fórmula e o propósito das réplicas, sem consultar materiais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro de Estatística ou referência online sobre IC",
                                    "Anotações pessoais"
                                  ],
                                  "tips": "Use analogias como 'réplicas são como repetições de um experimento para confiança nos resultados médios'.",
                                  "learningObjective": "Entender a base teórica da fórmula para cálculo de réplicas.",
                                  "commonMistakes": [
                                    "Confundir σ com variância (use desvio padrão)",
                                    "Ignorar suposições de normalidade",
                                    "Pensar que mais réplicas sempre melhoram sem custo computacional"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar simulação piloto para estimar σ",
                                  "subSteps": [
                                    "Configure uma simulação simples do sistema (ex: fila M/M/1).",
                                    "Execute 10-20 réplicas iniciais e calcule a média e o desvio padrão dos resultados.",
                                    "Use a fórmula de desvio padrão amostral: σ = sqrt(Σ(xi - x̄)^2 / (m-1)), onde m é o número de réplicas piloto.",
                                    "Registre σ com pelo menos 2 casas decimais.",
                                    "Valide se o piloto é representativo do sistema real."
                                  ],
                                  "verification": "Calcule σ para um conjunto de dados piloto fornecido e compare com valor esperado.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Software de simulação (Python com SimPy ou Arena)",
                                    "Planilha Excel para cálculos"
                                  ],
                                  "tips": "Comece com poucas réplicas para agilizar; aumente se variância alta.",
                                  "learningObjective": "Adquirir habilidade prática em estimar variância via simulação piloto.",
                                  "commonMistakes": [
                                    "Usar poucas réplicas piloto (mínimo 10)",
                                    "Confundir desvio padrão com variância",
                                    "Não garantir independência das runs"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar z e E com base nos requisitos",
                                  "subSteps": [
                                    "Escolha o nível de confiança (ex: 95% → z=1.96; 99% → z=2.576) consultando tabela z.",
                                    "Defina E como fração da média esperada ou valor absoluto desejado (ex: E=1 minuto).",
                                    "Considere trade-offs: maior confiança ou menor erro aumenta n.",
                                    "Documente justificativa para escolhas de z e E.",
                                    "Arredonde z para valores padrão da tabela normal."
                                  ],
                                  "verification": "Para cenários dados (95% confiança, E=2), identifique z e E corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela de valores z críticos",
                                    "Calculadora"
                                  ],
                                  "tips": "Memorize z para 90%,95%,99%; use ferramentas online para tabelas.",
                                  "learningObjective": "Selecionar parâmetros apropriados para o contexto da simulação.",
                                  "commonMistakes": [
                                    "Usar z=1.96 para 90% (é z=1.645)",
                                    "Definir E muito pequeno sem considerar custo computacional",
                                    "Ignorar unidades de E (deve combinar com σ)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a fórmula para calcular n",
                                  "subSteps": [
                                    "Calcule o numerador: z * σ.",
                                    "Divida pelo denominador: (z * σ) / E.",
                                    "Eleve ao quadrado: [(z * σ) / E]^2.",
                                    "Arredonde n para cima para o inteiro seguinte (ceil(n)).",
                                    "Verifique dimensionalidade: n deve ser adimensional e inteiro positivo."
                                  ],
                                  "verification": "Insira valores exemplo (z=1.96, σ=5, E=1) e obtenha n=96.04 → 97.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora científica ou Python/Excel"
                                  ],
                                  "tips": "Use funções como CEILING no Excel para arredondamento.",
                                  "learningObjective": "Executar o cálculo preciso da fórmula.",
                                  "commonMistakes": [
                                    "Esquecer de elevar ao quadrado",
                                    "Não arredondar para cima",
                                    "Erro de cálculo em z*σ/E"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar, validar e ajustar o número de réplicas",
                                  "subSteps": [
                                    "Execute n réplicas calculadas e verifique se o IC tem largura ~2E.",
                                    "Compare variância final com piloto; ajuste se necessário.",
                                    "Avalie custo computacional vs. precisão ganha.",
                                    "Documente relatório com n, justificativa e resultados.",
                                    "Teste sensibilidade variando E ou z."
                                  ],
                                  "verification": "Para exemplo prático, confirme que IC atende E desejado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de simulação",
                                    "Ferramentas de plotagem (Matplotlib)"
                                  ],
                                  "tips": "Sempre valide empiricamente: rode n e cheque largura do IC.",
                                  "learningObjective": "Garantir aplicabilidade prática do n calculado.",
                                  "commonMistakes": [
                                    "Não validar com simulação real",
                                    "Ignorar que n pode ser muito alto para simulações lentas",
                                    "Ajustar sem reestimar σ"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila bank M/M/1 com λ=4, μ=5. σ piloto=4.5 minutos (de 15 runs). Para confiança 95% (z=1.96) e E=0.8 minutos, n=(1.96*4.5/0.8)^2 ≈ 30.4 → 31 réplicas. Rode 31 simulações: média≈0.8, IC largura<1.6 confirma precisão.",
                              "finalVerifications": [
                                "Explica corretamente todos componentes da fórmula n = (z * σ / E)^2.",
                                "Calcula n=97 para z=1.96, σ=5, E=1.",
                                "Realiza simulação piloto e estima σ com <10% erro.",
                                "Valida empiricamente que IC tem largura ≤2E.",
                                "Ajusta n se piloto subestima σ.",
                                "Documenta trade-offs de custo vs. precisão."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo da fórmula (erro <1%).",
                                "Correta escolha de z para nível de confiança dado.",
                                "Qualidade da estimativa σ via piloto (m≥10 runs).",
                                "Validação empírica do IC.",
                                "Interpretação contextualizada para simulação.",
                                "Arredondamento correto de n para inteiro superior."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Inferência e testes de hipóteses.",
                                "Programação: Implementação de simulações em Python/R.",
                                "Engenharia Industrial: Otimização de processos simulados.",
                                "Pesquisa Científica: Planejamento experimental DOE.",
                                "Gestão de Projetos: Avaliação de recursos computacionais."
                              ],
                              "realWorldApplication": "Em simulações de Monte Carlo para previsão de riscos em finanças (ex: VaR), calcula réplicas necessárias para IC preciso no risco de portfólio, evitando sub ou super-dimensionamento de poder computacional em clusters de servidores."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.3.2",
                            "name": "Usar réplicas piloto para estimativas iniciais",
                            "description": "Executar um pequeno número de réplicas piloto para estimar variância e iterativamente determinar o número total de réplicas necessárias (Banks et al., 2000).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Planejar e Configurar Réplicas Piloto",
                                  "subSteps": [
                                    "Definir o modelo de simulação e os parâmetros iniciais baseados no experimento principal.",
                                    "Escolher o número inicial de réplicas piloto (tipicamente 3-10, dependendo da complexidade).",
                                    "Configurar sementes aleatórias diferentes para cada réplica para garantir independência.",
                                    "Preparar o ambiente de simulação com scripts ou software apropriado (ex: Python com SimPy ou Arena).",
                                    "Documentar hipóteses sobre variância esperada e critérios de parada iterativa."
                                  ],
                                  "verification": "Verificar se o setup de simulação roda sem erros para uma réplica única e se as sementes estão variadas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software de simulação (ex: Python, R, Arena)",
                                    "Modelo de simulação validado",
                                    "Planilha para registrar configurações"
                                  ],
                                  "tips": "Comece com poucas réplicas para testar viabilidade computacional antes de escalar.",
                                  "learningObjective": "Entender como configurar réplicas independentes para capturar variabilidade inicial.",
                                  "commonMistakes": [
                                    "Usar a mesma semente para todas as réplicas, levando a resultados correlacionados.",
                                    "Ignorar tempo de warmup no modelo de simulação.",
                                    "Não documentar parâmetros, complicando iterações futuras."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar as Réplicas Piloto",
                                  "subSteps": [
                                    "Rodar cada réplica piloto coletando métricas chave (ex: tempo médio de espera, throughput).",
                                    "Registrar estatísticas brutas para cada réplica em uma tabela ou arquivo CSV.",
                                    "Monitorar tempo de execução e recursos computacionais para estimar escalabilidade.",
                                    "Verificar se todas as réplicas completaram sem falhas ou timeouts.",
                                    "Salvar outputs em formato padronizado para análise posterior."
                                  ],
                                  "verification": "Confirmar que dados de todas as réplicas piloto foram coletados e salvos corretamente.",
                                  "estimatedTime": "2-4 horas (dependendo do modelo)",
                                  "materials": [
                                    "Computador com software de simulação",
                                    "Scripts de execução em batch",
                                    "Ferramentas de logging"
                                  ],
                                  "tips": "Use paralelização se possível para acelerar execuções múltiplas.",
                                  "learningObjective": "Executar simulações independentes e coletar dados de forma eficiente.",
                                  "commonMistakes": [
                                    "Parar execuções prematuramente devido a lentidão sem otimizar o modelo.",
                                    "Não registrar metadados como semente e timestamp.",
                                    "Misturar dados de diferentes runs."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Resultados e Estimar Variância",
                                  "subSteps": [
                                    "Calcular estatísticas descritivas: média, desvio padrão e variância amostral das métricas das réplicas piloto.",
                                    "Construir intervalos de confiança preliminares (ex: usando t-Student para amostras pequenas).",
                                    "Visualizar dados com boxplots ou histogramas para detectar outliers ou não-normalidade.",
                                    "Testar hipóteses sobre variância (ex: teste de Levene se aplicável).",
                                    "Documentar estimativa de variância (σ²) para uso na fórmula de número de réplicas."
                                  ],
                                  "verification": "Produzir um relatório com variância estimada e gráficos que mostram consistência nos dados.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Python/R com bibliotecas (numpy, pandas, matplotlib, scipy)",
                                    "Planilha Excel ou Jupyter Notebook"
                                  ],
                                  "tips": "Use fórmulas como n = (z * σ / E)^2 para preview de réplicas totais, onde E é erro desejado.",
                                  "learningObjective": "Aplicar análise estatística básica para quantificar variabilidade em simulações.",
                                  "commonMistakes": [
                                    "Confundir variância amostral com populacional.",
                                    "Ignorar efeitos de warmup ou steady-state.",
                                    "Usar todos os dados sem descartar transient."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Determinar Número Total de Réplicas e Iterar",
                                  "subSteps": [
                                    "Aplicar fórmula iterativa: n_total = f(σ_piloto, precisão desejada, confiança).",
                                    "Comparar n_total estimado com capacidade computacional e ajustar se necessário.",
                                    "Decidir se mais réplicas piloto são needed (ex: se CV > threshold).",
                                    "Planejar run completo com n_total réplicas, incorporando lições do piloto.",
                                    "Documentar decisão final e razões para reprodutibilidade."
                                  ],
                                  "verification": "Gerar um plano final com n_total justificado matematicamente e pronto para execução.",
                                  "estimatedTime": "30 minutos - 1 hora",
                                  "materials": [
                                    "Calculadora ou script para fórmulas estatísticas",
                                    "Documentação do experimento"
                                  ],
                                  "tips": "Itere 1-2 vezes no máximo para evitar overhead; priorize precisão sobre exatidão absoluta.",
                                  "learningObjective": "Usar estimativas piloto para otimizar design experimental de forma iterativa.",
                                  "commonMistakes": [
                                    "Subestimar variância levando a réplicas insuficientes.",
                                    "Não considerar custo computacional no cálculo.",
                                    "Parar iteração prematuramente sem convergência."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado (M/M/1), execute 5 réplicas piloto de 1000 clientes cada. Calcule variância no tempo médio de espera (ex: σ² = 25 min²). Use para estimar n_total = 30 réplicas para erro < 2 min com 95% confiança.",
                              "finalVerifications": [
                                "Variância estimada é consistente com múltiplas runs piloto independentes.",
                                "Número total de réplicas calculado reduz erro abaixo do threshold desejado.",
                                "Gráficos mostram convergência de ICs com réplicas adicionais.",
                                "Plano final é documentado com fórmulas e justificativas.",
                                "Execução piloto não excede 10% do tempo total estimado do experimento.",
                                "Resultados piloto passam em testes de normalidade ou robustez."
                              ],
                              "assessmentCriteria": [
                                "Precisão da estimativa de variância (erro < 20% do verdadeiro).",
                                "Correta aplicação de fórmulas estatísticas para n_total.",
                                "Qualidade da documentação e visualizações.",
                                "Eficiência computacional demonstrada (tempo piloto razoável).",
                                "Capacidade de iterar baseado em resultados iniciais.",
                                "Identificação e mitigação de erros comuns no processo."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Cálculo de variância, intervalos de confiança e testes de hipóteses.",
                                "Programação: Scripts de simulação em batch e análise de dados (Python/R).",
                                "Gestão de Projetos: Planejamento iterativo e otimização de recursos.",
                                "Física/Engenharia: Modelagem estocástica de sistemas reais.",
                                "Pesquisa Científica: Design de experimentos e validação empírica."
                              ],
                              "realWorldApplication": "Em manufatura, simulações de linhas de produção usam réplicas piloto para estimar variância em throughput, otimizando número de runs para decisões de investimento sem desperdício computacional excessivo."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.3.3",
                            "name": "Aplicar critérios de parada sequencial",
                            "description": "Implementar métodos de parada sequencial para decidir quando o número de réplicas é suficiente, monitorando a largura do intervalo de confiança em tempo real.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos dos Critérios de Parada Sequencial",
                                  "subSteps": [
                                    "Estude a definição de critérios de parada sequencial: métodos que decidem dinamicamente o número de réplicas baseado em estatísticas acumuladas.",
                                    "Revise o conceito de intervalo de confiança (IC) para a média de uma simulação, usando a fórmula IC = média ± (t * desvio_padrão / sqrt(n)).",
                                    "Aprenda critérios comuns como parada quando largura do IC < ε (threshold pré-definido).",
                                    "Analise vantagens sobre número fixo de réplicas: eficiência computacional e adaptabilidade.",
                                    "Compare com métodos sequenciais como SPRT (Sequential Probability Ratio Test)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que critérios de parada sequencial são úteis em simulações com variância desconhecida.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação de estatística sequencial (ex: livros como 'Sequential Analysis' de Abraham Wald)",
                                    "Notebook Jupyter para anotações"
                                  ],
                                  "tips": "Comece com exemplos simples de 1D para visualizar o estreitamento do IC.",
                                  "learningObjective": "Entender os princípios teóricos e motivações para usar parada sequencial em experimentos de simulação.",
                                  "commonMistakes": [
                                    "Confundir largura do IC com comprimento total (2 * margem de erro)",
                                    "Ignorar a dependência da variância na decisão de parada"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar o Monitoramento do Intervalo de Confiança em Tempo Real",
                                  "subSteps": [
                                    "Implemente uma função para executar uma réplica única da simulação e coletar a estatística de interesse (ex: média).",
                                    "Crie um loop que acumule réplicas, atualizando média e desvio padrão a cada batch (use Welford's method para estabilidade).",
                                    "Calcule o IC dinâmico usando distribuição t de Student para n pequeno, ou normal para n grande.",
                                    "Defina o threshold ε baseado em requisitos de precisão (ex: ε = 0.05 para tempo médio).",
                                    "Visualize o IC estreitando com plots em tempo real usando matplotlib."
                                  ],
                                  "verification": "Execute 10 réplicas manuais e confirme que o IC é calculado corretamente via print ou gráfico.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python 3.x",
                                    "Bibliotecas: numpy, scipy.stats, matplotlib"
                                  ],
                                  "tips": "Use batches de réplicas (ex: 10 por vez) para reduzir overhead computacional.",
                                  "learningObjective": "Configurar computação incremental de IC para monitoramento sequencial.",
                                  "commonMistakes": [
                                    "Usar desvio padrão populacional em vez de amostral",
                                    "Esquecer de atualizar graus de liberdade na t-Student"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o Algoritmo de Parada Sequencial Completo",
                                  "subSteps": [
                                    "Estruture o algoritmo principal: inicialize contadores, defina ε e α (nível de confiança).",
                                    "No loop: execute batch de réplicas, atualize IC, verifique se largura < ε; se sim, pare.",
                                    "Adicione condições de segurança: máximo de réplicas (ex: 10.000) para evitar loops infinitos.",
                                    "Registre histórico de largura do IC e número de réplicas usadas.",
                                    "Teste com variância conhecida para validar contra número fixo teórico."
                                  ],
                                  "verification": "Rode o algoritmo em uma simulação toy e confirme parada automática com log.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código Python do Step 2",
                                    "Simulador simples (ex: gerador de números aleatórios para variância controlada)"
                                  ],
                                  "tips": "Log tudo em um DataFrame para análise posterior.",
                                  "learningObjective": "Codificar um algoritmo funcional de parada sequencial.",
                                  "commonMistakes": [
                                    "Parar baseado em média em vez de largura do IC",
                                    "Não tratar casos de variância zero ou infinita"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Otimizar a Implementação em Contexto de Simulação",
                                  "subSteps": [
                                    "Integre o algoritmo em uma simulação real de sistema discreto (ex: fila M/M/1).",
                                    "Compare resultados com número fixo de réplicas: verifique se IC final é similar mas com menos réplicas.",
                                    "Analise sensibilidade a ε, batch size e variância inicial.",
                                    "Otimize performance: vetorize cálculos com numpy.",
                                    "Documente o código com comentários e gere relatório de eficiência."
                                  ],
                                  "verification": "Produza um relatório mostrando economia de réplicas (ex: 30% menos) com precisão mantida.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Simulador de filas (ex: simpy ou código custom)",
                                    "Jupyter Notebook para relatórios"
                                  ],
                                  "tips": "Use seed fixo para reprodutibilidade em testes.",
                                  "learningObjective": "Aplicar e validar o método em cenários realistas de simulação.",
                                  "commonMistakes": [
                                    "Sobreestimar economia sem múltiplas runs",
                                    "Ignorar correlação entre réplicas em sistemas com estado"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar Resultados e Realizar Verificações Finais",
                                  "subSteps": [
                                    "Execute múltiplas runs independentes para estimar distribuição do número de réplicas.",
                                    "Calcule métricas: média de réplicas usadas, variância do IC final, taxa de parada precoce.",
                                    "Compare com teoria: verifique se P(largura < ε) ≈ 1-α.",
                                    "Identifique padrões de falha e ajuste hiperparâmetros.",
                                    "Prepare apresentação ou relatório com gráficos de convergência."
                                  ],
                                  "verification": "Gere gráficos mostrando convergência e confirme cobertura do IC (95% contém verdadeiro valor).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Bibliotecas: pandas, seaborn para análise",
                                    "Código dos steps anteriores"
                                  ],
                                  "tips": "Use boxplots para visualizar variabilidade entre runs.",
                                  "learningObjective": "Avaliar robustez e eficiência do critério de parada.",
                                  "commonMistakes": [
                                    "Usar uma única run para validação",
                                    "Confundir cobertura empírica com nominal"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila M/M/1 com taxa de chegada λ=1 e serviço μ=1.2, implemente parada sequencial monitorando o IC do tempo médio no sistema até largura < 0.1. O algoritmo tipicamente para após 500-1500 réplicas, economizando 40% de computação vs. 2000 fixas.",
                              "finalVerifications": [
                                "O algoritmo para automaticamente quando largura do IC < ε.",
                                "O IC final contém o valor verdadeiro em pelo menos 95% das runs independentes.",
                                "Número médio de réplicas é menor que fixo equivalente com mesma precisão.",
                                "Código roda sem erros e é eficiente (tempo < 1 min para 1000 réplicas).",
                                "Histórico de IC mostra estreitamento monotônico.",
                                "Relatório inclui gráficos de convergência e métricas de economia."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Largura média final do IC ≤ ε.",
                                "Eficiência: Redução ≥20% no número médio de réplicas vs. fixo.",
                                "Robustez: Funciona com variâncias de 1 a 100.",
                                "Corretude: Cobertura empírica do IC próxima de 95%.",
                                "Clareza: Código comentado e modular.",
                                "Escalabilidade: Tempo linear com réplicas."
                              ],
                              "crossCurricularConnections": [
                                "Estatística Inferencial (intervalos de confiança dinâmicos)",
                                "Programação Científica (otimização de loops numéricos)",
                                "Otimização Computacional (alocação adaptativa de recursos)",
                                "Simulação e Modelagem (sistemas estocásticos)",
                                "Análise de Dados (monitoramento sequencial em streaming)"
                              ],
                              "realWorldApplication": "Em indústrias como manufatura ou telecom, otimiza simulações de Monte Carlo para previsão de desempenho de sistemas (ex: dimensionamento de servidores), reduzindo tempo de computação em clusters limitados enquanto garante precisão estatística."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.3.4",
                            "name": "Integrar técnicas de redução de variância",
                            "description": "Combinar planejamento de réplicas com técnicas como common random numbers ou antithetic variates para minimizar o número de réplicas requeridas (Kelton & Law, 1991).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Planejamento de Réplicas e Variância em Simulações",
                                  "subSteps": [
                                    "Explique o papel das réplicas na obtenção de intervalos de confiança confiáveis em simulações de Monte Carlo.",
                                    "Calcule o número de réplicas necessário usando a fórmula de precisão: n = (z * σ / E)^2, onde σ é o desvio padrão da média amostral.",
                                    "Identifique fontes de variância em sistemas discretos, como variabilidade em chegadas e serviços em filas.",
                                    "Discuta limitações do planejamento independente de réplicas, como alto custo computacional.",
                                    "Resuma princípios de redução de variância de Kelton & Law (1991)."
                                  ],
                                  "verification": "Crie um diagrama ou tabela resumindo a fórmula de réplicas e fontes de variância; valide com um exemplo numérico simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro 'Simulation Modeling and Analysis' de Kelton & Law (capítulo relevante); calculadora ou planilha (Excel/Google Sheets).",
                                  "tips": "Use exemplos de filas M/M/1 para ilustrar variância; foque em independência das réplicas.",
                                  "learningObjective": "Compreender como a variância impacta o planejamento de réplicas e por que redução é necessária.",
                                  "commonMistakes": "Confundir variância da população com variância amostral; ignorar batching como alternativa inicial."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Técnicas Específicas de Redução de Variância: CRN e Antithetic Variates",
                                  "subSteps": [
                                    "Descreva Common Random Numbers (CRN): usar a mesma sequência de números aleatórios para múltiplos cenários para reduzir variância entre médias.",
                                    "Implemente um exemplo simples de CRN em código para comparar dois sistemas.",
                                    "Explique Antithetic Variates (AV): parear runs com números aleatórios complementares (U e 1-U) para correlação negativa.",
                                    "Compare CRN vs. AV: CRN para diferenças de médias, AV para médias absolutas.",
                                    "Calcule coeficiente de correlação esperado para cada técnica."
                                  ],
                                  "verification": "Gere um relatório curto com pseudocódigo para CRN e AV, incluindo cálculo de correlação simulada.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com NumPy/SciPy ou R; tutoriais online sobre simulação estocástica.",
                                  "tips": "Sempre normalize streams de RNG para CRN; teste com distribuições uniformes primeiro para AV.",
                                  "learningObjective": "Dominar os mecanismos de CRN e AV e suas condições de aplicação.",
                                  "commonMistakes": "Usar CRN para estimativas absolutas (melhor para diferenças); não garantir independência entre pares em AV."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar Técnicas de Redução de Variância ao Planejamento de Réplicas",
                                  "subSteps": [
                                    "Adapte a fórmula de réplicas para cenários correlacionados: n = (z * sqrt(Var(Ȳ1 - Ȳ2)) / E)^2 para CRN.",
                                    "Planeje o número reduzido de réplicas: compare n_independente vs. n_correlacionado.",
                                    "Defina regras para seleção: CRN para comparações de sistemas, AV para precisão em um sistema.",
                                    "Crie um fluxograma de decisão para escolher e aplicar a técnica no planejamento.",
                                    "Simule um piloto para estimar a redução efetiva na variância."
                                  ],
                                  "verification": "Desenvolva uma planilha ou script que calcule n para cenários com e sem redução, mostrando economia >30%.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Planilha Excel com fórmulas; software de simulação (Arena, Simul8 ou Python-SimPy).",
                                  "tips": "Comece com piloto de 10 réplicas para estimar covariância; mire redução de 50% em n.",
                                  "learningObjective": "Integrar quantitativamente CRN/AV ao planejamento para minimizar réplicas.",
                                  "commonMistakes": "Subestimar covariância positiva em CRN (piora variância); ignorar não-linearidades em AV."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar, Testar e Analisar a Integração em uma Simulação Real",
                                  "subSteps": [
                                    "Configure uma simulação de sistema discreto (ex: fila única) com streams de RNG sincronizados para CRN/AV.",
                                    "Execute réplicas planejadas e compute ICs com e sem redução.",
                                    "Compare número de réplicas: valide redução no custo computacional.",
                                    "Analise sensibilidade a parâmetros (tamanho de run, precisão desejada).",
                                    "Documente trade-offs e recomendações baseadas em Kelton & Law."
                                  ],
                                  "verification": "Produza gráficos de IC vs. n_réplicas para métodos independentes vs. reduzidos; confirme narrowing de ICs.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Software de simulação (Python com SimPy/NumPy, R com simmer); dados de entrada sintéticos.",
                                  "tips": "Use batch means para ICs robustos; replique 2x para validar consistência.",
                                  "learningObjective": "Aplicar a integração em prática e quantificar benefícios.",
                                  "commonMistakes": "Não sincronizar corretamente streams RNG; confundir redução de variância com viés."
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila M/M/1 para comparar tempos de espera sob cargas ρ=0.7 vs. ρ=0.9: use CRN com mesma seed para ambos, reduzindo n de 1000 para 200 réplicas independentes, mantendo IC de ±5% com 50% menos tempo de CPU.",
                              "finalVerifications": [
                                "O plano de réplicas integra CRN/AV corretamente, reduzindo n em pelo menos 40%.",
                                "Cálculos de IC mostram variância reduzida via correlação negativa/positiva esperada.",
                                "Implementação em código/simulação roda sem erros de sincronização RNG.",
                                "Análise compara quantitativamente custo computacional pré/pós-redução.",
                                "Relatório cita Kelton & Law com aplicação contextualizada.",
                                "Fluxograma de decisão cobre seleção de técnica."
                              ],
                              "assessmentCriteria": [
                                "Precisão na adaptação de fórmulas para variância correlacionada (90%+ acurácia).",
                                "Profundidade de substeps em implementação (mín. 4 testes de validação).",
                                "Quantificação de redução em réplicas (gráficos + métricas).",
                                "Correta distinção entre CRN (diferenças) e AV (absolutos).",
                                "Análise de trade-offs e sensibilidade (cobertura completa).",
                                "Clareza e estrutura do fluxograma/plano."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Inferência sobre médias com dependência (covariância).",
                                "Programação: Gerenciamento de streams RNG em simulações.",
                                "Otimização: Minimização de custo computacional em experimentos.",
                                "Probabilidade: Propriedades de variates antithetic e correlação."
                              ],
                              "realWorldApplication": "Em manufatura, otimizar linhas de produção comparando layouts com CRN, reduzindo simulações de dias para horas; em finanças, precificar opções com AV para menos runs Monte Carlo em risco VaR."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.3",
                    "name": "Designs Fatoriais e Fracionários",
                    "description": "Aplicação de planos fatoriais completos ou fracionários para explorar interações entre fatores.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.3.1",
                        "name": "Planos Fatoriais Completos",
                        "description": "Conceito fundamental que envolve a execução de todos os possíveis combinação de níveis de fatores em um experimento de simulação para avaliar efeitos principais e interações completas sem aliasing.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.1.1",
                            "name": "Identificar fatores e níveis em experimentos de simulação",
                            "description": "Selecionar variáveis de entrada relevantes (fatores) como taxa de chegada ou tempo de serviço em modelos de simulação discreta e definir níveis realistas (ex: baixo, médio, alto) para análise estatística.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o contexto do sistema e modelo de simulação",
                                  "subSteps": [
                                    "Analise a descrição do sistema real a ser simulado (ex: fila de supermercado).",
                                    "Identifique as saídas principais de interesse (ex: tempo médio de espera).",
                                    "Revise o modelo de simulação discreta, incluindo equações ou lógica de eventos.",
                                    "Liste premissas do modelo e restrições do experimento.",
                                    "Desenhe um diagrama de fluxo do sistema para visualizar interações."
                                  ],
                                  "verification": "Crie um resumo escrito do sistema com diagrama e saídas chave identificadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Descrição do problema",
                                    "Papel e caneta ou software de diagramação (ex: Draw.io)"
                                  ],
                                  "tips": "Foquem em saídas críticas primeiro para guiar a seleção de fatores.",
                                  "learningObjective": "Entender como o contexto define variáveis relevantes no modelo.",
                                  "commonMistakes": "Ignorar premissas do modelo, levando a fatores irrelevantes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Listar variáveis de entrada potenciais (fatores candidatos)",
                                  "subSteps": [
                                    "Brainstorm todas as variáveis de entrada no modelo (ex: taxa de chegada λ, tempo de serviço μ).",
                                    "Classifique-as por tipo: contínuas, discretas, determinísticas ou estocásticas.",
                                    "Consulte literatura ou dados reais para variáveis comuns em simulações semelhantes.",
                                    "Priorize variáveis que variam no mundo real e afetam saídas.",
                                    "Registre pelo menos 5-10 candidatos com justificativa inicial."
                                  ],
                                  "verification": "Gere uma tabela com lista de fatores candidatos, tipos e impacto esperado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha (Excel/Google Sheets)",
                                    "Referências de simulação (livros ou artigos)"
                                  ],
                                  "tips": "Use perguntas como 'O que muda o desempenho?' para brainstorm eficaz.",
                                  "learningObjective": "Reconhecer e catalogar variáveis de entrada em modelos de simulação.",
                                  "commonMistakes": "Incluir variáveis fixas ou irrelevantes, inchando o design experimental."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Selecionar fatores relevantes",
                                  "subSteps": [
                                    "Avalie impacto de cada candidato via análise de sensibilidade rápida ou conhecimento domínio.",
                                    "Selecione 2-5 fatores principais baseados em relevância para saídas e custo computacional.",
                                    "Elimine fatores correlacionados ou com variação insignificante.",
                                    "Justifique seleção com evidências (ex: estudos prévios ou lógica causal).",
                                    "Confirme com stakeholders se aplicável."
                                  ],
                                  "verification": "Produza relatório curto justificando os fatores finais selecionados.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Planilha de análise",
                                    "Gráficos de sensibilidade se disponível"
                                  ],
                                  "tips": "Limite a 4 fatores para designs fatoriais completos viáveis.",
                                  "learningObjective": "Discriminar fatores chave para experimentos eficientes.",
                                  "commonMistakes": "Selecionar muitos fatores, tornando o experimento impraticável."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir níveis realistas para cada fator",
                                  "subSteps": [
                                    "Pesquise faixas realistas de variação para cada fator (ex: λ de 5-15 clientes/hora).",
                                    "Defina 2-3 níveis por fator: baixo, médio, alto, baseados em dados históricos.",
                                    "Garanta níveis cobrem extremos plausíveis sem extrapolação irreal.",
                                    "Calcule valores numéricos precisos e units.",
                                    "Teste níveis em simulação piloto para validar."
                                  ],
                                  "verification": "Crie tabela de fatores e níveis com fontes de dados e justificativas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Dados reais ou literatura",
                                    "Software de simulação para teste rápido"
                                  ],
                                  "tips": "Use percentis (10%, 50%, 90%) de dados reais para níveis equilibrados.",
                                  "learningObjective": "Estabelecer níveis práticos para análise estatística robusta.",
                                  "commonMistakes": "Níveis muito estreitos, mascarando efeitos reais."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e documentar o plano de fatores e níveis",
                                  "subSteps": [
                                    "Revise o plano completo por consistência e completude.",
                                    "Simule cenários extremos para checar viabilidade.",
                                    "Estime poder estatístico aproximado do design.",
                                    "Documente em formato pronto para design fatorial.",
                                    "Obtenha feedback de pares ou mentor."
                                  ],
                                  "verification": "Gere documento final com tabela de fatores/níveis e validações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de simulação",
                                    "Template de relatório"
                                  ],
                                  "tips": "Sempre pilote com 1-2 réplicas para detectar issues cedo.",
                                  "learningObjective": "Garantir plano acionável e confiável para experimentos.",
                                  "commonMistakes": "Pular validação, levando a dados inválidos depois."
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de call center: Fatores = Taxa de chegada (baixa: 10 cham/h, média: 20, alta: 30); Tempo médio de serviço (curto: 2min, médio: 4min, longo: 6min). Isso gera 9 combinações para analisar impacto no tempo de espera médio.",
                              "finalVerifications": [
                                "Fatores selecionados afetam saídas principais conforme análise preliminar.",
                                "Níveis são realistas e baseados em dados do mundo real.",
                                "Número de fatores permite design fatorial completo factível (≤ 32 runs).",
                                "Justificativas documentadas para cada escolha.",
                                "Plano testado em simulação piloto sem erros.",
                                "Conexão clara com objetivos do experimento."
                              ],
                              "assessmentCriteria": [
                                "Relevância: Fatores diretamente ligam entradas a saídas chave (peso: 25%).",
                                "Realismo: Níveis refletem variações reais (peso: 20%).",
                                "Completude: Todos campos (fatores, níveis, justificativas) preenchidos (peso: 20%).",
                                "Eficiência: Design viável computacionalmente (peso: 15%).",
                                "Justificativa: Evidências lógicas/dados suportam escolhas (peso: 10%).",
                                "Validação: Piloto confirma plausibilidade (peso: 10%)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Preparação para ANOVA em designs fatoriais.",
                                "Programação: Implementação de parâmetros em código de simulação (ex: Python/SimPy).",
                                "Engenharia Industrial: Otimização de processos de manufatura/serviços.",
                                "Ciência de Dados: Análise de sensibilidade e feature selection.",
                                "Gestão de Projetos: Planejamento experimental em metodologias ágeis."
                              ],
                              "realWorldApplication": "Em logística, identificar fatores como velocidade de chegada de caminhões e tempo de carregamento em simulações de armazéns permite otimizar layouts, reduzindo custos operacionais em até 20% via testes fatoriais antes de investimentos reais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.1.2",
                            "name": "Construir tabela de experimentos fatoriais completos",
                            "description": "Gerar a matriz de design para k fatores com níveis especificados (ex: 2^k runs para dois níveis), incluindo todas as combinações para simulações paralelas ou sequenciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e listar os fatores e seus níveis",
                                  "subSteps": [
                                    "Defina os fatores do experimento (ex: temperatura, pressão, concentração).",
                                    "Especifique o número de níveis para cada fator (ex: 2 níveis: baixo e alto).",
                                    "Atribua códigos ou valores numéricos a cada nível (ex: -1 para baixo, +1 para alto).",
                                    "Registre o número total de fatores k.",
                                    "Crie uma tabela inicial com colunas para cada fator."
                                  ],
                                  "verification": "Lista completa de k fatores com níveis definidos e codificados corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta ou planilha Excel/Google Sheets",
                                    "Descrição do experimento"
                                  ],
                                  "tips": [
                                    "Use códigos padronizados como -1/+1 para facilitar análises posteriores.",
                                    "Mantenha níveis realistas baseados no contexto da simulação."
                                  ],
                                  "learningObjective": "Compreender a estrutura de fatores e níveis em designs fatoriais.",
                                  "commonMistakes": [
                                    "Confundir fatores com respostas.",
                                    "Esquecer de especificar todos os níveis para um fator.",
                                    "Usar níveis inconsistentes entre fatores."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o número total de runs e preparar a estrutura da tabela",
                                  "subSteps": [
                                    "Calcule o número total de experimentos: produto do número de níveis de cada fator (ex: 2^k para k fatores com 2 níveis).",
                                    "Crie uma tabela com linhas iguais ao número de runs e colunas para cada fator mais uma para run number.",
                                    "Numere as runs sequencialmente de 1 ao total.",
                                    "Inicialize todas as células vazias para preencher combinações.",
                                    "Verifique se o cálculo está correto com exemplos simples (ex: 2 fatores = 4 runs)."
                                  ],
                                  "verification": "Tabela inicial criada com tamanho correto (ex: 8 linhas para 3 fatores 2 níveis) e runs numeradas.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Planilha digital (Excel ou similar)",
                                    "Calculadora"
                                  ],
                                  "tips": [
                                    "Para designs 2^k, use potências de 2 para validação rápida.",
                                    "Planeje espaço para colunas de respostas futuras."
                                  ],
                                  "learningObjective": "Dominar o dimensionamento de designs fatoriais completos.",
                                  "commonMistakes": [
                                    "Erro no cálculo do produto de níveis.",
                                    "Confundir runs com fatores.",
                                    "Não numerar runs sequencialmente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar todas as combinações sistemáticas dos níveis",
                                  "subSteps": [
                                    "Use contagem binária para 2 níveis: represente números de 0 a 2^k - 1 em binário, mapeando 0=-1, 1=+1.",
                                    "Preencha a tabela linha por linha: para cada run, atribua níveis baseados na representação binária.",
                                    "Para mais de 2 níveis, use contagem em base-n (ex: para 3 níveis, 0,1,2).",
                                    "Garanta que todas as combinações sejam únicas e exhaustivas.",
                                    "Liste manualmente ou use fórmula em planilha para automação simples."
                                  ],
                                  "verification": "Todas as 2^k (ou equivalente) combinações únicas preenchidas sem duplicatas ou omissões.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Planilha com fórmulas (ex: =DEC2BIN para binário)",
                                    "Tabela de verdade binária impressa"
                                  ],
                                  "tips": [
                                    "Comece com k=2 para praticar, depois escale.",
                                    "Use funções como BIN2DEC no Excel para verificação."
                                  ],
                                  "learningObjective": "Gerar combinações exaustivas usando métodos sistemáticos.",
                                  "commonMistakes": [
                                    "Repetir combinações.",
                                    "Invertar mapeamento binário.",
                                    "Pular runs no preenchimento."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formatar a tabela final e realizar verificações iniciais",
                                  "subSteps": [
                                    "Adicione cabeçalhos claros: Run, Fator A (níveis), Fator B, etc.",
                                    "Formate para legibilidade: centralize valores, use negrito em cabeçalhos.",
                                    "Conte o número de cada nível por fator (deve ser equilibrado: 2^{k-1} por nível em 2^k).",
                                    "Verifique interações: todas as pares de níveis aparecem igualmente.",
                                    "Salve ou imprima a tabela pronta para simulações."
                                  ],
                                  "verification": "Tabela formatada com contagens de níveis balanceadas e sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Software de planilhas avançado (Excel com formatação)",
                                    "Checklist de verificação"
                                  ],
                                  "tips": [
                                    "Use formatação condicional para destacar desbalanceamentos.",
                                    "Teste com simulação manual de uma run."
                                  ],
                                  "learningObjective": "Finalizar e validar a tabela de experimentos para uso prático.",
                                  "commonMistakes": [
                                    "Cabeçalhos ambíguos.",
                                    "Desbalanceamento de níveis não detectado.",
                                    "Formatação pobre que dificulta leitura."
                                  ]
                                }
                              ],
                              "practicalExample": "Para 3 fatores (A: Temperatura -1=baixo/+1=alto; B: Pressão -1/+1; C: Concentração -1/+1), gere 8 runs: Run1: A-1 B-1 C-1; Run2: A-1 B-1 C+1; ... Run8: A+1 B+1 C+1. Tabela em Excel com fórmulas binárias.",
                              "finalVerifications": [
                                "Número de runs exato: produto dos níveis (ex: 8 para 2^3).",
                                "Todas combinações únicas e exhaustivas sem duplicatas.",
                                "Balanceamento: cada nível aparece 2^{k-1} vezes por fator.",
                                "Colunas corretamente rotuladas com fatores e níveis codificados.",
                                "Tabela legível e pronta para input em simulações.",
                                "Verificação cruzada: soma de códigos por coluna = 0 para designs balanceados."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo do número de runs (100% correto).",
                                "Completude das combinações (nenhuma omissão ou duplicata).",
                                "Correto uso de codificação de níveis (-1/+1 ou equivalente).",
                                "Clareza e formatação profissional da tabela.",
                                "Demonstração de balanceamento via contagens.",
                                "Capacidade de explicar o processo verbalmente."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Análise de variância (ANOVA) para resultados.",
                                "Programação: Geração automatizada via loops em Python/R.",
                                "Engenharia: Otimização de processos industriais.",
                                "Ciência de Dados: Testes A/B multivariados em marketing."
                              ],
                              "realWorldApplication": "Em indústrias farmacêuticas, usado para testar combinações de ingredientes em formulações, permitindo identificar interações principais e identificar a receita ótima com mínimo de experimentos físicos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.1.3",
                            "name": "Calcular efeitos principais e interações",
                            "description": "Aplicar contrastes ou método de Yates para estimar efeitos principais e interações de segunda ordem a partir dos resultados médios das réplicas de simulação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a Tabela de Resultados Médios",
                                  "subSteps": [
                                    "Liste todos os tratamentos do design factorial completo (ex: para 2^3, 8 combinações como (1), a, b, ab, c, ac, bc, abc).",
                                    "Calcule a média dos resultados para cada tratamento a partir das réplicas de simulação.",
                                    "Organize os dados em uma tabela na ordem padrão de Yates (binária: 000, 001, 010, etc.) ou ordem natural.",
                                    "Verifique a completude dos dados e ausência de valores ausentes.",
                                    "Rotule as colunas claramente: Tratamento, Média."
                                  ],
                                  "verification": "Tabela organizada corretamente com 8 linhas para 2^3, médias calculadas com precisão decimal de 2 casas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel ou planilha Excel/Google Sheets",
                                    "Dados de simulação das réplicas",
                                    "Calculadora"
                                  ],
                                  "tips": [
                                    "Use a ordem binária para facilitar contrastes: baixo=0, alto=1.",
                                    "Arredonde médias apenas no final para evitar erros de propagação."
                                  ],
                                  "learningObjective": "Organizar dados de experimentos simulados para análise de efeitos.",
                                  "commonMistakes": [
                                    "Esquecer réplicas e usar valores brutos.",
                                    "Bagunçar a ordem dos tratamentos."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Contrastes para Efeitos Principais",
                                  "subSteps": [
                                    "Para cada fator principal (ex: A), atribua +1 aos níveis altos e -1 aos baixos nos tratamentos correspondentes.",
                                    "Multiplique a coluna de médias pela coluna de contrastes do fator.",
                                    "Some os produtos para obter o contraste bruto do efeito principal.",
                                    "Repita para todos os fatores principais (B, C, etc.).",
                                    "Registre os contrastes em uma nova tabela."
                                  ],
                                  "verification": "Contrastes calculados coincidem com fórmula: contraste_A = Σ (nível_A * média) onde nível_A = ±1.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Planilha com tabela de dados",
                                    "Tabela de sinais de contrastes pré-definida para 2^k"
                                  ],
                                  "tips": [
                                    "Baixe tabelas de contrastes padrão para designs comuns.",
                                    "Verifique soma dos sinais: deve ser zero para equilíbrio."
                                  ],
                                  "learningObjective": "Aplicar contrastes para isolar efeitos principais em designs fatoriais.",
                                  "commonMistakes": [
                                    "Confundir níveis alto/baixo.",
                                    "Não somar todos os termos corretamente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Contrastes para Interações de Segunda Ordem",
                                  "subSteps": [
                                    "Para cada interação (ex: AB), gere coluna de contrastes multiplicando colunas de A e B (±1 * ±1).",
                                    "Multiplique pela coluna de médias e some os produtos para o contraste bruto.",
                                    "Repita para todas as interações de 2ª ordem (AC, BC, etc.).",
                                    "Para 2^3, calcule 3 interações principais.",
                                    "Anote em tabela com rótulos claros (ex: I_AB)."
                                  ],
                                  "verification": "Contraste de interação AB = Σ (sinais_AB * média), sinais_AB = sinais_A * sinais_B.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Planilha expandida",
                                    "Software como R ou Python para automação opcional"
                                  ],
                                  "tips": [
                                    "Interações são produtos de colunas principais; use multiplicação elemento a elemento.",
                                    "Comece com interações de 2 fatores antes de 3."
                                  ],
                                  "learningObjective": "Estimar interações via contrastes multiplicativos.",
                                  "commonMistakes": [
                                    "Usar soma em vez de produto para sinais de interação.",
                                    "Ignorar o número de réplicas na normalização posterior."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estimar Efeitos e Aplicar Método de Yates (Opcional)",
                                  "subSteps": [
                                    "Estime o efeito: Efeito = contraste / (número de réplicas * 2^{k-1}), onde k=nº fatores.",
                                    "Aplique algoritmo de Yates: reordene colunas e some/alterne para gerar efeitos diretamente.",
                                    "Compare resultados de contrastes vs. Yates para validação.",
                                    "Calcule efeitos principais e interações normalizados.",
                                    "Interprete: efeitos >0 indicam aumento com nível alto."
                                  ],
                                  "verification": "Efeitos calculados batem com exemplo conhecido (ex: para dados padrão, efeito A=2.0).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora ou Excel com fórmulas",
                                    "Guia de algoritmo Yates"
                                  ],
                                  "tips": [
                                    "Yates é mais rápido para mão; contrastes mais flexíveis para software.",
                                    "Sempre divida pelo denominador correto para evitar superestimação."
                                  ],
                                  "learningObjective": "Converter contrastes em efeitos estimados padronizados.",
                                  "commonMistakes": [
                                    "Errar o denominador (ex: esquecer 2^{k-1}).",
                                    "Confundir Yates com ANOVA."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e Interpretar Resultados",
                                  "subSteps": [
                                    "Some todos os efeitos * contrastes para reconstruir médias (deve aproximar tabela original).",
                                    "Identifique efeitos significativos (maiores em magnitude).",
                                    "Discuta implicações: quais fatores/interações dominam.",
                                    "Gere gráfico de efeitos (pareto ou half-normal).",
                                    "Documente em relatório."
                                  ],
                                  "verification": "Reconstrução das médias tem erro <1%; gráfico gerado corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de plotagem (Excel/R)",
                                    "Relatório template"
                                  ],
                                  "tips": [
                                    "Use teste de reconstrução como checksum.",
                                    "Priorize efeitos principais sobre interações."
                                  ],
                                  "learningObjective": "Validar cálculos e extrair insights acionáveis.",
                                  "commonMistakes": [
                                    "Não verificar soma para fechamento.",
                                    "Interpretar ruído como sinal."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um design 2^2 para simulação de fila (fatores: A=chegada alta/baixa, B=serviço rápido/lento). Médias: (1)=10, a=12, b=14, ab=16. Contraste A: -10+12-14+16=4, Efeito A=4/(2*2)=1.0 (aumenta tempo de fila). Similar para B e AB.",
                              "finalVerifications": [
                                "Tabela de contrastes balanceada (soma de sinais=0).",
                                "Efeitos principais e interações calculados com precisão ±0.01.",
                                "Reconstrução das médias via efeitos coincide com originais.",
                                "Identificação correta dos 3 maiores efeitos.",
                                "Gráfico de Pareto gerado e interpretado.",
                                "Relatório resume dominância de fatores."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos contrastes (100% correto).",
                                "Correta normalização dos efeitos.",
                                "Validação via reconstrução bem-sucedida.",
                                "Interpretação qualitativa coerente.",
                                "Eficiência: tempo dentro do estimado.",
                                "Clareza na documentação e gráficos."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: ANOVA e testes de significância.",
                                "Programação: Implementação em R/Python (pacotes como DoE.base).",
                                "Engenharia Industrial: Otimização de processos simulados.",
                                "Ciência de Dados: Análise de experimentos em ML.",
                                "Matemática: Álgebra linear para matrizes de contrastes."
                              ],
                              "realWorldApplication": "Em simulações de manufatura, calcular efeitos de fatores como velocidade de máquina e setup time para otimizar throughput, reduzindo custos em 15-20% em fábricas como automotivas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.3.2",
                        "name": "Planos Fatoriais Fracionários",
                        "description": "Técnica para reduzir o número de execuções de simulação ao usar frações regulares dos planos completos, gerenciando relações de confusão para priorizar efeitos principais e interações de baixa ordem.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.2.1",
                            "name": "Projetar frações fatoriais (2^{k-p})",
                            "description": "Definir geradores para frações como 2^{4-1} ou 2^{5-2}, calculando o número de runs reduzidas e verificando resolução do design para experimentos de simulação eficientes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de Designs Fracionários 2^{k-p}",
                                  "subSteps": [
                                    "Estude a definição de designs fatoriais completos 2^k e como frações 2^{k-p} reduzem o número de runs de 2^k para 2^{k-p}.",
                                    "Identifique os parâmetros k (fatores) e p (geradores independentes).",
                                    "Revise a relação entre resolução do design e confusões de efeitos principais e interações.",
                                    "Examine exemplos simples como 2^{4-1} (resolução III) e 2^{5-2} (resolução V).",
                                    "Anote as vantagens para experimentos de simulação eficientes."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras explicando 2^{k-p} e dê exemplos de k e p.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro 'Design and Analysis of Experiments' de Montgomery (capítulos sobre fractionals)",
                                    "Planilhas Excel ou Python com biblioteca pyDOE",
                                    "Vídeos tutoriais sobre DOE fracionário no YouTube"
                                  ],
                                  "tips": [
                                    "Comece com designs de baixa resolução para entender trade-offs.",
                                    "Use diagramas de Venn para visualizar aliasing."
                                  ],
                                  "learningObjective": "Dominar os conceitos básicos de frações fatoriais e sua utilidade em simulações discretas.",
                                  "commonMistakes": [
                                    "Confundir k (total fatores) com p (número de frações).",
                                    "Ignorar o impacto da resolução em efeitos principais.",
                                    "Achar que frações eliminam interações (apenas as confundem)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e Definir Geradores para 2^{k-p}",
                                  "subSteps": [
                                    "Liste todos os fatores A, B, C, ..., até k.",
                                    "Escolha p geradores independentes usando colunas ortogonais de uma tabela de Walsh (ex: para 2^{4-1}, use I = ABCD).",
                                    "Gere relações de definição multiplicando geradores (ex: para 2^{5-2}, I=ABC, I=DE → gerar todas combinações).",
                                    "Verifique independência: os geradores não devem ser produtos de outros.",
                                    "Documente a estrutura de aliasing para cada efeito principal e interação de 2 vias."
                                  ],
                                  "verification": "Crie geradores para 2^{4-1} e 2^{5-2}, listando as relações de definição.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Tabelas de Walsh impressas ou geradas em software como Minitab/JMP",
                                    "Planilha Excel para multiplicação modular de fatores (±1)",
                                    "Software R com pacote FrF2"
                                  ],
                                  "tips": [
                                    "Priorize geradores que maximizem resolução (ex: resolução V > IV).",
                                    "Use convenção de notação: maiúsculas para fatores altos."
                                  ],
                                  "learningObjective": "Habilitar a definição correta de geradores para qualquer 2^{k-p}.",
                                  "commonMistakes": [
                                    "Escolher geradores dependentes, levando a singularidade.",
                                    "Esquecer de gerar todas as relações de definição.",
                                    "Confundir multiplicação de colunas com adição."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o Número de Runs e Construir a Tabela de Design",
                                  "subSteps": [
                                    "Calcule runs = 2^{k-p} (ex: 2^{5-2} = 8 runs).",
                                    "Preencha as colunas dos primeiros k-p fatores da tabela full factorial 2^{k-p}.",
                                    "Gere colunas restantes multiplicando pelas relações de definição (ex: E = ABC).",
                                    "Atribua níveis ±1 para cada run e liste todas as combinações.",
                                    "Crie uma tabela com run number, fatores A-K e ordem de execução aleatória."
                                  ],
                                  "verification": "Construa e imprima a tabela completa para 2^{5-2} com 8 runs.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software Python (numpy, pandas para tabelas)",
                                    "Excel com fórmulas para multiplicação de colunas",
                                    "Templates de DOE online"
                                  ],
                                  "tips": [
                                    "Randomize ordem de runs para evitar viés de tempo.",
                                    "Verifique ortogonalidade somando colunas (deve ser zero)."
                                  ],
                                  "learningObjective": "Gerar tabelas de experimentos fracionários precisas e eficientes.",
                                  "commonMistakes": [
                                    "Erro no cálculo de 2^{k-p} (ex: confundir com k-p).",
                                    "Multiplicação incorreta de colunas levando a designs inválidos.",
                                    "Não randomizar runs."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Resolução e Estrutura de Aliasing do Design",
                                  "subSteps": [
                                    "Classifique a resolução: mais alta palavra não-fraca em relações de definição (ex: V se ABCDE livre).",
                                    "Liste palavras de aliasing para efeitos principais (ex: A + BCDE).",
                                    "Confirme que efeitos principais claros de interações de alta ordem.",
                                    "Avalie adequação para objetivos: resolução IV para screening, V para modelagem.",
                                    "Simule dados e verifique estimativas via ANOVA."
                                  ],
                                  "verification": "Escreva um relatório de 1 página com resolução e aliasing para seu design 2^{5-2}.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software Minitab ou R (DoE.base) para análise de resolução",
                                    "Calculadora de aliasing online",
                                    "Papel e lápis para estruturas manuais"
                                  ],
                                  "tips": [
                                    "Use tabela de resolução padrão para validação rápida.",
                                    "Para simulações, assuma efeitos principais dominantes."
                                  ],
                                  "learningObjective": "Avaliar a qualidade e limitações de um design fracionário.",
                                  "commonMistakes": [
                                    "Classificar resolução errada (ex: ignorar palavras mais longas).",
                                    "Assumir independência total em frações.",
                                    "Não considerar interações relevantes para o contexto."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar e Testar o Design em um Experimento de Simulação",
                                  "subSteps": [
                                    "Escolha um sistema discreto simulado (ex: fila M/M/1 com fatores chegada, serviço).",
                                    "Execute as runs no simulador, coletando métricas de performance.",
                                    "Analise dados: calcule efeitos principais e interações via half-normal plot.",
                                    "Interprete resultados considerando aliasing.",
                                    "Compare com full factorial para validar economia."
                                  ],
                                  "verification": "Execute simulação com seu design e produza gráfico de Pareto de efeitos.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Simulador Arena/Simio ou Python SimPy",
                                    "Jupyter Notebook para análise",
                                    "Dados simulados de exemplo"
                                  ],
                                  "tips": [
                                    "Use replicatas por run para variância.",
                                    "Bloqueie runs se houver fatores de ruído."
                                  ],
                                  "learningObjective": "Integrar design fracionário em experimentos de simulação reais.",
                                  "commonMistakes": [
                                    "Poucas replicatas levando a alta variância.",
                                    "Ignorar aliasing na interpretação.",
                                    "Não comparar custo-benefício com full design."
                                  ]
                                }
                              ],
                              "practicalExample": "Para otimizar uma simulação de fila bank com 5 fatores (taxa chegada A, canais B, tempo serviço C, variância D, prioridade E), projete 2^{5-2} com geradores I=ABC, I=DE. Isso gera 8 runs: ex. Run 1: A=-,B=-,C=-,D=-,E=ABC*DE=+. Colete tempo médio de espera e analise, economizando 24 runs vs full 32.",
                              "finalVerifications": [
                                "Correta definição de geradores independentes para 2^{k-p} dado.",
                                "Tabela de design com runs = 2^{k-p} e colunas ortogonais.",
                                "Cálculo preciso da resolução e lista de aliasing principal.",
                                "Verificação de claredade de efeitos principais em pelo menos um exemplo.",
                                "Aplicação bem-sucedida em simulação com análise de resultados.",
                                "Relatório documentando trade-offs de economia vs precisão."
                              ],
                              "assessmentCriteria": [
                                "Precisão na geração de relações de definição (sem dependências).",
                                "Correção matemática no número de runs e multiplicações de colunas.",
                                "Classificação de resolução alinhada com tabelas padrão.",
                                "Interpretação adequada de aliasing e limitações do design.",
                                "Eficiência demonstrada em exemplo prático de simulação.",
                                "Clareza e completude na documentação do processo."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Análise de variância (ANOVA) e plots de efeitos.",
                                "Engenharia Industrial: Otimização de processos e Taguchi methods.",
                                "Ciência de Computação: Programação de simuladores discretos (SimPy, Arena).",
                                "Matemática Discreta: Álgebra de grupos e funções de Walsh.",
                                "Gestão de Projetos: Planejamento eficiente de experimentos DOE."
                              ],
                              "realWorldApplication": "Em indústrias como manufatura automotiva ou semicondutores, designs 2^{k-p} permitem testar múltiplos fatores de processo (ex: temperatura, pressão, velocidade) com poucas runs, reduzindo custos de protótipos e tempo de simulação em software como AnyLogic, identificando interações chave para melhoria de yield."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.2.2",
                            "name": "Determinar relações de confusão",
                            "description": "Construir tabela de aliasing e identificar quais interações são confundidas (ex: AB = CDE), avaliando impacto na interpretação de resultados de simulações discretas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Planos Fatoriais Fracionários e Definir Aliasing",
                                  "subSteps": [
                                    "Estude a definição de plano factorial fracionário e sua relação com o gerador do design.",
                                    "Aprenda o conceito de aliasing: interações que são confundidas devido à fração reduzida.",
                                    "Identifique a estrutura da tabela de aliasing, incluindo colunas para efeitos principais e interações.",
                                    "Revise a notação padrão (ex: AB = CDE significa que a interação AB é indistinguível de CDE).",
                                    "Pratique definindo o resolution do design e seu impacto nas confusões."
                                  ],
                                  "verification": "Crie um glossário pessoal com definições de aliasing, gerador e resolution, e explique verbalmente para um colega.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Montgomery 'Design and Analysis of Experiments'",
                                    "Notas de aula sobre designs fracionários",
                                    "Planilha Excel para anotações"
                                  ],
                                  "tips": "Use diagramas de Venn para visualizar sobreposições de colunas no design gerador.",
                                  "learningObjective": "Compreender os conceitos básicos de aliasing e sua origem em planos fracionários.",
                                  "commonMistakes": [
                                    "Confundir aliasing com blocking",
                                    "Ignorar o papel do resolution na severidade das confusões"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a Tabela de Aliasing para um Design Específico",
                                  "subSteps": [
                                    "Selecione um design exemplo, como 2^(4-1) com gerador I = ABCD.",
                                    "Gere todas as colunas do design completo e aplique o gerador para criar as frações.",
                                    "Multiplique sistematicamente as colunas para obter as relações de aliasing (ex: A = BCD).",
                                    "Organize em tabela: liste efeitos principais, 2-fatores, 3-fatores etc., com seus aliases.",
                                    "Verifique completude somando o número de colunas (16 para 2^4)."
                                  ],
                                  "verification": "Construa a tabela manualmente e compare com uma referência padrão; deve coincidir em 100%.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software R ou Python (pacote FrF2)",
                                    "Papel quadriculado ou software de tabela (Excel/Google Sheets)",
                                    "Exemplos de designs de Montgomery Cap. 8"
                                  ],
                                  "tips": "Comece com designs de baixa resolução para praticar; use multiplicação modular para independência.",
                                  "learningObjective": "Dominar a construção manual e automatizada de tabelas de aliasing.",
                                  "commonMistakes": [
                                    "Erros na multiplicação de colunas",
                                    "Esquecer aliases de alta ordem",
                                    "Não normalizar a tabela pela convenção padrão"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Relações de Confusão Específicas",
                                  "subSteps": [
                                    "Analise a tabela para destacar confusões principais (ex: principais com interações de alta ordem).",
                                    "Classifique confusões por tipo: principais claras, 2FI confundidas, etc.",
                                    "Liste pares confundidos explicitamente (ex: AB = CDE).",
                                    "Use o conceito de word length pattern para priorizar.",
                                    "Documente em formato legível, como 'Efeito A confunde com BCD'."
                                  ],
                                  "verification": "Para um design dado, liste todas as confusões principais sem erros, validado por simulação em software.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Tabela de aliasing do Step 2",
                                    "Ferramenta online como Stat-Ease ou R",
                                    "Template de relatório em Word"
                                  ],
                                  "tips": "Priorize efeitos de baixa ordem; ignore aliases improváveis em modelos práticos.",
                                  "learningObjective": "Extrair e interpretar relações de confusão de forma precisa.",
                                  "commonMistakes": [
                                    "Interpretar aliases simétricos como unidirecionais",
                                    "Subestimar confusões em designs de alta resolução"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Impacto na Interpretação de Resultados de Simulações",
                                  "subSteps": [
                                    "Simule dados de um experimento discreto com o design fracionário.",
                                    "Aplique ANOVA ou half-normal plot considerando aliases.",
                                    "Discuta como confusões afetam conclusões (ex: se AB é confundido com ruído, inferência fraca).",
                                    "Recomende augmentação do design se confusões críticas.",
                                    "Relacione com simulações discretas: variabilidade em eventos discretos amplifica erros de aliasing."
                                  ],
                                  "verification": "Gere relatório de 1 página avaliando impacto em um simulação exemplo, com gráficos de efeitos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software de simulação (Arena ou Python SimPy)",
                                    "Dados simulados",
                                    "R para análise DOE"
                                  ],
                                  "tips": "Sempre valide com modelo verdadeiro conhecido para quantificar bias.",
                                  "learningObjective": "Avaliar quantitativamente o impacto de confusões em análises de simulação.",
                                  "commonMistakes": [
                                    "Ignorar variância inflada por aliases",
                                    "Assumir todos os aliases são ruído sem evidência"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um design 2^(5-2) V com geradores I=ABC, I=ADE para simular um sistema de manufatura discreta (5 fatores: temperatura A, pressão B, velocidade C, material D, catalisador E). Tabela revela AB = CDE; se AB for significativo, não distingue de CDE, impactando otimização de throughput.",
                              "finalVerifications": [
                                "Construa corretamente tabela de aliasing para 2^(4-1).",
                                "Identifique todas as confusões principais em um design dado.",
                                "Explique impacto de uma confusão específica em interpretação de ANOVA.",
                                "Simule dados e demonstre bias devido a aliasing.",
                                "Recomende design alternativo para resolver confusão crítica.",
                                "Crie word length pattern para o design."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção da tabela de aliasing (sem erros de multiplicação).",
                                "Correta identificação e listagem de todas as relações de confusão.",
                                "Análise qualitativa e quantitativa do impacto em resultados.",
                                "Uso apropriado de software para verificação.",
                                "Clareza na documentação e relatórios.",
                                "Capacidade de relacionar com simulações discretas."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Análise de variância e half-normal plots.",
                                "Programação: Implementação em R/Python para automação de tabelas.",
                                "Engenharia Industrial: Otimização de processos de manufatura.",
                                "Ciência de Dados: Modelagem de efeitos em experimentos de alto volume.",
                                "Matemática Discreta: Álgebra de grupos e multiplicação de colunas."
                              ],
                              "realWorldApplication": "Em simulações de linhas de produção discretas (ex: automotiva), designs fracionários reduzem runs custosos; entender confusões previne erros em decisões de engenharia, como atribuir ganhos errados a fatores, economizando milhões em retrabalho."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.2.3",
                            "name": "Analisar dados de planos fracionários",
                            "description": "Usar análise de regressão ou half-normal plots para estimar efeitos não confundidos, aplicando em saídas de simulação para otimizar parâmetros do modelo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e organizar os dados da simulação",
                                  "subSteps": [
                                    "Coletar as saídas da simulação para cada combinação de fatores do plano fracionário.",
                                    "Criar uma tabela com colunas para fatores, respostas (ex: tempo médio de ciclo) e runs.",
                                    "Codificar fatores em níveis -1 e +1 para análise.",
                                    "Verificar ausência de valores ausentes ou outliers iniciais.",
                                    "Calcular médias e desvios padrão por run."
                                  ],
                                  "verification": "Tabela de dados organizada e salva em formato CSV ou DataFrame, com resumo estatístico impresso.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha de simulação (ex: dados de Arena ou Python Pandas), software como R ou Python (pandas, numpy).",
                                  "tips": "Use nomes de colunas padronizados como 'A', 'B', 'AB' para interações.",
                                  "learningObjective": "Entender a estrutura de dados em experimentos fracionários para análise posterior.",
                                  "commonMistakes": "Ignorar codificação de fatores ou confundir runs com replicatas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir half-normal plot para identificação visual de efeitos",
                                  "subSteps": [
                                    "Calcular efeitos principais e interações usando contraste (ex: média de + vs -).",
                                    "Ordenar efeitos absolutos do menor para o maior.",
                                    "Plotar half-normal: eixo x com probabilidades half-normal, eixo y com efeitos ordenados.",
                                    "Adicionar linha de regressão para efeitos sob ruído.",
                                    "Identificar efeitos que se desviam da linha (não confundidos e significativos)."
                                  ],
                                  "verification": "Gráfico half-normal gerado com pelo menos 3 efeitos destacados como potenciais significativos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "R (qqnorm ou ggpubr), Python (statsmodels ou matplotlib com scipy.stats).",
                                  "tips": "Efeitos alinhados na linha são ruído; desvios indicam sinal.",
                                  "learningObjective": "Visualizar e distinguir efeitos reais de ruído em planos fracionários.",
                                  "commonMistakes": "Plotar normal em vez de half-normal ou ignorar aliasing de efeitos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar análise de regressão para estimar efeitos não confundidos",
                                  "subSteps": [
                                    "Construir modelo de regressão linear com termos para efeitos principais e interações não confundidas.",
                                    "Ajustar modelo usando mínimos quadrados (OLS).",
                                    "Verificar pressupostos: normalidade resíduos (QQ-plot), homocedasticidade.",
                                    "Obter coeficientes, p-valores e intervalos de confiança.",
                                    "Comparar com half-normal para confirmação."
                                  ],
                                  "verification": "Modelo ajustado com tabela de coeficientes mostrando efeitos significativos (p < 0.05).",
                                  "estimatedTime": "60 minutos",
                                  "materials": "R (lm()), Python (statsmodels.formula.api.ols).",
                                  "tips": "Inclua apenas efeitos não confundidos pela resolução do design (ex: I em 2^(3-1)).",
                                  "learningObjective": "Quantificar efeitos e sua significância estatística.",
                                  "commonMistakes": "Incluir termos aliased ou violar pressupostos sem correção."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Otimizar parâmetros do modelo e validar resultados",
                                  "subSteps": [
                                    "Usar efeitos significativos para definir níveis ótimos dos fatores.",
                                    "Simular confirmação com novos runs nos níveis otimizados.",
                                    "Calcular ganho de performance (ex: redução em variância).",
                                    "Avaliar robustez com análise de Pareto de efeitos.",
                                    "Documentar recomendações para o modelo de simulação."
                                  ],
                                  "verification": "Relatório com níveis otimizados, simulação de confirmação e gráfico Pareto.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de simulação (ex: Simul8, Python simpy), planilha para otimização.",
                                  "tips": "Priorize efeitos principais sobre interações para simplicidade.",
                                  "learningObjective": "Aplicar insights da análise para melhoria prática do sistema simulado.",
                                  "commonMistakes": "Otimizar sem run de confirmação ou ignorar custos de implementação."
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de call center com fatores A: número de agentes (2/4), B: script length (curto/longo), usando plano 2^(2-1). Half-normal mostra efeito A significativo; regressão confirma (p=0.01). Otimiza para 4 agentes, reduzindo tempo médio de espera em 25%.",
                              "finalVerifications": [
                                "Half-normal plot identifica corretamente pelo menos 2 efeitos não-ruído.",
                                "Modelo de regressão ajusta com R² > 0.7 e resíduos normais.",
                                "Efeitos principais não confundidos são priorizados.",
                                "Níveis otimizados melhoram métrica da simulação em >10%.",
                                "Relatório inclui tabelas, plots e recomendações claras.",
                                "Run de confirmação valida predições."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de efeitos não confundidos (80% acerto).",
                                "Qualidade dos plots e tabelas (legíveis, rotulados).",
                                "Correta aplicação de regressão e verificação de pressupostos.",
                                "Lógica na otimização e ganho quantificado.",
                                "Documentação completa e profissional.",
                                "Tempo total dentro de 3 horas."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Inferência e modelagem linear.",
                                "Programação: Manipulação de dados em R/Python.",
                                "Engenharia Industrial: Otimização de processos.",
                                "Ciência de Dados: Visualização e análise exploratória."
                              ],
                              "realWorldApplication": "Em manufatura, analisar plano fracionário de uma linha de produção para otimizar velocidade de máquina e setup time, reduzindo downtime em 15% sem experimentos custosos em produção real."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.3.3",
                        "name": "Aplicação em Experimentos de Simulação",
                        "description": "Integração de designs fatoriais e fracionários no planejamento de experimentos de simulação para explorar interações entre fatores, considerando variância e validação do modelo.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.3.1",
                            "name": "Selecionar designs adequados para simulações",
                            "description": "Escolher entre completo ou fracionário baseado no número de fatores, custo computacional e interesse em interações específicas em sistemas discretos de eventos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Designs Fatoriais",
                                  "subSteps": [
                                    "Defina design fatorial completo: todos os níveis de todos os fatores são testados em todas as combinações possíveis.",
                                    "Defina design fatorial fracionário: subconjunto das combinações, usando relações de alias para estimar efeitos principais e algumas interações.",
                                    "Liste vantagens e desvantagens: completo captura todas interações, mas exponencial em custo; fracionário é eficiente mas confunde efeitos.",
                                    "Estude exemplos em sistemas discretos: filas, manufatura com eventos discretos.",
                                    "Calcule número de runs: para k fatores com 2 níveis, completo = 2^k, fracionário = 2^{k-p}."
                                  ],
                                  "verification": "Resuma em um diagrama ou tabela comparativa os dois designs, confirmando cálculos para 3-5 fatores.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Montgomery 'Design and Analysis of Experiments', planilha Excel ou Python (NumPy/Pandas).",
                                  "tips": "Use tabelas de decisão para visualizar quando usar cada um.",
                                  "learningObjective": "Compreender diferenças teóricas entre designs completo e fracionário.",
                                  "commonMistakes": "Confundir aliasing com perda total de informação; assumir fracionário sempre ignora interações altas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Avaliar Número de Fatores e Custo Computacional",
                                  "subSteps": [
                                    "Identifique número de fatores (k) e níveis (geralmente 2 para discretos).",
                                    "Calcule runs necessárias: compare 2^k vs opções fracionárias como 2^{k-1}.",
                                    "Estime custo: tempo de simulação por run x número de runs x replicatas.",
                                    "Defina limite de custo: baseado em hardware disponível e prazo.",
                                    "Compare cenários: para k=4, completo=16 runs vs fracionário=8 runs."
                                  ],
                                  "verification": "Crie tabela com k=3 a 7, runs e custo estimado (ex: 1h/run), justificando viabilidade.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software de simulação (SimPy em Python, ou Arena), calculadora ou script Python.",
                                  "tips": "Inclua margem de 20% para replicatas em variância alta de eventos discretos.",
                                  "learningObjective": "Quantificar trade-off entre precisão e custo computacional.",
                                  "commonMistakes": "Ignorar replicatas; superestimar custo sem benchmark de simulação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Interações de Interesse Específicas",
                                  "subSteps": [
                                    "Liste efeitos principais e interações esperadas baseadas em conhecimento domínio (ex: interação velocidade x chegada em filas).",
                                    "Priorize: principais sempre; 2-fatores se hierarquia forte; altas só se teoria suportar.",
                                    "Selecione resolução do fracionário: Res IV para confundir 2fi com 3fi, não principais.",
                                    "Modele efeitos: use half-normal plots ou conhecimento prévio.",
                                    "Decida: se interações altas críticas, force completo."
                                  ],
                                  "verification": "Desenhe matriz de efeitos desejados vs confundidos para design proposto.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Tabelas de fracionários (DoE software como Minitab ou R package DoE.base), papel e caneta.",
                                  "tips": "Assuma hierarquia: principais > 2fi > 3fi, comum em simulações discretas.",
                                  "learningObjective": "Avaliar necessidade de interações para guiar escolha de design.",
                                  "commonMistakes": "Priorizar todas interações sem evidência; escolher baixa resolução desnecessariamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Selecionar e Justificar o Design Adequado",
                                  "subSteps": [
                                    "Sintetize análises: pontue número fatores (alto → fracionário), custo (alto → fracionário), interações (todas → completo).",
                                    "Escolha: completo se k≤4 e custo ok; fracionário senão, especificando fração (1/2, 1/4).",
                                    "Gere tabela de design: runs, níveis fatores.",
                                    "Planeje análise: ANOVA para completo; efeitos para fracionário com aliases.",
                                    "Documente decisão em relatório curto."
                                  ],
                                  "verification": "Apresente design final com justificativa quantitativa e tabela de runs.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "R (DoE.wrapper) ou Python (pyDOE), documento Word/Google Docs.",
                                  "tips": "Sempre valide com piloto pequeno antes de full simulação.",
                                  "learningObjective": "Integrar critérios para decisão final acionável.",
                                  "commonMistakes": "Não documentar trade-offs; escolher sem considerar eventos discretos (alta variância)."
                                }
                              ],
                              "practicalExample": "Em simulação de call center: fatores chegada(baixa/alta), agentes(3/5), script(complexo/simples). k=3, completo=8 runs. Custo alto? Use 2^{3-1}=4 runs Res III, confundindo 2fi com principal não de interesse.",
                              "finalVerifications": [
                                "Design selecionado reduz runs em ≥50% se k>4 sem perder efeitos principais.",
                                "Justificativa cobre os 3 critérios: fatores, custo, interações.",
                                "Tabela de design gerada corretamente sem erros de codificação.",
                                "Análise planejada lida com aliases adequadamente.",
                                "Decisão alinhada com contexto de eventos discretos (ex: replicatas planejadas).",
                                "Relatório resume trade-offs quantitativamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições e cálculos corretos (30%).",
                                "Análise quantitativa: tabelas custo/runs precisas (25%).",
                                "Relevância interações: priorização hierárquica lógica (20%).",
                                "Justificativa integrada: decisão coerente com critérios (15%).",
                                "Documentação: clara, acionável com tabelas (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: ANOVA e análise de efeitos principais.",
                                "Programação: Implementação em Python/R para simulações (SimPy, simmer).",
                                "Engenharia Industrial: Otimização de processos discretos.",
                                "Ciência de Dados: Modelagem preditiva de interações."
                              ],
                              "realWorldApplication": "Em manufatura, selecionar design fracionário para testar fatores como setup time e batch size em linha de produção, reduzindo tempo de simulação de semanas para dias, otimizando throughput sem experimentos físicos caros."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.3.2",
                            "name": "Interpretar interações via ANOVA e gráficos",
                            "description": "Realizar análise de variância (ANOVA) em réplicas de simulação e plotar gráficos de interação para detectar sinergias entre fatores como filas e tempos de processamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os Dados de Simulação para ANOVA",
                                  "subSteps": [
                                    "Coletar réplicas múltiplas (pelo menos 3-5 por combinação) das simulações para cada nível dos fatores (ex: níveis de filas: baixo/alto; tempos de processamento: curto/longo).",
                                    "Estruturar os dados em formato longo (tidy data) com colunas: variável resposta (ex: tempo médio de espera), fator1 (filas), fator2 (tempo processamento), réplica.",
                                    "Verificar e tratar missing values, outliers e normalidade dos resíduos usando testes como Shapiro-Wilk.",
                                    "Transformar variáveis se necessário (ex: log para variâncias desiguais) e balancear o design.",
                                    "Exportar para formato compatível com software estatístico (CSV ou DataFrame)."
                                  ],
                                  "verification": "DataFrame tidy com shape (n_replicas * n_combinacoes, 4), sem NAs e sumário descritivo por grupo.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Dados de simulação de sistemas discretos (ex: gerados em Arena/Simio)",
                                    "Python (pandas, scipy) ou R (tidyr, dplyr)",
                                    "Jupyter Notebook ou RStudio"
                                  ],
                                  "tips": "Sempre inclua réplicas como fator aleatório para evitar pseudo-replicação; use group_by() + summarise() para resumos iniciais.",
                                  "learningObjective": "Dominar a preparação de dados balanceados e tidy para designs fatoriais com réplicas.",
                                  "commonMistakes": [
                                    "Usar dados em formato wide sem converter para long.",
                                    "Ignorar réplicas e tratar médias como observações independentes.",
                                    "Não checar pressupostos de ANOVA como homogeneidade de variâncias."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar a Análise ANOVA com Termos de Interação",
                                  "subSteps": [
                                    "Especificar o modelo ANOVA: resposta ~ fator1 * fator2 + (1|réplica) para efeitos fixos e aleatórios.",
                                    "Ajustar o modelo usando aov() em R ou anova_lm() em Python (statsmodels).",
                                    "Extrair tabela ANOVA com soma de quadrados, graus de liberdade, F e p-values para main effects e interação.",
                                    "Verificar pressupostos: normalidade (qqplot), homocedasticidade (Levene) e independência.",
                                    "Realizar ANOVA pós-hoc se main effects significativos (ex: Tukey HSD)."
                                  ],
                                  "verification": "Tabela ANOVA impressa com p-value da interação fator1:fator2 < 0.05 indicando significância.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "R (aov(), Anova() do pacote car)",
                                    "Python (statsmodels.formula.api.ols)",
                                    "Bibliotecas: car, emmeans em R; pingouin em Python"
                                  ],
                                  "tips": "Use Type II ou III SS para designs desbalanceados; inclua réplica como random effect com lmer() se variabilidade alta.",
                                  "learningObjective": "Executar e validar ANOVA multifatorial para detectar interações.",
                                  "commonMistakes": [
                                    "Esquecer o termo de interação (* em vez de +).",
                                    "Não testar pressupostos levando a falsos positivos.",
                                    "Confundir F para main effects com interação."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar Gráficos de Interação para Visualização",
                                  "subSteps": [
                                    "Calcular médias e erros padrão por combinação de fatores usando aggregate ou groupby.",
                                    "Plotar interaction plot: linhas para um fator vs níveis do outro (ex: tempo espera vs filas, colorido por tempo processamento).",
                                    "Adicionar intervalos de confiança (95%) e rotular eixos claramente.",
                                    "Criar boxplots ou heatmaps de médias para complementar.",
                                    "Salvar gráficos em alta resolução (PNG/PDF)."
                                  ],
                                  "verification": "Gráficos com linhas não paralelas para interações significativas, legendas e títulos descritivos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "R (interaction.plot(), ggplot2 com geom_line())",
                                    "Python (seaborn.catplot, matplotlib)",
                                    "Dados preparados do Step 1"
                                  ],
                                  "tips": "Linhas cruzadas ou divergentes indicam sinergia; use facet_wrap() para múltiplas respostas.",
                                  "learningObjective": "Visualizar interações para suporte à interpretação estatística.",
                                  "commonMistakes": [
                                    "Plotar sem médias agregadas (ruído de réplicas).",
                                    "Eixos não rotulados ou escalas inadequadas.",
                                    "Ignorar CIs levando a superinterpretação visual."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Resultados e Detectar Sinergias",
                                  "subSteps": [
                                    "Analisar p-values: se interação significativa, main effects são condicionais.",
                                    "Descrever padrões nos gráficos: sinergia se efeito de um fator depende do outro (ex: filas altas só ruins com processamento lento).",
                                    "Quantificar efeito (eta-squared ou tamanho de efeito).",
                                    "Relatar conclusões em parágrafo: implicações para o sistema simulado.",
                                    "Sugerir próximos passos (ex: superfícies de resposta)."
                                  ],
                                  "verification": "Relatório escrito identificando sinergias com evidência estatística e visual.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Tabelas/gráficos dos steps anteriores",
                                    "Editor de texto ou Markdown para relatório",
                                    "Referências: Montgomery 'Design and Analysis of Experiments'"
                                  ],
                                  "tips": "Sinergia positiva: combinação melhora resposta; negativa: piora. Sempre combine stats + plots.",
                                  "learningObjective": "Integrar ANOVA e visualizações para conclusões acionáveis sobre interações.",
                                  "commonMistakes": [
                                    "Interpretar main effects ignorando interação significativa.",
                                    "Sobre-generalizar de p<0.05 sem tamanho de efeito.",
                                    "Não contextualizar com o problema de simulação."
                                  ]
                                }
                              ],
                              "practicalExample": "Em simulação de um call center: fatores filas (baixa/alta), tempo processamento (rápido/lento). ANOVA revela interação (p<0.01): filas altas só causam atrasos com processamento lento. Gráficos mostram linhas divergentes, guiando priorizar redução de tempo sobre mais atendentes.",
                              "finalVerifications": [
                                "Tabela ANOVA completa com interação significativa (p<0.05).",
                                "Gráficos de interação com linhas não paralelas e CIs.",
                                "Relatório descrevendo sinergias com evidência quantitativa.",
                                "Pressupostos de ANOVA verificados e atendidos.",
                                "Conclusões alinhadas ao contexto de simulação de filas."
                              ],
                              "assessmentCriteria": [
                                "Modelo ANOVA corretamente especificado com interações e réplicas.",
                                "Interpretação precisa de p-values, F-stats e padrões gráficos.",
                                "Gráficos profissionais, rotulados e informativos.",
                                "Tratamento adequado de dados e pressupostos.",
                                "Relatório lógico conectando resultados a decisões práticas.",
                                "Uso eficiente de ferramentas computacionais sem erros."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Modelos lineares e testes de hipóteses.",
                                "Programação: Manipulação/visualização de dados em Python/R.",
                                "Engenharia de Produção: Otimização de sistemas de filas (Teoria das Filas).",
                                "Ciência de Dados: Análise exploratória e inferencial.",
                                "Simulação Computacional: Validação de modelos discretos."
                              ],
                              "realWorldApplication": "Na manufatura, detectar sinergias entre velocidade de máquina e setup time para reduzir gargalos; em logística, otimizar armazéns avaliando interações entre capacidade de armazenamento e taxa de chegada, economizando milhões em investimentos mal direcionados."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.3.3",
                            "name": "Integrar com técnicas de redução de variância",
                            "description": "Combinar designs fatoriais com common random numbers ou control variates para minimizar variância nas estimativas de efeitos em experimentos de simulação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Designs Fatoriais e Introduzir Técnicas de Redução de Variância",
                                  "subSteps": [
                                    "Relembrar estrutura de designs fatoriais completos e fracionários em simulações.",
                                    "Explicar variância nas estimativas de efeitos principais e interações.",
                                    "Descrever Common Random Numbers (CRN): sincronizar sementes de geradores de números aleatórios para correlação positiva entre réplicas.",
                                    "Descrever Control Variates (CV): selecionar variável auxiliar com alta correlação negativa para ajuste da estimativa.",
                                    "Discutir critérios de escolha entre CRN e CV baseado no modelo simulado."
                                  ],
                                  "verification": "Escrever um resumo de 200 palavras comparando variância com e sem essas técnicas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação de simulação (ex: Law & Kelton)",
                                    "Python com numpy e scipy",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Visualize correlações com scatter plots para entender CRN/CV.",
                                  "learningObjective": "Compreender os fundamentos teóricos de integração de designs fatoriais com CRN e CV.",
                                  "commonMistakes": [
                                    "Assumir independência total entre réplicas",
                                    "Escolher control variate com baixa correlação sem teste"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Common Random Numbers (CRN) em Design Fatorial",
                                  "subSteps": [
                                    "Definir um design 2^k simples (ex: k=2) para um sistema de simulação discreto como fila M/M/1.",
                                    "Configurar gerador de números aleatórios com semente fixa para todas as combinações fatoriais.",
                                    "Executar réplicas independentes usando a mesma sequência de números aleatórios para cada combinação.",
                                    "Calcular estimativas de efeitos e intervalos de confiança.",
                                    "Comparar variância das estimativas com réplicas independentes (sem CRN)."
                                  ],
                                  "verification": "Plotar variâncias lado a lado e confirmar redução >30% com CRN.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python (numpy.random, simpy ou queueing-tool)",
                                    "Jupyter Notebook",
                                    "Exemplo de código base para fila"
                                  ],
                                  "tips": "Use np.random.seed(42) globalmente antes de loops de simulação.",
                                  "learningObjective": "Aplicar CRN para reduzir variância em estimativas fatoriais.",
                                  "commonMistakes": [
                                    "Mudar semente entre combinações",
                                    "Ignorar warm-up period na simulação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Control Variates (CV) em Design Fatorial",
                                  "subSteps": [
                                    "Identificar variável auxiliar Y* (ex: tempo total de simulação) correlacionada com resposta Y.",
                                    "Coletar dados de Y e Y* para todas combinações e réplicas.",
                                    "Estimar coeficiente beta = cov(Y,Y*)/var(Y*) via regressão.",
                                    "Ajustar estimativas: Y_adj = Y - beta*(Y* - mu_Y*) onde mu_Y* é conhecido ou estimado.",
                                    "Calcular nova variância e comparar com baseline e CRN."
                                  ],
                                  "verification": "Verificar que beta está entre -1 e 1 e redução de variância é significativa via teste t.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Python (scipy.stats.linregress)",
                                    "Código da simulação anterior",
                                    "Ferramentas de plotagem (matplotlib)"
                                  ],
                                  "tips": "Teste múltiplas Y* e escolha a de maior |rho| >0.7.",
                                  "learningObjective": "Integrar CV para ajuste de viés e variância em experimentos fatoriais.",
                                  "commonMistakes": [
                                    "Usar beta sem testar estacionariedade",
                                    "Não normalizar Y* se média desconhecida"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar, Comparar e Otimizar Integração de Técnicas",
                                  "subSteps": [
                                    "Executar experimento completo combinando CRN + CV em design fracionário.",
                                    "Realizar ANOVA nas estimativas ajustadas para detectar efeitos significativos.",
                                    "Comparar tempos de computação e precisão (comprimento IC) entre métodos.",
                                    "Otimizar número de réplicas baseado em redução de variância observada.",
                                    "Documentar trade-offs e recomendações para cenários reais."
                                  ],
                                  "verification": "Gerar relatório com tabelas de variância e plots de IC para todos métodos.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "R ou Python para ANOVA (statsmodels)",
                                    "Códigos anteriores integrados"
                                  ],
                                  "tips": "Combine CRN primeiro, depois CV para efeito multiplicativo.",
                                  "learningObjective": "Avaliar e otimizar combinação de designs fatoriais com múltiplas reduções de variância.",
                                  "commonMistakes": [
                                    "Sobreajustar CV levando a viés",
                                    "Ignorar interações na análise"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar em Cenário Avançado e Sintetizar Aprendizado",
                                  "subSteps": [
                                    "Aplicar em design fracionário 2^{k-p} com k=4.",
                                    "Testar robustez variando parâmetros do modelo simulado.",
                                    "Sintetizar regras empíricas para escolha de técnica (ex: CRN para processos semelhantes).",
                                    "Preparar apresentação com resultados quantitativos.",
                                    "Planejar extensões como stratified sampling."
                                  ],
                                  "verification": "Simulação reproduzível com variância <50% da baseline em novo cenário.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Código modularizado",
                                    "LaTeX ou Markdown para relatório"
                                  ],
                                  "tips": "Salve sementes em arquivo para reprodutibilidade total.",
                                  "learningObjective": "Validar integração em contextos complexos e generalizar conhecimento.",
                                  "commonMistakes": [
                                    "Generalizar sem testes de sensibilidade",
                                    "Esquecer steady-state nas métricas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em simulação de call center com fatores: número de agentes (4/8), probabilidade de abandono (0.1/0.3). Design 2^2 full factorial, 10 réplicas. Sem técnica: var(tempo espera)=15. Com CRN: var=6. Com CRN+CV (usando chamadas totais): var=2. Redução de 87%, detectando interação significativa.",
                              "finalVerifications": [
                                "Variância das estimativas reduzida em ≥50% vs baseline.",
                                "Intervalos de confiança 30% mais estreitos.",
                                "Efeitos principais/interações consistentes em réplicas múltiplas.",
                                "Código reproduz resultados com semente fixa.",
                                "Relatório inclui plots comparativos de variância e IC."
                              ],
                              "assessmentCriteria": [
                                "Correta sincronização de RNG em CRN (verificação por seed).",
                                "Estimativa precisa de beta em CV (R²>0.6).",
                                "Análise estatística válida (testes de significância p<0.05).",
                                "Eficiência computacional demonstrada (tempo vs precisão).",
                                "Documentação clara com interpretação de resultados."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Análise de Variância (ANOVA) e regressão linear.",
                                "Programação: Gerenciamento avançado de RNG e paralelização.",
                                "Otimização: Minimização de custo em simulações Monte Carlo.",
                                "Engenharia de Sistemas: Design of Experiments (DOE) em manufatura.",
                                "Machine Learning: Técnicas de variance reduction em reinforcement learning."
                              ],
                              "realWorldApplication": "Em logística, otimizar parâmetros de armazéns simulados (ex: layout, velocidade de picking) reduzindo tempo de simulação de dias para horas, permitindo iterações rápidas em design de supply chain para empresas como Amazon."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.3.4",
                            "name": "Planejar réplicas e validação",
                            "description": "Determinar número de réplicas independentes por run para confiança estatística e validar conclusões do design contra o modelo de simulação real.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Avaliar variância e definir níveis de confiança",
                                  "subSteps": [
                                    "Execute runs preliminares (pilot runs) do modelo de simulação para estimar a variância da resposta de interesse (ex: média de throughput).",
                                    "Calcule a variância amostral usando fórmulas estatísticas básicas (s² = Σ(xi - x̄)² / (n-1)).",
                                    "Defina o nível de confiança desejado (ex: 95%) e a precisão (margem de erro, ex: ±5%).",
                                    "Identifique fatores que influenciam a variância, como sementes aleatórias e condições iniciais.",
                                    "Documente os resultados preliminares em uma tabela de variância por run."
                                  ],
                                  "verification": "Verifique se a variância estimada está documentada com pelo menos 5 runs preliminares e cálculos corretos.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": "Software de simulação (ex: Simul8, Arena), planilha Excel ou Python (numpy/pandas), dados de pilot runs.",
                                  "tips": "Use sementes diferentes para cada run para garantir independência.",
                                  "learningObjective": "Compreender como a variância afeta a confiabilidade das estimativas em simulações estocásticas.",
                                  "commonMistakes": "Ignorar a independência das réplicas ou usar poucos pilot runs (menos de 5)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o número de réplicas necessárias",
                                  "subSteps": [
                                    "Aplique a fórmula para tamanho de amostra em médias: n = (Z² * σ²) / E², onde Z é o valor crítico (1.96 para 95%), σ é desvio padrão, E é margem de erro.",
                                    "Ajuste para simulações: considere warm-up period e run length para steady-state.",
                                    "Use power analysis se aplicável (ex: para detectar diferenças entre tratamentos).",
                                    "Arredonde para cima e valide com simulações adicionais se necessário.",
                                    "Crie uma tabela comparativa de n vs. precisão para diferentes cenários."
                                  ],
                                  "verification": "Confirme que o cálculo resulta em n >= 10 réplicas por run e atende ao intervalo de confiança desejado.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": "Calculadora estatística, Python (scipy.stats), ou tabelas de Z-scores.",
                                  "tips": "Comece com margem de erro conservadora para evitar subamostragem.",
                                  "learningObjective": "Dominar o cálculo estatístico para determinar réplicas suficientes para inferência confiável.",
                                  "commonMistakes": "Confundir desvio padrão com variância ou ignorar o warm-up period."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar réplicas independentes e coletar dados",
                                  "subSteps": [
                                    "Configure o modelo com sementes aleatórias únicas para cada réplica.",
                                    "Execute todas as réplicas por run, garantindo condições idênticas exceto aleatoriedade.",
                                    "Colete estatísticas de saída: médias, desvios, intervalos de confiança por réplica.",
                                    "Monitore convergência usando batch means ou plots de controle estatístico.",
                                    "Armazene dados em formato estruturado para análise posterior."
                                  ],
                                  "verification": "Verifique independência via teste de correlação entre réplicas e plots de médias cumulativas estabilizadas.",
                                  "estimatedTime": "4-6 horas (dependendo do modelo)",
                                  "materials": "Software de simulação configurado, scripts de automação (ex: Python com simpy), armazenamento de dados (CSV).",
                                  "tips": "Automatize execuções em batch para eficiência.",
                                  "learningObjective": "Implementar réplicas de forma prática, garantindo independência e qualidade de dados.",
                                  "commonMistakes": "Reutilizar sementes iguais ou não descartar transient phase."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar conclusões contra o modelo de simulação real",
                                  "subSteps": [
                                    "Compare intervalos de confiança das réplicas com outputs do modelo real (conhecido).",
                                    "Aplique testes estatísticos (ex: t-test ou ANOVA) para verificar se diferenças são significativas.",
                                    "Analise resíduos e plots Q-Q para normalidade das estimativas.",
                                    "Ajuste design se validação falhar (aumente réplicas ou refine modelo).",
                                    "Documente relatório de validação com evidências gráficas e numéricas."
                                  ],
                                  "verification": "As conclusões do design devem estar dentro de 95% do modelo real, com p-value > 0.05 em testes.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": "R ou Python (statsmodels, matplotlib), dados do modelo real.",
                                  "tips": "Use visualizações como boxplots para validação intuitiva.",
                                  "learningObjective": "Validar rigorosamente resultados simulados contra benchmarks reais.",
                                  "commonMistakes": "Não testar normalidade ou ignorar múltiplos testes (ajuste Bonferroni)."
                                }
                              ],
                              "practicalExample": "Em uma simulação de sistema de filas M/M/1 para estimar tempo médio de espera (conhecido: 2.5 min), execute 5 pilot runs para variância σ²=1.2, defina 95% confiança com E=0.3 min, calcule n=34 réplicas por run. Execute e valide se IC contém 2.5 min.",
                              "finalVerifications": [
                                "Número de réplicas calculado atende à fórmula estatística com documentação.",
                                "Réplicas são independentes (correlação <0.1).",
                                "Intervalos de confiança das médias se sobrepõem ao valor real.",
                                "Testes de validação (t-test) mostram não-rejeição da hipótese nula.",
                                "Relatório inclui plots de convergência e tabelas de resultados.",
                                "Design ajustado se precisão inicial insuficiente."
                              ],
                              "assessmentCriteria": [
                                "Precisão do cálculo de n (erro <10%).",
                                "Qualidade da execução (independência e steady-state verificados).",
                                "Correção dos testes de validação estatísticos.",
                                "Documentação completa com evidências visuais.",
                                "Capacidade de iterar se validação falhar.",
                                "Eficiência temporal dentro dos estimados."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Inferência e power analysis.",
                                "Programação: Automação de simulações em Python/R.",
                                "Engenharia Industrial: Otimização de processos via simulação.",
                                "Ciência de Dados: Análise de variância e validação de modelos."
                              ],
                              "realWorldApplication": "Em manufatura, planejar réplicas em simulações de linhas de produção para validar designs fatoriais, garantindo decisões confiáveis sobre alocação de recursos sem testes físicos caros."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.4",
                    "name": "Técnicas de Redução de Variância",
                    "description": "Métodos como números aleatórios comuns e variados antitéticos para minimizar a variabilidade dos estimadores.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.4.1",
                        "name": "Números Aleatórios Comuns (Common Random Numbers)",
                        "description": "Técnica que utiliza a mesma sequência de números aleatórios para diferentes sistemas ou configurações, permitindo comparações mais precisas ao reduzir a variância entre replicatas.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.1.1",
                            "name": "Compreender o princípio dos Números Aleatórios Comuns",
                            "description": "Explicar como o uso da mesma semente ou sequência de números aleatórios em múltiplas simulações minimiza a variância dos estimadores de diferença entre sistemas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos básicos de variância em simulações",
                                  "subSteps": [
                                    "Defina simulação de Monte Carlo e seu uso em sistemas discretos.",
                                    "Explique o que é um estimador de diferença entre dois sistemas (ex: média de performance A - B).",
                                    "Calcule a variância de um estimador simples usando números aleatórios independentes.",
                                    "Discuta por que a variância alta afeta a precisão das comparações.",
                                    "Identifique cenários onde comparações de sistemas são comuns."
                                  ],
                                  "verification": "Resuma em um parágrafo a relação entre variância e confiabilidade dos resultados de simulação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de simulação (ex: 'Simulation' de Ross)",
                                    "Planilha Excel ou Python com NumPy"
                                  ],
                                  "tips": "Use gráficos de histogramas para visualizar a variância.",
                                  "learningObjective": "Entender como a variância surge de amostras aleatórias independentes.",
                                  "commonMistakes": [
                                    "Confundir variância com desvio padrão",
                                    "Ignorar o impacto na confiança dos intervalos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar o problema da variância em estimadores de diferença",
                                  "subSteps": [
                                    "Simule dois sistemas independentes (ex: filas M/M/1 com taxas diferentes) com seeds aleatórias distintas.",
                                    "Calcule múltiplas réplicas e observe a variância do estimador de diferença.",
                                    "Compare com cenários reais onde a alta variância exige mais réplicas.",
                                    "Explique matematicamente por que Var(Â - B̂) = Var(Â) + Var(B̂) para independentes.",
                                    "Registre os resultados em uma tabela comparativa."
                                  ],
                                  "verification": "Gere um gráfico mostrando a distribuição do estimador com alta variância.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python (NumPy, SciPy para simulações de fila)",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Use seeds fixas inicialmente para reproduzir resultados.",
                                  "learningObjective": "Reconhecer o custo computacional de reduzir variância via mais réplicas.",
                                  "commonMistakes": [
                                    "Usar poucas réplicas, levando a conclusões erradas",
                                    "Não fixar seeds, impossibilitando reprodução"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aprender o princípio dos Números Aleatórios Comuns (CRN)",
                                  "subSteps": [
                                    "Defina CRN: usar a mesma sequência de números aleatórios para múltiplos sistemas.",
                                    "Explique como isso induz correlação positiva nos estimadores.",
                                    "Deriva matematicamente: Cov(Â, B̂) > 0 implica Var(Â - B̂) < Var(Â) + Var(B̂).",
                                    "Discuta pré-condições: sistemas devem ser comparáveis e monotônicos.",
                                    "Compare com anti-tético variates brevemente para contexto."
                                  ],
                                  "verification": "Escreva uma fórmula mostrando a redução de variância e explique verbalmente.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Artigo ou capítulo sobre técnicas de redução de variância",
                                    "Quadro branco para derivações"
                                  ],
                                  "tips": "Visualize com vetores de RNs idênticos para sistemas A e B.",
                                  "learningObjective": "Dominar a teoria por trás da correlação positiva em CRN.",
                                  "commonMistakes": [
                                    "Aplicar CRN sem monotonia, podendo aumentar variância",
                                    "Confundir com independência"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar e verificar o benefício do CRN",
                                  "subSteps": [
                                    "Implemente simulação com CRN: mesma seed para sistemas A e B.",
                                    "Calcule variância do estimador e compare com o independente.",
                                    "Execute 100 réplicas e plote intervalos de confiança.",
                                    "Analise quantas réplicas a menos são necessárias para mesma precisão.",
                                    "Documente ganhos em eficiência computacional."
                                  ],
                                  "verification": "Mostre tabelas/gráficos comprovando redução de variância em pelo menos 30-50%.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Código Python pronto para CRN vs. Independente",
                                    "Software de plotagem (Matplotlib)"
                                  ],
                                  "tips": "Estruture o código em funções modulares para fácil comparação.",
                                  "learningObjective": "Aplicar CRN e quantificar sua efetividade.",
                                  "commonMistakes": [
                                    "Não randomizar adequadamente a seed comum",
                                    "Ignorar efeitos de dependências no sistema"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule dois servidores de call center (A: 1 atendente, B: 2 atendentes). Use CRN com semente fixa (ex: 42) para gerar chegadas e serviços idênticos em ambas simulações. Compare tempo médio de espera: com CRN, a diferença é mais estável, reduzindo variância de 20% para 5%, permitindo decisão confiante com 50% menos réplicas.",
                              "finalVerifications": [
                                "Explicar verbalmente por que CRN reduz variância via correlação.",
                                "Implementar código simples de CRN e mostrar redução numérica.",
                                "Identificar quando NÃO usar CRN (ex: sistemas não monotônicos).",
                                "Calcular Cov(Â, B̂) em um exemplo numérico.",
                                "Discutir limitações como sincronização de streams.",
                                "Propor um experimento próprio com CRN."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação matemática da redução de variância (correlação positiva).",
                                "Correta implementação e comparação em simulação prática.",
                                "Identificação de pré-condições e limitações do método.",
                                "Quantificação de ganhos (ex: fator de redução de variância).",
                                "Clareza na explicação oral/escrita do princípio.",
                                "Criatividade em extensão para cenários reais."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Covariância e correlação em estimadores.",
                                "Programação: Geradores de números pseudo-aleatórios e seeds.",
                                "Otimização: Redução de variância em métodos estocásticos.",
                                "Engenharia de Sistemas: Simulações em manufatura e logística.",
                                "Probabilidade: Dependência em processos estocásticos."
                              ],
                              "realWorldApplication": "Em simulações de Monte Carlo para otimização de supply chains, CRN permite comparar políticas de estoque com menos tempo computacional, como na indústria automotiva para testar layouts de fábrica, reduzindo custos de simulação em 40-60%."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.1.2",
                            "name": "Implementar Números Aleatórios Comuns em software de simulação",
                            "description": "Configurar streams independentes de números aleatórios em ferramentas como Arena ou Simio para aplicar a técnica em experimentos comparativos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar Streams Independentes de Números Aleatórios no Software",
                                  "subSteps": [
                                    "Instale e abra o software de simulação (ex: Arena ou Simio).",
                                    "Acesse as configurações de geração de números aleatórios e identifique opções para múltiplos streams.",
                                    "Crie pelo menos dois streams independentes (ex: Stream 1 para chegada de clientes, Stream 2 para tempo de serviço).",
                                    "Atribua seeds fixos diferentes para cada stream para garantir reprodutibilidade.",
                                    "Salve o modelo base com streams configurados."
                                  ],
                                  "verification": "Verifique no log ou relatório do software se os streams estão listados como independentes e com seeds distintos.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Software Arena ou Simio instalado",
                                    "Documentação oficial do software (manual de RNG)",
                                    "Computador com licença válida"
                                  ],
                                  "tips": "Use seeds baixos como 1, 2 para testes iniciais; documente cada stream em um comentário no modelo.",
                                  "learningObjective": "Compreender e configurar múltiplos streams RNG independentes para controle de variância.",
                                  "commonMistakes": [
                                    "Usar o mesmo seed para todos streams, causando correlação indesejada",
                                    "Ignorar limites de streams disponíveis no software"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desenvolver Cenários Comparativos com Sincronização de Streams",
                                  "subSteps": [
                                    "Crie dois cenários alternativos no mesmo modelo (ex: Cenário A: 1 servidor; Cenário B: 2 servidores).",
                                    "Garanta que ambos os cenários usem exatamente os mesmos streams RNG para chegadas e serviços (técnica CRN).",
                                    "Configure réplicas idênticas (mesmo número de runs e tempo de simulação).",
                                    "Adicione variáveis de saída comuns (ex: tempo médio na fila) para comparação.",
                                    "Teste uma run rápida para validar sincronização."
                                  ],
                                  "verification": "Execute uma run única e confirme que sequências de números aleatórios são idênticas nos cenários via inspeção de traces ou logs.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Modelo base do Step 1",
                                    "Templates de cenários do software",
                                    "Planilha para registrar configurações de streams"
                                  ],
                                  "tips": "Copie o modelo inteiro para cada cenário em vez de alternar parâmetros, para evitar erros de sincronização.",
                                  "learningObjective": "Aplicar sincronização de streams RNG entre cenários para habilitar CRN.",
                                  "commonMistakes": [
                                    "Mudar seeds entre cenários",
                                    "Usar streams diferentes para o mesmo processo estocástico"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar Experimentos Comparativos e Coletar Dados",
                                  "subSteps": [
                                    "Defina número de réplicas (ex: 30 runs por cenário) com o mesmo seed global se suportado.",
                                    "Execute as simulações em batch para eficiência.",
                                    "Colete estatísticas de saída: médias, desvios padrão e intervalos de confiança.",
                                    "Exporte dados para análise externa (ex: Excel ou R).",
                                    "Registre tempo total de computação."
                                  ],
                                  "verification": "Confira relatórios de saída mostrando variâncias reduzidas e sobreposição de intervalos de confiança entre cenários.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Modelo com cenários sincronizados",
                                    "Ferramenta de análise (Excel, Python ou R)",
                                    "Espaço em disco para outputs"
                                  ],
                                  "tips": "Monitore uso de CPU; pare runs se variância estabilizar cedo.",
                                  "learningObjective": "Executar simulações comparativas com CRN e coletar métricas de variância.",
                                  "commonMistakes": [
                                    "Poucas réplicas levando a resultados instáveis",
                                    "Não registrar desvios padrão para comparação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Resultados e Validar Redução de Variância",
                                  "subSteps": [
                                    "Calcule variância das médias por cenário usando fórmulas estatísticas.",
                                    "Compare variância com baseline (sem CRN, usando streams independentes).",
                                    "Plote gráficos de distribuições de saídas para visualização.",
                                    "Teste hipóteses (ex: t-test pareado) para diferenças significativas.",
                                    "Documente conclusões em relatório."
                                  ],
                                  "verification": "Variância com CRN deve ser pelo menos 20-50% menor que baseline, com p-value <0.05 em testes.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Dados exportados dos Steps anteriores",
                                    "Software estatístico (R, Python com pandas/statsmodels)",
                                    "Templates de gráficos"
                                  ],
                                  "tips": "Use boxplots para visualizar redução de variância intuitivamente.",
                                  "learningObjective": "Interpretar impactos de CRN na precisão de comparações simuladas.",
                                  "commonMistakes": [
                                    "Confundir variância da amostra com variância populacional",
                                    "Ignorar autocorrelação em réplicas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de supermercado, compare tempo médio de checkout com 1 vs 2 caixas. Use CRN para sincronizar chegadas de clientes (Stream 1) e tempos de serviço (Stream 2) em ambos cenários. Com 30 réplicas, observe variância do tempo médio reduzida de 15% para 4%, confirmando superioridade de 2 caixas.",
                              "finalVerifications": [
                                "Streams RNG sincronizados produzem sequências idênticas em cenários.",
                                "Variância das estimativas de performance reduzida em >20% vs baseline.",
                                "Intervalos de confiança sobrepostos onde esperado, diferenças detectadas corretamente.",
                                "Relatórios de saída mostram desvios padrão consistentes.",
                                "Testes estatísticos confirmam significância das comparações.",
                                "Modelo é reprodutível com mesmos seeds."
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração e sincronização de streams (100% match em traces).",
                                "Número adequado de réplicas e análise de variância quantitativa.",
                                "Interpretação correta de resultados com evidência de redução de variância.",
                                "Documentação clara de configurações e conclusões.",
                                "Eficiência computacional demonstrada.",
                                "Aplicação correta de testes estatísticos pareados."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Análise de variância e testes de hipóteses pareados.",
                                "Programação: Manipulação de RNG e automação de simulações em scripts.",
                                "Otimização: Redução de variância em métodos de simulação estocástica.",
                                "Ciência de Dados: Visualização e exportação de dados simulados."
                              ],
                              "realWorldApplication": "Em manufatura, use CRN no Arena para comparar layouts de fábrica, reduzindo tempo de simulação em 40% e aumentando confiança em decisões de investimento em equipamentos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.1.3",
                            "name": "Avaliar a redução de variância com Números Aleatórios Comuns",
                            "description": "Calcular intervalos de confiança e comparar variâncias antes e após a aplicação da técnica em um exemplo de simulação de filas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o cenário de simulação de filas com números aleatórios independentes",
                                  "subSteps": [
                                    "Defina os parâmetros da fila M/M/1: taxa de chegada λ = 4 clientes/hora, taxa de serviço μ = 5 clientes/hora.",
                                    "Implemente a lógica de simulação em Python usando bibliotecas como SimPy ou numpy.random para gerar streams independentes de números aleatórios.",
                                    "Execute N=100 réplicas independentes, registrando o tempo médio de espera por réplica.",
                                    "Calcule a média amostral e a variância amostral dos tempos de espera.",
                                    "Construa o intervalo de confiança de 95% usando a fórmula t-student."
                                  ],
                                  "verification": "Verifique se as réplicas produzem variâncias esperadas (aprox. 1.25 para este setup) e se o IC tem largura razoável (cerca de 0.4).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python 3.x",
                                    "Bibliotecas: numpy, scipy, simpy",
                                    "Editor de código (VS Code ou Jupyter Notebook)"
                                  ],
                                  "tips": "Use seeds diferentes para cada réplica para garantir independência; teste com poucas runs primeiro para depurar.",
                                  "learningObjective": "Compreender e implementar simulações independentes para estimar variância em sistemas de filas.",
                                  "commonMistakes": [
                                    "Usar a mesma seed para todas réplicas, causando correlação artificial; ignorar o warm-up period na simulação."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar e analisar simulações independentes",
                                  "subSteps": [
                                    "Rode as 100 réplicas e colete dados de tempo de espera médio por réplica.",
                                    "Calcule estatísticas: média μ_ind, variância σ²_ind e desvio padrão.",
                                    "Construa o IC: μ_ind ± t*(σ_ind / sqrt(N)), com t de Student para 99 gl.",
                                    "Registre os resultados em uma tabela ou gráfico (histograma das médias).",
                                    "Interprete: note a largura do IC como medida de precisão."
                                  ],
                                  "verification": "Confirme que σ²_ind ≈ 1.25 e largura do IC > 0.3 unidades.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com matplotlib para gráficos",
                                    "Planilha Excel para tabelas opcionais"
                                  ],
                                  "tips": "Automatize com loops para evitar erros manuais; plote boxplot para visualizar variabilidade.",
                                  "learningObjective": "Calcular e interpretar variância e IC em simulações independentes.",
                                  "commonMistakes": [
                                    "Confundir variância da réplica com variância do tempo individual; usar Z em vez de t para amostras pequenas."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Números Aleatórios Comuns (CRN)",
                                  "subSteps": [
                                    "Configure dois cenários: baseline (μ=5) e alternativo (μ=6, mais rápido).",
                                    "Gere um único stream de números aleatórios comum para chegadas e serviços em ambos cenários.",
                                    "Use a mesma seed e sequência sincronizada para cada réplica nos dois cenários.",
                                    "Implemente a simulação pareada: para cada réplica i, rode baseline e alternativo com os mesmos RNs.",
                                    "Colete tempos de espera pareados."
                                  ],
                                  "verification": "Verifique se os RNs são idênticos nas sequências de chegada/serviço para cada par de réplicas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python com numpy.random.seed fixo por réplica",
                                    "Código da simulação anterior"
                                  ],
                                  "tips": "Sincronize os geradores de RN manualmente ou use um gerador global; registre seeds usadas.",
                                  "learningObjective": "Aplicar CRN para induzir correlação positiva entre réplicas pareadas.",
                                  "commonMistakes": [
                                    "Desalinhar sequências de RN entre cenários; usar RN independentes acidentalmente."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar simulações com CRN e calcular estatísticas",
                                  "subSteps": [
                                    "Rode 100 réplicas pareadas e calcule diferenças: Δ = tempo_baseline - tempo_alternativo.",
                                    "Calcule média μ_crn e variância σ²_crn das diferenças Δ.",
                                    "Construa IC para μ_Δ: μ_crn ± t*(σ_crn / sqrt(N)).",
                                    "Compare larguras de IC independentes vs. CRN.",
                                    "Registre redução percentual na variância: (1 - σ²_crn / σ²_ind) * 100%."
                                  ],
                                  "verification": "Confirme σ²_crn < σ²_ind (esperado ~50% redução) e IC mais estreito.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com scipy.stats para t-student",
                                    "Gráficos comparativos"
                                  ],
                                  "tips": "Foque na variância das diferenças, não das médias absolutas; use scatterplot de pares para visualizar correlação.",
                                  "learningObjective": "Quantificar redução de variância via CRN através de estatísticas pareadas.",
                                  "commonMistakes": [
                                    "Calcular variância errada das diferenças; ignorar que CRN reduz var(Δ), não var individual."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Comparar e avaliar a redução de variância",
                                  "subSteps": [
                                    "Compare σ²_ind vs. σ²_crn e larguras de IC.",
                                    "Calcule eficiência: N_ind / N_crn = σ²_ind / σ²_crn (runs necessárias para mesma precisão).",
                                    "Interprete resultados: CRN reduz variância devido a Cov(Θ1, Θ2) > 0.",
                                    "Teste sensibilidade variando N ou parâmetros da fila.",
                                    "Documente conclusões em relatório com tabelas/gráficos."
                                  ],
                                  "verification": "Relatório mostra redução >30% na variância e IC 20-50% mais estreito com CRN.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramentas de relatório: Jupyter ou Word"
                                  ],
                                  "tips": "Use fórmula teórica para validar: Var(Θ1 - Θ2) = Var(Θ1) + Var(Θ2) - 2Cov.",
                                  "learningObjective": "Avaliar efetividade de CRN na redução de variância em simulações.",
                                  "commonMistakes": [
                                    "Atribuir redução a sorte; não considerar se cenários são similares o suficiente para CRN."
                                  ]
                                }
                              ],
                              "practicalExample": "Simule uma fila de supermercado (λ=4 clientes/h, μ=5 baseline vs. μ=6 com caixa extra). Sem CRN: IC do tempo médio de espera tem largura 0.42. Com CRN: largura reduz para 0.22, variância cai 70%, permitindo detectar melhoria com menos réplicas.",
                              "finalVerifications": [
                                "Variância das diferenças com CRN é significativamente menor que variância independente.",
                                "Intervalo de confiança com CRN é mais estreito (redução >20%).",
                                "Eficiência computacional calculada corretamente (N_ind/N_crn >1).",
                                "Gráficos mostram correlação positiva nos pares de réplicas.",
                                "Relatório documenta todos cálculos e interpretações.",
                                "Teste com N=50 confirma tendências."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de variância e IC (erro <5%).",
                                "Correta implementação e sincronização de CRN.",
                                "Análise quantitativa da redução de variância com fórmulas.",
                                "Uso apropriado de gráficos e tabelas para comparação.",
                                "Interpretação correta dos resultados (causalidade via correlação positiva).",
                                "Código limpo, reproduzível com seeds documentadas."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Cálculo de intervalos de confiança e variância amostral.",
                                "Programação: Gerenciamento de geradores pseudo-aleatórios e simulação discreta.",
                                "Probabilidade: Propriedades de variância e covariância em estimadores.",
                                "Ciência de Dados: Técnicas de redução de variância em Monte Carlo.",
                                "Engenharia: Otimização de sistemas de filas em manufatura."
                              ],
                              "realWorldApplication": "Em simulações de Monte Carlo para finanças (comparar portfólios), logística (otimizar filas de distribuição) ou saúde (avaliar protocolos hospitalares), CRN permite decisões mais precisas com menos tempo computacional, economizando recursos em supercomputadores industriais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.4.2",
                        "name": "Variáveis Antitéticas (Antithetic Variates)",
                        "description": "Método que gera pares de simulações usando números aleatórios complementares (ex: U e 1-U), explorando a correlação negativa para reduzir a variância dos estimadores.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.2.1",
                            "name": "Entender o mecanismo das Variáveis Antitéticas",
                            "description": "Descrever como a correlação negativa entre variáveis antitéticas (geradas a partir de U e 1-U) leva à redução da variância do estimador médio.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Simulação de Monte Carlo e Variância do Estimador",
                                  "subSteps": [
                                    "Lembre-se do método de Monte Carlo básico: gerar amostras independentes U ~ Uniform(0,1) para estimar E[g(U)].",
                                    "Calcule o estimador médio θ̂ = (1/n) Σ g(U_i) e sua variância Var(θ̂) = (1/n) Var(g(U)).",
                                    "Entenda que a variância é alta quando g(U) tem alta variância, levando a intervalos de confiança largos.",
                                    "Implemente um exemplo simples em Python ou R para estimar uma integral, como ∫_0^1 x^2 dx = 1/3.",
                                    "Observe a variância empírica em múltiplas simulações."
                                  ],
                                  "verification": "Execute 100 simulações de Monte Carlo padrão e calcule a variância média do estimador; ela deve ser aproximadamente Var(g(U))/n.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python ou R com bibliotecas numpy/random",
                                    "Notebook Jupyter para experimentos"
                                  ],
                                  "tips": "Use sementes fixas para reprodutibilidade (np.random.seed(42)).",
                                  "learningObjective": "Compreender por que a variância é um problema em simulações de Monte Carlo básicas.",
                                  "commonMistakes": [
                                    "Confundir variância do estimador com variância da função g(U)",
                                    "Usar amostras muito pequenas (n<1000), levando a resultados instáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Conceito de Variáveis Antitéticas",
                                  "subSteps": [
                                    "Defina variáveis antitéticas: para cada U_i ~ Uniform(0,1), gere o par (U_i, 1 - U_i).",
                                    "Note que Cov(U_i, 1 - U_i) = -Var(U_i) = -1/12 < 0, criando correlação negativa perfeita.",
                                    "Gere pares de estimativas: g(U_i) e g(1 - U_i), cuja média é [g(U_i) + g(1 - U_i)] / 2.",
                                    "Implemente geração de n/2 pares em código, produzindo n estimativas pareadas.",
                                    "Compare distribuições de g(U) e g(1-U) graficamente para visualizar simetria."
                                  ],
                                  "verification": "Gere 1000 pares (U, 1-U) e confirme que corr(g(U), g(1-U)) ≈ -1 para funções g não-lineares.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código Python/R do Step 1 estendido",
                                    "Biblioteca matplotlib para gráficos de scatter"
                                  ],
                                  "tips": "Escolha funções g onde g(x) + g(1-x) é suave para maximizar redução de variância.",
                                  "learningObjective": "Identificar a correlação negativa inerente aos pares antitéticos.",
                                  "commonMistakes": [
                                    "Gerar U e 1-U independentemente (perde correlação)",
                                    "Assumir que funciona para toda g (falha se g(x)+g(1-x) tem alta variância)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir e Calcular o Estimador com Variáveis Antitéticas",
                                  "subSteps": [
                                    "Formule o estimador antitético: θ̂_A = (1/(n/2)) Σ [g(U_i) + g(1 - U_i)] / 2.",
                                    "Compare com Monte Carlo padrão usando o mesmo n.",
                                    "Calcule a variância teórica: Var(θ̂_A) = (1/n) [Var((g(U)+g(1-U))/2) + 2 Cov((g(U)+g(1-U))/2, ...)] mas simplifique para redução quando Cov(g(U),g(1-U)) < 0.",
                                    "Implemente simulações paralelas: MC padrão vs antitético, repita 100 vezes.",
                                    "Meça redução percentual na variância empírica."
                                  ],
                                  "verification": "Em simulações, Var(θ̂_A) deve ser ≤ Var(θ̂_MC), idealmente 50% menor para g adequada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código anterior",
                                    "Função para calcular variância de múltiplas runs"
                                  ],
                                  "tips": "Teste com g(x) = x^2 ou sin(2πx) para ver ganhos claros.",
                                  "learningObjective": "Construir o estimador antitético e quantificar sua eficiência.",
                                  "commonMistakes": [
                                    "Não parear corretamente (usar médias não pareadas)",
                                    "Ignorar que n deve ser par"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar o Mecanismo de Redução de Variância",
                                  "subSteps": [
                                    "Derive matematicamente: Var(θ̂_A) = (1/n) Var( (g(U)+g(1-U))/2 ) = (1/(2n)) [Var(g(U)) + Var(g(1-U)) + 2 Cov(g(U),g(1-U)) ].",
                                    "Como Var(g(U))=Var(g(1-U)), simplifica para (1/n) [ Var(g(U))/2 * (1 + ρ) ], onde ρ = Corr(g(U),g(1-U)) < 0.",
                                    "Explique: ρ negativo faz (1+ρ)<1, reduzindo variância abaixo de MC padrão.",
                                    "Discuta condições: funciona bem se g é monotônica (ρ ≈ -1).",
                                    "Compare numericamente com teoria em seu código."
                                  ],
                                  "verification": "Escreva a derivação em papel/código e confirme numericamente que Var(θ̂_A)/Var(θ̂_MC) ≈ (1 + ρ)/2.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Papel e caneta para derivação",
                                    "Código para estimar ρ empiricamente"
                                  ],
                                  "tips": "Use fórmulas simbólicas no SymPy para verificação exata.",
                                  "learningObjective": "Explicar matematicamente por que a correlação negativa reduz variância.",
                                  "commonMistakes": [
                                    "Confundir Cov com Corr",
                                    "Assumir redução sempre (testar com g constante, ρ=1, sem ganho)"
                                  ]
                                }
                              ],
                              "practicalExample": "Estime ∫_0^1 sin(2πx) dx = 0 usando Monte Carlo (n=1000). Com MC padrão, Var(θ̂) ≈ 0.5/n. Com antitéticas, gere 500 pares U e 1-U; ρ ≈ -0.95, reduzindo Var para ~0.025/n (95% menos variância). Código Python: compare erros em 100 runs.",
                              "finalVerifications": [
                                "Explicar verbalmente como pares (U,1-U) induzem correlação negativa.",
                                "Derivar a fórmula de variância reduzida para estimador antitético.",
                                "Implementar código que demonstre redução de variância em pelo menos 50% para g(x)=x^2.",
                                "Identificar quando antitéticas falham (ex: g constante).",
                                "Calcular ρ empírico e confirmar <0.",
                                "Comparar intervalos de confiança MC vs antitético."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação matemática da redução de variância (correlação ρ).",
                                "Correção no código de implementação pareada.",
                                "Quantificação numérica de ganhos (redução ≥30% em variância).",
                                "Identificação de condições ideais (g monotônica).",
                                "Explicação clara do mecanismo sem erros conceituais.",
                                "Uso adequado de verificações empíricas (múltiplas simulações)."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: Covariância e correlação em estimadores.",
                                "Programação Computacional: Implementação eficiente em Python/R.",
                                "Cálculo Numérico: Redução de variância em métodos de integração.",
                                "Finanças Quantitativas: Simulações de Monte Carlo para precificação de opções.",
                                "Otimização: Técnicas de variância reduction em ML e simulações."
                              ],
                              "realWorldApplication": "Em finanças, usa-se antitéticas para simular caminhos de preços de ativos com menor variância, reduzindo tempo computacional em avaliações de risco (VaR) ou precificação de derivativos complexos, economizando horas de CPU em supercomputadores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.2.2",
                            "name": "Gerar pares antitéticos em simulações",
                            "description": "Implementar a geração de variáveis aleatórias antitéticas em linguagens como Python ou R para simulações de processos estocásticos simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos das Variáveis Antitéticas",
                                  "subSteps": [
                                    "Estude a definição de variáveis antitéticas: pares de variáveis aleatórias negativamente correlacionadas para reduzir variância em simulações de Monte Carlo.",
                                    "Analise matematicamente por que E[f(U) + f(1-U)]/2 tem menor variância que a média simples de U independentes.",
                                    "Revise conceitos prévios: números aleatórios uniformes U ~ Uniform(0,1) e processos estocásticos simples.",
                                    "Examine um exemplo teórico: integral ∫f(x)dx ≈ média de f(U_i).",
                                    "Discuta limitações: funciona bem para funções monótonas."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras explicando o mecanismo de redução de variância e dê um exemplo numérico simples.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação de simulação de Monte Carlo (ex: livro 'Simulation' de Sheldon Ross)",
                                    "Vídeos tutoriais no YouTube sobre antithetic variates",
                                    "Notebook Jupyter para anotações"
                                  ],
                                  "tips": "Visualize graficamente f(U) vs f(1-U) para funções monótonas decrescentes para ver a correlação negativa.",
                                  "learningObjective": "Dominar o princípio teórico das variáveis antitéticas e sua justificativa estatística.",
                                  "commonMistakes": [
                                    "Confundir com amostragem estratificada",
                                    "Ignorar a necessidade de monotonicidade da função",
                                    "Achar que sempre reduz variância independentemente da função"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar Pares Antitéticos de Números Aleatórios",
                                  "subSteps": [
                                    "Gere um número aleatório uniforme U ~ Uniform(0,1) usando funções built-in (random.uniform em Python ou runif em R).",
                                    "Crie o par antitético: V = 1 - U.",
                                    "Repita para N pares independentes: (U1, 1-U1), (U2, 1-U2), etc.",
                                    "Teste a soma: confirme que U + V ≈ 1 para cada par.",
                                    "Calcule a correlação empírica entre U e V para verificar negatividade."
                                  ],
                                  "verification": "Execute um script que gera 1000 pares e imprima média de U+V (deve ser ~1) e correlação (deve ser ~-1).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com numpy.random ou R com base",
                                    "Notebook Jupyter ou RStudio"
                                  ],
                                  "tips": "Evite U=0 ou 1 exatos; use U = min(max(U, 1e-10), 1-1e-10) para estabilidade numérica.",
                                  "learningObjective": "Saber gerar pares antitéticos básicos de forma manual e automatizada.",
                                  "commonMistakes": [
                                    "Gerar U e V independentes em vez de pareados",
                                    "Usar 1-U incorretamente em distribuições não-uniformes",
                                    "Não verificar propriedades estatísticas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Geração em Código para Simulações",
                                  "subSteps": [
                                    "Defina uma função para simulação padrão: gere N amostras independentes U_i e compute média de f(U_i).",
                                    "Defina função antitética: gere N/2 pares (U,1-U), compute média de [f(U)+f(1-U)]/2.",
                                    "Implemente em Python: use numpy para vetorização (ex: U = np.random.uniform(0,1,N//2); pares = np.stack([U,1-U]) ).",
                                    "Adapte para R: use runif e mean(c(f(U),f(1-U))).",
                                    "Estruture o código com classes ou funções modulares para reutilização."
                                  ],
                                  "verification": "Rode o código para f(x)=x^2 em [0,1]; compare variâncias de 1000 réplicas (antitética deve ser menor).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Bibliotecas: numpy.random (Python), base R",
                                    "Exemplos de código de repositórios GitHub sobre Monte Carlo"
                                  ],
                                  "tips": "Vetorize operações para eficiência; use seed para reprodutibilidade (np.random.seed(42)).",
                                  "learningObjective": "Implementar código funcional para geração e uso de pares antitéticos em simulações.",
                                  "commonMistakes": [
                                    "Erro de indexação em arrays pareados",
                                    "Não dividir por 2 na média antitética",
                                    "Ignorar vetorização levando a lentidão"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Analisar em Simulação Estocástica Real",
                                  "subSteps": [
                                    "Escolha um processo estocástico simples: ex. tempo de vida exponencial ou integral de função monótona.",
                                    "Execute simulações paralelas: método padrão vs antitético, com N=10^4-10^6.",
                                    "Calcule estimativas, variâncias e intervalos de confiança para ambos.",
                                    "Plote histogramas das estimativas e scatter de pares f(U) vs f(1-U).",
                                    "Compare redução percentual de variância e tempo de computação."
                                  ],
                                  "verification": "Gere relatório com tabelas/gráficos mostrando redução de variância >20% na maioria dos casos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Matplotlib/ggplot2 para plots",
                                    "Pandas/data.frame para análise"
                                  ],
                                  "tips": "Teste múltiplas funções (monótonas e não) para ver quando falha.",
                                  "learningObjective": "Avaliar empiricamente a eficácia das antitéticas em simulações reais.",
                                  "commonMistakes": [
                                    "N pequeno levando a resultados não significativos",
                                    "Funções não-monótonas sem ajuste",
                                    "Não normalizar variâncias adequadamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule a expectativa de uma variável exponencial Lambda=1 usando Monte Carlo: gere U~Unif(0,1), X=-log(U)/Lambda. Compare variância da média de 10^5 amostras independentes vs. pares antitéticos (U e 1-U → X1=-log(U), X2=-log(1-U)). A antitética deve reduzir variância em ~50% devido à monotonicidade de -log.",
                              "finalVerifications": [
                                "Código gera pares com U + (1-U) = 1 numericamente.",
                                "Correlação entre pares f(U) e f(1-U) é negativa (ρ < -0.5).",
                                "Variância empírica da estimativa antitética é menor que a padrão em pelo menos 20%.",
                                "Simulação converge para valor teórico conhecido (ex. integral=0.5).",
                                "Gráficos mostram distribuição mais concentrada na antitética.",
                                "Código roda em <10s para N=10^6."
                              ],
                              "assessmentCriteria": [
                                "Correção conceitual: explicação precisa do mecanismo.",
                                "Implementação funcional: código sem erros e vetorizado.",
                                "Análise quantitativa: cálculo correto de variâncias e comparações.",
                                "Eficiência computacional: tempo similar ou menor que padrão.",
                                "Generalização: adaptação a diferentes funções/distribuições.",
                                "Relatório claro: com plots, tabelas e conclusões."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: variância, correlação, Monte Carlo.",
                                "Programação Computacional: vetores, funções randômicas em Python/R.",
                                "Matemática Aplicada: integrais numéricas, processos estocásticos.",
                                "Finanças Quantitativas: simulações de risco e precificação.",
                                "Ciência de Dados: redução de variância em machine learning."
                              ],
                              "realWorldApplication": "Em finanças, usa-se variáveis antitéticas para acelerar simulações de Monte Carlo na precificação de opções derivativas e avaliação de risco (VaR), reduzindo tempo de computação em clusters sem perda de precisão, essencial para trading em alta frequência."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.2.3",
                            "name": "Analisar eficácia das Variáveis Antitéticas",
                            "description": "Comparar variâncias de estimadores com e sem antitéticos em um modelo de simulação, calculando o coeficiente de variação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Variáveis Antitéticas",
                                  "subSteps": [
                                    "Estude a definição de variáveis antitéticas: pares de variáveis aleatórias negativamente correlacionadas, como U e 1-U para U ~ Uniform(0,1).",
                                    "Compreenda o impacto na variância: Var((X1 + X2)/2) = (Var(X1) + Var(X2) - 2Cov(X1,X2))/4, onde Cov negativa reduz variância.",
                                    "Revise estimadores de Monte Carlo padrão e como calcular variância amostral.",
                                    "Analise exemplos teóricos de redução de variância em integrações numéricas.",
                                    "Prepare um modelo de simulação simples para testar (ex: integral de e^{-x})."
                                  ],
                                  "verification": "Resuma em um parágrafo os princípios e forneça um exemplo matemático correto.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação de simulação Monte Carlo",
                                    "Livro ou notes sobre técnicas de redução de variância",
                                    "Python com NumPy"
                                  ],
                                  "tips": "Foquem em entender a correlação negativa como chave para redução de variância.",
                                  "learningObjective": "Compreender teoricamente como variáveis antitéticas reduzem variância em estimadores de simulação.",
                                  "commonMistakes": [
                                    "Confundir com controle de variáveis",
                                    "Ignorar a necessidade de pares perfeitamente antitéticos",
                                    "Não calcular covariância explicitamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Simulação Monte Carlo Padrão (Sem Antitéticas)",
                                  "subSteps": [
                                    "Defina o problema: estime I = ∫_0^1 e^{-x} dx ≈ 1 - 1/e usando N runs independentes.",
                                    "Gere N amostras U_i ~ Uniform(0,1), compute X_i = e^{-U_i}, estimador μ = média(X_i).",
                                    "Calcule variância amostral: s^2 = (1/(N-1)) Σ (X_i - μ)^2.",
                                    "Repita para múltiplos N (ex: 100, 1000) e registre variâncias.",
                                    "Plote histograma das X_i e variância vs N."
                                  ],
                                  "verification": "Código executa sem erros, variância calculada corretamente e converge para valor teórico.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python",
                                    "NumPy",
                                    "Matplotlib",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Use np.random.seed(42) para reprodutibilidade.",
                                  "learningObjective": "Implementar e quantificar variância de um estimador Monte Carlo padrão.",
                                  "commonMistakes": [
                                    "Usar N-1 incorretamente na variância",
                                    "Não fixar seed causando resultados variáveis",
                                    "Escolha inadequada de função para simulação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Simulação com Variáveis Antitéticas",
                                  "subSteps": [
                                    "Gere pares antitéticos: para cada U_i ~ Uniform(0,1), use U_i e 1-U_i.",
                                    "Compute X1 = e^{-U_i}, X2 = e^{-(1-U_i)}, estimador por par: (X1 + X2)/2.",
                                    "Calcule média sobre N/2 pares e variância amostral dos estimadores por par.",
                                    "Compare com o mesmo N total de amostras independentes do Step 2.",
                                    "Plote histogramas lado a lado e variâncias."
                                  ],
                                  "verification": "Variância antitética é menor que a padrão para mesmo N, código roda corretamente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python",
                                    "NumPy",
                                    "Matplotlib",
                                    "Código do Step 2 como base"
                                  ],
                                  "tips": "Garanta que pares sejam perfeitamente antitéticos para máxima correlação negativa.",
                                  "learningObjective": "Aplicar variáveis antitéticas em uma simulação e medir redução de variância.",
                                  "commonMistakes": [
                                    "Gerar pares independentes em vez de antitéticos",
                                    "Média incorreta dos pares",
                                    "Não usar mesmo N efetivo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Eficácia e Calcular Coeficiente de Variação",
                                  "subSteps": [
                                    "Para cada método, calcule coeficiente de variação CV = sqrt(Var(μ)) / |μ|.",
                                    "Compare CVs: razão CV_padrão / CV_antitética para quantificar ganho.",
                                    "Teste com diferentes N e plote curvas de convergência (erro vs N).",
                                    "Interprete resultados: discuta quando antitéticas são eficazes (funções monotônicas).",
                                    "Gere relatório com tabelas e gráficos comparativos."
                                  ],
                                  "verification": "Tabelas mostram CV menor para antitéticas, interpretação escrita correta.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Códigos dos Steps 2-3",
                                    "Pandas para tabelas",
                                    "Matplotlib/Seaborn para plots"
                                  ],
                                  "tips": "Use log-scale para plots de CV vs N para visualizar ganhos.",
                                  "learningObjective": "Analisar quantitativamente a eficácia das antitéticas via CV e visualizações.",
                                  "commonMistakes": [
                                    "Calcular CV errado (esquecer sqrt ou normalizar por μ)",
                                    "Ignorar dependência em N",
                                    "Conclusões sem evidência numérica"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação Monte Carlo para estimar a integral I = ∫_0^1 e^{-x} dx (valor exato ≈ 0.632), gere 1000 amostras uniformes independentes (variância ≈ 0.08) vs 500 pares antitéticos U e 1-U (variância reduzida para ≈ 0.02), resultando em CV 30% menor com antitéticas.",
                              "finalVerifications": [
                                "Variância do estimador antitético é consistentemente menor que o padrão para mesmo N.",
                                "Coeficiente de variação (CV) antitético < CV padrão, com razão >1.",
                                "Gráficos mostram convergência mais rápida com antitéticas.",
                                "Cálculos teóricos de variância amostral estão corretos.",
                                "Interpretação explica por que redução ocorre (correlação negativa).",
                                "Testes com múltiplos N confirmam robustez."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos cálculos de variância e CV (erro <5%).",
                                "Código limpo, reprodutível e bem comentado.",
                                "Visualizações claras comparando métodos.",
                                "Análise qualitativa e quantitativa da eficácia.",
                                "Identificação correta de condições para eficácia (ex: monotonicidade).",
                                "Relatório estruturado com conclusões baseadas em dados."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Cálculo de variância, covariância e testes de hipótese.",
                                "Programação: Implementação eficiente de simulações em Python/NumPy.",
                                "Finanças: Redução de variância em simulações Monte Carlo para precificação de derivativos.",
                                "Física Computacional: Simulações de partículas ou processos estocásticos."
                              ],
                              "realWorldApplication": "Em bancos de investimento, variáveis antitéticas aceleram simulações Monte Carlo para Value-at-Risk (VaR), permitindo estimativas precisas de risco com 50% menos runs computacionais, economizando tempo e recursos em clusters de alta performance."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.6.4.2.4",
                            "name": "Aplicar antitéticos em sistemas discretos",
                            "description": "Usar a técnica em simulações de eventos discretos, como filas M/M/1, e interpretar resultados em termos de precisão dos estimadores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar simulação padrão de fila M/M/1",
                                  "subSteps": [
                                    "Defina parâmetros: taxa de chegada λ (ex: 1.0) e taxa de serviço μ (ex: 1.5).",
                                    "Implemente gerador de eventos discretos usando distribuições exponenciais para interchegadas e tempos de serviço.",
                                    "Simule N réplicas independentes (ex: 1000) para estimar o tempo médio no sistema W.",
                                    "Colete estatísticas: média e variância dos estimadores W.",
                                    "Valide o modelo base com fórmulas analíticas de filas (L = λ/(μ-λ) para comprimento médio)."
                                  ],
                                  "verification": "Execute o código e confirme que a média simulada está próxima da analítica (erro <5%) e variância é calculada corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Linguagem de programação (Python com NumPy/SciPy), editor de código (Jupyter Notebook), documentação de filas M/M/1.",
                                  "tips": "Use sementes fixas para reprodutibilidade inicial.",
                                  "learningObjective": "Compreender e implementar simulação básica de eventos discretos em filas M/M/1.",
                                  "commonMistakes": "Confundir taxa de chegada com tempo médio entre chegadas; ignorar condição de estabilidade ρ=λ/μ <1."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar variáveis aleatórias antitéticas",
                                  "subSteps": [
                                    "Gere U ~ Uniforme(0,1) para uma réplica e use 1-U para a réplica antitética.",
                                    "Aplique inversa exponencial: tempo = -1/λ * ln(U) e antitético -1/λ * ln(1-U).",
                                    "Ajuste para ambos interchegadas de chegada e tempos de serviço.",
                                    "Crie função pareada que gera réplicas normal e antitética simultaneamente.",
                                    "Teste correlação: confirme que corr(U, 1-U) ≈ -1 para pares."
                                  ],
                                  "verification": "Gere 1000 pares e calcule coeficiente de correlação; deve ser próximo de -0.99.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Mesmo ambiente de programação; funções scipy.stats.expon para testes.",
                                  "tips": "Mantenha o mesmo número de eventos por par para alinhamento perfeito.",
                                  "learningObjective": "Dominar geração de variáveis antitéticas e sua correlação negativa.",
                                  "commonMistakes": "Usar U antitético sem inversa cumulativa; aplicar apenas em um tipo de evento."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar simulações pareadas e coletar dados",
                                  "subSteps": [
                                    "Rode M/2 pares (ex: 500 pares para M=1000 réplicas) usando antitéticas.",
                                    "Para cada par, calcule W_normal e W_antithetic, então média pareada: (W_n + W_a)/2.",
                                    "Colete todas as médias pareadas e compute média geral e variância empírica.",
                                    "Compare com simulação independente (mesmo N).",
                                    "Registre variâncias para ambos métodos."
                                  ],
                                  "verification": "Confirme que número de réplicas é equivalente e dados pareados estão salvos em arrays.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Scripts de simulação expandidos; planilhas ou pandas para análise.",
                                  "tips": "Paralelize se possível para eficiência, mas mantenha pares intactos.",
                                  "learningObjective": "Executar experimento comparativo com controle de variância.",
                                  "commonMistakes": "Desbalancear número de réplicas; não parear corretamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar resultados e interpretar precisão",
                                  "subSteps": [
                                    "Calcule variância do estimador independente: Var(W_ind) = std(W)^2 / N.",
                                    "Para antitéticas: Var(W_pair) ≈ [Var(W_n + W_a)/2] / (N/2), considerando covariança.",
                                    "Compute razão de variância: Var_ind / Var_anti; espere >1 (redução).",
                                    "Teste intervalos de confiança (IC 95%) e compare larguras.",
                                    "Interprete: redução reflete correlação negativa eficaz."
                                  ],
                                  "verification": "Gráficos de histogramas de W_ind vs W_pair mostram sobreposição e variância menor na pareada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Matplotlib/Seaborn para plots; fórmulas de variância de Rubinstein.",
                                  "tips": "Use bootstrap para IC robustos se N pequeno.",
                                  "learningObjective": "Interpretar impacto da redução de variância em precisão de estimadores.",
                                  "commonMistakes": "Ignorar fator N/2 na variância pareada; confundir média com variância."
                                }
                              ],
                              "practicalExample": "Em uma simulação M/M/1 com λ=1, μ=1.5, rode 1000 réplicas independentes: Var(W_ind)≈0.45. Com antitéticas pareadas: Var(W_anti)≈0.28 (redução de 38%). IC ind: [1.45, 1.65]; IC anti: [1.48, 1.62] – mais preciso!",
                              "finalVerifications": [
                                "Variância do estimador antitético é menor que o independente (>10% redução).",
                                "Correlação entre pares é negativa e significativa (r < -0.5).",
                                "IC do antitético é mais estreito que o independente.",
                                "Resultados consistentes em múltiplas runs com sementes diferentes.",
                                "Interpretação correta: antitéticas reduzem variância via correlação negativa.",
                                "Código reproduzível gera mesmos resultados com semente fixa."
                              ],
                              "assessmentCriteria": [
                                "Precisão da implementação antitética (correlação negativa confirmada: 100%).",
                                "Correção dos cálculos de variância e IC (erro <1%: 25%).",
                                "Análise comparativa clara com gráficos (qualidade visual: 25%).",
                                "Interpretação em termos de precisão dos estimadores (profundidade: 25%).",
                                "Código limpo, comentado e eficiente (legibilidade: 15%).",
                                "Relatório conciso com conclusões acionáveis (clareza: 10%)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Inferência e redução de variância em Monte Carlo.",
                                "Programação: Simulação orientada a eventos e vetores NumPy.",
                                "Probabilidade: Propriedades de variáveis uniformes e exponenciais.",
                                "Otimização: Técnicas para melhorar eficiência computacional em simulações."
                              ],
                              "realWorldApplication": "Em call centers, usar antitéticas para simular tempos de espera com menos réplicas, reduzindo tempo de computação em planejamento de staff; em manufatura, otimizar buffers de filas com estimadores precisos para decisões de investimento."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.4.3",
                        "name": "Outras Técnicas de Redução de Variância",
                        "description": "Visão geral de métodos complementares como variáveis de controle e amostragem estratificada para minimizar variabilidade em experimentos de simulação.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.3.1",
                            "name": "Identificar condições para uso de Variáveis de Controle",
                            "description": "Explicar como variáveis de controle correlacionadas com o estimador de interesse podem ser usadas para ajustar e reduzir variância.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de Variáveis de Controle em Simulações",
                                  "subSteps": [
                                    "Estude a definição de variável de controle como uma variável auxiliar correlacionada ao estimador de interesse θ̂.",
                                    "Revise o estimador de controle: θ̂_c = θ̂ - b(Y - E[Y]), onde Y é a variável de controle e b é o coeficiente ótimo.",
                                    "Analise como a redução de variância ocorre quando Cov(θ̂, Y) ≠ 0 e Var(Y) é conhecida ou baixa.",
                                    "Explore exemplos simples de Monte Carlo puro versus com controle.",
                                    "Calcule manualmente a variância reduzida para um caso toy."
                                  ],
                                  "verification": "Resuma em 3 frases os princípios básicos e calcule a variância para um exemplo dado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Simulação (ex: 'Simulation' de Ross)",
                                    "Notebook Jupyter para cálculos iniciais",
                                    "Slides ou vídeo sobre Monte Carlo"
                                  ],
                                  "tips": "Comece com exemplos visuais de gráficos de dispersão para ver correlação.",
                                  "learningObjective": "Explicar o mecanismo matemático de redução de variância via variáveis de controle.",
                                  "commonMistakes": "Confundir correlação com causalidade; ignorar que b ótimo minimiza variância."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Critérios de Correlação Necessária",
                                  "subSteps": [
                                    "Calcule o coeficiente de correlação ρ entre θ̂ e Y usando amostras simuladas.",
                                    "Verifique se |ρ| > 0.3 como threshold inicial para viabilidade (alta correlação ideal).",
                                    "Teste correlação positiva ou negativa, preferindo negativa para b > 0.",
                                    "Gere múltiplas simulações para estimar ρ com confiança (ex: bootstrap).",
                                    "Compare ρ com benchmarks de literatura para o contexto específico."
                                  ],
                                  "verification": "Produza um gráfico de dispersão e compute ρ > 0.5 para um par θ̂-Y simulado.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python/R com bibliotecas numpy, scipy.stats",
                                    "Datasets de simulação gerados",
                                    "Ferramenta de plotagem como matplotlib/ggplot"
                                  ],
                                  "tips": "Use 10.000+ réplicas para estimativas estáveis de ρ.",
                                  "learningObjective": "Determinar se a correlação é suficiente para justificar o uso de controle.",
                                  "commonMistakes": "Usar poucas amostras levando a ρ instável; assumir causalidade de alta ρ."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar Condições de Expectativa e Variância Conhecidas",
                                  "subSteps": [
                                    "Confirme se E[Y] é conhecida analiticamente ou computável com alta precisão.",
                                    "Estime Var(Y) empiricamente e verifique se é menor que Var(θ̂).",
                                    "Calcule b ótimo = Cov(θ̂,Y)/Var(Y) e avalie se é estável across runs.",
                                    "Teste sensibilidade: simule sem E[Y] conhecida e observe bias.",
                                    "Documente se Y é 'stratified' ou 'antithetic' compatível."
                                  ],
                                  "verification": "Forneça fórmula analítica para E[Y] ou simulação com erro <1% e b estável.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Código fonte de simulação",
                                    "Documentação teórica do modelo",
                                    "Calculadora simbólica como SymPy"
                                  ],
                                  "tips": "Priorize Y com E[Y]=0 para simplificar (centralizar dados).",
                                  "learningObjective": "Avaliar se as propriedades estatísticas de Y atendem aos requisitos.",
                                  "commonMistakes": "Assumir E[Y] conhecida sem prova analítica; ignorar custo computacional de Var(Y)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Impacto Geral e Condições Integradas",
                                  "subSteps": [
                                    "Integre todos critérios: ρ alta + E[Y]/Var(Y) conhecidas + custo computacional baixo.",
                                    "Simule cenários before/after controle e meça % redução de variância.",
                                    "Crie checklist: correlação >0.4, E[Y] exata, custo <2x simulação base.",
                                    "Teste em contexto real: aplique a um experimento de simulação discreto.",
                                    "Conclua com recomendação: usar ou não, com justificativa quantitativa."
                                  ],
                                  "verification": "Relatório com tabela comparativa de variâncias e checklist preenchido.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Ambiente de simulação completo (ex: SimPy para discretos)",
                                    "Templates de relatório",
                                    "Ferramentas de profiling de tempo CPU"
                                  ],
                                  "tips": "Automatize simulações em loop para eficiência.",
                                  "learningObjective": "Sintetizar condições para decisão final de uso de variáveis de controle.",
                                  "commonMistakes": "Superestimar redução sem testes empíricos; negligenciar overhead computacional."
                                }
                              ],
                              "practicalExample": "Em uma simulação Monte Carlo para estimar a probabilidade de falha em uma fila M/M/1 (θ̂ = proporção de jobs perdidos), use Y = tempo médio de espera (conhecido analiticamente E[Y]=ρ/(1-ρ)) como controle. Com ρ_correl=-0.7, reduza Var(θ̂) em 40%. Simule 5000 runs, compute b=-0.12, e verifique redução.",
                              "finalVerifications": [
                                "Correlação |ρ| > 0.4 confirmada empiricamente.",
                                "E[Y] conhecida analiticamente ou com precisão >99%.",
                                "Variância reduzida em pelo menos 20% em simulação teste.",
                                "Coeficiente b estável (CV <10%) across múltiplas runs.",
                                "Custo computacional adicional <50% do baseline.",
                                "Checklist de condições 100% atendido."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de ρ e seu threshold (30%)",
                                "Correta verificação de E[Y]/Var(Y) com evidência matemática (25%)",
                                "Cálculo quantitativo de redução de variância (20%)",
                                "Análise de custo-benefício integrada (15%)",
                                "Clareza na recomendação final com justificativa (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Inferência e controle de variância em amostragem.",
                                "Programação: Implementação eficiente de simulações em Python/R.",
                                "Probabilidade: Expectativas condicionais e covariâncias.",
                                "Otimização: Escolha de b para minimização de variância."
                              ],
                              "realWorldApplication": "Em finanças, usar tempo de maturidade como controle para estimar VaR de portfólios simulados, reduzindo variância em 30-50% para decisões de risco mais precisas; em manufatura, controlar throughput conhecido para estimar eficiência de linhas de produção via simulação discreta."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.1.1",
                              "10.1.6.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.6.4.3.2",
                            "name": "Planejar experimentos com múltiplas técnicas combinadas",
                            "description": "Combinar números aleatórios comuns, antitéticos e estratificação em um plano de experimento para otimizar a precisão em simulações complexas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos das Técnicas Individuais",
                                  "subSteps": [
                                    "Estude números aleatórios comuns (pseudo-random) e sua variância básica em simulações.",
                                    "Analise números antitéticos: gere pares opostos para reduzir correlação negativa e variância.",
                                    "Revise estratificação: divida o espaço de amostragem em estratos e amostre proporcionalmente.",
                                    "Compare métricas de variância para cada técnica usando exemplos simples.",
                                    "Documente limitações de cada técnica isolada em contextos complexos."
                                  ],
                                  "verification": "Crie um resumo escrito comparando variância de cada técnica em uma simulação teste simples.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Documentação de Monte Carlo (ex: livros de Ripley), Python/R com bibliotecas numpy/random.",
                                  "tips": "Use gráficos de histogramas para visualizar distribuições e variâncias.",
                                  "learningObjective": "Compreender profundamente cada técnica para basear combinações eficazes.",
                                  "commonMistakes": "Confundir antitéticos com simetria simples; ignorar dependências entre variáveis."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Problema de Simulação e Fontes de Variância",
                                  "subSteps": [
                                    "Defina o modelo de simulação complexo (ex: sistema de filas com múltiplas variáveis).",
                                    "Execute simulações preliminares com aleatoriedade comum para quantificar variância total.",
                                    "Identifique componentes de variância principais usando análise de sensibilidade.",
                                    "Mapeie como cada técnica (antitético, estratificação) pode mitigar fontes específicas.",
                                    "Estime ganhos potenciais de redução de variância via fórmulas teóricas."
                                  ],
                                  "verification": "Gere relatório com decomposição de variância e proposta de alocação de técnicas.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Software de simulação (Python com simpy ou R), planilhas para análise.",
                                  "tips": "Comece com 1000 runs para estimativas robustas de variância.",
                                  "learningObjective": "Identificar alvos precisos para aplicação combinada de técnicas.",
                                  "commonMistakes": "Subestimar variância em caudas de distribuições; ignorar interações entre variáveis."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Projetar a Combinação das Técnicas",
                                  "subSteps": [
                                    "Defina estrutura: aplique estratificação no espaço principal, antitéticos em subespaços, comum como base.",
                                    "Especifique alocação de amostras: ex: 50% estratificado-antitético, 50% comum para controle.",
                                    "Crie gerador de amostras híbrido: integre funções para cada técnica.",
                                    "Calcule variância esperada combinada usando fórmulas de variância condicional.",
                                    "Desenhe fluxograma do plano de experimento."
                                  ],
                                  "verification": "Implemente protótipo de gerador e teste variância em simulação pequena.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Pseudocódigo editor, bibliotecas random stratified/antithetic (ex: Python's stratifiedtools).",
                                  "tips": "Garanta independência entre estratos para evitar bias.",
                                  "learningObjective": "Criar plano sinérgico que maximize redução de variância.",
                                  "commonMistakes": "Sobrepor técnicas causando dependência positiva; ignorar custo computacional."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar, Testar e Otimizar o Plano",
                                  "subSteps": [
                                    "Codifique o experimento completo com controle (comum) vs. combinado.",
                                    "Execute múltiplos runs e compute intervalos de confiança.",
                                    "Compare reduções de variância e tempos de execução.",
                                    "Ajuste alocações baseadas em resultados (ex: mais antitéticos se correlação alta).",
                                    "Documente plano final com parâmetros otimizados."
                                  ],
                                  "verification": "Demonstre redução de variância >30% vs. baseline com ICs não sobrepostos.",
                                  "estimatedTime": "5 horas",
                                  "materials": "Ambiente de programação completo, profiler de performance.",
                                  "tips": "Use paralelização para acelerar runs grandes.",
                                  "learningObjective": "Validar e refinar plano para precisão otimizada.",
                                  "commonMistakes": "Não rodar runs suficientes para ICs estáveis; confundir variância com bias."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Avaliar Robustez e Generalizar",
                                  "subSteps": [
                                    "Teste sensibilidade a parâmetros (ex: número de estratos).",
                                    "Aplique a cenários variados para verificar generalidade.",
                                    "Calcule eficiência (redução variância / custo extra).",
                                    "Escreva guidelines para replicação em outros problemas.",
                                    "Prepare apresentação do plano completo."
                                  ],
                                  "verification": "Relatório final com métricas de robustez e eficiência >1.5.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Ferramentas de plotting (matplotlib/ggplot), templates de relatório.",
                                  "tips": "Registre seeds para reprodutibilidade.",
                                  "learningObjective": "Garantir plano escalável e confiável.",
                                  "commonMistakes": "Testar só em casos ideais; negligenciar overhead computacional."
                                }
                              ],
                              "practicalExample": "Em uma simulação de sistema de filas M/M/1 com arrival rates variáveis, estratifique por rates (baixo/médio/alto), aplique antitéticos dentro de cada estrato para tempos de serviço, e use comum para baseline. Resultado: variância reduzida em 45% com 20% mais runs.",
                              "finalVerifications": [
                                "Plano especifica alocação clara de técnicas por componente de variância.",
                                "Simulações mostram redução estatisticamente significativa de variância (>25%).",
                                "Custo computacional justificado pela precisão ganha.",
                                "Fluxograma ou pseudocódigo do gerador híbrido está completo.",
                                "Intervalos de confiança são mais estreitos que baseline.",
                                "Documentação inclui fórmulas teóricas de variância combinada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na combinação: técnicas aplicadas sinergeticamente sem conflitos (40%).",
                                "Redução de variância demonstrada empiricamente (25%).",
                                "Eficiência custo-benefício otimizada (15%).",
                                "Clareza e completude do plano documentado (10%).",
                                "Robustez testada em variações (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Análise de variância e amostragem avançada.",
                                "Programação: Implementação de geradores customizados em Python/R.",
                                "Otimização: Trade-offs entre precisão e custo computacional.",
                                "Probabilidade: Teoria de processos estocásticos em simulações."
                              ],
                              "realWorldApplication": "Em finanças, otimizar simulações Monte Carlo para precificação de derivativos complexos, reduzindo tempo de computação em data centers enquanto mantém precisão para decisões de risco em bancos."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.1.3",
                              "10.1.6.4.2.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.5",
                    "name": "Análise Estatística dos Resultados",
                    "description": "Construção de intervalos de confiança e testes para validar a precisão dos resultados da simulação.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.5.1",
                        "name": "Intervalos de Confiança em Simulações",
                        "description": "Conceitos fundamentais para construir intervalos de confiança que estimam a precisão das médias e outras estatísticas obtidas de réplicas de simulações discretas.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.1.1",
                            "name": "Calcular Intervalo de Confiança para a Média",
                            "description": "Aplicar a fórmula do intervalo de confiança para a média de uma simulação, assumindo normalidade aproximada pelo Teorema Central do Limite, usando o desvio padrão amostral e o valor crítico t ou z.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os Dados da Simulação",
                                  "subSteps": [
                                    "Colete o conjunto de dados gerado pela simulação (ex: valores numéricos de uma variável de interesse como tempo médio de processamento).",
                                    "Verifique o tamanho da amostra (n) e confirme que n ≥ 30 para aplicar o Teorema Central do Limite (TCL).",
                                    "Identifique e remova ou trate outliers se necessário, assumindo normalidade aproximada.",
                                    "Registre o nível de confiança desejado (ex: 95%).",
                                    "Organize os dados em uma tabela ou vetor para cálculos subsequentes."
                                  ],
                                  "verification": "Conjunto de dados limpo, n calculado e nível de confiança definido, pronto para estatísticas descritivas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Dados da simulação (planilha Excel, Python com NumPy/Pandas ou R)",
                                    "Calculadora ou software estatístico"
                                  ],
                                  "tips": "Use funções prontas como np.mean() no Python para agilizar, mas entenda o processo manual.",
                                  "learningObjective": "Preparar dados amostrais adequados para cálculo de intervalo de confiança assumindo TCL.",
                                  "commonMistakes": [
                                    "Usar n < 30 sem justificativa",
                                    "Ignorar outliers que distorcem a média",
                                    "Confundir população com amostra"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Estatísticas Descritivas",
                                  "subSteps": [
                                    "Calcule a média amostral (x̄) somando todos os valores e dividindo por n.",
                                    "Calcule o desvio padrão amostral (s) usando a fórmula √[Σ(xi - x̄)² / (n-1)].",
                                    "Calcule o erro padrão (SE) como s / √n.",
                                    "Verifique os valores com software para validação.",
                                    "Registre x̄, s e SE com precisão decimal adequada (ex: 4 casas)."
                                  ],
                                  "verification": "Média, desvio padrão e erro padrão calculados corretamente e validados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software: Excel (funções AVERAGE, STDEV.S), Python (numpy.std(ddof=1)) ou R"
                                  ],
                                  "tips": "Use desvio padrão amostral (divisor n-1), não populacional.",
                                  "learningObjective": "Dominar cálculo de estatísticas descritivas essenciais para IC.",
                                  "commonMistakes": [
                                    "Usar desvio padrão populacional (n no denominador)",
                                    "Arredondar prematuramente",
                                    "Confundir SE com s"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar o Valor Crítico",
                                  "subSteps": [
                                    "Escolha entre distribuição z (n grande, >30) ou t de Student (n menor, graus de liberdade n-1).",
                                    "Para 95% de confiança: z ≈ 1.96 (normal padrão) ou t via tabela/software com α/2 = 0.025.",
                                    "Consulte tabela t ou use função (ex: norm.ppf(0.975) no Python para z).",
                                    "Registre o valor crítico (z* ou t*) com precisão.",
                                    "Justifique a escolha baseada em n e pressupostos."
                                  ],
                                  "verification": "Valor crítico correto selecionado e justificado para o nível de confiança.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela de valores críticos z/t",
                                    "Software: scipy.stats.t.ppf ou Excel T.INV.2T"
                                  ],
                                  "tips": "Para n>30, z é boa aproximação; sempre prefira t para exatidão.",
                                  "learningObjective": "Selecionar e obter valor crítico apropriado para IC da média.",
                                  "commonMistakes": [
                                    "Usar z para n pequeno",
                                    "Confundir α com α/2",
                                    "Ler tabela errada (unicaudal vs bicaudal)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular e Interpretar o Intervalo de Confiança",
                                  "subSteps": [
                                    "Aplique a fórmula: IC = [x̄ - valor_crítico * SE, x̄ + valor_crítico * SE].",
                                    "Calcule os limites inferior e superior.",
                                    "Interprete: 'Com 95% de confiança, a verdadeira média populacional está entre [LI, LS]'.",
                                    "Valide com software (ex: stats.t.interval no Python).",
                                    "Discuta implicações para a simulação (ex: precisão do modelo)."
                                  ],
                                  "verification": "IC calculado corretamente, interpretado e validado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Software para validação (Python scipy.stats, R t.test)"
                                  ],
                                  "tips": "Sempre reporte com o nível de confiança e contexto da simulação.",
                                  "learningObjective": "Construir e interpretar IC para média em contexto de simulações.",
                                  "commonMistakes": [
                                    "Inverter limites",
                                    "Esquecer multiplicar pelo SE",
                                    "Interpretar como probabilidade da média estar no IC"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Documentar o Resultado",
                                  "subSteps": [
                                    "Compare IC com resultados de múltiplas simulações (se disponíveis).",
                                    "Avalie largura do IC (precisão: estreito = bom).",
                                    "Documente todos os passos, fórmulas e suposições.",
                                    "Gere gráfico do IC (ex: barra de erro).",
                                    "Conclua sobre a confiabilidade da estimativa média."
                                  ],
                                  "verification": "Documentação completa com validação e gráfico.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Software de plotagem (Matplotlib, ggplot2)",
                                    "Relatório template"
                                  ],
                                  "tips": "Largura do IC indica variabilidade; aumente n se larga.",
                                  "learningObjective": "Validar e comunicar resultados de IC em simulações.",
                                  "commonMistakes": [
                                    "Não documentar suposições TCL",
                                    "Ignorar largura do IC",
                                    "Faltar interpretação contextual"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de sistema de filas discretas (supermercado), gere 100 tempos de espera (média x̄=5.2 min, s=1.8 min). Para 95% confiança, use z=1.96: SE=1.8/√100=0.18, IC=[5.2-1.96*0.18, 5.2+1.96*0.18] ≈ [4.85, 5.55] min. Interprete: média real de espera entre 4.85 e 5.55 min com 95% confiança.",
                              "finalVerifications": [
                                "Cálculo da média e desvio padrão amostral correto.",
                                "Seleção adequada de z ou t com justificativa.",
                                "Fórmula do IC aplicada sem erros aritméticos.",
                                "Interpretação probabilística precisa (não '95% chance da média estar no IC').",
                                "Validação com software e discussão de precisão.",
                                "Documentação completa incluindo suposições TCL."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos descritivos (erro <1%).",
                                "Correta escolha e uso do valor crítico (z vs t).",
                                "Aplicação exata da fórmula do IC.",
                                "Interpretação contextual para simulações.",
                                "Análise de sensibilidade (ex: impacto de n).",
                                "Clareza na documentação e gráficos."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar simulações em Python/R para gerar dados.",
                                "Probabilidade: Entender TCL e distribuições z/t.",
                                "Engenharia de Simulação: Validar modelos em sistemas discretos.",
                                "Estatística Aplicada: Inferência em experimentos DOE.",
                                "Ciência de Dados: Visualização e reporting de ICs."
                              ],
                              "realWorldApplication": "Em simulações de manufatura, calcula IC para tempo médio de produção para otimizar processos; em finanças, para médias de retornos simulados em Monte Carlo; em saúde, para tempos de resposta em modelos de epidemias, auxiliando decisões baseadas em evidências com quantificação de incerteza."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.1.2",
                            "name": "Determinar o Número de Réplicas Necessário",
                            "description": "Utilizar fórmulas para calcular o número mínimo de réplicas independentes em uma simulação para alcançar um intervalo de confiança com precisão e confiança desejadas, considerando a variância estimada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Intervalo de Confiança e Réplicas",
                                  "subSteps": [
                                    "Defina intervalo de confiança (IC) como uma faixa estimada para o parâmetro populacional com um nível de confiança específico.",
                                    "Explique precisão (E) como a metade da largura do IC desejada, representando a margem de erro.",
                                    "Descreva o nível de confiança (1-α), como 95%, e o valor crítico Z (ex: 1.96 para 95%).",
                                    "Entenda variância (s²) como medida de dispersão dos resultados da simulação, estimada de réplicas piloto.",
                                    "Discuta por que réplicas devem ser independentes para validade estatística."
                                  ],
                                  "verification": "Escreva definições curtas para cada conceito e dê um exemplo simples de simulação (ex: lançamento de dados).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de papel ou editor de texto",
                                    "Tabela de valores Z para níveis de confiança",
                                    "Calculadora"
                                  ],
                                  "tips": "Use analogias cotidianas, como estimar altura média de uma população com amostras.",
                                  "learningObjective": "Identificar e explicar os parâmetros chave necessários para calcular réplicas.",
                                  "commonMistakes": [
                                    "Confundir precisão com nível de confiança",
                                    "Ignorar independência das réplicas",
                                    "Usar desvio padrão em vez de variância"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender e Memorizar a Fórmula para Número de Réplicas",
                                  "subSteps": [
                                    "Estude a fórmula: n = (Z * s / E)², onde n é o número mínimo de réplicas, Z é o valor crítico, s é o desvio padrão estimado (raiz de s²), e E é a precisão desejada.",
                                    "Derive intuitivamente a fórmula a partir da aproximação normal para a média amostral.",
                                    "Identifique que n deve ser arredondado para cima para o inteiro seguinte.",
                                    "Pratique reescrevendo a fórmula com diferentes notações (ex: t para amostras pequenas).",
                                    "Discuta limitações, como assumir normalidade e variância conhecida."
                                  ],
                                  "verification": "Escreva a fórmula de memória e aplique a valores fictícios simples (Z=1.96, s=2, E=0.5).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Fórmula anotada",
                                    "Calculadora",
                                    "Software de planilha como Excel ou Google Sheets"
                                  ],
                                  "tips": "Arredonde n sempre para cima e verifique se n > 30 para validade da aproximação normal.",
                                  "learningObjective": "Dominar a fórmula e suas componentes para aplicação direta.",
                                  "commonMistakes": [
                                    "Esquecer o quadrado na fórmula",
                                    "Usar Z incorreto para o nível de confiança",
                                    "Não arredondar para cima"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estimar a Variância a Partir de Réplicas Piloto",
                                  "subSteps": [
                                    "Execute 10-20 réplicas piloto de uma simulação simples para coletar dados.",
                                    "Calcule a média e variância amostral dos resultados piloto usando s² = Σ(xi - x̄)² / (m-1), onde m é o número de pilotos.",
                                    "Converta variância para desvio padrão s se necessário.",
                                    "Avalie se a variância é estável; execute mais pilotos se houver alta variabilidade.",
                                    "Documente os resultados em uma tabela para referência."
                                  ],
                                  "verification": "Calcule variância de um conjunto de dados piloto fornecido e compare com valor esperado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código de simulação simples (Python/R ou planilha)",
                                    "Dados de exemplo de simulação",
                                    "Calculadora ou software estatístico"
                                  ],
                                  "tips": "Use pelo menos 10 pilotos para boa estimativa inicial; evite simulações muito longas.",
                                  "learningObjective": "Adquirir variância confiável para input na fórmula.",
                                  "commonMistakes": [
                                    "Usar divisão por m em vez de m-1 para variância amostral",
                                    "Réplicas não independentes (ex: sementes correlacionadas)",
                                    "Ignorar outliers nos pilotos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular, Interpretar e Validar o Número de Réplicas",
                                  "subSteps": [
                                    "Insira valores na fórmula: Z do nível desejado, s da estimativa, E da precisão.",
                                    "Calcule n e execute as réplicas finais para verificar o IC resultante.",
                                    "Confira se a largura do IC atende à precisão E (2E total).",
                                    "Ajuste n iterativamente se necessário (ex: se variância subestimada).",
                                    "Registre o processo em um relatório curto."
                                  ],
                                  "verification": "Produza um IC com n calculado que tenha largura ≤ 2E e contenha a média conhecida (se simulada).",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Software de simulação",
                                    "Planilha para cálculos",
                                    "Tabela Z"
                                  ],
                                  "tips": "Sempre valide com runs reais; considere custo computacional para n grande.",
                                  "learningObjective": "Aplicar a fórmula end-to-end e validar resultados.",
                                  "commonMistakes": [
                                    "Cálculo aritmético errado",
                                    "Não validar com simulação real",
                                    "Escolher E irrealista sem considerar variância"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de Monte Carlo para tempo médio de espera em uma fila (fila M/M/1), com variância piloto s²=12 (s≈3.46), precisão E=1 minuto e confiança 95% (Z=1.96). Calcule n = (1.96 * 3.46 / 1)² ≈ 46 réplicas. Execute 46 runs independentes e confirme IC de largura ≈2 minutos.",
                              "finalVerifications": [
                                "Calcule n corretamente para o exemplo prático.",
                                "Explique o impacto de dobrar E no valor de n.",
                                "Identifique quando usar distribuição t em vez de Z.",
                                "Valide IC de uma simulação com n calculado.",
                                "Discuta trade-offs entre precisão, confiança e custo computacional.",
                                "Estime variância de 15 runs piloto com precisão."
                              ],
                              "assessmentCriteria": [
                                "Fórmula aplicada corretamente sem erros aritméticos.",
                                "Variância estimada de pilotos com fórmula amostral adequada.",
                                "IC resultante atende precisão e confiança especificadas.",
                                "Réplicas confirmadas como independentes.",
                                "Interpretação clara dos resultados e limitações.",
                                "Documentação completa do processo."
                              ],
                              "crossCurricularConnections": [
                                "Estatística Inferencial: Construção de ICs e testes de hipóteses.",
                                "Programação Computacional: Implementação de simulações em Python/R.",
                                "Engenharia de Sistemas: Otimização de experimentos em manufatura.",
                                "Ciência de Dados: Amostragem em machine learning.",
                                "Gestão de Projetos: Planejamento de recursos computacionais."
                              ],
                              "realWorldApplication": "Em simulações de risco financeiro (ex: Value at Risk em bancos), calcular réplicas necessárias garante previsões confiáveis sem desperdício computacional excessivo, otimizando decisões de investimento sob incerteza."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.1.3",
                            "name": "Interpretar Largura do Intervalo de Confiança",
                            "description": "Analisar a largura do intervalo de confiança para avaliar a precisão dos resultados da simulação e decidir se mais réplicas são necessárias para refinar a estimativa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Largura do Intervalo de Confiança",
                                  "subSteps": [
                                    "Revise a fórmula do intervalo de confiança (IC): média ± (valor crítico * erro padrão).",
                                    "Identifique que a 'largura' é a diferença entre o limite superior e inferior do IC.",
                                    "Entenda que largura = 2 * (valor crítico * erro padrão).",
                                    "Discuta como a largura reflete a variabilidade dos dados da simulação.",
                                    "Compare exemplos: IC estreito (alta precisão) vs. IC largo (baixa precisão)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que a largura do IC representa e dê um exemplo numérico simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de aula sobre IC",
                                    "Calculadora ou software como Excel/Python"
                                  ],
                                  "tips": "Visualize a largura como a 'margem de erro' total; quanto menor, melhor a estimativa.",
                                  "learningObjective": "Definir e calcular a largura do IC a partir de componentes básicos.",
                                  "commonMistakes": [
                                    "Confundir largura com o valor crítico",
                                    "Ignorar o papel do erro padrão na largura"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a Largura do IC a Partir de Dados de Simulação",
                                  "subSteps": [
                                    "Colete os resultados das réplicas da simulação (ex.: médias de 10 runs).",
                                    "Calcule a média amostral e o desvio padrão dos resultados.",
                                    "Determine o erro padrão (desvio padrão / sqrt(n), onde n é o número de réplicas).",
                                    "Aplique o valor crítico (ex.: 1.96 para 95% de confiança com n grande).",
                                    "Compute a largura: 2 * (valor crítico * erro padrão)."
                                  ],
                                  "verification": "Produza um cálculo correto com dados de amostra, mostrando todos os passos intermediários.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Dados de simulação de exemplo",
                                    "Planilha Excel ou script Python (numpy, scipy)"
                                  ],
                                  "tips": "Use funções prontas como scipy.stats.t.interval() para validar cálculos manuais.",
                                  "learningObjective": "Executar o cálculo preciso da largura do IC usando dados reais de simulação.",
                                  "commonMistakes": [
                                    "Usar desvio padrão em vez de erro padrão",
                                    "Esquecer o fator 2 na largura total"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar a Largura em Termos de Precisão",
                                  "subSteps": [
                                    "Defina thresholds subjetivos ou baseados em contexto (ex.: largura < 5% da média é aceitável).",
                                    "Analise: IC largo indica alta variabilidade → precisão baixa.",
                                    "Compare com requisitos do projeto: tolerância de erro desejada.",
                                    "Visualize com gráficos: plotar ICs de diferentes números de réplicas.",
                                    "Avalie o trade-off: mais réplicas reduzem largura, mas aumentam tempo computacional."
                                  ],
                                  "verification": "Interprete um IC dado (ex.: [45, 55]) como 'preciso' ou 'impreciso' justificando com contexto.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráficos de ICs gerados em software",
                                    "Tabela de thresholds de precisão"
                                  ],
                                  "tips": "Relacione a largura à unidade de medida (ex.: segundos em tempo de espera).",
                                  "learningObjective": "Avaliar qualitativamente e quantitativamente a precisão baseada na largura.",
                                  "commonMistakes": [
                                    "Interpretar IC largo como 'incerto' sem ligar à precisão",
                                    "Ignorar o contexto da aplicação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Decidir sobre Réplicas Adicionais Baseado na Largura",
                                  "subSteps": [
                                    "Estabeleça critérios de parada: ex. largura ≤ threshold ou budget de réplicas esgotado.",
                                    "Simule cenários: calcule largura esperada com mais réplicas (1/sqrt(n)).",
                                    "Decida: se largo, planeje +réplicas; documente justificativa.",
                                    "Atualize o experimento: rode simulações adicionais e recalcule IC.",
                                    "Registre decisão em relatório: largura inicial, final e razão."
                                  ],
                                  "verification": "Elabore um relatório curto recomendando ação (mais réplicas ou parar) com cálculos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Software de simulação (ex.: Python com simpy)",
                                    "Relatório template"
                                  ],
                                  "tips": "Monitore convergência: plote largura vs. n para prever quando parar.",
                                  "learningObjective": "Tomar decisões acionáveis sobre refino de simulações usando largura do IC.",
                                  "commonMistakes": [
                                    "Aumentar réplicas indefinidamente sem threshold",
                                    "Não considerar custo computacional"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado, após 20 réplicas, o IC do tempo médio de espera é [4.2, 5.8] minutos (largura=1.6 min). Como é largo (>10% da média), rode +30 réplicas, obtendo [4.5, 5.1] (largura=0.6 min), agora preciso o suficiente para decisões de staffing.",
                              "finalVerifications": [
                                "Calcula corretamente a largura de um IC dado.",
                                "Explica o impacto de uma largura larga na confiabilidade da estimativa.",
                                "Propõe threshold apropriado para um contexto específico.",
                                "Decide corretamente se mais réplicas são necessárias com justificativa.",
                                "Visualiza ICs em gráfico e interpreta mudanças.",
                                "Relaciona largura ao erro padrão e número de réplicas."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo da largura (100% correto).",
                                "Interpretação contextualizada da precisão (qualitativa e quantitativa).",
                                "Decisão lógica baseada em thresholds e trade-offs.",
                                "Uso adequado de visualizações e ferramentas.",
                                "Documentação clara de passos e justificativas.",
                                "Identificação de erros comuns e como evitá-los."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Conceitos de variância e inferência.",
                                "Programação: Implementação em Python/R para cálculos de IC.",
                                "Engenharia Industrial: Otimização de simulações em manufatura.",
                                "Ciência de Dados: Análise de resultados de Monte Carlo.",
                                "Gestão de Projetos: Decisões baseadas em critérios de precisão."
                              ],
                              "realWorldApplication": "Em simulações de supply chain, interpretar largura de IC no tempo de entrega permite decidir mais runs para refinar previsões, evitando estoques excessivos ou faltas, economizando milhões em logística."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.5.2",
                        "name": "Testes Estatísticos para Validação",
                        "description": "Métodos estatísticos para testar hipóteses sobre os resultados da simulação, validando se as estimativas são suficientemente precisas ou comparáveis a valores conhecidos.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.2.1",
                            "name": "Realizar Teste t para Média",
                            "description": "Executar o teste t de Student para uma amostra ou duas amostras independentes, verificando se a média simulada difere significativamente de um valor hipotético ou de outra simulação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir Hipóteses e Preparar Dados",
                                  "subSteps": [
                                    "Identifique o tipo de teste: uma amostra (comparar com valor hipotético) ou duas amostras independentes (comparar médias de grupos).",
                                    "Estabeleça H0 (hipótese nula: médias iguais ou igual a μ0) e H1 (hipótese alternativa: unidirecional ou bidirecional).",
                                    "Colete ou carregue os dados de simulação em um ambiente computacional (ex: Python com pandas ou R).",
                                    "Calcule estatísticas descritivas básicas: média, desvio padrão e tamanho da amostra.",
                                    "Defina nível de significância α (geralmente 0.05)."
                                  ],
                                  "verification": "Hipóteses claras documentadas e dados carregados com estatísticas descritivas exibidas corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software: Python (scipy.stats, pandas) ou R",
                                    "Dados de simulação (CSV ou gerados)",
                                    "Notebook Jupyter ou RStudio"
                                  ],
                                  "tips": "Use nomes claros para variáveis de dados para evitar confusão entre amostras.",
                                  "learningObjective": "Formular hipóteses estatísticas precisas e preparar dados para análise.",
                                  "commonMistakes": [
                                    "Confundir H0 e H1",
                                    "Esquecer de especificar o tipo de teste (unilateral/bilateral)",
                                    "Não registrar α"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar Premissas do Teste t",
                                  "subSteps": [
                                    "Teste normalidade dos dados: use Shapiro-Wilk ou QQ-plot (para amostras pequenas).",
                                    "Para duas amostras, verifique homogeneidade de variâncias com teste de Levene ou F.",
                                    "Se premissas violadas, considere alternativas como teste t de Welch ou não-paramétrico (Wilcoxon).",
                                    "Visualize dados com histogramas, boxplots ou gráficos de densidade.",
                                    "Documente resultados dos testes de premissas."
                                  ],
                                  "verification": "Relatório com p-values dos testes de normalidade e variância, e gráficos gerados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Bibliotecas: scipy.stats (Python) ou nortest (R)",
                                    "Ferramentas de plotagem: matplotlib/seaborn ou ggplot2"
                                  ],
                                  "tips": "Para n > 30, normalidade pode ser assumida pelo Teorema Central do Limite.",
                                  "learningObjective": "Avaliar validade das premissas para garantir robustez do teste t.",
                                  "commonMistakes": [
                                    "Ignorar violações de normalidade",
                                    "Usar teste t Welch sem verificar variâncias",
                                    "Não plotar dados visualmente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar o Teste t de Student",
                                  "subSteps": [
                                    "Para uma amostra: use ttest_1samp(dados, μ0) ou t.test(dados, mu=μ0).",
                                    "Para duas amostras: use ttest_ind(amostra1, amostra2) ou t.test(amostra1, amostra2).",
                                    "Extraia estatísticas: valor t, graus de liberdade (df), p-value.",
                                    "Ajuste para bilateral/unilateral se necessário (divida p-value por 2 para unilateral).",
                                    "Salve resultados em uma tabela ou dicionário."
                                  ],
                                  "verification": "Código executado sem erros, com valor t, df e p-value corretos exibidos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Bibliotecas: scipy.stats.ttest_1samp/ttest_ind (Python) ou stats::t.test (R)"
                                  ],
                                  "tips": "Sempre especifique equal_var=False se variâncias diferem (Welch).",
                                  "learningObjective": "Implementar computacionalmente o teste t para diferentes cenários.",
                                  "commonMistakes": [
                                    "Usar teste errado para o número de amostras",
                                    "Esquecer ajuste para unilateral",
                                    "Confundir valor t com p-value"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Resultados e Concluir",
                                  "subSteps": [
                                    "Compare p-value com α: rejeite H0 se p < α.",
                                    "Calcule intervalo de confiança para a média (ou diferença de médias).",
                                    "Discuta implicações no contexto da simulação (ex: validação do modelo).",
                                    "Reporte em formato padronizado: 't(df) = valor, p = valor, [rejeitar/aceitar] H0'.",
                                    "Sugira próximos passos se não significativo (aumentar amostra)."
                                  ],
                                  "verification": "Relatório escrito com interpretação correta, IC e conclusão lógica.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Templates de relatório em Markdown ou LaTeX"
                                  ],
                                  "tips": "Inclua efeito prático (tamanho do efeito Cohen's d) além de significância.",
                                  "learningObjective": "Traduzir resultados estatísticos em conclusões acionáveis.",
                                  "commonMistakes": [
                                    "Confundir rejeitar H0 com 'provar H1'",
                                    "Ignorar tamanho da amostra",
                                    "Não reportar df"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de filas discretas, teste se a média de tempos de espera (amostra de 50 runs) difere significativamente de 5 minutos (μ0=5). Use Python: from scipy.stats import ttest_1samp; resultado = ttest_1samp(tempos_espera, 5). Se p<0.05, ajuste o modelo de simulação.",
                              "finalVerifications": [
                                "Hipóteses H0/H1 corretamente definidas para o cenário.",
                                "Premissas verificadas com testes e gráficos apropriados.",
                                "Valor t, df e p-value calculados precisamente.",
                                "Interpretação coerente: rejeição/aceitação de H0 baseada em α.",
                                "Relatório completo com IC e implicações para simulação.",
                                "Código reproduzível e livre de erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação de hipóteses (20%)",
                                "Validação rigorosa de premissas (25%)",
                                "Execução correta do teste computacional (20%)",
                                "Interpretação estatística e relatório claro (25%)",
                                "Uso eficiente de ferramentas e documentação (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação em Python/R para análise estatística.",
                                "Simulação: Validação de modelos estocásticos discretos.",
                                "Probabilidade: Entendimento de distribuições t-Student e p-values.",
                                "Ciência de Dados: Visualização e manipulação de dados com pandas/ggplot."
                              ],
                              "realWorldApplication": "Em controle de qualidade industrial, testar se a média de tempos de produção em uma linha simulada difere de um padrão (ex: 10 unidades/hora), permitindo otimizar processos antes de implementação real e reduzir custos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.2.2",
                            "name": "Aplicar Teste Qui-Quadrado para Distribuições",
                            "description": "Usar o teste qui-quadrado de aderência para validar se a distribuição empírica dos resultados da simulação segue uma distribuição teórica esperada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Coletar e organizar os dados empíricos da simulação",
                                  "subSteps": [
                                    "Executar a simulação para gerar um número suficiente de observações (mínimo 100-1000 iterações dependendo da complexidade).",
                                    "Categorizar os resultados em bins ou classes discretas.",
                                    "Contar e registrar as frequências observadas (O_i) para cada categoria em uma tabela ou estrutura de dados."
                                  ],
                                  "verification": "Somar as frequências observadas e confirmar que equals o total de simulações realizadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software de simulação (Python com NumPy, R ou Excel)",
                                    "Planilha para tabulação inicial"
                                  ],
                                  "tips": "Use amostras grandes para garantir validade do teste; armazene dados em array ou DataFrame para automação.",
                                  "learningObjective": "Preparar dados empíricos de simulações de forma precisa e organizada.",
                                  "commonMistakes": [
                                    "Amostra muito pequena (menos de 5 esperados por categoria)",
                                    "Erros de categorização ou contagem manual"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir hipóteses e calcular frequências esperadas",
                                  "subSteps": [
                                    "Estabelecer H0: 'A distribuição empírica segue a distribuição teórica esperada' e H1: 'Não segue'.",
                                    "Definir as probabilidades teóricas (p_i) para cada categoria baseadas no modelo (ex: uniforme para dado).",
                                    "Calcular frequências esperadas E_i = N * p_i, onde N é o total de observações."
                                  ],
                                  "verification": "Verificar se soma(E_i) = N e cada E_i >= 5; ajustar categorias se necessário.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Documentação do modelo teórico",
                                    "Calculadora ou script Python/R"
                                  ],
                                  "tips": "Para distribuições não-uniformes, use histogramas teóricos; garanta independência das observações.",
                                  "learningObjective": "Formular hipóteses claras e computar expectativas teóricas com precisão.",
                                  "commonMistakes": [
                                    "Probabilidades teóricas incorretas",
                                    "Ignorar condição E_i >=5, levando a teste inválido"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a estatística Qui-Quadrado",
                                  "subSteps": [
                                    "Para cada categoria i: computar contribuição (O_i - E_i)^2 / E_i.",
                                    "Somar todas as contribuições para obter χ² = Σ (O_i - E_i)^2 / E_i.",
                                    "Determinar graus de liberdade df = k - 1, onde k é o número de categorias."
                                  ],
                                  "verification": "Comparar χ² calculado manualmente com resultado de função built-in (ex: scipy.stats.chisquare).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Biblioteca SciPy (Python) ou base R",
                                    "Editor de código (Jupyter Notebook)"
                                  ],
                                  "tips": "Automatize com loop ou vetorização para evitar erros aritméticos; plote barras O vs E para visualização.",
                                  "learningObjective": "Executar o cálculo central do teste Qui-Quadrado de aderência.",
                                  "commonMistakes": [
                                    "Dividir por O_i em vez de E_i",
                                    "Esquecer de subtrair ou elevar ao quadrado incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Determinar p-valor e interpretar resultados",
                                  "subSteps": [
                                    "Usar função de distribuição qui-quadrado para calcular p-valor: 1 - cdf(χ², df).",
                                    "Escolher nível de significância α (ex: 0.05) e comparar: se p <= α, rejeitar H0.",
                                    "Concluir sobre a aderência e discutir limitações (ex: tamanho da amostra)."
                                  ],
                                  "verification": "Executar teste completo em software e confirmar p-valor e decisão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Funções stats: chisquare (Python), chisq.test (R)",
                                    "Tabela qui-quadrado para verificação manual"
                                  ],
                                  "tips": "Sempre reporte χ², df, p-valor e α; considere aproximação assintótica válida apenas para N grande.",
                                  "learningObjective": "Avaliar significância estatística e interpretar no contexto da simulação.",
                                  "commonMistakes": [
                                    "Confundir p-valor com probabilidade de H0 verdadeira",
                                    "Usar df incorreto (ex: k em vez de k-1)"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar e validar a análise",
                                  "subSteps": [
                                    "Gerar relatório com tabela O/E, χ², p-valor e conclusão.",
                                    "Realizar simulações adicionais para sensibilidade (ex: variar N).",
                                    "Verificar pressupostos do teste (independência, categorias mutuamente exclusivas)."
                                  ],
                                  "verification": "Peer-review ou auto-teste com dados conhecidos (ex: dado justo deve ter p alto).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Template de relatório LaTeX/Markdown",
                                    "Dados de teste padrão"
                                  ],
                                  "tips": "Inclua código fonte para reprodutibilidade; visualize resíduos padronizados.",
                                  "learningObjective": "Comunicar resultados de forma profissional e validar robustez.",
                                  "commonMistakes": [
                                    "Omitir limitações do teste",
                                    "Não documentar código ou suposições"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de 1000 lançamentos de um dado de 6 faces (supostamente justo), conte frequências observadas: [162, 170, 165, 158, 172, 173]. Probabilidades teóricas: 1/6 cada. Calcule χ² ≈ 1.42, df=5, p≈0.92 >0.05 → não rejeita uniformidade.",
                              "finalVerifications": [
                                "Cálculo correto de χ² e p-valor em exemplo prático.",
                                "Interpretação adequada da decisão (rejeitar/não rejeitar H0).",
                                "Verificação de pressupostos (E_i >=5, independência).",
                                "Relatório completo com tabelas e conclusões.",
                                "Reprodutibilidade via código executável.",
                                "Análise de sensibilidade a variações na amostra."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de O_i, E_i e χ² (erro <1%).",
                                "Correta formulação de hipóteses e df.",
                                "Interpretação estatística válida do p-valor.",
                                "Uso adequado de software com código limpo.",
                                "Documentação clara e conexões com simulação.",
                                "Identificação de erros comuns e limitações."
                              ],
                              "crossCurricularConnections": [
                                "Estatística Inferencial (testes de hipóteses)",
                                "Programação Computacional (NumPy/SciPy, R)",
                                "Simulações em Física (distribuições discretas)",
                                "Análise de Dados em Engenharia (validação de modelos)",
                                "Bioinformática (testes em sequências genéticas)"
                              ],
                              "realWorldApplication": "Validação de geradores de números pseudo-aleatórios em criptografia e jogos; controle de qualidade em linhas de produção (distribuição de defeitos); análise de padrões em dados observacionais como pesquisas eleitorais ou tráfego de rede."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.2.3",
                            "name": "Avaliar Poder do Teste e Nível de Significância",
                            "description": "Determinar o nível de significância (alpha) e calcular o poder do teste para garantir que os testes estatísticos sejam robustos na validação da precisão simulada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Nível de Significância e Poder do Teste",
                                  "subSteps": [
                                    "Definir nível de significância (α) como a probabilidade de cometer erro tipo I (rejeitar H₀ quando verdadeira).",
                                    "Definir poder do teste como 1 - β, onde β é a probabilidade de erro tipo II (não rejeitar H₀ quando falsa).",
                                    "Explicar fatores que influenciam o poder: tamanho do efeito (δ), tamanho da amostra (n), variância (σ²) e α.",
                                    "Discutir trade-offs: reduzir α aumenta β, diminuindo o poder.",
                                    "Revisar notação padrão para testes de hipóteses em contextos de simulação."
                                  ],
                                  "verification": "Resumir em 3-5 frases os conceitos de α e poder, incluindo uma analogia simples.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Estatística Inferencial (ex: 'Mathematical Statistics' de Wackerly)",
                                    "Vídeos tutoriais sobre power analysis (Khan Academy ou YouTube)",
                                    "Folha de anotações"
                                  ],
                                  "tips": "Use a analogia de um detector de mentiras: α é risco de acusar inocente, poder é chance de pegar culpado.",
                                  "learningObjective": "Dominar definições, relações e trade-offs entre α, β, poder e parâmetros estatísticos.",
                                  "commonMistakes": [
                                    "Confundir α com poder do teste.",
                                    "Ignorar que poder depende do tamanho do efeito alternativo.",
                                    "Assumir α fixo sem contexto."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar o Nível de Significância (α) Apropriado",
                                  "subSteps": [
                                    "Avaliar custos relativos de erros tipo I e II no contexto de validação de simulações.",
                                    "Escolher α padrão (0.05 para exploratory, 0.01 para confirmatório) baseado em domínio.",
                                    "Considerar ajustes para múltiplos testes (ex: Bonferroni: α/k).",
                                    "Documentar justificativa com referência a normas em simulações discretas.",
                                    "Verificar sensibilidade variando α em cenários hipotéticos."
                                  ],
                                  "verification": "Justificar α=0.05 para um teste de média em simulação de fila, citando prós e contras.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Artigo 'Statistical Validation of Simulation Models' (IEEE)",
                                    "Tabela de valores convencionais de α por campo",
                                    "Calculadora para simulações rápidas"
                                  ],
                                  "tips": "Em simulações, priorize α menor se falso positivo custa caro (ex: rejeitar modelo bom).",
                                  "learningObjective": "Capacitar escolha contextualizada de α para robustez em testes estatísticos.",
                                  "commonMistakes": [
                                    "Escolher α arbitrariamente sem contexto.",
                                    "Esquecer correções para testes múltiplos.",
                                    "Subestimar impacto de α no poder."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o Poder do Teste",
                                  "subSteps": [
                                    "Identificar parâmetros: H₀ (μ=μ₀), H₁ (μ=μ₁), σ, n.",
                                    "Aplicar fórmula para teste z unilateral: z = (μ₁ - μ₀)/(σ/√n), poder = 1 - Φ(z_{α} - z).",
                                    "Implementar cálculo em software (R: pwr.t.test(), Python: statsmodels.stats.power).",
                                    "Gerar curvas de poder variando n ou δ para visualização.",
                                    "Validar com simulação Monte Carlo de 1000 réplicas."
                                  ],
                                  "verification": "Calcular e plotar poder para n=100, δ=0.2, σ=1, α=0.05, obtendo poder ≈0.85.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "R ou Python com pacotes pwr/statsmodels",
                                    "Jupyter Notebook template para power analysis",
                                    "Dados de exemplo de simulação M/M/1"
                                  ],
                                  "tips": "Sempre plote curvas de poder vs n para insight visual intuitivo.",
                                  "learningObjective": "Executar cálculos precisos de poder usando fórmulas e ferramentas computacionais.",
                                  "commonMistakes": [
                                    "Erro no sinal da alternativa (unilateral vs bilateral).",
                                    "Usar σ amostral em vez de populacional.",
                                    "Ignorar aproximações para testes t."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Robustez, Interpretar e Aplicar aos Resultados de Simulação",
                                  "subSteps": [
                                    "Verificar se poder ≥ 0.80; se não, recomendar aumentar n ou refinar modelo.",
                                    "Interpretar: alto poder confirma robustez; baixo indica risco de falso negativo.",
                                    "Integrar em relatório de validação: relatar α, poder e confiança nos resultados simulados.",
                                    "Simular ajuste: recalcular poder após mudanças em n ou modelo.",
                                    "Discutir limitações como suposições de normalidade em simulações discretas."
                                  ],
                                  "verification": "Analisar relatório completo: recomendar n mínimo para poder=0.90 em cenário dado.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Template de relatório de análise estatística",
                                    "Software de simulação (ex: SimPy ou Arena)",
                                    "Checklist de validação estatística"
                                  ],
                                  "tips": "Padrão industrial: mire poder 0.80-0.90 para publicação ou decisão.",
                                  "learningObjective": "Integrar avaliação de poder e α na validação prática de simulações discretas.",
                                  "commonMistakes": [
                                    "Não reportar poder no estudo.",
                                    "Ajustar apenas α sem considerar n.",
                                    "Generalizar poder sem contexto específico."
                                  ]
                                }
                              ],
                              "practicalExample": "Em simulação de sistema de filas M/M/1 com λ=4, μ=5, valide se tempo médio de espera simulada (W_sim=5.2 min) ≠ analítico (W=5 min). Use α=0.05, n=100, σ=1.2, δ=0.2. Calcule poder ≈0.82 via Python; se <0.80, aumente n para 150.",
                              "finalVerifications": [
                                "Explicar corretamente α e poder com fórmulas.",
                                "Calcular poder manualmente para teste z simples.",
                                "Escolher e justificar α em contexto de simulação.",
                                "Implementar power analysis em código e interpretar plot.",
                                "Recomendar ajustes para poder alvo de 0.90."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de poder (>95% match com software).",
                                "Justificativa contextual de α (cobrir custos de erros).",
                                "Interpretação correta de resultados (alto/baixo poder).",
                                "Código funcional e plot de curvas de poder.",
                                "Relatório claro com limitações e recomendações."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Distribuições (normal, t para aproximações).",
                                "Programação Computacional (implementação em R/Python para simulações).",
                                "Design de Experimentos (otimização de n).",
                                "Análise de Dados (validação estatística em big data simulada).",
                                "Ciência da Computação (modelagem de sistemas discretos)."
                              ],
                              "realWorldApplication": "Em engenharia de telecomunicações, validar precisão de simulações de redes discretas-eventos para dimensionar infraestrutura, evitando sub ou super-dimensionamento custoso; ou em logística para testar robustez de modelos de supply chain simulados."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.2.4",
                            "name": "Interpretar p-valores em Contextos de Simulação",
                            "description": "Analisar p-valores obtidos de testes para decidir sobre a rejeição da hipótese nula, considerando múltiplos testes e correções como Bonferroni em experimentos de simulação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de p-valores e Hipóteses",
                                  "subSteps": [
                                    "Defina a hipótese nula (H0) como a suposição de ausência de efeito ou diferença.",
                                    "Explique o p-valor como a probabilidade de obter resultados tão extremos quanto os observados, assumindo H0 verdadeira.",
                                    "Discuta o nível de significância (α, tipicamente 0.05) como o limiar para rejeição de H0.",
                                    "Diferencie p-valor de probabilidade de H0 ser verdadeira.",
                                    "Revise tipos de erro: Tipo I (falso positivo) e Tipo II (falso negativo)."
                                  ],
                                  "verification": "Resuma em suas palavras os conceitos de H0, p-valor e α, e identifique um exemplo de erro Tipo I.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notebook com exemplos de testes de hipóteses",
                                    "Artigo introdutório sobre p-valores (ex: Khan Academy)"
                                  ],
                                  "tips": "Use analogias como 'p-valor é como a chance de chover dado céu azul; não prova que vai chover'.",
                                  "learningObjective": "Dominar definições e interpretações básicas para base sólida.",
                                  "commonMistakes": [
                                    "Confundir p-valor com P(H0|dados)",
                                    "Ignorar que p-valor não mede tamanho do efeito"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Interpretar p-valores em Testes Únicos",
                                  "subSteps": [
                                    "Colete p-valor de um teste estatístico (ex: t-test de simulação).",
                                    "Compare p-valor com α: se p ≤ α, rejeite H0; caso contrário, não rejeite.",
                                    "Considere o contexto da simulação: resultados observados vs. esperados sob H0.",
                                    "Registre a decisão e justifique com evidência numérica.",
                                    "Avalie a força da evidência (ex: p<0.01 é mais forte que p=0.04)."
                                  ],
                                  "verification": "Interprete um p-valor fornecido (ex: p=0.03, α=0.05) e decida corretamente sobre H0.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de simulação (Python com scipy.stats)",
                                    "Dataset simulado simples (ex: lançamentos de moeda)"
                                  ],
                                  "tips": "Sempre pergunte: 'Isso é evidência suficiente contra H0 no contexto da simulação?'",
                                  "learningObjective": "Aplicar regra de decisão para testes isolados com confiança.",
                                  "commonMistakes": [
                                    "Rejeitar H0 baseado em p próximo de α sem contexto",
                                    "Interpretar p>α como prova de H0"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Correções para Múltiplos Testes (Bonferroni)",
                                  "subSteps": [
                                    "Identifique o número de testes múltiplos (m) realizados na simulação.",
                                    "Calcule α ajustado: α_Bonferroni = α / m.",
                                    "Ajuste cada p-valor ou compare com novo α: rejeite se p ≤ α/m.",
                                    "Discuta limitações do Bonferroni (conservadorismo excessivo).",
                                    "Compare decisões antes e após correção para avaliar impacto."
                                  ],
                                  "verification": "Para 10 testes com α=0.05 e p=0.004 em um, aplique Bonferroni e confirme rejeição.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Excel ou Python script para múltiplos testes",
                                    "Tabela de p-valores simulados"
                                  ],
                                  "tips": "Automatize cálculos em código para evitar erros aritméticos.",
                                  "learningObjective": "Controlar taxa de falsos positivos em análises múltiplas.",
                                  "commonMistakes": [
                                    "Usar α original em múltiplos testes",
                                    "Confundir Bonferroni com FDR"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Interpretação em Contextos de Simulação e Concluir",
                                  "subSteps": [
                                    "Revise resultados da simulação: distribuições, médias, desvios.",
                                    "Decida coletivamente sobre H0 considerando todos p-valores corrigidos.",
                                    "Reporte conclusões: rejeitada/não rejeitada, com justificativa e implicações.",
                                    "Discuta robustez: sensibilidade a α ou tamanho amostral.",
                                    "Sugira próximos passos, como aumentar simulações."
                                  ],
                                  "verification": "Produza um relatório curto integrando 3 p-valores corrigidos de uma simulação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Relatório template em Markdown ou Word",
                                    "Resultados completos de simulação"
                                  ],
                                  "tips": "Estruture relatório: Introdução, Métodos, Resultados, Discussão.",
                                  "learningObjective": "Sintetizar análises para validação de modelos simulados.",
                                  "commonMistakes": [
                                    "Ignorar contexto da simulação",
                                    "Sobre-generalizar de p-valores"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de 1000 lançamentos de um dado virtual para testar se é justo (H0: média=3.5), realize 5 testes (média, variância, etc.). Obtenha p=0.02 para média (α=0.05 rejeita), mas com Bonferroni α=0.01, não rejeita. Conclusão: sem evidência forte de viés após correção.",
                              "finalVerifications": [
                                "Explicar corretamente o significado de p=0.01 em um teste.",
                                "Calcular α Bonferroni para m=20 e α=0.05.",
                                "Decidir rejeição para p=0.0025 com α_Bonferroni=0.0025.",
                                "Identificar risco de erro Tipo I em múltiplos testes sem correção.",
                                "Relatar implicações de não rejeição em simulação de sistema discreto.",
                                "Diferenciar interpretação em teste único vs. múltiplo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e interpretação de p-valor (20%)",
                                "Correta aplicação de Bonferroni em múltiplos testes (25%)",
                                "Decisões lógicas baseadas em contexto de simulação (20%)",
                                "Relatório claro e justificado (15%)",
                                "Identificação de erros comuns e limitações (10%)",
                                "Uso adequado de ferramentas computacionais (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação de simulações em Python/R",
                                "Estatística: Inferência e controle de erros familiares",
                                "Ciência de Dados: Validação de modelos preditivos",
                                "Física: Testes em simulações de sistemas discretos (ex: partículas)",
                                "Machine Learning: Ajuste de significância em validações cruzadas"
                              ],
                              "realWorldApplication": "Em pesquisa farmacêutica, simulações de ensaios clínicos testam múltiplas hipóteses sobre eficácia de drogas; correções como Bonferroni previnem falsos positivos, garantindo decisões seguras para aprovação regulatória."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.7",
                "name": "Técnicas de Redução de Variância",
                "description": "Apresenta métodos para minimizar a variância nas estimativas obtidas por simulações.",
                "totalSkills": 45,
                "atomicTopics": [
                  {
                    "id": "10.1.7.1",
                    "name": "Amostragem com Números Aleatórios Comuns",
                    "description": "Técnica que utiliza a mesma sequência de números aleatórios em réplicas de simulações comparativas para reduzir a variância das diferenças entre estimativas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.1.1",
                        "name": "Princípio da Amostragem com Números Aleatórios Comuns",
                        "description": "Conceito fundamental que explora o uso da mesma sequência de números aleatórios em réplicas comparativas de simulações para induzir correlação positiva entre as estimativas, reduzindo assim a variância das diferenças entre elas.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.1.1.1",
                            "name": "Definir Amostragem com Números Aleatórios Comuns (CRN)",
                            "description": "Explicar o que é a técnica de Common Random Numbers (CRN), incluindo sua aplicação em simulações de sistemas discretos para comparações de sistemas alternativos, destacando como ela sincroniza a aleatoriedade entre réplicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender simulações de sistemas discretos e variância",
                                  "subSteps": [
                                    "Revise o conceito de simulação de eventos discretos (DES).",
                                    "Identifique fontes de variância em estimativas de desempenho, como médias de tempos de espera.",
                                    "Explique por que réplicas independentes levam a alta variância em comparações.",
                                    "Calcule um exemplo simples de intervalo de confiança para uma média simulada.",
                                    "Discuta a necessidade de redução de variância para comparações precisas."
                                  ],
                                  "verification": "Resuma em uma frase o impacto da variância em comparações de sistemas e liste duas causas comuns.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Acesso a um simulador online de filas (ex: Simul8 trial)"
                                  ],
                                  "tips": "Use diagramas de fluxo de eventos para visualizar a variância.",
                                  "learningObjective": "Entender o problema de variância em simulações comparativas.",
                                  "commonMistakes": [
                                    "Confundir variância com viés",
                                    "Ignorar o efeito de réplicas curtas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o conceito de Números Aleatórios Comuns (CRN)",
                                  "subSteps": [
                                    "Defina CRN como o uso da mesma sequência de números aleatórios em múltiplas simulações.",
                                    "Compare com amostragem independente (réplicas com seeds diferentes).",
                                    "Explique a correlação positiva induzida entre estimativas de sistemas alternativos.",
                                    "Desenhe um diagrama mostrando streams sincronizados vs. independentes.",
                                    "Calcule covariança qualitativamente para ilustrar redução de variância."
                                  ],
                                  "verification": "Escreva a definição de CRN e diferencie de métodos independentes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel para diagramas",
                                    "Software de geração de RNG como Python random module"
                                  ],
                                  "tips": "Pense em CRN como 'filmando a mesma cena com câmeras diferentes' para sincronizar ruído.",
                                  "learningObjective": "Definir CRN e seu papel na sincronização de aleatoriedade.",
                                  "commonMistakes": [
                                    "Achar que CRN elimina variância completamente",
                                    "Confundir com quasimonte carlo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar a sincronização de aleatoriedade entre réplicas",
                                  "subSteps": [
                                    "Descreva como dividir streams de números aleatórios uniformes para eventos comuns.",
                                    "Implemente sincronização em um exemplo de fila: mesmo interarrivos e serviços para ambos sistemas.",
                                    "Discuta condições para correlação positiva (monotonicidade nas saídas).",
                                    "Gere um pequeno conjunto de dados simulados manualmente com CRN.",
                                    "Compare estatísticas de réplicas CRN vs. independentes."
                                  ],
                                  "verification": "Crie uma tabela comparativa de 10 réplicas mostrando menor variância com CRN.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python ou Excel para simulação simples",
                                    "Gerador de números aleatórios online"
                                  ],
                                  "tips": "Sempre use a mesma seed e ordem de consumo de RNG para sincronia perfeita.",
                                  "learningObjective": "Dominar o mecanismo de sincronização em CRN.",
                                  "commonMistakes": [
                                    "Usar RNGs diferentes para eventos idênticos",
                                    "Não verificar monotonicidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar CRN em comparações de sistemas alternativos",
                                  "subSteps": [
                                    "Selecione um sistema discreto simples (ex: filas M/M/1 com diferentes μ).",
                                    "Configure simulação com CRN para estimar diferença de médias.",
                                    "Analise resultados: intervalo de confiança para diferença.",
                                    "Discuta limitações: falha se correlação não for positiva.",
                                    "Resuma benefícios: redução de número de réplicas necessárias."
                                  ],
                                  "verification": "Simule e mostre que IC para diferença é menor com CRN.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Python com numpy e matplotlib",
                                    "Código template de simulação de fila"
                                  ],
                                  "tips": "Teste com poucos runs primeiro para validar sincronia visualmente.",
                                  "learningObjective": "Aplicar CRN para reduzir variância em comparações reais.",
                                  "commonMistakes": [
                                    "Aplicar CRN sem monotonicidade",
                                    "Interpretar erroneamente correlações negativas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de duas filas M/M/1 (uma com servidor rápido μ=2, outra lento μ=1, λ=1.5), use a mesma sequência de números aleatórios para interarrivos e serviços em 100 réplicas. Compare o tempo médio de espera: com CRN, a diferença estimada tem variância 70% menor que réplicas independentes, facilitando decidir qual servidor adotar.",
                              "finalVerifications": [
                                "Defina CRN corretamente em termos de sincronização de RNG.",
                                "Explique por que CRN reduz variância em comparações.",
                                "Identifique condições para sucesso (correlação positiva).",
                                "Gere um exemplo numérico simples com CRN.",
                                "Compare resultados CRN vs. independentes.",
                                "Liste limitações de CRN."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e mecanismo de CRN (30%)",
                                "Compreensão de redução de variância e correlação (25%)",
                                "Capacidade de implementação em exemplo prático (20%)",
                                "Identificação de condições e limitações (15%)",
                                "Clareza em diagramas e cálculos (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Covariância e intervalos de confiança.",
                                "Programação: Geradores de números pseudoaleatórios e simulações.",
                                "Probabilidade: Distribuições em simulações discretas.",
                                "Otimização: Redução de variância em métodos estocásticos."
                              ],
                              "realWorldApplication": "Na indústria logística, CRN é usado para comparar configurações de armazéns simulados (ex: diferentes layouts de robôs), reduzindo tempo de simulação em 50% ao precisar de menos réplicas para decisões confiáveis sobre investimentos em automação."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.1.2",
                            "name": "Explicar a Redução de Variância via Correlação Positiva",
                            "description": "Demonstrar matematicamente como a covariância positiva entre réplicas com CRN diminui a variância da diferença de estimativas, usando fórmulas como Var(θ̂₁ - θ̂₂) = Var(θ̂₁) + Var(θ̂₂) - 2Cov(θ̂₁, θ̂₂).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de Variância e Covariância",
                                  "subSteps": [
                                    "Defina variância como a medida de dispersão de uma estimativa θ̂.",
                                    "Explique covariância como a medida de dependência linear entre duas variáveis aleatórias θ̂₁ e θ̂₂.",
                                    "Discuta que Cov(θ̂₁, θ̂₂) > 0 indica correlação positiva.",
                                    "Revise a fórmula básica: Cov(θ̂₁, θ̂₂) = E[(θ̂₁ - E[θ̂₁])(θ̂₂ - E[θ̂₂])].",
                                    "Diferencie variância de uma única estimativa da variância de diferenças."
                                  ],
                                  "verification": "Escreva definições precisas e calcule Cov para dois exemplos simples de variáveis correlacionadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta; calculadora; notas de estatística básica.",
                                  "tips": "Use exemplos visuais como retas de regressão para ilustrar correlação positiva.",
                                  "learningObjective": "Compreender os fundamentos matemáticos de variância e covariância aplicados a estimativas.",
                                  "commonMistakes": "Confundir covariância com correlação; ignorar que covariância pode ser negativa."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Fórmula da Variância da Diferença de Estimativas",
                                  "subSteps": [
                                    "Comece com a definição: Var(θ̂₁ - θ̂₂) = E[(θ̂₁ - θ̂₂ - E[θ̂₁ - θ̂₂])²].",
                                    "Expanda usando propriedades de variância: Var(θ̂₁ - θ̂₂) = Var(θ̂₁) + Var(θ̂₂) - 2Cov(θ̂₁, θ̂₂).",
                                    "Assuma Var(θ̂₁) = Var(θ̂₂) = σ² para simplificação.",
                                    "Mostre que se Cov = 0 (independentes), Var = 2σ².",
                                    "Conclua que Cov > 0 reduz a variância total."
                                  ],
                                  "verification": "Derive a fórmula do zero e substitua valores numéricos para casos Cov=0 e Cov>0.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel e caneta; software simbólico como SymPy ou Mathematica (opcional).",
                                  "tips": "Anote cada expansão algébrica passo a passo para evitar erros aritméticos.",
                                  "learningObjective": "Dominar a derivação matemática que mostra o impacto da covariância na variância da diferença.",
                                  "commonMistakes": "Esquecer o sinal negativo no termo de covariância; assumir simetria sem justificativa."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar o Papel do CRN na Criação de Covariância Positiva",
                                  "subSteps": [
                                    "Descreva CRN: usar a mesma sequência de números aleatórios U para ambas as réplicas.",
                                    "Explique que θ̂₁ = f₁(U) e θ̂₂ = f₂(U), onde f₁ e f₂ são funções monotônicas na mesma direção.",
                                    "Mostre que se f₁ ↑ e f₂ ↑ com U, então Cov > 0.",
                                    "Discuta condições para correlação positiva: funções com inclinação positiva similar.",
                                    "Compare com amostragem independente (sequências U₁ e U₂ diferentes)."
                                  ],
                                  "verification": "Esboce gráficos de f₁(U) e f₂(U) e compute Cov manualmente para um U pequeno.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Gerador de números aleatórios online; Python ou R para plotar funções.",
                                  "tips": "Escolha funções simples como médias de exponenciais para visualizar a correlação.",
                                  "learningObjective": "Entender mecanicamente como CRN induz correlação positiva entre estimativas.",
                                  "commonMistakes": "Assumir CRN sempre funciona sem monotonia nas funções; ignorar normalização das sequências."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar Redução de Variância com Exemplo Numérico",
                                  "subSteps": [
                                    "Simule duas estimativas de médias μ₁ e μ₂ com N=100 réplicas independentes e com CRN.",
                                    "Calcule Var(θ̂₁ - θ̂₂) para ambos os casos.",
                                    "Compare: mostre redução percentual quando Cov > 0.",
                                    "Repita com diferentes N para observar escalabilidade.",
                                    "Analise o impacto quantitativo na precisão da estimativa de diferença."
                                  ],
                                  "verification": "Execute simulação e gere tabela comparativa de variâncias; redução >20% indica sucesso.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Python (bibliotecas numpy, matplotlib); ou R; código template para CRN.",
                                  "tips": "Use seed fixa para reprodutibilidade: np.random.seed(42).",
                                  "learningObjective": "Aplicar a teoria em simulação prática para validar a redução de variância.",
                                  "commonMistakes": "Não sincronizar seeds corretamente; usar funções não monotônicas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e Verificar Compreensão",
                                  "subSteps": [
                                    "Resuma: CRN → Cov > 0 → Var(θ̂₁ - θ̂₂) < 2σ².",
                                    "Discuta limitações: falha se funções não correlacionadas positivamente.",
                                    "Crie um fluxograma do processo CRN.",
                                    "Responda perguntas de autoavaliação sobre a fórmula.",
                                    "Planeje aplicação em problema real."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o mecanismo para um colega fictício.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel para fluxograma; gravador de áudio (opcional).",
                                  "tips": "Use analogia: 'como gêmeos correndo juntos vs. separadamente'.",
                                  "learningObjective": "Consolidar o conhecimento para explicação clara e identificação de aplicações.",
                                  "commonMistakes": "Superestimar benefícios sem condições; omitir prova matemática."
                                }
                              ],
                              "practicalExample": "Em uma simulação de filas M/M/1, estime a diferença de tempos médios de espera sob cargas ρ=0.7 e ρ=0.8. Use CRN com a mesma sequência de chegadas/serviços: gere U ~ Uniform(0,1), tempos interchegada= -log(U)/λ, etc. Simule 1000 réplicas; variância da diferença cai de ~0.015 (independente) para ~0.008 (CRN), reduzindo 47%.",
                              "finalVerifications": [
                                "Derive corretamente Var(θ̂₁ - θ̂₂) mostrando o termo -2Cov.",
                                "Simule exemplo simples e observe redução de variância >10%.",
                                "Identifique quando CRN falha (ex: funções opostas).",
                                "Explique monotonia necessária para Cov>0.",
                                "Compare variâncias em tabela numérica.",
                                "Crie fluxograma completo do processo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da fórmula (100% correta).",
                                "Correta implementação de CRN em código/simulação.",
                                "Quantificação exata da redução de variância.",
                                "Identificação clara de condições para sucesso.",
                                "Explicação verbal/mathemática fluida.",
                                "Análise de limitações e erros potenciais.",
                                "Integração com contexto de simulação de sistemas discretos."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Inferência e testes de hipóteses para diferenças de médias.",
                                "Programação: Implementação eficiente de geradores de RN em Python/R.",
                                "Finanças: Simulações de Monte Carlo para Value-at-Risk comparativo.",
                                "Engenharia: Otimização de simulações em manufatura (ex: filas).",
                                "Machine Learning: Redução de variância em ensembles de modelos."
                              ],
                              "realWorldApplication": "Em simulações financeiras de Monte Carlo para comparar retornos de portfólios A e B, CRN reduz variância da diferença de retornos esperados, permitindo detecção mais precisa de superioridade com menos réplicas, economizando tempo computacional em risco management de bancos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.1.3",
                            "name": "Identificar Condições de Aplicabilidade do CRN",
                            "description": "Reconhecer cenários ideais para CRN, como simulações com estruturas semelhantes e sem interações complexas entre streams de números aleatórios, evitando casos onde correlação negativa pode ocorrer.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos do CRN",
                                  "subSteps": [
                                    "Estude a definição de Common Random Numbers (CRN): uso da mesma sequência de números aleatórios para múltiplas simulações para induzir correlação positiva.",
                                    "Revise o objetivo principal: reduzir variância na estimativa da diferença entre sistemas.",
                                    "Analise diagramas de simulações discretas que usam streams independentes vs. streams comuns.",
                                    "Leia exemplos iniciais de literatura sobre redução de variância.",
                                    "Anote os benefícios em cenários de comparação de desempenho."
                                  ],
                                  "verification": "Resuma em 3 frases os princípios do CRN e seus benefícios; compare com simulações independentes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Artigo ou capítulo sobre técnicas de redução de variância",
                                    "Diagramas de simulação de filas M/M/1"
                                  ],
                                  "tips": "Foque em como a sincronização dos números aleatórios cria dependência positiva.",
                                  "learningObjective": "Entender o mecanismo e propósito do CRN para identificar contextos aplicáveis.",
                                  "commonMistakes": [
                                    "Confundir CRN com antithetic variates",
                                    "Ignorar que CRN visa correlação positiva, não independência"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Condições Ideais de Aplicabilidade",
                                  "subSteps": [
                                    "Liste critérios: estruturas de simulação semelhantes (mesmo número e tipo de eventos).",
                                    "Examine exemplos onde os sistemas têm topologias idênticas, como filas paralelas.",
                                    "Verifique ausência de interações complexas entre streams aleatórios.",
                                    "Pratique com casos onde o tempo de simulação é o mesmo para todos os sistemas.",
                                    "Crie uma checklist: similaridade estrutural, sincronização possível, outputs comparáveis."
                                  ],
                                  "verification": "Crie uma checklist com pelo menos 4 condições ideais e aplique a um exemplo simples.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Exemplos de simulações de filas",
                                    "Planilha para checklist",
                                    "Software de simulação como SimPy ou Arena (opcional)"
                                  ],
                                  "tips": "Priorize similaridade nas dinâmicas de eventos para garantir correlação positiva.",
                                  "learningObjective": "Reconhecer cenários onde CRN maximiza a redução de variância.",
                                  "commonMistakes": [
                                    "Aplicar CRN em sistemas com diferentes escalas de tempo",
                                    "Ignorar diferenças sutis na lógica de eventos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Reconhecer Cenários de Não Aplicabilidade",
                                  "subSteps": [
                                    "Identifique riscos de correlação negativa: interações complexas entre múltiplos streams.",
                                    "Analise casos onde estruturas diferem, como um sistema com feedback e outro sem.",
                                    "Estude exemplos onde CRN aumenta variância, como em simulações com regeneração.",
                                    "Discuta alternativas como stratified sampling nesses casos.",
                                    "Compile uma lista de 'red flags': dependências não lineares, eventos assíncronos."
                                  ],
                                  "verification": "Identifique 3 cenários problemáticos em descrições de simulações e justifique por quê evitar CRN.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Casos de estudo de falhas em CRN",
                                    "Referências de livros como Law & Kelton"
                                  ],
                                  "tips": "Sempre simule um teste pequeno para checar sinal da correlação.",
                                  "learningObjective": "Evitar uso indevido do CRN que pode piorar a variância.",
                                  "commonMistakes": [
                                    "Assumir que CRN sempre funciona",
                                    "Não testar correlação em protótipos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação em Exemplos Práticos",
                                  "subSteps": [
                                    "Selecione 5 cenários de simulação e classifique como 'aplicável' ou 'não aplicável' ao CRN.",
                                    "Justifique cada classificação com base nas condições aprendidas.",
                                    "Simule um caso aplicável vs. não aplicável usando pseudocódigo.",
                                    "Avalie o impacto potencial na variância para cada.",
                                    "Revise e refine sua checklist com base nos exercícios."
                                  ],
                                  "verification": "Apresente análise de 5 cenários com justificativas corretas em 80% dos casos.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Pseudocódigo de simulações",
                                    "Ferramenta de planilha para classificação"
                                  ],
                                  "tips": "Use diagramas de fluxo para visualizar similaridades entre sistemas.",
                                  "learningObjective": "Aplicar critérios de forma autônoma para decidir uso do CRN.",
                                  "commonMistakes": [
                                    "Superestimar similaridade superficial",
                                    "Não considerar múltiplos streams independentes"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de duas filas M/M/1 com taxas de chegada λ=1 e μ1=1.5 vs. μ2=2.0, use a mesma stream de chegadas e serviços para ambos; isso é ideal para CRN pois estruturas são idênticas e sincronizáveis, reduzindo variância na diferença de tempos de espera médios. Evite se uma fila tiver política de prioridade, criando interações complexas.",
                              "finalVerifications": [
                                "Lista corretamente 4 condições ideais para CRN.",
                                "Identifica 3 cenários onde CRN causa correlação negativa.",
                                "Aplica checklist a um novo exemplo com justificativa precisa.",
                                "Explica por que estruturas semelhantes são cruciais.",
                                "Distingue CRN de outras técnicas como antithetic variates.",
                                "Simula impacto na variância em um caso simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de condições ideais (30%)",
                                "Capacidade de reconhecer riscos de não aplicabilidade (25%)",
                                "Uso correto de checklist em exemplos (20%)",
                                "Justificativas baseadas em princípios teóricos (15%)",
                                "Clareza e completude na análise prática (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Conceitos de variância e correlação em amostras",
                                "Programação: Implementação de geradores de números aleatórios em Python/R",
                                "Engenharia Industrial: Simulações de sistemas de produção e filas",
                                "Probabilidade: Dependências em processos estocásticos"
                              ],
                              "realWorldApplication": "Na indústria manufatureira, CRN é usado para comparar configurações de linhas de produção (ex: diferentes layouts de máquinas) garantindo comparações justas com menor variância, acelerando decisões de otimização em simulações de Monte Carlo."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.1.2",
                        "name": "Implementação Prática da Técnica CRN",
                        "description": "Procedimentos operacionais para gerar, sincronizar e aplicar sequências comuns de números aleatórios em softwares de simulação de eventos discretos.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.1.2.1",
                            "name": "Gerar Sequências Comuns de Números Aleatórios",
                            "description": "Utilizar geradores de números pseudoaleatórios (como Mersenne Twister) para criar uma única semente e stream compartilhado entre réplicas de simulações comparativas em linguagens como Arena ou Simio.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Geradores Pseudoaleatórios e Conceito de CRN",
                                  "subSteps": [
                                    "Estude o funcionamento do Mersenne Twister como gerador de números pseudoaleatórios (PRNG), focando em seu período longo e qualidade estatística.",
                                    "Diferencie números pseudoaleatórios de verdadeiramente aleatórios e explique a reprodutibilidade via sementes.",
                                    "Aprenda o conceito de Common Random Numbers (CRN) para redução de variância em simulações comparativas.",
                                    "Identifique por que uma única semente é crucial para streams compartilhados entre réplicas.",
                                    "Revise exemplos teóricos de como CRN sincroniza variabilidade entre cenários."
                                  ],
                                  "verification": "Resuma em um parágrafo os princípios do Mersenne Twister e CRN, incluindo vantagens para simulações.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Documentação oficial do Mersenne Twister (Wikipedia ou papers), tutoriais de simulação em Arena/Simio sobre RNG"
                                  ],
                                  "tips": "Use diagramas para visualizar o fluxo de um PRNG com semente inicial.",
                                  "learningObjective": "Dominar os fundamentos teóricos de PRNGs e CRN para aplicação em simulações discretas.",
                                  "commonMistakes": [
                                    "Confundir pseudoaleatoriedade com aleatoriedade verdadeira",
                                    "Ignorar o impacto da semente na reprodutibilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Semente Única em Software de Simulação",
                                  "subSteps": [
                                    "Instale e abra Arena ou Simio e localize as configurações de replicação e RNG.",
                                    "Defina uma semente fixa única (ex: 12345) nas opções globais de simulação.",
                                    "Configure múltiplas réplicas (ex: 10) para um modelo básico de fila.",
                                    "Teste a execução de uma réplica e anote os primeiros números gerados pelo RNG.",
                                    "Verifique se todas as réplicas usam a mesma semente via logs ou saídas."
                                  ],
                                  "verification": "Execute 2 réplicas e confirme que os primeiros 5 números aleatórios são idênticos.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Arena ou Simio instalado, modelo básico de simulação de fila (template fornecido pelo software)"
                                  ],
                                  "tips": "Salve o modelo com semente documentada no nome do arquivo para rastreabilidade.",
                                  "learningObjective": "Configurar corretamente uma semente única para garantir reprodutibilidade em réplicas.",
                                  "commonMistakes": [
                                    "Deixar a semente no modo automático/random",
                                    "Não sincronizar semente entre módulos de RNG"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Streams Compartilhados para Sequências Comuns",
                                  "subSteps": [
                                    "Crie streams de RNG dedicados (ex: stream 1 para chegadas, stream 2 para serviços) no Arena/Simio.",
                                    "Atribua o mesmo stream ID e semente inicial a réplicas comparativas de cenários diferentes.",
                                    "Modifique um modelo para dois cenários (ex: FIFO vs SJF) compartilhando os streams.",
                                    "Execute réplicas paralelas e capture saídas de RNG para comparação.",
                                    "Ajuste parâmetros para garantir que streams sejam consumidos na mesma ordem."
                                  ],
                                  "verification": "Compare logs de RNG das réplicas 1 de cada cenário; confirme identidade nos primeiros 20 números.",
                                  "estimatedTime": "2.5 hours",
                                  "materials": [
                                    "Modelos de simulação em Arena/Simio com módulos RNG, calculadora ou script Python para validar streams"
                                  ],
                                  "tips": "Use funções built-in como SetSeed() em Arena para controle preciso.",
                                  "learningObjective": "Gerar e gerenciar streams compartilhados usando PRNG para CRN em simulações multi-cenário.",
                                  "commonMistakes": [
                                    "Atribuir streams diferentes aos cenários comparativos",
                                    "Esquecer de resetar streams entre execuções"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Aplicar Sequências Comuns em Simulações Comparativas",
                                  "subSteps": [
                                    "Execute simulações completas com CRN em cenários comparativos e colete métricas (ex: tempo médio de espera).",
                                    "Analise variância reduzida comparando com runs independentes (sem CRN).",
                                    "Gere relatórios de output mostrando correlação positiva nas réplicas.",
                                    "Teste sensibilidade alterando semente e revalidando consistência.",
                                    "Documente o processo em um relatório com capturas de tela de configurações."
                                  ],
                                  "verification": "Demonstre redução de variância >20% em métricas comparativas via tabelas de output.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Ferramentas de análise do Arena/Simio (Output Analyzer), Excel para gráficos de variância"
                                  ],
                                  "tips": "Compare sempre réplicas pareadas (réplica 1 cenário A vs réplica 1 cenário B).",
                                  "learningObjective": "Validar a efetividade de CRN na redução de variância para decisões comparativas robustas.",
                                  "commonMistakes": [
                                    "Interpretar erroneamente correlações negativas como falha",
                                    "Executar réplicas em ordem não sincronizada"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Arena, modele uma fila M/M/1 com duas políticas (FIFO e LIFO). Configure semente 12345 e streams compartilhados (stream 1 para interchegadas, stream 2 para tempos de serviço). Execute 10 réplicas pareadas; verifique que o tempo de espera médio mostra variância reduzida e diferença significativa entre políticas devido a CRN.",
                              "finalVerifications": [
                                "Lista dos primeiros 10 números de um stream com semente fixa é idêntica em múltiplas execuções.",
                                "Réplicas pareadas de cenários diferentes exibem os mesmos números aleatórios iniciais.",
                                "Relatório mostra redução de variância em métricas chave (ex: IC mais estreito).",
                                "Configurações de semente e streams estão documentadas e reproduzíveis.",
                                "Teste com semente alterada gera sequências diferentes consistentemente.",
                                "Análise confirma correlação positiva entre outputs pareados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração de semente única e streams compartilhados (100% match em sequências).",
                                "Demonstração de redução de variância quantitativa (>15% em IC).",
                                "Clareza na documentação de passos e verificações.",
                                "Correta interpretação de resultados CRN vs runs independentes.",
                                "Uso eficiente de recursos de software (sem erros de setup).",
                                "Aplicação correta em contexto comparativo real."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Técnicas de redução de variância e intervalos de confiança.",
                                "Programação: Implementação de algoritmos RNG em linguagens de simulação.",
                                "Engenharia Industrial: Otimização de sistemas de filas e processos.",
                                "Ciência da Computação: Algoritmos de geração de números aleatórios.",
                                "Análise de Dados: Validação de simulações e análise de sensibilidade."
                              ],
                              "realWorldApplication": "Em logística de supply chain, usar CRN em Simio para comparar estratégias de roteamento de veículos, reduzindo variância nas estimativas de tempo de entrega e permitindo decisões confiáveis sobre investimentos em frota."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.2.2",
                            "name": "Sincronizar Streams de RN em Sistemas Diferentes",
                            "description": "Implementar sincronização de múltiplos streams de números aleatórios (ex.: chegadas, serviços) entre configurações alternativas de um modelo, garantindo que o mesmo RN seja usado na mesma ordem lógica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar Geradores de Números Aleatórios Independentes",
                                  "subSteps": [
                                    "Identifique os eventos que requerem RN em cada sistema (ex.: chegadas, tempos de serviço).",
                                    "Selecione uma biblioteca de RN (ex.: NumPy em Python ou Mersenne Twister).",
                                    "Crie streams separados para cada tipo de evento em cada configuração do sistema.",
                                    "Atribua seeds iniciais únicos a cada stream para garantir independência inicial.",
                                    "Documente a estrutura dos streams em um diagrama ou tabela."
                                  ],
                                  "verification": "Verifique se cada stream gera sequências únicas e independentes ao rodar testes isolados.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Biblioteca de RN (ex.: numpy.random), editor de código, diagrama de fluxograma"
                                  ],
                                  "tips": "Use seeds baseados em timestamps ou IDs de configuração para rastreabilidade.",
                                  "learningObjective": "Compreender a configuração de múltiplos streams de RN para simulações paralelas.",
                                  "commonMistakes": [
                                    "Reutilizar o mesmo seed para todos os streams, causando correlação indesejada.",
                                    "Ignorar a ordem lógica dos eventos ao mapear streams."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Mapear a Ordem Lógica de Uso dos RN",
                                  "subSteps": [
                                    "Liste todos os eventos em ordem cronológica lógica comum entre as configurações.",
                                    "Defina uma numeração global para RN (ex.: RN1 para primeira chegada em todos os sistemas).",
                                    "Crie um mapeamento que associe o mesmo índice de RN ao mesmo evento lógico.",
                                    "Valide o mapeamento simulando uma sequência curta manualmente.",
                                    "Implemente o mapeamento como uma tabela ou dicionário no código."
                                  ],
                                  "verification": "Confirme que o mapeamento produz a mesma sequência de RN para eventos equivalentes em ambos os sistemas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Planilha ou ferramenta de diagramação (ex.: Excel, Draw.io), código base da simulação"
                                  ],
                                  "tips": "Priorize eventos que ocorrem em momentos idênticos lógicos, como inícios de simulação.",
                                  "learningObjective": "Mapear sequências de RN para garantir consistência lógica entre sistemas.",
                                  "commonMistakes": [
                                    "Mapear por tempo real em vez de ordem lógica.",
                                    "Esquecer eventos raros ou condicionais."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a Sincronização nos Modelos de Simulação",
                                  "subSteps": [
                                    "Modifique o código da simulação para consumir RN de streams sincronizados via índices globais.",
                                    "Crie uma função wrapper que avance o stream correto baseado no mapeamento.",
                                    "Integre a sincronização em ambas as configurações alternativas do modelo.",
                                    "Adicione logs para rastrear qual RN foi usado em cada evento.",
                                    "Execute uma simulação de teste curta para depuração."
                                  ],
                                  "verification": "Compare logs de RN usados em execuções paralelas dos dois sistemas; devem ser idênticos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código fonte das simulações, debugger/IDE (ex.: VS Code, PyCharm)"
                                  ],
                                  "tips": "Use contadores globais para índices de RN em vez de avançar streams sequencialmente.",
                                  "learningObjective": "Implementar código que força o uso da mesma sequência de RN em eventos lógicos.",
                                  "commonMistakes": [
                                    "Avançar streams de forma assíncrona devido a loops diferentes.",
                                    "Não logar RN para depuração."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Validar a Sincronização",
                                  "subSteps": [
                                    "Rode múltiplas réplicas das simulações sincronizadas e compare estatísticas.",
                                    "Verifique se variâncias entre configurações são reduzidas conforme esperado em CRN.",
                                    "Teste casos extremos (ex.: sem eventos, eventos intensos).",
                                    "Meça o tempo de execução e overhead da sincronização.",
                                    "Documente resultados e ajustes feitos."
                                  ],
                                  "verification": "Estatísticas de saída (médias, variâncias) devem coincidir para eventos equivalentes dentro de tolerância numérica.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Ferramentas de plotagem (ex.: Matplotlib), scripts de comparação estatística"
                                  ],
                                  "tips": "Use asserts no código para falhar se RN não baterem durante testes.",
                                  "learningObjective": "Validar empiricamente a efetividade da sincronização CRN.",
                                  "commonMistakes": [
                                    "Comparar apenas médias, ignorando variâncias.",
                                    "Não testar com seeds diferentes para independência."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de duas filas M/M/1 com taxas diferentes (fila A: λ=1, μ=1.5; fila B: λ=1.2, μ=1.8), sincronize o stream de chegadas para usar o mesmo RN para decidir interchegadas, e stream de serviços para tempos idênticos lógicos, permitindo comparação direta de tempos de espera médios.",
                              "finalVerifications": [
                                "Sequências de RN idênticas para eventos lógicos em todas as configurações.",
                                "Redução observada na variância das estimativas entre réplicas.",
                                "Código roda sem erros de desincronização em múltiplas execuções.",
                                "Logs confirmam mapeamento correto de streams.",
                                "Estatísticas finais coincidem dentro de precisão de ponto flutuante.",
                                "Overhead de sincronização < 10% do tempo total."
                              ],
                              "assessmentCriteria": [
                                "Precisão no mapeamento lógico de eventos (100% cobertura).",
                                "Implementação robusta com logs e verificações automáticas.",
                                "Redução de variância comprovada em testes (ex.: >20%).",
                                "Código limpo, modular e documentado.",
                                "Tratamento correto de casos edge e erros numéricos.",
                                "Eficiência computacional mantida."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Uso avançado de geradores pseudo-aleatórios e estruturas de dados.",
                                "Estatística: Conceitos de variância e métodos de Monte Carlo.",
                                "Ciência da Computação: Paralelismo e simulações estocásticas.",
                                "Engenharia: Modelagem de sistemas de filas em manufatura.",
                                "Matemática: Sequências e funções geradoras."
                              ],
                              "realWorldApplication": "Em simulações de supply chain para comparar políticas de estoque em cenários alternativos, garantindo comparações justas; ou em finanças para testar estratégias de trading com ruído aleatório sincronizado, reduzindo incerteza em avaliações de risco."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.2.3",
                            "name": "Configurar Réplicas Comparativas com CRN",
                            "description": "Estruturar experimentos de simulação com réplicas pareadas, definindo o número de runs e garantindo independência entre pares, conforme recomendado em Banks et al. (2000).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Réplicas Comparativas e CRN",
                                  "subSteps": [
                                    "Estude a definição de réplicas comparativas conforme Banks et al. (2000): simulações pareadas para reduzir variância.",
                                    "Entenda CRN (Common Random Numbers): uso de sequências idênticas de números aleatórios para diferentes sistemas.",
                                    "Identifique requisitos: independência entre pares de réplicas e dependência dentro do par.",
                                    "Revise fórmulas de variância reduzida para réplicas pareadas: Var(D) = (1/n) * [Var(X1) + Var(X2) - 2Cov(X1,X2)].",
                                    "Anote exemplos de cenários onde CRN é aplicável, como comparação de políticas em filas."
                                  ],
                                  "verification": "Resuma em um parágrafo os benefícios da CRN sobre réplicas independentes e liste 3 condições para sua aplicação válida.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro Banks et al. (2000), Capítulo sobre técnicas de redução de variância",
                                    "Notas de aula sobre simulação discreta",
                                    "Artigos online sobre CRN"
                                  ],
                                  "tips": "Foquem em visualizar streams de RN como 'fitas' sincronizadas para diferentes sistemas.",
                                  "learningObjective": "Compreender os princípios teóricos de réplicas comparativas com CRN e suas vantagens em redução de variância.",
                                  "commonMistakes": [
                                    "Confundir CRN com independência total de réplicas",
                                    "Ignorar a necessidade de sincronização perfeita nos streams de RN"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Planejar o Experimento: Definir Número de Runs e Estrutura de Pares",
                                  "subSteps": [
                                    "Determine o número de réplicas (n) baseado em análise de poder estatístico ou piloto (ex: n=30 por sistema).",
                                    "Estruture pares: cada par contém uma réplica do Sistema A e uma do Sistema B com os mesmos RN.",
                                    "Garanta independência entre pares: avance streams de RN para o próximo par após cada execução.",
                                    "Defina a medida de performance (ex: tempo médio de espera) e como calcular a diferença pareada D_i = X_{A,i} - X_{B,i}.",
                                    "Crie um diagrama esquemático mostrando n pares independentes."
                                  ],
                                  "verification": "Produza um plano escrito com n, estrutura de pares e justificativa para o número escolhido.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Planilha Excel para cálculos de poder",
                                    "Software de diagramação como Draw.io",
                                    "Referência Banks et al. para guidelines de n"
                                  ],
                                  "tips": "Use piloto com n=10 para estimar variância e calcular n final via fórmula de confiança.",
                                  "learningObjective": "Planejar adequadamente o número de réplicas e a estrutura pareada para experimentos com CRN.",
                                  "commonMistakes": [
                                    "Escolher n muito pequeno sem análise de variância",
                                    "Não garantir regeneração de streams entre pares"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar Streams de Números Aleatórios Comuns no Simulador",
                                  "subSteps": [
                                    "Selecione um simulador (ex: Simio, Arena ou Python com SimPy/numpy.random).",
                                    "Inicialize múltiplos streams de RN: um para cada fonte de aleatoriedade (chegadas, serviços).",
                                    "Sincronize streams: use a mesma semente para o par A-B, mas avance para par seguinte.",
                                    "Implemente código para fixar sementes: ex. em Python, random.seed(i) para par i.",
                                    "Teste sincronização rodando um par e verificando sequências idênticas de RN."
                                  ],
                                  "verification": "Execute um par de réplicas e confirme que as primeiras 10 RNs são idênticas para A e B.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Simulador de eventos discretos (Arena/SimPy)",
                                    "Documentação de geradores de RN do software",
                                    "Código template para CRN"
                                  ],
                                  "tips": "Sempre documente sementes usadas para reprodutibilidade.",
                                  "learningObjective": "Configurar corretamente streams de RN comuns para garantir pareamento válido.",
                                  "commonMistakes": [
                                    "Usar semente global sem reset por par",
                                    "Misturar streams independentes dentro do par"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar Simulações, Coletar Dados e Validar Independência",
                                  "subSteps": [
                                    "Rode todas as n réplicas pareadas, coletando X_{A,i} e X_{B,i} para cada i.",
                                    "Calcule diferenças D_i e estatísticas: média de D, IC de 95% via t-Student.",
                                    "Teste independência entre pares: verifique autocorrelação de D_i ou teste de runs.",
                                    "Valide redução de variância: compare Var(D) com Var independentes.",
                                    "Gere relatório com gráficos de D_i vs i para checar padrões."
                                  ],
                                  "verification": "Forneça IC da diferença de performance e prova de independência (ex: p-value >0.05 em teste).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Simulador configurado",
                                    "R ou Python para análise (t.test, acf)",
                                    "Templates de relatório"
                                  ],
                                  "tips": "Monitore tempo de computação; paralelize pares se possível.",
                                  "learningObjective": "Executar o experimento completo e validar as premissas de CRN.",
                                  "commonMistakes": [
                                    "Não testar independência entre pares",
                                    "Interpretar IC sem checar normalidade de D_i"
                                  ]
                                }
                              ],
                              "practicalExample": "Compare duas políticas de alocação em um call center (FIFO vs. SPT) simulando 30 pares de réplicas. Use CRN para sincronizar chegadas e tempos de serviço, calculando diferença no tempo médio de espera. Resultado: política SPT reduz espera em 15% com IC estreito.",
                              "finalVerifications": [
                                "N réplicas pareadas executadas com streams de RN sincronizados dentro de pares.",
                                "Independência entre pares confirmada via teste estatístico.",
                                "IC de 95% da diferença de performance calculado corretamente.",
                                "Redução de variância demonstrada comparando com método independente.",
                                "Relatório inclui diagramas de streams e gráficos de D_i.",
                                "Condições de Banks et al. (2000) atendidas explicitamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração de CRN (sincronização perfeita: 30%)",
                                "Escolha adequada de n e validação estatística (25%)",
                                "Implementação livre de erros comuns em streams (20%)",
                                "Análise de resultados com IC e testes (15%)",
                                "Clareza no relatório e diagramas (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Testes de hipóteses pareados e análise de variância.",
                                "Programação: Gerenciamento de estados aleatórios e simulação em Python/SimPy.",
                                "Otimização: Comparação de políticas em sistemas estocásticos.",
                                "Ciência de Dados: Redução de variância em experimentos de ML."
                              ],
                              "realWorldApplication": "Em manufatura, configure CRN para comparar layouts de fábrica em simulações, reduzindo tempo de decisão em otimização de throughput; em finanças, avalie estratégias de portfólio com réplicas pareadas para precisão em Value-at-Risk."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.1.3",
                        "name": "Avaliação e Análise de Resultados com CRN",
                        "description": "Métodos para quantificar a redução de variância e interpretar as diferenças nas estimativas de desempenho obtidas com a técnica.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.1.3.1",
                            "name": "Calcular Intervalos de Confiança para Diferenças",
                            "description": "Computar a variância amostral das diferenças entre réplicas pareadas e construir intervalos de confiança para θ₁ - θ₂, verificando a redução em relação ao método independente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar Dados de Réplicas Pareadas com CRN",
                                  "subSteps": [
                                    "Colete réplicas pareadas X_{1i} e X_{2i} geradas usando Números Aleatórios Comuns (CRN) para i = 1 a n.",
                                    "Verifique que as réplicas compartilham a mesma sequência de números aleatórios para correlação positiva.",
                                    "Armazene os dados em uma tabela ou array para fácil acesso.",
                                    "Calcule a média amostral das diferenças iniciais como referência: média_D = (1/n) * sum(D_i), onde D_i = X_{1i} - X_{2i}.",
                                    "Confirme n ≥ 30 para aproximação normal válida."
                                  ],
                                  "verification": "Dados organizados em tabela com réplicas pareadas idênticas em streams de RAN e média_D calculada corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software de simulação (ex: R, Python com NumPy/SciPy)",
                                    "Dados de simulação de exemplo com CRN"
                                  ],
                                  "tips": "Use seeds idênticos para garantir pareamento perfeito em CRN.",
                                  "learningObjective": "Entender como preparar dados pareados para reduzir variância via correlação.",
                                  "commonMistakes": [
                                    "Usar streams independentes em vez de CRN",
                                    "Esquecer de calcular média_D inicial",
                                    "n muito pequeno para IC válido"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Computar Variância Amostral das Diferenças",
                                  "subSteps": [
                                    "Calcule cada diferença D_i = X_{1i} - X_{2i} para todas as réplicas.",
                                    "Compute a média das diferenças: mean_D = (1/n) * Σ D_i.",
                                    "Calcule os desvios: (D_i - mean_D)^2 para cada i.",
                                    "Some os desvios e divida por (n-1): s_D² = [Σ (D_i - mean_D)^2] / (n-1).",
                                    "Compare qualitativamente s_D² com variâncias individuais s1² e s2²."
                                  ],
                                  "verification": "s_D² calculada numericamente e exibida, com fórmula mostrada passo a passo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha Excel ou Python/Jupyter Notebook",
                                    "Dados pareados do Step 1"
                                  ],
                                  "tips": "Automatize com loop em código para evitar erros aritméticos manuais.",
                                  "learningObjective": "Dominar o cálculo de variância amostral para diferenças pareadas.",
                                  "commonMistakes": [
                                    "Dividir por n em vez de (n-1)",
                                    "Confundir D_i com X_{1i}",
                                    "Ignorar sinal nas diferenças"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir Intervalo de Confiança para θ₁ - θ₂",
                                  "subSteps": [
                                    "Determine o nível de confiança (ex: 95%) e graus de liberdade df = n-1.",
                                    "Encontre o valor crítico t de Student t-table ou função (ex: qt(0.975, df) no R).",
                                    "Calcule o erro padrão: SE = s_D / sqrt(n).",
                                    "Construa o IC: mean_D ± t * SE.",
                                    "Interprete: 'Com 95% de confiança, θ₁ - θ₂ está entre [limite_inf, limite_sup]'."
                                  ],
                                  "verification": "IC calculado e plotado (ex: gráfico de erro), com t e SE explicitados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela t-Student",
                                    "Biblioteca SciPy.stats ou R stats"
                                  ],
                                  "tips": "Use funções built-in como confint() para validação rápida.",
                                  "learningObjective": "Aplicar distribuição t para IC de diferenças pareadas.",
                                  "commonMistakes": [
                                    "Usar z em vez de t",
                                    "Erro no SE (esquecer sqrt(n))",
                                    "Inverter limites do IC"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Redução de Variância vs. Método Independente",
                                  "subSteps": [
                                    "Calcule IC para método independente: var_ind = s1²/n1 + s2²/n2, IC_ind = mean1 - mean2 ± z * sqrt(var_ind).",
                                    "Compare larguras: largura_D = 2*t*SE_D vs. largura_ind = 2*z*sqrt(var_ind).",
                                    "Calcule redução percentual: (largura_ind - largura_D)/largura_ind * 100%.",
                                    "Teste hipótese qualitativa: CRN reduz variância se largura_D < largura_ind.",
                                    "Documente conclusões em relatório curto."
                                  ],
                                  "verification": "Tabela comparativa de larguras e redução percentual >0% confirmada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código para simulação independente",
                                    "Resultados dos steps anteriores"
                                  ],
                                  "tips": "Simule ambos métodos com mesmas seeds para comparação justa.",
                                  "learningObjective": "Avaliar eficácia de CRN na redução de variância.",
                                  "commonMistakes": [
                                    "Comparar variâncias brutas sem ajustar por n",
                                    "Usar z para pareado",
                                    "Ignorar correlação positiva esperada"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de duas filas M/M/1 (θ₁: tempo médio fila 1, θ₂: fila 2), gere 50 réplicas pareadas com CRN (mesmo seed). Diferenças D_i levam a s_D² = 0.25 (vs. var_ind = 0.8). IC pareado: 1.2 ± 0.3 (largura 0.6); independente: 1.2 ± 0.8 (largura 1.6). Redução: 62.5%.",
                              "finalVerifications": [
                                "IC pareado corretamente calculado e mais estreito que independente.",
                                "Variância s_D² < s1²/n + s2²/n demonstrada numericamente.",
                                "Interpretação correta da redução de variância via CRN.",
                                "Todos cálculos validados com código ou planilha reproduzível.",
                                "Relatório resume comparação e conclusões.",
                                "Gráfico compara larguras de ICs."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de mean_D, s_D² e IC (erro <1%).",
                                "Correta aplicação de t-Student vs. normal.",
                                "Demonstração clara de redução de variância (>20% tipicamente).",
                                "Uso apropriado de CRN em simulação.",
                                "Documentação completa com fórmulas e código.",
                                "Interpretação estatística válida."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Inferência paramétrica e testes t pareados.",
                                "Programação: Implementação em Python/R para simulações.",
                                "Engenharia Industrial: Otimização de simulações em manufatura.",
                                "Probabilidade: Propriedades de variância em variáveis correlacionadas.",
                                "Análise de Dados: Visualização de ICs e comparações."
                              ],
                              "realWorldApplication": "Em simulações de supply chain, CRN com ICs para diferenças reduz tempo de simulação em 50% para comparar políticas de estoque (ex: FIFO vs. LIFO), permitindo decisões rápidas em logística da Amazon ou fábricas automotivas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.3.2",
                            "name": "Comparar Eficiência com Outras Técnicas",
                            "description": "Avaliar o ganho em precisão do CRN versus simulações independentes, calculando fatores de redução de variância e discutindo limitações como dependência de modelos semelhantes (Kelton & Law, 1991).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de CRN e Simulações Independentes",
                                  "subSteps": [
                                    "Defina simulações independentes: cada replicação usa streams aleatórios distintos.",
                                    "Explique CRN: uso de mesmos números aleatórios para replicações de sistemas comparados.",
                                    "Identifique métricas chave: variância do estimador, intervalo de confiança (IC) e comprimento do IC.",
                                    "Estude referência: leia seção relevante de Kelton & Law (1991) sobre redução de variância.",
                                    "Liste vantagens iniciais do CRN: correlação positiva reduz variância da diferença."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos e métricas, confirmando compreensão com exemplos simples.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro Kelton & Law (1991)",
                                    "Notas de aula sobre simulação discreta",
                                    "Calculadora ou software como Excel"
                                  ],
                                  "tips": "Use diagramas para visualizar streams aleatórios em CRN vs independentes.",
                                  "learningObjective": "Compreender as bases teóricas que permitem comparações de eficiência entre CRN e simulações independentes.",
                                  "commonMistakes": [
                                    "Confundir CRN com estratificação",
                                    "Ignorar necessidade de modelos semelhantes para CRN funcionar"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar e Executar Simulações Comparativas",
                                  "subSteps": [
                                    "Selecione um sistema modelo simples, como fila M/M/1 com taxa de chegada λ=4 e serviço μ=5.",
                                    "Implemente simulações independentes: 100 replicações com 1000 observações cada, streams separados.",
                                    "Implemente CRN: 100 replicações usando o mesmo stream de números aleatórios para chegada e serviço.",
                                    "Colete estatísticas: média do tempo no sistema (W) e variância amostral para cada método.",
                                    "Registre comprimento médio do IC a 95% de confiança para W."
                                  ],
                                  "verification": "Gere relatórios de saída com médias, variâncias e ICs para ambos os métodos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software de simulação (R, Python com SimPy, Arena)",
                                    "Código fonte modelo M/M/1"
                                  ],
                                  "tips": "Garanta sementes aleatórias idênticas no CRN; teste com poucas runs primeiro.",
                                  "learningObjective": "Executar simulações práticas para gerar dados empíricos comparáveis.",
                                  "commonMistakes": [
                                    "Não estabilizar o sistema (warm-up inadequado)",
                                    "Usar poucos runs, levando a variância alta"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Fatores de Redução de Variância",
                                  "subSteps": [
                                    "Calcule variância amostral (s²) para estimadores de W em independentes (s_ind²) e CRN (s_crn²).",
                                    "Compute fator de redução: FRV = s_ind² / s_crn² para a diferença de médias se aplicável.",
                                    "Calcule percentual de redução: (1 - 1/√FRV) * 100% no comprimento do IC.",
                                    "Teste estatístico: verifique se redução é significativa via teste F para variâncias.",
                                    "Plote histogramas de W para visualmente comparar dispersões."
                                  ],
                                  "verification": "Apresente tabela com FRV, percentual de redução e p-valor do teste F.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Planilha Excel ou Python/R para cálculos estatísticos",
                                    "Dados das simulações"
                                  ],
                                  "tips": "Use fórmula batch means para variância se runs longas; normalize por número de runs.",
                                  "learningObjective": "Quantificar matematicamente o ganho em precisão do CRN.",
                                  "commonMistakes": [
                                    "Calcular variância errada (amostra vs população)",
                                    "Esquecer de ajustar por graus de liberdade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Limitações e Concluir Comparação de Eficiência",
                                  "subSteps": [
                                    "Discuta limitações do CRN: requer modelos semelhantes, falha em correlações negativas.",
                                    "Compare eficiência geral: tempo computacional vs ganho em precisão (runs necessárias para IC igual).",
                                    "Avalie cenários onde CRN é superior/inferior: e.g., filas vs inventário.",
                                    "Reflita sobre Kelton & Law: dependência de estruturas similares.",
                                    "Escreva relatório conclusivo com recomendações."
                                  ],
                                  "verification": "Produza relatório de 1 página com análise qualitativa e quantitativa.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Referência Kelton & Law",
                                    "Dados e cálculos anteriores"
                                  ],
                                  "tips": "Use tabela comparativa: prós/contras, condições ideais para CRN.",
                                  "learningObjective": "Avaliar trade-offs e contextos de aplicação do CRN.",
                                  "commonMistakes": [
                                    "Superestimar benefícios sem testar limitações",
                                    "Ignorar custo computacional"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila M/M/1 (λ=4, μ=5), simulações independentes com 100 runs dão Var(W)=0.25 e IC médio=0.10; CRN dá Var(W)=0.15 e IC=0.08, resultando em FRV=1.67 e redução de 20% no IC, demonstrando ganho de precisão.",
                              "finalVerifications": [
                                "Fator de redução de variância calculado corretamente (>1 para CRN eficaz).",
                                "Comprimento de IC comparado quantitativamente entre métodos.",
                                "Limitações discutidas com exemplos de falha (modelos dissimilares).",
                                "Relatório inclui plots de variância e testes estatísticos.",
                                "Conclusão recomenda uso condicional do CRN."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de variância e FRV (erro <5%).",
                                "Profundidade na discussão de limitações (cita Kelton & Law).",
                                "Qualidade dos dados simulados (mínimo 50 runs por método).",
                                "Clareza em visualizações e relatórios.",
                                "Análise de trade-offs computacionais vs precisão.",
                                "Aplicação correta de testes estatísticos."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Inferência e testes de variância.",
                                "Programação: Implementação de geradores de números aleatórios.",
                                "Otimização: Redução de custo em experimentos simulados.",
                                "Engenharia Industrial: Simulações em manufatura e logística."
                              ],
                              "realWorldApplication": "Em simulações de call centers, CRN compara eficiência de roteiros de serviço reduzindo variância em tempos de espera, permitindo decisões mais precisas em alocação de agentes sem aumentar tempo de computação."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.2",
                    "name": "Variáveis Antitéticas",
                    "description": "Método que gera pares de corridas de simulação com números aleatórios complementares (U e 1-U) para induzir correlação negativa e minimizar variância.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.2.1",
                        "name": "Princípio das Variáveis Antitéticas",
                        "description": "Fundamento teórico do método que utiliza pares de números aleatórios complementares (U e 1-U) para gerar réplicas de simulação com correlação negativa, reduzindo a variância do estimador.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.2.1.1",
                            "name": "Explicar o mecanismo de correlação negativa",
                            "description": "Descrever como o uso de U e 1-U em réplicas pareadas induz uma correlação negativa entre as saídas das simulações, levando à redução da variância do estimador médio conforme a fórmula Var((X1 + X2)/2) = (Var(X)/2) * (1 + ρ), onde ρ < 0.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a variância em estimadores de Monte Carlo independentes",
                                  "subSteps": [
                                    "Revise o método de Monte Carlo básico: gere réplicas independentes X1, X2 ~ distribuição alvo para estimar E[X] ≈ (X1 + X2)/2.",
                                    "Derive a variância do estimador médio: Var((X1 + X2)/2) = (Var(X1) + Var(X2))/4 = Var(X)/2, assumindo independência (ρ = 0).",
                                    "Discuta o impacto da variância alta em simulações: mais réplicas necessárias para precisão.",
                                    "Calcule um exemplo numérico simples com X ~ Bernoulli(p=0.5).",
                                    "Compare com o desvio padrão do estimador."
                                  ],
                                  "verification": "Derive corretamente a fórmula Var((X1 + X2)/2) = Var(X)/2 e compute para um exemplo com Var(X)=0.25.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora",
                                    "Software de simulação como Python (opcional)"
                                  ],
                                  "tips": "Sempre normalize pela divisão por 2 no estimador médio para reduzir variância pela metade em independentes.",
                                  "learningObjective": "Estabelecer o baseline de variância para réplicas independentes como ponto de comparação.",
                                  "commonMistakes": [
                                    "Esquecer de dividir por 4 na variância somada",
                                    "Confundir Var(X) com E[X]",
                                    "Ignorar que independência implica Cov(X1,X2)=0"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o conceito de variáveis antitéticas com U e 1-U",
                                  "subSteps": [
                                    "Explique geração de U ~ Uniform(0,1) e defina X1 = g(U), X2 = g(1-U), onde g é função inversa cumulativa monotônica decrescente.",
                                    "Descreva pareamento: U e 1-U são perfeitamente negativamente correlacionados, pois quando U é alto, 1-U é baixo e vice-versa.",
                                    "Ilustre com gráfico: plote U vs 1-U mostrando correlação -1.",
                                    "Verifique que X1 e X2 têm mesma marginal, mas são dependentes.",
                                    "Discuta requisito: g deve ser monotônica para induzir oposição nos valores."
                                  ],
                                  "verification": "Gere U=0.2, compute 1-U=0.8 e mostre que eles se movem em direções opostas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel para gráficos",
                                    "Python ou R para gerar U e plotar correlação"
                                  ],
                                  "tips": "Escolha funções g estritamente decrescentes para maximizar o efeito negativo.",
                                  "learningObjective": "Entender como o pareamento U e 1-U cria dependência oposta nas réplicas.",
                                  "commonMistakes": [
                                    "Usar g crescente, que induz correlação positiva",
                                    "Assumir U e 1-U independentes",
                                    "Esquecer que marginals permanecem iguais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar o mecanismo de indução de correlação negativa",
                                  "subSteps": [
                                    "Mostre que Corr(U, 1-U) = -1, e por composição monotônica decrescente, Corr(X1, X2) = Corr(g(U), g(1-U)) < 0.",
                                    "Derive Cov(X1, X2) = E[X1 X2] - E[X1]E[X2] < 0 devido à oposição: altos X1 correspondem a baixos X2.",
                                    "Use exemplo: g(u) = 1-u (linear decrescente), compute ρ = -1 explicitamente.",
                                    "Generalize: para g não-linear mas monotônica, ρ ∈ (-1, 0).",
                                    "Compare histogramas de pares (X1,X2) vs independentes para visualizar negatividade."
                                  ],
                                  "verification": "Compute Cov(X1,X2) para g(u)=1-u e mostre ρ < 0.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de cálculo ou Python para covariância",
                                    "Gráficos de dispersão"
                                  ],
                                  "tips": "Visualize pares (X1,X2) em scatterplot: inclinação negativa confirma correlação.",
                                  "learningObjective": "Dominar como o pareamento induz ρ < 0 via monotonicidade oposta.",
                                  "commonMistakes": [
                                    "Calcular Corr(U,1-U) como 0",
                                    "Ignorar monotonicidade de g",
                                    "Confundir correlação com covariância"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar à redução de variância via fórmula geral",
                                  "subSteps": [
                                    "Estenda a fórmula: Var((X1 + X2)/2) = (Var(X)/2) * (1 + ρ).",
                                    "Mostre que ρ < 0 implica Var < Var(X)/2 (melhor que independentes).",
                                    "Quantifique ganho: eficiência = 1/(1+ρ) > 1 quando ρ < 0.",
                                    "Simule numericamente: compare variâncias empíricas de antitéticas vs independentes.",
                                    "Conclua com condições para sucesso: g monotônica decrescente."
                                  ],
                                  "verification": "Simule 1000 pares, compute variâncias e confirme redução quando ρ < 0.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python/R com numpy/random para simulações",
                                    "Planilha para médias"
                                  ],
                                  "tips": "Teste com n=10000 réplicas para variância estável; plote boxplots de estimadores.",
                                  "learningObjective": "Explicar matematicamente e empiricamente a redução de variância.",
                                  "commonMistakes": [
                                    "Esquecer o fator (1+ρ)/2",
                                    "Usar ρ > 0 em exemplos",
                                    "Não simular para validar"
                                  ]
                                }
                              ],
                              "practicalExample": "Para estimar ∫_0^1 √x dx = 2/3 via Monte Carlo: gere U~Unif(0,1), X1=√U, X2=√(1-U). Média (X1+X2)/2 tem variância reduzida ~30-50% vs independentes, simulável em Python: np.mean(np.sqrt(U) + np.sqrt(1-U))/2.",
                              "finalVerifications": [
                                "Deriva corretamente Var((X1+X2)/2) = (Var(X)/2)(1+ρ) com ρ<0.",
                                "Explica por que U e 1-U induzem oposição em g monotônica decrescente.",
                                "Simula e compara variâncias empíricas antitéticas vs independentes.",
                                "Identifica condições para ρ<0 (monotonicidade).",
                                "Calcula ganho de eficiência 1/(1+ρ) >1.",
                                "Discute falhas se g não monotônica."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da fórmula de variância (correta inclusão de ρ).",
                                "Clareza na explicação do pareamento U/1-U e monotonicidade.",
                                "Validação numérica/simulada com redução observada de variância.",
                                "Identificação correta de erros comuns e condições.",
                                "Comunicação fluida do mecanismo intuitivo (oposição de valores).",
                                "Uso apropriado de exemplos concretos."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Conceitos de covariância e correlação em amostras dependentes.",
                                "Programação: Implementação de simulações Monte Carlo em Python/R.",
                                "Finanças: Redução de variância em precificação de derivativos (ex: opções Black-Scholes).",
                                "Física Computacional: Simulações de partículas com antitéticas para eficiência.",
                                "Probabilidade: Propriedades de transformadas monotônicas em uniforms."
                              ],
                              "realWorldApplication": "Em finanças quantitativas, variáveis antitéticas reduzem tempo de computação em simulações Monte Carlo para valuation de opções exóticas, permitindo milhões de paths com precisão alta em horas vs dias, economizando custos em hedge funds e bancos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.1.2",
                            "name": "Identificar condições ideais para aplicação",
                            "description": "Reconhecer cenários de simulação monotônica onde funções de entrada-saída são inversamente proporcionais, como em filas M/M/1 com taxa de chegada inversa, maximizando o ganho de redução de variância.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Princípio das Variáveis Antitéticas",
                                  "subSteps": [
                                    "Estude a definição de variáveis antitéticas: geração de pares de variáveis aleatórias negativamente correlacionadas (U e 1-U).",
                                    "Revise como a correlação negativa reduz a variância do estimador em simulações Monte Carlo.",
                                    "Analise a fórmula de variância reduzida: Var[(f(U)+f(1-U))/2] < Var[f(U)] quando f é monotônica.",
                                    "Discuta condições para máxima redução: forte correlação negativa e monotonicidade.",
                                    "Compare com método comum (independente) usando gráficos de variância."
                                  ],
                                  "verification": "Escreva um parágrafo explicando por que variáveis antitéticas funcionam melhor que amostras independentes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Notas de aula sobre simulação Monte Carlo",
                                    "Artigo introdutório sobre variáveis antitéticas",
                                    "Calculadora ou software como R/Python"
                                  ],
                                  "tips": "Visualize com histogramas de pares (U, 1-U) para ver a correlação negativa perfeita.",
                                  "learningObjective": "Explicar o mecanismo de redução de variância via correlação negativa induzida por variáveis antitéticas.",
                                  "commonMistakes": [
                                    "Assumir redução sempre, ignorando necessidade de monotonicidade",
                                    "Confundir com estratificação aleatória"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Monotonicidade em Funções de Simulação",
                                  "subSteps": [
                                    "Defina monotonicidade: função f é monotônica crescente/decrescente se x1 < x2 implica f(x1) <= f(x2) ou >=.",
                                    "Teste monotonicidade em funções simples de simulação (ex: tempo de espera em fila cresce com taxa de chegada).",
                                    "Diferencie monotônica estrita de fraca usando contraexemplos.",
                                    "Examine cenários de simulação monotônica: filas, inventários, redes.",
                                    "Pratique plotando f(U) vs U para verificar inclinação consistente."
                                  ],
                                  "verification": "Classifique 3 funções de simulação como monotônicas ou não, justificando com exemplos numéricos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Planilha Excel ou Python com NumPy/Matplotlib",
                                    "Lista de funções de simulação de exemplo"
                                  ],
                                  "tips": "Use derivadas ou diferenças finitas para testar monotonicidade numericamente.",
                                  "learningObjective": "Reconhecer quando uma função de entrada-saída em simulação é monotônica.",
                                  "commonMistakes": [
                                    "Ignorar ruído estocástico que mascara monotonicidade",
                                    "Confundir causalidade com monotonicidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Reconhecer Proporcionalidade Inversa em Cenários de Simulação",
                                  "subSteps": [
                                    "Identifique proporcionalidade inversa: entrada alta leva a saída baixa (ex: alta chegada, baixa utilização efetiva).",
                                    "Analise simulações onde variáveis de entrada são inversas: taxa chegada λ e serviço μ em filas.",
                                    "Estude impacto na variância: pares antitéticos maximizam correlação negativa em funções inversas.",
                                    "Compare com proporcional direta (ex: λ e tempo de espera ambos crescem).",
                                    "Liste 5 cenários comuns: filas, alocação de recursos, controle de qualidade."
                                  ],
                                  "verification": "Descreva 2 cenários onde entrada-saída é inversamente proporcional e explique benefício antitético.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Diagrama de filas M/M/1",
                                    "Simulador online de filas (ex: Simul8 trial)"
                                  ],
                                  "tips": "Pense em trade-offs: alta entrada sobrecarrega, baixa alivia.",
                                  "learningObjective": "Detectar relações inversas entre variáveis de entrada e métricas de performance em simulações.",
                                  "commonMistakes": [
                                    "Focar só em linearidade, ignorando não-linearidades inversas",
                                    "Confundir com anti-correlacionadas por design"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar ao Exemplo de Filas M/M/1 e Sintetizar Condições Ideais",
                                  "subSteps": [
                                    "Modele fila M/M/1: tempo médio de espera W(q) crescente em q=λ/μ.",
                                    "Gere pares antitéticos: alta λ com baixa μ e vice-versa para W baixo/alto.",
                                    "Simule e calcule variância reduzida vs independente.",
                                    "Liste condições ideais: monotonicidade em q, inversa em λ (fixo μ), simulação monotônica.",
                                    "Generalize para outros sistemas discretos."
                                  ],
                                  "verification": "Simule 100 pares em M/M/1, compare variâncias e conclua sobre condições ideais.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Código Python/R para simulação M/M/1",
                                    "Ferramenta Jupyter Notebook"
                                  ],
                                  "tips": "Use semente fixa para reprodutibilidade e plot variância.",
                                  "learningObjective": "Identificar e validar condições ideais em contexto específico de filas M/M/1.",
                                  "commonMistakes": [
                                    "Usar μ variável sem fixar relação ρ<1",
                                    "Ignorar regime de estabilidade da fila"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de call center modelada como fila M/M/1, pareie dias de alta chegada de chamadas (λ=10/h) com baixa capacidade de atendentes (μ=8/h) e dias de baixa chegada (λ=5/h) com alta capacidade (μ=12/h). Isso induz correlação negativa no tempo de espera médio, reduzindo variância do estimador em 40-60%.",
                              "finalVerifications": [
                                "Explique monotonicidade e proporcionalidade inversa em suas palavras.",
                                "Identifique condições ideais para antitéticas em 3 cenários de simulação.",
                                "Simule M/M/1 com antitéticas e mostre redução de variância >20%.",
                                "Distinga cenários onde antitéticas falham (não-monotônicos).",
                                "Liste limitações: custo computacional de pareamento.",
                                "Aplique a um novo sistema (ex: inventário)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de monotonicidade e inversa proporcional (80%+ correto).",
                                "Capacidade de simular e quantificar redução de variância.",
                                "Identificação correta de 4+ condições ideais.",
                                "Explicações claras com exemplos concretos.",
                                "Análise de erros comuns e limitações.",
                                "Criatividade em generalizações para outros contextos."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Técnicas de redução de variância em Monte Carlo.",
                                "Ciência da Computação: Programação de simulações estocásticas em Python/R.",
                                "Engenharia Industrial: Modelagem de sistemas de filas e otimização.",
                                "Probabilidade: Processos estocásticos Markovianos (M/M/1).",
                                "Análise de Dados: Validação de estimadores via simulação."
                              ],
                              "realWorldApplication": "Em planejamento de supply chain, simulações com variáveis antitéticas otimizam estoques em armazéns, identificando condições ideais (alta demanda com baixa capacidade de armazenamento) para reduzir variância em previsões de custo, economizando milhões em indústrias como e-commerce (ex: Amazon logística)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.1.3",
                            "name": "Comparar com amostragem comum",
                            "description": "Comparar a variância do estimador antitético com o da amostragem independente, destacando o fator de redução (1 + ρ)/2 < 1 quando ρ < 0.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a variância do estimador na amostragem independente",
                                  "subSteps": [
                                    "Lembre-se da fórmula da variância para o estimador de Monte Carlo padrão: Var(θ̂) = σ² / n, onde σ² é a variância da variável aleatória e n é o número de amostras independentes.",
                                    "Calcule explicitamente σ² para uma distribuição uniforme U(0,1) ou similar usada em simulações.",
                                    "Simule numericamente 1000 réplicas para estimar a variância empírica da amostragem independente.",
                                    "Registre os valores de variância observados para comparação futura.",
                                    "Discuta como a independência afeta diretamente a eficiência do estimador."
                                  ],
                                  "verification": "Conseguiu derivar e simular Var(θ̂_ind) corretamente, com resultados consistentes em múltiplas runs.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta para derivação; Python ou R com bibliotecas numpy/random para simulação.",
                                  "tips": "Use funções de seed para reprodutibilidade nas simulações.",
                                  "learningObjective": "Compreender e calcular a variância baseline da amostragem comum.",
                                  "commonMistakes": "Confundir variância da média com variância da população; esquecer de dividir por n."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir variáveis antitéticas e calcular sua correlação ρ",
                                  "subSteps": [
                                    "Defina variáveis antitéticas: para X_i ~ U(0,1), defina Y_i = 1 - X_i.",
                                    "Mostre que Cov(X_i, Y_i) = E[(X_i - 0.5)(Y_i - 0.5)] = -Var(X)/12 para uniforme, levando a ρ < 0.",
                                    "Calcule ρ explicitamente: ρ = Cov(X,Y) / (σ_X σ_Y) = -1/3 para uniforme padrão em integrais.",
                                    "Simule pares (X_i, Y_i) e estime ρ empiricamente via correlação amostral.",
                                    "Verifique que ρ é consistentemente negativo em simulações."
                                  ],
                                  "verification": "Cálculo analítico de ρ coincide com estimativa empírica (erro < 5%).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software de programação (Python/R); tabela de fórmulas de estatística básica.",
                                  "tips": "Visualize a correlação com scatter plot de X vs Y para intuição negativa.",
                                  "learningObjective": "Dominar o conceito de correlação negativa induzida por antitéticas.",
                                  "commonMistakes": "Assumir independência entre X e Y; erro no cálculo de Cov devido a centros errados."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a variância do estimador antitético",
                                  "subSteps": [
                                    "Escreva o estimador antitético: θ̂_ant = (1/(2n)) Σ [g(X_i) + g(Y_i)], com pares (X_i, Y_i).",
                                    "Derive Var(θ̂_ant) = (1/(4n)) Σ Var[g(X_i) + g(Y_i)] = [Var(g(X))]/(2n) * (1 + ρ_g), onde ρ_g é corr de g(X),g(Y).",
                                    "Assuma g linear ou uniforme para simplificar ρ_g ≈ ρ.",
                                    "Compare com Var(θ̂_ind) = Var(g(X))/(2n) para mesmo custo computacional (2n amostras).",
                                    "Simplifique para fator geral: Var_ant / Var_ind = (1 + ρ)/2."
                                  ],
                                  "verification": "Derivação passo a passo leva à fórmula (1 + ρ)/2 corretamente anotada.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Caderno para derivação algébrica; calculadora simbólica como SymPy.",
                                  "tips": "Comece com n=1 para simplificar, depois generalize.",
                                  "learningObjective": "Derivar analiticamente a variância reduzida do estimador antitético.",
                                  "commonMistakes": "Errar o fator 1/(2n) vs 1/n; ignorar que custo é dobrado mas variância cai mais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e comparar o fator de redução de variância",
                                  "subSteps": [
                                    "Mostre que (1 + ρ)/2 < 1 iff ρ < 0, destacando ganho quando correlação negativa.",
                                    "Calcule numericamente para ρ = -0.5: fator = 0.25 (redução de 75%).",
                                    "Simule cenários: compare variâncias empíricas de θ̂_ind e θ̂_ant em 1000 runs cada.",
                                    "Plote histogramas de estimadores para visualizar redução de variância.",
                                    "Conclua condições onde antitéticas superam independentes (ρ suficientemente negativo)."
                                  ],
                                  "verification": "Simulações mostram Var_ant < Var_ind consistentemente, com fator próximo ao teórico.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python/R com matplotlib para plots; dados de simulações anteriores.",
                                  "tips": "Use número grande de runs para precisão; compute razão Var_ant/Var_ind.",
                                  "learningObjective": "Interpretar e validar o fator (1 + ρ)/2 através de análise e simulação.",
                                  "commonMistakes": "Interpretar ρ > 0 como benefício; não equalizar custo computacional nas comparações."
                                }
                              ],
                              "practicalExample": "Em uma simulação Monte Carlo para estimar a integral ∫_0^1 x^2 dx = 1/3, use amostragem independente com 1000 U(0,1) vs antitéticas pares (U,1-U), compute médias e variâncias: observe Var_ant ≈ 0.00008 vs Var_ind ≈ 0.00017, fator ≈0.47 devido a ρ≈-0.5.",
                              "finalVerifications": [
                                "Derivação correta de Var(θ̂_ant) = [σ²/(2n)](1 + ρ).",
                                "Simulação empírica confirma (1 + ρ)/2 < 1 para ρ < 0.",
                                "Explicação clara do porquê antitéticas reduzem variância via correlação negativa.",
                                "Comparação quantitativa com números específicos para um exemplo.",
                                "Identificação de cenários onde técnica falha (ρ ≈ 0)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação matemática (fórmulas corretas).",
                                "Consistência entre teoria e simulações empíricas (erro <10%).",
                                "Interpretação qualitativa do fator de redução.",
                                "Uso adequado de visualizações para comparação.",
                                "Capacidade de generalizar para funções g não-lineares."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Conceitos de correlação e variância em estimadores.",
                                "Programação: Implementação de simulações Monte Carlo em Python/R.",
                                "Finanças: Redução de variância em modelagem de risco (Value-at-Risk).",
                                "Física Computacional: Simulações de partículas com antitéticas."
                              ],
                              "realWorldApplication": "Em finanças quantitativas, usar variáveis antitéticas em simulações Monte Carlo para precificar opções reduz a variância dos estimadores de preço, permitindo convergência mais rápida e confiança maior em decisões de investimento com menos amostras computacionais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.2.2",
                        "name": "Geração e Implementação de Variáveis Antitéticas",
                        "description": "Procedimentos práticos para gerar streams de números aleatórios complementares e parear réplicas em simulações discretas de eventos.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.2.2.1",
                            "name": "Gerar pares complementares U e 1-U",
                            "description": "Implementar algoritmo para transformar um stream uniforme U_i em pares (U_i, 1 - U_i) para inputs como tempos interchegada e serviço em simulações de filas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Pares Complementares U e 1-U",
                                  "subSteps": [
                                    "Estudar a distribuição uniforme U ~ Uniform(0,1) e suas propriedades",
                                    "Aprender que pares antitéticos (U_i, 1-U_i) têm correlação perfeita negativa (-1)",
                                    "Explicar como isso reduz a variância em estimativas de simulações Monte Carlo",
                                    "Visualizar graficamente pares (U_i, 1-U_i) para observar simetria em torno de 0.5",
                                    "Discutir aplicação em tempos interchegada e serviço para simulações de filas"
                                  ],
                                  "verification": "Escrever uma explicação em 3 frases confirmando que Corr(U,1-U)=-1 e seu benefício em variância",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula sobre simulação",
                                    "Gráficos de exemplo em papel ou software como Desmos"
                                  ],
                                  "tips": "Lembre-se: valores extremos em U levam a valores opostos em 1-U, cancelando variabilidade",
                                  "learningObjective": "Dominar a teoria por trás dos pares complementares e sua utilidade em redução de variância",
                                  "commonMistakes": [
                                    "Assumir independência entre U e 1-U",
                                    "Esquecer que U deve estar em (0,1)",
                                    "Ignorar impacto na variância de funções inversas de CDF"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar Stream de Variáveis Uniformes U_i",
                                  "subSteps": [
                                    "Configurar ambiente Python com bibliotecas numpy e random",
                                    "Implementar função para gerar N valores U_i usando np.random.uniform(0,1, N)",
                                    "Definir semente (seed) para reprodutibilidade dos resultados",
                                    "Visualizar distribuição com histograma usando matplotlib",
                                    "Testar estatísticas básicas: média ≈0.5, variância ≈1/12"
                                  ],
                                  "verification": "Histograma uniforme e estatísticas confirmam propriedades da Uniform(0,1)",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python/Jupyter Notebook",
                                    "Bibliotecas: numpy, matplotlib"
                                  ],
                                  "tips": "Use np.random.seed(42) para resultados consistentes em testes",
                                  "learningObjective": "Gerar streams uniformes confiáveis para base de pares antitéticos",
                                  "commonMistakes": [
                                    "Gerar U_i fora de (0,1)",
                                    "Não usar seed levando a resultados irreprodutíveis",
                                    "Confundir uniform com normal"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Transformar Stream em Pares Complementares (U_i, 1-U_i)",
                                  "subSteps": [
                                    "Criar array de pares: para cada U_i, computar [U_i, 1 - U_i]",
                                    "Armazenar em estrutura 2D: lista de listas ou array numpy (N x 2)",
                                    "Calcular correlação entre primeira e segunda coluna usando np.corrcoef",
                                    "Verificar que todos os pares somam exatamente 1.0",
                                    "Exportar pares para uso em inversora de CDF (ex: exponencial)"
                                  ],
                                  "verification": "Correlação entre colunas = -1.0 e soma de cada par = 1.0",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Código Python do Step 2",
                                    "numpy para corrcoef"
                                  ],
                                  "tips": "Use broadcasting numpy: pairs = np.stack([U, 1-U], axis=1) para eficiência",
                                  "learningObjective": "Implementar transformação atômica de stream uniforme em pares antitéticos",
                                  "commonMistakes": [
                                    "Erro de arredondamento fazendo soma ≠1",
                                    "Índices errados em loops manuais",
                                    "Não verificar correlação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Pares em Simulação de Fila M/M/1",
                                  "subSteps": [
                                    "Definir inversora CDF para exponencial: tempo = -lambda^{-1} * log(U)",
                                    "Para cada par, gerar interchegada A_i = -1/mu_a * log(U_i), serviço S_i = -1/mu_s * log(1-U_i)",
                                    "Simular fila: acumular chegadas, processar serviços, medir tempo médio na fila W",
                                    "Repetir simulação M vezes e estimar Var(W)",
                                    "Comparar com versão independente (2N uniformes independentes)"
                                  ],
                                  "verification": "Simulação roda sem erros e Var(W_antitetica) < Var(W_independente)",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código dos steps anteriores",
                                    "numpy para simulação vetorial"
                                  ],
                                  "tips": "Simule 1000 clientes por run para precisão; plote boxplots de W",
                                  "learningObjective": "Integrar pares antitéticos em contexto prático de simulação de filas",
                                  "commonMistakes": [
                                    "Usar log(0) causando overflow",
                                    "Não inverter corretamente para antitéticas",
                                    "Confundir mu_a e mu_s"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma fila M/M/1 com taxa chegada λ=1 e serviço μ=1.5, gere 1000 pares (U_i,1-U_i). Compute tempos interchegada A_i = -log(U_i), serviço S_i = -log(1-U_i). Simule 10 runs de 1000 clientes cada; observe redução de ~30-50% na variância do tempo médio na fila comparado a independentes.",
                              "finalVerifications": [
                                "Todos os pares somam exatamente 1.0",
                                "Correlação entre U e 1-U é -1.0",
                                "Tempos gerados via inversora CDF são positivos e seguem exponencial",
                                "Simulação de fila converge sem NaNs ou erros",
                                "Variância da estimativa é menor que na versão independente",
                                "Código é reprodutível com seed"
                              ],
                              "assessmentCriteria": [
                                "Precisão teórica: explicação correta de antitéticas (peso 20%)",
                                "Implementação código: gera pares corretos e correlação -1 (peso 30%)",
                                "Aplicação em simulação: integração em fila M/M/1 sem bugs (peso 25%)",
                                "Análise de variância: demonstra redução quantitativa (peso 15%)",
                                "Eficiência e clareza: código limpo, comentado, vetorial (peso 10%)"
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: Correlação e redução de variância Monte Carlo",
                                "Programação Computacional: Manipulação de arrays numpy e vetores",
                                "Simulação e Modelagem: Sistemas de filas M/M/1",
                                "Otimização Numérica: Técnicas de aceleração em simulações",
                                "Análise de Dados: Visualização de histogramas e boxplots"
                              ],
                              "realWorldApplication": "Em logística, simular centros de distribuição com antitéticas para estimar tempos de espera com precisão maior usando menos computação, otimizando alocação de recursos em cenários de alta variabilidade como e-commerce durante Black Friday."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.7.2.2.2",
                            "name": "Estruturar corridas pareadas em software",
                            "description": "Configurar simulações em linguagens como Simio ou código customizado (ex: Python com SimPy) para executar pares de runs com seeds complementares, garantindo sincronia nos eventos discretos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o Modelo de Simulação Base",
                                  "subSteps": [
                                    "Defina o sistema de eventos discretos a ser simulado (ex: fila M/M/1).",
                                    "Implemente o gerador de números aleatórios padrão no software escolhido (Simio ou Python com SimPy).",
                                    "Configure parâmetros iniciais: tempo de simulação, número de replicatas e estatísticas a coletar (ex: tempo médio na fila).",
                                    "Execute uma run de teste para validar o modelo base.",
                                    "Documente o código ou configuração para referência futura."
                                  ],
                                  "verification": "Modelo executa sem erros e produz estatísticas consistentes em múltiplas runs independentes.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Software: Simio ou Python com SimPy instalado",
                                    "Documentação da biblioteca SimPy",
                                    "Exemplo de modelo de fila simples"
                                  ],
                                  "tips": "Comece com um modelo simples para evitar complexidades desnecessárias.",
                                  "learningObjective": "Compreender e implementar um modelo de simulação de eventos discretos funcional.",
                                  "commonMistakes": [
                                    "Ignorar condições iniciais transitórias",
                                    "Não sincronizar o relógio de simulação",
                                    "Usar seeds fixos sem variabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar Seeds Complementares (Antitéticos)",
                                  "subSteps": [
                                    "Estude o conceito de variáveis antitéticas: U e 1-U para uniformes.",
                                    "Implemente uma função para gerar pares de seeds: seed1 e seed2 = 1 - seed1 (ou equivalente para outras distribuições).",
                                    "Adapte para múltiplos streams de aleatoriedade (ex: chegadas e serviços).",
                                    "Teste a função isoladamente para garantir complementariedade.",
                                    "Integre os seeds no gerador de aleatoriedade do modelo."
                                  ],
                                  "verification": "Pares de seeds gerados satisfazem a relação antitética (ex: média de pares = 0.5 para uniformes).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Biblioteca de RNG como random em Python",
                                    "Referências teóricas sobre variáveis antitéticas"
                                  ],
                                  "tips": "Use funções invertíveis para transformações antitéticas em não-uniformes.",
                                  "learningObjective": "Dominar a geração de variáveis aleatórias antitéticas sincronizadas.",
                                  "commonMistakes": [
                                    "Não tratar distribuições não-uniformes corretamente",
                                    "Desalinhar streams de aleatoriedade",
                                    "Usar seeds independentes em vez de pareados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar Execução de Corridas Pareadas",
                                  "subSteps": [
                                    "Estruture o loop principal para executar pares: run com seed1 seguida imediatamente por run com seed2.",
                                    "Garanta sincronia total nos eventos discretos entre as runs pareadas.",
                                    "Colete estatísticas pareadas: média antitética = (estat1 + estat2)/2 para cada par.",
                                    "Configure replicatas pareadas (ex: 100 pares).",
                                    "Implemente armazenamento de resultados em estrutura de dados (ex: DataFrame Pandas)."
                                  ],
                                  "verification": "Runs pareadas executam sem discrepâncias nos timestamps de eventos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Ambiente de desenvolvimento Python ou Simio",
                                    "Pandas para análise de dados"
                                  ],
                                  "tips": "Use o mesmo estado inicial e sequência de eventos para sincronia perfeita.",
                                  "learningObjective": "Configurar software para simulações pareadas com sincronia de eventos.",
                                  "commonMistakes": [
                                    "Perda de sincronia por reset incompleto",
                                    "Média incorreta das pareadas",
                                    "Execução assíncrona de runs"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e Validar Redução de Variância",
                                  "subSteps": [
                                    "Calcule variância das médias pareadas vs. runs independentes.",
                                    "Compare intervalos de confiança: deve haver redução na variância.",
                                    "Plote histogramas ou gráficos de variância para visualização.",
                                    "Teste estatístico (ex: teste F para variâncias).",
                                    "Documente ganhos de eficiência e ajuste parâmetros se necessário."
                                  ],
                                  "verification": "Variância das estimativas antitéticas é menor que a das independentes (pelo menos 20-50% de redução).",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Matplotlib/Seaborn para plots",
                                    "SciPy para testes estatísticos"
                                  ],
                                  "tips": "Registre tempos de execução para quantificar eficiência computacional.",
                                  "learningObjective": "Avaliar empiricamente a eficácia das variáveis antitéticas.",
                                  "commonMistakes": [
                                    "Não contabilizar bias transitório",
                                    "Comparação inválida de variâncias",
                                    "Ignorar correlação negativa esperada"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado (chegadas Poisson λ=5/h, serviço Expo μ=6/h), configure 100 pares de runs antitéticas. Use Python/SimPy: para cada par, inverta seeds de chegadas e serviços. Resultado: variância do tempo médio na fila reduz de 0.15 para 0.08, acelerando convergência.",
                              "finalVerifications": [
                                "Código executa pares de runs sincronizadas sem erros.",
                                "Seeds complementares gerados corretamente para todos streams.",
                                "Médias antitéticas calculadas e armazenadas adequadamente.",
                                "Redução de variância confirmada por cálculo e visualização.",
                                "Sincronia de eventos verificada em logs de simulação.",
                                "Eficiência computacional documentada (tempo vs. precisão)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na implementação de seeds antitéticos (100% complementares).",
                                "Sincronia perfeita entre runs pareadas (zero discrepâncias em eventos).",
                                "Redução de variância quantificada (>20%).",
                                "Código limpo, comentado e reproduzível.",
                                "Análise estatística robusta com plots e testes.",
                                "Eficiência: tempo de execução pareado similar a duas runs independentes."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Redução de variância e intervalos de confiança.",
                                "Programação: Estruturas de loops, funções e gerenciamento de estado.",
                                "Matemática: Distribuições probabilísticas e transformações.",
                                "Engenharia de Software: Testes unitários e validação de simulações.",
                                "Análise de Dados: Manipulação e visualização com Pandas/Matplotlib."
                              ],
                              "realWorldApplication": "Em otimização de cadeias de suprimentos, como na Amazon, corridas pareadas antitéticas aceleram simulações de logística, reduzindo tempo de avaliação de cenários de dias para horas, permitindo decisões mais rápidas em alocação de armazéns e rotas de entrega."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.1.2"
                            ]
                          },
                          {
                            "id": "10.1.7.2.2.3",
                            "name": "Evitar armadilhas comuns na geração",
                            "description": "Identificar e corrigir problemas como quebra de independência entre pares ou não-monotonicidade da resposta, testando com gráficos de scatter plot de pares (X1, X2).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Princípios Fundamentais das Variáveis Antitéticas",
                                  "subSteps": [
                                    "Revise a definição de variáveis antitéticas: pares (X1, X2) onde X2 = 1 - X1 para uniformes, garantindo correlação negativa perfeita.",
                                    "Estude a condição de monotonicidade: a função f deve ser monotonicamente crescente ou decrescente para que E[f(X1)] + E[f(X2)] ≈ 2E[f(U)].",
                                    "Analise a independência: pares consecutivos devem ser independentes, mas antitéticos internamente.",
                                    "Implemente um gerador simples de pares antitéticos em Python usando numpy.random.uniform.",
                                    "Calcule a correlação teórica esperada de -1 para pares perfeitos."
                                  ],
                                  "verification": "Confirme que a correlação Pearson entre X1 e X2 é aproximadamente -1 usando np.corrcoef.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python com NumPy e SciPy; notebook Jupyter.",
                                  "tips": "Sempre normalize para [0,1] antes de aplicar transformações.",
                                  "learningObjective": "Dominar os fundamentos teóricos para identificar violações potenciais.",
                                  "commonMistakes": "Confundir independência entre pares com correlação dentro do par; ignorar bounds de uniformes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Armadilhas Comuns na Geração",
                                  "subSteps": [
                                    "Liste armadilhas: quebra de independência (reuso de seeds), não-monotonicidade (funções como sin(x)), viés em distribuições não-uniformes.",
                                    "Gere pares com seed fixo e observe repetição: use np.random.seed() incorretamente entre pares.",
                                    "Teste monotonicidade: aplique f(x) = x^2 (não monotônica em [0,1]) e compare variância.",
                                    "Simule cenários falhos: gere X2 sem inverter corretamente (ex: X2 = X1).",
                                    "Documente sintomas: variância maior que Monte Carlo padrão."
                                  ],
                                  "verification": "Crie uma tabela comparando variância de MC padrão vs. antitético falho.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com NumPy, Matplotlib para plots iniciais.",
                                  "tips": "Use funções puras sem side-effects para isolar problemas.",
                                  "learningObjective": "Reconhecer padrões de falha na implementação prática.",
                                  "commonMistakes": "Assumir que qualquer inversão funciona sem verificar monotonicidade; reutilizar gerador sem reset."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diagnosticar com Scatter Plots de Pares (X1, X2)",
                                  "subSteps": [
                                    "Gere 1000 pares antitéticos corretos e plote scatter(X1, X2).",
                                    "Introduza falhas: não inverter (X2=X1), seed compartilhado, e plote cada caso.",
                                    "Analise plots: linha reta inclinação -1 = correto; nuvem aleatória = independência quebrada; curvas = não-monotônica.",
                                    "Calcule e plote coeficiente de correlação em cada subplot.",
                                    "Compare com histogramas de f(X1) e f(X2) para simetria."
                                  ],
                                  "verification": "Scatter plot exibe linha diagonal perfeita com inclinação -1 e R=-1.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Python com Matplotlib e Seaborn para visualizações avançadas.",
                                  "tips": "Use plt.plot(X1, X2, 'o', alpha=0.5) para densidade; adicione linha y=1-x.",
                                  "learningObjective": "Usar visualização para diagnosticar problemas de geração.",
                                  "commonMistakes": "Escala errada no plot (não usar aspect='equal'); amostra pequena (<500 pontos)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Corrigir e Validar a Implementação",
                                  "subSteps": [
                                    "Corrija independência: gere pares com seeds independentes ou streams separados.",
                                    "Ajuste para monotonicidade: transforme f para ser monotônica ou use controle parcial.",
                                    "Reimplemente gerador robusto: def antithetic_pairs(n): return U, 1-U com U uniforme.",
                                    "Execute simulação completa: compare variâncias MC vs. antitético corrigido.",
                                    "Teste com múltiplas funções (linear, exp) e valide redução de variância."
                                  ],
                                  "verification": "Variância antitético < 50% da MC padrão em 10 runs; scatter plots limpos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Código Python completo; ambiente Jupyter.",
                                  "tips": "Encapsule em função testável com asserts para correlação.",
                                  "learningObjective": "Implementar correções acionáveis e validar empiricamente.",
                                  "commonMistakes": "Não resetar RNG entre simulações; ignorar efeitos de borda em distribuições truncadas."
                                }
                              ],
                              "practicalExample": "Em uma simulação Monte Carlo para estimar ∫_0^1 exp(x) dx, gere 1000 pares U ~ Uniform[0,1], X1=U, X2=1-U. Plote scatter(U, 1-U): deve ser linha y=1-x. Calcule média de [exp(X1)+exp(X2)]/2 vs. MC padrão. Se scatter for diagonal perfeita, variância reduz ~50%; caso contrário, corrija seed ou inversão.",
                              "finalVerifications": [
                                "Scatter plot de X1 vs X2 mostra linha reta com inclinação -1 e correlação Pearson ≈ -1.",
                                "Variância do estimador antitético é menor que a do MC padrão em pelo menos 30%.",
                                "Pares consecutivos exibem independência (autocorrelação ≈0).",
                                "Função aplicada mantém simetria: média f(X1) ≈ média f(X2).",
                                "Testes com 3 funções diferentes (linear, exponencial, log) passam.",
                                "Código roda sem erros de bounds ou NaNs."
                              ],
                              "assessmentCriteria": [
                                "Identificação precisa de pelo menos 3 armadilhas comuns com exemplos.",
                                "Scatter plots corretamente interpretados e usados para diagnóstico.",
                                "Implementação corrigida reduz variância consistentemente.",
                                "Documentação clara de correções e validações.",
                                "Análise quantitativa (correlação, variância) incluída.",
                                "Código modular e reproduzível."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Análise de variância e correlação em simulações.",
                                "Programação: Gerenciamento de RNG e visualização de dados com Python.",
                                "Matemática: Funções monótonas e integrais numéricas.",
                                "Ciência de Dados: Diagnóstico visual com scatter plots e seaborn."
                              ],
                              "realWorldApplication": "Em finanças quantitativas, evitar essas armadilhas em simulações Monte Carlo para precificação de opções europeias, reduzindo tempo computacional em 40-50% sem perda de precisão; usado por bancos como JPMorgan em modelos de risco."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.2.3",
                        "name": "Análise e Avaliação da Redução de Variância",
                        "description": "Métodos para quantificar o ganho de variância e validar a eficácia das variáveis antitéticas em experimentos de simulação.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.2.3.1",
                            "name": "Calcular o coeficiente de correlação ρ",
                            "description": "Estimar ρ = Cov(X1, X2) / sqrt(Var(X1) Var(X2)) a partir de múltiplos pares de runs e verificar se ρ < -0.5 para ganho significativo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os pares de dados de simulação antitéticas",
                                  "subSteps": [
                                    "Gerar n pares de runs (X1_i, X2_i) usando variáveis antitéticas para o sistema discreto, onde n ≥ 30 para boa estimativa.",
                                    "Implementar o gerador de antitéticas invertendo uniformes U e 1-U para entradas aleatórias.",
                                    "Registrar todos os pares em uma tabela ou array (colunas: X1, X2).",
                                    "Verificar se os dados foram gerados corretamente sem duplicatas ou erros de inversão.",
                                    "Salvar os dados em formato acessível (CSV ou lista em código)."
                                  ],
                                  "verification": "Conferir se há exatamente n pares válidos com valores numéricos plausíveis e antitéticos invertidos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Software de simulação (Python com NumPy/SciPy ou R), código para gerador antitético, sistema de simulação discreto (ex: fila M/M/1).",
                                  "tips": "Use sementes fixas para reprodutibilidade durante testes iniciais.",
                                  "learningObjective": "Entender como gerar dados pareados antitéticos para análise de correlação.",
                                  "commonMistakes": "Esquecer de inverter corretamente as variáveis aleatórias; gerar runs independentes em vez de antitéticos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular médias e variâncias amostrais de X1 e X2",
                                  "subSteps": [
                                    "Calcular a média amostral μ1 = (1/n) Σ X1_i e μ2 = (1/n) Σ X2_i.",
                                    "Calcular variância amostral Var(X1) = (1/(n-1)) Σ (X1_i - μ1)^2 e similar para Var(X2).",
                                    "Usar fórmulas vetoriais em software para eficiência.",
                                    "Armazenar μ1, μ2, s1^2, s2^2 em variáveis ou tabela.",
                                    "Verificar se variâncias são positivas e não zero."
                                  ],
                                  "verification": "Comparar médias e variâncias com valores esperados de simulações independentes (devem ser similares).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Planilha (Excel/Google Sheets) ou código Python/R com funções mean() e var().",
                                  "tips": "Use divisão por (n-1) para variância não viesada.",
                                  "learningObjective": "Dominar cálculo de estatísticas descritivas para estimadores de variância em simulações.",
                                  "commonMistakes": "Usar divisão por n em vez de (n-1); confundir média com mediana."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a covariância amostral Cov(X1, X2)",
                                  "subSteps": [
                                    "Calcular os desvios: d1_i = X1_i - μ1 e d2_i = X2_i - μ2 para cada i.",
                                    "Computar Cov = (1/(n-1)) Σ d1_i * d2_i.",
                                    "Implementar em loop ou vetorizado (np.cov em Python).",
                                    "Verificar sinal: deve ser negativo para antitéticas eficazes.",
                                    "Documentar o valor exato."
                                  ],
                                  "verification": "Cov deve ser negativo e magnitude razoável comparada às variâncias.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Código Python/R ou calculadora matricial.",
                                  "tips": "Vetorize para evitar loops lentos em grandes n.",
                                  "learningObjective": "Compreender o papel da covariância na dependência entre variáveis antitéticas.",
                                  "commonMistakes": "Usar μ erradas ou esquecer o fator (n-1); calcular produto incorreto."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estimar ρ e verificar condição de ganho significativo",
                                  "subSteps": [
                                    "Calcular ρ = Cov / sqrt(Var(X1) * Var(X2)).",
                                    "Verificar se |ρ| < 1 e sinal negativo.",
                                    "Testar se ρ < -0.5 para ganho significativo (redução de var((X1+X2)/2) > 25%).",
                                    "Calcular ganho aproximado: 1 - (1+ρ)/2.",
                                    "Interpretar: ρ < -0.5 indica bom pareamento antitético."
                                  ],
                                  "verification": "ρ calculado matches função built-in como np.corrcoef; condição booleana confirmada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Funções corrcoef() em SciPy/NumPy ou cor() em R.",
                                  "tips": "Confirme com função pronta antes de fórmula manual para validação.",
                                  "learningObjective": "Aplicar fórmula de correlação de Pearson e interpretar para redução de variância.",
                                  "commonMistakes": "Raiz quadrada incorreta; dividir por zero se variância zero; ignorar sinal negativo."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar e documentar resultados",
                                  "subSteps": [
                                    "Resumir: valores de ρ, ganho, confiança (ex: IC via bootstrap se n grande).",
                                    "Comparar com runs independentes (ρ ≈ 0).",
                                    "Ajustar antitéticas se ρ > -0.5 e reexecutar.",
                                    "Gerar relatório com tabela e gráfico scatter(X1 vs X2).",
                                    "Concluir sobre eficácia da técnica."
                                  ],
                                  "verification": "Relatório mostra ρ < -0.5 e ganho >25%; scatter linear negativo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Bibliotecas de plot (Matplotlib/ggplot), editor de relatório.",
                                  "tips": "Plote scatter para visualização intuitiva da correlação negativa.",
                                  "learningObjective": "Interpretar ρ no contexto de redução de variância em simulações.",
                                  "commonMistakes": "Não comparar com baseline independente; superestimar ganho sem IC."
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila M/M/1 (λ=4, μ=5), gere 100 pares antitéticos de tempo médio de espera W, invertendo chegadas. Calcule ρ ≈ -0.7, confirmando redução de Var((W1+W2)/2) em 35%, acelerando estimativa de steady-state.",
                              "finalVerifications": [
                                "ρ calculado corretamente via fórmula e matches função built-in.",
                                "ρ < -0.5 com n ≥ 30 pares válidos.",
                                "Ganho de variância documentado >25%.",
                                "Scatter plot mostra tendência linear negativa.",
                                "Comparação com runs independentes (ρ ≈ 0).",
                                "Relatório completo com todos valores intermediários."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica de ρ dentro de 0.01 do valor built-in.",
                                "Correta geração de pares antitéticos (inversão U e 1-U).",
                                "Interpretação adequada: ρ < -0.5 implica ganho significativo.",
                                "Uso de fórmulas não viesadas (divisão por n-1).",
                                "Visualizações e documentação claras.",
                                "Tratamento de edge cases (ex: variância baixa)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Correlação de Pearson e inferência.",
                                "Programação: Implementação numérica em Python/R.",
                                "Probabilidade: Dependência em variáveis aleatórias.",
                                "Engenharia de Simulação: Redução de variância em Monte Carlo."
                              ],
                              "realWorldApplication": "Em finanças, usar antitéticas com ρ < -0.5 para acelerar simulações de risco (VaR) em portfólios, reduzindo tempo computacional em 30-50% sem perda de precisão."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.7.2.3.2",
                            "name": "Avaliar redução de variância em exemplo",
                            "description": "Aplicar em modelo simples como tempo médio em sistema M/M/1, comparando ICs de 95% com e sem antitéticas, usando fórmulas de Banks et al.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o modelo M/M/1 e entender os parâmetros",
                                  "subSteps": [
                                    "Defina os parâmetros do sistema M/M/1: taxa de chegada λ = 4 clientes/hora, taxa de serviço μ = 5 clientes/hora.",
                                    "Calcule o tempo médio teórico no sistema W = 1/(μ - λ) = 1 hora.",
                                    "Implemente a geração de chegadas e serviços usando distribuições exponenciais.",
                                    "Gere N=1000 réplicas independentes para simulação crude.",
                                    "Prepare o código para calcular a média amostral e variância."
                                  ],
                                  "verification": "Verifique se o tempo médio simulado está próximo de 1 hora (erro <10%) e se as réplicas são independentes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com numpy e scipy",
                                    "Editor de código (Jupyter Notebook)",
                                    "Fórmulas de Banks et al. para ICs"
                                  ],
                                  "tips": "Use np.random.exponential para gerar tempos; fixe a semente para reprodutibilidade.",
                                  "learningObjective": "Compreender e configurar corretamente um sistema M/M/1 para simulação.",
                                  "commonMistakes": [
                                    "Confundir λ e μ",
                                    "Gerar tempos de chegada cumulativos incorretamente",
                                    "Esquecer de resetar o relógio do sistema"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar simulação crude e calcular IC 95% sem antitéticas",
                                  "subSteps": [
                                    "Execute N=1000 simulações independentes do tempo no sistema para cada réplica.",
                                    "Calcule a média amostral μ̂ e variância amostral S² usando fórmulas de Banks et al.",
                                    "Determine o intervalo de confiança de 95% (IC) com t-student: μ̂ ± t*(S/√n).",
                                    "Registre a largura do IC (diferença entre limites superior e inferior).",
                                    "Repita para validar consistência."
                                  ],
                                  "verification": "O IC deve conter o valor teórico de 1 hora com probabilidade ~95%; anote a largura média.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código Python da Step 1",
                                    "Tabela de valores t-student para df=999"
                                  ],
                                  "tips": "Use scipy.stats.t para quantis; n=1000 réplicas para boa aproximação normal.",
                                  "learningObjective": "Aplicar simulação Monte Carlo crude e construir ICs precisos.",
                                  "commonMistakes": [
                                    "Usar Z em vez de t-student para amostras finitas",
                                    "Calcular variância com N em vez de N-1",
                                    "Ignorar normalidade aproximada"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar variáveis antitéticas no modelo M/M/1",
                                  "subSteps": [
                                    "Gere pares antitéticos: para cada chegada U, use 1-U para o antitético.",
                                    "Aplique a antitéticas tanto em chegadas quanto em serviços exponenciais.",
                                    "Execute N/2 = 500 pares independentes, calculando médias pareadas: (X_i + X_i')/2.",
                                    "Calcule variância das médias pareadas usando fórmula ajustada de Banks et al.",
                                    "Verifique correlação negativa entre pares (ρ ≈ -0.3 a -0.5 esperada)."
                                  ],
                                  "verification": "Confirme correlação negativa via np.corrcoef; variância pareada < variância crude.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Código das steps anteriores",
                                    "Documentação de Banks et al. sobre antitéticas"
                                  ],
                                  "tips": "Para exponencial, se X~Exp(λ), então 1-U também ~Exp(λ) via inversa.",
                                  "learningObjective": "Implementar corretamente variáveis antitéticas em simulações de filas.",
                                  "commonMistakes": [
                                    "Não inverter corretamente U para 1-U",
                                    "Parear incorretamente chegadas e serviços",
                                    "Esquecer divisão por 2 nas médias pareadas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular com antitéticas e calcular IC 95%",
                                  "subSteps": [
                                    "Execute simulação antitética com 500 pares (equivalente a 1000 runs crude).",
                                    "Calcule média e variância das 500 médias pareadas.",
                                    "Construa IC 95% para as pareadas: ajuste fator de variância pela correlação.",
                                    "Registre a largura do IC antitético.",
                                    "Compare estatisticamente as larguras (teste se redução >20%)."
                                  ],
                                  "verification": "IC antitético mais estreito que crude; contenha valor teórico.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código antitético",
                                    "Fórmulas de variância pareada: Var((X+X')/2) = (1+ρ)Var(X)/2"
                                  ],
                                  "tips": "Redução de variância ≈ 1 + ρ; mire ρ negativo forte.",
                                  "learningObjective": "Calcular ICs em simulações antitéticas e quantificar ganhos.",
                                  "commonMistakes": [
                                    "Não ajustar n efetivo para pareadas",
                                    "Ignorar fator (1+ρ)/2",
                                    "Comparar runs totais em vez de efetivos"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Avaliar e comparar a redução de variância",
                                  "subSteps": [
                                    "Calcule % de redução de variância: (1 - Var_ant / Var_crude) * 100%.",
                                    "Compare larguras de ICs: redução esperada similar ao % de variância.",
                                    "Interprete resultados: eficiência computacional (mesmo esforço, melhor precisão).",
                                    "Gere gráfico de histogramas de tempos crude vs. antitético.",
                                    "Documente conclusões com fórmulas de Banks et al."
                                  ],
                                  "verification": "Redução de variância >10%; relatório escrito com tabelas e gráficos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Resultados anteriores",
                                    "Matplotlib para gráficos",
                                    "Referência Banks et al."
                                  ],
                                  "tips": "Use boxplots para visualizar variâncias; valide com múltiplas seeds.",
                                  "learningObjective": "Avaliar quantitativamente a eficácia das antitéticas.",
                                  "commonMistakes": [
                                    "Comparar variâncias brutas sem pareamento",
                                    "Esquecer normalização por n",
                                    "Ignorar custo computacional"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um call center M/M/1 com λ=4 chamadas/h, μ=5, simule 1000 runs crude: IC 95% largura ~0.15h. Com antitéticas (500 pares), ρ=-0.4, largura reduz para ~0.10h, economizando 50% de runs para mesma precisão.",
                              "finalVerifications": [
                                "Cálculo correto de IC crude e antitético com fórmulas de Banks.",
                                "Correlação negativa observada entre pares antitéticos.",
                                "Redução de variância quantificada (>10%) e comparada às larguras de IC.",
                                "Gráficos mostram distribuição mais concentrada com antitéticas.",
                                "Relatório interpreta eficiência em termos de precisão vs. custo computacional.",
                                "Valor teórico W=1h está dentro de ambos ICs."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de médias, variâncias e ICs (erro <5%).",
                                "Implementação correta de antitéticas com correlação negativa comprovada.",
                                "% de redução de variância alinhado com teoria (1+ρ)/2.",
                                "Comparação clara de larguras de ICs e eficiência.",
                                "Uso adequado de ferramentas (Python, gráficos).",
                                "Interpretação contextualizada com referências a Banks et al."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Intervalos de confiança e redução de variância em Monte Carlo.",
                                "Programação: Simulações numéricas e geração de aleatórias.",
                                "Probabilidade: Propriedades de variáveis antitéticas e exponenciais.",
                                "Engenharia de Sistemas: Modelagem de filas em processos reais.",
                                "Análise de Dados: Visualização e interpretação de resultados simulados."
                              ],
                              "realWorldApplication": "Em simulações de filas para otimizar call centers, hospitais ou redes de telecomunicações, reduzindo tempo de computação para estimativas precisas de tempos de espera, permitindo decisões rápidas em design de sistemas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.2.2"
                            ]
                          },
                          {
                            "id": "10.1.7.2.3.3",
                            "name": "Interpretar resultados e limitações",
                            "description": "Analisar casos onde ρ > 0 (pior que comum), citando referências como Law & Kelton, e decidir quando combinar com outras técnicas como estratificação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar resultados da simulação com variáveis antitéticas",
                                  "subSteps": [
                                    "Execute ou carregue os resultados de uma simulação usando pares antitéticos (X_i e Y_i = M - X_i).",
                                    "Calcule as estimativas de média e variância para o método comum e antitético.",
                                    "Compare a variância reduzida (Var[(X_i + Y_i)/2]) com a variância comum.",
                                    "Registre os valores de ρ estimados a partir da amostra: ρ ≈ 1 - 2 * Var[(X_i + Y_i)/2] / Var[X_i].",
                                    "Identifique preliminarmente se ρ < 0 (sucesso) ou ρ > 0 (falha na redução)."
                                  ],
                                  "verification": "Confirme que as tabelas de resultados mostram variâncias calculadas e ρ estimado com precisão numérica.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Código de simulação (Python/R), planilha ou software como Arena/Simio.",
                                  "tips": "Sempre use pelo menos 1000 réplicas para estimativas confiáveis de ρ.",
                                  "learningObjective": "Compreender os dados brutos gerados por simulações antitéticas.",
                                  "commonMistakes": "Ignorar o número insuficiente de réplicas, levando a ρ instável."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar casos onde ρ > 0 (pior que o comum)",
                                  "subSteps": [
                                    "Calcule explicitamente ρ da amostra e confirme se ρ > 0.",
                                    "Examine a distribuição das variáveis: ρ > 0 ocorre quando X_i e Y_i tendem a ser ambos altos ou ambos baixos.",
                                    "Investigue dependências não lineares ou assimetrias na distribuição que violam a independência negativa ideal.",
                                    "Compare com método comum: verifique se Var_antitético > Var_comum.",
                                    "Documente exemplos específicos da simulação onde isso acontece (e.g., caudas pesadas)."
                                  ],
                                  "verification": "Produza um gráfico de dispersão de X_i vs Y_i mostrando correlação positiva.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Bibliotecas de plotagem (Matplotlib/ggplot), dados da simulação.",
                                  "tips": "ρ > 0 é comum em distribuições multimodais; plote histogramas conjuntos.",
                                  "learningObjective": "Identificar falhas na redução de variância devido a correlação positiva.",
                                  "commonMistakes": "Confundir ρ amostral com ρ populacional sem testes de significância."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Citar e aplicar referências como Law & Kelton",
                                  "subSteps": [
                                    "Consulte Law & Kelton (Simulation Modeling and Analysis, cap. 11.3): ρ > 0 quando E[X(M-x)] > 0 para x ≠ M/2.",
                                    "Extraia teoremas sobre condições para ρ negativo (e.g., monotonicidade).",
                                    "Aplique ao seu caso: verifique se a função de performance é não-monotônica.",
                                    "Anote limitações discutidas: antitéticas falham em sistemas com feedback forte.",
                                    "Compare com exemplos do livro (e.g., filas M/M/1 onde ρ ≈ -0.7 vs casos ruins)."
                                  ],
                                  "verification": "Inclua citações exatas e parágrafos relevantes no relatório.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro Law & Kelton (PDF ou físico), notas de aula.",
                                  "tips": "Use índice para 'antithetic variates' e foque em Seção 11.3.2.",
                                  "learningObjective": "Integrar literatura acadêmica à análise prática.",
                                  "commonMistakes": "Citar superficialmente sem conectar ao caso específico."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Decidir combinação com outras técnicas como estratificação",
                                  "subSteps": [
                                    "Avalie se estratificação resolve: divida o espaço de entrada em estratos balanceados.",
                                    "Planeje hibridização: use antitéticas dentro de estratos.",
                                    "Simule piloto do método combinado e compare variâncias.",
                                    "Decida critérios: combine se redução > 20% vs antitéticas sozinhas.",
                                    "Documente trade-offs: custo computacional vs ganho em precisão."
                                  ],
                                  "verification": "Relatório com comparação de variâncias: comum, antitéticas, estratificadas, combinadas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código para estratificação, simulador.",
                                  "tips": "Estratificação é robusta; mire em estratos proporcionais à variância.",
                                  "learningObjective": "Selecionar técnicas complementares baseado em evidências.",
                                  "commonMistakes": "Combinar sem testar, assumindo sinergia automática."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar limitações gerais e recomendações",
                                  "subSteps": [
                                    "Liste limitações: sensível a não-linearidades, difícil diagnóstico a priori.",
                                    "Recomende testes prévios (e.g., correlograma piloto).",
                                    "Sugira alternativas: controle de variância condicional se ρ > 0 persistir.",
                                    "Escreva conclusões acionáveis para o modelo simulado.",
                                    "Atualize o plano de simulação com lições aprendidas."
                                  ],
                                  "verification": "Seção de relatório com bullet points de limitações e próximos passos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Template de relatório.",
                                  "tips": "Sempre quantifique limitações com números da simulação.",
                                  "learningObjective": "Formular recomendações holísticas para redução de variância.",
                                  "commonMistakes": "Subestimar limitações, levando a overuse de antitéticas."
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila M/M/1 com ρ=0.3 >0 (devido a chegadas bursty), antitéticas aumentam variância em 15%; combinando com estratificação por número de chegadas/hora, reduz variância em 45% vs comum.",
                              "finalVerifications": [
                                "ρ calculado corretamente e interpretado (positivo/negativo).",
                                "Citação precisa de Law & Kelton com aplicação ao caso.",
                                "Gráficos mostram evidência visual de correlação.",
                                "Recomendação de combinação justificada por simulação piloto.",
                                "Relatório lista 3+ limitações específicas.",
                                "Variâncias comparadas numericamente em tabela."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de ρ e variâncias (90%+ acurácia).",
                                "Profundidade na análise de causas de ρ > 0 (3+ razões identificadas).",
                                "Integração correta de referências acadêmicas.",
                                "Qualidade da decisão de hibridização (baseada em dados).",
                                "Clareza e completude do relatório (todos elementos presentes).",
                                "Criatividade em conexões com mundo real."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Testes de correlação e variância (Spearman/Kendall).",
                                "Programação: Implementação eficiente em Python (NumPy/SciPy).",
                                "Gestão de Projetos: Decisões baseadas em trade-offs custo-benefício.",
                                "Física/Engenharia: Modelagem estocástica em sistemas dinâmicos."
                              ],
                              "realWorldApplication": "Em simulações de supply chain para previsão de estoque, onde ρ > 0 em demandas sazonais; combine antitéticas com estratificação para otimizar alocação de recursos, reduzindo custos em 20-30% em ferramentas como AnyLogic."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.3",
                    "name": "Variáveis de Controle",
                    "description": "Emprega variáveis aleatórias auxiliares correlacionadas com a resposta de interesse para ajustar a estimativa e reduzir a variância da simulação.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.3.1",
                        "name": "Princípio das Variáveis de Controle",
                        "description": "Entende o conceito fundamental de usar variáveis aleatórias auxiliares, conhecidas como variáveis de controle, que são correlacionadas negativamente com a resposta de interesse para reduzir a variância da estimativa na simulação de sistemas discretos.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.3.1.1",
                            "name": "Definir variáveis de controle",
                            "description": "Explicar o que são variáveis de controle em simulações, destacando que são variáveis aleatórias auxiliares com valor esperado conhecido e alta correlação negativa com a variável de resposta, conforme descrito em Banks et al. (2000).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição formal de variáveis de controle",
                                  "subSteps": [
                                    "Ler a definição em Banks et al. (2000): variáveis aleatórias auxiliares com valor esperado conhecido.",
                                    "Identificar o papel na redução de variância em simulações.",
                                    "Anotar exemplos iniciais de simulações discretas onde são aplicadas.",
                                    "Explicar em suas próprias palavras o conceito.",
                                    "Comparar com outras técnicas de redução de variância."
                                  ],
                                  "verification": "Escrever um parágrafo resumindo a definição e seu propósito.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Referência: Banks et al. (2000), capítulo sobre simulação",
                                    "Caderno de anotações",
                                    "Acesso online ao livro ou PDF"
                                  ],
                                  "tips": "Foque na distinção entre variável de resposta e auxiliar.",
                                  "learningObjective": "Dominar a definição conceitual de variáveis de controle.",
                                  "commonMistakes": [
                                    "Confundir com variáveis independentes",
                                    "Ignorar a necessidade de valor esperado conhecido"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar os critérios essenciais para variáveis de controle",
                                  "subSteps": [
                                    "Listar os dois critérios principais: E[g(X)] conhecido e Cov(h(X), g(X)) < 0 alta.",
                                    "Explicar por que a correlação negativa é crucial para redução de variância.",
                                    "Analisar fórmulas matemáticas da estimativa controlada: Y_c = h(X) - b[g(X) - E[g(X)]]",
                                    "Discutir como escolher b ótimo.",
                                    "Criar uma tabela comparativa de critérios bons vs. ruins."
                                  ],
                                  "verification": "Montar uma checklist com os critérios e exemplos de cumprimento.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Fórmulas de redução de variância impressas",
                                    "Calculadora ou software simbólico como SymPy",
                                    "Planilha para tabela"
                                  ],
                                  "tips": "Use diagramas para visualizar covariância.",
                                  "learningObjective": "Saber selecionar variáveis candidatas baseadas em critérios precisos.",
                                  "commonMistakes": [
                                    "Assumir correlação positiva como benéfica",
                                    "Esquecer de normalizar pelo valor esperado"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar exemplos e construir uma variável de controle",
                                  "subSteps": [
                                    "Estudar exemplo em simulação de filas M/M/1: usar número de chegadas como controle para tempo de espera.",
                                    "Calcular manualmente E[g(X)] para o exemplo.",
                                    "Verificar correlação negativa computando Cov em uma amostra simulada.",
                                    "Construir uma variável de controle personalizada para um sistema discreto simples.",
                                    "Simular 100 réplicas para testar redução de variância."
                                  ],
                                  "verification": "Gerar relatório com cálculos de variância antes/depois do controle.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software de simulação (Python com NumPy/SciPy ou R)",
                                    "Dataset de simulação de filas",
                                    "Editor de código"
                                  ],
                                  "tips": "Comece com sistemas familiares para facilitar.",
                                  "learningObjective": "Aplicar critérios para definir variáveis de controle em contextos reais.",
                                  "commonMistakes": [
                                    "Escolher variável sem verificar E[g(X)] conhecido",
                                    "Usar amostras pequenas para correlação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e otimizar a definição de variáveis de controle",
                                  "subSteps": [
                                    "Testar sensibilidade do parâmetro b em diferentes valores.",
                                    "Comparar variância reduzida com método crude.",
                                    "Documentar limitações, como dependência de conhecimento prévio de E[g(X)].",
                                    "Refinar a variável de controle iterativamente.",
                                    "Preparar um caso de uso para apresentação."
                                  ],
                                  "verification": "Demonstrar redução de variância >20% em simulação.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Código de simulação do step 3",
                                    "Gráficos de variância (Matplotlib ou ggplot)",
                                    "Referências adicionais sobre princípios de controle"
                                  ],
                                  "tips": "Otimize b via regressão linear simples.",
                                  "learningObjective": "Garantir eficácia e robustez na definição.",
                                  "commonMistakes": [
                                    "Fixar b=1 sem otimização",
                                    "Ignorar multicolinearidade em múltiplos controles"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de sistema de filas M/M/1 (λ=1, μ=1.5), a variável de resposta é o tempo médio de espera W. Defina g(X) = número de chegadas N no intervalo de simulação, com E[N]=λT conhecido. Calcule Cov(W, N)<0 devido à relação inversa (mais chegadas aumentam espera, mas controle ajusta). Simule 1000 runs: variância crude Var(W)=0.15, com controle Var(W_c)=0.09 (redução de 40%).",
                              "finalVerifications": [
                                "Explicar definição e critérios sem consultar materiais.",
                                "Identificar variável de controle válida em novo cenário de simulação.",
                                "Calcular corretamente a estimativa controlada Y_c.",
                                "Demonstrar redução de variância em exemplo prático.",
                                "Discutir limitações do método.",
                                "Comparar com antithetic variates."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição (valor esperado conhecido e correlação negativa).",
                                "Capacidade de aplicar em simulação discreta.",
                                "Cálculos matemáticos corretos (Cov, b ótimo).",
                                "Evidência quantitativa de redução de variância.",
                                "Clareza na documentação e exemplos.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Cálculo de covariâncias e regressão linear.",
                                "Programação: Implementação em Python/R para simulações Monte Carlo.",
                                "Otimização: Minimização de variância como problema de otimização.",
                                "Probabilidade: Propriedades de variáveis aleatórias em sistemas estocásticos."
                              ],
                              "realWorldApplication": "Em simulações financeiras para precificação de opções (Monte Carlo), variáveis de controle reduzem tempo computacional em 30-50%, permitindo análises em tempo real para trading algorítmico; em logística, otimizam simulações de supply chain para prever atrasos com maior precisão."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.3.1.2",
                            "name": "Identificar requisitos para variáveis de controle",
                            "description": "Listar e justificar os requisitos essenciais: E[Y_aux] conhecido, Cov(X, Y_aux) < 0 e |ρ| próximo de 1, onde X é a resposta e Y_aux a auxiliar, para garantir redução de variância.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar fundamentos das variáveis de controle em simulações Monte Carlo",
                                  "subSteps": [
                                    "Explicar o estimador controlado: E[X] ≈ (1/n) Σ (X_i - Y_aux_i) + E[Y_aux]",
                                    "Discutir a fórmula da variância reduzida: Var(X_c) = Var(X) + Var(Y_aux) - 2 Cov(X, Y_aux)",
                                    "Identificar que redução ocorre quando Cov(X, Y_aux) < 0 e Var(Y_aux) pequena",
                                    "Exemplificar com um caso simples de integral Monte Carlo",
                                    "Calcular manualmente a variância para n=1000 amostras fictícias"
                                  ],
                                  "verification": "Capacidade de derivar a fórmula da variância do estimador controlado de memória",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Notas de aula sobre Monte Carlo",
                                    "Calculadora ou Python/Jupyter para cálculos"
                                  ],
                                  "tips": "Sempre anote a fórmula da variância antes de prosseguir para fixar na memória",
                                  "learningObjective": "Compreender como variáveis de controle reduzem variância via covariância negativa",
                                  "commonMistakes": "Confundir sinal da covariância (pensar que positiva reduz variância)"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e justificar o requisito E[Y_aux] conhecido",
                                  "subSteps": [
                                    "Explicar por que E[Y_aux] deve ser calculado analiticamente, não por simulação",
                                    "Derivar o estimador unbiased: média de (X - Y_aux) + E[Y_aux]",
                                    "Mostrar que se E[Y_aux] desconhecido, o bias é introduzido",
                                    "Testar com exemplo numérico: assumir Y_aux com E[Y_aux]=0.5 conhecido vs desconhecido",
                                    "Verificar impacto na estimativa final com 10 réplicas"
                                  ],
                                  "verification": "Justificar em uma frase por que E[Y_aux] conhecido preserva unbiasedness",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de papel para derivações",
                                    "Software R ou Python para simular Y_aux"
                                  ],
                                  "tips": "Escolha Y_aux simples como funções lineares para E[] fácil de calcular",
                                  "learningObjective": "Reconhecer E[Y_aux] conhecido como essencial para estimador não viesado",
                                  "commonMistakes": "Achar que E[Y_aux] pode ser aproximado pela simulação (introduz variância extra)"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e justificar Cov(X, Y_aux) < 0",
                                  "subSteps": [
                                    "Calcular Cov(X, Y_aux) = E[(X - E[X])(Y_aux - E[Y_aux])]",
                                    "Mostrar na fórmula Var(X_c) que termo -2 Cov reduz variância se Cov < 0",
                                    "Construir Y_aux anticorrelated: e.g., Y_aux = f(X) crescente se X decrescente",
                                    "Simular e plotar scatter plot de X vs Y_aux para visualizar correlação negativa",
                                    "Quantificar ganho: calcular Var(X_c)/Var(X) < 1"
                                  ],
                                  "verification": "Produzir gráfico ou tabela mostrando Cov < 0 e redução de variância",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Python com NumPy/Matplotlib ou R",
                                    "Dados simulados de X e Y_aux"
                                  ],
                                  "tips": "Use Y_aux = c - X para garantir Cov negativa se c constante",
                                  "learningObjective": "Entender o papel da covariância negativa na minimização da variância",
                                  "commonMistakes": "Ignorar o sinal: usar Y_aux positively correlated (aumenta variância)"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar e justificar |ρ| próximo de 1 para máxima redução",
                                  "subSteps": [
                                    "Definir ρ = Cov(X, Y_aux) / (σ_X σ_{Y_aux})",
                                    "Explicar que |ρ| ≈1 maximiza |Cov| para Var(Y_aux) fixed",
                                    "Comparar simulações: ρ=-0.3 vs ρ=-0.9, medir Var(X_c)",
                                    "Discutir trade-off: alta |ρ| requer Y_aux bem escolhido mas E[] simples",
                                    "Listar os 3 requisitos completos e sua interdependência"
                                  ],
                                  "verification": "Calcular ρ em simulação e confirmar |ρ| > 0.8 para redução >50%",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Código Python/R pronto para correlação",
                                    "Gráficos de variância vs ρ"
                                  ],
                                  "tips": "Monitore ρ iterativamente ao escolher Y_aux para otimizar",
                                  "learningObjective": "Reconhecer alta correlação como chave para eficiência máxima",
                                  "commonMistakes": "Confundir ρ com Cov: alta Cov sem normalizar não garante ótima redução"
                                }
                              ],
                              "practicalExample": "Em simulação de tempo médio de espera em fila M/M/1 (λ=0.8, μ=1), X=espera, Y_aux=1-X/max_espera simulada (normalizada). E[Y_aux]=0.2 conhecido analiticamente, Cov<0 por construção, |ρ|≈0.85, reduz Var em 60%. Código Python: simule 10k paths, compare ICs.",
                              "finalVerifications": [
                                "Lista corretamente os 3 requisitos: E[Y_aux] conhecido, Cov<0, |ρ|≈1",
                                "Justifica redução de variância via fórmula Var(X_c)",
                                "Aplica requisitos em exemplo numérico com cálculo de Cov e ρ",
                                "Identifica Y_aux válida para um problema dado",
                                "Compara Var antes/depois controle em simulação",
                                "Explica por que violar um requisito falha (e.g., E[Y_aux] desconhecido causa bias)"
                              ],
                              "assessmentCriteria": [
                                "Precisão na lista e justificativa dos 3 requisitos (100%)",
                                "Correta derivação da fórmula de variância reduzida",
                                "Qualidade do exemplo prático com números concretos",
                                "Demonstração de Cov<0 e |ρ|>0.7 via simulação ou cálculo",
                                "Clareza na interconexão dos requisitos",
                                "Identificação de erros comuns e como evitá-los"
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Cálculo de covariância e correlação",
                                "Programação Computacional: Implementação em Python/R para simulações",
                                "Probabilidade: Expectativas analíticas e propriedades de variância",
                                "Otimização: Escolha de Y_aux como problema de maximização |ρ|"
                              ],
                              "realWorldApplication": "Em finanças quantitativas, reduzir variância na simulação de Value-at-Risk (VaR) de portfólios usando controles anticorrelated com retornos, permitindo estimativas precisas com menos simulações computacionalmente caras; economiza tempo em risco management de bancos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.3.1.3",
                            "name": "Comparar com simulação crua",
                            "description": "Comparar a variância da simulação crua Var(Ȳ) com a ajustada usando controle, destacando o ganho quando o coeficiente de correlação é negativo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Simulação Crua e Sua Variância",
                                  "subSteps": [
                                    "Execute uma simulação crua de Monte Carlo para estimar E[Y], gerando n amostras independentes Y1, ..., Yn e computando Ȳ = (1/n) Σ Yi.",
                                    "Calcule a variância amostral de Ȳ, que é aproximadamente Var(Ȳ) = σ² / n, onde σ² = Var(Y).",
                                    "Registre valores numéricos para diferentes tamanhos de n (ex: n=100, 1000) para observar o comportamento da variância.",
                                    "Discuta assintoticamente que Var(Ȳ) → 0 à medida que n → ∞, mas lentamente para variância alta.",
                                    "Compare com cenários reais onde variância alta exige n muito grande."
                                  ],
                                  "verification": "Confirme que o código/simulação produz Ȳ com variância empírica próxima a σ²/n; plote histogramas de Ȳ sobre múltiplas runs.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python/R com bibliotecas numpy/random; caderno para anotações; simulador online de Monte Carlo.",
                                  "tips": "Use sementes fixas para reprodutibilidade; comece com distribuições simples como exponencial.",
                                  "learningObjective": "Entender a variância da estimativa crua e seus limites computacionais.",
                                  "commonMistakes": "Confundir variância amostral com variância populacional; ignorar dependência de n."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a Variável de Controle e Estimativa Ajustada",
                                  "subSteps": [
                                    "Selecione uma variável de controle Z com E[Z] = μ_z conhecido e Cov(Y,Z) ≠ 0.",
                                    "Gere pares (Yi, Zi) na simulação e compute Ȳ_z = (1/n) Σ Zi.",
                                    "Escolha b = Cov(Y,Z)/Var(Z) (ideal) e forme a estimativa ajustada Ȳ_adj = Ȳ - b (Ȳ_z - μ_z).",
                                    "Execute simulações pareadas para ambos Ȳ e Ȳ_adj.",
                                    "Observe que Ȳ_adj é ainda não viesada: E[Ȳ_adj] = E[Y]."
                                  ],
                                  "verification": "Verifique que E[Ȳ_adj] ≈ E[Y] em múltiplas runs; compute b empiricamente se necessário.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Mesmo software do Step 1; tabela de valores conhecidos μ_z (ex: para Z~Uniform(0,1), μ_z=0.5).",
                                  "tips": "Escolha Z negativamente correlacionada com Y para ganho intuitivo; plote pares (Y,Z).",
                                  "learningObjective": "Construir e validar a estimativa ajustada usando controle.",
                                  "commonMistakes": "Usar b incorreto (ex: 1 em vez de covariância); esquecer de parear Yi e Zi."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar e Calcular a Variância Ajustada",
                                  "subSteps": [
                                    "Derive Var(Ȳ_adj) = Var(Ȳ) * (1 - ρ²), onde ρ = Corr(Y,Z).",
                                    "Mostre que o fator de redução é 1/(1 - ρ²) >1 quando ρ ≠0.",
                                    "Compute ρ empiricamente das simulações pareadas.",
                                    "Simule cenários com ρ positivo e negativo, fixando |ρ| igual.",
                                    "Calcule variâncias empíricas de Ȳ e Ȳ_adj para comparação numérica."
                                  ],
                                  "verification": "Confirme que Var_emp(Ȳ_adj) / Var_emp(Ȳ) ≈ 1 - ρ²; teste com n=1000 para precisão.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Software com funções de correlação (corrcoef em Python); quadro para derivação.",
                                  "tips": "Use aproximações assintóticas; foque em |ρ|>0.5 para ganhos visíveis.",
                                  "learningObjective": "Compreender matematicamente a redução de variância via correlação.",
                                  "commonMistakes": "Esquecer o fator 1/n em ambas variâncias; confundir ρ com Cov."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Variâncias e Destacar Ganho com Correlação Negativa",
                                  "subSteps": [
                                    "Compare Var(Ȳ) vs Var(Ȳ_adj) em tabelas/gráficos para ρ=-0.8 vs ρ=0.8 vs ρ=0.",
                                    "Note que ganho é idêntico para ±ρ (devido a ρ²), mas explique intuição: correlação negativa faz Ȳ_adj 'cancelar' erros opostos.",
                                    "Calcule eficiência: n_adj = n_crua * (1 - ρ²) para mesma precisão.",
                                    "Simule com ρ negativo alto e observe redução dramática na variância.",
                                    "Discuta quando ganho é máximo: |ρ| próximo de 1."
                                  ],
                                  "verification": "Produza relatório com tabelas/gráficos mostrando Var_adj < Var_crua, especialmente para ρ<0.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software de plotagem (matplotlib/ggplot); exemplos pré-gerados de simulações.",
                                  "tips": "Visualize com boxplots de Ȳ e Ȳ_adj; quantifique ganho em %.",
                                  "learningObjective": "Analisar quantitativamente o benefício, enfatizando cenários de ρ negativo.",
                                  "commonMistakes": "Acreditar que ρ negativo dá ganho maior que positivo (é simétrico); ignorar custo computacional extra."
                                }
                              ],
                              "practicalExample": "Estime P(X>1) onde X~Exp(1) via MC crua (Y=I(X>1)). Use Z=X como controle (μ_z=1, ρ≈-0.58). Para n=10^4, Var(Ȳ_crua)≈9.5e-5, Var(Ȳ_adj)≈1.6e-5 (redução ~85%).",
                              "finalVerifications": [
                                "Código roda sem erros e reproduz resultados consistentes.",
                                "Variância ajustada é menor que crua em simulações com |ρ|>0.3.",
                                "Fórmula Var(Ȳ_adj)=Var(Ȳ)(1-ρ²) é corretamente derivada/aplicada.",
                                "Gráficos/tabelas mostram claramente o ganho para ρ negativo.",
                                "Eficiência computacional é calculada corretamente.",
                                "Explicação intuiutiva do 'cancelamento' para ρ<0 está presente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da fórmula de variância (100% correto).",
                                "Qualidade dos experimentos numéricos (múltiplas runs, n adequados).",
                                "Interpretação correta do papel da correlação negativa.",
                                "Visualizações claras e informativas.",
                                "Quantificação exata do ganho (fator 1/(1-ρ²)).",
                                "Ausência de vieses na estimativa ajustada."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Conceitos de correlação e redução de variância em inferência.",
                                "Programação: Simulações em Python/R, análise de dados com pandas.",
                                "Probabilidade: Propriedades de variáveis auxiliares e controle.",
                                "Engenharia: Otimização em simulações de sistemas estocásticos."
                              ],
                              "realWorldApplication": "Em finanças, reduzir variância em simulações de risco (Value-at-Risk) usando retornos passados como controle; em física, simular colisões de partículas com conservação de momentum como Z para precisão em experimentos caros."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.3.2",
                        "name": "Construção do Estimador com Variáveis de Controle",
                        "description": "Aprende a formular o estimador ajustado usando o método de variáveis de controle, incluindo a determinação ótima do parâmetro de ajuste β.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.3.2.1",
                            "name": "Formular o estimador ajustado",
                            "description": "Derivar a fórmula do estimador controlado Ȳ_c = Ȳ - β(Ȳ_aux - μ_aux), onde β é o parâmetro de controle e μ_aux = E[Y_aux] é conhecido.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o estimador não controlado e motivação para controle",
                                  "subSteps": [
                                    "Lembre-se da definição do estimador Monte Carlo padrão: Ȳ = (1/n) Σ Y_i, onde Y_i são amostras independentes de Y.",
                                    "Entenda que Var(Ȳ) = Var(Y)/n, e o objetivo é reduzi-la usando informações auxiliares.",
                                    "Identifique cenários onde uma variável auxiliar Y_aux está correlacionada com Y e tem expectativa conhecida μ_aux = E[Y_aux].",
                                    "Discuta intuitivamente como subtrair um múltiplo do erro de Y_aux pode cancelar variância.",
                                    "Esboce a forma geral proposta: Ȳ_c = Ȳ - β (Ȳ_aux - μ_aux)."
                                  ],
                                  "verification": "Escreva a fórmula do estimador padrão e explique verbalmente por que o ajuste com β reduz variância.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e lápis; notas de aula sobre Monte Carlo; calculadora.",
                                  "tips": "Visualize graficamente Y vs Y_aux para ver a correlação linear.",
                                  "learningObjective": "Compreender a limitação do estimador básico e a necessidade de variáveis de controle.",
                                  "commonMistakes": "Confundir variância com viés; ignorar que μ_aux deve ser exatamente conhecido."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir propriedades da variável auxiliar e estimadores amostrais",
                                  "subSteps": [
                                    "Defina formalmente Y_aux tal que Cov(Y, Y_aux) ≠ 0 e E[Y_aux] = μ_aux conhecido.",
                                    "Calcule os estimadores amostrais: Ȳ_aux = (1/n) Σ Y_aux,i.",
                                    "Verifique que E[Ȳ_aux] = μ_aux, logo E[Ȳ_aux - μ_aux] = 0.",
                                    "Compute E[Ȳ_c] = E[Ȳ] - β E[Ȳ_aux - μ_aux] = E[Y], confirmando não viés.",
                                    "Introduza a covariância: Cov(Ȳ, Ȳ_aux - μ_aux) = Cov(Y, Y_aux)/n."
                                  ],
                                  "verification": "Prove algebricamente que o estimador ajustado é não viesado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel e lápis; tabela de fórmulas de expectativa e covariância.",
                                  "tips": "Use independência das amostras para simplificar expectativas.",
                                  "learningObjective": "Estabelecer as condições matemáticas para a variável de controle.",
                                  "commonMistakes": "Esquecer de dividir por n nas variâncias amostrais; assumir dependência entre amostras."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a variância do estimador ajustado",
                                  "subSteps": [
                                    "Escreva Var(Ȳ_c) = Var(Ȳ - β (Ȳ_aux - μ_aux)) = Var(Ȳ) + β² Var(Ȳ_aux) - 2β Cov(Ȳ, Ȳ_aux).",
                                    "Substitua: Var(Ȳ) = σ²/n, Var(Ȳ_aux) = σ_aux²/n, Cov(Ȳ, Ȳ_aux) = γ/n, onde γ = Cov(Y, Y_aux).",
                                    "Simplifique para Var(Ȳ_c) = (σ² - 2β γ + β² σ_aux²)/n.",
                                    "Identifique isso como uma função quadrática em β: a β² - 2b β + c, com mínimo em β = b/a.",
                                    "Mostre que o mínimo ocorre em β = γ / σ_aux² = Cov(Y, Y_aux)/Var(Y_aux)."
                                  ],
                                  "verification": "Derive a expressão completa de Var(Ȳ_c) e encontre o β que a minimiza.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e lápis; software como Python ou Mathematica para simbolismo opcional.",
                                  "tips": "Complete o quadrado para visualizar o mínimo da quadrática.",
                                  "learningObjective": "Calcular a variância do estimador controlado e otimizar β.",
                                  "commonMistakes": "Erros de sinal na covariância; confundir Cov(Ȳ, Ȳ_aux) com Cov(Y, Y_aux)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar a fórmula e verificar redução de variância",
                                  "subSteps": [
                                    "Substitua β ótimo na fórmula: Ȳ_c = Ȳ - [Cov(Y, Y_aux)/Var(Y_aux)] (Ȳ_aux - μ_aux).",
                                    "Calcule Var(Ȳ_c) no ótimo: (σ² - γ²/σ_aux²)/n = [1 - ρ²] σ²/n, onde ρ é correlação.",
                                    "Confirme que Var(Ȳ_c) < Var(Ȳ) se |ρ| > 0.",
                                    "Discuta estimação prática de β via amostras piloto.",
                                    "Escreva a fórmula final destacando todos os componentes."
                                  ],
                                  "verification": "Escreva a fórmula completa com β ótimo e prove que a variância é reduzida.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel e lápis; exemplo numérico simples para teste.",
                                  "tips": "Use ρ² para quantificar a redução percentual de variância.",
                                  "learningObjective": "Consolidar a derivação e entender o ganho prático.",
                                  "commonMistakes": "Não reconhecer que β ótimo requer conhecimento ou estimação de momentos; ignorar o caso ρ=0."
                                }
                              ],
                              "practicalExample": "Em simulação de uma integral ∫_0^1 x² dx = 1/3, use Y = x² e Y_aux = x (μ_aux=1/2). Correlação negativa permite β ≈ -2/3, reduzindo variância em ~66%. Simule n=1000 amostras em Python: gere x~U(0,1), compute Ȳ e Ȳ_c, compare variâncias.",
                              "finalVerifications": [
                                "Derivação correta de E[Ȳ_c] = E[Y].",
                                "Expressão exata de Var(Ȳ_c) como função de β.",
                                "β ótimo = Cov(Y,Y_aux)/Var(Y_aux).",
                                "Prova de que Var(Ȳ_c) ≤ Var(Ȳ) com igualdade iff ρ=0.",
                                "Fórmula final escrita corretamente: Ȳ_c = Ȳ - β(Ȳ_aux - μ_aux).",
                                "Exemplo numérico com redução de variância demonstrada."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação de expectativa e variância (40%).",
                                "Correta identificação e otimização de β (30%).",
                                "Clareza na explicação de substeps e verificações (15%).",
                                "Uso correto de notação estatística (10%).",
                                "Demonstração prática via exemplo (5%)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Conceitos de covariância, correlação e regressão linear.",
                                "Programação: Implementação em Python/R para simulações Monte Carlo.",
                                "Probabilidade: Propriedades de expectativa condicional e independência.",
                                "Física/Engenharia: Redução de variância em simulações de sistemas estocásticos."
                              ],
                              "realWorldApplication": "Em finanças, otimizar simulações de risco (Value-at-Risk) usando retornos auxiliares correlacionados; em engenharia, melhorar precisão de simulações de Monte Carlo para confiabilidade de sistemas discretos, reduzindo tempo computacional em 50-90%."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.1"
                            ]
                          },
                          {
                            "id": "10.1.7.3.2.2",
                            "name": "Calcular o β ótimo",
                            "description": "Determinar o valor ótimo de β que minimiza a variância: β* = Cov(X, Y_aux)/Var(Y_aux), e explicar seu impacto na redução de variância para ρ² próximo de 1.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de variáveis de controle e β ótimo",
                                  "subSteps": [
                                    "Revise a definição de variável de controle Y_aux como uma variável correlacionada com o estimador X, mas com variância conhecida ou menor.",
                                    "Entenda a fórmula do estimador controlado: θ_controlado = X - β (Y_aux - E[Y_aux]).",
                                    "Derive intuitivamente por que β* = Cov(X, Y_aux)/Var(Y_aux) minimiza a variância, usando a relação Var(θ_controlado) = Var(X) (1 - ρ²), onde ρ é a correlação.",
                                    "Explique o impacto: quando ρ² ≈ 1, a redução de variância é máxima, acelerando a convergência de simulações Monte Carlo.",
                                    "Identifique condições para uso: Cov(X, Y_aux) ≠ 0 e Var(Y_aux) conhecida."
                                  ],
                                  "verification": "Escreva a derivação da fórmula de β* a partir da minimização da variância e explique o papel de ρ².",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Notas de aula sobre técnicas de redução de variância",
                                    "Calculadora ou papel para derivações",
                                    "Artigo ou vídeo sobre variáveis de controle em simulações"
                                  ],
                                  "tips": "Visualize graficamente a regressão linear entre X e Y_aux para intuitivamente ver β* como o coeficiente de inclinação.",
                                  "learningObjective": "Dominar a teoria por trás do β ótimo e sua relação com a correlação ρ.",
                                  "commonMistakes": [
                                    "Confundir Cov(X, Y_aux) com correlação ρ.",
                                    "Ignorar que E[Y_aux] deve ser subtraído para centralizar.",
                                    "Assumir ρ² = 1 sempre possível sem verificar linearidade."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar e coletar dados amostrais para X e Y_aux",
                                  "subSteps": [
                                    "Defina o experimento de simulação: gere N amostras independentes de X (estimador bruto) e Y_aux (variável auxiliar).",
                                    "Garanta que as amostras sejam pareadas: para cada replicação i, compute X_i e Y_i_aux simultaneamente.",
                                    "Calcule as médias amostrais: média_X = (1/N) Σ X_i, média_Y_aux = (1/N) Σ Y_i_aux.",
                                    "Centralize os dados: defina X_c_i = X_i - média_X, Y_aux_c_i = Y_i_aux - média_Y_aux.",
                                    "Verifique a correlação preliminar: compute ρ_amostral ≈ Cov(X_c, Y_aux_c) / (std(X_c) * std(Y_aux_c)) para confirmar |ρ| alto."
                                  ],
                                  "verification": "Gere um conjunto de dados com N=1000 e confirme que as médias estão estáveis e ρ_amostral > 0.7.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Software de programação (Python com NumPy ou R)",
                                    "Script de simulação para o sistema discreto específico",
                                    "Planilha Excel para dados pequenos"
                                  ],
                                  "tips": "Use N grande (≥1000) para precisão; armazene dados em arrays para eficiência computacional.",
                                  "learningObjective": "Preparar dados empíricos pareados essenciais para estimativa robusta de β*.",
                                  "commonMistakes": [
                                    "Usar amostras não pareadas, levando a Cov enviesada.",
                                    "N muito pequeno, causando variância alta na estimativa de β*.",
                                    "Não centralizar dados antes de calcular momentos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Cov(X, Y_aux), Var(Y_aux) e derivar β*",
                                  "subSteps": [
                                    "Compute a covariância amostral: Cov = (1/(N-1)) Σ (X_c_i * Y_aux_c_i).",
                                    "Compute a variância de Y_aux: Var_Y_aux = (1/(N-1)) Σ (Y_aux_c_i²).",
                                    "Calcule β* = Cov / Var_Y_aux.",
                                    "Avalie a redução de variância: estime ρ² ≈ [Cov / (std_X * std_Y_aux)]² e Var_reduzida ≈ Var_X * (1 - ρ²).",
                                    "Compare Var(θ_controlado) com Var(X) via simulações adicionais para validar."
                                  ],
                                  "verification": "Implemente o cálculo em código e confirme que β* produz menor variância em 100 replicações extras.",
                                  "estimatedTime": "25-40 minutos",
                                  "materials": [
                                    "Código Python/R pronto com funções np.cov() ou var()",
                                    "Dados gerados no step anterior",
                                    "Gráficos para scatter plot de X vs Y_aux"
                                  ],
                                  "tips": "Use fórmulas amostrais unbiased (divisor N-1); valide com np.corrcoef() para ρ.",
                                  "learningObjective": "Executar os cálculos numéricos precisos para obter β* acionável.",
                                  "commonMistakes": [
                                    "Dividir por N em vez de N-1, subestimando variância.",
                                    "Confundir ordem: β* = Cov(X,Y_aux)/Var(Y_aux), não o inverso.",
                                    "Não testar se Var_Y_aux ≈ 0, causando divisão por zero."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar impacto de β* e verificar redução de variância",
                                  "subSteps": [
                                    "Construa o estimador controlado: θ_controlado_i = X_i - β* (Y_aux_i - média_Y_aux).",
                                    "Compute Var(θ_controlado) = (1/(N-1)) Σ (θ_controlado_c_i²) e compare com Var(X).",
                                    "Quantifique ganho: eficiência = Var(X) / Var(θ_controlado) = 1 / (1 - ρ²).",
                                    "Teste sensibilidade: varie N ou adicione ruído para ver robustez de β*.",
                                    "Documente: ρ² obtido, β* final e % de redução de variância."
                                  ],
                                  "verification": "Demonstre que Var(θ_controlado) < Var(X) e eficiência > 1.5 em exemplo prático.",
                                  "estimatedTime": "20-35 minutos",
                                  "materials": [
                                    "Código estendido do step 3",
                                    "Ferramentas de plotagem (Matplotlib/ggplot)",
                                    "Relatório template para resultados"
                                  ],
                                  "tips": "Sempre plote histogramas de X vs θ_controlado para visualização da redução de variância.",
                                  "learningObjective": "Validar empiricamente o benefício de β* ótimo na prática.",
                                  "commonMistakes": [
                                    "Esquecer de subtrair E[Y_aux] no estimador controlado.",
                                    "Interpretar ρ² baixo como falha sem checar linearidade.",
                                    "Não reportar intervalos de confiança para β*."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação Monte Carlo para estimar P(S > 0) em um sistema de filas M/M/1 com λ=0.8, μ=1, onde X_i = I(S_i > 0) (indicador de sobrecarga) e Y_aux_i = tempo médio na fila (correlacionado negativamente). Gere 5000 runs, calcule β* ≈ -0.45, resultando em ρ²=0.82 e redução de variância em 82%, permitindo estimativa precisa com menos simulações.",
                              "finalVerifications": [
                                "Deriva corretamente β* = Cov(X, Y_aux)/Var(Y_aux) a partir da minimização de Var(θ_controlado).",
                                "Calcula Cov e Var amostrais corretamente com divisor N-1 em dados dados.",
                                "Implementa estimador controlado em código e confirma redução de variância.",
                                "Explica impacto de ρ² próximo de 1 na eficiência simulacional.",
                                "Identifica e corrige erros comuns como amostras não pareadas.",
                                "Aplica em um exemplo real de simulação discreta."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação e fórmulas (100% correto).",
                                "Correção numérica nos cálculos com dados (erro < 1%).",
                                "Qualidade do código: eficiente, comentado e reproduzível.",
                                "Análise de impacto: quantificação clara de ρ² e eficiência.",
                                "Validação empírica: comparações gráficas e estatísticas.",
                                "Compreensão conceitual: explicação clara do porquê β* minimiza variância."
                              ],
                              "crossCurricularConnections": [
                                "Estatística Descritiva: cálculo de momentos (Cov, Var).",
                                "Programação Numérica: uso de NumPy/R para vetores e funções estatísticas.",
                                "Simulação Computacional: aplicação em Monte Carlo para sistemas estocásticos.",
                                "Otimização: minimização de função quadrática (variância).",
                                "Probabilidade: propriedades de correlação e variância condicional."
                              ],
                              "realWorldApplication": "Em finanças, otimiza simulações Monte Carlo para precificação de opções derivativas, reduzindo tempo computacional em 50-90%; em engenharia, melhora estimativas de confiabilidade em simulações de falhas de redes; em logística, acelera análise de performance de cadeias de suprimentos simuladas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.1"
                            ]
                          },
                          {
                            "id": "10.1.7.3.2.3",
                            "name": "Calcular variância do estimador controlado",
                            "description": "Computar Var(Ȳ_c) = Var(Ȳ)[1 - ρ²], demonstrando que a redução é proporcional ao quadrado da correlação, com exemplos numéricos simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Variância e Correlação",
                                  "subSteps": [
                                    "Defina a variância do estimador não controlado Ȳ como Var(Ȳ) = σ²/n, onde σ² é a variância populacional e n o tamanho da amostra.",
                                    "Explique o coeficiente de correlação ρ entre a variável de controle C e o estimador Ȳ.",
                                    "Lembre que ρ mede a dependência linear entre Ȳ e C, variando de -1 a 1.",
                                    "Discuta como ρ² representa a proporção da variância explicada pela correlação.",
                                    "Verifique com um exemplo simples: se ρ=0, não há redução; se ρ=1, variância zero."
                                  ],
                                  "verification": "Resuma em uma frase por que ρ² afeta a redução de variância e forneça um diagrama conceitual.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Folha de papel ou software de desenho (ex: Draw.io)",
                                    "Calculadora ou Python/Jupyter para fórmulas rápidas"
                                  ],
                                  "tips": "Use analogias como 'ρ² é como o quanto de sol explica o derretimento do gelo'.",
                                  "learningObjective": "Compreender os papéis de Var(Ȳ) e ρ na fórmula de variância controlada.",
                                  "commonMistakes": "Confundir ρ com ρ²; assumir ρ sempre positivo sem considerar sinal."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Fórmula da Variância do Estimador Controlado",
                                  "subSteps": [
                                    "Lembre o estimador controlado: Ȳ_c = Ȳ - b(C - μ_c), onde b = Cov(Ȳ,C)/Var(C).",
                                    "Mostre que Var(Ȳ_c) = Var(Ȳ) * (1 - ρ²), simplificando com ρ = Cov(Ȳ,C)/(σ_Ȳ σ_C).",
                                    "Derive passo a passo: Var(Ȳ_c) = Var(Ȳ - b(C - μ_c)) = Var(Ȳ) - 2b Cov(Ȳ,C) + b² Var(C), substituindo b.",
                                    "Simplifique para Var(Ȳ)(1 - ρ²), destacando a redução proporcional a ρ².",
                                    "Confirme com propriedades de variância condicional."
                                  ],
                                  "verification": "Escreva a derivação completa em um papel e verifique se chega exatamente em [1 - ρ²].",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Caderno de anotações",
                                    "Livro ou PDF de referência em simulação (ex: Ross 'Simulation')",
                                    "Calculadora simbólica como SymPy no Python"
                                  ],
                                  "tips": "Faça a derivação duas vezes: uma algebricamente, outra intuitivamente com regressão linear.",
                                  "learningObjective": "Derivar e justificar matematicamente a fórmula Var(Ȳ_c) = Var(Ȳ)[1 - ρ²].",
                                  "commonMistakes": "Esquecer o termo b na derivação; não normalizar corretamente para ρ."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Numericamente com um Exemplo Simples",
                                  "subSteps": [
                                    "Escolha um exemplo: Suponha Var(Ȳ) = 100, ρ = 0.8, então ρ² = 0.64.",
                                    "Calcule Var(Ȳ_c) = 100 * (1 - 0.64) = 36.",
                                    "Simule dados: Gere 100 pares (Ȳ_i, C_i) com correlação 0.8 usando numpy.random.",
                                    "Compute Cov(Ȳ,C), Var(C), b, e então Var(Ȳ_c) empiricamente para validar.",
                                    "Repita para ρ=0.5 (ρ²=0.25, Var=75) e ρ=0 (Var=100)."
                                  ],
                                  "verification": "Execute o cálculo e compare Var(Ȳ_c) teórica vs. simulada (erro <5%).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python com numpy e matplotlib",
                                    "Jupyter Notebook",
                                    "Dados simulados via código"
                                  ],
                                  "tips": "Use seed para reproducibilidade: np.random.seed(42).",
                                  "learningObjective": "Aplicar a fórmula em cálculos numéricos concretos.",
                                  "commonMistakes": "Usar ρ ao invés de ρ²; erros de arredondamento em simulações pequenas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar e Interpretar a Redução Proporcional",
                                  "subSteps": [
                                    "Crie uma tabela: ρ | ρ² | Fator de Redução (1-ρ²) | Exemplo Var(Ȳ=100)",
                                    "Preencha para ρ=0, 0.3, 0.6, 0.9: reduções 0%, 91%, 64%, 19%.",
                                    "Plote gráfico: eixo x=ρ, y=1-ρ², mostrando proporcionalidade quadrática.",
                                    "Interprete: Ganho maior para |ρ|>0.7; controle perfeito só se ρ=±1.",
                                    "Discuta impacto: tempo de simulação reduzido por fator 1/(1-ρ²)."
                                  ],
                                  "verification": "Gere tabela e gráfico corretos, explicando por que ρ=0.9 reduz 81%.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python matplotlib para plot",
                                    "Excel ou Google Sheets para tabela"
                                  ],
                                  "tips": "Foque em |ρ|, pois ρ² é sempre positivo.",
                                  "learningObjective": "Demonstrar visual e numericamente a proporcionalidade ao quadrado da correlação.",
                                  "commonMistakes": "Plotar ρ linear ao invés de ρ²; ignorar que redução é sempre ≤100%."
                                }
                              ],
                              "practicalExample": "Em uma simulação Monte Carlo para estimar π via método de Monte Carlo (jogando dardos em círculo), use a área média como Ȳ e uma variável auxiliar C (distância ao centro) correlacionada. Com ρ=0.85, Var(Ȳ_c)= Var(Ȳ)*0.2775, reduzindo amostras necessárias de 10k para ~2.8k para mesma precisão.",
                              "finalVerifications": [
                                "Deriva corretamente Var(Ȳ_c) = Var(Ȳ)[1 - ρ²] sem erros algébricos.",
                                "Calcula Var(Ȳ_c) para ρ=0.7 como 51% de Var(Ȳ).",
                                "Simula dados e valida fórmula empiricamente (erro <10%).",
                                "Explica por que ρ²=0.5 reduz variância em exatamente 50%.",
                                "Cria tabela comparativa para 3 valores de ρ mostrando proporcionalidade.",
                                "Interpreta gráfico de redução vs. ρ corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação (100% correta).",
                                "Correção numérica em exemplos (erro <1%).",
                                "Profundidade de substeps (mínimo 4 por step).",
                                "Clareza na demonstração da proporcionalidade quadrática.",
                                "Validação prática via simulação.",
                                "Interpretação qualitativa precisa do impacto de ρ."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Regressão linear e coeficiente de determinação R²=ρ².",
                                "Programação: Implementação em Python/R para simulações Monte Carlo.",
                                "Probabilidade: Propriedades de covariância e variância condicional.",
                                "Finanças Computacionais: Redução de variância em precificação de derivativos."
                              ],
                              "realWorldApplication": "Em simulações Monte Carlo para modelagem de risco financeiro (ex: Value-at-Risk), variáveis de controle reduzem tempo computacional de dias para horas ao cortar variância em até 90% com boa correlação, permitindo análises em tempo real para traders."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.3.3",
                        "name": "Seleção e Aplicação Prática de Variáveis de Controle",
                        "description": "Explora estratégias para selecionar variáveis auxiliares adequadas e implementá-las em simulações de sistemas discretos, com foco em validação.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.3.3.1",
                            "name": "Selecionar variáveis auxiliares correlacionadas",
                            "description": "Identificar candidatas a Y_aux em modelos de simulação, como tempos de ciclo ou contagens parciais, garantindo correlação negativa via análise preliminar de corridas de simulação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Variáveis Auxiliares Correlacionadas",
                                  "subSteps": [
                                    "Estude a definição de variáveis de controle em simulações discretas e seu papel na redução de variância.",
                                    "Revise exemplos clássicos de Y_aux, como tempos de ciclo em filas ou contagens parciais em processos de produção.",
                                    "Identifique condições ideais: correlação negativa forte (ρ < -0.5) com a variável de interesse Y.",
                                    "Discuta por que correlação negativa é crucial para o método de controle funcionar.",
                                    "Anote potenciais candidatas Y_aux para um modelo específico de simulação."
                                  ],
                                  "verification": "Resuma em um parágrafo os critérios para uma boa Y_aux e liste 3 exemplos hipotéticos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação sobre técnicas de redução de variância (ex: livro de Law & Kelton), notebook para anotações.",
                                  "tips": "Foquem em variáveis que sejam baratas de computar e conhecidas analiticamente.",
                                  "learningObjective": "Dominar os fundamentos teóricos de variáveis auxiliares correlacionadas.",
                                  "commonMistakes": "Confundir correlação positiva com negativa; ignorar viés na seleção."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar e Executar Corridas Preliminares de Simulação",
                                  "subSteps": [
                                    "Configure um modelo de simulação discreta simples (ex: fila M/M/1) com variável de interesse Y (ex: tempo médio no sistema).",
                                    "Defina candidatas Y_aux (ex: número de chegadas, tempo ocioso do servidor).",
                                    "Execute n=100-500 corridas independentes curtas, coletando pares (Y, Y_aux) para cada.",
                                    "Salve dados em formato tabular (CSV) com colunas para Y e cada Y_aux.",
                                    "Garanta sementes aleatórias diferentes para independência das corridas."
                                  ],
                                  "verification": "Confirme que o dataset tem pelo menos 100 observações por par (Y, Y_aux) sem valores ausentes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de simulação (ex: SimPy em Python, Arena), ambiente de programação (Jupyter Notebook).",
                                  "tips": "Use corridas curtas para agilizar; replique o modelo para consistência.",
                                  "learningObjective": "Gerar dados empíricos confiáveis para análise de correlação.",
                                  "commonMistakes": "Corridas muito curtas levando a variância alta; reutilizar sementes iguais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Correlações e Identificar Candidatas",
                                  "subSteps": [
                                    "Calcule o coeficiente de correlação de Pearson (ρ) para cada par (Y, Y_aux) usando função pronta (ex: pandas.corr()).",
                                    "Visualize com scatter plots e histogramas de ρ para identificar padrões.",
                                    "Filtre candidatas com ρ < -0.5 e teste significância (p-value < 0.05).",
                                    "Compare múltiplas Y_aux e ranqueie pela magnitude |ρ| e facilidade de computação.",
                                    "Documente razões para descartar candidatas (ex: ρ fraca ou positiva)."
                                  ],
                                  "verification": "Produza um relatório com tabela de ρ, p-values e gráficos selecionando top 1-2 Y_aux.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Bibliotecas Python (pandas, matplotlib, scipy.stats), dataset das corridas.",
                                  "tips": "Use log(Y) se distribuições forem assimétricas para melhor linearidade.",
                                  "learningObjective": "Aplicar análise estatística para quantificar correlações negativas.",
                                  "commonMistakes": "Ignorar não-linearidades; usar Spearman sem justificativa."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar Seleção e Planejar Aplicação",
                                  "subSteps": [
                                    "Execute 10 corridas adicionais longas com a Y_aux selecionada para confirmar estabilidade de ρ.",
                                    "Estime o ganho de variância (redução % = 1 - (1-ρ²)) para justificar escolha.",
                                    "Planeje integração no método de controle: E[Y_aux] conhecido analiticamente?",
                                    "Teste sensibilidade variando parâmetros do modelo.",
                                    "Escreva um procedimento padrão para futuras simulações."
                                  ],
                                  "verification": "Demonstre redução de variância >20% em simulação de validação comparativa.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Mesmo software de simulação, scripts de análise atualizados.",
                                  "tips": "Sempre valide com corridas independentes para evitar overfitting.",
                                  "learningObjective": "Garantir robustez da Y_aux selecionada na prática.",
                                  "commonMistakes": "Assumir estabilidade sem validação; negligenciar custo computacional."
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila M/M/1 (λ=4, μ=5), Y = tempo médio no sistema. Candidata Y_aux = tempo ocioso do servidor por unidade de tempo. Corridas preliminares mostram ρ ≈ -0.7. Aplicar controle reduz variância de Y em 49%.",
                              "finalVerifications": [
                                "Coeficiente ρ < -0.5 com p-value < 0.05 confirmado em múltiplas corridas.",
                                "Y_aux selecionada é computacionalmente eficiente e E[Y_aux] conhecido.",
                                "Gráficos scatter mostram linearidade clara.",
                                "Relatório documenta pelo menos 3 candidatas analisadas com justificativas.",
                                "Teste de validação mostra ganho de variância quantificado.",
                                "Procedimento escrito para replicação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de correlação negativa (ρ calculado corretamente).",
                                "Qualidade dos dados: ≥100 corridas independentes sem erros.",
                                "Análise estatística rigorosa (p-values, visualizações).",
                                "Justificativa clara para seleção final de Y_aux.",
                                "Demonstração prática de redução de variância.",
                                "Documentação completa e organizada."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Cálculo de correlações e testes de hipótese.",
                                "Programação: Implementação de simulações em Python/SimPy.",
                                "Probabilidade: Modelos estocásticos e variância.",
                                "Engenharia Industrial: Otimização de sistemas de filas."
                              ],
                              "realWorldApplication": "Em logística, selecionar tempo ocioso de máquinas como Y_aux para estimar throughput com menor variância, acelerando decisões em planejamento de produção e reduzindo custos de simulação em fábricas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.1"
                            ]
                          },
                          {
                            "id": "10.1.7.3.3.2",
                            "name": "Implementar em software de simulação",
                            "description": "Desenvolver código em linguagens como Arena ou pseudocódigo para coletar X e Y_aux, estimar β empiricamente e ajustar a saída, referenciando Kelton e Law (1991).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de simulação e modelo básico",
                                  "subSteps": [
                                    "Instalar ou acessar o software Arena ou preparar ambiente para pseudocódigo (ex: Python com SimPy).",
                                    "Definir o sistema discreto a simular (ex: fila M/M/1 com chegada Poisson e serviço exponencial).",
                                    "Implementar a lógica básica do modelo: chegadas, processamento e saídas.",
                                    "Executar simulação preliminar para coletar estatísticas iniciais de X (ex: tempo médio na fila).",
                                    "Identificar uma variável auxiliar Y_aux correlacionada negativamente com X (ex: número de clientes no sistema)."
                                  ],
                                  "verification": "Modelo roda sem erros e produz saídas iniciais para X; visualize relatórios ou logs.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": "Software Arena ou Python/SimPy; referência Kelton e Law (1991), Capítulo 11.",
                                  "tips": "Comece com modelo simples para depuração rápida; use seeds fixos para reprodutibilidade.",
                                  "learningObjective": "Entender configuração inicial de simulações discretas para técnicas de variância.",
                                  "commonMistakes": "Ignorar distribuições corretas de chegada/serviço; não fixar seeds para réplicas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar coleta de dados para X e Y_aux",
                                  "subSteps": [
                                    "Adicionar variáveis de estado para rastrear X (ex: soma de tempos na fila) e Y_aux (ex: soma de ocupação do sistema).",
                                    "Inserir pontos de coleta em eventos chave: chegada, saída, fim de réplica.",
                                    "Configurar contadores para múltiplas réplicas independentes (ex: 30-50 runs).",
                                    "Armazenar pares (X_i, Y_aux_i) por réplica em array ou arquivo CSV.",
                                    "Testar coleta com poucas réplicas e inspecionar dados para correlação visual."
                                  ],
                                  "verification": "Dados coletados mostram correlação negativa entre X e Y_aux (plot scatterplot).",
                                  "estimatedTime": "1 hora",
                                  "materials": "Arena modules (Variables, Record); Python lists/DataFrames; Excel para inspeção.",
                                  "tips": "Colete em réplicas curtas primeiro para validar; normalize unidades se necessário.",
                                  "learningObjective": "Capturar dados correlacionados para redução de variância via controle.",
                                  "commonMistakes": "Coleta em pontos errados levando a viés; não resetar contadores entre réplicas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estimar β empiricamente via regressão linear",
                                  "subSteps": [
                                    "Executar N réplicas (ex: 50) para obter pares (X_i, Y_aux_i).",
                                    "Calcular β como cov(X, Y_aux) / var(Y_aux) usando fórmulas ou função de regressão.",
                                    "Implementar em pseudocódigo ou Arena expression: β = sum((X_i - meanX)(Y_aux_i - meanY_aux)) / sum((Y_aux_i - meanY_aux)^2).",
                                    "Validar β < 0 para correlação negativa esperada.",
                                    "Armazenar β para uso posterior e plotar linha de regressão."
                                  ],
                                  "verification": "Valor de β é negativo e plausível (ex: -0.5 a -2); R^2 > 0.3 indica boa correlação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Fórmulas de regressão de Kelton e Law; Python numpy/scipy ou Excel.",
                                  "tips": "Use pelo menos 30 réplicas para estimativa estável; teste com dados sintéticos.",
                                  "learningObjective": "Aplicar regressão para estimar coeficiente de controle em simulação.",
                                  "commonMistakes": "Confundir numerator/denominador na fórmula; usar poucas réplicas levando a β instável."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ajustar a saída da simulação usando variável de controle",
                                  "subSteps": [
                                    "Modificar estimativa de X_bar_adj = X_bar - β (Y_aux_bar - μ_Y_aux).",
                                    "Implementar no código: após réplicas, calcular médias e aplicar ajuste.",
                                    "Executar simulações com e sem controle para comparar variâncias.",
                                    "Calcular redução de variância: (1 - Var_adj / Var_original) * 100%.",
                                    "Documentar código com comentários referenciando Kelton e Law."
                                  ],
                                  "verification": "Variância ajustada é menor que original; redução > 20%.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Código anterior; funções de variância (np.var).",
                                  "tips": "Automatize em loop para múltiplas seeds; compare ICs (intervalos de confiança).",
                                  "learningObjective": "Implementar ajuste final para redução prática de variância.",
                                  "commonMistakes": "Sinal errado no ajuste (deve subtrair se β<0); não comparar variâncias corretamente."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e otimizar a implementação",
                                  "subSteps": [
                                    "Executar simulações longas (ex: 100 réplicas) com/sem controle.",
                                    "Comparar intervalos de confiança e tempos de CPU.",
                                    "Testar sensibilidade variando Y_aux ou N réplicas.",
                                    "Refatorar código para reutilização em outros modelos.",
                                    "Preparar relatório com gráficos de variância reduzida."
                                  ],
                                  "verification": "Relatório mostra redução consistente de variância e ICs mais estreitos.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": "Gráficos (matplotlib); relatório template.",
                                  "tips": "Salve seeds para reprodutibilidade; considere stratified sampling como extensão.",
                                  "learningObjective": "Avaliar eficácia da técnica de controle em cenários reais.",
                                  "commonMistakes": "Overfitting β com poucas réplicas; ignorar custo computacional."
                                }
                              ],
                              "practicalExample": "Em uma simulação de call center (fila M/M/5), X = tempo médio de espera, Y_aux = fração de tempo ocioso dos atendentes. Colete 50 réplicas de 1000 chamadas cada, estime β ≈ -1.2, ajuste X_bar reduzindo variância em 35%, permitindo decisões mais precisas sobre número de atendentes.",
                              "finalVerifications": [
                                "Código roda sem erros e produz X_bar_adj com variância reduzida.",
                                "β é negativo e correlação R^2 > 0.2.",
                                "Comparação mostra redução de variância > 15%.",
                                "Intervalos de confiança ajustados são mais estreitos.",
                                "Referência a Kelton e Law está no código/relatório.",
                                "Implementação é modular e reutilizável."
                              ],
                              "assessmentCriteria": [
                                "Precisão na coleta de X e Y_aux (sem viés).",
                                "Correta implementação da fórmula de β (erro < 5%).",
                                "Demonstração quantitativa de redução de variância.",
                                "Qualidade do código: comentado, eficiente e reproduzível.",
                                "Validação com múltiplas réplicas e sensibilidade.",
                                "Integração correta de conceitos teóricos da referência."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Regressão linear e análise de variância.",
                                "Programação: Estruturas de dados, loops e funções em simulação.",
                                "Engenharia Industrial: Otimização de filas e sistemas de produção.",
                                "Matemática Aplicada: Processos estocásticos e Monte Carlo."
                              ],
                              "realWorldApplication": "Em logística de manufatura, simulações com controle reduzem tempo de calibração de modelos de supply chain, permitindo otimizar estoques com maior confiança estatística, economizando milhões em decisões de investimento."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.2"
                            ]
                          },
                          {
                            "id": "10.1.7.3.3.3",
                            "name": "Avaliar efetividade da redução",
                            "description": "Medir o ganho de redução de variância comparando intervalos de confiança antes e após o controle, e discutir limitações como dependência de múltiplas corridas independentes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Executar simulações baseline sem variável de controle",
                                  "subSteps": [
                                    "Implemente o modelo de simulação discreta sem controle (ex: Monte Carlo para estimar média de um sistema).",
                                    "Execute múltiplas corridas independentes (n ≥ 1000) para coletar amostras.",
                                    "Calcule a média amostral e a variância inicial das estimativas.",
                                    "Construa o intervalo de confiança (IC) de 95% usando t-Student ou normal.",
                                    "Registre os resultados em uma tabela ou planilha."
                                  ],
                                  "verification": "Verifique se o IC foi calculado corretamente comparando com fórmula padrão e se n é suficiente para convergência.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python (NumPy, SciPy), Jupyter Notebook, modelo de simulação discreta (ex: código Monte Carlo).",
                                  "tips": "Use seeds aleatórias fixas para reprodutibilidade entre corridas.",
                                  "learningObjective": "Compreender a variância natural em simulações sem redução.",
                                  "commonMistakes": "Usar poucas corridas (n < 500), ignorando viés de amostragem."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar e executar simulações com variável de controle",
                                  "subSteps": [
                                    "Selecione e implemente uma variável de controle correlacionada (ex: variável auxiliar com variância conhecida).",
                                    "Ajuste as estimativas usando a fórmula de controle: Y_adj = Y - b*(X - μ_X), onde b é covariância.",
                                    "Execute o mesmo número de corridas independentes com o controle ativado.",
                                    "Calcule média ajustada, variância reduzida e novo IC de 95%.",
                                    "Compare comprimentos iniciais dos ICs."
                                  ],
                                  "verification": "Confirme redução na variância comparando Var(Y_adj) < Var(Y) via teste estatístico (ex: F-test).",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python (NumPy, SciPy para covariância), mesmo notebook do Step 1.",
                                  "tips": "Escolha controle com alta correlação (|ρ| > 0.5) para ganho ótimo.",
                                  "learningObjective": "Aplicar corretamente a correção pela variável de controle.",
                                  "commonMistakes": "Calcular b incorretamente (usar correlação ao invés de regressão), não normalizar X."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar intervalos de confiança e quantificar ganho de redução",
                                  "subSteps": [
                                    "Calcule o comprimento do IC baseline (upper - lower) e com controle.",
                                    "Compute o ganho percentual: (1 - length_IC_control / length_IC_baseline) * 100%.",
                                    "Visualize com gráficos: histogramas de estimativas e barras de ICs lado a lado.",
                                    "Teste significância da redução (ex: bootstrap para variâncias).",
                                    "Documente o ganho em relatório curto."
                                  ],
                                  "verification": "Ganho > 10% indica efetividade; valide plots com eixos corretos e legendas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Matplotlib/Seaborn para plots, Pandas para tabelas.",
                                  "tips": "Use bootstrap (1000 resamples) para ICs robustos em amostras pequenas.",
                                  "learningObjective": "Quantificar objetivamente a efetividade da redução de variância.",
                                  "commonMistakes": "Comparar médias ao invés de larguras de IC, ignorar assimetria nos ICs."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir limitações e sensibilidade da redução",
                                  "subSteps": [
                                    "Analise dependência em múltiplas corridas independentes (ex: custo computacional).",
                                    "Teste sensibilidade variando n e força da correlação do controle.",
                                    "Identifique cenários onde controle falha (ex: baixa correlação, não-estacionariedade).",
                                    "Discuta trade-offs: ganho vs. overhead de computar controle.",
                                    "Escreva parágrafo resumindo limitações."
                                  ],
                                  "verification": "Relatório cobre pelo menos 3 limitações com evidências dos experimentos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Notebook para testes adicionais, documento Markdown/Word.",
                                  "tips": "Rode experimentos com n reduzido para mostrar colapso da redução.",
                                  "learningObjective": "Criticar realisticamente as técnicas de redução de variância.",
                                  "commonMistakes": "Superestimar ganhos sem testar variações, ignorar custo computacional."
                                }
                              ],
                              "practicalExample": "Em simulação Monte Carlo para estimar π (hit-miss em círculo unitário), use Y = indicador de hit como estimativa, e X = distância ao centro como controle (E[X]=0.5 conhecido). Sem controle: IC ~0.02 largo; com controle: reduz para ~0.01, ganho de 50%.",
                              "finalVerifications": [
                                "IC com controle é estatisticamente menor (teste F ou Levene p<0.05).",
                                "Ganho quantificado corretamente com fórmula percentual.",
                                "Gráficos mostram sobreposição reduzida de estimativas.",
                                "Relatório discute ≥3 limitações com evidências.",
                                "Resultados reproduzíveis com seeds fornecidas.",
                                "Código comentado e modular."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de IC e variância (erro <5%).",
                                "Quantificação clara do ganho de redução (>20% em exemplo padrão).",
                                "Análise de limitações abrangente e baseada em dados.",
                                "Visualizações profissionais e interpretáveis.",
                                "Código eficiente e documentado.",
                                "Relatório lógico com conclusões justificadas."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Intervalos de confiança, testes de variância.",
                                "Programação: Implementação numérica eficiente em Python.",
                                "Probabilidade: Correlação e dependência em processos estocásticos.",
                                "Análise de Dados: Visualização e bootstrap para inferência."
                              ],
                              "realWorldApplication": "Em finanças, avaliar risco de portfólios via simulações Monte Carlo; redução de variância acelera precisão em Value-at-Risk (VaR), permitindo decisões rápidas em trading de alta frequência."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.3.2"
                            ]
                          },
                          {
                            "id": "10.1.7.3.3.4",
                            "name": "Analisar exemplos de sistemas discretos",
                            "description": "Aplicar o método a um exemplo clássico, como fila M/M/1, usando tempo total no sistema como X e número de chegadas como Y_aux, calculando redução prática.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o modelo de fila M/M/1",
                                  "subSteps": [
                                    "Estude as propriedades do modelo M/M/1: chegadas Poisson com taxa λ, tempos de serviço exponenciais com taxa μ > λ, buffer infinito e um servidor.",
                                    "Selecione parâmetros realistas, como λ = 4 clientes/hora e μ = 5 serviços/hora (ρ = 0.8), para garantir estabilidade.",
                                    "Defina o número de réplicas de simulação N = 10.000 para boa precisão estatística.",
                                    "Implemente geradores de variáveis aleatórias para interarrivos (exponencial λ) e serviços (exponencial μ).",
                                    "Crie uma função para simular o tempo total no sistema W para um cliente selecionado."
                                  ],
                                  "verification": "Parâmetros λ, μ definidos com ρ < 1; função de simulação testada com pelo menos 10 runs manuais produzindo trajetórias coerentes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python com bibliotecas numpy e scipy para distribuições exponenciais",
                                    "Editor de código (Jupyter Notebook recomendado)",
                                    "Documentação de teoria de filas M/M/1"
                                  ],
                                  "tips": "Fixe a semente aleatória (np.random.seed(42)) para reprodutibilidade durante testes iniciais.",
                                  "learningObjective": "Parametrizar corretamente um sistema de fila M/M/1 e preparar simulações Monte Carlo.",
                                  "commonMistakes": [
                                    "Escolher μ ≤ λ causando instabilidade",
                                    "Confundir taxa de chegada λ com taxa de serviço μ",
                                    "Simular poucos runs levando a variância alta"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e caracterizar as variáveis X e Y_aux",
                                  "subSteps": [
                                    "Defina X como o tempo total no sistema W de um cliente aleatório (espera + serviço).",
                                    "Defina Y_aux como o número de chegadas durante o intervalo W do cliente focal (excluindo sua própria chegada).",
                                    "Calcule E[Y_aux] ≈ λ * E[W] usando propriedades do processo de Poisson homogêneo.",
                                    "Verifique a correlação negativa esperada entre X e Y_aux, pois mais chegadas sugerem menor W em sistemas estáveis.",
                                    "Prepare fórmula analítica para E[X] = 1/(μ - λ) em M/M/1 para validação."
                                  ],
                                  "verification": "Definições de X e Y_aux documentadas; E[Y_aux] calculado corretamente e comparado com valor teórico.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de cálculos ou Python para expressões simbólicas (sympy)",
                                    "Referência teórica de filas M/M/1"
                                  ],
                                  "tips": "Lembre-se: Y_aux conta chegadas no intervalo (0, W], usando processo de Poisson com taxa λ.",
                                  "learningObjective": "Identificar e justificar variáveis de controle adequadas para redução de variância em simulações.",
                                  "commonMistakes": [
                                    "Incluir a chegada do cliente focal em Y_aux",
                                    "Ignorar o viés de tempo na contagem de chegadas",
                                    "Assumir independência entre X e Y_aux"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar simulações sem e com variável de controle",
                                  "subSteps": [
                                    "Simule N réplicas de X sem controle e calcule média \bar{X}, variância amostral Var(X).",
                                    "Para cada réplica, compute Y_aux simultaneamente e estime E[Y_aux] empiricamente.",
                                    "Aplique o estimador controlado: \bar{X}_c = \bar{X} - b (\bar{Y_aux} - E[Y_aux]), com b = Cov(X, Y_aux)/Var(Y_aux).",
                                    "Calcule Cov(X, Y_aux) e Var(Y_aux) das simulações pareadas.",
                                    "Compare Var(\bar{X}_c) com Var(\bar{X}) para quantificar redução."
                                  ],
                                  "verification": "Scripts executados produzindo \bar{X}, Var(\bar{X}), \bar{X}_c, Var(\bar{X}_c); redução de variância > 10%.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Código Python completo com loops de simulação",
                                    "Gráficos de scatter plot X vs Y_aux para visualizar correlação"
                                  ],
                                  "tips": "Use vetores numpy para eficiência em N grande; otimize com vetorização.",
                                  "learningObjective": "Implementar simulações pareadas e estimador de variável de controle.",
                                  "commonMistakes": [
                                    "Calcular covariância incorretamente (use np.cov)",
                                    "Escolher b errado (não maximizar redução)",
                                    "Usar E[Y_aux] empírico em vez de teórico"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e quantificar a redução de variância",
                                  "subSteps": [
                                    "Calcule o coeficiente de redução de variância: 1 - Var(\bar{X}_c)/Var(\bar{X}).",
                                    "Teste sensibilidade variando ρ (ex: 0.5, 0.8, 0.9) e observe impacto.",
                                    "Valide resultados contra teoria: correlação esperada ρ_{X,Y} ≈ -√(ρ(2-ρ)).",
                                    "Gere relatório com tabelas de médias, variâncias e gráficos de redução.",
                                    "Discuta limitações, como suposição de E[Y_aux] conhecido."
                                  ],
                                  "verification": "Relatório com cálculos numéricos mostrando redução prática (ex: 15-30%); validação teórica coerente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Planilha Excel ou pandas para tabelas",
                                    "Biblioteca matplotlib para plots"
                                  ],
                                  "tips": "Automatize sensibilidade com loop sobre ρ para insights rápidos.",
                                  "learningObjective": "Interpretar resultados de redução de variância e validar contra teoria.",
                                  "commonMistakes": [
                                    "Ignorar intervalos de confiança nas variâncias",
                                    "Sobreestimar redução com N pequeno",
                                    "Não comparar com benchmark teórico"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma fila M/M/1 com λ=4/h e μ=5/h, simule 10.000 clientes. Sem controle: \bar{W} ≈ 4h, Var(\bar{W}) ≈ 0.02. Com Y_aux (chegadas durante W): Corr ≈ -0.7, redução de variância ≈ 25%, Var(\bar{W}_c) ≈ 0.015, permitindo estimativas mais precisas com menos runs.",
                              "finalVerifications": [
                                "X definido como tempo total W e Y_aux como chegadas durante W, com E[Y_aux] = λ E[W] correto.",
                                "Simulações produzem correlação negativa Cov(X, Y_aux) < 0.",
                                "Estimador controlado implementado com b otimizado.",
                                "Redução de variância quantificada >10% em pelo menos um cenário.",
                                "Resultados validados contra fórmulas analíticas M/M/1.",
                                "Código reprodutível com semente fixa."
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração do modelo M/M/1 (ρ <1, distribuições corretas): 20%",
                                "Correta definição e cálculo de E[Y_aux] e covariância: 25%",
                                "Implementação correta do estimador controlado e redução >15%: 25%",
                                "Análise sensível e validação teórica: 15%",
                                "Clareza do relatório com gráficos e tabelas: 10%",
                                "Eficiência computacional e reprodutibilidade: 5%"
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: Cálculo de covariâncias e processos de Poisson.",
                                "Programação Computacional: Simulações Monte Carlo em Python.",
                                "Teoria de Filas: Modelos M/M/1 e métricas de desempenho.",
                                "Otimização: Técnicas de redução de variância em simulações.",
                                "Análise de Dados: Interpretação de variâncias e plots de correlação."
                              ],
                              "realWorldApplication": "Em call centers ou hospitais, simular tempos de espera com redução de variância permite dimensionar servidores com menos simulações custosas, otimizando recursos computacionais e decisões de alocação de pessoal."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.4",
                    "name": "Amostragem Estratificada",
                    "description": "Divide o espaço amostral em estratos disjuntos e amostra proporcionalmente de cada um, garantindo representação equilibrada e menor variância.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.4.1",
                        "name": "Princípios Básicos da Amostragem Estratificada",
                        "description": "Compreensão dos fundamentos que definem a divisão do espaço amostral em estratos disjuntos e a importância da representação equilibrada.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.4.1.1",
                            "name": "Identificar estratos disjuntos no espaço amostral",
                            "description": "Reconhecer e definir subconjuntos mutuamente exclusivos e exaustivos do espaço amostral para divisão em estratos, garantindo cobertura completa sem sobreposições.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Espaço Amostral em Amostragem Estratificada",
                                  "subSteps": [
                                    "Defina o espaço amostral como o conjunto completo de todos os resultados possíveis de um experimento ou processo estocástico.",
                                    "Identifique exemplos simples de espaços amostrais, como o lançamento de um dado (1 a 6) ou seleção de itens de uma população finita.",
                                    "Explique por que o espaço amostral deve ser bem definido antes de qualquer estratificação.",
                                    "Discuta a importância da estratificação para reduzir variância em simulações discretas.",
                                    "Liste propriedades básicas: finito ou infinito, discreto ou contínuo."
                                  ],
                                  "verification": "Crie um diagrama do espaço amostral para um exemplo dado e confirme que inclui todos os outcomes possíveis.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Acesso a um software de simulação como Python (opcional)"
                                  ],
                                  "tips": "Comece com espaços amostrais pequenos e familiares para construir intuição.",
                                  "learningObjective": "Entender o espaço amostral como base para divisão em estratos.",
                                  "commonMistakes": [
                                    "Confundir espaço amostral com população alvo",
                                    "Ignorar outcomes improváveis mas possíveis"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Estratos Mutuamente Exclusivos (Disjuntos)",
                                  "subSteps": [
                                    "Defina disjuntos: dois conjuntos A e B são disjuntos se sua interseção A ∩ B = ∅.",
                                    "Estenda para múltiplos estratos: nenhum par de estratos deve ter elementos em comum.",
                                    "Use notação matemática: para estratos S1, S2, ..., Sk, Si ∩ Sj = ∅ para i ≠ j.",
                                    "Verifique disjuntividade em um exemplo: pares e ímpares em lançamentos de dado.",
                                    "Pratique identificando violações: se um outcome aparece em dois estratos."
                                  ],
                                  "verification": "Divida um espaço amostral simples em 3 estratos e prove que são disjuntos usando interseções vazias.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de exercícios com espaços amostrais",
                                    "Calculadora para contagens"
                                  ],
                                  "tips": "Visualize com diagramas de Venn para múltiplos conjuntos.",
                                  "learningObjective": "Reconhecer e garantir ausência de sobreposições entre estratos.",
                                  "commonMistakes": [
                                    "Permitir sobreposições sutis em categorias ambíguas",
                                    "Confundir disjunto com não-vazio"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Garantir que os Estratos sejam Exaustivos",
                                  "subSteps": [
                                    "Defina exaustivo: a união de todos os estratos cobre o espaço amostral inteiro, ∪ Si = Ω.",
                                    "Verifique cobertura: todo elemento do espaço amostral pertence a exatamente um estrato.",
                                    "Use equações: soma das probabilidades dos estratos deve ser 1, Σ P(Si) = 1.",
                                    "Identifique falhas: elementos órfãos não alocados a nenhum estrato.",
                                    "Ajuste estratos para cobrir lacunas identificadas."
                                  ],
                                  "verification": "Para um espaço amostral dado, liste todos os elementos e confirme alocação em estratos com união total.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Lista de espaços amostrais de exemplo",
                                    "Planilha para rastrear uniões"
                                  ],
                                  "tips": "Conte elementos em cada estrato e some para igualar o total do espaço.",
                                  "learningObjective": "Assegurar cobertura completa do espaço amostral pelos estratos.",
                                  "commonMistakes": [
                                    "Deixar categorias residuais indefinidas",
                                    "Duplicar cobertura acidentalmente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação e Definição de Estratos Completos",
                                  "subSteps": [
                                    "Escolha um espaço amostral complexo, como resultados de dois dados.",
                                    "Proponha estratos baseados em critérios relevantes (ex: soma par/ímpar, valores altos/baixos).",
                                    "Verifique disjuntividade e exaustividade matematicamente.",
                                    "Refine estratos para otimizar redução de variância.",
                                    "Documente a divisão final com justificativa."
                                  ],
                                  "verification": "Apresente uma divisão estratificada para revisão, comprovando disjuntividade e exaustividade.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de simulação (R ou Python para validar)",
                                    "Exemplos de cenários reais"
                                  ],
                                  "tips": "Comece com critérios binários e evolua para multicategoriais.",
                                  "learningObjective": "Aplicar conceitos para identificar estratos válidos em contextos práticos.",
                                  "commonMistakes": [
                                    "Escolher estratos irrelevantes que não reduzem variância",
                                    "Ignorar balanceamento de tamanhos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de lançamento de um dado justo (espaço amostral Ω = {1,2,3,4,5,6}), defina estratos: S1 = {1,3,5} (ímpares), S2 = {2,4,6} (pares). Verifique: S1 ∩ S2 = ∅ (disjuntos) e S1 ∪ S2 = Ω (exaustivos). Isso garante amostragem estratificada sem sobreposições e cobertura total.",
                              "finalVerifications": [
                                "Divida corretamente um espaço amostral dado em estratos disjuntos e exaustivos.",
                                "Prove disjuntividade mostrando interseções vazias para todos pares de estratos.",
                                "Confirme exaustividade listando todos elementos cobertos na união.",
                                "Identifique e corrija uma divisão inválida com sobreposições ou lacunas.",
                                "Explique como essa divisão reduz variância em uma simulação.",
                                "Aplique em um exemplo computacional simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de disjuntividade e exaustividade (matemática correta).",
                                "Capacidade de identificar violações em exemplos dados.",
                                "Criatividade e relevância na escolha de critérios de estratificação.",
                                "Clareza na documentação e verificações.",
                                "Integração com redução de variância em amostragem estratificada.",
                                "Eficiência na divisão (estrato equilibrados quando possível)."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade: Cálculo de probabilidades condicionais dentro de estratos.",
                                "Estatística: Redução de variância e estimativas mais precisas.",
                                "Programação: Implementação de amostragem estratificada em Python/R.",
                                "Ciência de Dados: Aplicação em datasets desbalanceados.",
                                "Lógica Matemática: Propriedades de conjuntos e uniões/interseções."
                              ],
                              "realWorldApplication": "Em pesquisas eleitorais, estratificar eleitores por idade (18-30, 31-50, 51+) garante amostras representativas sem sobreposições, reduzindo viés e variância nos resultados de simulações de votação."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.1.2",
                            "name": "Explicar o conceito de amostragem proporcional",
                            "description": "Descrever como determinar o tamanho da amostra em cada estrato proporcionalmente à sua representatividade no universo populacional, visando equilíbrio.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de População e Estratos",
                                  "subSteps": [
                                    "Defina população como o conjunto total de elementos de interesse.",
                                    "Explique estratos como subgrupos homogêneos dentro da população.",
                                    "Identifique o tamanho total da população (N) e o tamanho de cada estrato (N_h).",
                                    "Discuta por que a amostragem estratificada melhora a precisão em relação à aleatória simples.",
                                    "Calcule a proporção de cada estrato na população total (w_h = N_h / N)."
                                  ],
                                  "verification": "Liste corretamente os tamanhos da população e estratos e calcule as proporções w_h com precisão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, calculadora, tabela de exemplo com dados populacionais.",
                                  "tips": "Use uma população familiar, como alunos de uma escola, para visualizar os estratos.",
                                  "learningObjective": "Entender a estrutura da população estratificada e calcular pesos proporcionais.",
                                  "commonMistakes": "Confundir estrato com cluster; ignorar que estratos devem ser mutuamente exclusivos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o Conceito de Amostragem Proporcional",
                                  "subSteps": [
                                    "Descreva amostragem proporcional como alocação de amostras onde n_h = n * (N_h / N).",
                                    "Compare com amostragem não proporcional (ex: igual por estrato).",
                                    "Explique o objetivo: manter a representatividade relativa dos estratos na amostra.",
                                    "Discuta benefícios: reduz viés e preserva proporções populacionais.",
                                    "Identifique cenários onde proporcionalidade é essencial para equilíbrio."
                                  ],
                                  "verification": "Explique em suas palavras a diferença entre proporcional e não proporcional, com um exemplo simples.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Quadro branco ou software de desenho para diagramas de população vs. amostra.",
                                  "tips": "Desenhe pizza charts para visualizar proporções antes e depois da amostragem.",
                                  "learningObjective": "Diferenciar amostragem proporcional de outras alocações e justificar seu uso.",
                                  "commonMistakes": "Achar que proporcional significa amostra igual em todos estratos; ignorar o fator de equilíbrio."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aprender a Fórmula e Calcular Tamanhos de Amostra",
                                  "subSteps": [
                                    "Memorize a fórmula: n_h = n * w_h, onde n é o tamanho total da amostra.",
                                    "Arredonde n_h para números inteiros usando métodos como maior resto.",
                                    "Pratique cálculo passo a passo: some N_h para N, calcule w_h, multiplique por n.",
                                    "Verifique se soma dos n_h equals n.",
                                    "Ajuste para casos onde arredondamento causa discrepância."
                                  ],
                                  "verification": "Calcule n_h para 3 estratos dados N=1000, n=100, e confirme soma exata.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora científica, planilha Excel ou Google Sheets para cálculos.",
                                  "tips": "Sempre verifique a soma final dos n_h para garantir conservação do tamanho total.",
                                  "learningObjective": "Aplicar a fórmula de alocação proporcional com precisão matemática.",
                                  "commonMistakes": "Erro de arredondamento sem ajuste; dividir errado w_h = N / N_h em vez de N_h / N."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Validar em um Cenário Prático",
                                  "subSteps": [
                                    "Selecione um dataset real ou simulado com estratos.",
                                    "Calcule amostras proporcionais e compare com amostragem simples.",
                                    "Analise impacto na representatividade (ex: variância reduzida).",
                                    "Discuta limitações: assume variância similar entre estratos.",
                                    "Simule seleção aleatória dentro de cada estrato."
                                  ],
                                  "verification": "Produza uma tabela de alocação proporcional e explique por que é equilibrada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Dataset exemplo (ex: CSV de população), software R ou Python para simulação opcional.",
                                  "tips": "Use funções como sample() em R para demonstrar seleção intra-estrato.",
                                  "learningObjective": "Integrar cálculo proporcional em um fluxo completo de amostragem.",
                                  "commonMistakes": "Selecionar amostras sem aleatoriedade dentro do estrato; ignorar validação da soma."
                                }
                              ],
                              "practicalExample": "Em uma pesquisa eleitoral com população de 10.000 eleitores: 60% jovens (6.000), 30% adultos (3.000), 10% idosos (1.000). Para n=200, calcule: jovens n=120, adultos=60, idosos=20. Isso garante que a amostra reflita as proporções reais, evitando viés para grupos maiores.",
                              "finalVerifications": [
                                "Calcula corretamente w_h e n_h para estratos dados.",
                                "Explica verbalmente o propósito do equilíbrio proporcional.",
                                "Identifica quando usar proporcional vs. ótimo (ex: variâncias desiguais).",
                                "Produz tabela de alocação sem erros de soma.",
                                "Compara variância simulada com amostragem simples.",
                                "Ajusta arredondamentos adequadamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos (90%+ correto).",
                                "Clareza na explicação conceitual (uso de termos corretos).",
                                "Capacidade de aplicar em exemplo novo.",
                                "Identificação de erros comuns e soluções.",
                                "Demonstração de benefícios via comparação.",
                                "Uso adequado de visualizações ou tabelas."
                              ],
                              "crossCurricularConnections": [
                                "Estatística Descritiva: Cálculo de proporções e pesos.",
                                "Programação Computacional: Implementação em Python/R para simulações de Monte Carlo.",
                                "Pesquisa Social: Design de surveys e questionários.",
                                "Probabilidade: Conceitos de viés e variância em distribuições."
                              ],
                              "realWorldApplication": "Em controle de qualidade industrial, amostragem proporcional estratificada por turnos de fábrica garante que defeitos sejam detectados proporcionalmente à produção de cada turno, otimizando eficiência e precisão em auditorias."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.1.3",
                            "name": "Comparar com amostragem aleatória simples",
                            "description": "Analisar as diferenças entre amostragem estratificada e aleatória simples, destacando a garantia de representação em subgrupos heterogêneos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de Amostragem Aleatória Simples (SRS)",
                                  "subSteps": [
                                    "Defina SRS como seleção de amostra onde cada unidade da população tem igual probabilidade de ser escolhida.",
                                    "Explique o processo: gerar números aleatórios e selecionar unidades correspondentes.",
                                    "Discuta variância: em populações heterogêneas, SRS pode sub-representar subgrupos.",
                                    "Calcule probabilidade de seleção para uma população de tamanho N e amostra n.",
                                    "Identifique quando SRS é adequada: populações homogêneas ou sem subgrupos críticos."
                                  ],
                                  "verification": "Resuma em 3 frases o que é SRS e sua limitação em heterogeneidade; confira com definição padrão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro-texto de estatística, calculadora, planilha Excel para simulação básica.",
                                  "tips": "Use analogia de sorteio de bilhetes para visualizar igualdade de chances.",
                                  "learningObjective": "Compreender os fundamentos e limitações da SRS em populações heterogêneas.",
                                  "commonMistakes": "Confundir SRS com amostragem sistemática; ignorar impacto da heterogeneidade na variância."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Amostragem Estratificada",
                                  "subSteps": [
                                    "Defina estratificação: dividir população em subgrupos homogêneos (estratos) baseados em característica relevante.",
                                    "Descreva processo: calcular tamanho proporcional por estrato, aplicar SRS dentro de cada estrato.",
                                    "Explique garantia de representação: cada estrato é amostrado proporcionalmente.",
                                    "Compare variância: redução em estimativas por maior precisão em subgrupos.",
                                    "Discuta requisitos: conhecimento prévio da população para definir estratos."
                                  ],
                                  "verification": "Desenhe diagrama de estratos em uma população heterogênea e liste proporções de amostragem.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel e caneta para diagramas, software R ou Python para exemplo simples.",
                                  "tips": "Pense em estratos como 'fatias' de uma pizza heterogênea para garantir cada sabor.",
                                  "learningObjective": "Dominar o mecanismo da amostragem estratificada e sua garantia de representação.",
                                  "commonMistakes": "Definir estratos muito amplos ou irrelevantes; esquecer proporcionalidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Diferenças Chave Entre SRS e Estratificada",
                                  "subSteps": [
                                    "Liste diferenças: SRS ignora subgrupos vs. estratificada garante representação.",
                                    "Compare variância: estratificada reduz variância em populações heterogêneas.",
                                    "Analise viés: ambos não viesados, mas estratificada mais precisa para subgrupos.",
                                    "Discuta custo: estratificada requer mais planejamento vs. SRS simples.",
                                    "Crie tabela comparativa com colunas: método, representação, variância, uso ideal."
                                  ],
                                  "verification": "Preencha tabela comparativa e explique uma diferença com exemplo numérico.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha Excel ou Google Sheets para tabela, exemplos de dados populacionais.",
                                  "tips": "Use métricas como desvio padrão de estimativas para quantificar diferenças.",
                                  "learningObjective": "Mapear diferenças qualitativas e quantitativas entre os métodos.",
                                  "commonMistakes": "Afirmar que estratificada elimina viés (apenas reduz variância); ignorar custos adicionais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Impacto na Representação de Subgrupos Heterogêneos",
                                  "subSteps": [
                                    "Simule cenário: população com 60% grupo A (homogêneo), 40% grupo B (heterogêneo).",
                                    "Amostre com SRS: calcule chance de sub-representação em B.",
                                    "Amostre estratificada: mostre representação garantida em B.",
                                    "Calcule redução de variância: use fórmula V(estr) < V(SRS) para médias.",
                                    "Conclua vantagens: melhor para simulações precisas em sistemas discretos."
                                  ],
                                  "verification": "Execute simulação em software e compare histogramas de estimativas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Python (bibliotecas numpy, matplotlib) ou R para simulação Monte Carlo.",
                                  "tips": "Repita simulação 1000x para ver estabilidade; foque em subgrupos <20%.",
                                  "learningObjective": "Demonstrar superioridade da estratificada via análise quantitativa.",
                                  "commonMistakes": "Usar população homogênea na simulação (anula vantagens); erros em proporções."
                                }
                              ],
                              "practicalExample": "Em uma pesquisa escolar com 1000 alunos (60% urbanos, 40% rurais), use SRS: possível amostra com só 10% rurais, distorcendo resultados. Com estratificada, garanta 40 rurais, representando fielmente opiniões rurais sobre educação remota.",
                              "finalVerifications": [
                                "Liste 4 diferenças principais entre SRS e estratificada.",
                                "Explique com números por que estratificada reduz variância em heterogeneidade.",
                                "Crie diagrama comparando representação em subgrupos.",
                                "Simule 2 cenários e compare precisão das estimativas.",
                                "Identifique 2 cenários onde SRS é preferível.",
                                "Descreva erro comum em cada método."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de ambos métodos (90%+ correção).",
                                "Clareza na tabela comparativa com pelo menos 5 diferenças.",
                                "Correção matemática em cálculos de variância e proporções.",
                                "Profundidade na análise de representação em subgrupos heterogêneos.",
                                "Qualidade da simulação prática com visualizações.",
                                "Uso correto de terminologia estatística."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar simulações em Python/R para Monte Carlo.",
                                "Ciência de Dados: Aplicar em machine learning para validação cruzada estratificada.",
                                "Estatística Inferencial: Ligar à redução de erro padrão em estimativas.",
                                "Pesquisa Social: Usar em surveys para equidade demográfica."
                              ],
                              "realWorldApplication": "Em eleições, amostragem estratificada por região/idade garante polls precisos, evitando erros como sub-representar jovens; em controle de qualidade fabril, estratifica por turnos para detectar defeitos específicos."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.4.1.2",
                        "name": "Procedimentos de Implementação",
                        "description": "Passos práticos para aplicar a técnica em simulações de sistemas discretos, incluindo seleção e geração de amostras.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.4.1.2.1",
                            "name": "Definir critérios para formação de estratos",
                            "description": "Estabelecer critérios baseados em variáveis de estratificação relevantes, como tempo de espera ou tipos de eventos em simulações discretas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Amostragem Estratificada",
                                  "subSteps": [
                                    "Estude a definição de amostragem estratificada e seu propósito em reduzir variância.",
                                    "Revise fórmulas chave: variância total, variância dentro de estratos e ganho de eficiência.",
                                    "Analise exemplos simples de estratificação em simulações discretas, como filas M/M/1.",
                                    "Identifique quando estratificar é superior à amostragem aleatória simples."
                                  ],
                                  "verification": "Resuma em 3 frases os benefícios da estratificação e liste 2 condições para seu uso eficaz.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Simulation' de Sheldon Ross (capítulo sobre variância reduction)",
                                    "Notas de aula sobre simulações discretas",
                                    "Calculadora ou planilha Excel"
                                  ],
                                  "tips": "Foquem em entender o trade-off entre número de estratos e custo computacional.",
                                  "learningObjective": "Compreender os princípios teóricos da amostragem estratificada em simulações.",
                                  "commonMistakes": [
                                    "Confundir estratificação com cluster sampling",
                                    "Ignorar o custo de implementação na prática"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Variáveis Relevantes no Sistema de Simulação",
                                  "subSteps": [
                                    "Mapeie o sistema de simulação: liste eventos, estados e variáveis de saída chave (ex: tempo de espera, throughput).",
                                    "Colete dados preliminares de uma simulação piloto para analisar distribuições.",
                                    "Avalie variabilidade: calcule coeficiente de variação para cada variável candidata.",
                                    "Priorize variáveis com alta variância e relevância para o objetivo da simulação."
                                  ],
                                  "verification": "Crie uma tabela com 5 variáveis candidatas, sua variância e justificativa de relevância.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software de simulação (Python com SimPy ou Arena)",
                                    "Dados de simulação piloto (CSV)",
                                    "Ferramentas de análise: Pandas e Matplotlib"
                                  ],
                                  "tips": "Use histogramas para visualizar distribuições multimodais, sinal de boa estratificação.",
                                  "learningObjective": "Selecionar variáveis de estratificação que maximizem redução de variância.",
                                  "commonMistakes": [
                                    "Escolher variáveis irrelevantes para o output de interesse",
                                    "Subestimar correlação entre variáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Critérios Específicos para Formação de Estratos",
                                  "subSteps": [
                                    "Defina limites dos estratos baseados em quantis (ex: 25%, 50%, 75%) ou thresholds lógicos.",
                                    "Garanta homogeneidade dentro de estratos e heterogeneidade entre eles.",
                                    "Calcule tamanhos de amostra proporcional ou ótimo por estratos usando fórmula de Neyman.",
                                    "Documente critérios em termos claros e implementáveis (ex: tempo de espera <10min = estrato 1)."
                                  ],
                                  "verification": "Escreva uma especificação formal dos estratos com limites, proporções e justificativa estatística.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Fórmulas de alocação ótima (folha de cálculo)",
                                    "Artigo 'Variance Reduction Techniques in Simulation'"
                                  ],
                                  "tips": "Comece com 3-5 estratos; mais pode aumentar complexidade sem ganho proporcional.",
                                  "learningObjective": "Estabelecer critérios mensuráveis e otimizados para estratos.",
                                  "commonMistakes": [
                                    "Estratos desbalanceados levando a ineficiência",
                                    "Limites arbitrários sem base estatística"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Ajustar os Critérios Definidos",
                                  "subSteps": [
                                    "Execute simulações comparativas: estratificada vs. aleatória simples.",
                                    "Meça redução de variância e tempo de execução.",
                                    "Ajuste limites base em resultados (ex: fundir estratos com variância similar).",
                                    "Documente iterações e decisões finais."
                                  ],
                                  "verification": "Gere relatório com métricas: % redução de variância e confiança intervals comparados.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código de simulação reutilizável",
                                    "Ferramentas de benchmark: timeit em Python"
                                  ],
                                  "tips": "Use 95% IC para outputs chave; mire redução >20% de variância.",
                                  "learningObjective": "Refinar critérios para robustez em simulações discretas.",
                                  "commonMistakes": [
                                    "Não rodar réplicas suficientes para validar",
                                    "Ignorar overhead computacional da estratificação"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar e Planejar Implementação",
                                  "subSteps": [
                                    "Compile todos os critérios em um protocolo padronizado.",
                                    "Planeje integração no código de simulação (ex: gerador de amostras por estrato).",
                                    "Teste edge cases: eventos raros ou distribuições skewed.",
                                    "Prepare para revisão por pares."
                                  ],
                                  "verification": "Produza um documento de 1 página com critérios, validação e plano de uso.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Template de relatório LaTeX ou Markdown",
                                    "Repositório Git para versionamento"
                                  ],
                                  "tips": "Use pseudocódigo para critérios para facilitar implementação.",
                                  "learningObjective": "Garantir critérios acionáveis e reproduzíveis.",
                                  "commonMistakes": [
                                    "Falta de documentação clara",
                                    "Não considerar escalabilidade para simulações grandes"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de supermercado (M/M/c), identifique tempo de espera como variável chave. Defina estratos: curto (0-2min, 40% amostras), médio (2-10min, 35%), longo (>10min, 25%). Rode 1000 réplicas por estrato, reduzindo variância do tempo médio de espera em 30%.",
                              "finalVerifications": [
                                "Explica corretamente como critérios reduzem variância com exemplo numérico.",
                                "Lista 3 variáveis relevantes de um sistema dado e justifica escolhas.",
                                "Produz critérios com limites baseados em dados, não intuição.",
                                "Compara performance estratificada vs. simples em simulação real.",
                                "Documenta protocolo completo e reproduzível."
                              ],
                              "assessmentCriteria": [
                                "Relevância das variáveis escolhidas (alta variância e correlação com output).",
                                "Precisão matemática nos cálculos de alocação e limites.",
                                "Redução comprovada de variância (>15-20%).",
                                "Clareza e mensurabilidade dos critérios definidos.",
                                "Robustez em validação com dados simulados."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Cálculo de variância e alocação ótima (Neyman).",
                                "Programação: Implementação em linguagens de simulação (Python/SimPy).",
                                "Gestão de Operações: Otimização de processos em filas e logística.",
                                "Ciência de Dados: Análise exploratória e visualização de distribuições."
                              ],
                              "realWorldApplication": "Em simulações de tráfego urbano para otimizar semáforos (estratificar por horários de pico), ou em modelagem epidemiológica para prever surtos (estratificar por faixas etárias), reduzindo tempo de simulação e melhorando precisão de previsões em saúde pública e engenharia."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.7.4.1.2.2",
                            "name": "Calcular tamanhos de amostra por estrato",
                            "description": "Aplicar fórmula N_h = (N * n) / N_total, onde N_h é o tamanho do estrato h, N o tamanho total da população e n o tamanho da amostra total.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Coletar e Organizar Dados da População e Amostra",
                                  "subSteps": [
                                    "Identifique o tamanho total da população (N_total).",
                                    "Liste todos os estratos e seus tamanhos individuais (N_h para cada h).",
                                    "Verifique se a soma dos tamanhos dos estratos equals N_total.",
                                    "Defina o tamanho total da amostra desejada (n).",
                                    "Registre todos os valores em uma tabela ou planilha para referência."
                                  ],
                                  "verification": "Confirme que todos os dados estão corretamente listados e somam corretamente via soma manual ou calculadora.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Planilha (Excel/Google Sheets), calculadora, dados da população estratificada.",
                                  "tips": "Use uma tabela com colunas: Estrato, N_h, % do total.",
                                  "learningObjective": "Compreender a estrutura de dados necessária para amostragem estratificada.",
                                  "commonMistakes": "Confundir N_total com soma dos N_h ou usar dados inconsistentes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar a Fórmula Proporcional para Cada Estrato",
                                  "subSteps": [
                                    "Para cada estrato h, calcule N_h_amostra = (N_h * n) / N_total.",
                                    "Realize a multiplicação N_h * n primeiro para evitar erros de ordem.",
                                    "Divida o resultado por N_total usando divisão precisa.",
                                    "Anote o valor exato (decimal) para cada estrato.",
                                    "Calcule a proporção de cada estrato (N_h / N_total) como auxiliar."
                                  ],
                                  "verification": "Compare cálculos manuais com uma calculadora para consistência em pelo menos dois estratos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Calculadora científica, planilha com fórmulas = (N_h * n) / N_total.",
                                  "tips": "Calcule proporções primeiro para validar: soma das proporções deve ser 1.",
                                  "learningObjective": "Dominar a aplicação precisa da fórmula de alocação proporcional.",
                                  "commonMistakes": "Inverter N_h e N_total ou esquecer de multiplicar por n antes de dividir."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Arredondar Tamanhos de Amostra para Inteiros",
                                  "subSteps": [
                                    "Aplique arredondamento padrão (ex: arredondar para o inteiro mais próximo).",
                                    "Use método sistemático: arredondar .5 para cima, ou método de maior resíduo.",
                                    "Calcule os resíduos (parte fracionária) para ajustes.",
                                    "Ajuste um ou dois valores para compensar discrepâncias.",
                                    "Registre tanto valores decimais quanto inteiros finais."
                                  ],
                                  "verification": "Verifique se todos os N_h_amostra arredondados são inteiros positivos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Planilha com função ROUND(), lista de resíduos.",
                                  "tips": "Prefira arredondamento que minimize o erro total de alocação.",
                                  "learningObjective": "Aprender técnicas de arredondamento em contextos estatísticos.",
                                  "commonMistakes": "Arredondar independentemente sem verificar soma final igual a n."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Ajustar a Alocação Total",
                                  "subSteps": [
                                    "Some todos os N_h_amostra arredondados e compare com n.",
                                    "Se houver discrepância (ex: soma = n ±1), ajuste o estrato com maior resíduo.",
                                    "Recalcule proporções finais e compare com originais.",
                                    "Documente o processo de ajuste em notas.",
                                    "Teste com um pequeno subconjunto para validação cruzada."
                                  ],
                                  "verification": "Confirme que soma dos N_h_amostra = n exato e proporções preservadas (±1%).",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Planilha com função SUM(), notas de validação.",
                                  "tips": "Use validação automatizada em planilhas com fórmulas condicionais.",
                                  "learningObjective": "Garantir precisão e viabilidade prática da amostragem.",
                                  "commonMistakes": "Ignorar discrepâncias na soma, levando a amostras enviesadas."
                                }
                              ],
                              "practicalExample": "População total N_total=1000, estratos: Estrato A (N_A=400), B (300), C (300). Amostra total n=100. Cálculos: N_A= (400*100)/1000=40; N_B=30; N_C=30. Soma=100 (perfeito, sem ajustes).",
                              "finalVerifications": [
                                "Soma dos tamanhos de amostra por estrato equals n exato.",
                                "Proporções dos estratos na amostra aproximam as da população (±2%).",
                                "Todos os N_h_amostra são inteiros não-negativos.",
                                "Fórmula aplicada corretamente em todos os estratos.",
                                "Documentação completa com valores originais e finais.",
                                "Validação cruzada com cálculo manual em pelo menos 50% dos estratos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na aplicação da fórmula (erro <1%).",
                                "Correto tratamento de arredondamentos e ajustes.",
                                "Validação da soma total igual a n.",
                                "Clareza na documentação e tabela de resultados.",
                                "Identificação e correção de erros comuns.",
                                "Eficiência no tempo estimado total."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Integração com variância e redução de erro em amostragem.",
                                "Programação: Implementação em Python/R com loops para estratos.",
                                "Pesquisa Científica: Aplicação em surveys e experimentos controlados.",
                                "Gestão de Dados: Manipulação de datasets em Excel/SQL."
                              ],
                              "realWorldApplication": "Em pesquisas eleitorais, calcular amostras por região (estrato) para prever resultados com precisão; em controle de qualidade industrial, alocar inspeções por lote de produção proporcionalmente ao tamanho."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.4.1.1.2"
                            ]
                          },
                          {
                            "id": "10.1.7.4.1.2.3",
                            "name": "Implementar seleção aleatória dentro de estratos",
                            "description": "Gerar números aleatórios uniformes para selecionar observações independentes dentro de cada estrato usando geradores de simulação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir Estratos e Tamanhos de Amostra",
                                  "subSteps": [
                                    "Identifique as variáveis de estratificação no conjunto de dados (ex.: idade, região).",
                                    "Divida o dataset em estratos mutuamente exclusivos e exaustivos.",
                                    "Calcule o tamanho proporcional ou ótimo de amostra para cada estrato usando fórmulas como Neyman allocation.",
                                    "Armazene os índices ou dados de cada estrato em listas ou arrays separados.",
                                    "Verifique que a soma dos tamanhos de amostra equals o tamanho total desejado."
                                  ],
                                  "verification": "Confirme que estratos cobrem todo o dataset sem sobreposição e tamanhos somam corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Dataset de exemplo (CSV ou Pandas DataFrame)",
                                    "Biblioteca Pandas para manipulação de dados",
                                    "Editor de código (Jupyter Notebook recomendado)"
                                  ],
                                  "tips": "Use groupby no Pandas para estratificar rapidamente; visualize com histogramas para validar divisões.",
                                  "learningObjective": "Compreender e implementar a divisão de dados em estratos balanceados.",
                                  "commonMistakes": [
                                    "Ignorar sobreposições entre estratos",
                                    "Tamanhos de amostra desproporcionais sem justificativa",
                                    "Excluir observações fora de estratos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Gerador de Números Aleatórios Uniformes",
                                  "subSteps": [
                                    "Importe bibliotecas de geração aleatória (ex.: numpy.random ou random em Python).",
                                    "Defina semente (seed) para reprodutibilidade durante testes.",
                                    "Configure parâmetros para distribuição uniforme [0,1) ou inteiros no range do estrato.",
                                    "Crie uma função wrapper para gerar amostras aleatórias independentes.",
                                    "Teste o gerador isoladamente com prints para validar uniformidade."
                                  ],
                                  "verification": "Gere 1000 números e verifique histograma uniforme via plot.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "NumPy ou random module em Python",
                                    "Matplotlib para visualização",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Sempre use seed para debugging; prefira numpy para vetores eficientes.",
                                  "learningObjective": "Configurar geradores pseudo-aleatórios para simulações independentes.",
                                  "commonMistakes": [
                                    "Não definir seed levando a resultados irreprodutíveis",
                                    "Usar distribuição errada (ex.: normal em vez de uniforme)",
                                    "Gerar dependências correlacionadas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Seleção Aleatória por Estrato",
                                  "subSteps": [
                                    "Para cada estrato, gere índices aleatórios únicos no range do tamanho do estrato.",
                                    "Use funções como np.random.choice com replace=False para amostragem sem reposição.",
                                    "Selecione as observações correspondentes aos índices gerados.",
                                    "Armazene seleções em uma lista ou array por estrato.",
                                    "Repita o processo iterativamente para todos os estratos."
                                  ],
                                  "verification": "Verifique que número de seleções por estrato matches o tamanho planejado e sem duplicatas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "NumPy para random.choice",
                                    "Pandas para indexação",
                                    "Código dos passos anteriores"
                                  ],
                                  "tips": "Vetorize com loops sobre estratos para eficiência; use sets para checar unicidade.",
                                  "learningObjective": "Executar amostragem aleatória simples dentro de subgrupos estratificados.",
                                  "commonMistakes": [
                                    "Reposicionamento acidental (replace=True)",
                                    "Índices fora do range do estrato",
                                    "Misturar seleções entre estratos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Combinar Amostra e Validar Independência",
                                  "subSteps": [
                                    "Concatene todas as seleções estratificadas em um dataset final.",
                                    "Verifique representatividade comparando proporções estratais na amostra vs população.",
                                    "Teste independência com estatísticas como variância reduzida vs amostragem simples.",
                                    "Execute simulação múltipla para comparar variâncias.",
                                    "Documente o código em uma função reutilizável."
                                  ],
                                  "verification": "Amostra final tem proporções estratadas preservadas e variância menor que aleatória simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Pandas para concatenação",
                                    "SciPy para testes estatísticos",
                                    "Código completo"
                                  ],
                                  "tips": "Use pd.concat com ignore_index; compare com np.var para métricas.",
                                  "learningObjective": "Validar a implementação estratificada garantindo redução de variância.",
                                  "commonMistakes": [
                                    "Perder proporções ao concatenar",
                                    "Não testar múltiplas runs",
                                    "Confundir independência com estratificação"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma pesquisa eleitoral com 10000 eleitores estratificados por idade (18-30, 31-50, 51+), selecione 200 por estrato: divida dados, gere random.choice( tam_estratos[i], 200, replace=False) para cada, combine para amostra de 600 representativa.",
                              "finalVerifications": [
                                "Tamanhos de amostra por estrato correspondem ao planejado.",
                                "Nenhuma duplicata dentro de estratos.",
                                "Proporções estratadas na amostra ≈ população.",
                                "Código roda sem erros e é reprodutível com seed.",
                                "Variância da estimativa (ex.: média) < amostragem simples em simulações.",
                                "Função modular aceita novos datasets."
                              ],
                              "assessmentCriteria": [
                                "Precisão na divisão de estratos (sem vazamentos).",
                                "Uniformidade e independência dos geradores aleatórios.",
                                "Eficiência computacional (O(n) tempo).",
                                "Validação estatística de redução de variância.",
                                "Clareza e documentação do código.",
                                "Robustez a diferentes tamanhos de estratos."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Conceitos de variância e alocação ótima.",
                                "Programação: Loops, vetores e funções em Python/R.",
                                "Ciência de Dados: Pré-processamento e validação de amostras.",
                                "Probabilidade: Distribuições uniformes e independência."
                              ],
                              "realWorldApplication": "Em pesquisas de mercado (ex.: Nielsen estratifica por demografia), simulações Monte Carlo para finanças (reduzir variância em VaR), ou ensaios clínicos (estratificar por idade/sexo para equilíbrio)."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.4.1.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.4.1.3",
                        "name": "Benefícios e Análise de Variância",
                        "description": "Avaliação da redução de variância e condições para aplicação eficaz da técnica em experimentos de simulação.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.4.1.3.1",
                            "name": "Calcular a variância reduzida da estimativa",
                            "description": "Usar a fórmula Var(ȳ_st) = Σ (W_h² * σ_h² / n_h), onde W_h é o peso do estrato, σ_h² a variância interna e n_h o tamanho da amostra, comparando com variância simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e preparar os dados dos estratos",
                                  "subSteps": [
                                    "Liste todos os estratos da população e suas proporções relativas (N_h / N total).",
                                    "Registre o tamanho da amostra para cada estrato (n_h).",
                                    "Obtenha ou calcule a variância populacional interna de cada estrato (σ_h²).",
                                    "Confirme o tamanho total da amostra (∑ n_h) e da população (N).",
                                    "Organize os dados em uma tabela para facilitar os cálculos subsequentes."
                                  ],
                                  "verification": "Verifique se a tabela contém colunas para estrato, W_h, n_h, σ_h² e soma de W_h = 1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel ou planilha Excel, calculadora, dataset de exemplo com estratos.",
                                  "tips": "Use proporções decimais para W_h para evitar erros de arredondamento.",
                                  "learningObjective": "Compreender a estrutura de dados necessária para amostragem estratificada.",
                                  "commonMistakes": "Confundir proporções de população (W_h) com proporções de amostra; ignorar unidades consistentes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular os pesos dos estratos (W_h)",
                                  "subSteps": [
                                    "Para cada estrato h, calcule W_h = N_h / N, onde N_h é o tamanho do estrato e N o total da população.",
                                    "Arredonde W_h para 4 casas decimais.",
                                    "Some todos os W_h e confirme que a soma é igual a 1.",
                                    "Registre os valores em uma nova coluna da tabela.",
                                    "Valide com um exemplo simples: se dois estratos 50/50, W_h = 0.5 cada."
                                  ],
                                  "verification": "Soma de W_h deve ser exatamente 1.0.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora ou software como Excel/Python.",
                                  "tips": "Mantenha N_h e N em números inteiros grandes para simular populações reais.",
                                  "learningObjective": "Dominar o cálculo de pesos proporcionais na estratificação.",
                                  "commonMistakes": "Usar n_h em vez de N_h para pesos; erros de divisão por zero."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular os termos individuais W_h² * σ_h² / n_h",
                                  "subSteps": [
                                    "Para cada estrato, calcule W_h ao quadrado (W_h²).",
                                    "Multiplique W_h² por σ_h² (variância interna).",
                                    "Divida o resultado por n_h (tamanho da amostra no estrato).",
                                    "Registre cada termo em uma coluna separada da tabela.",
                                    "Verifique cálculos intermediários com uma calculadora passo a passo."
                                  ],
                                  "verification": "Cada termo deve ser positivo e decrescente com n_h maior.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Planilha com fórmulas automáticas, calculadora científica.",
                                  "tips": "Use funções de planilha como =W_h^2 * sigma_h^2 / n_h para automação.",
                                  "learningObjective": "Aplicar a fórmula componente por componente para variância estratificada.",
                                  "commonMistakes": "Esquecer o quadrado em W_h; confundir σ_h² com variância amostral."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Somar os termos para obter Var(ȳ_st) e calcular variância simples",
                                  "subSteps": [
                                    "Some todos os termos W_h² * σ_h² / n_h para obter Var(ȳ_st).",
                                    "Calcule a variância simples: Var(ȳ) = σ² / n_total, usando variância populacional média ponderada.",
                                    "Compare Var(ȳ_st) com Var(ȳ), calculando a redução percentual: (1 - Var(ȳ_st)/Var(ȳ)) * 100%.",
                                    "Interprete: redução >0 indica benefício da estratificação.",
                                    "Documente os resultados em um relatório curto."
                                  ],
                                  "verification": "Var(ȳ_st) < Var(ȳ) para estratificação eficaz; verifique soma exata.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Planilha final, gráfico comparativo opcional.",
                                  "tips": "Para variância simples, use σ² = ∑ W_h * σ_h² como aproximação populacional.",
                                  "learningObjective": "Comparar variâncias e quantificar redução de variância.",
                                  "commonMistakes": "Usar soma errada ou variância simples incorreta (ex: sem ponderação)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar e validar os resultados",
                                  "subSteps": [
                                    "Analise por que certos estratos contribuem mais para a variância.",
                                    "Simule um ajuste: aumente n_h em estratos de alta variância e recalcule.",
                                    "Discuta limitações: assume variâncias conhecidas a priori.",
                                    "Crie um gráfico de barras comparando variâncias.",
                                    "Resuma benefícios em uma frase conclusiva."
                                  ],
                                  "verification": "Relatório inclui interpretação qualitativa e quantitativa.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Software de gráficos como Excel ou Python (matplotlib).",
                                  "tips": "Foco em estratos heterogêneos para maximizar redução.",
                                  "learningObjective": "Interpretar análise de variância no contexto de simulações discretas.",
                                  "commonMistakes": "Ignorar que σ_h² deve ser conhecida ou estimada previamente."
                                }
                              ],
                              "practicalExample": "População de 1000 unidades em 3 estratos: Estrato 1 (N1=200, W1=0.2, σ1²=4, n1=20); Estrato 2 (N2=300, W2=0.3, σ2²=9, n2=30); Estrato 3 (N3=500, W3=0.5, σ3²=16, n3=50). Calcule Var(ȳ_st) = 0.2²*4/20 + 0.3²*9/30 + 0.5²*16/50 = 0.008 + 0.027 + 0.08 = 0.115. Variância simples: σ²≈10.3, n=100, Var(ȳ)=0.103. Redução: ~11.7%.",
                              "finalVerifications": [
                                "Fórmula Var(ȳ_st) aplicada corretamente com soma exata.",
                                "Pesos W_h somam 1.0.",
                                "Comparação com variância simples mostra redução positiva.",
                                "Todos os termos individuais positivos e coerentes.",
                                "Interpretação inclui impacto na precisão da estimativa.",
                                "Gráfico ou tabela visual confirma resultados."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de W_h, termos individuais e soma (erro <1%).",
                                "Correta identificação de componentes da fórmula.",
                                "Comparação quantitativa e qualitativa com variância simples.",
                                "Uso adequado de materiais e automação em planilhas.",
                                "Interpretação clara dos benefícios da estratificação.",
                                "Ausência de erros comuns como confusão de n_h e N_h."
                              ],
                              "crossCurricularConnections": [
                                "Estatística Descritiva: Cálculo de variâncias internas.",
                                "Programação Computacional: Implementação em Python/R para simulações Monte Carlo.",
                                "Probabilidade: Conceitos de variância em estimadores.",
                                "Análise de Dados: Aplicação em big data estratificado."
                              ],
                              "realWorldApplication": "Em simulações de sistemas discretos como filas de atendimento em call centers, estratificando por horários de pico para reduzir variância nas estimativas de tempo médio de espera, melhorando previsões para alocação de recursos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.4.1.2.2"
                            ]
                          },
                          {
                            "id": "10.1.7.4.1.3.2",
                            "name": "Identificar cenários ideais para aplicação",
                            "description": "Determinar quando usar em simulações com heterogeneidade populacional, como filas com diferentes prioridades ou tempos de serviço variáveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Heterogeneidade Populacional em Simulações",
                                  "subSteps": [
                                    "Defina heterogeneidade como variações significativas nas características da população simulada, como tempos de serviço ou prioridades diferentes.",
                                    "Identifique fontes comuns de heterogeneidade em sistemas discretos, como filas com clientes de alta e baixa prioridade.",
                                    "Analise o impacto da heterogeneidade na variância das estimativas de simulação sem estratificação.",
                                    "Compare distribuições homogêneas vs. heterogêneas usando histogramas conceituais.",
                                    "Discuta por que a variância alta torna a simulação ineficiente."
                                  ],
                                  "verification": "Crie um diagrama ilustrando heterogeneidade em uma fila simples e explique seu impacto na variância.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de simulação (ex: 'Simulation' de Ross), papel e caneta ou software de desenho como Draw.io.",
                                  "tips": "Use analogias cotidianas, como filas de supermercado expresso vs. normal, para visualizar heterogeneidade.",
                                  "learningObjective": "Reconhecer e quantificar heterogeneidade em populações simuladas.",
                                  "commonMistakes": "Confundir heterogeneidade com aleatoriedade simples; sempre verificar se há subgrupos distintos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar Princípios da Amostragem Estratificada",
                                  "subSteps": [
                                    "Explique como a amostragem estratificada divide a população em estratos homogêneos dentro de si.",
                                    "Descreva a alocação proporcional e ótima de amostras por estrato.",
                                    "Calcule a redução de variância teórica: Var_strat < Var_simples quando estratos têm variâncias internas baixas.",
                                    "Implemente um exemplo simples em pseudocódigo para amostragem estratificada.",
                                    "Compare com amostragem simples aleatória em termos de precisão."
                                  ],
                                  "verification": "Derive a fórmula de variância para amostragem estratificada e compare com a simples para um caso numérico.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Calculadora ou Python/Jupyter Notebook com bibliotecas numpy e matplotlib.",
                                  "tips": "Comece com 2 estratos para simplicidade antes de expandir.",
                                  "learningObjective": "Dominar os fundamentos matemáticos da amostragem estratificada.",
                                  "commonMistakes": "Ignorar a proporção dos estratos; sempre aloque amostras proporcionalmente ao tamanho do estrato."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Características de Cenários Ideais",
                                  "subSteps": [
                                    "Liste critérios: presença de subpopulações distintas com baixa variância interna e alta entre estratos.",
                                    "Avalie heterogeneidade usando testes como ANOVA ou inspeção visual de distribuições.",
                                    "Reconheça cenários como filas M/G/1 com prioridades ou tempos de serviço multimodais.",
                                    "Exclua cenários não ideais, como populações uniformemente distribuídas.",
                                    "Crie uma checklist para diagnóstico rápido de aplicabilidade."
                                  ],
                                  "verification": "Aplique a checklist a 3 cenários hipotéticos e justifique se estratificação é ideal.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Planilha Excel ou Google Sheets para checklists, exemplos de problemas de simulação.",
                                  "tips": "Priorize cenários onde a variância total é dominada por diferenças entre grupos.",
                                  "learningObjective": "Desenvolver critérios claros para detectar cenários ideais.",
                                  "commonMistakes": "Aplicar estratificação em populações homogêneas, aumentando custo sem ganho."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação em Exemplos Reais de Simulação",
                                  "subSteps": [
                                    "Analise um caso de fila de hospital com pacientes urgentes e rotineiros.",
                                    "Simule variância com e sem estratificação usando código simples.",
                                    "Identifique cenários ideais em tráfego urbano ou call centers.",
                                    "Discuta trade-offs: custo computacional vs. precisão ganha.",
                                    "Registre 5 cenários pessoais onde estratificação seria ideal."
                                  ],
                                  "verification": "Produza um relatório curto com 3 cenários identificados, incluindo justificativa e estimativa de redução de variância.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Python com simpy ou queueing-tool, dados sintéticos de filas.",
                                  "tips": "Use simulações Monte Carlo rápidas para validar intuições.",
                                  "learningObjective": "Aplicar conceitos para identificar cenários em contextos práticos.",
                                  "commonMistakes": "Superestimar benefícios sem dados; sempre valide com simulação."
                                }
                              ],
                              "practicalExample": "Em uma simulação de fila de call center com chamadas de alta prioridade (VIP, tempo médio 2 min) e baixa (padrão, 10 min), a heterogeneidade causa alta variância no tempo médio de espera. Estratificar por tipo de chamada reduz a variância em 60%, permitindo estimativas precisas com menos runs.",
                              "finalVerifications": [
                                "Corretamente identifica heterogeneidade em 4/5 cenários testados.",
                                "Explica redução de variância com fórmula ou exemplo numérico.",
                                "Lista pelo menos 3 cenários ideais com justificativa.",
                                "Distingue cenários ideais de não-ideais com precisão.",
                                "Propõe estratificação viável para um problema dado.",
                                "Valida com simulação simples mostrando ganho de eficiência."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção de heterogeneidade (peso 25%).",
                                "Compreensão matemática da redução de variância (peso 25%).",
                                "Relevância dos cenários identificados (peso 20%).",
                                "Qualidade da justificativa e exemplos (peso 15%).",
                                "Aplicação prática via simulação ou checklist (peso 15%)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Análise de variância (ANOVA) para validar estratos.",
                                "Programação: Implementação em Python/R para simulações Monte Carlo.",
                                "Gestão de Operações: Otimização de filas e serviços.",
                                "Probabilidade: Distribuições compostas em sistemas heterogêneos."
                              ],
                              "realWorldApplication": "Em modelagem de epidemias, estratificar por faixas etárias (alta/baixa suscetibilidade) reduz variância nas estimativas de R0, permitindo políticas de saúde mais precisas com menos poder computacional."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.1.3.3",
                            "name": "Avaliar ganho de precisão em simulações",
                            "description": "Interpretar o fator de redução de variância e estimar o número de réplicas necessárias para atingir precisão desejada em projetos de experimentos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos de Variância em Simulações de Monte Carlo",
                                  "subSteps": [
                                    "Explique a variância como medida de dispersão nos resultados de simulações.",
                                    "Discuta como a variância afeta a precisão das estimativas em simulações sem estratificação.",
                                    "Identifique a fórmula básica da variância de uma estimativa: Var(Ȳ) = σ² / n.",
                                    "Compare variância em amostragem simples vs. estratificada usando exemplos numéricos simples.",
                                    "Pratique calculando variância para um conjunto de dados simulados."
                                  ],
                                  "verification": "Calcule corretamente a variância para um dataset fornecido e explique sua interpretação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Calculadora ou planilha (Excel/Google Sheets), tutorial de simulação de Monte Carlo.",
                                  "tips": "Use dados pequenos inicialmente para visualizar o impacto da variância.",
                                  "learningObjective": "Compreender o papel da variância na precisão de simulações.",
                                  "commonMistakes": "Confundir variância com desvio padrão; ignorar o impacto do tamanho da amostra."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Interpretar o Fator de Redução de Variância na Amostragem Estratificada",
                                  "subSteps": [
                                    "Defina o fator de redução de variância (FRV) como FRV = 1 - (Var_estrat / Var_simples).",
                                    "Derive a fórmula do FRV para amostragem estratificada: envolve somas ponderadas de variâncias intra-estratos.",
                                    "Calcule FRV para estratos proporcionais e ótimos usando dados hipotéticos.",
                                    "Interprete valores de FRV: >0 indica ganho, quanto maior, melhor eficiência.",
                                    "Compare FRV com outras técnicas como importance sampling."
                                  ],
                                  "verification": "Compute FRV para um exemplo dado e interprete se há ganho de precisão (>10%).",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software Python (com NumPy/Pandas) ou R, fórmulas anotadas.",
                                  "tips": "Visualize com gráficos de variância antes/depois da estratificação.",
                                  "learningObjective": "Dominar a interpretação quantitativa do ganho de precisão via FRV.",
                                  "commonMistakes": "Usar pesos errados nos estratos; assumir FRV sempre positivo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estimar Número de Réplicas Necessárias para Precisão Desejada",
                                  "subSteps": [
                                    "Defina precisão desejada como intervalo de confiança ou erro padrão alvo (e.g., ε = 0.05).",
                                    "Use fórmula: n_estrat = (z * σ_estrat / ε)^2, ajustada pelo FRV.",
                                    "Calcule n_simples vs. n_estrat e compare economia de réplicas (n_simples / n_estrat).",
                                    "Ajuste para múltiplos estratos: n_h = n * (N_h / N) * (σ_h / σ_total).",
                                    "Simule para validar: rode com n estimado e cheque se ε é atingido."
                                  ],
                                  "verification": "Estime n para ε=0.05 em um cenário e confirme com simulação que o erro está dentro do alvo.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Python/R para simulações, calculadora científica.",
                                  "tips": "Comece com z=1.96 para 95% CI; itere se necessário.",
                                  "learningObjective": "Calcular réplicas otimizadas baseadas em FRV e precisão alvo.",
                                  "commonMistakes": "Esquecer fator z ou pesos estratificados; superestimar σ."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Validar em Projeto de Experimento Simulado",
                                  "subSteps": [
                                    "Escolha um sistema discreto (e.g., fila M/M/1) e defina estratos (e.g., por carga).",
                                    "Implemente simulação simples e estratificada, calculando FRV empiricamente.",
                                    "Estime n para precisão desejada e rode simulações comparativas.",
                                    "Analise resultados: plote ICs e discuta economia computacional.",
                                    "Documente relatório com FRV, n estimado vs. usado e conclusões."
                                  ],
                                  "verification": "Produza relatório mostrando redução de variância >20% e n otimizado.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Python (SimPy ou custom Monte Carlo), Jupyter Notebook.",
                                  "tips": "Use seed para reprodutibilidade; foque em 2-3 estratos iniciais.",
                                  "learningObjective": "Integrar FRV e estimativa de n em um projeto completo.",
                                  "commonMistakes": "Estratos mal definidos; não validar empiricamente."
                                }
                              ],
                              "practicalExample": "Em uma simulação de tempo médio de espera em uma fila de supermercado (sistema M/M/1 com λ=4, μ=5), estratifique por períodos de pico (alta carga) e baixo (baixa carga). Calcule FRV ≈ 0.35, reduzindo variância em 35%. Para precisão ε=0.1 no tempo médio, n_simples=1000, mas n_estrat=650, economizando 35% de réplicas.",
                              "finalVerifications": [
                                "Calcula FRV corretamente para dados estratificados fornecidos.",
                                "Estima n réplicas com erro <10% do valor ótimo.",
                                "Interpreta ganho de precisão em termos de economia computacional.",
                                "Valida estimativa com simulação real, atingindo ε desejada.",
                                "Explica limitações (e.g., custo de estratificação).",
                                "Compara com amostragem simples em relatório."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de FRV (90%+ acurácia).",
                                "Correção na fórmula de n réplicas (inclui FRV e ε).",
                                "Qualidade da interpretação qualitativa/quantitativa.",
                                "Eficiência demonstrada em simulação (redução variância >20%).",
                                "Clareza no relatório com gráficos e conclusões.",
                                "Identificação de erros comuns evitados.",
                                "Aplicação contextualizada ao projeto."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Inferência e intervalos de confiança.",
                                "Programação: Implementação de simulações em Python/R.",
                                "Engenharia de Sistemas: Otimização de experimentos em manufatura.",
                                "Ciência de Dados: Técnicas de redução de variância em ML.",
                                "Gestão de Projetos: Planejamento de recursos computacionais."
                              ],
                              "realWorldApplication": "Em simulações de risco financeiro (Monte Carlo para VaR), estratificar por cenários de mercado reduz réplicas de 10k para 6k, acelerando análises diárias em bancos; ou em manufatura, otimizar simulações de linhas de produção para precisão em tempos de ciclo com menos tempo de CPU."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.4.1.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.5",
                    "name": "Amostragem por Importância",
                    "description": "Modifica a distribuição de probabilidade de amostragem para concentrar amostras em regiões de alta contribuição, compensando com pesos adequados.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.5.1",
                        "name": "Princípio Fundamental da Amostragem por Importância",
                        "description": "Entende o conceito básico de modificar a distribuição de probabilidade de amostragem para concentrar esforços computacionais em regiões de alta contribuição à estimativa, compensando com pesos para manter a imparcialidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.5.1.1",
                            "name": "Identificar motivação para redução de variância",
                            "description": "Reconhecer situações em simulações discretas onde a variância é alta devido a eventos raros, e explicar como a amostragem por importância reduz a variância concentrando amostras em áreas críticas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de variância em estimativas de Monte Carlo",
                                  "subSteps": [
                                    "Defina variância como a medida de dispersão dos resultados de uma simulação em torno da média verdadeira.",
                                    "Explique que em métodos de Monte Carlo padrão, a variância é dada por Var(g(X))/N, onde N é o número de amostras.",
                                    "Discuta como alta variância leva a intervalos de confiança largos e estimativas imprecisas.",
                                    "Calcule a variância para uma simulação simples de lançamento de dados.",
                                    "Compare variância baixa vs. alta em exemplos gráficos."
                                  ],
                                  "verification": "Capacidade de calcular e interpretar a variância de uma estimativa Monte Carlo simples com precisão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora, software de simulação como Python (NumPy), planilha Excel.",
                                  "tips": "Use histogramas para visualizar a dispersão das amostras.",
                                  "learningObjective": "Entender matematicamente por que a variância afeta a confiabilidade das simulações.",
                                  "commonMistakes": "Confundir variância com desvio padrão ou ignorar o papel de N na redução."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar situações de alta variância em simulações discretas",
                                  "subSteps": [
                                    "Revise simulações discretas como cadeias de Markov ou processos de filas.",
                                    "Identifique eventos raros como transições improváveis ou falhas catastróficas.",
                                    "Simule um cenário com eventos raros, como probabilidade de ruína em um jogo de apostas.",
                                    "Meça a variância observando que poucas amostras capturam o evento raro.",
                                    "Registre o número de amostras necessárias para uma estimativa estável."
                                  ],
                                  "verification": "Produzir um gráfico mostrando alta variância em uma simulação com eventos raros.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python ou R para simulação, gráficos de convergência.",
                                  "tips": "Aumente o número de simulações até ver estabilização para quantificar o problema.",
                                  "learningObjective": "Reconhecer padrões onde eventos raros causam variância elevada.",
                                  "commonMistakes": "Subestimar a raridade do evento ou usar amostras insuficientes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o impacto de eventos raros na variância",
                                  "subSteps": [
                                    "Explique que eventos raros contribuem desproporcionalmente para a variância devido a payoffs altos.",
                                    "Derive qualitativamente por que Var ≈ p*(1-p)* (payoff)^2 para eventos raros Bernoulli.",
                                    "Compare com eventos comuns onde variância é mais equilibrada.",
                                    "Quantifique o problema: calcule quantas amostras são necessárias para precisão ε.",
                                    "Discuta limitações computacionais em simulações discretas reais."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito por que eventos raros inflacionam a variância.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Papel e lápis para derivações, simulador online de Monte Carlo.",
                                  "tips": "Pense em termos de 'caudas pesadas' na distribuição das estimativas.",
                                  "learningObjective": "Quantificar o problema da variância alta causado por raridade.",
                                  "commonMistakes": "Atribuir alta variância apenas a poucos amostras sem considerar raridade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar como a amostragem por importância reduz a variância",
                                  "subSteps": [
                                    "Defina amostragem por importância: amostrar de uma distribuição q(x) que enfatiza regiões críticas.",
                                    "Mostre a fórmula do estimador: média de g(x)/q(x) * p(x), com variância reduzida se q ≈ |g|p.",
                                    "Aplique a um exemplo: reamostrar eventos raros com maior probabilidade.",
                                    "Compare variâncias: demonstre redução em simulação paralela.",
                                    "Verifique unbiasedness: E[estimador] = integral verdadeira."
                                  ],
                                  "verification": "Implementar uma simulação comparativa mostrando redução de variância.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Código Python pronto para amostragem por importância, Jupyter Notebook.",
                                  "tips": "Escolha q como uma mistura que oversample regiões raras.",
                                  "learningObjective": "Compreender o mecanismo de concentração de amostras para redução de variância.",
                                  "commonMistakes": "Esquecer de reponderar com p(x)/q(x), levando a bias."
                                }
                              ],
                              "practicalExample": "Em uma simulação de risco financeiro para estimar a probabilidade de perda >90% em um portfólio (evento raro ~0.01), Monte Carlo padrão requer milhões de runs devido à alta variância. Com amostragem por importância, oversample cenários de crash de mercado, reduzindo runs para milhares com variância 10x menor.",
                              "finalVerifications": [
                                "Explicar corretamente por que eventos raros causam alta variância em simulações discretas.",
                                "Identificar um exemplo real de simulação com variância alta.",
                                "Descrever o mecanismo de concentração de amostras na amostragem por importância.",
                                "Comparar variâncias numéricamente em uma simulação simples.",
                                "Reconhecer quando aplicar redução de variância."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e cálculo de variância (80%+ correto).",
                                "Identificação correta de cenários de alta variância (exemplos relevantes).",
                                "Explicação clara e sem erros do papel da amostragem por importância.",
                                "Uso de evidências simuladas para suportar argumentos.",
                                "Conexão lógica entre problema e solução.",
                                "Clareza na comunicação (gráficos, fórmulas corretas)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Conceitos de variância e teorema do limite central.",
                                "Probabilidade: Distribuições com caudas pesadas e eventos raros.",
                                "Computação: Otimização de algoritmos de simulação em Python/R.",
                                "Finanças: Modelagem de risco como Value at Risk (VaR)."
                              ],
                              "realWorldApplication": "Na indústria farmacêutica, simular probabilidade rara de falha em testes clínicos; amostragem por importância acelera estimativas precisas, economizando tempo computacional em supercomputadores para aprovações regulatórias mais rápidas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.1.2",
                            "name": "Diferenciar de amostragem uniforme",
                            "description": "Comparar a amostragem por importância com métodos de Monte Carlo padrão, destacando a mudança na densidade de probabilidade p(x) para g(x) e a necessidade de correção por pesos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de Amostragem Uniforme em Monte Carlo",
                                  "subSteps": [
                                    "Defina amostragem uniforme: amostras x_i geradas de uma distribuição uniforme p(x) = 1 sobre o domínio.",
                                    "Explique a estimativa de Monte Carlo padrão: média de f(x_i)/p(x_i), mas como p(x) é uniforme, simplifica para média de f(x_i).",
                                    "Discuta limitações: variância alta quando f(x) varia muito em regiões de baixa probabilidade.",
                                    "Calcule variância para um exemplo simples, como integral de f(x) = x^2 em [0,1].",
                                    "Visualize com histograma de amostras uniformes."
                                  ],
                                  "verification": "Crie um gráfico mostrando distribuição uniforme e variância da estimativa.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e lápis ou software como Python (Matplotlib, NumPy)",
                                  "tips": "Comece com exemplos 1D para intuição visual.",
                                  "learningObjective": "Compreender como a amostragem uniforme distribui pontos igualmente, ignorando importância de f(x).",
                                  "commonMistakes": "Confundir p(x) com f(x); assumir que uniforme sempre é eficiente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Amostragem por Importância e Mudança de Densidade",
                                  "subSteps": [
                                    "Defina amostragem por importância: amostras de g(x) onde g(x) ≈ |f(x)| para reduzir variância.",
                                    "Compare p(x) uniforme vs. g(x) concentrada em regiões de alta contribuição de f(x).",
                                    "Escreva a fórmula da estimativa: média de [f(x_i)/g(x_i)] com pesos w_i = p(x_i)/g(x_i).",
                                    "Mostre graficamente: plote p(x), g(x) e f(x) no mesmo gráfico.",
                                    "Discuta escolha ideal de g(x): proporcional a |f(x) p(x)|."
                                  ],
                                  "verification": "Desenhe gráficos comparando p(x) e g(x) para uma f(x) não-uniforme.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de plotagem (Python/Jupyter ou papel)",
                                  "tips": "Use funções como f(x) = exp(-x^2) para mostrar concentração em x=0.",
                                  "learningObjective": "Identificar como g(x) altera a densidade para focar em áreas relevantes.",
                                  "commonMistakes": "Ignorar que g(x) deve ser não-zero onde f(x) p(x) ≠ 0."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar a Correção por Pesos w(x) = p(x)/g(x)",
                                  "subSteps": [
                                    "Derive por que pesos são necessários: para manter expectativa E[f(X)] invariante.",
                                    "Mostre prova: E_g [f(X)/g(X) * p(X)] = ∫ f(x) p(x) dx.",
                                    "Calcule pesos para exemplo: g(x) gaussiana vs. p(x) uniforme.",
                                    "Compare variância: Var_g [f/g * p] vs. Var_p [f/p].",
                                    "Simule numericamente pequena amostra para ilustrar redução de variância."
                                  ],
                                  "verification": "Implemente simulação simples mostrando menor variância com importância.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com NumPy/SciPy para simulação",
                                  "tips": "Use seeds fixas para reprodutibilidade em comparações.",
                                  "learningObjective": "Entender o papel dos pesos na correção da mudança de medida.",
                                  "commonMistakes": "Esquecer pesos, levando a viés; confundir w(x) com f(x)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar e Sintetizar Diferenças Chave",
                                  "subSteps": [
                                    "Liste prós/contras: uniforme simples mas ineficiente; importância eficiente mas requer boa g(x).",
                                    "Discuta condições para superioridade: quando f(x) tem picos.",
                                    "Analise impacto na taxa de convergência: O(1/sqrt(N)) mas constante menor.",
                                    "Crie tabela comparativa: fórmulas, variâncias, exemplos.",
                                    "Resolva exercício: adapte uniforme para importância em integral específica."
                                  ],
                                  "verification": "Preencha tabela comparativa e resolva exercício com cálculos corretos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha ou documento para tabela",
                                  "tips": "Foco em intuição: 'amostras onde importam, mas pese corretamente'.",
                                  "learningObjective": "Diferenciar claramente os dois métodos e suas implicações.",
                                  "commonMistakes": "Superestimar benefícios sem pesos adequados."
                                }
                              ],
                              "practicalExample": "Estime ∫_0^1 exp(-1/x) dx (integral com pico perto de 1). Uniforme: amostras espalhadas, alta variância. Importância: g(x) ~ exp(-1/x)/normalização, pesos p(x)/g(x)=constante, variância reduzida drasticamente em simulações.",
                              "finalVerifications": [
                                "Explique verbalmente diferença entre p(x) e g(x) sem hesitação.",
                                "Derive fórmula de pesos w(x) = p(x)/g(x) a partir de expectativa.",
                                "Simule e compare variâncias em código para exemplo dado.",
                                "Identifique quando importância falha (g(x) mal escolhida).",
                                "Crie gráfico ilustrando mudança de densidade.",
                                "Resolva novo problema adaptando método."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação matemática das fórmulas (100% correto).",
                                "Demonstração de redução de variância via simulação (>50% redução).",
                                "Clareza em gráficos comparando distribuições.",
                                "Correta identificação de erros comuns em pesos.",
                                "Aplicação conceitual a exemplo não visto.",
                                "Explicação fluida da invariância da expectativa."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Redução de variância em inferência bayesiana.",
                                "Programação: Implementação em bibliotecas como PyMC ou TensorFlow Probability.",
                                "Física: Simulações de Monte Carlo em mecânica quântica (path integrals).",
                                "Finanças: Precificação de opções com simulações de risco.",
                                "Machine Learning: Importance sampling em reinforcement learning."
                              ],
                              "realWorldApplication": "Em finanças quantitativas, usa-se amostragem por importância para estimar riscos raros em Value-at-Risk (VaR), onde uniforme falha em capturar caudas pesadas, permitindo simulações eficientes com poucos samples para decisões de bilhões em portfólios."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.1.3",
                            "name": "Reconhecer propriedades do estimador",
                            "description": "Verificar que o estimador da amostragem por importância é não viesado, com expectativa igual à integral original, apesar da mudança de distribuição.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o estimador padrão de Monte Carlo",
                                  "subSteps": [
                                    "Lembre-se da integral original I = ∫ f(x) p(x) dx = E_p[f(X)] onde X ~ p(x).",
                                    "Entenda o estimador MC: Î_MC = (1/N) Σ f(X_i) com X_i ~ p(x).",
                                    "Verifique que E[Î_MC] = I, provando que é não viesado.",
                                    "Discuta limitações quando p(x) é difícil de amostrar.",
                                    "Calcule variância básica do estimador MC."
                                  ],
                                  "verification": "Escreva a fórmula do estimador MC e prove sua não viés calculando E[Î_MC].",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Folha de papel, calculadora, notas de aula sobre Monte Carlo.",
                                  "tips": "Use notação probabilística clara: E_p para expectativa sob p.",
                                  "learningObjective": "Compreender o estimador baseline e sua propriedade de não viés.",
                                  "commonMistakes": "Confundir amostragem com a função f(x); esquecer que X_i ~ p(x)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a amostragem por importância",
                                  "subSteps": [
                                    "Defina uma distribuição alternativa q(x) fácil de amostrar, com q(x) > 0 onde f(x)p(x) > 0.",
                                    "Escreva o estimador de importância: Î_IS = (1/N) Σ [f(X_i) p(X_i)/q(X_i)] com X_i ~ q(x).",
                                    "Explique o peso w(X_i) = p(X_i)/q(X_i).",
                                    "Discuta por que isso permite amostrar de q em vez de p.",
                                    "Verifique suporte comum entre p e q."
                                  ],
                                  "verification": "Escreva a fórmula de Î_IS e identifique os componentes (f, w, distribuição de amostragem).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel, exemplos de funções p e q simples.",
                                  "tips": "Escolha q que aproxime f p para redução de variância futura.",
                                  "learningObjective": "Dominar a definição formal da amostragem por importância.",
                                  "commonMistakes": "Esquecer o peso w(X); inverter p/q."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a expectativa do estimador de importância",
                                  "subSteps": [
                                    "Compute E_q[Î_IS] = E_q[ (1/N) Σ f(X_i) w(X_i) ] = E_q[ f(X) w(X) ].",
                                    "Substitua w(X) = p(X)/q(X): E_q[ f(X) p(X)/q(X) ].",
                                    "Reconheça mudança de medida: ∫ f(x) p(x)/q(x) q(x) dx = ∫ f(x) p(x) dx = I.",
                                    "Conclua que E_q[Î_IS] = I.",
                                    "Escreva a prova integral explicitamente."
                                  ],
                                  "verification": "Derive passo a passo E[Î_IS] = I usando integrais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel para derivacão, software como Python/Jupyter para visualização opcional.",
                                  "tips": "Pense em termos de densidades: o q(x) cancela na integral.",
                                  "learningObjective": "Provar matematicamente a não viés do estimador IS.",
                                  "commonMistakes": "Não cancelar q(x) corretamente; confundir E_p e E_q."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar propriedades e implicações",
                                  "subSteps": [
                                    "Afirme que o estimador é não viesado independentemente de q (desde que suporte ok).",
                                    "Discuta consistência: convergência em probabilidade para I quando N→∞.",
                                    "Compare variâncias: Var(IS) pode ser menor que Var(MC) se q bem escolhida.",
                                    "Identifique condições: q absoluta contínua w.r.t. p, etc.",
                                    "Teste com exemplo numérico simples."
                                  ],
                                  "verification": "Explique verbalmente por que é não viesado apesar da mudança de distribuição.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Exemplo numérico em Python ou Excel.",
                                  "tips": "Simule N=1000 para ver E[Î_IS] ≈ I.",
                                  "learningObjective": "Reconhecer e justificar propriedades chave do estimador.",
                                  "commonMistakes": "Pensar que viés depende de q; ignorar suporte."
                                }
                              ],
                              "practicalExample": "Estime I = ∫_0^1 (x^2 / (1 + x)) dx usando MC padrão (p uniforme) vs IS com q concentrada onde integrando é maior. Amostre 1000 pontos de q(x) = 2x (Beta(2,1)), compute pesos e verifique médias próximas a I≈0.25.",
                              "finalVerifications": [
                                "Provar E[Î_IS] = I via cálculo de expectativa.",
                                "Identificar corretamente o papel do peso w(X) = p/q.",
                                "Explicar por que não viés apesar de amostrar de q ≠ p.",
                                "Simular numericamente e confirmar médias iguais.",
                                "Listar condições necessárias para validade (suporte, normalização).",
                                "Comparar com MC padrão em um exemplo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da expectativa (sem erros algébricos).",
                                "Compreensão conceitual da mudança de medida.",
                                "Correta identificação de não viés e consistência.",
                                "Uso apropriado de notação probabilística.",
                                "Aplicação em exemplo prático com resultados coerentes.",
                                "Explicação clara de implicações práticas."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade: Mudança de medida e teorema de Radon-Nikodym.",
                                "Estatística: Estimadores não viesados e redução de variância.",
                                "Computação: Implementação em simulações Monte Carlo (Python/R).",
                                "Física: Simulações de partículas em MCMC.",
                                "Finanças: Precificação de opções via IS."
                              ],
                              "realWorldApplication": "Em finanças quantitativas, usar IS para estimar riscos raros como Value-at-Risk em portfólios, amostrando cenários extremos de uma q otimizada, reduzindo tempo computacional sem introduzir viés."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.5.2",
                        "name": "Escolha da Distribuição de Importância",
                        "description": "Analisa critérios para selecionar uma distribuição de importância g(x) que minimize a variância do estimador, idealmente aproximando h(x)p(x)/g(x) constante.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.5.2.1",
                            "name": "Avaliar critérios de boa distribuição g(x)",
                            "description": "Determinar que g(x) deve ser positiva onde h(x)p(x) > 0, ter menor suporte que p(x) e minimizar Var[(h(X)p(X)/g(X))]/g(X).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar regiões onde h(x)p(x) > 0 e definir suporte de g(x)",
                                  "subSteps": [
                                    "Defina a função h(x) e a densidade p(x) do problema de integração ou expectativa.",
                                    "Calcule ou plote o produto h(x)p(x) e identifique o conjunto S = {x | h(x)p(x) > 0}.",
                                    "Verifique que g(x) > 0 para todo x em S, garantindo que amostras de g cubram contribuições relevantes.",
                                    "Confirme que o suporte de g(x) é menor ou igual ao de p(x) para evitar amostras desnecessárias.",
                                    "Discuta implicações: se g(x)=0 em parte de S, variância explode."
                                  ],
                                  "verification": "Plote p(x), h(x)p(x) e g(x); confirme sobreposição perfeita em S e suporte de g ⊆ suporte de p.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e lápis, software de plotagem (Python Matplotlib ou R), exemplos de funções teste",
                                  "tips": "Sempre visualize graficamente; use log-escala para caudas.",
                                  "learningObjective": "Compreender a necessidade de g(x) positiva em regiões contributivas para evitar viés e variância infinita.",
                                  "commonMistakes": "Assumir suporte de g maior que p(x), gerando amostras com peso zero; ignorar sinal de h(x)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender a fórmula de variância do estimador em Importance Sampling",
                                  "subSteps": [
                                    "Lembre que o estimador é média de Y_i = h(X_i) p(X_i)/g(X_i) com X_i ~ g(x).",
                                    "Escreva Var(estimador) = { Var[Y] } / n, onde Var[Y] = E[Y^2] - (E[Y])^2.",
                                    "Expresse Var[Y] = E[ (h p / g)^2 ] - (∫ h p)^2, com X~g.",
                                    "Identifique o termo Var[(h(X)p(X)/g(X))] / g(X) como métrica proxy para eficiência.",
                                    "Calcule para um exemplo simples para ver dependência em g."
                                  ],
                                  "verification": "Derive a fórmula de Var[Y] em um caso toy e compute numericamente para g=p vs g ótima.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Calculadora simbólica (SymPy ou Mathematica), caderno para derivações",
                                  "tips": "Normalize tudo para probabilidades; foque em E[(h p / g)^2] como chave para variância.",
                                  "learningObjective": "Derivar e interpretar a variância do estimador IS, ligando-a à escolha de g.",
                                  "commonMistakes": "Confundir Var[Y]/n com Var[Y]/g(X); esquecer que E[Y] = integral alvo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar critérios para minimizar a variância via escolha de g(x)",
                                  "subSteps": [
                                    "Liste critérios: (1) g>0 em S, (2) suporte ≤ p, (3) minimizar Var[(h p / g)] / g.",
                                    "Proponha g(x) ∝ |h(x) p(x)| como ideal (zero variância se exata).",
                                    "Compare métricas: compute ∫ (h p / g)^2 g dx para candidatos g.",
                                    "Ajuste g para aproximar ótima, balanceando simplicidade e performance.",
                                    "Teste sensibilidade: varie parâmetros de g e meça variância simulada."
                                  ],
                                  "verification": "Para duas g candidatas, compute métrica de variância e confirme qual minimiza.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Software de simulação (Python NumPy/SciPy), funções de teste definidas",
                                  "tips": "Use aproximações como misturas ou truncadas para g prática.",
                                  "learningObjective": "Aplicar critérios quantitativos para selecionar g que reduz variância efetivamente.",
                                  "commonMistakes": "Escolher g muito estreita, perdendo cobertura de S; ignorar normalização de g."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e sintetizar avaliação de g(x) em um problema completo",
                                  "subSteps": [
                                    "Escolha um problema real: estime ∫ h(x) p(x) dx via IS com g proposta.",
                                    "Simule N=10^4 amostras, compute estimador e variância amostral.",
                                    "Compare com MC vanilla (g=p): verifique redução de variância >50%.",
                                    "Ajuste g baseado em diagnóstico (plots de pesos w_i = p/g).",
                                    "Documente trade-offs: complexidade computacional vs ganho de variância."
                                  ],
                                  "verification": "Relatório com tabelas: variância IS vs vanilla, plots de histogramas de pesos uniformes.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Ambiente de programação (Jupyter Notebook), dados simulados",
                                  "tips": "Diagnostique pesos: se muito variáveis, g ruim; mire uniformidade.",
                                  "learningObjective": "Integrar todos critérios em avaliação prática de g para problemas de simulação.",
                                  "commonMistakes": "N pequeno levando a falsos positivos; não checar se E[Y] unbiased."
                                }
                              ],
                              "practicalExample": "Estime P(X > 3) para X ~ N(0,1) usando IS. p(x)=φ(x), h(x)=I(x>3). S=[3,∞). g ótima ~ N(3,1) truncada. Verifique g>0 em S, suporte ok, Var[Y] minimizada vs g=p (redução >90%). Simule: MC vanilla var~0.0013, IS var~10^-5.",
                              "finalVerifications": [
                                "Lista corretamente os 3 critérios principais para boa g(x).",
                                "Explica por que g>0 em {h p >0} previne variância infinita.",
                                "Computa Var[Y] para exemplo simples e identifica impacto de g.",
                                "Compara duas g e justifica a melhor por métrica de variância.",
                                "Gera simulação IS com redução de variância mensurável.",
                                "Identifica diagnóstico de pesos ruins em g inadequada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de S e suporte (0-4 pontos).",
                                "Correção na derivação e interpretação de Var[(h p / g)] (0-5 pontos).",
                                "Qualidade da minimização prática de variância via escolha g (0-5 pontos).",
                                "Validade da simulação e diagnósticos (plots/pesos) (0-4 pontos).",
                                "Síntese de trade-offs e critérios integrados (0-4 pontos).",
                                "Clareza e completude do relatório (0-3 pontos)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Redução de variância em inferência bayesiana MCMC.",
                                "Computação: Otimização numérica para ajuste de g.",
                                "Probabilidade: Teoria de medidas e mudança de medida.",
                                "Finanças: Simulações Monte Carlo para VaR e precificação.",
                                "Física: Simulação de partículas raras em colisões."
                              ],
                              "realWorldApplication": "Em finanças quantitativas, usar IS com g ótima para estimar riscos de cauda em portfólios (ex: Value-at-Risk 99.9%), reduzindo tempo computacional de dias para minutos em simulações de bilhões de cenários."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.7.5.2.2",
                            "name": "Aplicar heurísticas para seleção",
                            "description": "Usar heurísticas como distribuição cruzada ou aproximações para escolher g(x) em problemas de simulação de sistemas discretos com eventos raros.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos da Amostragem por Importância e a necessidade de heurísticas",
                                  "subSteps": [
                                    "Revisar a fórmula da estimativa de Monte Carlo com amostragem por importância: E[f(X)] ≈ (1/N) Σ [f(X_i) w(X_i)], onde w(X_i) = p(X_i)/g(X_i).",
                                    "Identificar desafios em eventos raros: variância alta quando p(x) tem caudas pesadas.",
                                    "Explicar por que escolher g(x) próxima de h(x) = f(x)p(x)/E[f(X)] reduz variância.",
                                    "Discutir limitações de conhecimento exato de h(x) em sistemas discretos complexos.",
                                    "Listar heurísticas comuns: distribuição cruzada e aproximações (ex.: tilting exponencial)."
                                  ],
                                  "verification": "Escrever um resumo de 200 palavras explicando o papel de g(x) e quando heurísticas são necessárias.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Notas de aula sobre simulação MC, livro 'Simulation' de Ross, Jupyter Notebook para anotações.",
                                  "tips": "Desenhe gráficos de p(x), g(x) e h(x) para visualizar a importância da proximidade.",
                                  "learningObjective": "Dominar os conceitos teóricos que justificam o uso de heurísticas para seleção de g(x).",
                                  "commonMistakes": "Confundir amostragem por importância com estratificação ou ignorar o peso w(x) na variância."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar e implementar a heurística da Distribuição Cruzada (Cross-Entropy)",
                                  "subSteps": [
                                    "Entender o método CE: minimizar D_KL(g || h) iterativamente via amostras de uma distribuição inicial.",
                                    "Implementar o algoritmo: (1) amostrar de g^{(0)}, (2) atualizar parâmetros de g via médias amostradas ponderadas por h(x)/g(x), (3) repetir até convergência.",
                                    "Aplicar em um toy problem discreto: estados de uma Markov chain com estado raro.",
                                    "Calcular variância antes/depois e plotar evolução da KL-divergência.",
                                    "Ajustar hiperparâmetros como elite fraction (tipicamente 0.1)."
                                  ],
                                  "verification": "Executar código que converge para g(x) com variância reduzida em pelo menos 50%.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Python com NumPy/SciPy, código template de CE method de repositórios GitHub (ex.: rare-event-simulation).",
                                  "tips": "Use log-probabilidades para evitar underflow em eventos raros.",
                                  "learningObjective": "Implementar autonomamente o método CE para otimizar g(x).",
                                  "commonMistakes": "Escolher elite fraction muito pequena (leva a overfitting) ou não normalizar pesos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar heurísticas de Aproximação para g(x)",
                                  "subSteps": [
                                    "Analisar aproximação por tilting exponencial: g(x) ∝ p(x) exp(θ f(x)), otimizando θ via maximização de likelihood.",
                                    "Estudar aproximações locais: usar gradientes ou Hessian de log h(x) em pontos de interesse.",
                                    "Comparar com CE: quando aproximações são mais rápidas (problemas de baixa dimensão).",
                                    "Implementar tilting em um exemplo discreto: simulação de binomial com sucesso raro.",
                                    "Avaliar trade-offs: simplicidade vs. precisão em sistemas discretos."
                                  ],
                                  "verification": "Comparar variâncias de CE vs. tilting em um benchmark simples, documentando resultados.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "SciPy.optimize para maximização, exemplos de código de 'Monte Carlo Statistical Methods' de Robert.",
                                  "tips": "Comece com θ pequeno e use gradiente numérico se analítico não for viável.",
                                  "learningObjective": "Selecionar e aplicar aproximações adequadas baseado no contexto do problema.",
                                  "commonMistakes": "Ignorar normalização de g(x) ou superestimar convergência sem checar variância efetiva."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar heurísticas em um problema de simulação de eventos raros e avaliar",
                                  "subSteps": [
                                    "Definir problema: simular probabilidade de fila > K em M/M/1 queue com ρ próximo de 1 (evento raro).",
                                    "Escolher heurística (CE ou tilting) baseada em dimensionalidade e computação.",
                                    "Implementar simulação full: MC vanilla vs. importância com g(x) heurística.",
                                    "Calcular intervalo de confiança e eficiência (variação * custo computacional).",
                                    "Refinar: testar múltiplas iterações e documentar escolha final."
                                  ],
                                  "verification": "Gerar relatório com plots de variância reduzida e IC estreito para P(fila > K).",
                                  "estimatedTime": "4 horas",
                                  "materials": "SimPy ou custom queue simulator em Python, perfis de tempo com %timeit.",
                                  "tips": "Monitore tempo de simulação; pare se eficiência > 10x MC vanilla.",
                                  "learningObjective": "Integrar heurísticas em fluxos de simulação reais e justificar escolhas.",
                                  "commonMistakes": "Não comparar com baseline ou usar g(x) não normalizada levando a bias."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar robustez e otimizar a seleção de heurísticas",
                                  "subSteps": [
                                    "Testar sensibilidade: variar parâmetros do problema e medir performance.",
                                    "Combinar heurísticas híbridas: CE inicial + tilting refinado.",
                                    "Analisar falhas: casos onde heurística falha (multimodal h(x)).",
                                    "Documentar guidelines para escolha: CE para alta dim, tilting para low dim.",
                                    "Preparar apresentação de 5 min explicando aplicação."
                                  ],
                                  "verification": "Criar tabela comparativa de 3 cenários com métricas de variância e tempo.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Pandas para tabelas, Matplotlib para plots comparativos.",
                                  "tips": "Use effective sample size ESS = (Σ w_i)^2 / Σ w_i^2 > 0.5 N como métrica.",
                                  "learningObjective": "Desenvolver critérios robustos para seleção heurística em contextos variados.",
                                  "commonMistakes": "Overfitting a um único problema sem generalização."
                                }
                              ],
                              "practicalExample": "Em uma simulação de sistema de filas M/M/1 com taxa de chegada λ=0.95 μ (ρ=0.95), estimar P(L > 20) ≈ 10^{-4} (evento raro). Usar CE para iterativamente ajustar g(x) ~ Gamma(α_k, β_k) baseada em estados com filas longas, reduzindo variância de 10^6 para 10^2 amostras.",
                              "finalVerifications": [
                                "Código roda sem erros e produz estimativas com IC < 10% do valor.",
                                "Variância reduzida em pelo menos 100x vs. MC vanilla.",
                                "g(x) converge (KL < 0.01) em <10 iterações.",
                                "Effective sample size > 50% das amostras.",
                                "Relatório inclui plots de histogramas p(x), g(x) e pesos.",
                                "Testes em 2 problemas diferentes confirmam generalidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão da estimativa (erro relativo <5%).",
                                "Eficiência computacional (ganho de variância >50x).",
                                "Correta implementação de pelo menos 2 heurísticas.",
                                "Justificativa clara da escolha de g(x).",
                                "Análise de convergência e sensibilidade.",
                                "Código limpo, comentado e reproduzível.",
                                "Compreensão teórica demonstrada em explicações."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Métodos de Monte Carlo e redução de variância.",
                                "Programação: Implementação numérica em Python/NumPy/SciPy.",
                                "Probabilidade: Cadeias de Markov e distribuições em sistemas de filas.",
                                "Otimização: Minimização de divergência KL e gradientes.",
                                "Ciência de Dados: Análise de variância e validação de simulações."
                              ],
                              "realWorldApplication": "Em engenharia de telecomunicações para estimar perda de pacotes raros em redes; em finanças para Value-at-Risk (VaR) de crashes extremos; em confiabilidade de sistemas para probabilidade de falhas catastróficas em power grids discretos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.5.1.3"
                            ]
                          },
                          {
                            "id": "10.1.7.5.2.3",
                            "name": "Calcular variância ótima teórica",
                            "description": "Derivar a distribuição g*(x) = h(x)p(x)/∫h(u)p(u)du que torna a variância zero, e discutir sua impraticabilidade prática.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Amostragem por Importância",
                                  "subSteps": [
                                    "Recordar a estimativa de Monte Carlo padrão: E[h(X)] ≈ (1/N) Σ h(X_i) onde X_i ~ p(x).",
                                    "Entender a mudança para amostragem por importância: amostrar de g(x) e usar pesos w(x) = p(x)/g(x), estimativa μ̂ = (1/N) Σ h(X_i) w(X_i).",
                                    "Derivar a variância da estimativa: Var(μ̂) = (1/N) Var[h(X) p(X)/g(X)] onde X ~ g(x).",
                                    "Discutir objetivo: minimizar Var(μ̂) escolhendo g(x) adequadamente.",
                                    "Resolver exercícios simples para fixar notação."
                                  ],
                                  "verification": "Capaz de escrever a fórmula exata da variância da estimativa de importância.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de aula sobre MC",
                                    "Calculadora ou papel para anotações"
                                  ],
                                  "tips": "Use notação consistente: p para densidade original, g para importância, h para integrando.",
                                  "learningObjective": "Compreender a estrutura matemática da amostragem por importância e sua variância.",
                                  "commonMistakes": [
                                    "Confundir p(x) com g(x) nos pesos",
                                    "Esquecer o fator 1/N na variância"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Expressar a Variância como Função de g(x)",
                                  "subSteps": [
                                    "Escrever Var[h(X) p(X)/g(X)] = E[(h p / g)^2] - [E(h p / g)]^2, com X ~ g.",
                                    "Simplificar: como E[h p / g] = ∫ h p = μ (constante), focar em minimizar E[(h p / g)^2].",
                                    "Mostrar que E[(h p / g)^2] = ∫ (h^2 p^2 / g) dx.",
                                    "Identificar que para minimizar ∫ f(x)/g(x) dx com g densidade, usar Cauchy-Schwarz ou Lagrange.",
                                    "Praticar com exemplo numérico simples."
                                  ],
                                  "verification": "Derivar corretamente a expressão da variância em termos de g(x).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Lápis e papel",
                                    "Software como Python/Jupyter para simular variâncias"
                                  ],
                                  "tips": "Pense em g(x) como densidade que concentra massa onde h p é grande.",
                                  "learningObjective": "Expressar matematicamente a dependência da variância na escolha de g.",
                                  "commonMistakes": [
                                    "Esquecer que X ~ g na expectativa",
                                    "Confundir E com integral sobre p"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a Distribuição Ótima g*(x)",
                                  "subSteps": [
                                    "Aplicar desigualdade de Cauchy-Schwarz: [∫ h p]^2 ≤ ∫ (h^2 p^2 / g) ∫ g, igualdade quando g ∝ |h| p.",
                                    "Assumir h ≥ 0 para simplicidade: g*(x) = h(x) p(x) / ∫ h(u) p(u) du.",
                                    "Verificar que ∫ g*(x) dx = 1.",
                                    "Calcular E[h p / g*] = μ.",
                                    "Derivar explicitamente Var[h p / g*] = 0."
                                  ],
                                  "verification": "Escrever a fórmula exata de g*(x) e provar que variância é zero.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro de texto MC (ex: Robert & Casella)",
                                    "Blackboard ou quadro branco"
                                  ],
                                  "tips": "Normalização é chave: denominador garante que g* seja densidade.",
                                  "learningObjective": "Derivar analiticamente a g* que anula a variância.",
                                  "commonMistakes": [
                                    "Esquecer normalização ∫ h p",
                                    "Assumir h negativo sem módulo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir Impraticabilidade Prática de g*(x)",
                                  "subSteps": [
                                    "Explicar problema: para usar g*, precisamos conhecer ∫ h p du, que é o que queremos estimar!",
                                    "Discutir ciclos viciosos em aplicações reais (ex: finanças, física).",
                                    "Comparar com alternativas: g aproximada por momentos, cross-entropy.",
                                    "Simular numericamente: mostrar variância zero teórica vs. prática.",
                                    "Concluir limitações e quando aproximar."
                                  ],
                                  "verification": "Explicar em palavras por que g* não é usável na prática.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Exemplos de código Python para simulação",
                                    "Artigos sobre IS ótima"
                                  ],
                                  "tips": "Sempre volte ao objetivo: estimar μ sem conhecê-lo.",
                                  "learningObjective": "Analisar limitações teóricas vs. prática em MC.",
                                  "commonMistakes": [
                                    "Ignorar dependência circular",
                                    "Subestimar custo computacional da normalização"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar e Verificar Conceitos",
                                  "subSteps": [
                                    "Escolher exemplo: estimar ∫_0^1 x^2 e^{-x} dx.",
                                    "Calcular g* analiticamente.",
                                    "Simular amostragem com g* e medir variância ≈0.",
                                    "Comparar com amostragem uniforme.",
                                    "Documentar insights sobre impraticabilidade."
                                  ],
                                  "verification": "Implementar simulação que demonstra variância zero com g*.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Use seeds para reprodutibilidade nas simulações.",
                                  "learningObjective": "Consolidar teoria com prática computacional.",
                                  "commonMistakes": [
                                    "Erros numéricos em integrais",
                                    "Amostras insuficientes N"
                                  ]
                                }
                              ],
                              "practicalExample": "Estimar a integral μ = ∫_0^∞ x e^{-x^2/2} / √(2π) dx (expectativa de |X| para normal padrão). A g*(x) = x e^{-x^2/2} / ∫ u e^{-u^2/2} du leva a variância zero, mas requer conhecer a integral no denominador.",
                              "finalVerifications": [
                                "Deriva corretamente g*(x) = h(x)p(x)/∫h(u)p(u)du.",
                                "Prova que Var[h p / g*] = 0.",
                                "Explica o problema circular da normalização.",
                                "Simula numericamente variância zero com g* conhecida.",
                                "Discute 2-3 alternativas práticas para g.",
                                "Compara variâncias em exemplo concreto."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de g* (fórmula e normalização).",
                                "Correção na prova de variância zero.",
                                "Profundidade na discussão de impraticabilidade.",
                                "Qualidade da simulação prática (N grande, reprodutível).",
                                "Clareza em conexões com teoria MC geral.",
                                "Criatividade em exemplos e alternativas."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Otimização de estimadores e variância.",
                                "Probabilidade: Densidades e expectativas condicionais.",
                                "Computação: Implementação em Python/R para simulações MC.",
                                "Otimização: Minimização via Cauchy-Schwarz.",
                                "Física: Aplicações em simulações de partículas."
                              ],
                              "realWorldApplication": "Em finanças, otimizar simulações Monte Carlo para precificação de opções raras, onde g* idealiza reduções de variância extremas, guiando heurísticas práticas como minimização de KL-divergência."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.5.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.5.3",
                        "name": "Cálculo de Pesos e Implementação",
                        "description": "Domina o cálculo dos pesos w_i = p(X_i)/g(X_i) e a implementação prática em algoritmos de simulação para estimar integrais ou expectativas.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.5.3.1",
                            "name": "Implementar algoritmo básico",
                            "description": "Escrever pseudocódigo para gerar amostras de g(x), calcular pesos w_i = p(X_i)/g(X_i) e estimar θ ≈ (1/n) Σ h(X_i) w_i.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir as funções densidade p(x), proposta g(x) e função h(x)",
                                  "subSteps": [
                                    "Identifique o problema: determine θ = E_p[h(X)] que deseja estimar.",
                                    "Especifique a densidade alvo p(x), garantindo que seja normalizada (∫ p(x) dx = 1).",
                                    "Escolha uma densidade proposta g(x) suportada onde p(x) > 0, preferencialmente sobrepondo-se bem a h(x)p(x).",
                                    "Defina a função h(x) como o integrando ou indicador relevante para θ.",
                                    "Verifique se g(x) > 0 onde p(x)h(x) ≠ 0 para evitar divisão por zero."
                                  ],
                                  "verification": "Funções p, g e h estão claramente definidas com exemplos numéricos ou fórmulas explícitas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta ou editor de texto; documentação de distribuições probabilísticas.",
                                  "tips": "Escolha g(x) próxima de p(x)h(x)/θ para minimizar variância.",
                                  "learningObjective": "Compreender os componentes fundamentais do importance sampling.",
                                  "commonMistakes": "Escolher g(x) com suporte incompatível com p(x), levando a pesos indefinidos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escrever pseudocódigo para geração de amostras X_i de g(x)",
                                  "subSteps": [
                                    "Inicialize um loop para gerar n amostras independentes.",
                                    "Para cada i de 1 a n: gere X_i ~ g(x) usando métodos apropriados (ex: inversa CDF, rejeição).",
                                    "Armazene as amostras em uma lista ou array X[1..n].",
                                    "Inclua um parâmetro n configurável (ex: n=1000).",
                                    "Adicione comentários explicando o método de amostragem usado."
                                  ],
                                  "verification": "Pseudocódigo gera corretamente n amostras de g(x), testável com distribuições simples como uniforme.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de pseudocódigo ou Jupyter Notebook para prototipagem.",
                                  "tips": "Use geradores aleatórios built-in se implementando em código real.",
                                  "learningObjective": "Dominar a geração de amostras de distribuições propostas.",
                                  "commonMistakes": "Gerar amostras dependentes ou não independentes, violando i.i.d."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar cálculo dos pesos w_i = p(X_i)/g(X_i)",
                                  "subSteps": [
                                    "No pseudocódigo, após gerar X_i, calcule p(X_i) para cada amostra.",
                                    "Calcule g(X_i) para a mesma amostra.",
                                    "Compute w_i = p(X_i) / g(X_i), lidando com casos de g(X_i)=0 (raros se suporte correto).",
                                    "Armazene w_i em array W[1..n].",
                                    "Normalize pesos se necessário para estabilidade numérica (opcional)."
                                  ],
                                  "verification": "Pesos calculados coincidem com valores teóricos para amostras conhecidas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Calculadora ou software para validação numérica.",
                                  "tips": "Logaritme pesos para evitar underflow em probabilidades pequenas.",
                                  "learningObjective": "Calcular pesos de importância corretamente para reponderação.",
                                  "commonMistakes": "Inverter p e g, ou esquecer normalização de densidades."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular a estimativa θ ≈ (1/n) Σ h(X_i) w_i e finalizar pseudocódigo",
                                  "subSteps": [
                                    "Para cada i, compute h(X_i) * w_i.",
                                    "Some todos os termos: soma = Σ h(X_i) w_i.",
                                    "Calcule θ_est = soma / n.",
                                    "Retorne θ_est e opcionalmente variância estimada (Σ w_i^2 (h(X_i)-θ_est)^2 / n^2).",
                                    "Estruture o pseudocódigo completo com função principal."
                                  ],
                                  "verification": "Estimativa converge para valor verdadeiro em simulações repetidas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Simulador Monte Carlo simples para teste.",
                                  "tips": "Monitore variância dos pesos; se alta, ajuste g(x).",
                                  "learningObjective": "Finalizar o estimador unbiased do importance sampling.",
                                  "commonMistakes": "Usar média não ponderada ou somar sem dividir por n."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e validar o pseudocódigo com exemplo simples",
                                  "subSteps": [
                                    "Escolha um problema conhecido (ex: integral de exp(-x)/ (1+x^2)).",
                                    "Execute pseudocódigo manualmente para n=10.",
                                    "Compare com valor exato ou simulação direta.",
                                    "Ajuste se variância alta.",
                                    "Documente resultados no pseudocódigo como comentários."
                                  ],
                                  "verification": "Teste passa com erro < 10% do valor verdadeiro.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python/MATLAB para execução rápida do pseudocódigo.",
                                  "tips": "Comece com n pequeno para depuração.",
                                  "learningObjective": "Validar implementação prática do algoritmo.",
                                  "commonMistakes": "Ignorar normalização, levando a estimativas enviesadas."
                                }
                              ],
                              "practicalExample": "Estime θ = ∫_0^1 exp(-x) / (1 + x^2) dx usando g(x) uniforme em [0,1], p(x) = exp(-x)/∫exp(-t)dt ≈ 0.632, h(x)=1/(1+x^2). Gere 1000 X_i ~ U[0,1], w_i = p(X_i)/1, θ ≈ média h(X_i)w_i.",
                              "finalVerifications": [
                                "Pseudocódigo completo cobre geração, pesos e estimativa sem erros lógicos.",
                                "Pesos w_i são positivos e somam aproximadamente n (para g normalizada).",
                                "Estimativa converge com aumento de n em testes simulados.",
                                "Comentários explicam cada linha e assumições.",
                                "Código lida com casos edge (g(X_i)=0).",
                                "Variância estimada é finita e razoável."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: pesos e estimador corretos (30%).",
                                "Estrutura do pseudocódigo: claro, modular e comentado (25%).",
                                "Validação: testes com exemplo numérico incluídos (20%).",
                                "Eficiência: menção a redução de variância vs. Monte Carlo cru (15%).",
                                "Completude: todos componentes (p,g,h,n) parametrizados (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Inferência bayesiana e métodos MCMC.",
                                "Programação: Algoritmos numéricos e simulação estocástica.",
                                "Física Computacional: Simulações de partículas e transporte.",
                                "Finanças: Precificação de derivativos via Monte Carlo."
                              ],
                              "realWorldApplication": "Em finanças, importance sampling reduz variância ao precificar opções raras (ex: 'black swans'), permitindo simulações eficientes de caminhos brownianos raros com pesos para eventos extremos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.5.2.1"
                            ]
                          },
                          {
                            "id": "10.1.7.5.3.2",
                            "name": "Normalizar pesos para estabilidade",
                            "description": "Aplicar normalização de pesos (peso efetivo) para evitar underflow/overflow e estimar variância do estimador.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender e Calcular Pesos Não Normalizados em Amostragem por Importância",
                                  "subSteps": [
                                    "Revise as densidades alvo π(x) e de proposta q(x) no contexto da simulação.",
                                    "Gere N amostras x_i ~ q(x).",
                                    "Calcule pesos brutos w_i = π(x_i) / q(x_i) para cada i=1 a N.",
                                    "Registre os valores mínimos e máximos dos w_i para análise inicial."
                                  ],
                                  "verification": "Verifique se todos w_i são positivos e se a soma inicial reflete a escala esperada.",
                                  "estimatedTime": "45 minutes",
                                  "materials": "Python com NumPy e SciPy; caderno para anotações; dataset de amostras simuladas.",
                                  "tips": "Use log-densidades para evitar underflow inicial: log_w_i = log_π(x_i) - log_q(x_i).",
                                  "learningObjective": "Dominar o cálculo fundamental de pesos em IS e reconhecer sua variabilidade inerente.",
                                  "commonMistakes": [
                                    "Confundir π e q nas fórmulas.",
                                    "Gerar amostras da distribuição errada.",
                                    "Ignorar zeros em q(x_i), causando divisão por zero."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Detectar Problemas de Underflow e Overflow nos Pesos",
                                  "subSteps": [
                                    "Analise o range dinâmico dos w_i (min, max, std).",
                                    "Teste computacionalmente: simule soma de w_i e observe NaN ou inf.",
                                    "Calcule log-sum-exp para soma estável: log(sum w) ≈ logsumexp(log_w).",
                                    "Identifique se variância alta (>10^10) indica instabilidade."
                                  ],
                                  "verification": "Confirme detecção de overflow/underflow ao comparar soma direta vs. log-sum-exp.",
                                  "estimatedTime": "30 minutes",
                                  "materials": "Código Python com NumPy; gráficos de histograma dos log_w_i.",
                                  "tips": "Sempre trabalhe em escala logarítmica para diagnósticos iniciais.",
                                  "learningObjective": "Identificar numericamente instabilidades em estimadores de Monte Carlo.",
                                  "commonMistakes": [
                                    "Usar soma direta em vez de log-sum para grandes discrepâncias.",
                                    "Ignorar warnings de overflow em linguagens como Python.",
                                    "Não plotar distribuições de pesos para visualização."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Normalização de Pesos para Estabilidade",
                                  "subSteps": [
                                    "Calcule o normalizador S = sum w_i usando método estável (log-sum-exp).",
                                    "Defina pesos normalizados w_i' = w_i / S.",
                                    "Verifique que sum w_i' = 1 (probabilidades efetivas).",
                                    "Repita para sub-blocos de amostras se N for muito grande.",
                                    "Implemente resample com pesos normalizados se necessário."
                                  ],
                                  "verification": "Some w_i' e confirme igual a 1.0 dentro de precisão numérica (1e-10).",
                                  "estimatedTime": "40 minutes",
                                  "materials": "Funções NumPy: np.logsumexp, np.exp; script de simulação IS.",
                                  "tips": "Normalização incremental (a cada 1000 amostras) previne acúmulo de erro.",
                                  "learningObjective": "Implementar normalização que preserva o estimador não viesado.",
                                  "commonMistakes": [
                                    "Normalizar por max(w) em vez de sum(w), alterando o estimador.",
                                    "Esquecer de ajustar o estimador final: theta = sum(w_i' * f(x_i)).",
                                    "Perder precisão ao exp(log_w) sem clipping."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estimar Variância do Estimador Usando Peso Efetivo (ESS)",
                                  "subSteps": [
                                    "Calcule ESS = (sum w_i')^2 / sum (w_i'^2).",
                                    "Estime variância: Var(theta) ≈ (1/N) * sum w_i' * (f(x_i) - theta)^2 / (ESS/N).",
                                    "Compare ESS com N: se ESS/N < 0.3, reavalie q(x).",
                                    "Gere intervalos de confiança baseados em ESS efetivo.",
                                    "Documente melhora na estabilidade pós-normalização."
                                  ],
                                  "verification": "ESS entre 1 e N, com valores próximos a N indicando boa amostragem.",
                                  "estimatedTime": "35 minutes",
                                  "materials": "Código para ESS; ferramentas de plotagem como Matplotlib.",
                                  "tips": "ESS é uma métrica de qualidade da IS: mire >50% de N.",
                                  "learningObjective": "Quantificar e reduzir variância efetiva em simulações MC.",
                                  "commonMistakes": [
                                    "Usar sum w_i^2 sem normalizar primeiro.",
                                    "Interpretar ESS > N (impossível).",
                                    "Não ajustar variância para ESS baixo."
                                  ]
                                }
                              ],
                              "practicalExample": "Para estimar I = ∫ exp(-x^2/2) dx de 2 a ∞ (cauda normal), use q(x) ~ N(3,1). Gere 10^4 x_i, w_i = π(x_i)/q(x_i), normalize w_i' = w_i / sum w_i, compute theta = sum w_i' * indicator(x_i>2). Sem normalização, overflow ocorre; pós, ESS≈0.6N e Var estimada cai 40%.",
                              "finalVerifications": [
                                "Pesos normalizados somam exatamente 1.",
                                "Nenhum underflow/overflow detectado nos logs.",
                                "ESS > 30% de N amostras.",
                                "Variância estimada é finita e razoável (<10x variância crua).",
                                "Estimador theta converge monotonicamente com N.",
                                "Código roda sem warnings numéricos."
                              ],
                              "assessmentCriteria": [
                                "Precisão do cálculo de pesos e normalização (erro <1e-8).",
                                "Correta implementação de log-sum-exp para estabilidade.",
                                "Interpretação adequada de ESS e impacto na variância.",
                                "Eficiência computacional: tempo O(N) sem loops desnecessários.",
                                "Capacidade de debugar casos extremos (q mal escolhida).",
                                "Documentação clara do processo e resultados."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Controle de variância em estimadores MC.",
                                "Programação Numérica: Estabilidade em floating-point.",
                                "Física Computacional: Simulações de partículas raras.",
                                "Machine Learning: Weighted sampling em variational inference.",
                                "Finanças Quantitativas: Simulação de riscos extremos."
                              ],
                              "realWorldApplication": "Em finanças, normalizar pesos em Importance Sampling para simular 'black swan' events em Value-at-Risk (VaR), evitando crashes numéricos em caminhos de mercado extremos e fornecendo variâncias confiáveis para portfólios bilionários."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.5.2.2"
                            ]
                          },
                          {
                            "id": "10.1.7.5.3.3",
                            "name": "Validar em exemplo simples",
                            "description": "Resolver um exemplo numérico em simulação discreta, como estimar probabilidade de falha rara, comparando variância com Monte Carlo padrão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o problema e calcular referência analítica",
                                  "subSteps": [
                                    "Escolha um exemplo simples: estime P(X ≥ 3) onde X ~ Binomial(n=100, p=0.01), uma probabilidade de 'falha rara' (valor esperado E[X]=1).",
                                    "Calcule o valor exato usando funções de Poisson binomial ou aproximação Poisson (λ=1), P(X≥3) ≈ 0.0803.",
                                    "Defina o estimador para Monte Carlo: média de I(X≥3) sobre N amostras.",
                                    "Explique conceitualmente a Amostragem por Importância (IS): amostrar de Q em vez de P, peso w = dP/dQ.",
                                    "Planeje a distribuição alternativa Q: Binomial(n=100, q=0.04) para shiftar massa para o tail."
                                  ],
                                  "verification": "Confirme o valor analítico aproximado e anote os parâmetros de P e Q em um notebook.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python com NumPy e SciPy",
                                    "Notebook Jupyter",
                                    "Documentação de funções binomiais"
                                  ],
                                  "tips": "Use scipy.stats.binom.sf(k-1, n, p) para P(X≥k); teste com n pequeno para validar.",
                                  "learningObjective": "Compreender o problema de eventos raros e preparar distribuições para IS.",
                                  "commonMistakes": [
                                    "Confundir P(X≥3) com P(X>3)",
                                    "Escolher q muito extrema em Q, causando pesos instáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar e executar Monte Carlo padrão",
                                  "subSteps": [
                                    "Gere N=10^5 amostras de X ~ Binomial(100, 0.01) usando np.random.binomial.",
                                    "Calcule indicadores I = (X >= 3), estimador θ_MC = média(I), variância Var(θ_MC) ≈ θ(1-θ)/N.",
                                    "Execute múltiplas runs (ex: 100) para estimar variância empírica da média.",
                                    "Plote histograma das estimativas para visualizar variância.",
                                    "Registre tempo de execução e precisão (erro padrão)."
                                  ],
                                  "verification": "θ_MC ≈ 0.08 com erro padrão ~0.001; variância empírica anotada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python: NumPy, Matplotlib",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Use np.mean e np.var; vetorize para eficiência (evite loops).",
                                  "learningObjective": "Implementar MC básico e quantificar sua variância em eventos raros.",
                                  "commonMistakes": [
                                    "N muito pequeno levando a alta variância",
                                    "Não subtrair 1 no sf para P(X≥3)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Amostragem por Importância com cálculo de pesos",
                                  "subSteps": [
                                    "Gere N=10^5 amostras Y ~ Binomial(100, q=0.04).",
                                    "Para cada Y_i, calcule peso w_i = [binom.pmf(Y_i,100,0.01) / binom.pmf(Y_i,100,0.04)] * I(Y_i >=3).",
                                    "Estimador θ_IS = média(w), variância Var(θ_IS) ≈ Var(w)/N.",
                                    "Ajuste q se necessário para |E[log w]| pequeno (verificar estabilidade).",
                                    "Execute runs múltiplas e compare variâncias preliminarmente."
                                  ],
                                  "verification": "Pesos w_i entre 0 e 10 (não explosivos); θ_IS ≈ θ_MC.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "SciPy: stats.binom.pmf",
                                    "NumPy para vetores"
                                  ],
                                  "tips": "Use log-pmf para evitar underflow: w = exp(log_p_pmf - log_p_qmf) * I.",
                                  "learningObjective": "Dominar cálculo de pesos em IS e garantir estabilidade.",
                                  "commonMistakes": [
                                    "Underflow/overflow em pmf",
                                    "Esquecer I no peso",
                                    "q muito próximo de p sem ganho"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar variâncias e validar redução",
                                  "subSteps": [
                                    "Calcule razão de variâncias Var_MC / Var_IS para múltiplas runs.",
                                    "Plote distribuições de θ_MC vs θ_IS (boxplots).",
                                    "Confirme redução de variância >2x e tempo similar.",
                                    "Analise sensibilidade a N e q.",
                                    "Documente conclusões: IS reduz variância em tails raros."
                                  ],
                                  "verification": "Razão de variâncias ≥2; plots mostram menor dispersão em IS.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Matplotlib/Seaborn para plots",
                                    "Pandas para tabelas"
                                  ],
                                  "tips": "Use np.var(estimators) sobre runs; bootstrap para ICs.",
                                  "learningObjective": "Validar eficácia de IS comparando métricas quantitativas.",
                                  "commonMistakes": [
                                    "Comparar variância bruta em vez de do estimador",
                                    "Ignorar normalização dos pesos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema com 100 componentes independentes, cada um falha com probabilidade 0.01. Estime P(≥3 falhas) usando 10^5 simulações: MC padrão dá estimativa ~0.080 com var~10^-6; IS com q=0.04 reduz var para ~10^-7, acelerando convergência 3x.",
                              "finalVerifications": [
                                "Estimativa converge para ~0.0803 em ambos métodos.",
                                "Variância IS < 50% da MC.",
                                "Pesos estáveis (95% entre 0.1 e 10).",
                                "Tempo de IS similar ou menor que MC.",
                                "Plots mostram redução visual de dispersão.",
                                "Explicação correta de por quê IS funciona aqui."
                              ],
                              "assessmentCriteria": [
                                "Precisão da implementação de pmf e pesos (sem erros numéricos).",
                                "Correta quantificação e comparação de variâncias.",
                                "Escolha adequada de Q levando a redução efetiva.",
                                "Análise de estabilidade dos pesos.",
                                "Visualizações claras e conclusões fundamentadas.",
                                "Tempo total de execução eficiente."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Inferência em distribuições de cauda.",
                                "Programação: Vetorização NumPy/SciPy para simulações eficientes.",
                                "Engenharia de Confiabilidade: Análise de falhas raras em sistemas.",
                                "Finanças: Value-at-Risk via simulações de risco extremo.",
                                "Física Computacional: Redução de variância em Monte Carlo para partículas."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, estimar probabilidade de falha rara em sistemas redundantes (ex: NASA usa IS para missões); em finanças, calcular riscos de cauda em portfólios para conformidade regulatória (Basel III)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.5.1.1",
                              "10.1.7.5.2.3"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ],
            "totalSkills": 346
          }
        ],
        "totalSkills": 346,
        "percentage": 0
      }
    ]
  }
}